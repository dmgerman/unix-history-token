begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: channels.c,v 1.357 2017/02/01 02:59:09 dtucker Exp $ */
end_comment

begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  * This file contains functions for generic socket connection forwarding.  * There is also code for initiating connection forwarding for X11 connections,  * arbitrary tcp/ip connections, and the authentication agent connection.  *  * As far as I am concerned, the code I have written for this software  * can be used freely for any purpose.  Any derived versions of this  * software must be clearly marked as such, and if the derived work is  * incompatible with the protocol description in the RFC file, it must be  * called by a name other than "ssh" or "Secure Shell".  *  * SSH2 support added by Markus Friedl.  * Copyright (c) 1999, 2000, 2001, 2002 Markus Friedl.  All rights reserved.  * Copyright (c) 1999 Dug Song.  All rights reserved.  * Copyright (c) 1999 Theo de Raadt.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDINT_H
end_ifdef

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"openbsd-compat/sys-queue.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"ssh1.h"
end_include

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|"ssherr.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"channels.h"
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|"canohost.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"authfd.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_comment
comment|/* -- channel core */
end_comment

begin_comment
comment|/*  * Pointer to an array containing all allocated channels.  The array is  * dynamically extended as needed.  */
end_comment

begin_decl_stmt
specifier|static
name|Channel
modifier|*
modifier|*
name|channels
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Size of the channel array.  All slots of the array must always be  * initialized (at least the type field); unused slots set to NULL  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|channels_alloc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Maximum file descriptor value used in any of the channels.  This is  * updated in channel_new.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|channel_max_fd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -- tcp forwarding */
end_comment

begin_comment
comment|/*  * Data structure for storing which hosts are permitted for forward requests.  * The local sides of any remote forwards are stored in this array to prevent  * a corrupt remote server from accessing arbitrary TCP/IP ports on our local  * network (which might be behind a firewall).  */
end_comment

begin_comment
comment|/* XXX: streamlocal wants a path instead of host:port */
end_comment

begin_comment
comment|/*      Overload host_to_connect; we could just make this match Forward */
end_comment

begin_comment
comment|/*	XXX - can we use listen_host instead of listen_path? */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|host_to_connect
decl_stmt|;
comment|/* Connect to 'host'. */
name|int
name|port_to_connect
decl_stmt|;
comment|/* Connect to 'port'. */
name|char
modifier|*
name|listen_host
decl_stmt|;
comment|/* Remote side should listen address. */
name|char
modifier|*
name|listen_path
decl_stmt|;
comment|/* Remote side should listen path. */
name|int
name|listen_port
decl_stmt|;
comment|/* Remote side should listen port. */
name|Channel
modifier|*
name|downstream
decl_stmt|;
comment|/* Downstream mux*/
block|}
name|ForwardPermission
typedef|;
end_typedef

begin_comment
comment|/* List of all permitted host/port pairs to connect by the user. */
end_comment

begin_decl_stmt
specifier|static
name|ForwardPermission
modifier|*
name|permitted_opens
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of all permitted host/port pairs to connect by the admin. */
end_comment

begin_decl_stmt
specifier|static
name|ForwardPermission
modifier|*
name|permitted_adm_opens
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of permitted host/port pairs in the array permitted by the user. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_permitted_opens
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of permitted host/port pair in the array permitted by the admin. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_adm_permitted_opens
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* special-case port number meaning allow any port */
end_comment

begin_define
define|#
directive|define
name|FWD_PERMIT_ANY_PORT
value|0
end_define

begin_comment
comment|/* special-case wildcard meaning allow any host */
end_comment

begin_define
define|#
directive|define
name|FWD_PERMIT_ANY_HOST
value|"*"
end_define

begin_comment
comment|/*  * If this is true, all opens are permitted.  This is the case on the server  * on which we have to trust the client anyway, and the user could do  * anything after logging in anyway.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|all_opens_permitted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -- X11 forwarding */
end_comment

begin_comment
comment|/* Maximum number of fake X11 displays to try. */
end_comment

begin_define
define|#
directive|define
name|MAX_DISPLAYS
value|1000
end_define

begin_comment
comment|/* Saved X11 local (client) display. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|x11_saved_display
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Saved X11 authentication protocol name. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|x11_saved_proto
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Saved X11 authentication data.  This is the real data. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|x11_saved_data
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|x11_saved_data_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Deadline after which all X11 connections are refused */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|x11_refuse_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Fake X11 authentication data.  This is what the server will be sending us;  * we should replace any occurrences of this by the real data.  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|x11_fake_data
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|x11_fake_data_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -- agent forwarding */
end_comment

begin_define
define|#
directive|define
name|NUM_SOCKS
value|10
end_define

begin_comment
comment|/* AF_UNSPEC or AF_INET or AF_INET6 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|IPv4or6
init|=
name|AF_UNSPEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* helper */
end_comment

begin_function_decl
specifier|static
name|void
name|port_open_helper
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|rtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|channel_rfwd_bind_host
parameter_list|(
specifier|const
name|char
modifier|*
name|listen_host
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* non-blocking connect helpers */
end_comment

begin_function_decl
specifier|static
name|int
name|connect_next
parameter_list|(
name|struct
name|channel_connect
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|channel_connect_ctx_free
parameter_list|(
name|struct
name|channel_connect
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* -- channel core */
end_comment

begin_function
name|Channel
modifier|*
name|channel_by_id
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
operator|||
operator|(
name|u_int
operator|)
name|id
operator|>=
name|channels_alloc
condition|)
block|{
name|logit
argument_list|(
literal|"channel_by_id: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|=
name|channels
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|logit
argument_list|(
literal|"channel_by_id: %d: bad id: channel free"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
name|channel_by_remote_id
parameter_list|(
name|int
name|remote_id
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|remote_id
operator|==
name|remote_id
condition|)
return|return
name|c
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the channel if it is allowed to receive protocol messages.  * Private channels, like listening sockets, may not receive messages.  */
end_comment

begin_function
name|Channel
modifier|*
name|channel_lookup
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|channel_by_id
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
switch|switch
condition|(
name|c
operator|->
name|type
condition|)
block|{
case|case
name|SSH_CHANNEL_X11_OPEN
case|:
case|case
name|SSH_CHANNEL_LARVAL
case|:
case|case
name|SSH_CHANNEL_CONNECTING
case|:
case|case
name|SSH_CHANNEL_DYNAMIC
case|:
case|case
name|SSH_CHANNEL_OPENING
case|:
case|case
name|SSH_CHANNEL_OPEN
case|:
case|case
name|SSH_CHANNEL_INPUT_DRAINING
case|:
case|case
name|SSH_CHANNEL_OUTPUT_DRAINING
case|:
case|case
name|SSH_CHANNEL_ABANDONED
case|:
case|case
name|SSH_CHANNEL_MUX_PROXY
case|:
return|return
operator|(
name|c
operator|)
return|;
block|}
name|logit
argument_list|(
literal|"Non-public channel %d, type %d."
argument_list|,
name|id
argument_list|,
name|c
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register filedescriptors for a channel, used when allocating a channel or  * when the channel consumer/producer is ready, e.g. shell exec'd  */
end_comment

begin_function
specifier|static
name|void
name|channel_register_fds
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|int
name|rfd
parameter_list|,
name|int
name|wfd
parameter_list|,
name|int
name|efd
parameter_list|,
name|int
name|extusage
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|int
name|is_tty
parameter_list|)
block|{
comment|/* Update the maximum file descriptor value. */
name|channel_max_fd
operator|=
name|MAXIMUM
argument_list|(
name|channel_max_fd
argument_list|,
name|rfd
argument_list|)
expr_stmt|;
name|channel_max_fd
operator|=
name|MAXIMUM
argument_list|(
name|channel_max_fd
argument_list|,
name|wfd
argument_list|)
expr_stmt|;
name|channel_max_fd
operator|=
name|MAXIMUM
argument_list|(
name|channel_max_fd
argument_list|,
name|efd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfd
operator|!=
operator|-
literal|1
condition|)
name|fcntl
argument_list|(
name|rfd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|wfd
operator|!=
operator|-
literal|1
operator|&&
name|wfd
operator|!=
name|rfd
condition|)
name|fcntl
argument_list|(
name|wfd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|efd
operator|!=
operator|-
literal|1
operator|&&
name|efd
operator|!=
name|rfd
operator|&&
name|efd
operator|!=
name|wfd
condition|)
name|fcntl
argument_list|(
name|efd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
name|c
operator|->
name|rfd
operator|=
name|rfd
expr_stmt|;
name|c
operator|->
name|wfd
operator|=
name|wfd
expr_stmt|;
name|c
operator|->
name|sock
operator|=
operator|(
name|rfd
operator|==
name|wfd
operator|)
condition|?
name|rfd
else|:
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|efd
operator|=
name|efd
expr_stmt|;
name|c
operator|->
name|extended_usage
operator|=
name|extusage
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|isatty
operator|=
name|is_tty
operator|)
operator|!=
literal|0
condition|)
name|debug2
argument_list|(
literal|"channel %d: rfd %d isatty"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|rfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_AIX
comment|/* XXX: Later AIX versions can't push as much data to tty */
name|c
operator|->
name|wfd_isatty
operator|=
name|is_tty
operator|||
name|isatty
argument_list|(
name|c
operator|->
name|wfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* enable nonblocking mode */
if|if
condition|(
name|nonblock
condition|)
block|{
if|if
condition|(
name|rfd
operator|!=
operator|-
literal|1
condition|)
name|set_nonblock
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|wfd
operator|!=
operator|-
literal|1
condition|)
name|set_nonblock
argument_list|(
name|wfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|efd
operator|!=
operator|-
literal|1
condition|)
name|set_nonblock
argument_list|(
name|efd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a new channel object and set its type and socket. This will cause  * remote_name to be freed.  */
end_comment

begin_function
name|Channel
modifier|*
name|channel_new
parameter_list|(
name|char
modifier|*
name|ctype
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rfd
parameter_list|,
name|int
name|wfd
parameter_list|,
name|int
name|efd
parameter_list|,
name|u_int
name|window
parameter_list|,
name|u_int
name|maxpack
parameter_list|,
name|int
name|extusage
parameter_list|,
name|char
modifier|*
name|remote_name
parameter_list|,
name|int
name|nonblock
parameter_list|)
block|{
name|int
name|found
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
comment|/* Do initial allocation if this is the first call. */
if|if
condition|(
name|channels_alloc
operator|==
literal|0
condition|)
block|{
name|channels_alloc
operator|=
literal|10
expr_stmt|;
name|channels
operator|=
name|xcalloc
argument_list|(
name|channels_alloc
argument_list|,
sizeof|sizeof
argument_list|(
name|Channel
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
name|channels
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Try to find a free slot where to put the new channel. */
for|for
control|(
name|found
operator|=
operator|-
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* Found a free slot. */
name|found
operator|=
operator|(
name|int
operator|)
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
operator|<
literal|0
condition|)
block|{
comment|/* There are no free slots.  Take last+1 slot and expand the array.  */
name|found
operator|=
name|channels_alloc
expr_stmt|;
if|if
condition|(
name|channels_alloc
operator|>
literal|10000
condition|)
name|fatal
argument_list|(
literal|"channel_new: internal error: channels_alloc %d "
literal|"too big."
argument_list|,
name|channels_alloc
argument_list|)
expr_stmt|;
name|channels
operator|=
name|xreallocarray
argument_list|(
name|channels
argument_list|,
name|channels_alloc
operator|+
literal|10
argument_list|,
sizeof|sizeof
argument_list|(
name|Channel
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|channels_alloc
operator|+=
literal|10
expr_stmt|;
name|debug2
argument_list|(
literal|"channel: expanding %d"
argument_list|,
name|channels_alloc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|found
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
name|channels
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Initialize and return new channel. */
name|c
operator|=
name|channels
index|[
name|found
index|]
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Channel
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
expr_stmt|;
name|c
operator|->
name|path
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|listening_addr
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|listening_port
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|ostate
operator|=
name|CHAN_OUTPUT_OPEN
expr_stmt|;
name|c
operator|->
name|istate
operator|=
name|CHAN_INPUT_OPEN
expr_stmt|;
name|c
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|channel_register_fds
argument_list|(
name|c
argument_list|,
name|rfd
argument_list|,
name|wfd
argument_list|,
name|efd
argument_list|,
name|extusage
argument_list|,
name|nonblock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|notbefore
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|self
operator|=
name|found
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|c
operator|->
name|ctype
operator|=
name|ctype
expr_stmt|;
name|c
operator|->
name|local_window
operator|=
name|window
expr_stmt|;
name|c
operator|->
name|local_window_max
operator|=
name|window
expr_stmt|;
name|c
operator|->
name|local_consumed
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|local_maxpacket
operator|=
name|maxpack
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|remote_name
operator|=
name|xstrdup
argument_list|(
name|remote_name
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_window
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|remote_maxpacket
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|force_drain
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|single_connection
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|detach_user
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|detach_close
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|open_confirm
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|open_confirm_ctx
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|input_filter
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|output_filter
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|filter_ctx
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|filter_cleanup
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|ctl_chan
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|mux_rcb
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|mux_ctx
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|mux_pause
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|delayed
operator|=
literal|1
expr_stmt|;
comment|/* prevent call to channel_post handler */
name|TAILQ_INIT
argument_list|(
operator|&
name|c
operator|->
name|status_confirms
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"channel %d: new [%s]"
argument_list|,
name|found
argument_list|,
name|remote_name
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|channel_find_maxfd
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|int
name|max
init|=
literal|0
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
name|max
operator|=
name|MAXIMUM
argument_list|(
name|max
argument_list|,
name|c
operator|->
name|rfd
argument_list|)
expr_stmt|;
name|max
operator|=
name|MAXIMUM
argument_list|(
name|max
argument_list|,
name|c
operator|->
name|wfd
argument_list|)
expr_stmt|;
name|max
operator|=
name|MAXIMUM
argument_list|(
name|max
argument_list|,
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|max
return|;
block|}
end_function

begin_function
name|int
name|channel_close_fd
parameter_list|(
name|int
modifier|*
name|fdp
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|fd
init|=
operator|*
name|fdp
decl_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|*
name|fdp
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|channel_max_fd
condition|)
name|channel_max_fd
operator|=
name|channel_find_maxfd
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Close all channel fd/socket. */
end_comment

begin_function
specifier|static
name|void
name|channel_close_fds
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|)
block|{
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|sock
argument_list|)
expr_stmt|;
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|rfd
argument_list|)
expr_stmt|;
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|wfd
argument_list|)
expr_stmt|;
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the channel and close its fd/socket. */
end_comment

begin_function
name|void
name|channel_free
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|Channel
modifier|*
name|other
decl_stmt|;
name|struct
name|channel_confirm
modifier|*
name|cc
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|other
operator|=
name|channels
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|n
operator|++
expr_stmt|;
comment|/* detach from mux client and prepare for closing */
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_MUX_CLIENT
operator|&&
name|other
operator|->
name|type
operator|==
name|SSH_CHANNEL_MUX_PROXY
operator|&&
name|other
operator|->
name|mux_ctx
operator|==
name|c
condition|)
block|{
name|other
operator|->
name|mux_ctx
operator|=
name|NULL
expr_stmt|;
name|other
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
name|other
operator|->
name|istate
operator|=
name|CHAN_INPUT_CLOSED
expr_stmt|;
name|other
operator|->
name|ostate
operator|=
name|CHAN_OUTPUT_CLOSED
expr_stmt|;
block|}
block|}
block|}
name|debug
argument_list|(
literal|"channel %d: free: %s, nchannels %u"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|remote_name
condition|?
name|c
operator|->
name|remote_name
else|:
literal|"???"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* XXX more MUX cleanup: remove remote forwardings */
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_MUX_CLIENT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|u_int
operator|)
name|num_permitted_opens
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|downstream
operator|!=
name|c
condition|)
continue|continue;
comment|/* cancel on the server, since mux client is gone */
name|debug
argument_list|(
literal|"channel %d: cleanup remote forward for %s:%u"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_host
argument_list|,
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_port
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_GLOBAL_REQUEST
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"cancel-tcpip-forward"
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|channel_rfwd_bind_host
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_host
argument_list|)
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_port
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* unregister */
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_port
operator|=
literal|0
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|port_to_connect
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_host
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_host
operator|=
name|NULL
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_path
operator|=
name|NULL
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|downstream
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|s
operator|=
name|channel_open_message
argument_list|()
expr_stmt|;
name|debug3
argument_list|(
literal|"channel %d: status: %s"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|sock
operator|!=
operator|-
literal|1
condition|)
name|shutdown
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|SHUT_RDWR
argument_list|)
expr_stmt|;
name|channel_close_fds
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|remote_name
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_name
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|path
argument_list|)
expr_stmt|;
name|c
operator|->
name|path
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|listening_addr
argument_list|)
expr_stmt|;
name|c
operator|->
name|listening_addr
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|cc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|c
operator|->
name|status_confirms
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cc
operator|->
name|abandon_cb
operator|!=
name|NULL
condition|)
name|cc
operator|->
name|abandon_cb
argument_list|(
name|c
argument_list|,
name|cc
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|c
operator|->
name|status_confirms
argument_list|,
name|cc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|cc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cc
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|filter_cleanup
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|filter_ctx
operator|!=
name|NULL
condition|)
name|c
operator|->
name|filter_cleanup
argument_list|(
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|filter_ctx
argument_list|)
expr_stmt|;
name|channels
index|[
name|c
operator|->
name|self
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_free_all
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|channel_free
argument_list|(
name|channels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Closes the sockets/fds of all channels.  This is used to close extra file  * descriptors after a fork.  */
end_comment

begin_function
name|void
name|channel_close_all
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|channel_close_fds
argument_list|(
name|channels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop listening to channels.  */
end_comment

begin_function
name|void
name|channel_stop_listening
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|c
operator|->
name|type
condition|)
block|{
case|case
name|SSH_CHANNEL_AUTH_SOCKET
case|:
case|case
name|SSH_CHANNEL_PORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_RPORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_X11_LISTENER
case|:
case|case
name|SSH_CHANNEL_UNIX_LISTENER
case|:
case|case
name|SSH_CHANNEL_RUNIX_LISTENER
case|:
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|sock
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Returns true if no channel has too much buffered data, and false if one or  * more channel is overfull.  */
end_comment

begin_function
name|int
name|channel_not_very_much_buffered_data
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_OPEN
condition|)
block|{
if|#
directive|if
literal|0
block|if (!compat20&& 			    buffer_len(&c->input)> packet_get_maxsize()) { 				debug2("channel %d: big input buffer %d", 				    c->self, buffer_len(&c->input)); 				return 0; 			}
endif|#
directive|endif
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
name|packet_get_maxsize
argument_list|()
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: big output buffer %u> %u"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|,
name|packet_get_maxsize
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns true if any channel is still open. */
end_comment

begin_function
name|int
name|channel_still_open
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
continue|continue;
switch|switch
condition|(
name|c
operator|->
name|type
condition|)
block|{
case|case
name|SSH_CHANNEL_X11_LISTENER
case|:
case|case
name|SSH_CHANNEL_PORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_RPORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_MUX_LISTENER
case|:
case|case
name|SSH_CHANNEL_CLOSED
case|:
case|case
name|SSH_CHANNEL_AUTH_SOCKET
case|:
case|case
name|SSH_CHANNEL_DYNAMIC
case|:
case|case
name|SSH_CHANNEL_CONNECTING
case|:
case|case
name|SSH_CHANNEL_ZOMBIE
case|:
case|case
name|SSH_CHANNEL_ABANDONED
case|:
case|case
name|SSH_CHANNEL_UNIX_LISTENER
case|:
case|case
name|SSH_CHANNEL_RUNIX_LISTENER
case|:
continue|continue;
case|case
name|SSH_CHANNEL_LARVAL
case|:
if|if
condition|(
operator|!
name|compat20
condition|)
name|fatal
argument_list|(
literal|"cannot happen: SSH_CHANNEL_LARVAL"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|SSH_CHANNEL_OPENING
case|:
case|case
name|SSH_CHANNEL_OPEN
case|:
case|case
name|SSH_CHANNEL_X11_OPEN
case|:
case|case
name|SSH_CHANNEL_MUX_CLIENT
case|:
case|case
name|SSH_CHANNEL_MUX_PROXY
case|:
return|return
literal|1
return|;
case|case
name|SSH_CHANNEL_INPUT_DRAINING
case|:
case|case
name|SSH_CHANNEL_OUTPUT_DRAINING
case|:
if|if
condition|(
operator|!
name|compat13
condition|)
name|fatal
argument_list|(
literal|"cannot happen: OUT_DRAIN"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|fatal
argument_list|(
literal|"channel_still_open: bad channel type %d"
argument_list|,
name|c
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns the id of an open channel suitable for keepaliving */
end_comment

begin_function
name|int
name|channel_find_open
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|remote_id
operator|<
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|c
operator|->
name|type
condition|)
block|{
case|case
name|SSH_CHANNEL_CLOSED
case|:
case|case
name|SSH_CHANNEL_DYNAMIC
case|:
case|case
name|SSH_CHANNEL_X11_LISTENER
case|:
case|case
name|SSH_CHANNEL_PORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_RPORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_MUX_LISTENER
case|:
case|case
name|SSH_CHANNEL_MUX_CLIENT
case|:
case|case
name|SSH_CHANNEL_MUX_PROXY
case|:
case|case
name|SSH_CHANNEL_OPENING
case|:
case|case
name|SSH_CHANNEL_CONNECTING
case|:
case|case
name|SSH_CHANNEL_ZOMBIE
case|:
case|case
name|SSH_CHANNEL_ABANDONED
case|:
case|case
name|SSH_CHANNEL_UNIX_LISTENER
case|:
case|case
name|SSH_CHANNEL_RUNIX_LISTENER
case|:
continue|continue;
case|case
name|SSH_CHANNEL_LARVAL
case|:
case|case
name|SSH_CHANNEL_AUTH_SOCKET
case|:
case|case
name|SSH_CHANNEL_OPEN
case|:
case|case
name|SSH_CHANNEL_X11_OPEN
case|:
return|return
name|i
return|;
case|case
name|SSH_CHANNEL_INPUT_DRAINING
case|:
case|case
name|SSH_CHANNEL_OUTPUT_DRAINING
case|:
if|if
condition|(
operator|!
name|compat13
condition|)
name|fatal
argument_list|(
literal|"cannot happen: OUT_DRAIN"
argument_list|)
expr_stmt|;
return|return
name|i
return|;
default|default:
name|fatal
argument_list|(
literal|"channel_find_open: bad channel type %d"
argument_list|,
name|c
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a message describing the currently open forwarded connections,  * suitable for sending to the client.  The message contains crlf pairs for  * newlines.  */
end_comment

begin_function
name|char
modifier|*
name|channel_open_message
parameter_list|(
name|void
parameter_list|)
block|{
name|Buffer
name|buffer
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|buffer_init
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"The following connections are open:\r\n"
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
continue|continue;
switch|switch
condition|(
name|c
operator|->
name|type
condition|)
block|{
case|case
name|SSH_CHANNEL_X11_LISTENER
case|:
case|case
name|SSH_CHANNEL_PORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_RPORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_CLOSED
case|:
case|case
name|SSH_CHANNEL_AUTH_SOCKET
case|:
case|case
name|SSH_CHANNEL_ZOMBIE
case|:
case|case
name|SSH_CHANNEL_ABANDONED
case|:
case|case
name|SSH_CHANNEL_MUX_LISTENER
case|:
case|case
name|SSH_CHANNEL_UNIX_LISTENER
case|:
case|case
name|SSH_CHANNEL_RUNIX_LISTENER
case|:
continue|continue;
case|case
name|SSH_CHANNEL_LARVAL
case|:
case|case
name|SSH_CHANNEL_OPENING
case|:
case|case
name|SSH_CHANNEL_CONNECTING
case|:
case|case
name|SSH_CHANNEL_DYNAMIC
case|:
case|case
name|SSH_CHANNEL_OPEN
case|:
case|case
name|SSH_CHANNEL_X11_OPEN
case|:
case|case
name|SSH_CHANNEL_INPUT_DRAINING
case|:
case|case
name|SSH_CHANNEL_OUTPUT_DRAINING
case|:
case|case
name|SSH_CHANNEL_MUX_PROXY
case|:
case|case
name|SSH_CHANNEL_MUX_CLIENT
case|:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"  #%d %.300s (t%d r%d i%u/%d o%u/%d fd %d/%d cc %d)\r\n"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|remote_name
argument_list|,
name|c
operator|->
name|type
argument_list|,
name|c
operator|->
name|remote_id
argument_list|,
name|c
operator|->
name|istate
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
argument_list|,
name|c
operator|->
name|ostate
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|,
name|c
operator|->
name|rfd
argument_list|,
name|c
operator|->
name|wfd
argument_list|,
name|c
operator|->
name|ctl_chan
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|fatal
argument_list|(
literal|"channel_open_message: bad channel type %d"
argument_list|,
name|c
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|buffer_append
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"\0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|xstrdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer_ptr
argument_list|(
operator|&
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

begin_function
name|void
name|channel_send_open
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|logit
argument_list|(
literal|"channel_send_open: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|debug2
argument_list|(
literal|"channel %d: send open"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|c
operator|->
name|ctype
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_request_start
parameter_list|(
name|int
name|id
parameter_list|,
name|char
modifier|*
name|service
parameter_list|,
name|int
name|wantconfirm
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|logit
argument_list|(
literal|"channel_request_start: %d: unknown channel id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|debug2
argument_list|(
literal|"channel %d: request %s confirm %d"
argument_list|,
name|id
argument_list|,
name|service
argument_list|,
name|wantconfirm
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_REQUEST
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
name|wantconfirm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_register_status_confirm
parameter_list|(
name|int
name|id
parameter_list|,
name|channel_confirm_cb
modifier|*
name|cb
parameter_list|,
name|channel_confirm_abandon_cb
modifier|*
name|abandon_cb
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|channel_confirm
modifier|*
name|cc
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"channel_register_expect: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|cc
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cc
argument_list|)
argument_list|)
expr_stmt|;
name|cc
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|cc
operator|->
name|abandon_cb
operator|=
name|abandon_cb
expr_stmt|;
name|cc
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|c
operator|->
name|status_confirms
argument_list|,
name|cc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_register_open_confirm
parameter_list|(
name|int
name|id
parameter_list|,
name|channel_open_fn
modifier|*
name|fn
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|logit
argument_list|(
literal|"channel_register_open_confirm: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|open_confirm
operator|=
name|fn
expr_stmt|;
name|c
operator|->
name|open_confirm_ctx
operator|=
name|ctx
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_register_cleanup
parameter_list|(
name|int
name|id
parameter_list|,
name|channel_callback_fn
modifier|*
name|fn
parameter_list|,
name|int
name|do_close
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_by_id
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|logit
argument_list|(
literal|"channel_register_cleanup: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|detach_user
operator|=
name|fn
expr_stmt|;
name|c
operator|->
name|detach_close
operator|=
name|do_close
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_cancel_cleanup
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_by_id
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|logit
argument_list|(
literal|"channel_cancel_cleanup: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|detach_user
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|detach_close
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_register_filter
parameter_list|(
name|int
name|id
parameter_list|,
name|channel_infilter_fn
modifier|*
name|ifn
parameter_list|,
name|channel_outfilter_fn
modifier|*
name|ofn
parameter_list|,
name|channel_filter_cleanup_fn
modifier|*
name|cfn
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|logit
argument_list|(
literal|"channel_register_filter: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|input_filter
operator|=
name|ifn
expr_stmt|;
name|c
operator|->
name|output_filter
operator|=
name|ofn
expr_stmt|;
name|c
operator|->
name|filter_ctx
operator|=
name|ctx
expr_stmt|;
name|c
operator|->
name|filter_cleanup
operator|=
name|cfn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_set_fds
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|rfd
parameter_list|,
name|int
name|wfd
parameter_list|,
name|int
name|efd
parameter_list|,
name|int
name|extusage
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|int
name|is_tty
parameter_list|,
name|u_int
name|window_max
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_LARVAL
condition|)
name|fatal
argument_list|(
literal|"channel_activate for non-larval channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|channel_register_fds
argument_list|(
name|c
argument_list|,
name|rfd
argument_list|,
name|wfd
argument_list|,
name|efd
argument_list|,
name|extusage
argument_list|,
name|nonblock
argument_list|,
name|is_tty
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
name|c
operator|->
name|local_window
operator|=
name|c
operator|->
name|local_window_max
operator|=
name|window_max
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_WINDOW_ADJUST
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'channel_pre*' are called just before select() to add any bits relevant to  * channels in the select bitmasks.  */
end_comment

begin_comment
comment|/*  * 'channel_post*': perform any appropriate operations for channels which  * have events pending.  */
end_comment

begin_typedef
typedef|typedef
name|void
name|chan_fn
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
name|chan_fn
modifier|*
name|channel_pre
index|[
name|SSH_CHANNEL_MAX_TYPE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|chan_fn
modifier|*
name|channel_post
index|[
name|SSH_CHANNEL_MAX_TYPE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|channel_pre_listener
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|channel_pre_connecting
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|debug3
argument_list|(
literal|"channel %d: waiting for connection"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|channel_pre_open_13
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|<
name|packet_get_maxsize
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|channel_pre_open
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|u_int
name|limit
init|=
name|compat20
condition|?
name|c
operator|->
name|remote_window
else|:
name|packet_get_maxsize
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_OPEN
operator|&&
name|limit
operator|>
literal|0
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|<
name|limit
operator|&&
name|buffer_check_alloc
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
name|CHAN_RBUF
argument_list|)
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|rfd
argument_list|,
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_OPEN
operator|||
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_WAIT_DRAIN
condition|)
block|{
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_WAIT_DRAIN
condition|)
block|{
if|if
condition|(
name|CHANNEL_EFD_OUTPUT_ACTIVE
argument_list|(
name|c
argument_list|)
condition|)
name|debug2
argument_list|(
literal|"channel %d: obuf_empty delayed efd %d/(%d)"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|efd
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|chan_obuf_empty
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** XXX check close conditions, too */
if|if
condition|(
name|compat20
operator|&&
name|c
operator|->
name|efd
operator|!=
operator|-
literal|1
operator|&&
operator|!
operator|(
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_CLOSED
operator|&&
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_CLOSED
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_WRITE
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|efd
operator|!=
operator|-
literal|1
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHAN_EOF_SENT
operator|)
operator|&&
operator|(
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_READ
operator|||
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_IGNORE
operator|)
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
operator|<
name|c
operator|->
name|remote_window
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|readset
argument_list|)
expr_stmt|;
block|}
comment|/* XXX: What about efd? races? */
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|channel_pre_input_draining
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_CLOSED
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: closing after input drain."
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|channel_pre_output_draining
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|==
literal|0
condition|)
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is a special state for X11 authentication spoofing.  An opened X11  * connection (when authentication spoofing is being done) remains in this  * state until the first packet has been completely read.  The authentication  * data in that packet is then substituted by the real data if it matches the  * fake data, and the channel is put into normal mode.  * XXX All this happens at the client side.  * Returns: 0 = need more data, -1 = wrong cookie, 1 = ok  */
end_comment

begin_function
specifier|static
name|int
name|x11_open_helper
parameter_list|(
name|Buffer
modifier|*
name|b
parameter_list|)
block|{
name|u_char
modifier|*
name|ucp
decl_stmt|;
name|u_int
name|proto_len
decl_stmt|,
name|data_len
decl_stmt|;
comment|/* Is this being called after the refusal deadline? */
if|if
condition|(
name|x11_refuse_time
operator|!=
literal|0
operator|&&
operator|(
name|u_int
operator|)
name|monotime
argument_list|()
operator|>=
name|x11_refuse_time
condition|)
block|{
name|verbose
argument_list|(
literal|"Rejected X11 connection after ForwardX11Timeout "
literal|"expired"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check if the fixed size part of the packet is in buffer. */
if|if
condition|(
name|buffer_len
argument_list|(
name|b
argument_list|)
operator|<
literal|12
condition|)
return|return
literal|0
return|;
comment|/* Parse the lengths of variable-length fields. */
name|ucp
operator|=
name|buffer_ptr
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucp
index|[
literal|0
index|]
operator|==
literal|0x42
condition|)
block|{
comment|/* Byte order MSB first. */
name|proto_len
operator|=
literal|256
operator|*
name|ucp
index|[
literal|6
index|]
operator|+
name|ucp
index|[
literal|7
index|]
expr_stmt|;
name|data_len
operator|=
literal|256
operator|*
name|ucp
index|[
literal|8
index|]
operator|+
name|ucp
index|[
literal|9
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ucp
index|[
literal|0
index|]
operator|==
literal|0x6c
condition|)
block|{
comment|/* Byte order LSB first. */
name|proto_len
operator|=
name|ucp
index|[
literal|6
index|]
operator|+
literal|256
operator|*
name|ucp
index|[
literal|7
index|]
expr_stmt|;
name|data_len
operator|=
name|ucp
index|[
literal|8
index|]
operator|+
literal|256
operator|*
name|ucp
index|[
literal|9
index|]
expr_stmt|;
block|}
else|else
block|{
name|debug2
argument_list|(
literal|"Initial X11 packet contains bad byte order byte: 0x%x"
argument_list|,
name|ucp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check if the whole packet is in buffer. */
if|if
condition|(
name|buffer_len
argument_list|(
name|b
argument_list|)
operator|<
literal|12
operator|+
operator|(
operator|(
name|proto_len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
operator|+
operator|(
operator|(
name|data_len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Check if authentication protocol matches. */
if|if
condition|(
name|proto_len
operator|!=
name|strlen
argument_list|(
name|x11_saved_proto
argument_list|)
operator|||
name|memcmp
argument_list|(
name|ucp
operator|+
literal|12
argument_list|,
name|x11_saved_proto
argument_list|,
name|proto_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"X11 connection uses different authentication protocol."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check if authentication data matches our fake data. */
if|if
condition|(
name|data_len
operator|!=
name|x11_fake_data_len
operator|||
name|timingsafe_bcmp
argument_list|(
name|ucp
operator|+
literal|12
operator|+
operator|(
operator|(
name|proto_len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
argument_list|,
name|x11_fake_data
argument_list|,
name|x11_fake_data_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"X11 auth data does not match fake data."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check fake data length */
if|if
condition|(
name|x11_fake_data_len
operator|!=
name|x11_saved_data_len
condition|)
block|{
name|error
argument_list|(
literal|"X11 fake_data_len %d != saved_data_len %d"
argument_list|,
name|x11_fake_data_len
argument_list|,
name|x11_saved_data_len
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Received authentication protocol and data match 	 * our fake data. Substitute the fake data with real 	 * data. 	 */
name|memcpy
argument_list|(
name|ucp
operator|+
literal|12
operator|+
operator|(
operator|(
name|proto_len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
argument_list|,
name|x11_saved_data
argument_list|,
name|x11_saved_data_len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|channel_pre_x11_open_13
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|ret
init|=
name|x11_open_helper
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
comment|/* Start normal processing for the channel. */
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
name|channel_pre_open_13
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * We have received an X11 connection that has bad 		 * authentication information. 		 */
name|logit
argument_list|(
literal|"X11 connection rejected because of wrong authentication."
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|sock
argument_list|)
expr_stmt|;
name|c
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_CLOSED
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|channel_pre_x11_open
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|ret
init|=
name|x11_open_helper
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
decl_stmt|;
comment|/* c->force_drain = 1; */
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
name|channel_pre_open
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|logit
argument_list|(
literal|"X11 connection rejected because of wrong authentication."
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"X11 rejected %d i%d/o%d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|istate
argument_list|,
name|c
operator|->
name|ostate
argument_list|)
expr_stmt|;
name|chan_read_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|chan_ibuf_empty
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
comment|/* for proto v1, the peer will send an IEOF */
if|if
condition|(
name|compat20
condition|)
name|chan_write_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
name|debug2
argument_list|(
literal|"X11 closed %d i%d/o%d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|istate
argument_list|,
name|c
operator|->
name|ostate
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|channel_pre_mux_client
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_OPEN
operator|&&
operator|!
name|c
operator|->
name|mux_pause
operator|&&
name|buffer_check_alloc
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
name|CHAN_RBUF
argument_list|)
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|rfd
argument_list|,
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_WAIT_DRAIN
condition|)
block|{
comment|/* clear buffer immediately (discard any partial packet) */
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|chan_ibuf_empty
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Start output drain. XXX just kill chan? */
name|chan_rcvd_oclose
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_OPEN
operator|||
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_WAIT_DRAIN
condition|)
block|{
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_WAIT_DRAIN
condition|)
name|chan_obuf_empty
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* try to decode a socks4 header */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|channel_decode_socks4
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|host
decl_stmt|;
name|u_int
name|len
decl_stmt|,
name|have
decl_stmt|,
name|i
decl_stmt|,
name|found
decl_stmt|,
name|need
decl_stmt|;
name|char
name|username
index|[
literal|256
index|]
decl_stmt|;
struct|struct
block|{
name|u_int8_t
name|version
decl_stmt|;
name|u_int8_t
name|command
decl_stmt|;
name|u_int16_t
name|dest_port
decl_stmt|;
name|struct
name|in_addr
name|dest_addr
decl_stmt|;
block|}
name|s4_req
struct|,
name|s4_rsp
struct|;
name|debug2
argument_list|(
literal|"channel %d: decode socks4"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|have
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|s4_req
argument_list|)
expr_stmt|;
if|if
condition|(
name|have
operator|<
name|len
condition|)
return|return
literal|0
return|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|need
operator|=
literal|1
expr_stmt|;
comment|/* SOCKS4A uses an invalid IP address 0.0.0.x */
if|if
condition|(
name|p
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|p
index|[
literal|5
index|]
operator|==
literal|0
operator|&&
name|p
index|[
literal|6
index|]
operator|==
literal|0
operator|&&
name|p
index|[
literal|7
index|]
operator|!=
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: socks4a request"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
comment|/* ... and needs an extra string (the hostname) */
name|need
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Check for terminating NUL on the string(s) */
for|for
control|(
name|found
operator|=
literal|0
operator|,
name|i
operator|=
name|len
init|;
name|i
operator|<
name|have
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|need
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>
literal|1024
condition|)
block|{
comment|/* the peer is probably sending garbage */
name|debug
argument_list|(
literal|"channel %d: decode socks4: too long"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|found
operator|<
name|need
condition|)
return|return
literal|0
return|;
name|buffer_get
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|s4_req
operator|.
name|version
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buffer_get
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|s4_req
operator|.
name|command
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buffer_get
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|s4_req
operator|.
name|dest_port
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buffer_get
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|s4_req
operator|.
name|dest_addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|have
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|memchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|,
name|have
argument_list|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"channel %d: decode socks4: user not nul terminated"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: decode socks4: user %s/%d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
comment|/* trailing '\0' */
if|if
condition|(
name|len
operator|>
name|have
condition|)
name|fatal
argument_list|(
literal|"channel %d: decode socks4: len %d> have %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|len
argument_list|,
name|have
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|username
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|username
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|path
argument_list|)
expr_stmt|;
name|c
operator|->
name|path
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|need
operator|==
literal|1
condition|)
block|{
comment|/* SOCKS4: one string */
name|host
operator|=
name|inet_ntoa
argument_list|(
name|s4_req
operator|.
name|dest_addr
argument_list|)
expr_stmt|;
name|c
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* SOCKS4A: two strings */
name|have
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: decode socks4a: host %s/%d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
comment|/* trailing '\0' */
if|if
condition|(
name|len
operator|>
name|have
condition|)
name|fatal
argument_list|(
literal|"channel %d: decode socks4a: len %d> have %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|len
argument_list|,
name|have
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|NI_MAXHOST
condition|)
block|{
name|error
argument_list|(
literal|"channel %d: hostname \"%.100s\" too long"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|c
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|host_port
operator|=
name|ntohs
argument_list|(
name|s4_req
operator|.
name|dest_port
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: dynamic request: socks4 host %s port %u command %u"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|path
argument_list|,
name|c
operator|->
name|host_port
argument_list|,
name|s4_req
operator|.
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|s4_req
operator|.
name|command
operator|!=
literal|1
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: cannot handle: %s cn %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|need
operator|==
literal|1
condition|?
literal|"SOCKS4"
else|:
literal|"SOCKS4A"
argument_list|,
name|s4_req
operator|.
name|command
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|s4_rsp
operator|.
name|version
operator|=
literal|0
expr_stmt|;
comment|/* vn: 0 for reply */
name|s4_rsp
operator|.
name|command
operator|=
literal|90
expr_stmt|;
comment|/* cd: req granted */
name|s4_rsp
operator|.
name|dest_port
operator|=
literal|0
expr_stmt|;
comment|/* ignored */
name|s4_rsp
operator|.
name|dest_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
comment|/* ignored */
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
operator|&
name|s4_rsp
argument_list|,
sizeof|sizeof
argument_list|(
name|s4_rsp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* try to decode a socks5 header */
end_comment

begin_define
define|#
directive|define
name|SSH_SOCKS5_AUTHDONE
value|0x1000
end_define

begin_define
define|#
directive|define
name|SSH_SOCKS5_NOAUTH
value|0x00
end_define

begin_define
define|#
directive|define
name|SSH_SOCKS5_IPV4
value|0x01
end_define

begin_define
define|#
directive|define
name|SSH_SOCKS5_DOMAIN
value|0x03
end_define

begin_define
define|#
directive|define
name|SSH_SOCKS5_IPV6
value|0x04
end_define

begin_define
define|#
directive|define
name|SSH_SOCKS5_CONNECT
value|0x01
end_define

begin_define
define|#
directive|define
name|SSH_SOCKS5_SUCCESS
value|0x00
end_define

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|channel_decode_socks5
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
struct|struct
block|{
name|u_int8_t
name|version
decl_stmt|;
name|u_int8_t
name|command
decl_stmt|;
name|u_int8_t
name|reserved
decl_stmt|;
name|u_int8_t
name|atyp
decl_stmt|;
block|}
name|s5_req
struct|,
name|s5_rsp
struct|;
name|u_int16_t
name|dest_port
decl_stmt|;
name|char
name|dest_addr
index|[
literal|255
operator|+
literal|1
index|]
decl_stmt|,
name|ntop
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|u_int
name|have
decl_stmt|,
name|need
decl_stmt|,
name|i
decl_stmt|,
name|found
decl_stmt|,
name|nmethods
decl_stmt|,
name|addrlen
decl_stmt|,
name|af
decl_stmt|;
name|debug2
argument_list|(
literal|"channel %d: decode socks5"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|p
operator|=
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|0x05
condition|)
return|return
operator|-
literal|1
return|;
name|have
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|SSH_SOCKS5_AUTHDONE
operator|)
condition|)
block|{
comment|/* format: ver | nmethods | methods */
if|if
condition|(
name|have
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|nmethods
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|have
operator|<
name|nmethods
operator|+
literal|2
condition|)
return|return
literal|0
return|;
comment|/* look for method: "NO AUTHENTICATION REQUIRED" */
for|for
control|(
name|found
operator|=
literal|0
operator|,
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|nmethods
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
name|SSH_SOCKS5_NOAUTH
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: method SSH_SOCKS5_NOAUTH not found"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
name|nmethods
operator|+
literal|2
argument_list|)
expr_stmt|;
name|buffer_put_char
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* version */
name|buffer_put_char
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|SSH_SOCKS5_NOAUTH
argument_list|)
expr_stmt|;
comment|/* method */
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|SSH_SOCKS5_AUTHDONE
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: socks5 auth done"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* need more */
block|}
name|debug2
argument_list|(
literal|"channel %d: socks5 post auth"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
name|have
operator|<
sizeof|sizeof
argument_list|(
name|s5_req
argument_list|)
operator|+
literal|1
condition|)
return|return
literal|0
return|;
comment|/* need more */
name|memcpy
argument_list|(
operator|&
name|s5_req
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|s5_req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s5_req
operator|.
name|version
operator|!=
literal|0x05
operator|||
name|s5_req
operator|.
name|command
operator|!=
name|SSH_SOCKS5_CONNECT
operator|||
name|s5_req
operator|.
name|reserved
operator|!=
literal|0x00
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: only socks5 connect supported"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|s5_req
operator|.
name|atyp
condition|)
block|{
case|case
name|SSH_SOCKS5_IPV4
case|:
name|addrlen
operator|=
literal|4
expr_stmt|;
name|af
operator|=
name|AF_INET
expr_stmt|;
break|break;
case|case
name|SSH_SOCKS5_DOMAIN
case|:
name|addrlen
operator|=
name|p
index|[
sizeof|sizeof
argument_list|(
name|s5_req
argument_list|)
index|]
expr_stmt|;
name|af
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|SSH_SOCKS5_IPV6
case|:
name|addrlen
operator|=
literal|16
expr_stmt|;
name|af
operator|=
name|AF_INET6
expr_stmt|;
break|break;
default|default:
name|debug2
argument_list|(
literal|"channel %d: bad socks5 atyp %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|s5_req
operator|.
name|atyp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|need
operator|=
sizeof|sizeof
argument_list|(
name|s5_req
argument_list|)
operator|+
name|addrlen
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|s5_req
operator|.
name|atyp
operator|==
name|SSH_SOCKS5_DOMAIN
condition|)
name|need
operator|++
expr_stmt|;
if|if
condition|(
name|have
operator|<
name|need
condition|)
return|return
literal|0
return|;
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
sizeof|sizeof
argument_list|(
name|s5_req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s5_req
operator|.
name|atyp
operator|==
name|SSH_SOCKS5_DOMAIN
condition|)
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* host string length */
name|buffer_get
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
operator|&
name|dest_addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|buffer_get
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dest_port
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dest_addr
index|[
name|addrlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|path
argument_list|)
expr_stmt|;
name|c
operator|->
name|path
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|s5_req
operator|.
name|atyp
operator|==
name|SSH_SOCKS5_DOMAIN
condition|)
block|{
if|if
condition|(
name|addrlen
operator|>=
name|NI_MAXHOST
condition|)
block|{
name|error
argument_list|(
literal|"channel %d: dynamic request: socks5 hostname "
literal|"\"%.100s\" too long"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|dest_addr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|c
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|dest_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inet_ntop
argument_list|(
name|af
argument_list|,
name|dest_addr
argument_list|,
name|ntop
argument_list|,
sizeof|sizeof
argument_list|(
name|ntop
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|c
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|ntop
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|host_port
operator|=
name|ntohs
argument_list|(
name|dest_port
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: dynamic request: socks5 host %s port %u command %u"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|path
argument_list|,
name|c
operator|->
name|host_port
argument_list|,
name|s5_req
operator|.
name|command
argument_list|)
expr_stmt|;
name|s5_rsp
operator|.
name|version
operator|=
literal|0x05
expr_stmt|;
name|s5_rsp
operator|.
name|command
operator|=
name|SSH_SOCKS5_SUCCESS
expr_stmt|;
name|s5_rsp
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
comment|/* ignored */
name|s5_rsp
operator|.
name|atyp
operator|=
name|SSH_SOCKS5_IPV4
expr_stmt|;
name|dest_port
operator|=
literal|0
expr_stmt|;
comment|/* ignored */
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
operator|&
name|s5_rsp
argument_list|,
sizeof|sizeof
argument_list|(
name|s5_rsp
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|ntohl
argument_list|(
name|INADDR_ANY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* bind address */
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
operator|&
name|dest_port
argument_list|,
sizeof|sizeof
argument_list|(
name|dest_port
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|Channel
modifier|*
name|channel_connect_stdio_fwd
parameter_list|(
specifier|const
name|char
modifier|*
name|host_to_connect
parameter_list|,
name|u_short
name|port_to_connect
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|out
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
name|debug
argument_list|(
literal|"channel_connect_stdio_fwd %s:%d"
argument_list|,
name|host_to_connect
argument_list|,
name|port_to_connect
argument_list|)
expr_stmt|;
name|c
operator|=
name|channel_new
argument_list|(
literal|"stdio-forward"
argument_list|,
name|SSH_CHANNEL_OPENING
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_TCP_WINDOW_DEFAULT
argument_list|,
name|CHAN_TCP_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|"stdio-forward"
argument_list|,
comment|/*nonblock*/
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|host_to_connect
argument_list|)
expr_stmt|;
name|c
operator|->
name|host_port
operator|=
name|port_to_connect
expr_stmt|;
name|c
operator|->
name|listening_port
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|force_drain
operator|=
literal|1
expr_stmt|;
name|channel_register_fds
argument_list|(
name|c
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port_open_helper
argument_list|(
name|c
argument_list|,
literal|"direct-tcpip"
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* dynamic port forwarding */
end_comment

begin_function
specifier|static
name|void
name|channel_pre_dynamic
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|;
name|u_int
name|have
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|have
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: pre_dynamic: have %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|have
argument_list|)
expr_stmt|;
comment|/* buffer_dump(&c->input); */
comment|/* check if the fixed size part of the packet is in buffer. */
if|if
condition|(
name|have
operator|<
literal|3
condition|)
block|{
comment|/* need more */
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* try to guess the protocol */
name|p
operator|=
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0x04
case|:
name|ret
operator|=
name|channel_decode_socks4
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x05
case|:
name|ret
operator|=
name|channel_decode_socks5
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: pre_dynamic: need more"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
comment|/* need more */
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* switch to the next state */
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPENING
expr_stmt|;
name|port_open_helper
argument_list|(
name|c
argument_list|,
literal|"direct-tcpip"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is our fake X11 server socket. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|channel_post_x11_listener
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|Channel
modifier|*
name|nc
decl_stmt|;
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|int
name|newsock
decl_stmt|,
name|oerrno
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
name|char
name|buf
index|[
literal|16384
index|]
decl_stmt|,
modifier|*
name|remote_ipaddr
decl_stmt|;
name|int
name|remote_port
decl_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"X11 connection requested."
argument_list|)
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|newsock
operator|=
name|accept
argument_list|(
name|c
operator|->
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|single_connection
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
name|debug2
argument_list|(
literal|"single_connection: closing X11 listener."
argument_list|)
expr_stmt|;
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|sock
argument_list|)
expr_stmt|;
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
block|}
if|if
condition|(
name|newsock
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
operator|&&
name|errno
operator|!=
name|ECONNABORTED
condition|)
name|error
argument_list|(
literal|"accept: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EMFILE
operator|||
name|errno
operator|==
name|ENFILE
condition|)
name|c
operator|->
name|notbefore
operator|=
name|monotime
argument_list|()
operator|+
literal|1
expr_stmt|;
return|return;
block|}
name|set_nodelay
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
name|remote_ipaddr
operator|=
name|get_peer_ipaddr
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
name|remote_port
operator|=
name|get_peer_port
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"X11 connection from %.200s port %d"
argument_list|,
name|remote_ipaddr
argument_list|,
name|remote_port
argument_list|)
expr_stmt|;
name|nc
operator|=
name|channel_new
argument_list|(
literal|"accepted x11 socket"
argument_list|,
name|SSH_CHANNEL_OPENING
argument_list|,
name|newsock
argument_list|,
name|newsock
argument_list|,
operator|-
literal|1
argument_list|,
name|c
operator|->
name|local_window_max
argument_list|,
name|c
operator|->
name|local_maxpacket
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"x11"
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|nc
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|nc
operator|->
name|local_window_max
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|nc
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
comment|/* originator ipaddr and port */
name|packet_put_cstring
argument_list|(
name|remote_ipaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|datafellows
operator|&
name|SSH_BUG_X11FWD
condition|)
block|{
name|debug2
argument_list|(
literal|"ssh2 x11 bug compat mode"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|packet_put_int
argument_list|(
name|remote_port
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_SMSG_X11_OPEN
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|nc
operator|->
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_get_protocol_flags
argument_list|()
operator|&
name|SSH_PROTOFLAG_HOST_IN_FWD_OPEN
condition|)
name|packet_put_cstring
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|remote_ipaddr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|port_open_helper
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|rtype
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|local_ipaddr
init|=
name|get_local_ipaddr
argument_list|(
name|c
operator|->
name|sock
argument_list|)
decl_stmt|;
name|int
name|local_port
init|=
name|c
operator|->
name|sock
operator|==
operator|-
literal|1
condition|?
literal|65536
else|:
name|get_local_port
argument_list|(
name|c
operator|->
name|sock
argument_list|)
decl_stmt|;
name|char
modifier|*
name|remote_ipaddr
init|=
name|get_peer_ipaddr
argument_list|(
name|c
operator|->
name|sock
argument_list|)
decl_stmt|;
name|int
name|remote_port
init|=
name|get_peer_port
argument_list|(
name|c
operator|->
name|sock
argument_list|)
decl_stmt|;
if|if
condition|(
name|remote_port
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Fake addr/port to appease peers that validate it (Tectia) */
name|free
argument_list|(
name|remote_ipaddr
argument_list|)
expr_stmt|;
name|remote_ipaddr
operator|=
name|xstrdup
argument_list|(
literal|"127.0.0.1"
argument_list|)
expr_stmt|;
name|remote_port
operator|=
literal|65535
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%s: listening port %d for %.100s port %d, "
literal|"connect from %.200s port %d to %.100s port %d"
argument_list|,
name|rtype
argument_list|,
name|c
operator|->
name|listening_port
argument_list|,
name|c
operator|->
name|path
argument_list|,
name|c
operator|->
name|host_port
argument_list|,
name|remote_ipaddr
argument_list|,
name|remote_port
argument_list|,
name|local_ipaddr
argument_list|,
name|local_port
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|remote_name
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_name
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window_max
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"direct-tcpip"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* target host, port */
name|packet_put_cstring
argument_list|(
name|c
operator|->
name|path
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|host_port
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"direct-streamlocal@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* target path */
name|packet_put_cstring
argument_list|(
name|c
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"forwarded-streamlocal@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* listen path */
name|packet_put_cstring
argument_list|(
name|c
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* listen address, port */
name|packet_put_cstring
argument_list|(
name|c
operator|->
name|path
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|local_port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"forwarded-streamlocal@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* reserved for future owner/mode info */
name|packet_put_cstring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* originator host and port */
name|packet_put_cstring
argument_list|(
name|remote_ipaddr
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
operator|(
name|u_int
operator|)
name|remote_port
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_MSG_PORT_OPEN
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|c
operator|->
name|path
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|host_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_get_protocol_flags
argument_list|()
operator|&
name|SSH_PROTOFLAG_HOST_IN_FWD_OPEN
condition|)
name|packet_put_cstring
argument_list|(
name|c
operator|->
name|remote_name
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|remote_ipaddr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|local_ipaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|channel_set_reuseaddr
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
comment|/* 	 * Set socket options. 	 * Allow local port reuse in TIME_WAIT. 	 */
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"setsockopt SO_REUSEADDR fd %d: %s"
argument_list|,
name|fd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_set_x11_refuse_time
parameter_list|(
name|u_int
name|refuse_time
parameter_list|)
block|{
name|x11_refuse_time
operator|=
name|refuse_time
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This socket is listening for connections to a forwarded TCP/IP port.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|channel_post_port_listener
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|Channel
modifier|*
name|nc
decl_stmt|;
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|int
name|newsock
decl_stmt|,
name|nextstate
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
name|char
modifier|*
name|rtype
decl_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"Connection to port %d forwarding "
literal|"to %.100s port %d requested."
argument_list|,
name|c
operator|->
name|listening_port
argument_list|,
name|c
operator|->
name|path
argument_list|,
name|c
operator|->
name|host_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_RPORT_LISTENER
condition|)
block|{
name|nextstate
operator|=
name|SSH_CHANNEL_OPENING
expr_stmt|;
name|rtype
operator|=
literal|"forwarded-tcpip"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_RUNIX_LISTENER
condition|)
block|{
name|nextstate
operator|=
name|SSH_CHANNEL_OPENING
expr_stmt|;
name|rtype
operator|=
literal|"forwarded-streamlocal@openssh.com"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|host_port
operator|==
name|PORT_STREAMLOCAL
condition|)
block|{
name|nextstate
operator|=
name|SSH_CHANNEL_OPENING
expr_stmt|;
name|rtype
operator|=
literal|"direct-streamlocal@openssh.com"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|host_port
operator|==
literal|0
condition|)
block|{
name|nextstate
operator|=
name|SSH_CHANNEL_DYNAMIC
expr_stmt|;
name|rtype
operator|=
literal|"dynamic-tcpip"
expr_stmt|;
block|}
else|else
block|{
name|nextstate
operator|=
name|SSH_CHANNEL_OPENING
expr_stmt|;
name|rtype
operator|=
literal|"direct-tcpip"
expr_stmt|;
block|}
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|newsock
operator|=
name|accept
argument_list|(
name|c
operator|->
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsock
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
operator|&&
name|errno
operator|!=
name|ECONNABORTED
condition|)
name|error
argument_list|(
literal|"accept: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EMFILE
operator|||
name|errno
operator|==
name|ENFILE
condition|)
name|c
operator|->
name|notbefore
operator|=
name|monotime
argument_list|()
operator|+
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|->
name|host_port
operator|!=
name|PORT_STREAMLOCAL
condition|)
name|set_nodelay
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
name|nc
operator|=
name|channel_new
argument_list|(
name|rtype
argument_list|,
name|nextstate
argument_list|,
name|newsock
argument_list|,
name|newsock
argument_list|,
operator|-
literal|1
argument_list|,
name|c
operator|->
name|local_window_max
argument_list|,
name|c
operator|->
name|local_maxpacket
argument_list|,
literal|0
argument_list|,
name|rtype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nc
operator|->
name|listening_port
operator|=
name|c
operator|->
name|listening_port
expr_stmt|;
name|nc
operator|->
name|host_port
operator|=
name|c
operator|->
name|host_port
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|path
operator|!=
name|NULL
condition|)
name|nc
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|c
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextstate
operator|!=
name|SSH_CHANNEL_DYNAMIC
condition|)
name|port_open_helper
argument_list|(
name|nc
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is the authentication agent socket listening for connections from  * clients.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|channel_post_auth_listener
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|Channel
modifier|*
name|nc
decl_stmt|;
name|int
name|newsock
decl_stmt|;
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|newsock
operator|=
name|accept
argument_list|(
name|c
operator|->
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsock
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"accept from auth socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EMFILE
operator|||
name|errno
operator|==
name|ENFILE
condition|)
name|c
operator|->
name|notbefore
operator|=
name|monotime
argument_list|()
operator|+
literal|1
expr_stmt|;
return|return;
block|}
name|nc
operator|=
name|channel_new
argument_list|(
literal|"accepted auth socket"
argument_list|,
name|SSH_CHANNEL_OPENING
argument_list|,
name|newsock
argument_list|,
name|newsock
argument_list|,
operator|-
literal|1
argument_list|,
name|c
operator|->
name|local_window_max
argument_list|,
name|c
operator|->
name|local_maxpacket
argument_list|,
literal|0
argument_list|,
literal|"accepted auth socket"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"auth-agent@openssh.com"
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|nc
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window_max
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_SMSG_AGENT_OPEN
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|nc
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|channel_post_connecting
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|,
name|sock
decl_stmt|;
name|socklen_t
name|sz
init|=
sizeof|sizeof
argument_list|(
name|err
argument_list|)
decl_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|writeset
argument_list|)
condition|)
block|{
if|if
condition|(
name|getsockopt
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|&
name|err
argument_list|,
operator|&
name|sz
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
literal|"getsockopt SO_ERROR failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: connected to %s port %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|connect_ctx
operator|.
name|host
argument_list|,
name|c
operator|->
name|connect_ctx
operator|.
name|port
argument_list|)
expr_stmt|;
name|channel_connect_ctx_free
argument_list|(
operator|&
name|c
operator|->
name|connect_ctx
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|debug
argument_list|(
literal|"channel %d: connection failed: %s"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try next address, if any */
if|if
condition|(
operator|(
name|sock
operator|=
name|connect_next
argument_list|(
operator|&
name|c
operator|->
name|connect_ctx
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|close
argument_list|(
name|c
operator|->
name|sock
argument_list|)
expr_stmt|;
name|c
operator|->
name|sock
operator|=
name|c
operator|->
name|rfd
operator|=
name|c
operator|->
name|wfd
operator|=
name|sock
expr_stmt|;
name|channel_max_fd
operator|=
name|channel_find_maxfd
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Exhausted all addresses */
name|error
argument_list|(
literal|"connect_to %.100s port %d: failed."
argument_list|,
name|c
operator|->
name|connect_ctx
operator|.
name|host
argument_list|,
name|c
operator|->
name|connect_ctx
operator|.
name|port
argument_list|)
expr_stmt|;
name|channel_connect_ctx_free
argument_list|(
operator|&
name|c
operator|->
name|connect_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|SSH2_OPEN_CONNECT_FAILED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|datafellows
operator|&
name|SSH_BUG_OPENFAILURE
operator|)
condition|)
block|{
name|packet_put_cstring
argument_list|(
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
block|}
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|channel_handle_rfd
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|char
name|buf
index|[
name|CHAN_RBUF
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|force
decl_stmt|;
name|force
operator|=
name|c
operator|->
name|isatty
operator|&&
name|c
operator|->
name|detach_close
operator|&&
name|c
operator|->
name|istate
operator|!=
name|CHAN_INPUT_CLOSED
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|rfd
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|force
operator|||
name|FD_ISSET
argument_list|(
name|c
operator|->
name|rfd
argument_list|,
name|readset
argument_list|)
operator|)
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|read
argument_list|(
name|c
operator|->
name|rfd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
operator|(
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
operator|&&
operator|!
name|force
operator|)
operator|)
condition|)
return|return
literal|1
return|;
ifndef|#
directive|ifndef
name|PTY_ZEROREAD
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
operator|!
name|c
operator|->
name|isatty
operator|&&
name|len
operator|<=
literal|0
operator|)
operator|||
operator|(
name|c
operator|->
name|isatty
operator|&&
operator|(
name|len
operator|<
literal|0
operator|||
operator|(
name|len
operator|==
literal|0
operator|&&
name|errno
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
endif|#
directive|endif
name|debug2
argument_list|(
literal|"channel %d: read<=0 rfd %d len %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|rfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: not open"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|compat13
condition|)
block|{
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_INPUT_DRAINING
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: input draining."
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan_read_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|c
operator|->
name|input_filter
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|input_filter
argument_list|(
name|c
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: filter stops"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|chan_read_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|datagram
condition|)
block|{
name|buffer_put_string
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
comment|/* ARGSUSED */
specifier|static
name|int
name|channel_handle_wfd
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|struct
name|termios
name|tio
decl_stmt|;
name|u_char
modifier|*
name|data
init|=
name|NULL
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|u_int
name|dlen
decl_stmt|,
name|olen
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Send buffered output data to the socket. */
if|if
condition|(
name|c
operator|->
name|wfd
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
name|writeset
argument_list|)
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
literal|0
condition|)
block|{
name|olen
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|output_filter
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|buf
operator|=
name|c
operator|->
name|output_filter
argument_list|(
name|c
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|dlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: filter stops"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
condition|)
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|chan_write_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|datagram
condition|)
block|{
name|buf
operator|=
name|data
operator|=
name|buffer_get_string
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
operator|&
name|dlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|data
operator|=
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|datagram
condition|)
block|{
comment|/* ignore truncated writes, datagrams might get lost */
name|len
operator|=
name|write
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
name|buf
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
condition|)
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|chan_write_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|_AIX
comment|/* XXX: Later AIX versions can't push as much data to tty */
if|if
condition|(
name|compat20
operator|&&
name|c
operator|->
name|wfd_isatty
condition|)
name|dlen
operator|=
name|MIN
argument_list|(
name|dlen
argument_list|,
literal|8
operator|*
literal|1024
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|write
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
name|buf
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: not open"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|compat13
condition|)
block|{
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: input draining."
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_INPUT_DRAINING
expr_stmt|;
block|}
else|else
block|{
name|chan_write_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
ifndef|#
directive|ifndef
name|BROKEN_TCGETATTR_ICANON
if|if
condition|(
name|compat20
operator|&&
name|c
operator|->
name|isatty
operator|&&
name|dlen
operator|>=
literal|1
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\r'
condition|)
block|{
if|if
condition|(
name|tcgetattr
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
operator|&
name|tio
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|tio
operator|.
name|c_lflag
operator|&
name|ECHO
operator|)
operator|&&
operator|(
name|tio
operator|.
name|c_lflag
operator|&
name|ICANON
operator|)
condition|)
block|{
comment|/* 				 * Simulate echo to reduce the impact of 				 * traffic analysis. We need to match the 				 * size of a SSH2_MSG_CHANNEL_DATA message 				 * (4 byte channel id + buf) 				 */
name|packet_send_ignore
argument_list|(
literal|4
operator|+
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|compat20
operator|&&
name|olen
operator|>
literal|0
condition|)
name|c
operator|->
name|local_consumed
operator|+=
name|olen
operator|-
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
specifier|static
name|int
name|channel_handle_efd
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|char
name|buf
index|[
name|CHAN_RBUF
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/** XXX handle drain efd, too */
if|if
condition|(
name|c
operator|->
name|efd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_WRITE
operator|&&
name|FD_ISSET
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|writeset
argument_list|)
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: written %d to efd %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|len
argument_list|,
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: closing write-efd %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|c
operator|->
name|local_consumed
operator|+=
name|len
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|efd
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_READ
operator|||
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_IGNORE
operator|)
operator|&&
operator|(
name|c
operator|->
name|detach_close
operator|||
name|FD_ISSET
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|readset
argument_list|)
operator|)
condition|)
block|{
name|len
operator|=
name|read
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: read %d from efd %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|len
argument_list|,
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
operator|(
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
operator|&&
operator|!
name|c
operator|->
name|detach_close
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: closing read-efd %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_IGNORE
condition|)
block|{
name|debug3
argument_list|(
literal|"channel %d: discard efd"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
else|else
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
specifier|static
name|int
name|channel_check_window
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_OPEN
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
operator|(
name|CHAN_CLOSE_SENT
operator||
name|CHAN_CLOSE_RCVD
operator|)
operator|)
operator|&&
operator|(
operator|(
name|c
operator|->
name|local_window_max
operator|-
name|c
operator|->
name|local_window
operator|>
name|c
operator|->
name|local_maxpacket
operator|*
literal|3
operator|)
operator|||
name|c
operator|->
name|local_window
operator|<
name|c
operator|->
name|local_window_max
operator|/
literal|2
operator|)
operator|&&
name|c
operator|->
name|local_consumed
operator|>
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_WINDOW_ADJUST
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_consumed
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: window %d sent adjust %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|local_window
argument_list|,
name|c
operator|->
name|local_consumed
argument_list|)
expr_stmt|;
name|c
operator|->
name|local_window
operator|+=
name|c
operator|->
name|local_consumed
expr_stmt|;
name|c
operator|->
name|local_consumed
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
specifier|static
name|void
name|channel_post_open
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|channel_handle_rfd
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
name|channel_handle_wfd
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compat20
condition|)
return|return;
name|channel_handle_efd
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
name|channel_check_window
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
specifier|static
name|u_int
name|read_mux
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|u_int
name|need
parameter_list|)
block|{
name|char
name|buf
index|[
name|CHAN_RBUF
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|<
name|need
condition|)
block|{
name|rlen
operator|=
name|need
operator|-
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|len
operator|=
name|read
argument_list|(
name|c
operator|->
name|rfd
argument_list|,
name|buf
argument_list|,
name|MINIMUM
argument_list|(
name|rlen
argument_list|,
name|CHAN_RBUF
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
return|return
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
return|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: ctl read<=0 rfd %d len %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|rfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|chan_read_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
return|;
block|}
specifier|static
name|void
name|channel_post_mux_client
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|u_int
name|need
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|compat20
condition|)
name|fatal
argument_list|(
literal|"%s: entered with !compat20"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|rfd
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|c
operator|->
name|mux_pause
operator|&&
name|FD_ISSET
argument_list|(
name|c
operator|->
name|rfd
argument_list|,
name|readset
argument_list|)
operator|&&
operator|(
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_OPEN
operator|||
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_WAIT_DRAIN
operator|)
condition|)
block|{
comment|/* 		 * Don't not read past the precise end of packets to 		 * avoid disrupting fd passing. 		 */
if|if
condition|(
name|read_mux
argument_list|(
name|c
argument_list|,
literal|4
argument_list|)
operator|<
literal|4
condition|)
comment|/* read header */
return|return;
name|need
operator|=
name|get_u32
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|CHANNEL_MUX_MAX_PACKET
value|(256 * 1024)
if|if
condition|(
name|need
operator|>
name|CHANNEL_MUX_MAX_PACKET
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: packet too big %u> %u"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|CHANNEL_MUX_MAX_PACKET
argument_list|,
name|need
argument_list|)
expr_stmt|;
name|chan_rcvd_oclose
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|read_mux
argument_list|(
name|c
argument_list|,
name|need
operator|+
literal|4
argument_list|)
operator|<
name|need
operator|+
literal|4
condition|)
comment|/* read body */
return|return;
if|if
condition|(
name|c
operator|->
name|mux_rcb
argument_list|(
name|c
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: mux_rcb failed"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|c
operator|->
name|wfd
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
name|writeset
argument_list|)
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
return|return;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|channel_post_mux_listener
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|Channel
modifier|*
name|nc
decl_stmt|;
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
name|int
name|newsock
decl_stmt|;
name|uid_t
name|euid
decl_stmt|;
name|gid_t
name|egid
decl_stmt|;
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
condition|)
return|return;
name|debug
argument_list|(
literal|"multiplexing control connection"
argument_list|)
expr_stmt|;
comment|/* 	 * Accept connection on control socket 	 */
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newsock
operator|=
name|accept
argument_list|(
name|c
operator|->
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s accept: %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EMFILE
operator|||
name|errno
operator|==
name|ENFILE
condition|)
name|c
operator|->
name|notbefore
operator|=
name|monotime
argument_list|()
operator|+
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|getpeereid
argument_list|(
name|newsock
argument_list|,
operator|&
name|euid
argument_list|,
operator|&
name|egid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s getpeereid failed: %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|euid
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|getuid
argument_list|()
operator|!=
name|euid
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"multiplex uid mismatch: peer euid %u != uid %u"
argument_list|,
operator|(
name|u_int
operator|)
name|euid
argument_list|,
operator|(
name|u_int
operator|)
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
return|return;
block|}
name|nc
operator|=
name|channel_new
argument_list|(
literal|"multiplex client"
argument_list|,
name|SSH_CHANNEL_MUX_CLIENT
argument_list|,
name|newsock
argument_list|,
name|newsock
argument_list|,
operator|-
literal|1
argument_list|,
name|c
operator|->
name|local_window_max
argument_list|,
name|c
operator|->
name|local_maxpacket
argument_list|,
literal|0
argument_list|,
literal|"mux-control"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nc
operator|->
name|mux_rcb
operator|=
name|c
operator|->
name|mux_rcb
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: new mux channel %d fd %d"
argument_list|,
name|__func__
argument_list|,
name|nc
operator|->
name|self
argument_list|,
name|nc
operator|->
name|sock
argument_list|)
expr_stmt|;
comment|/* establish state */
name|nc
operator|->
name|mux_rcb
argument_list|(
name|nc
argument_list|)
expr_stmt|;
comment|/* mux state transitions must not elicit protocol messages */
name|nc
operator|->
name|flags
operator||=
name|CHAN_LOCAL
expr_stmt|;
block|}
comment|/* ARGSUSED */
specifier|static
name|void
name|channel_post_output_drain_13
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* Send buffered output data to the socket. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|writeset
argument_list|)
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
else|else
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|channel_handler_init_20
parameter_list|(
name|void
parameter_list|)
block|{
name|channel_pre
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_pre_open
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_OPEN
index|]
operator|=
operator|&
name|channel_pre_x11_open
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_RPORT_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_UNIX_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_RUNIX_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_CONNECTING
index|]
operator|=
operator|&
name|channel_pre_connecting
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_DYNAMIC
index|]
operator|=
operator|&
name|channel_pre_dynamic
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_MUX_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_MUX_CLIENT
index|]
operator|=
operator|&
name|channel_pre_mux_client
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_post_open
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_post_port_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_RPORT_LISTENER
index|]
operator|=
operator|&
name|channel_post_port_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_UNIX_LISTENER
index|]
operator|=
operator|&
name|channel_post_port_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_RUNIX_LISTENER
index|]
operator|=
operator|&
name|channel_post_port_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_post_x11_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_post_auth_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_CONNECTING
index|]
operator|=
operator|&
name|channel_post_connecting
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_DYNAMIC
index|]
operator|=
operator|&
name|channel_post_open
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_MUX_LISTENER
index|]
operator|=
operator|&
name|channel_post_mux_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_MUX_CLIENT
index|]
operator|=
operator|&
name|channel_post_mux_client
expr_stmt|;
block|}
specifier|static
name|void
name|channel_handler_init_13
parameter_list|(
name|void
parameter_list|)
block|{
name|channel_pre
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_pre_open_13
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_OPEN
index|]
operator|=
operator|&
name|channel_pre_x11_open_13
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_INPUT_DRAINING
index|]
operator|=
operator|&
name|channel_pre_input_draining
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_OUTPUT_DRAINING
index|]
operator|=
operator|&
name|channel_pre_output_draining
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_CONNECTING
index|]
operator|=
operator|&
name|channel_pre_connecting
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_DYNAMIC
index|]
operator|=
operator|&
name|channel_pre_dynamic
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_post_open
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_post_x11_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_post_port_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_post_auth_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_OUTPUT_DRAINING
index|]
operator|=
operator|&
name|channel_post_output_drain_13
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_CONNECTING
index|]
operator|=
operator|&
name|channel_post_connecting
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_DYNAMIC
index|]
operator|=
operator|&
name|channel_post_open
expr_stmt|;
block|}
specifier|static
name|void
name|channel_handler_init_15
parameter_list|(
name|void
parameter_list|)
block|{
name|channel_pre
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_pre_open
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_OPEN
index|]
operator|=
operator|&
name|channel_pre_x11_open
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_CONNECTING
index|]
operator|=
operator|&
name|channel_pre_connecting
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_DYNAMIC
index|]
operator|=
operator|&
name|channel_pre_dynamic
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_post_x11_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_post_port_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_post_auth_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_post_open
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_CONNECTING
index|]
operator|=
operator|&
name|channel_post_connecting
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_DYNAMIC
index|]
operator|=
operator|&
name|channel_post_open
expr_stmt|;
block|}
specifier|static
name|void
name|channel_handler_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SSH_CHANNEL_MAX_TYPE
condition|;
name|i
operator|++
control|)
block|{
name|channel_pre
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|channel_post
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|compat20
condition|)
name|channel_handler_init_20
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|compat13
condition|)
name|channel_handler_init_13
argument_list|()
expr_stmt|;
else|else
name|channel_handler_init_15
argument_list|()
expr_stmt|;
block|}
comment|/* gc dead channels */
specifier|static
name|void
name|channel_garbage_collect
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|c
operator|->
name|detach_user
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|chan_is_dead
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|detach_close
argument_list|)
condition|)
return|return;
name|debug2
argument_list|(
literal|"channel %d: gc: notify user"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|c
operator|->
name|detach_user
argument_list|(
name|c
operator|->
name|self
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* if we still have a callback */
if|if
condition|(
name|c
operator|->
name|detach_user
operator|!=
name|NULL
condition|)
return|return;
name|debug2
argument_list|(
literal|"channel %d: gc: user detached"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|chan_is_dead
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|debug2
argument_list|(
literal|"channel %d: garbage collecting"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|channel_handler
parameter_list|(
name|chan_fn
modifier|*
name|ftab
index|[]
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|,
name|time_t
modifier|*
name|unpause_secs
parameter_list|)
block|{
specifier|static
name|int
name|did_init
init|=
literal|0
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|oalloc
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|time_t
name|now
decl_stmt|;
if|if
condition|(
operator|!
name|did_init
condition|)
block|{
name|channel_handler_init
argument_list|()
expr_stmt|;
name|did_init
operator|=
literal|1
expr_stmt|;
block|}
name|now
operator|=
name|monotime
argument_list|()
expr_stmt|;
if|if
condition|(
name|unpause_secs
operator|!=
name|NULL
condition|)
operator|*
name|unpause_secs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|oalloc
operator|=
name|channels_alloc
init|;
name|i
operator|<
name|oalloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|c
operator|->
name|delayed
condition|)
block|{
if|if
condition|(
name|ftab
operator|==
name|channel_pre
condition|)
name|c
operator|->
name|delayed
operator|=
literal|0
expr_stmt|;
else|else
continue|continue;
block|}
if|if
condition|(
name|ftab
index|[
name|c
operator|->
name|type
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Run handlers that are not paused. 			 */
if|if
condition|(
name|c
operator|->
name|notbefore
operator|<=
name|now
condition|)
call|(
modifier|*
name|ftab
index|[
name|c
operator|->
name|type
index|]
call|)
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unpause_secs
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Collect the time that the earliest 				 * channel comes off pause. 				 */
name|debug3
argument_list|(
literal|"%s: chan %d: skip for %d more seconds"
argument_list|,
name|__func__
argument_list|,
name|c
operator|->
name|self
argument_list|,
call|(
name|int
call|)
argument_list|(
name|c
operator|->
name|notbefore
operator|-
name|now
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|unpause_secs
operator|==
literal|0
operator|||
operator|(
name|c
operator|->
name|notbefore
operator|-
name|now
operator|)
operator|<
operator|*
name|unpause_secs
condition|)
operator|*
name|unpause_secs
operator|=
name|c
operator|->
name|notbefore
operator|-
name|now
expr_stmt|;
block|}
block|}
name|channel_garbage_collect
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unpause_secs
operator|!=
name|NULL
operator|&&
operator|*
name|unpause_secs
operator|!=
literal|0
condition|)
name|debug3
argument_list|(
literal|"%s: first channel unpauses in %d seconds"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
operator|*
name|unpause_secs
argument_list|)
expr_stmt|;
block|}
comment|/*  * Allocate/update select bitmasks and add any bits relevant to channels in  * select bitmasks.  */
name|void
name|channel_prepare_select
parameter_list|(
name|fd_set
modifier|*
modifier|*
name|readsetp
parameter_list|,
name|fd_set
modifier|*
modifier|*
name|writesetp
parameter_list|,
name|int
modifier|*
name|maxfdp
parameter_list|,
name|u_int
modifier|*
name|nallocp
parameter_list|,
name|time_t
modifier|*
name|minwait_secs
parameter_list|,
name|int
name|rekeying
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|,
name|sz
decl_stmt|,
name|nfdset
decl_stmt|;
name|n
operator|=
name|MAXIMUM
argument_list|(
operator|*
name|maxfdp
argument_list|,
name|channel_max_fd
argument_list|)
expr_stmt|;
name|nfdset
operator|=
name|howmany
argument_list|(
name|n
operator|+
literal|1
argument_list|,
name|NFDBITS
argument_list|)
expr_stmt|;
comment|/* Explicitly test here, because xrealloc isn't always called */
if|if
condition|(
name|nfdset
operator|&&
name|SIZE_MAX
operator|/
name|nfdset
operator|<
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"channel_prepare_select: max_fd (%d) is too large"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|sz
operator|=
name|nfdset
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
expr_stmt|;
comment|/* perhaps check sz< nalloc/2 and shrink? */
if|if
condition|(
operator|*
name|readsetp
operator|==
name|NULL
operator|||
name|sz
operator|>
operator|*
name|nallocp
condition|)
block|{
operator|*
name|readsetp
operator|=
name|xreallocarray
argument_list|(
operator|*
name|readsetp
argument_list|,
name|nfdset
argument_list|,
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|writesetp
operator|=
name|xreallocarray
argument_list|(
operator|*
name|writesetp
argument_list|,
name|nfdset
argument_list|,
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|nallocp
operator|=
name|sz
expr_stmt|;
block|}
operator|*
name|maxfdp
operator|=
name|n
expr_stmt|;
name|memset
argument_list|(
operator|*
name|readsetp
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|writesetp
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rekeying
condition|)
name|channel_handler
argument_list|(
name|channel_pre
argument_list|,
operator|*
name|readsetp
argument_list|,
operator|*
name|writesetp
argument_list|,
name|minwait_secs
argument_list|)
expr_stmt|;
block|}
comment|/*  * After select, perform any appropriate operations for channels which have  * events pending.  */
name|void
name|channel_after_select
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|channel_handler
argument_list|(
name|channel_post
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* If there is data to send to the connection, enqueue some of it now. */
name|void
name|channel_output_poll
parameter_list|(
name|void
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|len
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * We are only interested in channels that can have buffered 		 * incoming data. 		 */
if|if
condition|(
name|compat13
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
operator|&&
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_INPUT_DRAINING
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
condition|)
continue|continue;
block|}
if|if
condition|(
name|compat20
operator|&&
operator|(
name|c
operator|->
name|flags
operator|&
operator|(
name|CHAN_CLOSE_SENT
operator||
name|CHAN_CLOSE_RCVD
operator|)
operator|)
condition|)
block|{
comment|/* XXX is this true? */
name|debug3
argument_list|(
literal|"channel %d: will not send data after close"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the amount of buffered data for this channel. */
if|if
condition|(
operator|(
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_OPEN
operator|||
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_WAIT_DRAIN
operator|)
operator|&&
operator|(
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|datagram
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|u_char
modifier|*
name|data
decl_stmt|;
name|u_int
name|dlen
decl_stmt|;
name|data
operator|=
name|buffer_get_string
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
operator|&
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlen
operator|>
name|c
operator|->
name|remote_window
operator|||
name|dlen
operator|>
name|c
operator|->
name|remote_maxpacket
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: datagram "
literal|"too big for channel"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_DATA
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|data
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|c
operator|->
name|remote_window
operator|-=
name|dlen
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 			 * Send some data for the other side over the secure 			 * connection. 			 */
if|if
condition|(
name|compat20
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|c
operator|->
name|remote_window
condition|)
name|len
operator|=
name|c
operator|->
name|remote_window
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|c
operator|->
name|remote_maxpacket
condition|)
name|len
operator|=
name|c
operator|->
name|remote_maxpacket
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|packet_is_interactive
argument_list|()
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|1024
condition|)
name|len
operator|=
literal|512
expr_stmt|;
block|}
else|else
block|{
comment|/* Keep the packets at reasonable size. */
if|if
condition|(
name|len
operator|>
name|packet_get_maxsize
argument_list|()
operator|/
literal|2
condition|)
name|len
operator|=
name|packet_get_maxsize
argument_list|()
operator|/
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|compat20
condition|?
name|SSH2_MSG_CHANNEL_DATA
else|:
name|SSH_MSG_CHANNEL_DATA
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_window
operator|-=
name|len
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_WAIT_DRAIN
condition|)
block|{
if|if
condition|(
name|compat13
condition|)
name|fatal
argument_list|(
literal|"cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3"
argument_list|)
expr_stmt|;
comment|/* 			 * input-buffer is empty and read-socket shutdown: 			 * tell peer, that we will not send more data: send IEOF. 			 * hack for extended data: delay EOF if EFD still in use. 			 */
if|if
condition|(
name|CHANNEL_EFD_INPUT_ACTIVE
argument_list|(
name|c
argument_list|)
condition|)
name|debug2
argument_list|(
literal|"channel %d: ibuf_empty delayed efd %d/(%d)"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|efd
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|chan_ibuf_empty
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Send extended data, i.e. stderr */
if|if
condition|(
name|compat20
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHAN_EOF_SENT
operator|)
operator|&&
name|c
operator|->
name|remote_window
operator|>
literal|0
operator|&&
operator|(
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_READ
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: rwin %u elen %u euse %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|remote_window
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
argument_list|,
name|c
operator|->
name|extended_usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|c
operator|->
name|remote_window
condition|)
name|len
operator|=
name|c
operator|->
name|remote_window
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|c
operator|->
name|remote_maxpacket
condition|)
name|len
operator|=
name|c
operator|->
name|remote_maxpacket
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_EXTENDED_DATA
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|SSH2_EXTENDED_DATA_STDERR
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_window
operator|-=
name|len
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: sent ext data %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* -- mux proxy support  */
comment|/*  * When multiplexing channel messages for mux clients we have to deal  * with downstream messages from the mux client and upstream messages  * from the ssh server:  * 1) Handling downstream messages is straightforward and happens  *    in channel_proxy_downstream():  *    - We forward all messages (mostly) unmodified to the server.  *    - However, in order to route messages from upstream to the correct  *      downstream client, we have to replace the channel IDs used by the  *      mux clients with a unique channel ID because the mux clients might  *      use conflicting channel IDs.  *    - so we inspect and change both SSH2_MSG_CHANNEL_OPEN and  *      SSH2_MSG_CHANNEL_OPEN_CONFIRMATION messages, create a local  *      SSH_CHANNEL_MUX_PROXY channel and replace the mux clients ID  *      with the newly allocated channel ID.  * 2) Upstream messages are received by matching SSH_CHANNEL_MUX_PROXY  *    channels and procesed by channel_proxy_upstream(). The local channel ID  *    is then translated back to the original mux client ID.  * 3) In both cases we need to keep track of matching SSH2_MSG_CHANNEL_CLOSE  *    messages so we can clean up SSH_CHANNEL_MUX_PROXY channels.  * 4) The SSH_CHANNEL_MUX_PROXY channels also need to closed when the  *    downstream mux client are removed.  * 5) Handling SSH2_MSG_CHANNEL_OPEN messages from the upstream server  *    requires more work, because they are not addressed to a specific  *    channel. E.g. client_request_forwarded_tcpip() needs to figure  *    out whether the request is addressed to the local client or a  *    specific downstream client based on the listen-address/port.  * 6) Agent and X11-Forwarding have a similar problem and are currenly  *    not supported as the matching session/channel cannot be identified  *    easily.  */
comment|/*  * receive packets from downstream mux clients:  * channel callback fired on read from mux client, creates  * SSH_CHANNEL_MUX_PROXY channels and translates channel IDs  * on channel creation.  */
name|int
name|channel_proxy_downstream
parameter_list|(
name|Channel
modifier|*
name|downstream
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|struct
name|ssh
modifier|*
name|ssh
init|=
name|active_state
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|original
init|=
name|NULL
decl_stmt|,
modifier|*
name|modified
init|=
name|NULL
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|ctype
init|=
name|NULL
decl_stmt|,
modifier|*
name|listen_host
init|=
name|NULL
decl_stmt|;
name|u_char
name|type
decl_stmt|;
name|size_t
name|have
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|,
name|r
decl_stmt|,
name|idx
decl_stmt|;
name|u_int
name|id
decl_stmt|,
name|remote_id
decl_stmt|,
name|listen_port
decl_stmt|;
comment|/* sshbuf_dump(&downstream->input, stderr); */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_string_direct
argument_list|(
operator|&
name|downstream
operator|->
name|input
argument_list|,
operator|&
name|cp
argument_list|,
operator|&
name|have
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: malformed message: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|have
operator|<
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"%s: short message"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|type
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
comment|/* skip padlen + type */
name|cp
operator|+=
literal|2
expr_stmt|;
name|have
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|ssh_packet_log_type
argument_list|(
name|type
argument_list|)
condition|)
name|debug3
argument_list|(
literal|"%s: channel %u: down->up: type %u"
argument_list|,
name|__func__
argument_list|,
name|downstream
operator|->
name|self
argument_list|,
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SSH2_MSG_CHANNEL_OPEN
case|:
if|if
condition|(
operator|(
name|original
operator|=
name|sshbuf_from
argument_list|(
name|cp
argument_list|,
name|have
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|modified
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: alloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_cstring
argument_list|(
name|original
argument_list|,
operator|&
name|ctype
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_u32
argument_list|(
name|original
argument_list|,
operator|&
name|id
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: parse error %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|c
operator|=
name|channel_new
argument_list|(
literal|"mux proxy"
argument_list|,
name|SSH_CHANNEL_MUX_PROXY
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ctype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|mux_ctx
operator|=
name|downstream
expr_stmt|;
comment|/* point to mux client */
name|c
operator|->
name|mux_downstream_id
operator|=
name|id
expr_stmt|;
comment|/* original downstream id */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_cstring
argument_list|(
name|modified
argument_list|,
name|ctype
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|modified
argument_list|,
name|c
operator|->
name|self
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_putb
argument_list|(
name|modified
argument_list|,
name|original
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: compose error %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
case|:
comment|/* 		 * Almost the same as SSH2_MSG_CHANNEL_OPEN, except then we 		 * need to parse 'remote_id' instead of 'ctype'. 		 */
if|if
condition|(
operator|(
name|original
operator|=
name|sshbuf_from
argument_list|(
name|cp
argument_list|,
name|have
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|modified
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: alloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u32
argument_list|(
name|original
argument_list|,
operator|&
name|remote_id
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_u32
argument_list|(
name|original
argument_list|,
operator|&
name|id
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: parse error %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|c
operator|=
name|channel_new
argument_list|(
literal|"mux proxy"
argument_list|,
name|SSH_CHANNEL_MUX_PROXY
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"mux-down-connect"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|mux_ctx
operator|=
name|downstream
expr_stmt|;
comment|/* point to mux client */
name|c
operator|->
name|mux_downstream_id
operator|=
name|id
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
name|remote_id
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|modified
argument_list|,
name|remote_id
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|modified
argument_list|,
name|c
operator|->
name|self
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_putb
argument_list|(
name|modified
argument_list|,
name|original
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: compose error %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|SSH2_MSG_GLOBAL_REQUEST
case|:
if|if
condition|(
operator|(
name|original
operator|=
name|sshbuf_from
argument_list|(
name|cp
argument_list|,
name|have
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: alloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_cstring
argument_list|(
name|original
argument_list|,
operator|&
name|ctype
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: parse error %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"tcpip-forward"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: unsupported request %s"
argument_list|,
name|__func__
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u8
argument_list|(
name|original
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_cstring
argument_list|(
name|original
argument_list|,
operator|&
name|listen_host
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_u32
argument_list|(
name|original
argument_list|,
operator|&
name|listen_port
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: parse error %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|listen_port
operator|>
literal|65535
condition|)
block|{
name|error
argument_list|(
literal|"%s: tcpip-forward for %s: bad port %u"
argument_list|,
name|__func__
argument_list|,
name|listen_host
argument_list|,
name|listen_port
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Record that connection to this host/port is permitted. */
name|permitted_opens
operator|=
name|xreallocarray
argument_list|(
name|permitted_opens
argument_list|,
name|num_permitted_opens
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|permitted_opens
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|=
name|num_permitted_opens
operator|++
expr_stmt|;
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|host_to_connect
operator|=
name|xstrdup
argument_list|(
literal|"<mux>"
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|port_to_connect
operator|=
operator|-
literal|1
expr_stmt|;
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|listen_host
operator|=
name|listen_host
expr_stmt|;
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|listen_port
operator|=
operator|(
name|int
operator|)
name|listen_port
expr_stmt|;
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|downstream
operator|=
name|downstream
expr_stmt|;
name|listen_host
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|SSH2_MSG_CHANNEL_CLOSE
case|:
if|if
condition|(
name|have
operator|<
literal|4
condition|)
break|break;
name|remote_id
operator|=
name|PEEK_U32
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|channel_by_remote_id
argument_list|(
name|remote_id
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHAN_CLOSE_RCVD
condition|)
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|c
operator|->
name|flags
operator||=
name|CHAN_CLOSE_SENT
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|modified
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshpkt_start
argument_list|(
name|ssh
argument_list|,
name|type
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshpkt_putb
argument_list|(
name|ssh
argument_list|,
name|modified
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshpkt_send
argument_list|(
name|ssh
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: send %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshpkt_start
argument_list|(
name|ssh
argument_list|,
name|type
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshpkt_put
argument_list|(
name|ssh
argument_list|,
name|cp
argument_list|,
name|have
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshpkt_send
argument_list|(
name|ssh
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: send %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|listen_host
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|original
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|modified
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/*  * receive packets from upstream server and de-multiplex packets  * to correct downstream:  * implemented as a helper for channel input handlers,  * replaces local (proxy) channel ID with downstream channel ID.  */
name|int
name|channel_proxy_upstream
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|struct
name|ssh
modifier|*
name|ssh
init|=
name|active_state
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|Channel
modifier|*
name|downstream
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* 	 * When receiving packets from the peer we need to check whether we 	 * need to forward the packets to the mux client. In this case we 	 * restore the orignal channel id and keep track of CLOSE messages, 	 * so we can cleanup the channel. 	 */
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_MUX_PROXY
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|downstream
operator|=
name|c
operator|->
name|mux_ctx
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SSH2_MSG_CHANNEL_CLOSE
case|:
case|case
name|SSH2_MSG_CHANNEL_DATA
case|:
case|case
name|SSH2_MSG_CHANNEL_EOF
case|:
case|case
name|SSH2_MSG_CHANNEL_EXTENDED_DATA
case|:
case|case
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
case|:
case|case
name|SSH2_MSG_CHANNEL_OPEN_FAILURE
case|:
case|case
name|SSH2_MSG_CHANNEL_WINDOW_ADJUST
case|:
case|case
name|SSH2_MSG_CHANNEL_SUCCESS
case|:
case|case
name|SSH2_MSG_CHANNEL_FAILURE
case|:
case|case
name|SSH2_MSG_CHANNEL_REQUEST
case|:
break|break;
default|default:
name|debug2
argument_list|(
literal|"%s: channel %u: unsupported type %u"
argument_list|,
name|__func__
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|b
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: alloc reply"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* get remaining payload (after id) */
name|cp
operator|=
name|sshpkt_ptr
argument_list|(
name|ssh
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: no packet"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* translate id and send to muxclient */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|||
comment|/* padlen */
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|b
argument_list|,
name|type
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|b
argument_list|,
name|c
operator|->
name|mux_downstream_id
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put
argument_list|(
name|b
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_stringb
argument_list|(
operator|&
name|downstream
operator|->
name|output
argument_list|,
name|b
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: compose for muxclient %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* sshbuf_dump(b, stderr); */
if|if
condition|(
name|ssh_packet_log_type
argument_list|(
name|type
argument_list|)
condition|)
name|debug3
argument_list|(
literal|"%s: channel %u: up->down: type %u"
argument_list|,
name|__func__
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* update state */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
case|:
comment|/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */
if|if
condition|(
name|cp
operator|&&
name|len
operator|>
literal|4
condition|)
name|c
operator|->
name|remote_id
operator|=
name|PEEK_U32
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH2_MSG_CHANNEL_CLOSE
case|:
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHAN_CLOSE_SENT
condition|)
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|c
operator|->
name|flags
operator||=
name|CHAN_CLOSE_RCVD
expr_stmt|;
break|break;
block|}
name|sshbuf_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* -- protocol input */
comment|/* ARGSUSED */
name|int
name|channel_input_data
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|data
decl_stmt|;
name|u_int
name|data_len
decl_stmt|,
name|win_len
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
comment|/* Get the channel number and verify it. */
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received data for nonexistent channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel_proxy_upstream
argument_list|(
name|c
argument_list|,
name|type
argument_list|,
name|seq
argument_list|,
name|ctxt
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Ignore any data for non-open channels (might happen on close) */
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
operator|&&
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_X11_OPEN
condition|)
return|return
literal|0
return|;
comment|/* Get the data. */
name|data
operator|=
name|packet_get_string_ptr
argument_list|(
operator|&
name|data_len
argument_list|)
expr_stmt|;
name|win_len
operator|=
name|data_len
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|datagram
condition|)
name|win_len
operator|+=
literal|4
expr_stmt|;
comment|/* string length header */
comment|/* 	 * Ignore data for protocol> 1.3 if output end is no longer open. 	 * For protocol 2 the sending side is reducing its window as it sends 	 * data, so we must 'fake' consumption of the data in order to ensure 	 * that window updates are sent back.  Otherwise the connection might 	 * deadlock. 	 */
if|if
condition|(
operator|!
name|compat13
operator|&&
name|c
operator|->
name|ostate
operator|!=
name|CHAN_OUTPUT_OPEN
condition|)
block|{
if|if
condition|(
name|compat20
condition|)
block|{
name|c
operator|->
name|local_window
operator|-=
name|win_len
expr_stmt|;
name|c
operator|->
name|local_consumed
operator|+=
name|win_len
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|compat20
condition|)
block|{
if|if
condition|(
name|win_len
operator|>
name|c
operator|->
name|local_maxpacket
condition|)
block|{
name|logit
argument_list|(
literal|"channel %d: rcvd big packet %d, maxpack %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|win_len
argument_list|,
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|win_len
operator|>
name|c
operator|->
name|local_window
condition|)
block|{
name|logit
argument_list|(
literal|"channel %d: rcvd too much data %d, win %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|win_len
argument_list|,
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|->
name|local_window
operator|-=
name|win_len
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|datagram
condition|)
name|buffer_put_string
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
else|else
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* ARGSUSED */
name|int
name|channel_input_extended_data
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|u_int
name|data_len
decl_stmt|,
name|tcode
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
comment|/* Get the channel number and verify it. */
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received extended_data for bad channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel_proxy_upstream
argument_list|(
name|c
argument_list|,
name|type
argument_list|,
name|seq
argument_list|,
name|ctxt
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
condition|)
block|{
name|logit
argument_list|(
literal|"channel %d: ext data for non open"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHAN_EOF_RCVD
condition|)
block|{
if|if
condition|(
name|datafellows
operator|&
name|SSH_BUG_EXTEOF
condition|)
name|debug
argument_list|(
literal|"channel %d: accepting ext data after eof"
argument_list|,
name|id
argument_list|)
expr_stmt|;
else|else
name|packet_disconnect
argument_list|(
literal|"Received extended_data after EOF "
literal|"on channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|tcode
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|efd
operator|==
operator|-
literal|1
operator|||
name|c
operator|->
name|extended_usage
operator|!=
name|CHAN_EXTENDED_WRITE
operator|||
name|tcode
operator|!=
name|SSH2_EXTENDED_DATA_STDERR
condition|)
block|{
name|logit
argument_list|(
literal|"channel %d: bad ext data"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|data
operator|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
if|if
condition|(
name|data_len
operator|>
name|c
operator|->
name|local_window
condition|)
block|{
name|logit
argument_list|(
literal|"channel %d: rcvd too much extended_data %d, win %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|data_len
argument_list|,
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|debug2
argument_list|(
literal|"channel %d: rcvd ext data %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|c
operator|->
name|local_window
operator|-=
name|data_len
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* ARGSUSED */
name|int
name|channel_input_ieof
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received ieof for nonexistent channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel_proxy_upstream
argument_list|(
name|c
argument_list|,
name|type
argument_list|,
name|seq
argument_list|,
name|ctxt
argument_list|)
condition|)
return|return
literal|0
return|;
name|chan_rcvd_ieof
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* XXX force input close */
if|if
condition|(
name|c
operator|->
name|force_drain
operator|&&
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_OPEN
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: FORCE input drain"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|c
operator|->
name|istate
operator|=
name|CHAN_INPUT_WAIT_DRAIN
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|==
literal|0
condition|)
name|chan_ibuf_empty
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* ARGSUSED */
name|int
name|channel_input_close
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received close for nonexistent channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel_proxy_upstream
argument_list|(
name|c
argument_list|,
name|type
argument_list|,
name|seq
argument_list|,
name|ctxt
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * Send a confirmation that we have closed the channel and no more 	 * data is coming for it. 	 */
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* 	 * If the channel is in closed state, we have sent a close request, 	 * and the other side will eventually respond with a confirmation. 	 * Thus, we cannot free the channel here, because then there would be 	 * no-one to receive the confirmation.  The channel gets freed when 	 * the confirmation arrives. 	 */
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_CLOSED
condition|)
block|{
comment|/* 		 * Not a closed channel - mark it as draining, which will 		 * cause it to be freed later. 		 */
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OUTPUT_DRAINING
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* proto version 1.5 overloads CLOSE_CONFIRMATION with OCLOSE */
comment|/* ARGSUSED */
name|int
name|channel_input_oclose
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received oclose for nonexistent channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel_proxy_upstream
argument_list|(
name|c
argument_list|,
name|type
argument_list|,
name|seq
argument_list|,
name|ctxt
argument_list|)
condition|)
return|return
literal|0
return|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|chan_rcvd_oclose
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* ARGSUSED */
name|int
name|channel_input_close_confirmation
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received close confirmation for "
literal|"out-of-range channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel_proxy_upstream
argument_list|(
name|c
argument_list|,
name|type
argument_list|,
name|seq
argument_list|,
name|ctxt
argument_list|)
condition|)
return|return
literal|0
return|;
name|packet_check_eom
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_CLOSED
operator|&&
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_ABANDONED
condition|)
name|packet_disconnect
argument_list|(
literal|"Received close confirmation for "
literal|"non-closed channel %d (type %d)."
argument_list|,
name|id
argument_list|,
name|c
operator|->
name|type
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* ARGSUSED */
name|int
name|channel_input_open_confirmation
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|,
name|remote_id
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received open confirmation for "
literal|"unknown channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel_proxy_upstream
argument_list|(
name|c
argument_list|,
name|type
argument_list|,
name|seq
argument_list|,
name|ctxt
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPENING
condition|)
name|packet_disconnect
argument_list|(
literal|"Received open confirmation for "
literal|"non-opening channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|remote_id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
comment|/* Record the remote channel number and mark that the channel is now open. */
name|c
operator|->
name|remote_id
operator|=
name|remote_id
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|c
operator|->
name|remote_window
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|->
name|remote_maxpacket
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|open_confirm
condition|)
block|{
name|debug2
argument_list|(
literal|"callback start"
argument_list|)
expr_stmt|;
name|c
operator|->
name|open_confirm
argument_list|(
name|c
operator|->
name|self
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|open_confirm_ctx
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"callback done"
argument_list|)
expr_stmt|;
block|}
name|debug2
argument_list|(
literal|"channel %d: open confirm rwindow %u rmax %u"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|remote_window
argument_list|,
name|c
operator|->
name|remote_maxpacket
argument_list|)
expr_stmt|;
block|}
name|packet_check_eom
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|char
modifier|*
name|reason2txt
parameter_list|(
name|int
name|reason
parameter_list|)
block|{
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED
case|:
return|return
literal|"administratively prohibited"
return|;
case|case
name|SSH2_OPEN_CONNECT_FAILED
case|:
return|return
literal|"connect failed"
return|;
case|case
name|SSH2_OPEN_UNKNOWN_CHANNEL_TYPE
case|:
return|return
literal|"unknown channel type"
return|;
case|case
name|SSH2_OPEN_RESOURCE_SHORTAGE
case|:
return|return
literal|"resource shortage"
return|;
block|}
return|return
literal|"unknown reason"
return|;
block|}
comment|/* ARGSUSED */
name|int
name|channel_input_open_failure
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|,
name|reason
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|,
modifier|*
name|lang
init|=
name|NULL
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received open failure for "
literal|"unknown channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel_proxy_upstream
argument_list|(
name|c
argument_list|,
name|type
argument_list|,
name|seq
argument_list|,
name|ctxt
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPENING
condition|)
name|packet_disconnect
argument_list|(
literal|"Received open failure for "
literal|"non-opening channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|reason
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|datafellows
operator|&
name|SSH_BUG_OPENFAILURE
operator|)
condition|)
block|{
name|msg
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|lang
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|logit
argument_list|(
literal|"channel %d: open failed: %s%s%s"
argument_list|,
name|id
argument_list|,
name|reason2txt
argument_list|(
name|reason
argument_list|)
argument_list|,
name|msg
condition|?
literal|": "
else|:
literal|""
argument_list|,
name|msg
condition|?
name|msg
else|:
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lang
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|open_confirm
condition|)
block|{
name|debug2
argument_list|(
literal|"callback start"
argument_list|)
expr_stmt|;
name|c
operator|->
name|open_confirm
argument_list|(
name|c
operator|->
name|self
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|open_confirm_ctx
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"callback done"
argument_list|)
expr_stmt|;
block|}
block|}
name|packet_check_eom
argument_list|()
expr_stmt|;
comment|/* Schedule the channel for cleanup/deletion. */
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* ARGSUSED */
name|int
name|channel_input_window_adjust
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
name|int
name|id
decl_stmt|;
name|u_int
name|adjust
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|compat20
condition|)
return|return
literal|0
return|;
comment|/* Get the channel number and verify it. */
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|logit
argument_list|(
literal|"Received window adjust for non-open channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|channel_proxy_upstream
argument_list|(
name|c
argument_list|,
name|type
argument_list|,
name|seq
argument_list|,
name|ctxt
argument_list|)
condition|)
return|return
literal|0
return|;
name|adjust
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: rcvd adjust %u"
argument_list|,
name|id
argument_list|,
name|adjust
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|c
operator|->
name|remote_window
operator|+
name|adjust
operator|)
operator|<
name|c
operator|->
name|remote_window
condition|)
name|fatal
argument_list|(
literal|"channel %d: adjust %u overflows remote window %u"
argument_list|,
name|id
argument_list|,
name|adjust
argument_list|,
name|c
operator|->
name|remote_window
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_window
operator|=
name|tmp
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* ARGSUSED */
name|int
name|channel_input_port_open
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|u_short
name|host_port
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|,
modifier|*
name|originator_string
decl_stmt|;
name|int
name|remote_id
decl_stmt|;
name|remote_id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|host
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|host_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|packet_get_protocol_flags
argument_list|()
operator|&
name|SSH_PROTOFLAG_HOST_IN_FWD_OPEN
condition|)
block|{
name|originator_string
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|originator_string
operator|=
name|xstrdup
argument_list|(
literal|"unknown (remote did not supply name)"
argument_list|)
expr_stmt|;
block|}
name|packet_check_eom
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_connect_to_port
argument_list|(
name|host
argument_list|,
name|host_port
argument_list|,
literal|"connected socket"
argument_list|,
name|originator_string
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|originator_string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
name|c
operator|->
name|remote_id
operator|=
name|remote_id
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* ARGSUSED */
name|int
name|channel_input_status_confirm
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
name|struct
name|channel_confirm
modifier|*
name|cc
decl_stmt|;
name|int
name|id
decl_stmt|;
comment|/* Reset keepalive timeout */
name|packet_set_alive_timeouts
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|debug2
argument_list|(
literal|"channel_input_status_confirm: type %d id %d"
argument_list|,
name|type
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|logit
argument_list|(
literal|"channel_input_status_confirm: %d: unknown"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|channel_proxy_upstream
argument_list|(
name|c
argument_list|,
name|type
argument_list|,
name|seq
argument_list|,
name|ctxt
argument_list|)
condition|)
return|return
literal|0
return|;
name|packet_check_eom
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|c
operator|->
name|status_confirms
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|cc
operator|->
name|cb
argument_list|(
name|type
argument_list|,
name|c
argument_list|,
name|cc
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|c
operator|->
name|status_confirms
argument_list|,
name|cc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|cc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cc
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* -- tcp forwarding */
name|void
name|channel_set_af
parameter_list|(
name|int
name|af
parameter_list|)
block|{
name|IPv4or6
operator|=
name|af
expr_stmt|;
block|}
comment|/*  * Determine whether or not a port forward listens to loopback, the  * specified address or wildcard. On the client, a specified bind  * address will always override gateway_ports. On the server, a  * gateway_ports of 1 (``yes'') will override the client's specification  * and force a wildcard bind, whereas a value of 2 (``clientspecified'')  * will bind to whatever address the client asked for.  *  * Special-case listen_addrs are:  *  * "0.0.0.0"               -> wildcard v4/v6 if SSH_OLD_FORWARD_ADDR  * "" (empty string), "*"  -> wildcard v4/v6  * "localhost"             -> loopback v4/v6  * "127.0.0.1" / "::1"     -> accepted even if gateway_ports isn't set  */
specifier|static
specifier|const
name|char
modifier|*
name|channel_fwd_bind_addr
parameter_list|(
specifier|const
name|char
modifier|*
name|listen_addr
parameter_list|,
name|int
modifier|*
name|wildcardp
parameter_list|,
name|int
name|is_client
parameter_list|,
name|struct
name|ForwardOptions
modifier|*
name|fwd_opts
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|addr
init|=
name|NULL
decl_stmt|;
name|int
name|wildcard
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|listen_addr
operator|==
name|NULL
condition|)
block|{
comment|/* No address specified: default to gateway_ports setting */
if|if
condition|(
name|fwd_opts
operator|->
name|gateway_ports
condition|)
name|wildcard
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fwd_opts
operator|->
name|gateway_ports
operator|||
name|is_client
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|datafellows
operator|&
name|SSH_OLD_FORWARD_ADDR
operator|)
operator|&&
name|strcmp
argument_list|(
name|listen_addr
argument_list|,
literal|"0.0.0.0"
argument_list|)
operator|==
literal|0
operator|&&
name|is_client
operator|==
literal|0
operator|)
operator|||
operator|*
name|listen_addr
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|listen_addr
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|!
name|is_client
operator|&&
name|fwd_opts
operator|->
name|gateway_ports
operator|==
literal|1
operator|)
condition|)
block|{
name|wildcard
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Notify client if they requested a specific listen 			 * address and it was overridden. 			 */
if|if
condition|(
operator|*
name|listen_addr
operator|!=
literal|'\0'
operator|&&
name|strcmp
argument_list|(
name|listen_addr
argument_list|,
literal|"0.0.0.0"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|listen_addr
argument_list|,
literal|"*"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|packet_send_debug
argument_list|(
literal|"Forwarding listen address "
literal|"\"%s\" overridden by server "
literal|"GatewayPorts"
argument_list|,
name|listen_addr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|listen_addr
argument_list|,
literal|"localhost"
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|listen_addr
argument_list|,
literal|"127.0.0.1"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|listen_addr
argument_list|,
literal|"::1"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Accept localhost address when GatewayPorts=yes */
name|addr
operator|=
name|listen_addr
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|listen_addr
argument_list|,
literal|"127.0.0.1"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|listen_addr
argument_list|,
literal|"::1"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If a specific IPv4/IPv6 localhost address has been 		 * requested then accept it even if gateway_ports is in 		 * effect. This allows the client to prefer IPv4 or IPv6. 		 */
name|addr
operator|=
name|listen_addr
expr_stmt|;
block|}
if|if
condition|(
name|wildcardp
operator|!=
name|NULL
condition|)
operator|*
name|wildcardp
operator|=
name|wildcard
expr_stmt|;
return|return
name|addr
return|;
block|}
specifier|static
name|int
name|channel_setup_fwd_listener_tcpip
parameter_list|(
name|int
name|type
parameter_list|,
name|struct
name|Forward
modifier|*
name|fwd
parameter_list|,
name|int
modifier|*
name|allocated_listen_port
parameter_list|,
name|struct
name|ForwardOptions
modifier|*
name|fwd_opts
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
name|int
name|sock
decl_stmt|,
name|r
decl_stmt|,
name|success
init|=
literal|0
decl_stmt|,
name|wildcard
init|=
literal|0
decl_stmt|,
name|is_client
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
decl_stmt|,
modifier|*
name|aitop
decl_stmt|;
specifier|const
name|char
modifier|*
name|host
decl_stmt|,
modifier|*
name|addr
decl_stmt|;
name|char
name|ntop
index|[
name|NI_MAXHOST
index|]
decl_stmt|,
name|strport
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|in_port_t
modifier|*
name|lport_p
decl_stmt|;
name|is_client
operator|=
operator|(
name|type
operator|==
name|SSH_CHANNEL_PORT_LISTENER
operator|)
expr_stmt|;
if|if
condition|(
name|is_client
operator|&&
name|fwd
operator|->
name|connect_path
operator|!=
name|NULL
condition|)
block|{
name|host
operator|=
name|fwd
operator|->
name|connect_path
expr_stmt|;
block|}
else|else
block|{
name|host
operator|=
operator|(
name|type
operator|==
name|SSH_CHANNEL_RPORT_LISTENER
operator|)
condition|?
name|fwd
operator|->
name|listen_host
else|:
name|fwd
operator|->
name|connect_host
expr_stmt|;
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No forward host name."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|host
argument_list|)
operator|>=
name|NI_MAXHOST
condition|)
block|{
name|error
argument_list|(
literal|"Forward host name too long."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Determine the bind address, cf. channel_fwd_bind_addr() comment */
name|addr
operator|=
name|channel_fwd_bind_addr
argument_list|(
name|fwd
operator|->
name|listen_host
argument_list|,
operator|&
name|wildcard
argument_list|,
name|is_client
argument_list|,
name|fwd_opts
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: type %d wildcard %d addr %s"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|,
name|wildcard
argument_list|,
operator|(
name|addr
operator|==
name|NULL
operator|)
condition|?
literal|"NULL"
else|:
name|addr
argument_list|)
expr_stmt|;
comment|/* 	 * getaddrinfo returns a loopback address if the hostname is 	 * set to NULL and hints.ai_flags is not AI_PASSIVE 	 */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|IPv4or6
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|wildcard
condition|?
name|AI_PASSIVE
else|:
literal|0
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|snprintf
argument_list|(
name|strport
argument_list|,
sizeof|sizeof
name|strport
argument_list|,
literal|"%d"
argument_list|,
name|fwd
operator|->
name|listen_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|getaddrinfo
argument_list|(
name|addr
argument_list|,
name|strport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|aitop
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
comment|/* This really shouldn't happen */
name|packet_disconnect
argument_list|(
literal|"getaddrinfo: fatal error: %s"
argument_list|,
name|ssh_gai_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"%s: getaddrinfo(%.64s): %s"
argument_list|,
name|__func__
argument_list|,
name|addr
argument_list|,
name|ssh_gai_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|allocated_listen_port
operator|!=
name|NULL
condition|)
operator|*
name|allocated_listen_port
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ai
operator|=
name|aitop
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
switch|switch
condition|(
name|ai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|lport_p
operator|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
operator|->
name|sin_port
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|lport_p
operator|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_port
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
comment|/* 		 * If allocating a port for -R forwards, then use the 		 * same port for all address families. 		 */
if|if
condition|(
name|type
operator|==
name|SSH_CHANNEL_RPORT_LISTENER
operator|&&
name|fwd
operator|->
name|listen_port
operator|==
literal|0
operator|&&
name|allocated_listen_port
operator|!=
name|NULL
operator|&&
operator|*
name|allocated_listen_port
operator|>
literal|0
condition|)
operator|*
name|lport_p
operator|=
name|htons
argument_list|(
operator|*
name|allocated_listen_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnameinfo
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|,
name|ntop
argument_list|,
sizeof|sizeof
argument_list|(
name|ntop
argument_list|)
argument_list|,
name|strport
argument_list|,
sizeof|sizeof
argument_list|(
name|strport
argument_list|)
argument_list|,
name|NI_NUMERICHOST
operator||
name|NI_NUMERICSERV
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: getnameinfo failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Create a port to listen for the host. */
name|sock
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|ai
operator|->
name|ai_socktype
argument_list|,
name|ai
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
comment|/* this is no error since kernel may not support ipv6 */
name|verbose
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|channel_set_reuseaddr
argument_list|(
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|)
name|sock_set_v6only
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Local forwarding listening on %s port %s."
argument_list|,
name|ntop
argument_list|,
name|strport
argument_list|)
expr_stmt|;
comment|/* Bind the socket to the address. */
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* address can be in use ipv6 address is already bound */
if|if
condition|(
operator|!
name|ai
operator|->
name|ai_next
condition|)
name|error
argument_list|(
literal|"bind: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|verbose
argument_list|(
literal|"bind: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Start listening for connections on the socket. */
if|if
condition|(
name|listen
argument_list|(
name|sock
argument_list|,
name|SSH_LISTEN_BACKLOG
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"listen: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * fwd->listen_port == 0 requests a dynamically allocated port - 		 * record what we got. 		 */
if|if
condition|(
name|type
operator|==
name|SSH_CHANNEL_RPORT_LISTENER
operator|&&
name|fwd
operator|->
name|listen_port
operator|==
literal|0
operator|&&
name|allocated_listen_port
operator|!=
name|NULL
operator|&&
operator|*
name|allocated_listen_port
operator|==
literal|0
condition|)
block|{
operator|*
name|allocated_listen_port
operator|=
name|get_local_port
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Allocated listen port %d"
argument_list|,
operator|*
name|allocated_listen_port
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate a channel number for the socket. */
name|c
operator|=
name|channel_new
argument_list|(
literal|"port listener"
argument_list|,
name|type
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_TCP_WINDOW_DEFAULT
argument_list|,
name|CHAN_TCP_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|"port listener"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|c
operator|->
name|host_port
operator|=
name|fwd
operator|->
name|connect_port
expr_stmt|;
name|c
operator|->
name|listening_addr
operator|=
name|addr
operator|==
name|NULL
condition|?
name|NULL
else|:
name|xstrdup
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwd
operator|->
name|listen_port
operator|==
literal|0
operator|&&
name|allocated_listen_port
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|datafellows
operator|&
name|SSH_BUG_DYNAMIC_RPORT
operator|)
condition|)
name|c
operator|->
name|listening_port
operator|=
operator|*
name|allocated_listen_port
expr_stmt|;
else|else
name|c
operator|->
name|listening_port
operator|=
name|fwd
operator|->
name|listen_port
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|success
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"%s: cannot listen to port: %d"
argument_list|,
name|__func__
argument_list|,
name|fwd
operator|->
name|listen_port
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|aitop
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
specifier|static
name|int
name|channel_setup_fwd_listener_streamlocal
parameter_list|(
name|int
name|type
parameter_list|,
name|struct
name|Forward
modifier|*
name|fwd
parameter_list|,
name|struct
name|ForwardOptions
modifier|*
name|fwd_opts
parameter_list|)
block|{
name|struct
name|sockaddr_un
name|sunaddr
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|int
name|port
decl_stmt|,
name|sock
decl_stmt|;
name|mode_t
name|omask
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SSH_CHANNEL_UNIX_LISTENER
case|:
if|if
condition|(
name|fwd
operator|->
name|connect_path
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|fwd
operator|->
name|connect_path
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|sunaddr
operator|.
name|sun_path
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Local connecting path too long: %s"
argument_list|,
name|fwd
operator|->
name|connect_path
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|path
operator|=
name|fwd
operator|->
name|connect_path
expr_stmt|;
name|port
operator|=
name|PORT_STREAMLOCAL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fwd
operator|->
name|connect_host
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No forward host name."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|fwd
operator|->
name|connect_host
argument_list|)
operator|>=
name|NI_MAXHOST
condition|)
block|{
name|error
argument_list|(
literal|"Forward host name too long."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|path
operator|=
name|fwd
operator|->
name|connect_host
expr_stmt|;
name|port
operator|=
name|fwd
operator|->
name|connect_port
expr_stmt|;
block|}
break|break;
case|case
name|SSH_CHANNEL_RUNIX_LISTENER
case|:
name|path
operator|=
name|fwd
operator|->
name|listen_path
expr_stmt|;
name|port
operator|=
name|PORT_STREAMLOCAL
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"%s: unexpected channel type %d"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fwd
operator|->
name|listen_path
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No forward path name."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|fwd
operator|->
name|listen_path
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|sunaddr
operator|.
name|sun_path
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Local listening path too long: %s"
argument_list|,
name|fwd
operator|->
name|listen_path
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|debug3
argument_list|(
literal|"%s: type %d path %s"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|,
name|fwd
operator|->
name|listen_path
argument_list|)
expr_stmt|;
comment|/* Start a Unix domain listener. */
name|omask
operator|=
name|umask
argument_list|(
name|fwd_opts
operator|->
name|streamlocal_bind_mask
argument_list|)
expr_stmt|;
name|sock
operator|=
name|unix_listener
argument_list|(
name|fwd
operator|->
name|listen_path
argument_list|,
name|SSH_LISTEN_BACKLOG
argument_list|,
name|fwd_opts
operator|->
name|streamlocal_bind_unlink
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|debug
argument_list|(
literal|"Local forwarding listening on path %s."
argument_list|,
name|fwd
operator|->
name|listen_path
argument_list|)
expr_stmt|;
comment|/* Allocate a channel number for the socket. */
name|c
operator|=
name|channel_new
argument_list|(
literal|"unix listener"
argument_list|,
name|type
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_TCP_WINDOW_DEFAULT
argument_list|,
name|CHAN_TCP_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|"unix listener"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|c
operator|->
name|host_port
operator|=
name|port
expr_stmt|;
name|c
operator|->
name|listening_port
operator|=
name|PORT_STREAMLOCAL
expr_stmt|;
name|c
operator|->
name|listening_addr
operator|=
name|xstrdup
argument_list|(
name|fwd
operator|->
name|listen_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
specifier|static
name|int
name|channel_cancel_rport_listener_tcpip
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channels
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_RPORT_LISTENER
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|c
operator|->
name|path
argument_list|,
name|host
argument_list|)
operator|==
literal|0
operator|&&
name|c
operator|->
name|listening_port
operator|==
name|port
condition|)
block|{
name|debug2
argument_list|(
literal|"%s: close channel %d"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
specifier|static
name|int
name|channel_cancel_rport_listener_streamlocal
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channels
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_RUNIX_LISTENER
condition|)
continue|continue;
if|if
condition|(
name|c
operator|->
name|path
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|c
operator|->
name|path
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"%s: close channel %d"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
name|int
name|channel_cancel_rport_listener
parameter_list|(
name|struct
name|Forward
modifier|*
name|fwd
parameter_list|)
block|{
if|if
condition|(
name|fwd
operator|->
name|listen_path
operator|!=
name|NULL
condition|)
return|return
name|channel_cancel_rport_listener_streamlocal
argument_list|(
name|fwd
operator|->
name|listen_path
argument_list|)
return|;
else|else
return|return
name|channel_cancel_rport_listener_tcpip
argument_list|(
name|fwd
operator|->
name|listen_host
argument_list|,
name|fwd
operator|->
name|listen_port
argument_list|)
return|;
block|}
specifier|static
name|int
name|channel_cancel_lport_listener_tcpip
parameter_list|(
specifier|const
name|char
modifier|*
name|lhost
parameter_list|,
name|u_short
name|lport
parameter_list|,
name|int
name|cport
parameter_list|,
name|struct
name|ForwardOptions
modifier|*
name|fwd_opts
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr
init|=
name|channel_fwd_bind_addr
argument_list|(
name|lhost
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|fwd_opts
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channels
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_PORT_LISTENER
condition|)
continue|continue;
if|if
condition|(
name|c
operator|->
name|listening_port
operator|!=
name|lport
condition|)
continue|continue;
if|if
condition|(
name|cport
operator|==
name|CHANNEL_CANCEL_PORT_STATIC
condition|)
block|{
comment|/* skip dynamic forwardings */
if|if
condition|(
name|c
operator|->
name|host_port
operator|==
literal|0
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|host_port
operator|!=
name|cport
condition|)
continue|continue;
block|}
if|if
condition|(
operator|(
name|c
operator|->
name|listening_addr
operator|==
name|NULL
operator|&&
name|addr
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|c
operator|->
name|listening_addr
operator|!=
name|NULL
operator|&&
name|addr
operator|==
name|NULL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|addr
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|c
operator|->
name|listening_addr
argument_list|,
name|addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"%s: close channel %d"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
specifier|static
name|int
name|channel_cancel_lport_listener_streamlocal
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: no path specified."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channels
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_UNIX_LISTENER
condition|)
continue|continue;
if|if
condition|(
name|c
operator|->
name|listening_addr
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|c
operator|->
name|listening_addr
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"%s: close channel %d"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
name|int
name|channel_cancel_lport_listener
parameter_list|(
name|struct
name|Forward
modifier|*
name|fwd
parameter_list|,
name|int
name|cport
parameter_list|,
name|struct
name|ForwardOptions
modifier|*
name|fwd_opts
parameter_list|)
block|{
if|if
condition|(
name|fwd
operator|->
name|listen_path
operator|!=
name|NULL
condition|)
return|return
name|channel_cancel_lport_listener_streamlocal
argument_list|(
name|fwd
operator|->
name|listen_path
argument_list|)
return|;
else|else
return|return
name|channel_cancel_lport_listener_tcpip
argument_list|(
name|fwd
operator|->
name|listen_host
argument_list|,
name|fwd
operator|->
name|listen_port
argument_list|,
name|cport
argument_list|,
name|fwd_opts
argument_list|)
return|;
block|}
comment|/* protocol local port fwd, used by ssh (and sshd in v1) */
name|int
name|channel_setup_local_fwd_listener
parameter_list|(
name|struct
name|Forward
modifier|*
name|fwd
parameter_list|,
name|struct
name|ForwardOptions
modifier|*
name|fwd_opts
parameter_list|)
block|{
if|if
condition|(
name|fwd
operator|->
name|listen_path
operator|!=
name|NULL
condition|)
block|{
return|return
name|channel_setup_fwd_listener_streamlocal
argument_list|(
name|SSH_CHANNEL_UNIX_LISTENER
argument_list|,
name|fwd
argument_list|,
name|fwd_opts
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|channel_setup_fwd_listener_tcpip
argument_list|(
name|SSH_CHANNEL_PORT_LISTENER
argument_list|,
name|fwd
argument_list|,
name|NULL
argument_list|,
name|fwd_opts
argument_list|)
return|;
block|}
block|}
comment|/* protocol v2 remote port fwd, used by sshd */
name|int
name|channel_setup_remote_fwd_listener
parameter_list|(
name|struct
name|Forward
modifier|*
name|fwd
parameter_list|,
name|int
modifier|*
name|allocated_listen_port
parameter_list|,
name|struct
name|ForwardOptions
modifier|*
name|fwd_opts
parameter_list|)
block|{
if|if
condition|(
name|fwd
operator|->
name|listen_path
operator|!=
name|NULL
condition|)
block|{
return|return
name|channel_setup_fwd_listener_streamlocal
argument_list|(
name|SSH_CHANNEL_RUNIX_LISTENER
argument_list|,
name|fwd
argument_list|,
name|fwd_opts
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|channel_setup_fwd_listener_tcpip
argument_list|(
name|SSH_CHANNEL_RPORT_LISTENER
argument_list|,
name|fwd
argument_list|,
name|allocated_listen_port
argument_list|,
name|fwd_opts
argument_list|)
return|;
block|}
block|}
comment|/*  * Translate the requested rfwd listen host to something usable for  * this server.  */
specifier|static
specifier|const
name|char
modifier|*
name|channel_rfwd_bind_host
parameter_list|(
specifier|const
name|char
modifier|*
name|listen_host
parameter_list|)
block|{
if|if
condition|(
name|listen_host
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|datafellows
operator|&
name|SSH_BUG_RFWD_ADDR
condition|)
return|return
literal|"127.0.0.1"
return|;
else|else
return|return
literal|"localhost"
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|listen_host
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|listen_host
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|datafellows
operator|&
name|SSH_BUG_RFWD_ADDR
condition|)
return|return
literal|"0.0.0.0"
return|;
else|else
return|return
literal|""
return|;
block|}
else|else
return|return
name|listen_host
return|;
block|}
comment|/*  * Initiate forwarding of connections to port "port" on remote host through  * the secure channel to host:port from local side.  * Returns handle (index) for updating the dynamic listen port with  * channel_update_permitted_opens().  */
name|int
name|channel_request_remote_forwarding
parameter_list|(
name|struct
name|Forward
modifier|*
name|fwd
parameter_list|)
block|{
name|int
name|type
decl_stmt|,
name|success
init|=
literal|0
decl_stmt|,
name|idx
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Send the forward request to the remote side. */
if|if
condition|(
name|compat20
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_GLOBAL_REQUEST
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwd
operator|->
name|listen_path
operator|!=
name|NULL
condition|)
block|{
name|packet_put_cstring
argument_list|(
literal|"streamlocal-forward@openssh.com"
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* boolean: want reply */
name|packet_put_cstring
argument_list|(
name|fwd
operator|->
name|listen_path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|packet_put_cstring
argument_list|(
literal|"tcpip-forward"
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* boolean: want reply */
name|packet_put_cstring
argument_list|(
name|channel_rfwd_bind_host
argument_list|(
name|fwd
operator|->
name|listen_host
argument_list|)
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|fwd
operator|->
name|listen_port
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Assume that server accepts the request */
name|success
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fwd
operator|->
name|listen_path
operator|==
name|NULL
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_PORT_FORWARD_REQUEST
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|fwd
operator|->
name|listen_port
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|fwd
operator|->
name|connect_host
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|fwd
operator|->
name|connect_port
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Wait for response from the remote side. */
name|type
operator|=
name|packet_read
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SSH_SMSG_SUCCESS
case|:
name|success
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SSH_SMSG_FAILURE
case|:
break|break;
default|default:
comment|/* Unknown packet */
name|packet_disconnect
argument_list|(
literal|"Protocol error for port forward request:"
literal|"received packet type %d."
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|logit
argument_list|(
literal|"Warning: Server does not support remote stream local forwarding."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
comment|/* Record that connection to this host/port is permitted. */
name|permitted_opens
operator|=
name|xreallocarray
argument_list|(
name|permitted_opens
argument_list|,
name|num_permitted_opens
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|permitted_opens
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|=
name|num_permitted_opens
operator|++
expr_stmt|;
if|if
condition|(
name|fwd
operator|->
name|connect_path
operator|!=
name|NULL
condition|)
block|{
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|host_to_connect
operator|=
name|xstrdup
argument_list|(
name|fwd
operator|->
name|connect_path
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|port_to_connect
operator|=
name|PORT_STREAMLOCAL
expr_stmt|;
block|}
else|else
block|{
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|host_to_connect
operator|=
name|xstrdup
argument_list|(
name|fwd
operator|->
name|connect_host
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|port_to_connect
operator|=
name|fwd
operator|->
name|connect_port
expr_stmt|;
block|}
if|if
condition|(
name|fwd
operator|->
name|listen_path
operator|!=
name|NULL
condition|)
block|{
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|listen_host
operator|=
name|NULL
expr_stmt|;
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|listen_path
operator|=
name|xstrdup
argument_list|(
name|fwd
operator|->
name|listen_path
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|listen_port
operator|=
name|PORT_STREAMLOCAL
expr_stmt|;
block|}
else|else
block|{
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|listen_host
operator|=
name|fwd
operator|->
name|listen_host
condition|?
name|xstrdup
argument_list|(
name|fwd
operator|->
name|listen_host
argument_list|)
else|:
name|NULL
expr_stmt|;
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|listen_path
operator|=
name|NULL
expr_stmt|;
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|listen_port
operator|=
name|fwd
operator|->
name|listen_port
expr_stmt|;
block|}
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|downstream
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|idx
operator|)
return|;
block|}
specifier|static
name|int
name|open_match
parameter_list|(
name|ForwardPermission
modifier|*
name|allowed_open
parameter_list|,
specifier|const
name|char
modifier|*
name|requestedhost
parameter_list|,
name|int
name|requestedport
parameter_list|)
block|{
if|if
condition|(
name|allowed_open
operator|->
name|host_to_connect
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|allowed_open
operator|->
name|port_to_connect
operator|!=
name|FWD_PERMIT_ANY_PORT
operator|&&
name|allowed_open
operator|->
name|port_to_connect
operator|!=
name|requestedport
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|allowed_open
operator|->
name|host_to_connect
argument_list|,
name|FWD_PERMIT_ANY_HOST
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|allowed_open
operator|->
name|host_to_connect
argument_list|,
name|requestedhost
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
comment|/*  * Note that in the listen host/port case  * we don't support FWD_PERMIT_ANY_PORT and  * need to translate between the configured-host (listen_host)  * and what we've sent to the remote server (channel_rfwd_bind_host)  */
specifier|static
name|int
name|open_listen_match_tcpip
parameter_list|(
name|ForwardPermission
modifier|*
name|allowed_open
parameter_list|,
specifier|const
name|char
modifier|*
name|requestedhost
parameter_list|,
name|u_short
name|requestedport
parameter_list|,
name|int
name|translate
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|allowed_host
decl_stmt|;
if|if
condition|(
name|allowed_open
operator|->
name|host_to_connect
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|allowed_open
operator|->
name|listen_port
operator|!=
name|requestedport
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|translate
operator|&&
name|allowed_open
operator|->
name|listen_host
operator|==
name|NULL
operator|&&
name|requestedhost
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|allowed_host
operator|=
name|translate
condition|?
name|channel_rfwd_bind_host
argument_list|(
name|allowed_open
operator|->
name|listen_host
argument_list|)
else|:
name|allowed_open
operator|->
name|listen_host
expr_stmt|;
if|if
condition|(
name|allowed_host
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|allowed_host
argument_list|,
name|requestedhost
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
specifier|static
name|int
name|open_listen_match_streamlocal
parameter_list|(
name|ForwardPermission
modifier|*
name|allowed_open
parameter_list|,
specifier|const
name|char
modifier|*
name|requestedpath
parameter_list|)
block|{
if|if
condition|(
name|allowed_open
operator|->
name|host_to_connect
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|allowed_open
operator|->
name|listen_port
operator|!=
name|PORT_STREAMLOCAL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|allowed_open
operator|->
name|listen_path
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|allowed_open
operator|->
name|listen_path
argument_list|,
name|requestedpath
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
comment|/*  * Request cancellation of remote forwarding of connection host:port from  * local side.  */
specifier|static
name|int
name|channel_request_rforward_cancel_tcpip
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|compat20
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_permitted_opens
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|open_listen_match_tcpip
argument_list|(
operator|&
name|permitted_opens
index|[
name|i
index|]
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|num_permitted_opens
condition|)
block|{
name|debug
argument_list|(
literal|"%s: requested forward not found"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|packet_start
argument_list|(
name|SSH2_MSG_GLOBAL_REQUEST
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"cancel-tcpip-forward"
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|channel_rfwd_bind_host
argument_list|(
name|host
argument_list|)
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_port
operator|=
literal|0
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|port_to_connect
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_host
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_host
operator|=
name|NULL
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_path
operator|=
name|NULL
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|downstream
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * Request cancellation of remote forwarding of Unix domain socket  * path from local side.  */
specifier|static
name|int
name|channel_request_rforward_cancel_streamlocal
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|compat20
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_permitted_opens
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|open_listen_match_streamlocal
argument_list|(
operator|&
name|permitted_opens
index|[
name|i
index|]
argument_list|,
name|path
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|num_permitted_opens
condition|)
block|{
name|debug
argument_list|(
literal|"%s: requested forward not found"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|packet_start
argument_list|(
name|SSH2_MSG_GLOBAL_REQUEST
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"cancel-streamlocal-forward@openssh.com"
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_port
operator|=
literal|0
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|port_to_connect
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
operator|=
name|NULL
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_host
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_path
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_path
operator|=
name|NULL
expr_stmt|;
name|permitted_opens
index|[
name|i
index|]
operator|.
name|downstream
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * Request cancellation of remote forwarding of a connection from local side.  */
name|int
name|channel_request_rforward_cancel
parameter_list|(
name|struct
name|Forward
modifier|*
name|fwd
parameter_list|)
block|{
if|if
condition|(
name|fwd
operator|->
name|listen_path
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|channel_request_rforward_cancel_streamlocal
argument_list|(
name|fwd
operator|->
name|listen_path
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|channel_request_rforward_cancel_tcpip
argument_list|(
name|fwd
operator|->
name|listen_host
argument_list|,
name|fwd
operator|->
name|listen_port
condition|?
name|fwd
operator|->
name|listen_port
else|:
name|fwd
operator|->
name|allocated_port
argument_list|)
operator|)
return|;
block|}
block|}
comment|/*  * Permits opening to any host/port if permitted_opens[] is empty.  This is  * usually called by the server, because the user could connect to any port  * anyway, and the server has no way to know but to trust the client anyway.  */
name|void
name|channel_permit_all_opens
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|num_permitted_opens
operator|==
literal|0
condition|)
name|all_opens_permitted
operator|=
literal|1
expr_stmt|;
block|}
name|void
name|channel_add_permitted_opens
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|debug
argument_list|(
literal|"allow port forwarding to host %s port %d"
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|permitted_opens
operator|=
name|xreallocarray
argument_list|(
name|permitted_opens
argument_list|,
name|num_permitted_opens
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|permitted_opens
argument_list|)
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|num_permitted_opens
index|]
operator|.
name|host_to_connect
operator|=
name|xstrdup
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|num_permitted_opens
index|]
operator|.
name|port_to_connect
operator|=
name|port
expr_stmt|;
name|permitted_opens
index|[
name|num_permitted_opens
index|]
operator|.
name|listen_host
operator|=
name|NULL
expr_stmt|;
name|permitted_opens
index|[
name|num_permitted_opens
index|]
operator|.
name|listen_path
operator|=
name|NULL
expr_stmt|;
name|permitted_opens
index|[
name|num_permitted_opens
index|]
operator|.
name|listen_port
operator|=
literal|0
expr_stmt|;
name|permitted_opens
index|[
name|num_permitted_opens
index|]
operator|.
name|downstream
operator|=
name|NULL
expr_stmt|;
name|num_permitted_opens
operator|++
expr_stmt|;
name|all_opens_permitted
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  * Update the listen port for a dynamic remote forward, after  * the actual 'newport' has been allocated. If 'newport'< 0 is  * passed then they entry will be invalidated.  */
name|void
name|channel_update_permitted_opens
parameter_list|(
name|int
name|idx
parameter_list|,
name|int
name|newport
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|num_permitted_opens
condition|)
block|{
name|debug
argument_list|(
literal|"channel_update_permitted_opens: index out of range:"
literal|" %d num_permitted_opens %d"
argument_list|,
name|idx
argument_list|,
name|num_permitted_opens
argument_list|)
expr_stmt|;
return|return;
block|}
name|debug
argument_list|(
literal|"%s allowed port %d for forwarding to host %s port %d"
argument_list|,
name|newport
operator|>
literal|0
condition|?
literal|"Updating"
else|:
literal|"Removing"
argument_list|,
name|newport
argument_list|,
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|host_to_connect
argument_list|,
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|port_to_connect
argument_list|)
expr_stmt|;
if|if
condition|(
name|newport
operator|>=
literal|0
condition|)
block|{
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|listen_port
operator|=
operator|(
name|datafellows
operator|&
name|SSH_BUG_DYNAMIC_RPORT
operator|)
condition|?
literal|0
else|:
name|newport
expr_stmt|;
block|}
else|else
block|{
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|listen_port
operator|=
literal|0
expr_stmt|;
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|port_to_connect
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|host_to_connect
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|host_to_connect
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|listen_host
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|listen_host
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|listen_path
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|idx
index|]
operator|.
name|listen_path
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|int
name|channel_add_adm_permitted_opens
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|debug
argument_list|(
literal|"config allows port forwarding to host %s port %d"
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|permitted_adm_opens
operator|=
name|xreallocarray
argument_list|(
name|permitted_adm_opens
argument_list|,
name|num_adm_permitted_opens
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|permitted_adm_opens
argument_list|)
argument_list|)
expr_stmt|;
name|permitted_adm_opens
index|[
name|num_adm_permitted_opens
index|]
operator|.
name|host_to_connect
operator|=
name|xstrdup
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|permitted_adm_opens
index|[
name|num_adm_permitted_opens
index|]
operator|.
name|port_to_connect
operator|=
name|port
expr_stmt|;
name|permitted_adm_opens
index|[
name|num_adm_permitted_opens
index|]
operator|.
name|listen_host
operator|=
name|NULL
expr_stmt|;
name|permitted_adm_opens
index|[
name|num_adm_permitted_opens
index|]
operator|.
name|listen_path
operator|=
name|NULL
expr_stmt|;
name|permitted_adm_opens
index|[
name|num_adm_permitted_opens
index|]
operator|.
name|listen_port
operator|=
literal|0
expr_stmt|;
return|return
operator|++
name|num_adm_permitted_opens
return|;
block|}
name|void
name|channel_disable_adm_local_opens
parameter_list|(
name|void
parameter_list|)
block|{
name|channel_clear_adm_permitted_opens
argument_list|()
expr_stmt|;
name|permitted_adm_opens
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|permitted_adm_opens
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|permitted_adm_opens
index|[
name|num_adm_permitted_opens
index|]
operator|.
name|host_to_connect
operator|=
name|NULL
expr_stmt|;
name|num_adm_permitted_opens
operator|=
literal|1
expr_stmt|;
block|}
name|void
name|channel_clear_permitted_opens
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_permitted_opens
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_host
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_path
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|permitted_opens
argument_list|)
expr_stmt|;
name|permitted_opens
operator|=
name|NULL
expr_stmt|;
name|num_permitted_opens
operator|=
literal|0
expr_stmt|;
block|}
name|void
name|channel_clear_adm_permitted_opens
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_adm_permitted_opens
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|permitted_adm_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|permitted_adm_opens
index|[
name|i
index|]
operator|.
name|listen_host
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|permitted_adm_opens
index|[
name|i
index|]
operator|.
name|listen_path
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|permitted_adm_opens
argument_list|)
expr_stmt|;
name|permitted_adm_opens
operator|=
name|NULL
expr_stmt|;
name|num_adm_permitted_opens
operator|=
literal|0
expr_stmt|;
block|}
name|void
name|channel_print_adm_permitted_opens
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"permitopen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_adm_permitted_opens
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" any\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_adm_permitted_opens
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|permitted_adm_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|" none"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %s:%d"
argument_list|,
name|permitted_adm_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
argument_list|,
name|permitted_adm_opens
index|[
name|i
index|]
operator|.
name|port_to_connect
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* returns port number, FWD_PERMIT_ANY_PORT or -1 on error */
name|int
name|permitopen_port
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FWD_PERMIT_ANY_PORT
return|;
if|if
condition|(
operator|(
name|port
operator|=
name|a2port
argument_list|(
name|p
argument_list|)
operator|)
operator|>
literal|0
condition|)
return|return
name|port
return|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Try to start non-blocking connect to next host in cctx list */
specifier|static
name|int
name|connect_next
parameter_list|(
name|struct
name|channel_connect
modifier|*
name|cctx
parameter_list|)
block|{
name|int
name|sock
decl_stmt|,
name|saved_errno
decl_stmt|;
name|struct
name|sockaddr_un
modifier|*
name|sunaddr
decl_stmt|;
name|char
name|ntop
index|[
name|NI_MAXHOST
index|]
decl_stmt|,
name|strport
index|[
name|MAXIMUM
argument_list|(
name|NI_MAXSERV
argument_list|,
sizeof|sizeof
argument_list|(
name|sunaddr
operator|->
name|sun_path
argument_list|)
argument_list|)
index|]
decl_stmt|;
for|for
control|(
init|;
name|cctx
operator|->
name|ai
condition|;
name|cctx
operator|->
name|ai
operator|=
name|cctx
operator|->
name|ai
operator|->
name|ai_next
control|)
block|{
switch|switch
condition|(
name|cctx
operator|->
name|ai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_UNIX
case|:
comment|/* unix:pathname instead of host:port */
name|sunaddr
operator|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|cctx
operator|->
name|ai
operator|->
name|ai_addr
expr_stmt|;
name|strlcpy
argument_list|(
name|ntop
argument_list|,
literal|"unix"
argument_list|,
sizeof|sizeof
argument_list|(
name|ntop
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|strport
argument_list|,
name|sunaddr
operator|->
name|sun_path
argument_list|,
sizeof|sizeof
argument_list|(
name|strport
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET
case|:
case|case
name|AF_INET6
case|:
if|if
condition|(
name|getnameinfo
argument_list|(
name|cctx
operator|->
name|ai
operator|->
name|ai_addr
argument_list|,
name|cctx
operator|->
name|ai
operator|->
name|ai_addrlen
argument_list|,
name|ntop
argument_list|,
sizeof|sizeof
argument_list|(
name|ntop
argument_list|)
argument_list|,
name|strport
argument_list|,
sizeof|sizeof
argument_list|(
name|strport
argument_list|)
argument_list|,
name|NI_NUMERICHOST
operator||
name|NI_NUMERICSERV
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"connect_next: getnameinfo failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
continue|continue;
block|}
if|if
condition|(
operator|(
name|sock
operator|=
name|socket
argument_list|(
name|cctx
operator|->
name|ai
operator|->
name|ai_family
argument_list|,
name|cctx
operator|->
name|ai
operator|->
name|ai_socktype
argument_list|,
name|cctx
operator|->
name|ai
operator|->
name|ai_protocol
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|cctx
operator|->
name|ai
operator|->
name|ai_next
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|verbose
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|set_nonblock
argument_list|(
name|sock
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: set_nonblock(%d)"
argument_list|,
name|__func__
argument_list|,
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|sock
argument_list|,
name|cctx
operator|->
name|ai
operator|->
name|ai_addr
argument_list|,
name|cctx
operator|->
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINPROGRESS
condition|)
block|{
name|debug
argument_list|(
literal|"connect_next: host %.100s ([%.100s]:%s): "
literal|"%.100s"
argument_list|,
name|cctx
operator|->
name|host
argument_list|,
name|ntop
argument_list|,
name|strport
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|saved_errno
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
continue|continue;
comment|/* fail -- try next */
block|}
if|if
condition|(
name|cctx
operator|->
name|ai
operator|->
name|ai_family
operator|!=
name|AF_UNIX
condition|)
name|set_nodelay
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"connect_next: host %.100s ([%.100s]:%s) "
literal|"in progress, fd=%d"
argument_list|,
name|cctx
operator|->
name|host
argument_list|,
name|ntop
argument_list|,
name|strport
argument_list|,
name|sock
argument_list|)
expr_stmt|;
name|cctx
operator|->
name|ai
operator|=
name|cctx
operator|->
name|ai
operator|->
name|ai_next
expr_stmt|;
return|return
name|sock
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
specifier|static
name|void
name|channel_connect_ctx_free
parameter_list|(
name|struct
name|channel_connect
modifier|*
name|cctx
parameter_list|)
block|{
name|free
argument_list|(
name|cctx
operator|->
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|cctx
operator|->
name|aitop
condition|)
block|{
if|if
condition|(
name|cctx
operator|->
name|aitop
operator|->
name|ai_family
operator|==
name|AF_UNIX
condition|)
name|free
argument_list|(
name|cctx
operator|->
name|aitop
argument_list|)
expr_stmt|;
else|else
name|freeaddrinfo
argument_list|(
name|cctx
operator|->
name|aitop
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|cctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cctx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*  * Return CONNECTING channel to remote host:port or local socket path,  * passing back the failure reason if appropriate.  */
specifier|static
name|Channel
modifier|*
name|connect_to_reason
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|port
parameter_list|,
name|char
modifier|*
name|ctype
parameter_list|,
name|char
modifier|*
name|rname
parameter_list|,
name|int
modifier|*
name|reason
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|int
name|gaierr
decl_stmt|;
name|int
name|sock
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|strport
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|struct
name|channel_connect
name|cctx
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
name|PORT_STREAMLOCAL
condition|)
block|{
name|struct
name|sockaddr_un
modifier|*
name|sunaddr
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|sunaddr
operator|->
name|sun_path
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%.100s: %.100s"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|ENAMETOOLONG
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 * Fake up a struct addrinfo for AF_UNIX connections. 		 * channel_connect_ctx_free() must check ai_family 		 * and use free() not freeaddirinfo() for AF_UNIX. 		 */
name|ai
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ai
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sunaddr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ai
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ai
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sunaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|ai
operator|+
literal|1
operator|)
expr_stmt|;
name|ai
operator|->
name|ai_addrlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sunaddr
argument_list|)
expr_stmt|;
name|ai
operator|->
name|ai_family
operator|=
name|AF_UNIX
expr_stmt|;
name|ai
operator|->
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|ai
operator|->
name|ai_protocol
operator|=
name|PF_UNSPEC
expr_stmt|;
name|sunaddr
operator|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|ai
operator|->
name|ai_addr
expr_stmt|;
name|sunaddr
operator|->
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|strlcpy
argument_list|(
name|sunaddr
operator|->
name|sun_path
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|sunaddr
operator|->
name|sun_path
argument_list|)
argument_list|)
expr_stmt|;
name|cctx
operator|.
name|aitop
operator|=
name|ai
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|IPv4or6
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|snprintf
argument_list|(
name|strport
argument_list|,
sizeof|sizeof
name|strport
argument_list|,
literal|"%d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gaierr
operator|=
name|getaddrinfo
argument_list|(
name|name
argument_list|,
name|strport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|cctx
operator|.
name|aitop
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errmsg
operator|!=
name|NULL
condition|)
operator|*
name|errmsg
operator|=
name|ssh_gai_strerror
argument_list|(
name|gaierr
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|!=
name|NULL
condition|)
operator|*
name|reason
operator|=
name|SSH2_OPEN_CONNECT_FAILED
expr_stmt|;
name|error
argument_list|(
literal|"connect_to %.100s: unknown host (%s)"
argument_list|,
name|name
argument_list|,
name|ssh_gai_strerror
argument_list|(
name|gaierr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|cctx
operator|.
name|host
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|cctx
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|cctx
operator|.
name|ai
operator|=
name|cctx
operator|.
name|aitop
expr_stmt|;
if|if
condition|(
operator|(
name|sock
operator|=
name|connect_next
argument_list|(
operator|&
name|cctx
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"connect to %.100s port %d failed: %s"
argument_list|,
name|name
argument_list|,
name|port
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|channel_connect_ctx_free
argument_list|(
operator|&
name|cctx
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|=
name|channel_new
argument_list|(
name|ctype
argument_list|,
name|SSH_CHANNEL_CONNECTING
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_TCP_WINDOW_DEFAULT
argument_list|,
name|CHAN_TCP_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
name|rname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|connect_ctx
operator|=
name|cctx
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/* Return CONNECTING channel to remote host:port or local socket path */
specifier|static
name|Channel
modifier|*
name|connect_to
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|port
parameter_list|,
name|char
modifier|*
name|ctype
parameter_list|,
name|char
modifier|*
name|rname
parameter_list|)
block|{
return|return
name|connect_to_reason
argument_list|(
name|name
argument_list|,
name|port
argument_list|,
name|ctype
argument_list|,
name|rname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
comment|/*  * returns either the newly connected channel or the downstream channel  * that needs to deal with this connection.  */
name|Channel
modifier|*
name|channel_connect_by_listen_address
parameter_list|(
specifier|const
name|char
modifier|*
name|listen_host
parameter_list|,
name|u_short
name|listen_port
parameter_list|,
name|char
modifier|*
name|ctype
parameter_list|,
name|char
modifier|*
name|rname
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_permitted_opens
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|open_listen_match_tcpip
argument_list|(
operator|&
name|permitted_opens
index|[
name|i
index|]
argument_list|,
name|listen_host
argument_list|,
name|listen_port
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|downstream
condition|)
return|return
name|permitted_opens
index|[
name|i
index|]
operator|.
name|downstream
return|;
return|return
name|connect_to
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
argument_list|,
name|permitted_opens
index|[
name|i
index|]
operator|.
name|port_to_connect
argument_list|,
name|ctype
argument_list|,
name|rname
argument_list|)
return|;
block|}
block|}
name|error
argument_list|(
literal|"WARNING: Server requests forwarding for unknown listen_port %d"
argument_list|,
name|listen_port
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|Channel
modifier|*
name|channel_connect_by_listen_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|ctype
parameter_list|,
name|char
modifier|*
name|rname
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_permitted_opens
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|open_listen_match_streamlocal
argument_list|(
operator|&
name|permitted_opens
index|[
name|i
index|]
argument_list|,
name|path
argument_list|)
condition|)
block|{
return|return
name|connect_to
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
argument_list|,
name|permitted_opens
index|[
name|i
index|]
operator|.
name|port_to_connect
argument_list|,
name|ctype
argument_list|,
name|rname
argument_list|)
return|;
block|}
block|}
name|error
argument_list|(
literal|"WARNING: Server requests forwarding for unknown path %.100s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Check if connecting to that port is permitted and connect. */
name|Channel
modifier|*
name|channel_connect_to_port
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|u_short
name|port
parameter_list|,
name|char
modifier|*
name|ctype
parameter_list|,
name|char
modifier|*
name|rname
parameter_list|,
name|int
modifier|*
name|reason
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|permit
decl_stmt|,
name|permit_adm
init|=
literal|1
decl_stmt|;
name|permit
operator|=
name|all_opens_permitted
expr_stmt|;
if|if
condition|(
operator|!
name|permit
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_permitted_opens
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|open_match
argument_list|(
operator|&
name|permitted_opens
index|[
name|i
index|]
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
condition|)
block|{
name|permit
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|num_adm_permitted_opens
operator|>
literal|0
condition|)
block|{
name|permit_adm
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_adm_permitted_opens
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|open_match
argument_list|(
operator|&
name|permitted_adm_opens
index|[
name|i
index|]
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
condition|)
block|{
name|permit_adm
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|permit
operator|||
operator|!
name|permit_adm
condition|)
block|{
name|logit
argument_list|(
literal|"Received request to connect to host %.100s port %d, "
literal|"but the request was denied."
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|!=
name|NULL
condition|)
operator|*
name|reason
operator|=
name|SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|connect_to_reason
argument_list|(
name|host
argument_list|,
name|port
argument_list|,
name|ctype
argument_list|,
name|rname
argument_list|,
name|reason
argument_list|,
name|errmsg
argument_list|)
return|;
block|}
comment|/* Check if connecting to that path is permitted and connect. */
name|Channel
modifier|*
name|channel_connect_to_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|ctype
parameter_list|,
name|char
modifier|*
name|rname
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|permit
decl_stmt|,
name|permit_adm
init|=
literal|1
decl_stmt|;
name|permit
operator|=
name|all_opens_permitted
expr_stmt|;
if|if
condition|(
operator|!
name|permit
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_permitted_opens
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|open_match
argument_list|(
operator|&
name|permitted_opens
index|[
name|i
index|]
argument_list|,
name|path
argument_list|,
name|PORT_STREAMLOCAL
argument_list|)
condition|)
block|{
name|permit
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|num_adm_permitted_opens
operator|>
literal|0
condition|)
block|{
name|permit_adm
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_adm_permitted_opens
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|open_match
argument_list|(
operator|&
name|permitted_adm_opens
index|[
name|i
index|]
argument_list|,
name|path
argument_list|,
name|PORT_STREAMLOCAL
argument_list|)
condition|)
block|{
name|permit_adm
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|permit
operator|||
operator|!
name|permit_adm
condition|)
block|{
name|logit
argument_list|(
literal|"Received request to connect to path %.100s, "
literal|"but the request was denied."
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|connect_to
argument_list|(
name|path
argument_list|,
name|PORT_STREAMLOCAL
argument_list|,
name|ctype
argument_list|,
name|rname
argument_list|)
return|;
block|}
name|void
name|channel_send_window_changes
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|winsize
name|ws
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|==
name|NULL
operator|||
operator|!
name|channels
index|[
name|i
index|]
operator|->
name|client_tty
operator|||
name|channels
index|[
name|i
index|]
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
condition|)
continue|continue;
if|if
condition|(
name|ioctl
argument_list|(
name|channels
index|[
name|i
index|]
operator|->
name|rfd
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
name|channel_request_start
argument_list|(
name|i
argument_list|,
literal|"window-change"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
operator|(
name|u_int
operator|)
name|ws
operator|.
name|ws_col
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
operator|(
name|u_int
operator|)
name|ws
operator|.
name|ws_row
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
operator|(
name|u_int
operator|)
name|ws
operator|.
name|ws_xpixel
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
operator|(
name|u_int
operator|)
name|ws
operator|.
name|ws_ypixel
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* -- X11 forwarding */
comment|/*  * Creates an internet domain socket for listening for X11 connections.  * Returns 0 and a suitable display number for the DISPLAY variable  * stored in display_numberp , or -1 if an error occurs.  */
name|int
name|x11_create_display_inet
parameter_list|(
name|int
name|x11_display_offset
parameter_list|,
name|int
name|x11_use_localhost
parameter_list|,
name|int
name|single_connection
parameter_list|,
name|u_int
modifier|*
name|display_numberp
parameter_list|,
name|int
modifier|*
modifier|*
name|chanids
parameter_list|)
block|{
name|Channel
modifier|*
name|nc
init|=
name|NULL
decl_stmt|;
name|int
name|display_number
decl_stmt|,
name|sock
decl_stmt|;
name|u_short
name|port
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
decl_stmt|,
modifier|*
name|aitop
decl_stmt|;
name|char
name|strport
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|int
name|gaierr
decl_stmt|,
name|n
decl_stmt|,
name|num_socks
init|=
literal|0
decl_stmt|,
name|socks
index|[
name|NUM_SOCKS
index|]
decl_stmt|;
if|if
condition|(
name|chanids
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|display_number
operator|=
name|x11_display_offset
init|;
name|display_number
operator|<
name|MAX_DISPLAYS
condition|;
name|display_number
operator|++
control|)
block|{
name|port
operator|=
literal|6000
operator|+
name|display_number
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|IPv4or6
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|x11_use_localhost
condition|?
literal|0
else|:
name|AI_PASSIVE
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|snprintf
argument_list|(
name|strport
argument_list|,
sizeof|sizeof
name|strport
argument_list|,
literal|"%d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gaierr
operator|=
name|getaddrinfo
argument_list|(
name|NULL
argument_list|,
name|strport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|aitop
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"getaddrinfo: %.100s"
argument_list|,
name|ssh_gai_strerror
argument_list|(
name|gaierr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|ai
operator|=
name|aitop
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET
operator|&&
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|sock
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|ai
operator|->
name|ai_socktype
argument_list|,
name|ai
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|errno
operator|!=
name|EINVAL
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|EAFNOSUPPORT
operator|)
ifdef|#
directive|ifdef
name|EPFNOSUPPORT
operator|&&
operator|(
name|errno
operator|!=
name|EPFNOSUPPORT
operator|)
endif|#
directive|endif
condition|)
block|{
name|error
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|aitop
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"x11_create_display_inet: Socket family %d not supported"
argument_list|,
name|ai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|)
name|sock_set_v6only
argument_list|(
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|x11_use_localhost
condition|)
name|channel_set_reuseaddr
argument_list|(
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"bind port %d: %.100s"
argument_list|,
name|port
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_socks
condition|;
name|n
operator|++
control|)
block|{
name|close
argument_list|(
name|socks
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
name|num_socks
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|socks
index|[
name|num_socks
operator|++
index|]
operator|=
name|sock
expr_stmt|;
if|if
condition|(
name|num_socks
operator|==
name|NUM_SOCKS
condition|)
break|break;
block|}
name|freeaddrinfo
argument_list|(
name|aitop
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_socks
operator|>
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|display_number
operator|>=
name|MAX_DISPLAYS
condition|)
block|{
name|error
argument_list|(
literal|"Failed to allocate internet-domain X11 display socket."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Start listening for connections on the socket. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_socks
condition|;
name|n
operator|++
control|)
block|{
name|sock
operator|=
name|socks
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|listen
argument_list|(
name|sock
argument_list|,
name|SSH_LISTEN_BACKLOG
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"listen: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Allocate a channel for each socket. */
operator|*
name|chanids
operator|=
name|xcalloc
argument_list|(
name|num_socks
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|chanids
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_socks
condition|;
name|n
operator|++
control|)
block|{
name|sock
operator|=
name|socks
index|[
name|n
index|]
expr_stmt|;
name|nc
operator|=
name|channel_new
argument_list|(
literal|"x11 listener"
argument_list|,
name|SSH_CHANNEL_X11_LISTENER
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_X11_WINDOW_DEFAULT
argument_list|,
name|CHAN_X11_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|"X11 inet listener"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nc
operator|->
name|single_connection
operator|=
name|single_connection
expr_stmt|;
operator|(
operator|*
name|chanids
operator|)
index|[
name|n
index|]
operator|=
name|nc
operator|->
name|self
expr_stmt|;
block|}
operator|(
operator|*
name|chanids
operator|)
index|[
name|n
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Return the display number for the DISPLAY environment variable. */
operator|*
name|display_numberp
operator|=
name|display_number
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|connect_local_xsocket_path
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
name|int
name|sock
decl_stmt|;
name|struct
name|sockaddr_un
name|addr
decl_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|strlcpy
argument_list|(
name|addr
operator|.
name|sun_path
argument_list|,
name|pathname
argument_list|,
sizeof|sizeof
name|addr
operator|.
name|sun_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sock
return|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"connect %.100s: %.100s"
argument_list|,
name|addr
operator|.
name|sun_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
specifier|static
name|int
name|connect_local_xsocket
parameter_list|(
name|u_int
name|dnr
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|_PATH_UNIX_X
argument_list|,
name|dnr
argument_list|)
expr_stmt|;
return|return
name|connect_local_xsocket_path
argument_list|(
name|buf
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|__APPLE__
specifier|static
name|int
name|is_path_to_xsocket
parameter_list|(
specifier|const
name|char
modifier|*
name|display
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|size_t
name|pathlen
parameter_list|)
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|path
argument_list|,
name|display
argument_list|,
name|pathlen
argument_list|)
operator|>=
name|pathlen
condition|)
block|{
name|error
argument_list|(
literal|"%s: display path too long"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|display
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
name|char
modifier|*
name|dot
init|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|dot
operator|!=
name|NULL
condition|)
block|{
operator|*
name|dot
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|int
name|x11_connect_display
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|display_number
decl_stmt|;
specifier|const
name|char
modifier|*
name|display
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
decl_stmt|,
modifier|*
name|aitop
decl_stmt|;
name|char
name|strport
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|int
name|gaierr
decl_stmt|,
name|sock
init|=
literal|0
decl_stmt|;
comment|/* Try to open a socket for the local X server. */
name|display
operator|=
name|getenv
argument_list|(
literal|"DISPLAY"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|display
condition|)
block|{
name|error
argument_list|(
literal|"DISPLAY not set."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Now we decode the value of the DISPLAY variable and make a 	 * connection to the real X server. 	 */
ifdef|#
directive|ifdef
name|__APPLE__
comment|/* Check if display is a path to a socket (as set by launchd). */
block|{
name|char
name|path
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
name|is_path_to_xsocket
argument_list|(
name|display
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"x11_connect_display: $DISPLAY is launchd"
argument_list|)
expr_stmt|;
comment|/* Create a socket. */
name|sock
operator|=
name|connect_local_xsocket_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* OK, we now have a connection to the display. */
return|return
name|sock
return|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Check if it is a unix domain socket.  Unix domain displays are in 	 * one of the following formats: unix:d[.s], :d[.s], ::d[.s] 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|display
argument_list|,
literal|"unix:"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|display
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* Connect to the unix domain socket. */
if|if
condition|(
name|sscanf
argument_list|(
name|strrchr
argument_list|(
name|display
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|display_number
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Could not parse display number from DISPLAY: %.100s"
argument_list|,
name|display
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Create a socket. */
name|sock
operator|=
name|connect_local_xsocket
argument_list|(
name|display_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* OK, we now have a connection to the display. */
return|return
name|sock
return|;
block|}
comment|/* 	 * Connect to an inet socket.  The DISPLAY value is supposedly 	 * hostname:d[.s], where hostname may also be numeric IP address. 	 */
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|display
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|error
argument_list|(
literal|"Could not find ':' in DISPLAY: %.100s"
argument_list|,
name|display
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
comment|/* buf now contains the host name.  But first we parse the display number. */
if|if
condition|(
name|sscanf
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|display_number
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Could not parse display number from DISPLAY: %.100s"
argument_list|,
name|display
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Look up the host address */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|IPv4or6
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|snprintf
argument_list|(
name|strport
argument_list|,
sizeof|sizeof
name|strport
argument_list|,
literal|"%u"
argument_list|,
literal|6000
operator|+
name|display_number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gaierr
operator|=
name|getaddrinfo
argument_list|(
name|buf
argument_list|,
name|strport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|aitop
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%.100s: unknown host. (%s)"
argument_list|,
name|buf
argument_list|,
name|ssh_gai_strerror
argument_list|(
name|gaierr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|ai
operator|=
name|aitop
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
comment|/* Create a socket. */
name|sock
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|ai
operator|->
name|ai_socktype
argument_list|,
name|ai
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Connect it to the display. */
if|if
condition|(
name|connect
argument_list|(
name|sock
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"connect %.100s port %u: %.100s"
argument_list|,
name|buf
argument_list|,
literal|6000
operator|+
name|display_number
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Success */
break|break;
block|}
name|freeaddrinfo
argument_list|(
name|aitop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ai
condition|)
block|{
name|error
argument_list|(
literal|"connect %.100s port %u: %.100s"
argument_list|,
name|buf
argument_list|,
literal|6000
operator|+
name|display_number
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|set_nodelay
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|sock
return|;
block|}
comment|/*  * This is called when SSH_SMSG_X11_OPEN is received.  The packet contains  * the remote channel number.  We should do whatever we want, and respond  * with either SSH_MSG_OPEN_CONFIRMATION or SSH_MSG_OPEN_FAILURE.  */
comment|/* ARGSUSED */
name|int
name|x11_input_open
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|int
name|remote_id
decl_stmt|,
name|sock
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|remote_host
decl_stmt|;
name|debug
argument_list|(
literal|"Received X11 open request."
argument_list|)
expr_stmt|;
name|remote_id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|packet_get_protocol_flags
argument_list|()
operator|&
name|SSH_PROTOFLAG_HOST_IN_FWD_OPEN
condition|)
block|{
name|remote_host
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|remote_host
operator|=
name|xstrdup
argument_list|(
literal|"unknown (remote did not supply name)"
argument_list|)
expr_stmt|;
block|}
name|packet_check_eom
argument_list|()
expr_stmt|;
comment|/* Obtain a connection to the real X display. */
name|sock
operator|=
name|x11_connect_display
argument_list|()
expr_stmt|;
if|if
condition|(
name|sock
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Allocate a channel for this connection. */
name|c
operator|=
name|channel_new
argument_list|(
literal|"connected x11 socket"
argument_list|,
name|SSH_CHANNEL_X11_OPEN
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|remote_host
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
name|remote_id
expr_stmt|;
name|c
operator|->
name|force_drain
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|remote_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
comment|/* Send refusal to the remote host. */
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Send a confirmation to the remote host. */
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* dummy protocol handler that denies SSH-1 requests (agent/x11) */
comment|/* ARGSUSED */
name|int
name|deny_input_open
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|rchan
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SSH_SMSG_AGENT_OPEN
case|:
name|error
argument_list|(
literal|"Warning: ssh server tried agent forwarding."
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_SMSG_X11_OPEN
case|:
name|error
argument_list|(
literal|"Warning: ssh server tried X11 forwarding."
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"deny_input_open: type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
argument_list|(
literal|"Warning: this is probably a break-in attempt by a malicious server."
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|rchan
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * Requests forwarding of X11 connections, generates fake authentication  * data, and enables authentication spoofing.  * This should be called in the client only.  */
name|void
name|x11_request_forwarding_with_spoofing
parameter_list|(
name|int
name|client_session_id
parameter_list|,
specifier|const
name|char
modifier|*
name|disp
parameter_list|,
specifier|const
name|char
modifier|*
name|proto
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|want_reply
parameter_list|)
block|{
name|u_int
name|data_len
init|=
operator|(
name|u_int
operator|)
name|strlen
argument_list|(
name|data
argument_list|)
operator|/
literal|2
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|value
decl_stmt|;
name|char
modifier|*
name|new_data
decl_stmt|;
name|int
name|screen_number
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|x11_saved_display
operator|==
name|NULL
condition|)
name|x11_saved_display
operator|=
name|xstrdup
argument_list|(
name|disp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|disp
argument_list|,
name|x11_saved_display
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"x11_request_forwarding_with_spoofing: different "
literal|"$DISPLAY already forwarded"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|disp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|screen_number
operator|=
operator|(
name|u_int
operator|)
name|strtonum
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|400
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|screen_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x11_saved_proto
operator|==
name|NULL
condition|)
block|{
comment|/* Save protocol name. */
name|x11_saved_proto
operator|=
name|xstrdup
argument_list|(
name|proto
argument_list|)
expr_stmt|;
comment|/* Extract real authentication data. */
name|x11_saved_data
operator|=
name|xmalloc
argument_list|(
name|data_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|data
operator|+
literal|2
operator|*
name|i
argument_list|,
literal|"%2x"
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"x11_request_forwarding: bad "
literal|"authentication data: %.100s"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|x11_saved_data
index|[
name|i
index|]
operator|=
name|value
expr_stmt|;
block|}
name|x11_saved_data_len
operator|=
name|data_len
expr_stmt|;
comment|/* Generate fake data of the same length. */
name|x11_fake_data
operator|=
name|xmalloc
argument_list|(
name|data_len
argument_list|)
expr_stmt|;
name|arc4random_buf
argument_list|(
name|x11_fake_data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|x11_fake_data_len
operator|=
name|data_len
expr_stmt|;
block|}
comment|/* Convert the fake data into hex. */
name|new_data
operator|=
name|tohex
argument_list|(
name|x11_fake_data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
comment|/* Send the request packet. */
if|if
condition|(
name|compat20
condition|)
block|{
name|channel_request_start
argument_list|(
name|client_session_id
argument_list|,
literal|"x11-req"
argument_list|,
name|want_reply
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX bool single connection */
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_X11_REQUEST_FORWARDING
argument_list|)
expr_stmt|;
block|}
name|packet_put_cstring
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|new_data
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|screen_number
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|new_data
argument_list|)
expr_stmt|;
block|}
comment|/* -- agent forwarding */
comment|/* Sends a message to the server to request authentication fd forwarding. */
name|void
name|auth_request_forwarding
parameter_list|(
name|void
parameter_list|)
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_AGENT_REQUEST_FORWARDING
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

