begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  * This file contains functions for generic socket connection forwarding.  * There is also code for initiating connection forwarding for X11 connections,  * arbitrary tcp/ip connections, and the authentication agent connection.  *  * As far as I am concerned, the code I have written for this software  * can be used freely for any purpose.  Any derived versions of this  * software must be clearly marked as such, and if the derived work is  * incompatible with the protocol description in the RFC file, it must be  * called by a name other than "ssh" or "Secure Shell".  *  *  * SSH2 support added by Markus Friedl.  * Copyright (c) 1999,2000 Markus Friedl.  All rights reserved.  * Copyright (c) 1999 Dug Song.  All rights reserved.  * Copyright (c) 1999 Theo de Raadt.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$OpenBSD: channels.c,v 1.72 2000/10/27 07:48:22 markus Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"uidswap.h"
end_include

begin_include
include|#
directive|include
file|"readconf.h"
end_include

begin_include
include|#
directive|include
file|"servconf.h"
end_include

begin_include
include|#
directive|include
file|"channels.h"
end_include

begin_include
include|#
directive|include
file|"nchan.h"
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|<openssl/rsa.h>
end_include

begin_include
include|#
directive|include
file|<openssl/dsa.h>
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"authfd.h"
end_include

begin_comment
comment|/* Maximum number of fake X11 displays to try. */
end_comment

begin_define
define|#
directive|define
name|MAX_DISPLAYS
value|1000
end_define

begin_comment
comment|/* Max len of agent socket */
end_comment

begin_define
define|#
directive|define
name|MAX_SOCKET_NAME
value|100
end_define

begin_comment
comment|/*  * Pointer to an array containing all allocated channels.  The array is  * dynamically extended as needed.  */
end_comment

begin_decl_stmt
specifier|static
name|Channel
modifier|*
name|channels
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Size of the channel array.  All slots of the array must always be  * initialized (at least the type field); unused slots are marked with type  * SSH_CHANNEL_FREE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|channels_alloc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Maximum file descriptor value used in any of the channels.  This is  * updated in channel_allocate.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|channel_max_fd_value
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name and directory of socket for authentication agent forwarding. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|channel_forwarded_auth_socket_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|channel_forwarded_auth_socket_dir
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Saved X11 authentication protocol name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|x11_saved_proto
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Saved X11 authentication data.  This is the real data. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|x11_saved_data
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|x11_saved_data_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Fake X11 authentication data.  This is what the server will be sending us;  * we should replace any occurrences of this by the real data.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|x11_fake_data
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|x11_fake_data_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Data structure for storing which hosts are permitted for forward requests.  * The local sides of any remote forwards are stored in this array to prevent  * a corrupt remote server from accessing arbitrary TCP/IP ports on our local  * network (which might be behind a firewall).  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|host_to_connect
decl_stmt|;
comment|/* Connect to 'host'. */
name|u_short
name|port_to_connect
decl_stmt|;
comment|/* Connect to 'port'. */
name|u_short
name|listen_port
decl_stmt|;
comment|/* Remote side should listen port number. */
block|}
name|ForwardPermission
typedef|;
end_typedef

begin_comment
comment|/* List of all permitted host/port pairs to connect. */
end_comment

begin_decl_stmt
specifier|static
name|ForwardPermission
name|permitted_opens
index|[
name|SSH_MAX_FORWARDS_PER_DIRECTION
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of permitted host/port pairs in the array. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_permitted_opens
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If this is true, all opens are permitted.  This is the case on the server  * on which we have to trust the client anyway, and the user could do  * anything after logging in anyway.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|all_opens_permitted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is set to true if both sides support SSH_PROTOFLAG_HOST_IN_FWD_OPEN. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_hostname_in_open
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sets specific protocol options. */
end_comment

begin_function
name|void
name|channel_set_options
parameter_list|(
name|int
name|hostname_in_open
parameter_list|)
block|{
name|have_hostname_in_open
operator|=
name|hostname_in_open
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Permits opening to any host/port in SSH_MSG_PORT_OPEN.  This is usually  * called by the server, because the user could connect to any port anyway,  * and the server has no way to know but to trust the client anyway.  */
end_comment

begin_function
name|void
name|channel_permit_all_opens
parameter_list|()
block|{
name|all_opens_permitted
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* lookup channel by id */
end_comment

begin_function
name|Channel
modifier|*
name|channel_lookup
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
operator|||
name|id
operator|>=
name|channels_alloc
condition|)
block|{
name|log
argument_list|(
literal|"channel_lookup: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|=
operator|&
name|channels
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_FREE
condition|)
block|{
name|log
argument_list|(
literal|"channel_lookup: %d: bad id: channel free"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * Register filedescriptors for a channel, used when allocating a channel or  * when the channel consumer/producer is ready, e.g. shell exec'd  */
end_comment

begin_function
name|void
name|channel_register_fds
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|int
name|rfd
parameter_list|,
name|int
name|wfd
parameter_list|,
name|int
name|efd
parameter_list|,
name|int
name|extusage
parameter_list|,
name|int
name|nonblock
parameter_list|)
block|{
comment|/* Update the maximum file descriptor value. */
if|if
condition|(
name|rfd
operator|>
name|channel_max_fd_value
condition|)
name|channel_max_fd_value
operator|=
name|rfd
expr_stmt|;
if|if
condition|(
name|wfd
operator|>
name|channel_max_fd_value
condition|)
name|channel_max_fd_value
operator|=
name|wfd
expr_stmt|;
if|if
condition|(
name|efd
operator|>
name|channel_max_fd_value
condition|)
name|channel_max_fd_value
operator|=
name|efd
expr_stmt|;
comment|/* XXX set close-on-exec -markus */
name|c
operator|->
name|rfd
operator|=
name|rfd
expr_stmt|;
name|c
operator|->
name|wfd
operator|=
name|wfd
expr_stmt|;
name|c
operator|->
name|sock
operator|=
operator|(
name|rfd
operator|==
name|wfd
operator|)
condition|?
name|rfd
else|:
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|efd
operator|=
name|efd
expr_stmt|;
name|c
operator|->
name|extended_usage
operator|=
name|extusage
expr_stmt|;
comment|/* XXX ugly hack: nonblock is only set by the server */
if|if
condition|(
name|nonblock
operator|&&
name|isatty
argument_list|(
name|c
operator|->
name|rfd
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"channel: %d: rfd %d isatty"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|rfd
argument_list|)
expr_stmt|;
name|c
operator|->
name|isatty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|c
operator|->
name|wfd
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"channel: %d: wfd %d is not a tty?"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|wfd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|c
operator|->
name|isatty
operator|=
literal|0
expr_stmt|;
block|}
comment|/* enable nonblocking mode */
if|if
condition|(
name|nonblock
condition|)
block|{
if|if
condition|(
name|rfd
operator|!=
operator|-
literal|1
condition|)
name|set_nonblock
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|wfd
operator|!=
operator|-
literal|1
condition|)
name|set_nonblock
argument_list|(
name|wfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|efd
operator|!=
operator|-
literal|1
condition|)
name|set_nonblock
argument_list|(
name|efd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a new channel object and set its type and socket. This will cause  * remote_name to be freed.  */
end_comment

begin_function
name|int
name|channel_new
parameter_list|(
name|char
modifier|*
name|ctype
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rfd
parameter_list|,
name|int
name|wfd
parameter_list|,
name|int
name|efd
parameter_list|,
name|int
name|window
parameter_list|,
name|int
name|maxpack
parameter_list|,
name|int
name|extusage
parameter_list|,
name|char
modifier|*
name|remote_name
parameter_list|,
name|int
name|nonblock
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|found
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
comment|/* Do initial allocation if this is the first call. */
if|if
condition|(
name|channels_alloc
operator|==
literal|0
condition|)
block|{
name|chan_init
argument_list|()
expr_stmt|;
name|channels_alloc
operator|=
literal|10
expr_stmt|;
name|channels
operator|=
name|xmalloc
argument_list|(
name|channels_alloc
operator|*
sizeof|sizeof
argument_list|(
name|Channel
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
name|channels
index|[
name|i
index|]
operator|.
name|type
operator|=
name|SSH_CHANNEL_FREE
expr_stmt|;
comment|/* 		 * Kludge: arrange a call to channel_stop_listening if we 		 * terminate with fatal(). 		 */
name|fatal_add_cleanup
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|channel_stop_listening
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Try to find a free slot where to put the new channel. */
for|for
control|(
name|found
operator|=
operator|-
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|type
operator|==
name|SSH_CHANNEL_FREE
condition|)
block|{
comment|/* Found a free slot. */
name|found
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* There are no free slots.  Take last+1 slot and expand the array.  */
name|found
operator|=
name|channels_alloc
expr_stmt|;
name|channels_alloc
operator|+=
literal|10
expr_stmt|;
name|debug2
argument_list|(
literal|"channel: expanding %d"
argument_list|,
name|channels_alloc
argument_list|)
expr_stmt|;
name|channels
operator|=
name|xrealloc
argument_list|(
name|channels
argument_list|,
name|channels_alloc
operator|*
sizeof|sizeof
argument_list|(
name|Channel
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|found
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
name|channels
index|[
name|i
index|]
operator|.
name|type
operator|=
name|SSH_CHANNEL_FREE
expr_stmt|;
block|}
comment|/* Initialize and return new channel number. */
name|c
operator|=
operator|&
name|channels
index|[
name|found
index|]
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
expr_stmt|;
name|chan_init_iostates
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|channel_register_fds
argument_list|(
name|c
argument_list|,
name|rfd
argument_list|,
name|wfd
argument_list|,
name|efd
argument_list|,
name|extusage
argument_list|,
name|nonblock
argument_list|)
expr_stmt|;
name|c
operator|->
name|self
operator|=
name|found
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|c
operator|->
name|ctype
operator|=
name|ctype
expr_stmt|;
name|c
operator|->
name|local_window
operator|=
name|window
expr_stmt|;
name|c
operator|->
name|local_window_max
operator|=
name|window
expr_stmt|;
name|c
operator|->
name|local_consumed
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|local_maxpacket
operator|=
name|maxpack
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|remote_name
operator|=
name|remote_name
expr_stmt|;
name|c
operator|->
name|remote_window
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|remote_maxpacket
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|cb_fn
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|cb_arg
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|cb_event
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|dettach_user
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|input_filter
operator|=
name|NULL
expr_stmt|;
name|debug
argument_list|(
literal|"channel %d: new [%s]"
argument_list|,
name|found
argument_list|,
name|remote_name
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* old interface XXX */
end_comment

begin_function
name|int
name|channel_allocate
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|sock
parameter_list|,
name|char
modifier|*
name|remote_name
parameter_list|)
block|{
return|return
name|channel_new
argument_list|(
literal|""
argument_list|,
name|type
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|remote_name
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Close all channel fd/socket. */
end_comment

begin_function
name|void
name|channel_close_fds
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|sock
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|c
operator|->
name|sock
argument_list|)
expr_stmt|;
name|c
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|rfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|c
operator|->
name|rfd
argument_list|)
expr_stmt|;
name|c
operator|->
name|rfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|wfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|c
operator|->
name|wfd
argument_list|)
expr_stmt|;
name|c
operator|->
name|wfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|efd
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
name|c
operator|->
name|efd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free the channel and close its fd/socket. */
end_comment

begin_function
name|void
name|channel_free
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"channel free: bad local channel %d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"channel_free: channel %d: status: %s"
argument_list|,
name|id
argument_list|,
name|channel_open_message
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|dettach_user
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"channel_free: channel %d: dettaching channel user"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|c
operator|->
name|dettach_user
argument_list|(
name|c
operator|->
name|self
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|sock
operator|!=
operator|-
literal|1
condition|)
name|shutdown
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|SHUT_RDWR
argument_list|)
expr_stmt|;
name|channel_close_fds
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_FREE
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|remote_name
condition|)
block|{
name|xfree
argument_list|(
name|c
operator|->
name|remote_name
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * 'channel_pre*' are called just before select() to add any bits relevant to  * channels in the select bitmasks.  */
end_comment

begin_comment
comment|/*  * 'channel_post*': perform any appropriate operations for channels which  * have events pending.  */
end_comment

begin_typedef
typedef|typedef
name|void
name|chan_fn
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
name|chan_fn
modifier|*
name|channel_pre
index|[
name|SSH_CHANNEL_MAX_TYPE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|chan_fn
modifier|*
name|channel_post
index|[
name|SSH_CHANNEL_MAX_TYPE
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|channel_pre_listener
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_pre_open_13
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|<
name|packet_get_maxsize
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_pre_open_15
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
comment|/* test whether sockets are 'alive' for read/write */
if|if
condition|(
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_OPEN
condition|)
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|<
name|packet_get_maxsize
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_OPEN
operator|||
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_WAIT_DRAIN
condition|)
block|{
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_WAIT_DRAIN
condition|)
block|{
name|chan_obuf_empty
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|channel_pre_open_20
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_OPEN
operator|&&
name|c
operator|->
name|remote_window
operator|>
literal|0
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|<
name|c
operator|->
name|remote_window
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|rfd
argument_list|,
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_OPEN
operator|||
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_WAIT_DRAIN
condition|)
block|{
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_WAIT_DRAIN
condition|)
block|{
name|chan_obuf_empty
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** XXX check close conditions, too */
if|if
condition|(
name|c
operator|->
name|efd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_WRITE
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_READ
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
operator|<
name|c
operator|->
name|remote_window
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|readset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|channel_pre_input_draining
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_CLOSED
expr_stmt|;
name|debug
argument_list|(
literal|"Closing channel %d after input drain."
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|channel_pre_output_draining
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|==
literal|0
condition|)
name|channel_free
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
else|else
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is a special state for X11 authentication spoofing.  An opened X11  * connection (when authentication spoofing is being done) remains in this  * state until the first packet has been completely read.  The authentication  * data in that packet is then substituted by the real data if it matches the  * fake data, and the channel is put into normal mode.  * XXX All this happens at the client side.  */
end_comment

begin_function
name|int
name|x11_open_helper
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ucp
decl_stmt|;
name|unsigned
name|int
name|proto_len
decl_stmt|,
name|data_len
decl_stmt|;
comment|/* Check if the fixed size part of the packet is in buffer. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|<
literal|12
condition|)
return|return
literal|0
return|;
comment|/* Parse the lengths of variable-length fields. */
name|ucp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucp
index|[
literal|0
index|]
operator|==
literal|0x42
condition|)
block|{
comment|/* Byte order MSB first. */
name|proto_len
operator|=
literal|256
operator|*
name|ucp
index|[
literal|6
index|]
operator|+
name|ucp
index|[
literal|7
index|]
expr_stmt|;
name|data_len
operator|=
literal|256
operator|*
name|ucp
index|[
literal|8
index|]
operator|+
name|ucp
index|[
literal|9
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ucp
index|[
literal|0
index|]
operator|==
literal|0x6c
condition|)
block|{
comment|/* Byte order LSB first. */
name|proto_len
operator|=
name|ucp
index|[
literal|6
index|]
operator|+
literal|256
operator|*
name|ucp
index|[
literal|7
index|]
expr_stmt|;
name|data_len
operator|=
name|ucp
index|[
literal|8
index|]
operator|+
literal|256
operator|*
name|ucp
index|[
literal|9
index|]
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"Initial X11 packet contains bad byte order byte: 0x%x"
argument_list|,
name|ucp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check if the whole packet is in buffer. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|<
literal|12
operator|+
operator|(
operator|(
name|proto_len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
operator|+
operator|(
operator|(
name|data_len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Check if authentication protocol matches. */
if|if
condition|(
name|proto_len
operator|!=
name|strlen
argument_list|(
name|x11_saved_proto
argument_list|)
operator|||
name|memcmp
argument_list|(
name|ucp
operator|+
literal|12
argument_list|,
name|x11_saved_proto
argument_list|,
name|proto_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"X11 connection uses different authentication protocol."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check if authentication data matches our fake data. */
if|if
condition|(
name|data_len
operator|!=
name|x11_fake_data_len
operator|||
name|memcmp
argument_list|(
name|ucp
operator|+
literal|12
operator|+
operator|(
operator|(
name|proto_len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
argument_list|,
name|x11_fake_data
argument_list|,
name|x11_fake_data_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"X11 auth data does not match fake data."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check fake data length */
if|if
condition|(
name|x11_fake_data_len
operator|!=
name|x11_saved_data_len
condition|)
block|{
name|error
argument_list|(
literal|"X11 fake_data_len %d != saved_data_len %d"
argument_list|,
name|x11_fake_data_len
argument_list|,
name|x11_saved_data_len
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Received authentication protocol and data match 	 * our fake data. Substitute the fake data with real 	 * data. 	 */
name|memcpy
argument_list|(
name|ucp
operator|+
literal|12
operator|+
operator|(
operator|(
name|proto_len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
argument_list|,
name|x11_saved_data
argument_list|,
name|x11_saved_data_len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|channel_pre_x11_open_13
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|ret
init|=
name|x11_open_helper
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
comment|/* Start normal processing for the channel. */
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
name|channel_pre_open_13
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * We have received an X11 connection that has bad 		 * authentication information. 		 */
name|log
argument_list|(
literal|"X11 connection rejected because of wrong authentication.\r\n"
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|c
operator|->
name|sock
argument_list|)
expr_stmt|;
name|c
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_CLOSED
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|channel_pre_x11_open
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|ret
init|=
name|x11_open_helper
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
name|channel_pre_open_20
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
else|else
name|channel_pre_open_15
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|debug
argument_list|(
literal|"X11 rejected %d i%d/o%d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|istate
argument_list|,
name|c
operator|->
name|ostate
argument_list|)
expr_stmt|;
name|chan_read_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/** force close? */
name|chan_write_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"X11 closed %d i%d/o%d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|istate
argument_list|,
name|c
operator|->
name|ostate
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is our fake X11 server socket. */
end_comment

begin_function
name|void
name|channel_post_x11_listener
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|struct
name|sockaddr
name|addr
decl_stmt|;
name|int
name|newsock
decl_stmt|,
name|newch
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
name|char
name|buf
index|[
literal|16384
index|]
decl_stmt|,
modifier|*
name|remote_hostname
decl_stmt|;
name|int
name|remote_port
decl_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"X11 connection requested."
argument_list|)
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|newsock
operator|=
name|accept
argument_list|(
name|c
operator|->
name|sock
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsock
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"accept: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|remote_hostname
operator|=
name|get_remote_hostname
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
name|remote_port
operator|=
name|get_peer_port
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"X11 connection from %.200s port %d"
argument_list|,
name|remote_hostname
argument_list|,
name|remote_port
argument_list|)
expr_stmt|;
name|newch
operator|=
name|channel_new
argument_list|(
literal|"x11"
argument_list|,
name|SSH_CHANNEL_OPENING
argument_list|,
name|newsock
argument_list|,
name|newsock
argument_list|,
operator|-
literal|1
argument_list|,
name|c
operator|->
name|local_window_max
argument_list|,
name|c
operator|->
name|local_maxpacket
argument_list|,
literal|0
argument_list|,
name|xstrdup
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"x11"
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|newch
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window_max
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
comment|/* originator host and port */
name|packet_put_cstring
argument_list|(
name|remote_hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|datafellows
operator|&
name|SSH_BUG_X11FWD
condition|)
block|{
name|debug
argument_list|(
literal|"ssh2 x11 bug compat mode"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|packet_put_int
argument_list|(
name|remote_port
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_SMSG_X11_OPEN
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|newch
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_hostname_in_open
condition|)
name|packet_put_string
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|xfree
argument_list|(
name|remote_hostname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This socket is listening for connections to a forwarded TCP/IP port.  */
end_comment

begin_function
name|void
name|channel_post_port_listener
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|struct
name|sockaddr
name|addr
decl_stmt|;
name|int
name|newsock
decl_stmt|,
name|newch
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
name|remote_hostname
decl_stmt|;
name|int
name|remote_port
decl_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"Connection to port %d forwarding "
literal|"to %.100s port %d requested."
argument_list|,
name|c
operator|->
name|listening_port
argument_list|,
name|c
operator|->
name|path
argument_list|,
name|c
operator|->
name|host_port
argument_list|)
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|newsock
operator|=
name|accept
argument_list|(
name|c
operator|->
name|sock
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsock
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"accept: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|remote_hostname
operator|=
name|get_remote_hostname
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
name|remote_port
operator|=
name|get_peer_port
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"listen port %d for %.100s port %d, "
literal|"connect from %.200s port %d"
argument_list|,
name|c
operator|->
name|listening_port
argument_list|,
name|c
operator|->
name|path
argument_list|,
name|c
operator|->
name|host_port
argument_list|,
name|remote_hostname
argument_list|,
name|remote_port
argument_list|)
expr_stmt|;
name|newch
operator|=
name|channel_new
argument_list|(
literal|"direct-tcpip"
argument_list|,
name|SSH_CHANNEL_OPENING
argument_list|,
name|newsock
argument_list|,
name|newsock
argument_list|,
operator|-
literal|1
argument_list|,
name|c
operator|->
name|local_window_max
argument_list|,
name|c
operator|->
name|local_maxpacket
argument_list|,
literal|0
argument_list|,
name|xstrdup
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"direct-tcpip"
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|newch
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window_max
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
comment|/* target host and port */
name|packet_put_string
argument_list|(
name|c
operator|->
name|path
argument_list|,
name|strlen
argument_list|(
name|c
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|host_port
argument_list|)
expr_stmt|;
comment|/* originator host and port */
name|packet_put_cstring
argument_list|(
name|remote_hostname
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_port
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_MSG_PORT_OPEN
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|newch
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|c
operator|->
name|path
argument_list|,
name|strlen
argument_list|(
name|c
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|host_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_hostname_in_open
condition|)
block|{
name|packet_put_string
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|xfree
argument_list|(
name|remote_hostname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is the authentication agent socket listening for connections from  * clients.  */
end_comment

begin_function
name|void
name|channel_post_auth_listener
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|struct
name|sockaddr
name|addr
decl_stmt|;
name|int
name|newsock
decl_stmt|,
name|newch
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|newsock
operator|=
name|accept
argument_list|(
name|c
operator|->
name|sock
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsock
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"accept from auth socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|newch
operator|=
name|channel_allocate
argument_list|(
name|SSH_CHANNEL_OPENING
argument_list|,
name|newsock
argument_list|,
name|xstrdup
argument_list|(
literal|"accepted auth socket"
argument_list|)
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_SMSG_AGENT_OPEN
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|newch
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|channel_handle_rfd
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|char
name|buf
index|[
literal|16
operator|*
literal|1024
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|rfd
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|c
operator|->
name|rfd
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|len
operator|=
name|read
argument_list|(
name|c
operator|->
name|rfd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: read<=0 rfd %d len %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|rfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat13
condition|)
block|{
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_INPUT_DRAINING
expr_stmt|;
name|debug
argument_list|(
literal|"Channel %d status set to input draining."
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan_read_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|c
operator|->
name|input_filter
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|input_filter
argument_list|(
name|c
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|debug
argument_list|(
literal|"filter stops channel %d"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|chan_read_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|channel_handle_wfd
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* Send buffered output data to the socket. */
if|if
condition|(
name|c
operator|->
name|wfd
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
name|writeset
argument_list|)
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|compat13
condition|)
block|{
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Channel %d status set to input draining."
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_INPUT_DRAINING
expr_stmt|;
block|}
else|else
block|{
name|chan_write_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|compat20
operator|&&
name|c
operator|->
name|isatty
condition|)
block|{
name|struct
name|termios
name|tio
decl_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
operator|&
name|tio
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|tio
operator|.
name|c_lflag
operator|&
name|ECHO
operator|)
operator|&&
operator|(
name|tio
operator|.
name|c_lflag
operator|&
name|ICANON
operator|)
condition|)
block|{
comment|/* 				 * Simulate echo to reduce the impact of 				 * traffic analysis. 				 */
name|packet_start
argument_list|(
name|SSH2_MSG_IGNORE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
name|c
operator|->
name|local_consumed
operator|+=
name|len
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|channel_handle_efd
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|char
name|buf
index|[
literal|16
operator|*
literal|1024
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/** XXX handle drain efd, too */
if|if
condition|(
name|c
operator|->
name|efd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_WRITE
operator|&&
name|FD_ISSET
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|writeset
argument_list|)
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: written %d to efd %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|len
argument_list|,
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|c
operator|->
name|local_consumed
operator|+=
name|len
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_READ
operator|&&
name|FD_ISSET
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|len
operator|=
name|read
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: read %d from efd %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|len
argument_list|,
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: closing efd %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
name|c
operator|->
name|efd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|channel_check_window
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
operator|(
name|CHAN_CLOSE_SENT
operator||
name|CHAN_CLOSE_RCVD
operator|)
operator|)
operator|&&
name|c
operator|->
name|local_window
operator|<
name|c
operator|->
name|local_window_max
operator|/
literal|2
operator|&&
name|c
operator|->
name|local_consumed
operator|>
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_WINDOW_ADJUST
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_consumed
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: window %d sent adjust %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|local_window
argument_list|,
name|c
operator|->
name|local_consumed
argument_list|)
expr_stmt|;
name|c
operator|->
name|local_window
operator|+=
name|c
operator|->
name|local_consumed
expr_stmt|;
name|c
operator|->
name|local_consumed
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|channel_post_open_1
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|channel_handle_rfd
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
name|channel_handle_wfd
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_post_open_2
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|channel_handle_rfd
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
name|channel_handle_wfd
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
name|channel_handle_efd
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
name|channel_check_window
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_post_output_drain_13
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* Send buffered output data to the socket. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|writeset
argument_list|)
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|channel_handler_init_20
parameter_list|(
name|void
parameter_list|)
block|{
name|channel_pre
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_pre_open_20
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_OPEN
index|]
operator|=
operator|&
name|channel_pre_x11_open
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_post_open_2
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_post_port_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_post_x11_listener
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_handler_init_13
parameter_list|(
name|void
parameter_list|)
block|{
name|channel_pre
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_pre_open_13
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_OPEN
index|]
operator|=
operator|&
name|channel_pre_x11_open_13
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_INPUT_DRAINING
index|]
operator|=
operator|&
name|channel_pre_input_draining
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_OUTPUT_DRAINING
index|]
operator|=
operator|&
name|channel_pre_output_draining
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_post_open_1
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_post_x11_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_post_port_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_post_auth_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_OUTPUT_DRAINING
index|]
operator|=
operator|&
name|channel_post_output_drain_13
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_handler_init_15
parameter_list|(
name|void
parameter_list|)
block|{
name|channel_pre
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_pre_open_15
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_OPEN
index|]
operator|=
operator|&
name|channel_pre_x11_open
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_post_x11_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_post_port_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_post_auth_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_post_open_1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_handler_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SSH_CHANNEL_MAX_TYPE
condition|;
name|i
operator|++
control|)
block|{
name|channel_pre
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|channel_post
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|compat20
condition|)
name|channel_handler_init_20
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|compat13
condition|)
name|channel_handler_init_13
argument_list|()
expr_stmt|;
else|else
name|channel_handler_init_15
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_handler
parameter_list|(
name|chan_fn
modifier|*
name|ftab
index|[]
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
specifier|static
name|int
name|did_init
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|did_init
condition|)
block|{
name|channel_handler_init
argument_list|()
expr_stmt|;
name|did_init
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_FREE
condition|)
continue|continue;
if|if
condition|(
name|ftab
index|[
name|c
operator|->
name|type
index|]
operator|==
name|NULL
condition|)
continue|continue;
call|(
modifier|*
name|ftab
index|[
name|c
operator|->
name|type
index|]
call|)
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
name|chan_delete_if_full_closed
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|channel_prepare_select
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|channel_handler
argument_list|(
name|channel_pre
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_after_select
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|channel_handler
argument_list|(
name|channel_post
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If there is data to send to the connection, send some of it now. */
end_comment

begin_function
name|void
name|channel_output_poll
parameter_list|()
block|{
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|channels
index|[
name|i
index|]
expr_stmt|;
comment|/* We are only interested in channels that can have buffered incoming data. */
if|if
condition|(
name|compat13
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
operator|&&
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_INPUT_DRAINING
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
condition|)
continue|continue;
if|if
condition|(
name|c
operator|->
name|istate
operator|!=
name|CHAN_INPUT_OPEN
operator|&&
name|c
operator|->
name|istate
operator|!=
name|CHAN_INPUT_WAIT_DRAIN
condition|)
continue|continue;
block|}
if|if
condition|(
name|compat20
operator|&&
operator|(
name|c
operator|->
name|flags
operator|&
operator|(
name|CHAN_CLOSE_SENT
operator||
name|CHAN_CLOSE_RCVD
operator|)
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|"channel: %d: no data after CLOSE"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the amount of buffered data for this channel. */
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Send some data for the other side over the secure connection. */
if|if
condition|(
name|compat20
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|c
operator|->
name|remote_window
condition|)
name|len
operator|=
name|c
operator|->
name|remote_window
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|c
operator|->
name|remote_maxpacket
condition|)
name|len
operator|=
name|c
operator|->
name|remote_maxpacket
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|packet_is_interactive
argument_list|()
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|1024
condition|)
name|len
operator|=
literal|512
expr_stmt|;
block|}
else|else
block|{
comment|/* Keep the packets at reasonable size. */
if|if
condition|(
name|len
operator|>
name|packet_get_maxsize
argument_list|()
operator|/
literal|2
condition|)
name|len
operator|=
name|packet_get_maxsize
argument_list|()
operator|/
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|compat20
condition|?
name|SSH2_MSG_CHANNEL_DATA
else|:
name|SSH_MSG_CHANNEL_DATA
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_window
operator|-=
name|len
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_WAIT_DRAIN
condition|)
block|{
if|if
condition|(
name|compat13
condition|)
name|fatal
argument_list|(
literal|"cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3"
argument_list|)
expr_stmt|;
comment|/* 			 * input-buffer is empty and read-socket shutdown: 			 * tell peer, that we will not send more data: send IEOF 			 */
name|chan_ibuf_empty
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Send extended data, i.e. stderr */
if|if
condition|(
name|compat20
operator|&&
name|c
operator|->
name|remote_window
operator|>
literal|0
operator|&&
operator|(
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_READ
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|c
operator|->
name|remote_window
condition|)
name|len
operator|=
name|c
operator|->
name|remote_window
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|c
operator|->
name|remote_maxpacket
condition|)
name|len
operator|=
name|c
operator|->
name|remote_maxpacket
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_EXTENDED_DATA
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|SSH2_EXTENDED_DATA_STDERR
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_window
operator|-=
name|len
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * This is called when a packet of type CHANNEL_DATA has just been received.  * The message type has already been consumed, but channel number and data is  * still there.  */
end_comment

begin_function
name|void
name|channel_input_data
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|data_len
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
comment|/* Get the channel number and verify it. */
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received data for nonexistent channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* Ignore any data for non-open channels (might happen on close) */
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
operator|&&
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_X11_OPEN
condition|)
return|return;
comment|/* same for protocol 1.5 if output end is no longer open */
if|if
condition|(
operator|!
name|compat13
operator|&&
name|c
operator|->
name|ostate
operator|!=
name|CHAN_OUTPUT_OPEN
condition|)
return|return;
comment|/* Get the data. */
name|data
operator|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
expr_stmt|;
name|packet_done
argument_list|()
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
if|if
condition|(
name|data_len
operator|>
name|c
operator|->
name|local_maxpacket
condition|)
block|{
name|log
argument_list|(
literal|"channel %d: rcvd big packet %d, maxpack %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|data_len
argument_list|,
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data_len
operator|>
name|c
operator|->
name|local_window
condition|)
block|{
name|log
argument_list|(
literal|"channel %d: rcvd too much data %d, win %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|data_len
argument_list|,
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|local_window
operator|-=
name|data_len
expr_stmt|;
block|}
else|else
block|{
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
literal|4
operator|+
literal|4
operator|+
name|data_len
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_input_extended_data
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|int
name|tcode
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|data_len
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
comment|/* Get the channel number and verify it. */
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received extended_data for bad channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
condition|)
block|{
name|log
argument_list|(
literal|"channel %d: ext data for non open"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|tcode
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|efd
operator|==
operator|-
literal|1
operator|||
name|c
operator|->
name|extended_usage
operator|!=
name|CHAN_EXTENDED_WRITE
operator|||
name|tcode
operator|!=
name|SSH2_EXTENDED_DATA_STDERR
condition|)
block|{
name|log
argument_list|(
literal|"channel %d: bad ext data"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
return|return;
block|}
name|data
operator|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
expr_stmt|;
name|packet_done
argument_list|()
expr_stmt|;
if|if
condition|(
name|data_len
operator|>
name|c
operator|->
name|local_window
condition|)
block|{
name|log
argument_list|(
literal|"channel %d: rcvd too much extended_data %d, win %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|data_len
argument_list|,
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
name|debug2
argument_list|(
literal|"channel %d: rcvd ext data %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|c
operator|->
name|local_window
operator|-=
name|data_len
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns true if no channel has too much buffered data, and false if one or  * more channel is overfull.  */
end_comment

begin_function
name|int
name|channel_not_very_much_buffered_data
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_OPEN
condition|)
block|{
if|if
condition|(
operator|!
name|compat20
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|>
name|packet_get_maxsize
argument_list|()
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: big input buffer %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
name|packet_get_maxsize
argument_list|()
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: big output buffer %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|channel_input_ieof
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received ieof for nonexistent channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|chan_rcvd_ieof
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_input_close
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received close for nonexistent channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* 	 * Send a confirmation that we have closed the channel and no more 	 * data is coming for it. 	 */
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* 	 * If the channel is in closed state, we have sent a close request, 	 * and the other side will eventually respond with a confirmation. 	 * Thus, we cannot free the channel here, because then there would be 	 * no-one to receive the confirmation.  The channel gets freed when 	 * the confirmation arrives. 	 */
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_CLOSED
condition|)
block|{
comment|/* 		 * Not a closed channel - mark it as draining, which will 		 * cause it to be freed later. 		 */
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OUTPUT_DRAINING
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* proto version 1.5 overloads CLOSE_CONFIRMATION with OCLOSE */
end_comment

begin_function
name|void
name|channel_input_oclose
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received oclose for nonexistent channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|chan_rcvd_oclose
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_input_close_confirmation
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|packet_done
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received close confirmation for "
literal|"out-of-range channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_CLOSED
condition|)
name|packet_disconnect
argument_list|(
literal|"Received close confirmation for "
literal|"non-closed channel %d (type %d)."
argument_list|,
name|id
argument_list|,
name|c
operator|->
name|type
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_input_open_confirmation
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|,
name|remote_id
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|compat20
condition|)
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
literal|4
operator|+
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPENING
condition|)
name|packet_disconnect
argument_list|(
literal|"Received open confirmation for "
literal|"non-opening channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|remote_id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
comment|/* Record the remote channel number and mark that the channel is now open. */
name|c
operator|->
name|remote_id
operator|=
name|remote_id
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|c
operator|->
name|remote_window
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|->
name|remote_maxpacket
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_done
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|cb_fn
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|cb_event
operator|==
name|type
condition|)
block|{
name|debug2
argument_list|(
literal|"callback start"
argument_list|)
expr_stmt|;
name|c
operator|->
name|cb_fn
argument_list|(
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"callback done"
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"channel %d: open confirm rwindow %d rmax %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|remote_window
argument_list|,
name|c
operator|->
name|remote_maxpacket
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|channel_input_open_failure
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|compat20
condition|)
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPENING
condition|)
name|packet_disconnect
argument_list|(
literal|"Received open failure for "
literal|"non-opening channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|int
name|reason
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|char
modifier|*
name|lang
init|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|log
argument_list|(
literal|"channel_open_failure: %d: reason %d: %s"
argument_list|,
name|id
argument_list|,
name|reason
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|packet_done
argument_list|()
expr_stmt|;
name|xfree
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|lang
argument_list|)
expr_stmt|;
block|}
comment|/* Free the channel.  This will also close the socket. */
name|channel_free
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_input_channel_request
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
operator|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
operator|&&
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_LARVAL
operator|)
condition|)
name|packet_disconnect
argument_list|(
literal|"Received request for "
literal|"non-open channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|cb_fn
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|cb_event
operator|==
name|type
condition|)
block|{
name|debug2
argument_list|(
literal|"callback start"
argument_list|)
expr_stmt|;
name|c
operator|->
name|cb_fn
argument_list|(
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"callback done"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|service
init|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|debug
argument_list|(
literal|"channel: %d rcvd request for %s"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"cb_fn %p cb_event %d"
argument_list|,
name|c
operator|->
name|cb_fn
argument_list|,
name|c
operator|->
name|cb_event
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|channel_input_window_adjust
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
name|int
name|id
decl_stmt|,
name|adjust
decl_stmt|;
if|if
condition|(
operator|!
name|compat20
condition|)
return|return;
comment|/* Get the channel number and verify it. */
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
condition|)
block|{
name|log
argument_list|(
literal|"Received window adjust for "
literal|"non-open channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|adjust
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_done
argument_list|()
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: rcvd adjust %d"
argument_list|,
name|id
argument_list|,
name|adjust
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_window
operator|+=
name|adjust
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stops listening for channels, and removes any unix domain sockets that we  * might have.  */
end_comment

begin_function
name|void
name|channel_stop_listening
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|SSH_CHANNEL_AUTH_SOCKET
case|:
name|close
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|sock
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|path
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_CHANNEL_PORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_X11_LISTENER
case|:
name|close
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|sock
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Closes the sockets/fds of all channels.  This is used to close extra file  * descriptors after a fork.  */
end_comment

begin_function
name|void
name|channel_close_all
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|SSH_CHANNEL_FREE
condition|)
name|channel_close_fds
argument_list|(
operator|&
name|channels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the maximum file descriptor number used by the channels. */
end_comment

begin_function
name|int
name|channel_max_fd
parameter_list|()
block|{
return|return
name|channel_max_fd_value
return|;
block|}
end_function

begin_comment
comment|/* Returns true if any channel is still open. */
end_comment

begin_function
name|int
name|channel_still_open
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|SSH_CHANNEL_FREE
case|:
case|case
name|SSH_CHANNEL_X11_LISTENER
case|:
case|case
name|SSH_CHANNEL_PORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_CLOSED
case|:
case|case
name|SSH_CHANNEL_AUTH_SOCKET
case|:
continue|continue;
case|case
name|SSH_CHANNEL_LARVAL
case|:
if|if
condition|(
operator|!
name|compat20
condition|)
name|fatal
argument_list|(
literal|"cannot happen: SSH_CHANNEL_LARVAL"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|SSH_CHANNEL_OPENING
case|:
case|case
name|SSH_CHANNEL_OPEN
case|:
case|case
name|SSH_CHANNEL_X11_OPEN
case|:
return|return
literal|1
return|;
case|case
name|SSH_CHANNEL_INPUT_DRAINING
case|:
case|case
name|SSH_CHANNEL_OUTPUT_DRAINING
case|:
if|if
condition|(
operator|!
name|compat13
condition|)
name|fatal
argument_list|(
literal|"cannot happen: OUT_DRAIN"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|fatal
argument_list|(
literal|"channel_still_open: bad channel type %d"
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a message describing the currently open forwarded connections,  * suitable for sending to the client.  The message contains crlf pairs for  * newlines.  */
end_comment

begin_function
name|char
modifier|*
name|channel_open_message
parameter_list|()
block|{
name|Buffer
name|buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|buffer_init
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"The following connections are open:\r\n"
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|Channel
modifier|*
name|c
init|=
operator|&
name|channels
index|[
name|i
index|]
decl_stmt|;
switch|switch
condition|(
name|c
operator|->
name|type
condition|)
block|{
case|case
name|SSH_CHANNEL_FREE
case|:
case|case
name|SSH_CHANNEL_X11_LISTENER
case|:
case|case
name|SSH_CHANNEL_PORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_CLOSED
case|:
case|case
name|SSH_CHANNEL_AUTH_SOCKET
case|:
continue|continue;
case|case
name|SSH_CHANNEL_LARVAL
case|:
case|case
name|SSH_CHANNEL_OPENING
case|:
case|case
name|SSH_CHANNEL_OPEN
case|:
case|case
name|SSH_CHANNEL_X11_OPEN
case|:
case|case
name|SSH_CHANNEL_INPUT_DRAINING
case|:
case|case
name|SSH_CHANNEL_OUTPUT_DRAINING
case|:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|remote_name
argument_list|,
name|c
operator|->
name|type
argument_list|,
name|c
operator|->
name|remote_id
argument_list|,
name|c
operator|->
name|istate
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
argument_list|,
name|c
operator|->
name|ostate
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|,
name|c
operator|->
name|rfd
argument_list|,
name|c
operator|->
name|wfd
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|fatal
argument_list|(
literal|"channel_open_message: bad channel type %d"
argument_list|,
name|c
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|buffer_append
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"\0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|xstrdup
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/*  * Initiate forwarding of connections to local port "port" through the secure  * channel to host:port from remote side.  */
end_comment

begin_function
name|void
name|channel_request_local_forwarding
parameter_list|(
name|u_short
name|port
parameter_list|,
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|u_short
name|host_port
parameter_list|,
name|int
name|gateway_ports
parameter_list|)
block|{
name|int
name|success
decl_stmt|,
name|ch
decl_stmt|,
name|sock
decl_stmt|,
name|on
init|=
literal|1
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
decl_stmt|,
modifier|*
name|aitop
decl_stmt|;
name|char
name|ntop
index|[
name|NI_MAXHOST
index|]
decl_stmt|,
name|strport
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|struct
name|linger
name|linger
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|host
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|channels
index|[
literal|0
index|]
operator|.
name|path
argument_list|)
operator|-
literal|1
condition|)
name|packet_disconnect
argument_list|(
literal|"Forward host name too long."
argument_list|)
expr_stmt|;
comment|/* 	 * getaddrinfo returns a loopback address if the hostname is 	 * set to NULL and hints.ai_flags is not AI_PASSIVE 	 */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|IPv4or6
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|gateway_ports
condition|?
name|AI_PASSIVE
else|:
literal|0
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|snprintf
argument_list|(
name|strport
argument_list|,
sizeof|sizeof
name|strport
argument_list|,
literal|"%d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|getaddrinfo
argument_list|(
name|NULL
argument_list|,
name|strport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|aitop
argument_list|)
operator|!=
literal|0
condition|)
name|packet_disconnect
argument_list|(
literal|"getaddrinfo: fatal error"
argument_list|)
expr_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ai
operator|=
name|aitop
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET
operator|&&
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
if|if
condition|(
name|getnameinfo
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|,
name|ntop
argument_list|,
sizeof|sizeof
argument_list|(
name|ntop
argument_list|)
argument_list|,
name|strport
argument_list|,
sizeof|sizeof
argument_list|(
name|strport
argument_list|)
argument_list|,
name|NI_NUMERICHOST
operator||
name|NI_NUMERICSERV
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"channel_request_local_forwarding: getnameinfo failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Create a port to listen for the host. */
name|sock
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
comment|/* this is no error since kernel may not support ipv6 */
name|verbose
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Set socket options.  We would like the socket to disappear 		 * as soon as it has been closed for whatever reason. 		 */
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
name|linger
operator|.
name|l_onoff
operator|=
literal|1
expr_stmt|;
name|linger
operator|.
name|l_linger
operator|=
literal|5
expr_stmt|;
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_LINGER
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|linger
argument_list|,
sizeof|sizeof
argument_list|(
name|linger
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Local forwarding listening on %s port %s."
argument_list|,
name|ntop
argument_list|,
name|strport
argument_list|)
expr_stmt|;
comment|/* Bind the socket to the address. */
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* address can be in use ipv6 address is already bound */
name|verbose
argument_list|(
literal|"bind: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Start listening for connections on the socket. */
if|if
condition|(
name|listen
argument_list|(
name|sock
argument_list|,
literal|5
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"listen: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate a channel number for the socket. */
name|ch
operator|=
name|channel_new
argument_list|(
literal|"port listener"
argument_list|,
name|SSH_CHANNEL_PORT_LISTENER
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_TCP_WINDOW_DEFAULT
argument_list|,
name|CHAN_TCP_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
name|xstrdup
argument_list|(
literal|"port listener"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|channels
index|[
name|ch
index|]
operator|.
name|path
argument_list|,
name|host
argument_list|,
sizeof|sizeof
argument_list|(
name|channels
index|[
name|ch
index|]
operator|.
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|channels
index|[
name|ch
index|]
operator|.
name|host_port
operator|=
name|host_port
expr_stmt|;
name|channels
index|[
name|ch
index|]
operator|.
name|listening_port
operator|=
name|port
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|success
operator|==
literal|0
condition|)
name|packet_disconnect
argument_list|(
literal|"cannot listen port: %d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|aitop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initiate forwarding of connections to port "port" on remote host through  * the secure channel to host:port from local side.  */
end_comment

begin_function
name|void
name|channel_request_remote_forwarding
parameter_list|(
name|u_short
name|listen_port
parameter_list|,
specifier|const
name|char
modifier|*
name|host_to_connect
parameter_list|,
name|u_short
name|port_to_connect
parameter_list|)
block|{
name|int
name|payload_len
decl_stmt|;
comment|/* Record locally that connection to this host/port is permitted. */
if|if
condition|(
name|num_permitted_opens
operator|>=
name|SSH_MAX_FORWARDS_PER_DIRECTION
condition|)
name|fatal
argument_list|(
literal|"channel_request_remote_forwarding: too many forwards"
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|num_permitted_opens
index|]
operator|.
name|host_to_connect
operator|=
name|xstrdup
argument_list|(
name|host_to_connect
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|num_permitted_opens
index|]
operator|.
name|port_to_connect
operator|=
name|port_to_connect
expr_stmt|;
name|permitted_opens
index|[
name|num_permitted_opens
index|]
operator|.
name|listen_port
operator|=
name|listen_port
expr_stmt|;
name|num_permitted_opens
operator|++
expr_stmt|;
comment|/* Send the forward request to the remote side. */
if|if
condition|(
name|compat20
condition|)
block|{
specifier|const
name|char
modifier|*
name|address_to_bind
init|=
literal|"0.0.0.0"
decl_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_GLOBAL_REQUEST
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"tcpip-forward"
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* boolean: want reply */
name|packet_put_cstring
argument_list|(
name|address_to_bind
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|listen_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_PORT_FORWARD_REQUEST
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|listen_port
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|host_to_connect
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|port_to_connect
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* 		 * Wait for response from the remote side.  It will send a disconnect 		 * message on failure, and we will never see it here. 		 */
name|packet_read_expect
argument_list|(
operator|&
name|payload_len
argument_list|,
name|SSH_SMSG_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called after receiving CHANNEL_FORWARDING_REQUEST.  This initates  * listening for the port, and sends back a success reply (or disconnect  * message if there was an error).  This never returns if there was an error.  */
end_comment

begin_function
name|void
name|channel_input_port_forward_request
parameter_list|(
name|int
name|is_root
parameter_list|,
name|int
name|gateway_ports
parameter_list|)
block|{
name|u_short
name|port
decl_stmt|,
name|host_port
decl_stmt|;
name|char
modifier|*
name|hostname
decl_stmt|;
comment|/* Get arguments from the packet. */
name|port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|hostname
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|host_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
comment|/* 	 * Check that an unprivileged user is not trying to forward a 	 * privileged port. 	 */
if|if
condition|(
name|port
operator|<
name|IPPORT_RESERVED
operator|&&
operator|!
name|is_root
condition|)
name|packet_disconnect
argument_list|(
literal|"Requested forwarding of port %d but user is not root."
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* 	 * Initiate forwarding, 	 */
name|channel_request_local_forwarding
argument_list|(
name|port
argument_list|,
name|hostname
argument_list|,
name|host_port
argument_list|,
name|gateway_ports
argument_list|)
expr_stmt|;
comment|/* Free the argument string. */
name|xfree
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX move to aux.c */
end_comment

begin_function
name|int
name|channel_connect_to
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|u_short
name|host_port
parameter_list|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
decl_stmt|,
modifier|*
name|aitop
decl_stmt|;
name|char
name|ntop
index|[
name|NI_MAXHOST
index|]
decl_stmt|,
name|strport
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|int
name|gaierr
decl_stmt|;
name|int
name|sock
init|=
operator|-
literal|1
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|IPv4or6
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|snprintf
argument_list|(
name|strport
argument_list|,
sizeof|sizeof
name|strport
argument_list|,
literal|"%d"
argument_list|,
name|host_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gaierr
operator|=
name|getaddrinfo
argument_list|(
name|host
argument_list|,
name|strport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|aitop
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%.100s: unknown host (%s)"
argument_list|,
name|host
argument_list|,
name|gai_strerror
argument_list|(
name|gaierr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|ai
operator|=
name|aitop
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET
operator|&&
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
if|if
condition|(
name|getnameinfo
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|,
name|ntop
argument_list|,
sizeof|sizeof
argument_list|(
name|ntop
argument_list|)
argument_list|,
name|strport
argument_list|,
sizeof|sizeof
argument_list|(
name|strport
argument_list|)
argument_list|,
name|NI_NUMERICHOST
operator||
name|NI_NUMERICSERV
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"channel_connect_to: getnameinfo failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Create the socket. */
name|sock
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Connect to the host/port. */
if|if
condition|(
name|connect
argument_list|(
name|sock
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"connect %.100s port %s: %.100s"
argument_list|,
name|ntop
argument_list|,
name|strport
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
continue|continue;
comment|/* fail -- try next */
block|}
break|break;
comment|/* success */
block|}
name|freeaddrinfo
argument_list|(
name|aitop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ai
condition|)
block|{
name|error
argument_list|(
literal|"connect %.100s port %d: failed."
argument_list|,
name|host
argument_list|,
name|host_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* success */
return|return
name|sock
return|;
block|}
end_function

begin_comment
comment|/*  * This is called after receiving PORT_OPEN message.  This attempts to  * connect to the given host:port, and sends back CHANNEL_OPEN_CONFIRMATION  * or CHANNEL_OPEN_FAILURE.  */
end_comment

begin_function
name|void
name|channel_input_port_open
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|u_short
name|host_port
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|,
modifier|*
name|originator_string
decl_stmt|;
name|int
name|remote_channel
decl_stmt|,
name|sock
init|=
operator|-
literal|1
decl_stmt|,
name|newch
decl_stmt|,
name|i
decl_stmt|,
name|denied
decl_stmt|;
name|unsigned
name|int
name|host_len
decl_stmt|,
name|originator_len
decl_stmt|;
comment|/* Get remote channel number. */
name|remote_channel
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
comment|/* Get host name to connect to. */
name|host
operator|=
name|packet_get_string
argument_list|(
operator|&
name|host_len
argument_list|)
expr_stmt|;
comment|/* Get port to connect to. */
name|host_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
comment|/* Get remote originator name. */
if|if
condition|(
name|have_hostname_in_open
condition|)
block|{
name|originator_string
operator|=
name|packet_get_string
argument_list|(
operator|&
name|originator_len
argument_list|)
expr_stmt|;
name|originator_len
operator|+=
literal|4
expr_stmt|;
comment|/* size of packet_int */
block|}
else|else
block|{
name|originator_string
operator|=
name|xstrdup
argument_list|(
literal|"unknown (remote did not supply name)"
argument_list|)
expr_stmt|;
name|originator_len
operator|=
literal|0
expr_stmt|;
comment|/* no originator supplied */
block|}
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
literal|4
operator|+
literal|4
operator|+
name|host_len
operator|+
literal|4
operator|+
name|originator_len
argument_list|,
name|SSH_MSG_PORT_OPEN
argument_list|)
expr_stmt|;
comment|/* Check if opening that port is permitted. */
name|denied
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|all_opens_permitted
condition|)
block|{
comment|/* Go trough all permitted ports. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_permitted_opens
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|port_to_connect
operator|==
name|host_port
operator|&&
name|strcmp
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
argument_list|,
name|host
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Check if we found the requested port among those permitted. */
if|if
condition|(
name|i
operator|>=
name|num_permitted_opens
condition|)
block|{
comment|/* The port is not permitted. */
name|log
argument_list|(
literal|"Received request to connect to %.100s:%d, but the request was denied."
argument_list|,
name|host
argument_list|,
name|host_port
argument_list|)
expr_stmt|;
name|denied
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|sock
operator|=
name|denied
condition|?
operator|-
literal|1
else|:
name|channel_connect_to
argument_list|(
name|host
argument_list|,
name|host_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|>
literal|0
condition|)
block|{
comment|/* Allocate a channel for this connection. */
name|newch
operator|=
name|channel_allocate
argument_list|(
name|SSH_CHANNEL_OPEN
argument_list|,
name|sock
argument_list|,
name|originator_string
argument_list|)
expr_stmt|;
name|channels
index|[
name|newch
index|]
operator|.
name|remote_id
operator|=
name|remote_channel
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_channel
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|newch
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_channel
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|xfree
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Creates an internet domain socket for listening for X11 connections.  * Returns a suitable value for the DISPLAY variable, or NULL if an error  * occurs.  */
end_comment

begin_define
define|#
directive|define
name|NUM_SOCKS
value|10
end_define

begin_function
name|char
modifier|*
name|x11_create_display_inet
parameter_list|(
name|int
name|screen_number
parameter_list|,
name|int
name|x11_display_offset
parameter_list|)
block|{
name|int
name|display_number
decl_stmt|,
name|sock
decl_stmt|;
name|u_short
name|port
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
decl_stmt|,
modifier|*
name|aitop
decl_stmt|;
name|char
name|strport
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|int
name|gaierr
decl_stmt|,
name|n
decl_stmt|,
name|num_socks
init|=
literal|0
decl_stmt|,
name|socks
index|[
name|NUM_SOCKS
index|]
decl_stmt|;
name|char
name|display
index|[
literal|512
index|]
decl_stmt|;
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
for|for
control|(
name|display_number
operator|=
name|x11_display_offset
init|;
name|display_number
operator|<
name|MAX_DISPLAYS
condition|;
name|display_number
operator|++
control|)
block|{
name|port
operator|=
literal|6000
operator|+
name|display_number
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|IPv4or6
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_PASSIVE
expr_stmt|;
comment|/* XXX loopback only ? */
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|snprintf
argument_list|(
name|strport
argument_list|,
sizeof|sizeof
name|strport
argument_list|,
literal|"%d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gaierr
operator|=
name|getaddrinfo
argument_list|(
name|NULL
argument_list|,
name|strport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|aitop
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"getaddrinfo: %.100s"
argument_list|,
name|gai_strerror
argument_list|(
name|gaierr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|ai
operator|=
name|aitop
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET
operator|&&
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|sock
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"bind port %d: %.100s"
argument_list|,
name|port
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|shutdown
argument_list|(
name|sock
argument_list|,
name|SHUT_RDWR
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_socks
condition|;
name|n
operator|++
control|)
block|{
name|shutdown
argument_list|(
name|socks
index|[
name|n
index|]
argument_list|,
name|SHUT_RDWR
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|socks
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
name|num_socks
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|socks
index|[
name|num_socks
operator|++
index|]
operator|=
name|sock
expr_stmt|;
if|if
condition|(
name|num_socks
operator|==
name|NUM_SOCKS
condition|)
break|break;
block|}
if|if
condition|(
name|num_socks
operator|>
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|display_number
operator|>=
name|MAX_DISPLAYS
condition|)
block|{
name|error
argument_list|(
literal|"Failed to allocate internet-domain X11 display socket."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Start listening for connections on the socket. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_socks
condition|;
name|n
operator|++
control|)
block|{
name|sock
operator|=
name|socks
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|listen
argument_list|(
name|sock
argument_list|,
literal|5
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"listen: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|shutdown
argument_list|(
name|sock
argument_list|,
name|SHUT_RDWR
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Set up a suitable value for the DISPLAY variable. */
if|if
condition|(
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"gethostname: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|display
argument_list|,
sizeof|sizeof
name|display
argument_list|,
literal|"%.400s:%d.%d"
argument_list|,
name|hostname
argument_list|,
name|display_number
argument_list|,
name|screen_number
argument_list|)
expr_stmt|;
comment|/* Allocate a channel for each socket. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_socks
condition|;
name|n
operator|++
control|)
block|{
name|sock
operator|=
name|socks
index|[
name|n
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|channel_new
argument_list|(
literal|"x11 listener"
argument_list|,
name|SSH_CHANNEL_X11_LISTENER
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_X11_WINDOW_DEFAULT
argument_list|,
name|CHAN_X11_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
name|xstrdup
argument_list|(
literal|"X11 inet listener"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Return a suitable value for the DISPLAY environment variable. */
return|return
name|xstrdup
argument_list|(
name|display
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|X_UNIX_PATH
end_ifndef

begin_define
define|#
directive|define
name|X_UNIX_PATH
value|"/tmp/.X11-unix/X"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|connect_local_xsocket
parameter_list|(
name|unsigned
name|int
name|dnr
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|x_sockets
index|[]
init|=
block|{
name|X_UNIX_PATH
literal|"%u"
block|,
literal|"/var/X/.X11-unix/X"
literal|"%u"
block|,
literal|"/usr/spool/sockets/X11/"
literal|"%u"
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|struct
name|sockaddr_un
name|addr
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|path
decl_stmt|;
for|for
control|(
name|path
operator|=
name|x_sockets
init|;
operator|*
name|path
condition|;
operator|++
name|path
control|)
block|{
name|sock
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|snprintf
argument_list|(
name|addr
operator|.
name|sun_path
argument_list|,
sizeof|sizeof
name|addr
operator|.
name|sun_path
argument_list|,
operator|*
name|path
argument_list|,
name|dnr
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sock
return|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|"connect %.100s: %.100s"
argument_list|,
name|addr
operator|.
name|sun_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|x11_connect_display
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|display_number
decl_stmt|,
name|sock
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|display
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
decl_stmt|,
modifier|*
name|aitop
decl_stmt|;
name|char
name|strport
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|int
name|gaierr
decl_stmt|;
comment|/* Try to open a socket for the local X server. */
name|display
operator|=
name|getenv
argument_list|(
literal|"DISPLAY"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|display
condition|)
block|{
name|error
argument_list|(
literal|"DISPLAY not set."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Now we decode the value of the DISPLAY variable and make a 	 * connection to the real X server. 	 */
comment|/* 	 * Check if it is a unix domain socket.  Unix domain displays are in 	 * one of the following formats: unix:d[.s], :d[.s], ::d[.s] 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|display
argument_list|,
literal|"unix:"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|display
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* Connect to the unix domain socket. */
if|if
condition|(
name|sscanf
argument_list|(
name|strrchr
argument_list|(
name|display
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|display_number
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Could not parse display number from DISPLAY: %.100s"
argument_list|,
name|display
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Create a socket. */
name|sock
operator|=
name|connect_local_xsocket
argument_list|(
name|display_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* OK, we now have a connection to the display. */
return|return
name|sock
return|;
block|}
comment|/* 	 * Connect to an inet socket.  The DISPLAY value is supposedly 	 * hostname:d[.s], where hostname may also be numeric IP address. 	 */
name|strncpy
argument_list|(
name|buf
argument_list|,
name|display
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|error
argument_list|(
literal|"Could not find ':' in DISPLAY: %.100s"
argument_list|,
name|display
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
comment|/* buf now contains the host name.  But first we parse the display number. */
if|if
condition|(
name|sscanf
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|display_number
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Could not parse display number from DISPLAY: %.100s"
argument_list|,
name|display
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Look up the host address */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|IPv4or6
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|snprintf
argument_list|(
name|strport
argument_list|,
sizeof|sizeof
name|strport
argument_list|,
literal|"%d"
argument_list|,
literal|6000
operator|+
name|display_number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gaierr
operator|=
name|getaddrinfo
argument_list|(
name|buf
argument_list|,
name|strport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|aitop
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%.100s: unknown host. (%s)"
argument_list|,
name|buf
argument_list|,
name|gai_strerror
argument_list|(
name|gaierr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|ai
operator|=
name|aitop
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
comment|/* Create a socket. */
name|sock
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Connect it to the display. */
if|if
condition|(
name|connect
argument_list|(
name|sock
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"connect %.100s port %d: %.100s"
argument_list|,
name|buf
argument_list|,
literal|6000
operator|+
name|display_number
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Success */
break|break;
block|}
name|freeaddrinfo
argument_list|(
name|aitop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ai
condition|)
block|{
name|error
argument_list|(
literal|"connect %.100s port %d: %.100s"
argument_list|,
name|buf
argument_list|,
literal|6000
operator|+
name|display_number
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|sock
return|;
block|}
end_function

begin_comment
comment|/*  * This is called when SSH_SMSG_X11_OPEN is received.  The packet contains  * the remote channel number.  We should do whatever we want, and respond  * with either SSH_MSG_OPEN_CONFIRMATION or SSH_MSG_OPEN_FAILURE.  */
end_comment

begin_function
name|void
name|x11_input_open
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|remote_channel
decl_stmt|,
name|sock
init|=
literal|0
decl_stmt|,
name|newch
decl_stmt|;
name|char
modifier|*
name|remote_host
decl_stmt|;
name|unsigned
name|int
name|remote_len
decl_stmt|;
comment|/* Get remote channel number. */
name|remote_channel
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
comment|/* Get remote originator name. */
if|if
condition|(
name|have_hostname_in_open
condition|)
block|{
name|remote_host
operator|=
name|packet_get_string
argument_list|(
operator|&
name|remote_len
argument_list|)
expr_stmt|;
name|remote_len
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|remote_host
operator|=
name|xstrdup
argument_list|(
literal|"unknown (remote did not supply name)"
argument_list|)
expr_stmt|;
name|remote_len
operator|=
literal|0
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"Received X11 open request."
argument_list|)
expr_stmt|;
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
literal|4
operator|+
name|remote_len
argument_list|,
name|SSH_SMSG_X11_OPEN
argument_list|)
expr_stmt|;
comment|/* Obtain a connection to the real X display. */
name|sock
operator|=
name|x11_connect_display
argument_list|()
expr_stmt|;
if|if
condition|(
name|sock
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Send refusal to the remote host. */
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_channel
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Allocate a channel for this connection. */
name|newch
operator|=
name|channel_allocate
argument_list|(
operator|(
name|x11_saved_proto
operator|==
name|NULL
operator|)
condition|?
name|SSH_CHANNEL_OPEN
else|:
name|SSH_CHANNEL_X11_OPEN
argument_list|,
name|sock
argument_list|,
name|remote_host
argument_list|)
expr_stmt|;
name|channels
index|[
name|newch
index|]
operator|.
name|remote_id
operator|=
name|remote_channel
expr_stmt|;
comment|/* Send a confirmation to the remote host. */
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_channel
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|newch
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* dummy protocol handler that denies SSH-1 requests (agent/x11) */
end_comment

begin_function
name|void
name|deny_input_open
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|rchan
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SSH_SMSG_AGENT_OPEN
case|:
name|error
argument_list|(
literal|"Warning: ssh server tried agent forwarding."
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_SMSG_X11_OPEN
case|:
name|error
argument_list|(
literal|"Warning: ssh server tried X11 forwarding."
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"deny_input_open: type %d plen %d"
argument_list|,
name|type
argument_list|,
name|plen
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
argument_list|(
literal|"Warning: this is probably a break in attempt by a malicious server."
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|rchan
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Requests forwarding of X11 connections, generates fake authentication  * data, and enables authentication spoofing.  */
end_comment

begin_function
name|void
name|x11_request_forwarding_with_spoofing
parameter_list|(
name|int
name|client_session_id
parameter_list|,
specifier|const
name|char
modifier|*
name|proto
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|int
name|data_len
init|=
operator|(
name|unsigned
name|int
operator|)
name|strlen
argument_list|(
name|data
argument_list|)
operator|/
literal|2
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|value
decl_stmt|;
name|char
modifier|*
name|new_data
decl_stmt|;
name|int
name|screen_number
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|u_int32_t
name|rand
init|=
literal|0
decl_stmt|;
name|cp
operator|=
name|getenv
argument_list|(
literal|"DISPLAY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|screen_number
operator|=
name|atoi
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|screen_number
operator|=
literal|0
expr_stmt|;
comment|/* Save protocol name. */
name|x11_saved_proto
operator|=
name|xstrdup
argument_list|(
name|proto
argument_list|)
expr_stmt|;
comment|/* 	 * Extract real authentication data and generate fake data of the 	 * same length. 	 */
name|x11_saved_data
operator|=
name|xmalloc
argument_list|(
name|data_len
argument_list|)
expr_stmt|;
name|x11_fake_data
operator|=
name|xmalloc
argument_list|(
name|data_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|data
operator|+
literal|2
operator|*
name|i
argument_list|,
literal|"%2x"
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"x11_request_forwarding: bad authentication data: %.100s"
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|4
operator|==
literal|0
condition|)
name|rand
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|x11_saved_data
index|[
name|i
index|]
operator|=
name|value
expr_stmt|;
name|x11_fake_data
index|[
name|i
index|]
operator|=
name|rand
operator|&
literal|0xff
expr_stmt|;
name|rand
operator|>>=
literal|8
expr_stmt|;
block|}
name|x11_saved_data_len
operator|=
name|data_len
expr_stmt|;
name|x11_fake_data_len
operator|=
name|data_len
expr_stmt|;
comment|/* Convert the fake data into hex. */
name|new_data
operator|=
name|xmalloc
argument_list|(
literal|2
operator|*
name|data_len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data_len
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
name|new_data
operator|+
literal|2
operator|*
name|i
argument_list|,
literal|"%02x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|x11_fake_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Send the request packet. */
if|if
condition|(
name|compat20
condition|)
block|{
name|channel_request_start
argument_list|(
name|client_session_id
argument_list|,
literal|"x11-req"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX bool single connection */
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_X11_REQUEST_FORWARDING
argument_list|)
expr_stmt|;
block|}
name|packet_put_cstring
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|new_data
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|screen_number
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
name|xfree
argument_list|(
name|new_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sends a message to the server to request authentication fd forwarding. */
end_comment

begin_function
name|void
name|auth_request_forwarding
parameter_list|()
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_AGENT_REQUEST_FORWARDING
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns the name of the forwarded authentication socket.  Returns NULL if  * there is no forwarded authentication socket.  The returned value points to  * a static buffer.  */
end_comment

begin_function
name|char
modifier|*
name|auth_get_socket_name
parameter_list|()
block|{
return|return
name|channel_forwarded_auth_socket_name
return|;
block|}
end_function

begin_comment
comment|/* removes the agent forwarding socket */
end_comment

begin_function
name|void
name|cleanup_socket
parameter_list|(
name|void
parameter_list|)
block|{
name|remove
argument_list|(
name|channel_forwarded_auth_socket_name
argument_list|)
expr_stmt|;
name|rmdir
argument_list|(
name|channel_forwarded_auth_socket_dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called to process SSH_CMSG_AGENT_REQUEST_FORWARDING on the server.  * This starts forwarding authentication requests.  */
end_comment

begin_function
name|int
name|auth_input_request_forwarding
parameter_list|(
name|struct
name|passwd
modifier|*
name|pw
parameter_list|)
block|{
name|int
name|sock
decl_stmt|,
name|newch
decl_stmt|;
name|struct
name|sockaddr_un
name|sunaddr
decl_stmt|;
if|if
condition|(
name|auth_get_socket_name
argument_list|()
operator|!=
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Protocol error: authentication forwarding requested twice."
argument_list|)
expr_stmt|;
comment|/* Temporarily drop privileged uid for mkdir/bind. */
name|temporarily_use_uid
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
comment|/* Allocate a buffer for the socket name, and format the name. */
name|channel_forwarded_auth_socket_name
operator|=
name|xmalloc
argument_list|(
name|MAX_SOCKET_NAME
argument_list|)
expr_stmt|;
name|channel_forwarded_auth_socket_dir
operator|=
name|xmalloc
argument_list|(
name|MAX_SOCKET_NAME
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|channel_forwarded_auth_socket_dir
argument_list|,
literal|"/tmp/ssh-XXXXXXXX"
argument_list|,
name|MAX_SOCKET_NAME
argument_list|)
expr_stmt|;
comment|/* Create private directory for socket */
if|if
condition|(
name|mkdtemp
argument_list|(
name|channel_forwarded_auth_socket_dir
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|packet_send_debug
argument_list|(
literal|"Agent forwarding disabled: mkdtemp() failed: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|restore_uid
argument_list|()
expr_stmt|;
name|xfree
argument_list|(
name|channel_forwarded_auth_socket_name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|channel_forwarded_auth_socket_dir
argument_list|)
expr_stmt|;
name|channel_forwarded_auth_socket_name
operator|=
name|NULL
expr_stmt|;
name|channel_forwarded_auth_socket_dir
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|snprintf
argument_list|(
name|channel_forwarded_auth_socket_name
argument_list|,
name|MAX_SOCKET_NAME
argument_list|,
literal|"%s/agent.%d"
argument_list|,
name|channel_forwarded_auth_socket_dir
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|atexit
argument_list|(
name|cleanup_socket
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|saved
init|=
name|errno
decl_stmt|;
name|cleanup_socket
argument_list|()
expr_stmt|;
name|packet_disconnect
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|saved
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Create the socket. */
name|sock
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
name|packet_disconnect
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Bind it to the name. */
name|memset
argument_list|(
operator|&
name|sunaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sunaddr
argument_list|)
argument_list|)
expr_stmt|;
name|sunaddr
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|strncpy
argument_list|(
name|sunaddr
operator|.
name|sun_path
argument_list|,
name|channel_forwarded_auth_socket_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sunaddr
operator|.
name|sun_path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sunaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sunaddr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|packet_disconnect
argument_list|(
literal|"bind: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the privileged uid. */
name|restore_uid
argument_list|()
expr_stmt|;
comment|/* Start listening on the socket. */
if|if
condition|(
name|listen
argument_list|(
name|sock
argument_list|,
literal|5
argument_list|)
operator|<
literal|0
condition|)
name|packet_disconnect
argument_list|(
literal|"listen: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate a channel for the authentication agent socket. */
name|newch
operator|=
name|channel_allocate
argument_list|(
name|SSH_CHANNEL_AUTH_SOCKET
argument_list|,
name|sock
argument_list|,
name|xstrdup
argument_list|(
literal|"auth socket"
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|channels
index|[
name|newch
index|]
operator|.
name|path
argument_list|,
name|channel_forwarded_auth_socket_name
argument_list|,
sizeof|sizeof
argument_list|(
name|channels
index|[
name|newch
index|]
operator|.
name|path
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This is called to process an SSH_SMSG_AGENT_OPEN message. */
end_comment

begin_function
name|void
name|auth_input_open_request
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|remch
decl_stmt|,
name|sock
decl_stmt|,
name|newch
decl_stmt|;
name|char
modifier|*
name|dummyname
decl_stmt|;
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Read the remote channel number from the message. */
name|remch
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
comment|/* 	 * Get a connection to the local authentication agent (this may again 	 * get forwarded). 	 */
name|sock
operator|=
name|ssh_get_authentication_socket
argument_list|()
expr_stmt|;
comment|/* 	 * If we could not connect the agent, send an error message back to 	 * the server. This should never happen unless the agent dies, 	 * because authentication forwarding is only enabled if we have an 	 * agent. 	 */
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remch
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
return|return;
block|}
name|debug
argument_list|(
literal|"Forwarding authentication connection."
argument_list|)
expr_stmt|;
comment|/* 	 * Dummy host name.  This will be freed when the channel is freed; it 	 * will still be valid in the packet_put_string below since the 	 * channel cannot yet be freed at that point. 	 */
name|dummyname
operator|=
name|xstrdup
argument_list|(
literal|"authentication agent connection"
argument_list|)
expr_stmt|;
name|newch
operator|=
name|channel_allocate
argument_list|(
name|SSH_CHANNEL_OPEN
argument_list|,
name|sock
argument_list|,
name|dummyname
argument_list|)
expr_stmt|;
name|channels
index|[
name|newch
index|]
operator|.
name|remote_id
operator|=
name|remch
expr_stmt|;
comment|/* Send a confirmation to the remote host. */
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remch
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|newch
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_start_open
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
literal|"channel_open: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|debug
argument_list|(
literal|"send channel open %d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|c
operator|->
name|ctype
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_open
parameter_list|(
name|int
name|id
parameter_list|)
block|{
comment|/* XXX REMOVE ME */
name|channel_start_open
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_request
parameter_list|(
name|int
name|id
parameter_list|,
name|char
modifier|*
name|service
parameter_list|,
name|int
name|wantconfirm
parameter_list|)
block|{
name|channel_request_start
argument_list|(
name|id
argument_list|,
name|service
argument_list|,
name|wantconfirm
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"channel request %d: %s"
argument_list|,
name|id
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_request_start
parameter_list|(
name|int
name|id
parameter_list|,
name|char
modifier|*
name|service
parameter_list|,
name|int
name|wantconfirm
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
literal|"channel_request: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_REQUEST
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
name|wantconfirm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_register_callback
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|mtype
parameter_list|,
name|channel_callback_fn
modifier|*
name|fn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
literal|"channel_register_callback: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|cb_event
operator|=
name|mtype
expr_stmt|;
name|c
operator|->
name|cb_fn
operator|=
name|fn
expr_stmt|;
name|c
operator|->
name|cb_arg
operator|=
name|arg
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_register_cleanup
parameter_list|(
name|int
name|id
parameter_list|,
name|channel_callback_fn
modifier|*
name|fn
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
literal|"channel_register_cleanup: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|dettach_user
operator|=
name|fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_cancel_cleanup
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
literal|"channel_cancel_cleanup: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|dettach_user
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_register_filter
parameter_list|(
name|int
name|id
parameter_list|,
name|channel_filter_fn
modifier|*
name|fn
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
literal|"channel_register_filter: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|input_filter
operator|=
name|fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_set_fds
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|rfd
parameter_list|,
name|int
name|wfd
parameter_list|,
name|int
name|efd
parameter_list|,
name|int
name|extusage
parameter_list|,
name|int
name|nonblock
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_LARVAL
condition|)
name|fatal
argument_list|(
literal|"channel_activate for non-larval channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|channel_register_fds
argument_list|(
name|c
argument_list|,
name|rfd
argument_list|,
name|wfd
argument_list|,
name|efd
argument_list|,
name|extusage
argument_list|,
name|nonblock
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
comment|/* XXX window size? */
name|c
operator|->
name|local_window
operator|=
name|c
operator|->
name|local_window_max
operator|=
name|c
operator|->
name|local_maxpacket
operator|*
literal|2
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_WINDOW_ADJUST
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

