begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  * This file contains functions for generic socket connection forwarding.  * There is also code for initiating connection forwarding for X11 connections,  * arbitrary tcp/ip connections, and the authentication agent connection.  *  * As far as I am concerned, the code I have written for this software  * can be used freely for any purpose.  Any derived versions of this  * software must be clearly marked as such, and if the derived work is  * incompatible with the protocol description in the RFC file, it must be  * called by a name other than "ssh" or "Secure Shell".  *  * SSH2 support added by Markus Friedl.  * Copyright (c) 1999, 2000, 2001, 2002 Markus Friedl.  All rights reserved.  * Copyright (c) 1999 Dug Song.  All rights reserved.  * Copyright (c) 1999 Theo de Raadt.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$OpenBSD: channels.c,v 1.171 2002/03/04 19:37:58 markus Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"ssh1.h"
end_include

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"uidswap.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"channels.h"
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|"canohost.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"authfd.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_comment
comment|/* -- channel core */
end_comment

begin_comment
comment|/*  * Pointer to an array containing all allocated channels.  The array is  * dynamically extended as needed.  */
end_comment

begin_decl_stmt
specifier|static
name|Channel
modifier|*
modifier|*
name|channels
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Size of the channel array.  All slots of the array must always be  * initialized (at least the type field); unused slots set to NULL  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|channels_alloc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Maximum file descriptor value used in any of the channels.  This is  * updated in channel_new.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|channel_max_fd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -- tcp forwarding */
end_comment

begin_comment
comment|/*  * Data structure for storing which hosts are permitted for forward requests.  * The local sides of any remote forwards are stored in this array to prevent  * a corrupt remote server from accessing arbitrary TCP/IP ports on our local  * network (which might be behind a firewall).  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|host_to_connect
decl_stmt|;
comment|/* Connect to 'host'. */
name|u_short
name|port_to_connect
decl_stmt|;
comment|/* Connect to 'port'. */
name|u_short
name|listen_port
decl_stmt|;
comment|/* Remote side should listen port number. */
block|}
name|ForwardPermission
typedef|;
end_typedef

begin_comment
comment|/* List of all permitted host/port pairs to connect. */
end_comment

begin_decl_stmt
specifier|static
name|ForwardPermission
name|permitted_opens
index|[
name|SSH_MAX_FORWARDS_PER_DIRECTION
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of permitted host/port pairs in the array. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_permitted_opens
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If this is true, all opens are permitted.  This is the case on the server  * on which we have to trust the client anyway, and the user could do  * anything after logging in anyway.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|all_opens_permitted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -- X11 forwarding */
end_comment

begin_comment
comment|/* Maximum number of fake X11 displays to try. */
end_comment

begin_define
define|#
directive|define
name|MAX_DISPLAYS
value|1000
end_define

begin_comment
comment|/* Saved X11 authentication protocol name. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|x11_saved_proto
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Saved X11 authentication data.  This is the real data. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|x11_saved_data
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|x11_saved_data_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Fake X11 authentication data.  This is what the server will be sending us;  * we should replace any occurrences of this by the real data.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|x11_fake_data
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|x11_fake_data_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -- agent forwarding */
end_comment

begin_define
define|#
directive|define
name|NUM_SOCKS
value|10
end_define

begin_comment
comment|/* Name and directory of socket for authentication agent forwarding. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|auth_sock_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|auth_sock_dir
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AF_UNSPEC or AF_INET or AF_INET6 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|IPv4or6
init|=
name|AF_UNSPEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* helper */
end_comment

begin_function_decl
specifier|static
name|void
name|port_open_helper
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|rtype
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* -- channel core */
end_comment

begin_function
name|Channel
modifier|*
name|channel_lookup
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
operator|||
name|id
operator|>=
name|channels_alloc
condition|)
block|{
name|log
argument_list|(
literal|"channel_lookup: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|=
name|channels
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
literal|"channel_lookup: %d: bad id: channel free"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * Register filedescriptors for a channel, used when allocating a channel or  * when the channel consumer/producer is ready, e.g. shell exec'd  */
end_comment

begin_function
specifier|static
name|void
name|channel_register_fds
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|int
name|rfd
parameter_list|,
name|int
name|wfd
parameter_list|,
name|int
name|efd
parameter_list|,
name|int
name|extusage
parameter_list|,
name|int
name|nonblock
parameter_list|)
block|{
comment|/* Update the maximum file descriptor value. */
name|channel_max_fd
operator|=
name|MAX
argument_list|(
name|channel_max_fd
argument_list|,
name|rfd
argument_list|)
expr_stmt|;
name|channel_max_fd
operator|=
name|MAX
argument_list|(
name|channel_max_fd
argument_list|,
name|wfd
argument_list|)
expr_stmt|;
name|channel_max_fd
operator|=
name|MAX
argument_list|(
name|channel_max_fd
argument_list|,
name|efd
argument_list|)
expr_stmt|;
comment|/* XXX set close-on-exec -markus */
name|c
operator|->
name|rfd
operator|=
name|rfd
expr_stmt|;
name|c
operator|->
name|wfd
operator|=
name|wfd
expr_stmt|;
name|c
operator|->
name|sock
operator|=
operator|(
name|rfd
operator|==
name|wfd
operator|)
condition|?
name|rfd
else|:
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|efd
operator|=
name|efd
expr_stmt|;
name|c
operator|->
name|extended_usage
operator|=
name|extusage
expr_stmt|;
comment|/* XXX ugly hack: nonblock is only set by the server */
if|if
condition|(
name|nonblock
operator|&&
name|isatty
argument_list|(
name|c
operator|->
name|rfd
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: rfd %d isatty"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|rfd
argument_list|)
expr_stmt|;
name|c
operator|->
name|isatty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|c
operator|->
name|wfd
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"channel %d: wfd %d is not a tty?"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|wfd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|c
operator|->
name|isatty
operator|=
literal|0
expr_stmt|;
block|}
comment|/* enable nonblocking mode */
if|if
condition|(
name|nonblock
condition|)
block|{
if|if
condition|(
name|rfd
operator|!=
operator|-
literal|1
condition|)
name|set_nonblock
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|wfd
operator|!=
operator|-
literal|1
condition|)
name|set_nonblock
argument_list|(
name|wfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|efd
operator|!=
operator|-
literal|1
condition|)
name|set_nonblock
argument_list|(
name|efd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a new channel object and set its type and socket. This will cause  * remote_name to be freed.  */
end_comment

begin_function
name|Channel
modifier|*
name|channel_new
parameter_list|(
name|char
modifier|*
name|ctype
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rfd
parameter_list|,
name|int
name|wfd
parameter_list|,
name|int
name|efd
parameter_list|,
name|int
name|window
parameter_list|,
name|int
name|maxpack
parameter_list|,
name|int
name|extusage
parameter_list|,
name|char
modifier|*
name|remote_name
parameter_list|,
name|int
name|nonblock
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|found
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
comment|/* Do initial allocation if this is the first call. */
if|if
condition|(
name|channels_alloc
operator|==
literal|0
condition|)
block|{
name|channels_alloc
operator|=
literal|10
expr_stmt|;
name|channels
operator|=
name|xmalloc
argument_list|(
name|channels_alloc
operator|*
sizeof|sizeof
argument_list|(
name|Channel
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
name|channels
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|fatal_add_cleanup
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|channel_free_all
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Try to find a free slot where to put the new channel. */
for|for
control|(
name|found
operator|=
operator|-
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* Found a free slot. */
name|found
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* There are no free slots.  Take last+1 slot and expand the array.  */
name|found
operator|=
name|channels_alloc
expr_stmt|;
name|channels_alloc
operator|+=
literal|10
expr_stmt|;
name|debug2
argument_list|(
literal|"channel: expanding %d"
argument_list|,
name|channels_alloc
argument_list|)
expr_stmt|;
name|channels
operator|=
name|xrealloc
argument_list|(
name|channels
argument_list|,
name|channels_alloc
operator|*
sizeof|sizeof
argument_list|(
name|Channel
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|found
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
name|channels
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Initialize and return new channel. */
name|c
operator|=
name|channels
index|[
name|found
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Channel
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Channel
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
expr_stmt|;
name|c
operator|->
name|ostate
operator|=
name|CHAN_OUTPUT_OPEN
expr_stmt|;
name|c
operator|->
name|istate
operator|=
name|CHAN_INPUT_OPEN
expr_stmt|;
name|c
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|channel_register_fds
argument_list|(
name|c
argument_list|,
name|rfd
argument_list|,
name|wfd
argument_list|,
name|efd
argument_list|,
name|extusage
argument_list|,
name|nonblock
argument_list|)
expr_stmt|;
name|c
operator|->
name|self
operator|=
name|found
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|c
operator|->
name|ctype
operator|=
name|ctype
expr_stmt|;
name|c
operator|->
name|local_window
operator|=
name|window
expr_stmt|;
name|c
operator|->
name|local_window_max
operator|=
name|window
expr_stmt|;
name|c
operator|->
name|local_consumed
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|local_maxpacket
operator|=
name|maxpack
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|remote_name
operator|=
name|remote_name
expr_stmt|;
name|c
operator|->
name|remote_window
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|remote_maxpacket
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|force_drain
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|single_connection
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|detach_user
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|confirm
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|input_filter
operator|=
name|NULL
expr_stmt|;
name|debug
argument_list|(
literal|"channel %d: new [%s]"
argument_list|,
name|found
argument_list|,
name|remote_name
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|channel_find_maxfd
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|max
init|=
literal|0
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
name|max
operator|=
name|MAX
argument_list|(
name|max
argument_list|,
name|c
operator|->
name|rfd
argument_list|)
expr_stmt|;
name|max
operator|=
name|MAX
argument_list|(
name|max
argument_list|,
name|c
operator|->
name|wfd
argument_list|)
expr_stmt|;
name|max
operator|=
name|MAX
argument_list|(
name|max
argument_list|,
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|max
return|;
block|}
end_function

begin_function
name|int
name|channel_close_fd
parameter_list|(
name|int
modifier|*
name|fdp
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|fd
init|=
operator|*
name|fdp
decl_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|*
name|fdp
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|channel_max_fd
condition|)
name|channel_max_fd
operator|=
name|channel_find_maxfd
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Close all channel fd/socket. */
end_comment

begin_function
specifier|static
name|void
name|channel_close_fds
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|)
block|{
name|debug3
argument_list|(
literal|"channel_close_fds: channel %d: r %d w %d e %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|rfd
argument_list|,
name|c
operator|->
name|wfd
argument_list|,
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|sock
argument_list|)
expr_stmt|;
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|rfd
argument_list|)
expr_stmt|;
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|wfd
argument_list|)
expr_stmt|;
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the channel and close its fd/socket. */
end_comment

begin_function
name|void
name|channel_free
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|channels
index|[
name|i
index|]
condition|)
name|n
operator|++
expr_stmt|;
name|debug
argument_list|(
literal|"channel_free: channel %d: %s, nchannels %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|remote_name
condition|?
name|c
operator|->
name|remote_name
else|:
literal|"???"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|s
operator|=
name|channel_open_message
argument_list|()
expr_stmt|;
name|debug3
argument_list|(
literal|"channel_free: status: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|sock
operator|!=
operator|-
literal|1
condition|)
name|shutdown
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|SHUT_RDWR
argument_list|)
expr_stmt|;
name|channel_close_fds
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|remote_name
condition|)
block|{
name|xfree
argument_list|(
name|c
operator|->
name|remote_name
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_name
operator|=
name|NULL
expr_stmt|;
block|}
name|channels
index|[
name|c
operator|->
name|self
index|]
operator|=
name|NULL
expr_stmt|;
name|xfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_free_all
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|channel_free
argument_list|(
name|channels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Closes the sockets/fds of all channels.  This is used to close extra file  * descriptors after a fork.  */
end_comment

begin_function
name|void
name|channel_close_all
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|channel_close_fds
argument_list|(
name|channels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop listening to channels.  */
end_comment

begin_function
name|void
name|channel_stop_listening
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|c
operator|->
name|type
condition|)
block|{
case|case
name|SSH_CHANNEL_AUTH_SOCKET
case|:
case|case
name|SSH_CHANNEL_PORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_RPORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_X11_LISTENER
case|:
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|sock
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Returns true if no channel has too much buffered data, and false if one or  * more channel is overfull.  */
end_comment

begin_function
name|int
name|channel_not_very_much_buffered_data
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_OPEN
condition|)
block|{
if|#
directive|if
literal|0
block|if (!compat20&& 			    buffer_len(&c->input)> packet_get_maxsize()) { 				debug("channel %d: big input buffer %d", 				    c->self, buffer_len(&c->input)); 				return 0; 			}
endif|#
directive|endif
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
name|packet_get_maxsize
argument_list|()
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: big output buffer %d> %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|,
name|packet_get_maxsize
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns true if any channel is still open. */
end_comment

begin_function
name|int
name|channel_still_open
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
continue|continue;
switch|switch
condition|(
name|c
operator|->
name|type
condition|)
block|{
case|case
name|SSH_CHANNEL_X11_LISTENER
case|:
case|case
name|SSH_CHANNEL_PORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_RPORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_CLOSED
case|:
case|case
name|SSH_CHANNEL_AUTH_SOCKET
case|:
case|case
name|SSH_CHANNEL_DYNAMIC
case|:
case|case
name|SSH_CHANNEL_CONNECTING
case|:
case|case
name|SSH_CHANNEL_ZOMBIE
case|:
continue|continue;
case|case
name|SSH_CHANNEL_LARVAL
case|:
if|if
condition|(
operator|!
name|compat20
condition|)
name|fatal
argument_list|(
literal|"cannot happen: SSH_CHANNEL_LARVAL"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|SSH_CHANNEL_OPENING
case|:
case|case
name|SSH_CHANNEL_OPEN
case|:
case|case
name|SSH_CHANNEL_X11_OPEN
case|:
return|return
literal|1
return|;
case|case
name|SSH_CHANNEL_INPUT_DRAINING
case|:
case|case
name|SSH_CHANNEL_OUTPUT_DRAINING
case|:
if|if
condition|(
operator|!
name|compat13
condition|)
name|fatal
argument_list|(
literal|"cannot happen: OUT_DRAIN"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|fatal
argument_list|(
literal|"channel_still_open: bad channel type %d"
argument_list|,
name|c
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns the id of an open channel suitable for keepaliving */
end_comment

begin_function
name|int
name|channel_find_open
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
continue|continue;
switch|switch
condition|(
name|c
operator|->
name|type
condition|)
block|{
case|case
name|SSH_CHANNEL_CLOSED
case|:
case|case
name|SSH_CHANNEL_DYNAMIC
case|:
case|case
name|SSH_CHANNEL_X11_LISTENER
case|:
case|case
name|SSH_CHANNEL_PORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_RPORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_OPENING
case|:
case|case
name|SSH_CHANNEL_CONNECTING
case|:
case|case
name|SSH_CHANNEL_ZOMBIE
case|:
continue|continue;
case|case
name|SSH_CHANNEL_LARVAL
case|:
case|case
name|SSH_CHANNEL_AUTH_SOCKET
case|:
case|case
name|SSH_CHANNEL_OPEN
case|:
case|case
name|SSH_CHANNEL_X11_OPEN
case|:
return|return
name|i
return|;
case|case
name|SSH_CHANNEL_INPUT_DRAINING
case|:
case|case
name|SSH_CHANNEL_OUTPUT_DRAINING
case|:
if|if
condition|(
operator|!
name|compat13
condition|)
name|fatal
argument_list|(
literal|"cannot happen: OUT_DRAIN"
argument_list|)
expr_stmt|;
return|return
name|i
return|;
default|default:
name|fatal
argument_list|(
literal|"channel_find_open: bad channel type %d"
argument_list|,
name|c
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a message describing the currently open forwarded connections,  * suitable for sending to the client.  The message contains crlf pairs for  * newlines.  */
end_comment

begin_function
name|char
modifier|*
name|channel_open_message
parameter_list|(
name|void
parameter_list|)
block|{
name|Buffer
name|buffer
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|buffer_init
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"The following connections are open:\r\n"
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
continue|continue;
switch|switch
condition|(
name|c
operator|->
name|type
condition|)
block|{
case|case
name|SSH_CHANNEL_X11_LISTENER
case|:
case|case
name|SSH_CHANNEL_PORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_RPORT_LISTENER
case|:
case|case
name|SSH_CHANNEL_CLOSED
case|:
case|case
name|SSH_CHANNEL_AUTH_SOCKET
case|:
case|case
name|SSH_CHANNEL_ZOMBIE
case|:
continue|continue;
case|case
name|SSH_CHANNEL_LARVAL
case|:
case|case
name|SSH_CHANNEL_OPENING
case|:
case|case
name|SSH_CHANNEL_CONNECTING
case|:
case|case
name|SSH_CHANNEL_DYNAMIC
case|:
case|case
name|SSH_CHANNEL_OPEN
case|:
case|case
name|SSH_CHANNEL_X11_OPEN
case|:
case|case
name|SSH_CHANNEL_INPUT_DRAINING
case|:
case|case
name|SSH_CHANNEL_OUTPUT_DRAINING
case|:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|remote_name
argument_list|,
name|c
operator|->
name|type
argument_list|,
name|c
operator|->
name|remote_id
argument_list|,
name|c
operator|->
name|istate
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
argument_list|,
name|c
operator|->
name|ostate
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|,
name|c
operator|->
name|rfd
argument_list|,
name|c
operator|->
name|wfd
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|fatal
argument_list|(
literal|"channel_open_message: bad channel type %d"
argument_list|,
name|c
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|buffer_append
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"\0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|xstrdup
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

begin_function
name|void
name|channel_send_open
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
literal|"channel_send_open: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|debug
argument_list|(
literal|"send channel open %d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|c
operator|->
name|ctype
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_request_start
parameter_list|(
name|int
name|local_id
parameter_list|,
name|char
modifier|*
name|service
parameter_list|,
name|int
name|wantconfirm
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|local_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
literal|"channel_request_start: %d: unknown channel id"
argument_list|,
name|local_id
argument_list|)
expr_stmt|;
return|return;
block|}
name|debug
argument_list|(
literal|"channel request %d: %s"
argument_list|,
name|local_id
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_REQUEST
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
name|wantconfirm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_register_confirm
parameter_list|(
name|int
name|id
parameter_list|,
name|channel_callback_fn
modifier|*
name|fn
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
literal|"channel_register_comfirm: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|confirm
operator|=
name|fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_register_cleanup
parameter_list|(
name|int
name|id
parameter_list|,
name|channel_callback_fn
modifier|*
name|fn
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
literal|"channel_register_cleanup: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|detach_user
operator|=
name|fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_cancel_cleanup
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
literal|"channel_cancel_cleanup: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|detach_user
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_register_filter
parameter_list|(
name|int
name|id
parameter_list|,
name|channel_filter_fn
modifier|*
name|fn
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
literal|"channel_register_filter: %d: bad id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|input_filter
operator|=
name|fn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_set_fds
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|rfd
parameter_list|,
name|int
name|wfd
parameter_list|,
name|int
name|efd
parameter_list|,
name|int
name|extusage
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|u_int
name|window_max
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_LARVAL
condition|)
name|fatal
argument_list|(
literal|"channel_activate for non-larval channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|channel_register_fds
argument_list|(
name|c
argument_list|,
name|rfd
argument_list|,
name|wfd
argument_list|,
name|efd
argument_list|,
name|extusage
argument_list|,
name|nonblock
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
name|c
operator|->
name|local_window
operator|=
name|c
operator|->
name|local_window_max
operator|=
name|window_max
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_WINDOW_ADJUST
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 'channel_pre*' are called just before select() to add any bits relevant to  * channels in the select bitmasks.  */
end_comment

begin_comment
comment|/*  * 'channel_post*': perform any appropriate operations for channels which  * have events pending.  */
end_comment

begin_typedef
typedef|typedef
name|void
name|chan_fn
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
name|chan_fn
modifier|*
name|channel_pre
index|[
name|SSH_CHANNEL_MAX_TYPE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|chan_fn
modifier|*
name|channel_post
index|[
name|SSH_CHANNEL_MAX_TYPE
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|channel_pre_listener
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|channel_pre_connecting
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|debug3
argument_list|(
literal|"channel %d: waiting for connection"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|channel_pre_open_13
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|<
name|packet_get_maxsize
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|channel_pre_open
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|u_int
name|limit
init|=
name|compat20
condition|?
name|c
operator|->
name|remote_window
else|:
name|packet_get_maxsize
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_OPEN
operator|&&
name|limit
operator|>
literal|0
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|<
name|limit
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|rfd
argument_list|,
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_OPEN
operator|||
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_WAIT_DRAIN
condition|)
block|{
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|ostate
operator|==
name|CHAN_OUTPUT_WAIT_DRAIN
condition|)
block|{
name|chan_obuf_empty
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** XXX check close conditions, too */
if|if
condition|(
name|compat20
operator|&&
name|c
operator|->
name|efd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_WRITE
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_READ
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
operator|<
name|c
operator|->
name|remote_window
condition|)
name|FD_SET
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|readset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|channel_pre_input_draining
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_CLOSED
expr_stmt|;
name|debug
argument_list|(
literal|"channel %d: closing after input drain."
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|channel_pre_output_draining
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|==
literal|0
condition|)
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is a special state for X11 authentication spoofing.  An opened X11  * connection (when authentication spoofing is being done) remains in this  * state until the first packet has been completely read.  The authentication  * data in that packet is then substituted by the real data if it matches the  * fake data, and the channel is put into normal mode.  * XXX All this happens at the client side.  * Returns: 0 = need more data, -1 = wrong cookie, 1 = ok  */
end_comment

begin_function
specifier|static
name|int
name|x11_open_helper
parameter_list|(
name|Buffer
modifier|*
name|b
parameter_list|)
block|{
name|u_char
modifier|*
name|ucp
decl_stmt|;
name|u_int
name|proto_len
decl_stmt|,
name|data_len
decl_stmt|;
comment|/* Check if the fixed size part of the packet is in buffer. */
if|if
condition|(
name|buffer_len
argument_list|(
name|b
argument_list|)
operator|<
literal|12
condition|)
return|return
literal|0
return|;
comment|/* Parse the lengths of variable-length fields. */
name|ucp
operator|=
name|buffer_ptr
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucp
index|[
literal|0
index|]
operator|==
literal|0x42
condition|)
block|{
comment|/* Byte order MSB first. */
name|proto_len
operator|=
literal|256
operator|*
name|ucp
index|[
literal|6
index|]
operator|+
name|ucp
index|[
literal|7
index|]
expr_stmt|;
name|data_len
operator|=
literal|256
operator|*
name|ucp
index|[
literal|8
index|]
operator|+
name|ucp
index|[
literal|9
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ucp
index|[
literal|0
index|]
operator|==
literal|0x6c
condition|)
block|{
comment|/* Byte order LSB first. */
name|proto_len
operator|=
name|ucp
index|[
literal|6
index|]
operator|+
literal|256
operator|*
name|ucp
index|[
literal|7
index|]
expr_stmt|;
name|data_len
operator|=
name|ucp
index|[
literal|8
index|]
operator|+
literal|256
operator|*
name|ucp
index|[
literal|9
index|]
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"Initial X11 packet contains bad byte order byte: 0x%x"
argument_list|,
name|ucp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check if the whole packet is in buffer. */
if|if
condition|(
name|buffer_len
argument_list|(
name|b
argument_list|)
operator|<
literal|12
operator|+
operator|(
operator|(
name|proto_len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
operator|+
operator|(
operator|(
name|data_len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Check if authentication protocol matches. */
if|if
condition|(
name|proto_len
operator|!=
name|strlen
argument_list|(
name|x11_saved_proto
argument_list|)
operator|||
name|memcmp
argument_list|(
name|ucp
operator|+
literal|12
argument_list|,
name|x11_saved_proto
argument_list|,
name|proto_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"X11 connection uses different authentication protocol."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check if authentication data matches our fake data. */
if|if
condition|(
name|data_len
operator|!=
name|x11_fake_data_len
operator|||
name|memcmp
argument_list|(
name|ucp
operator|+
literal|12
operator|+
operator|(
operator|(
name|proto_len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
argument_list|,
name|x11_fake_data
argument_list|,
name|x11_fake_data_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"X11 auth data does not match fake data."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check fake data length */
if|if
condition|(
name|x11_fake_data_len
operator|!=
name|x11_saved_data_len
condition|)
block|{
name|error
argument_list|(
literal|"X11 fake_data_len %d != saved_data_len %d"
argument_list|,
name|x11_fake_data_len
argument_list|,
name|x11_saved_data_len
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Received authentication protocol and data match 	 * our fake data. Substitute the fake data with real 	 * data. 	 */
name|memcpy
argument_list|(
name|ucp
operator|+
literal|12
operator|+
operator|(
operator|(
name|proto_len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
argument_list|,
name|x11_saved_data
argument_list|,
name|x11_saved_data_len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|channel_pre_x11_open_13
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|ret
init|=
name|x11_open_helper
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
comment|/* Start normal processing for the channel. */
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
name|channel_pre_open_13
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * We have received an X11 connection that has bad 		 * authentication information. 		 */
name|log
argument_list|(
literal|"X11 connection rejected because of wrong authentication."
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|sock
argument_list|)
expr_stmt|;
name|c
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_CLOSED
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|channel_pre_x11_open
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|ret
init|=
name|x11_open_helper
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
decl_stmt|;
comment|/* c->force_drain = 1; */
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
name|channel_pre_open
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|log
argument_list|(
literal|"X11 connection rejected because of wrong authentication."
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"X11 rejected %d i%d/o%d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|istate
argument_list|,
name|c
operator|->
name|ostate
argument_list|)
expr_stmt|;
name|chan_read_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|chan_ibuf_empty
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
comment|/* for proto v1, the peer will send an IEOF */
if|if
condition|(
name|compat20
condition|)
name|chan_write_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
name|debug
argument_list|(
literal|"X11 closed %d i%d/o%d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|istate
argument_list|,
name|c
operator|->
name|ostate
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* try to decode a socks4 header */
end_comment

begin_function
specifier|static
name|int
name|channel_decode_socks4
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|,
modifier|*
name|host
decl_stmt|;
name|int
name|len
decl_stmt|,
name|have
decl_stmt|,
name|i
decl_stmt|,
name|found
decl_stmt|;
name|char
name|username
index|[
literal|256
index|]
decl_stmt|;
struct|struct
block|{
name|u_int8_t
name|version
decl_stmt|;
name|u_int8_t
name|command
decl_stmt|;
name|u_int16_t
name|dest_port
decl_stmt|;
name|struct
name|in_addr
name|dest_addr
decl_stmt|;
block|}
name|s4_req
struct|,
name|s4_rsp
struct|;
name|debug2
argument_list|(
literal|"channel %d: decode socks4"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|have
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|s4_req
argument_list|)
expr_stmt|;
if|if
condition|(
name|have
operator|<
name|len
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
for|for
control|(
name|found
operator|=
literal|0
operator|,
name|i
operator|=
name|len
init|;
name|i
operator|<
name|have
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>
literal|1024
condition|)
block|{
comment|/* the peer is probably sending garbage */
name|debug
argument_list|(
literal|"channel %d: decode socks4: too long"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return
literal|0
return|;
name|buffer_get
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|s4_req
operator|.
name|version
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buffer_get
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|s4_req
operator|.
name|command
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buffer_get
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|s4_req
operator|.
name|dest_port
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buffer_get
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|s4_req
operator|.
name|dest_addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|have
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|p
operator|=
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: decode socks4: user %s/%d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|have
condition|)
name|fatal
argument_list|(
literal|"channel %d: decode socks4: len %d> have %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|len
argument_list|,
name|have
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|username
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|username
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* trailing '\0' */
name|host
operator|=
name|inet_ntoa
argument_list|(
name|s4_req
operator|.
name|dest_addr
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|c
operator|->
name|path
argument_list|,
name|host
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|host_port
operator|=
name|ntohs
argument_list|(
name|s4_req
operator|.
name|dest_port
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"channel %d: dynamic request: socks4 host %s port %u command %u"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|host
argument_list|,
name|c
operator|->
name|host_port
argument_list|,
name|s4_req
operator|.
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|s4_req
operator|.
name|command
operator|!=
literal|1
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: cannot handle: socks4 cn %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|s4_req
operator|.
name|command
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|s4_rsp
operator|.
name|version
operator|=
literal|0
expr_stmt|;
comment|/* vn: 0 for reply */
name|s4_rsp
operator|.
name|command
operator|=
literal|90
expr_stmt|;
comment|/* cd: req granted */
name|s4_rsp
operator|.
name|dest_port
operator|=
literal|0
expr_stmt|;
comment|/* ignored */
name|s4_rsp
operator|.
name|dest_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
comment|/* ignored */
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|s4_rsp
argument_list|,
sizeof|sizeof
argument_list|(
name|s4_rsp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* dynamic port forwarding */
end_comment

begin_function
specifier|static
name|void
name|channel_pre_dynamic
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|have
decl_stmt|,
name|ret
decl_stmt|;
name|have
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|c
operator|->
name|delayed
operator|=
literal|0
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: pre_dynamic: have %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|have
argument_list|)
expr_stmt|;
comment|/* buffer_dump(&c->input); */
comment|/* check if the fixed size part of the packet is in buffer. */
if|if
condition|(
name|have
operator|<
literal|4
condition|)
block|{
comment|/* need more */
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* try to guess the protocol */
name|p
operator|=
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0x04
case|:
name|ret
operator|=
name|channel_decode_socks4
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: pre_dynamic: need more"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
comment|/* need more */
name|FD_SET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* switch to the next state */
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPENING
expr_stmt|;
name|port_open_helper
argument_list|(
name|c
argument_list|,
literal|"direct-tcpip"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is our fake X11 server socket. */
end_comment

begin_function
specifier|static
name|void
name|channel_post_x11_listener
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|Channel
modifier|*
name|nc
decl_stmt|;
name|struct
name|sockaddr
name|addr
decl_stmt|;
name|int
name|newsock
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
name|char
name|buf
index|[
literal|16384
index|]
decl_stmt|,
modifier|*
name|remote_ipaddr
decl_stmt|;
name|int
name|remote_port
decl_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"X11 connection requested."
argument_list|)
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|newsock
operator|=
name|accept
argument_list|(
name|c
operator|->
name|sock
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|single_connection
condition|)
block|{
name|debug
argument_list|(
literal|"single_connection: closing X11 listener."
argument_list|)
expr_stmt|;
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|sock
argument_list|)
expr_stmt|;
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newsock
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"accept: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_nodelay
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
name|remote_ipaddr
operator|=
name|get_peer_ipaddr
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
name|remote_port
operator|=
name|get_peer_port
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"X11 connection from %.200s port %d"
argument_list|,
name|remote_ipaddr
argument_list|,
name|remote_port
argument_list|)
expr_stmt|;
name|nc
operator|=
name|channel_new
argument_list|(
literal|"accepted x11 socket"
argument_list|,
name|SSH_CHANNEL_OPENING
argument_list|,
name|newsock
argument_list|,
name|newsock
argument_list|,
operator|-
literal|1
argument_list|,
name|c
operator|->
name|local_window_max
argument_list|,
name|c
operator|->
name|local_maxpacket
argument_list|,
literal|0
argument_list|,
name|xstrdup
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"x11"
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|nc
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|nc
operator|->
name|local_window_max
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|nc
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
comment|/* originator ipaddr and port */
name|packet_put_cstring
argument_list|(
name|remote_ipaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|datafellows
operator|&
name|SSH_BUG_X11FWD
condition|)
block|{
name|debug
argument_list|(
literal|"ssh2 x11 bug compat mode"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|packet_put_int
argument_list|(
name|remote_port
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_SMSG_X11_OPEN
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|nc
operator|->
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_get_protocol_flags
argument_list|()
operator|&
name|SSH_PROTOFLAG_HOST_IN_FWD_OPEN
condition|)
name|packet_put_cstring
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|xfree
argument_list|(
name|remote_ipaddr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|port_open_helper
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|rtype
parameter_list|)
block|{
name|int
name|direct
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|remote_ipaddr
init|=
name|get_peer_ipaddr
argument_list|(
name|c
operator|->
name|sock
argument_list|)
decl_stmt|;
name|u_short
name|remote_port
init|=
name|get_peer_port
argument_list|(
name|c
operator|->
name|sock
argument_list|)
decl_stmt|;
name|direct
operator|=
operator|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"direct-tcpip"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%s: listening port %d for %.100s port %d, "
literal|"connect from %.200s port %d"
argument_list|,
name|rtype
argument_list|,
name|c
operator|->
name|listening_port
argument_list|,
name|c
operator|->
name|path
argument_list|,
name|c
operator|->
name|host_port
argument_list|,
name|remote_ipaddr
argument_list|,
name|remote_port
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|c
operator|->
name|remote_name
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_name
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window_max
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
if|if
condition|(
name|direct
condition|)
block|{
comment|/* target host, port */
name|packet_put_cstring
argument_list|(
name|c
operator|->
name|path
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|host_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* listen address, port */
name|packet_put_cstring
argument_list|(
name|c
operator|->
name|path
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|listening_port
argument_list|)
expr_stmt|;
block|}
comment|/* originator host and port */
name|packet_put_cstring
argument_list|(
name|remote_ipaddr
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_port
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_MSG_PORT_OPEN
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|c
operator|->
name|path
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|host_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_get_protocol_flags
argument_list|()
operator|&
name|SSH_PROTOFLAG_HOST_IN_FWD_OPEN
condition|)
name|packet_put_cstring
argument_list|(
name|c
operator|->
name|remote_name
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|xfree
argument_list|(
name|remote_ipaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This socket is listening for connections to a forwarded TCP/IP port.  */
end_comment

begin_function
specifier|static
name|void
name|channel_post_port_listener
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|Channel
modifier|*
name|nc
decl_stmt|;
name|struct
name|sockaddr
name|addr
decl_stmt|;
name|int
name|newsock
decl_stmt|,
name|nextstate
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
name|char
modifier|*
name|rtype
decl_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"Connection to port %d forwarding "
literal|"to %.100s port %d requested."
argument_list|,
name|c
operator|->
name|listening_port
argument_list|,
name|c
operator|->
name|path
argument_list|,
name|c
operator|->
name|host_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_RPORT_LISTENER
condition|)
block|{
name|nextstate
operator|=
name|SSH_CHANNEL_OPENING
expr_stmt|;
name|rtype
operator|=
literal|"forwarded-tcpip"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|host_port
operator|==
literal|0
condition|)
block|{
name|nextstate
operator|=
name|SSH_CHANNEL_DYNAMIC
expr_stmt|;
name|rtype
operator|=
literal|"dynamic-tcpip"
expr_stmt|;
block|}
else|else
block|{
name|nextstate
operator|=
name|SSH_CHANNEL_OPENING
expr_stmt|;
name|rtype
operator|=
literal|"direct-tcpip"
expr_stmt|;
block|}
block|}
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|newsock
operator|=
name|accept
argument_list|(
name|c
operator|->
name|sock
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsock
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"accept: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_nodelay
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
name|nc
operator|=
name|channel_new
argument_list|(
name|rtype
argument_list|,
name|nextstate
argument_list|,
name|newsock
argument_list|,
name|newsock
argument_list|,
operator|-
literal|1
argument_list|,
name|c
operator|->
name|local_window_max
argument_list|,
name|c
operator|->
name|local_maxpacket
argument_list|,
literal|0
argument_list|,
name|xstrdup
argument_list|(
name|rtype
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nc
operator|->
name|listening_port
operator|=
name|c
operator|->
name|listening_port
expr_stmt|;
name|nc
operator|->
name|host_port
operator|=
name|c
operator|->
name|host_port
expr_stmt|;
name|strlcpy
argument_list|(
name|nc
operator|->
name|path
argument_list|,
name|c
operator|->
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|nc
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextstate
operator|==
name|SSH_CHANNEL_DYNAMIC
condition|)
block|{
comment|/* 			 * do not call the channel_post handler until 			 * this flag has been reset by a pre-handler. 			 * otherwise the FD_ISSET calls might overflow 			 */
name|nc
operator|->
name|delayed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|port_open_helper
argument_list|(
name|nc
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * This is the authentication agent socket listening for connections from  * clients.  */
end_comment

begin_function
specifier|static
name|void
name|channel_post_auth_listener
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|Channel
modifier|*
name|nc
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|newsock
decl_stmt|;
name|struct
name|sockaddr
name|addr
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|newsock
operator|=
name|accept
argument_list|(
name|c
operator|->
name|sock
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsock
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"accept from auth socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|xstrdup
argument_list|(
literal|"accepted auth socket"
argument_list|)
expr_stmt|;
name|nc
operator|=
name|channel_new
argument_list|(
literal|"accepted auth socket"
argument_list|,
name|SSH_CHANNEL_OPENING
argument_list|,
name|newsock
argument_list|,
name|newsock
argument_list|,
operator|-
literal|1
argument_list|,
name|c
operator|->
name|local_window_max
argument_list|,
name|c
operator|->
name|local_maxpacket
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"auth-agent@openssh.com"
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|nc
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window_max
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_SMSG_AGENT_OPEN
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|nc
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|channel_post_connecting
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|socklen_t
name|sz
init|=
sizeof|sizeof
argument_list|(
name|err
argument_list|)
decl_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|writeset
argument_list|)
condition|)
block|{
if|if
condition|(
name|getsockopt
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|&
name|err
argument_list|,
operator|&
name|sz
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
literal|"getsockopt SO_ERROR failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: connected"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|debug
argument_list|(
literal|"channel %d: not connected: %s"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|SSH2_OPEN_CONNECT_FAILED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|datafellows
operator|&
name|SSH_BUG_OPENFAILURE
operator|)
condition|)
block|{
name|packet_put_cstring
argument_list|(
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
block|}
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|channel_handle_rfd
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|char
name|buf
index|[
literal|16
operator|*
literal|1024
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|rfd
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|c
operator|->
name|rfd
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|len
operator|=
name|read
argument_list|(
name|c
operator|->
name|rfd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: read<=0 rfd %d len %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|rfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: not open"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|compat13
condition|)
block|{
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_INPUT_DRAINING
expr_stmt|;
name|debug
argument_list|(
literal|"channel %d: input draining."
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan_read_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|c
operator|->
name|input_filter
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|input_filter
argument_list|(
name|c
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: filter stops"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|chan_read_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|channel_handle_wfd
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|struct
name|termios
name|tio
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
name|u_int
name|dlen
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Send buffered output data to the socket. */
if|if
condition|(
name|c
operator|->
name|wfd
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
name|writeset
argument_list|)
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|len
operator|=
name|write
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: not open"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|chan_mark_dead
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|compat13
condition|)
block|{
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"channel %d: input draining."
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_INPUT_DRAINING
expr_stmt|;
block|}
else|else
block|{
name|chan_write_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|compat20
operator|&&
name|c
operator|->
name|isatty
operator|&&
name|dlen
operator|>=
literal|1
operator|&&
name|data
index|[
literal|0
index|]
operator|!=
literal|'\r'
condition|)
block|{
if|if
condition|(
name|tcgetattr
argument_list|(
name|c
operator|->
name|wfd
argument_list|,
operator|&
name|tio
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|tio
operator|.
name|c_lflag
operator|&
name|ECHO
operator|)
operator|&&
operator|(
name|tio
operator|.
name|c_lflag
operator|&
name|ICANON
operator|)
condition|)
block|{
comment|/* 				 * Simulate echo to reduce the impact of 				 * traffic analysis. We need to match the 				 * size of a SSH2_MSG_CHANNEL_DATA message 				 * (4 byte channel id + data) 				 */
name|packet_send_ignore
argument_list|(
literal|4
operator|+
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
name|c
operator|->
name|local_consumed
operator|+=
name|len
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|channel_handle_efd
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|char
name|buf
index|[
literal|16
operator|*
literal|1024
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/** XXX handle drain efd, too */
if|if
condition|(
name|c
operator|->
name|efd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_WRITE
operator|&&
name|FD_ISSET
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|writeset
argument_list|)
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: written %d to efd %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|len
argument_list|,
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: closing write-efd %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|c
operator|->
name|local_consumed
operator|+=
name|len
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_READ
operator|&&
name|FD_ISSET
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|len
operator|=
name|read
argument_list|(
name|c
operator|->
name|efd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: read %d from efd %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|len
argument_list|,
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: closing read-efd %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
name|channel_close_fd
argument_list|(
operator|&
name|c
operator|->
name|efd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|channel_check_window
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_OPEN
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
operator|(
name|CHAN_CLOSE_SENT
operator||
name|CHAN_CLOSE_RCVD
operator|)
operator|)
operator|&&
name|c
operator|->
name|local_window
operator|<
name|c
operator|->
name|local_window_max
operator|/
literal|2
operator|&&
name|c
operator|->
name|local_consumed
operator|>
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_WINDOW_ADJUST
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_consumed
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: window %d sent adjust %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|local_window
argument_list|,
name|c
operator|->
name|local_consumed
argument_list|)
expr_stmt|;
name|c
operator|->
name|local_window
operator|+=
name|c
operator|->
name|local_consumed
expr_stmt|;
name|c
operator|->
name|local_consumed
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|channel_post_open
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|delayed
condition|)
return|return;
name|channel_handle_rfd
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
name|channel_handle_wfd
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compat20
condition|)
return|return;
name|channel_handle_efd
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
name|channel_check_window
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|channel_post_output_drain_13
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* Send buffered output data to the socket. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|writeset
argument_list|)
operator|&&
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|c
operator|->
name|sock
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|)
expr_stmt|;
else|else
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|channel_handler_init_20
parameter_list|(
name|void
parameter_list|)
block|{
name|channel_pre
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_pre_open
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_OPEN
index|]
operator|=
operator|&
name|channel_pre_x11_open
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_RPORT_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_CONNECTING
index|]
operator|=
operator|&
name|channel_pre_connecting
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_DYNAMIC
index|]
operator|=
operator|&
name|channel_pre_dynamic
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_post_open
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_post_port_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_RPORT_LISTENER
index|]
operator|=
operator|&
name|channel_post_port_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_post_x11_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_post_auth_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_CONNECTING
index|]
operator|=
operator|&
name|channel_post_connecting
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_DYNAMIC
index|]
operator|=
operator|&
name|channel_post_open
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|channel_handler_init_13
parameter_list|(
name|void
parameter_list|)
block|{
name|channel_pre
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_pre_open_13
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_OPEN
index|]
operator|=
operator|&
name|channel_pre_x11_open_13
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_INPUT_DRAINING
index|]
operator|=
operator|&
name|channel_pre_input_draining
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_OUTPUT_DRAINING
index|]
operator|=
operator|&
name|channel_pre_output_draining
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_CONNECTING
index|]
operator|=
operator|&
name|channel_pre_connecting
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_DYNAMIC
index|]
operator|=
operator|&
name|channel_pre_dynamic
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_post_open
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_post_x11_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_post_port_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_post_auth_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_OUTPUT_DRAINING
index|]
operator|=
operator|&
name|channel_post_output_drain_13
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_CONNECTING
index|]
operator|=
operator|&
name|channel_post_connecting
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_DYNAMIC
index|]
operator|=
operator|&
name|channel_post_open
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|channel_handler_init_15
parameter_list|(
name|void
parameter_list|)
block|{
name|channel_pre
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_pre_open
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_OPEN
index|]
operator|=
operator|&
name|channel_pre_x11_open
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_pre_listener
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_CONNECTING
index|]
operator|=
operator|&
name|channel_pre_connecting
expr_stmt|;
name|channel_pre
index|[
name|SSH_CHANNEL_DYNAMIC
index|]
operator|=
operator|&
name|channel_pre_dynamic
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_X11_LISTENER
index|]
operator|=
operator|&
name|channel_post_x11_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_PORT_LISTENER
index|]
operator|=
operator|&
name|channel_post_port_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_AUTH_SOCKET
index|]
operator|=
operator|&
name|channel_post_auth_listener
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_OPEN
index|]
operator|=
operator|&
name|channel_post_open
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_CONNECTING
index|]
operator|=
operator|&
name|channel_post_connecting
expr_stmt|;
name|channel_post
index|[
name|SSH_CHANNEL_DYNAMIC
index|]
operator|=
operator|&
name|channel_post_open
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|channel_handler_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SSH_CHANNEL_MAX_TYPE
condition|;
name|i
operator|++
control|)
block|{
name|channel_pre
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|channel_post
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|compat20
condition|)
name|channel_handler_init_20
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|compat13
condition|)
name|channel_handler_init_13
argument_list|()
expr_stmt|;
else|else
name|channel_handler_init_15
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* gc dead channels */
end_comment

begin_function
specifier|static
name|void
name|channel_garbage_collect
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|c
operator|->
name|detach_user
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|chan_is_dead
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|debug
argument_list|(
literal|"channel %d: gc: notify user"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|c
operator|->
name|detach_user
argument_list|(
name|c
operator|->
name|self
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* if we still have a callback */
if|if
condition|(
name|c
operator|->
name|detach_user
operator|!=
name|NULL
condition|)
return|return;
name|debug
argument_list|(
literal|"channel %d: gc: user detached"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|chan_is_dead
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|debug
argument_list|(
literal|"channel %d: garbage collecting"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|channel_handler
parameter_list|(
name|chan_fn
modifier|*
name|ftab
index|[]
parameter_list|,
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
specifier|static
name|int
name|did_init
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|did_init
condition|)
block|{
name|channel_handler_init
argument_list|()
expr_stmt|;
name|did_init
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ftab
index|[
name|c
operator|->
name|type
index|]
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ftab
index|[
name|c
operator|->
name|type
index|]
call|)
argument_list|(
name|c
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
name|channel_garbage_collect
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate/update select bitmasks and add any bits relevant to channels in  * select bitmasks.  */
end_comment

begin_function
name|void
name|channel_prepare_select
parameter_list|(
name|fd_set
modifier|*
modifier|*
name|readsetp
parameter_list|,
name|fd_set
modifier|*
modifier|*
name|writesetp
parameter_list|,
name|int
modifier|*
name|maxfdp
parameter_list|,
name|int
modifier|*
name|nallocp
parameter_list|,
name|int
name|rekeying
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|u_int
name|sz
decl_stmt|;
name|n
operator|=
name|MAX
argument_list|(
operator|*
name|maxfdp
argument_list|,
name|channel_max_fd
argument_list|)
expr_stmt|;
name|sz
operator|=
name|howmany
argument_list|(
name|n
operator|+
literal|1
argument_list|,
name|NFDBITS
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
expr_stmt|;
comment|/* perhaps check sz< nalloc/2 and shrink? */
if|if
condition|(
operator|*
name|readsetp
operator|==
name|NULL
operator|||
name|sz
operator|>
operator|*
name|nallocp
condition|)
block|{
operator|*
name|readsetp
operator|=
name|xrealloc
argument_list|(
operator|*
name|readsetp
argument_list|,
name|sz
argument_list|)
expr_stmt|;
operator|*
name|writesetp
operator|=
name|xrealloc
argument_list|(
operator|*
name|writesetp
argument_list|,
name|sz
argument_list|)
expr_stmt|;
operator|*
name|nallocp
operator|=
name|sz
expr_stmt|;
block|}
operator|*
name|maxfdp
operator|=
name|n
expr_stmt|;
name|memset
argument_list|(
operator|*
name|readsetp
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|writesetp
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rekeying
condition|)
name|channel_handler
argument_list|(
name|channel_pre
argument_list|,
operator|*
name|readsetp
argument_list|,
operator|*
name|writesetp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * After select, perform any appropriate operations for channels which have  * events pending.  */
end_comment

begin_function
name|void
name|channel_after_select
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|channel_handler
argument_list|(
name|channel_post
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If there is data to send to the connection, enqueue some of it now. */
end_comment

begin_function
name|void
name|channel_output_poll
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels_alloc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * We are only interested in channels that can have buffered 		 * incoming data. 		 */
if|if
condition|(
name|compat13
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
operator|&&
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_INPUT_DRAINING
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
condition|)
continue|continue;
block|}
if|if
condition|(
name|compat20
operator|&&
operator|(
name|c
operator|->
name|flags
operator|&
operator|(
name|CHAN_CLOSE_SENT
operator||
name|CHAN_CLOSE_RCVD
operator|)
operator|)
condition|)
block|{
comment|/* XXX is this true? */
name|debug3
argument_list|(
literal|"channel %d: will not send data after close"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the amount of buffered data for this channel. */
if|if
condition|(
operator|(
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_OPEN
operator|||
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_WAIT_DRAIN
operator|)
operator|&&
operator|(
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Send some data for the other side over the secure 			 * connection. 			 */
if|if
condition|(
name|compat20
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|c
operator|->
name|remote_window
condition|)
name|len
operator|=
name|c
operator|->
name|remote_window
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|c
operator|->
name|remote_maxpacket
condition|)
name|len
operator|=
name|c
operator|->
name|remote_maxpacket
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|packet_is_interactive
argument_list|()
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|1024
condition|)
name|len
operator|=
literal|512
expr_stmt|;
block|}
else|else
block|{
comment|/* Keep the packets at reasonable size. */
if|if
condition|(
name|len
operator|>
name|packet_get_maxsize
argument_list|()
operator|/
literal|2
condition|)
name|len
operator|=
name|packet_get_maxsize
argument_list|()
operator|/
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|compat20
condition|?
name|SSH2_MSG_CHANNEL_DATA
else|:
name|SSH_MSG_CHANNEL_DATA
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_window
operator|-=
name|len
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_WAIT_DRAIN
condition|)
block|{
if|if
condition|(
name|compat13
condition|)
name|fatal
argument_list|(
literal|"cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3"
argument_list|)
expr_stmt|;
comment|/* 			 * input-buffer is empty and read-socket shutdown: 			 * tell peer, that we will not send more data: send IEOF 			 */
name|chan_ibuf_empty
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Send extended data, i.e. stderr */
if|if
condition|(
name|compat20
operator|&&
name|c
operator|->
name|remote_window
operator|>
literal|0
operator|&&
operator|(
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_READ
condition|)
block|{
name|debug2
argument_list|(
literal|"channel %d: rwin %d elen %d euse %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|remote_window
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
argument_list|,
name|c
operator|->
name|extended_usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|c
operator|->
name|remote_window
condition|)
name|len
operator|=
name|c
operator|->
name|remote_window
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|c
operator|->
name|remote_maxpacket
condition|)
name|len
operator|=
name|c
operator|->
name|remote_maxpacket
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_EXTENDED_DATA
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|SSH2_EXTENDED_DATA_STDERR
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_window
operator|-=
name|len
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: sent ext data %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* -- protocol input */
end_comment

begin_function
name|void
name|channel_input_data
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|u_int
name|data_len
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
comment|/* Get the channel number and verify it. */
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received data for nonexistent channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* Ignore any data for non-open channels (might happen on close) */
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
operator|&&
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_X11_OPEN
condition|)
return|return;
comment|/* same for protocol 1.5 if output end is no longer open */
if|if
condition|(
operator|!
name|compat13
operator|&&
name|c
operator|->
name|ostate
operator|!=
name|CHAN_OUTPUT_OPEN
condition|)
return|return;
comment|/* Get the data. */
name|data
operator|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
if|if
condition|(
name|data_len
operator|>
name|c
operator|->
name|local_maxpacket
condition|)
block|{
name|log
argument_list|(
literal|"channel %d: rcvd big packet %d, maxpack %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|data_len
argument_list|,
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data_len
operator|>
name|c
operator|->
name|local_window
condition|)
block|{
name|log
argument_list|(
literal|"channel %d: rcvd too much data %d, win %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|data_len
argument_list|,
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|local_window
operator|-=
name|data_len
expr_stmt|;
block|}
name|packet_check_eom
argument_list|()
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_input_extended_data
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|int
name|tcode
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|u_int
name|data_len
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
comment|/* Get the channel number and verify it. */
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received extended_data for bad channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
condition|)
block|{
name|log
argument_list|(
literal|"channel %d: ext data for non open"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|tcode
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|efd
operator|==
operator|-
literal|1
operator|||
name|c
operator|->
name|extended_usage
operator|!=
name|CHAN_EXTENDED_WRITE
operator|||
name|tcode
operator|!=
name|SSH2_EXTENDED_DATA_STDERR
condition|)
block|{
name|log
argument_list|(
literal|"channel %d: bad ext data"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
return|return;
block|}
name|data
operator|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
if|if
condition|(
name|data_len
operator|>
name|c
operator|->
name|local_window
condition|)
block|{
name|log
argument_list|(
literal|"channel %d: rcvd too much extended_data %d, win %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|data_len
argument_list|,
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
name|debug2
argument_list|(
literal|"channel %d: rcvd ext data %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|c
operator|->
name|local_window
operator|-=
name|data_len
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_input_ieof
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received ieof for nonexistent channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|chan_rcvd_ieof
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* XXX force input close */
if|if
condition|(
name|c
operator|->
name|force_drain
operator|&&
name|c
operator|->
name|istate
operator|==
name|CHAN_INPUT_OPEN
condition|)
block|{
name|debug
argument_list|(
literal|"channel %d: FORCE input drain"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|c
operator|->
name|istate
operator|=
name|CHAN_INPUT_WAIT_DRAIN
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
operator|==
literal|0
condition|)
name|chan_ibuf_empty
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|channel_input_close
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received close for nonexistent channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* 	 * Send a confirmation that we have closed the channel and no more 	 * data is coming for it. 	 */
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* 	 * If the channel is in closed state, we have sent a close request, 	 * and the other side will eventually respond with a confirmation. 	 * Thus, we cannot free the channel here, because then there would be 	 * no-one to receive the confirmation.  The channel gets freed when 	 * the confirmation arrives. 	 */
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_CLOSED
condition|)
block|{
comment|/* 		 * Not a closed channel - mark it as draining, which will 		 * cause it to be freed later. 		 */
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OUTPUT_DRAINING
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* proto version 1.5 overloads CLOSE_CONFIRMATION with OCLOSE */
end_comment

begin_function
name|void
name|channel_input_oclose
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received oclose for nonexistent channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|chan_rcvd_oclose
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_input_close_confirmation
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
name|Channel
modifier|*
name|c
init|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"Received close confirmation for "
literal|"out-of-range channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_CLOSED
condition|)
name|packet_disconnect
argument_list|(
literal|"Received close confirmation for "
literal|"non-closed channel %d (type %d)."
argument_list|,
name|id
argument_list|,
name|c
operator|->
name|type
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_input_open_confirmation
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|,
name|remote_id
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPENING
condition|)
name|packet_disconnect
argument_list|(
literal|"Received open confirmation for "
literal|"non-opening channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|remote_id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
comment|/* Record the remote channel number and mark that the channel is now open. */
name|c
operator|->
name|remote_id
operator|=
name|remote_id
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_OPEN
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|c
operator|->
name|remote_window
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|->
name|remote_maxpacket
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|confirm
condition|)
block|{
name|debug2
argument_list|(
literal|"callback start"
argument_list|)
expr_stmt|;
name|c
operator|->
name|confirm
argument_list|(
name|c
operator|->
name|self
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"callback done"
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"channel %d: open confirm rwindow %d rmax %d"
argument_list|,
name|c
operator|->
name|self
argument_list|,
name|c
operator|->
name|remote_window
argument_list|,
name|c
operator|->
name|remote_maxpacket
argument_list|)
expr_stmt|;
block|}
name|packet_check_eom
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|reason2txt
parameter_list|(
name|int
name|reason
parameter_list|)
block|{
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED
case|:
return|return
literal|"administratively prohibited"
return|;
case|case
name|SSH2_OPEN_CONNECT_FAILED
case|:
return|return
literal|"connect failed"
return|;
case|case
name|SSH2_OPEN_UNKNOWN_CHANNEL_TYPE
case|:
return|return
literal|"unknown channel type"
return|;
case|case
name|SSH2_OPEN_RESOURCE_SHORTAGE
case|:
return|return
literal|"resource shortage"
return|;
block|}
return|return
literal|"unknown reason"
return|;
block|}
end_function

begin_function
name|void
name|channel_input_open_failure
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|,
name|reason
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|,
modifier|*
name|lang
init|=
name|NULL
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPENING
condition|)
name|packet_disconnect
argument_list|(
literal|"Received open failure for "
literal|"non-opening channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|reason
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|datafellows
operator|&
name|SSH_BUG_OPENFAILURE
operator|)
condition|)
block|{
name|msg
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|lang
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|log
argument_list|(
literal|"channel %d: open failed: %s%s%s"
argument_list|,
name|id
argument_list|,
name|reason2txt
argument_list|(
name|reason
argument_list|)
argument_list|,
name|msg
condition|?
literal|": "
else|:
literal|""
argument_list|,
name|msg
condition|?
name|msg
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lang
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|lang
argument_list|)
expr_stmt|;
block|}
name|packet_check_eom
argument_list|()
expr_stmt|;
comment|/* Free the channel.  This will also close the socket. */
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_input_window_adjust
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
name|int
name|id
decl_stmt|,
name|adjust
decl_stmt|;
if|if
condition|(
operator|!
name|compat20
condition|)
return|return;
comment|/* Get the channel number and verify it. */
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_OPEN
condition|)
block|{
name|log
argument_list|(
literal|"Received window adjust for "
literal|"non-open channel %d."
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
name|adjust
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|debug2
argument_list|(
literal|"channel %d: rcvd adjust %d"
argument_list|,
name|id
argument_list|,
name|adjust
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_window
operator|+=
name|adjust
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_input_port_open
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|u_short
name|host_port
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|,
modifier|*
name|originator_string
decl_stmt|;
name|int
name|remote_id
decl_stmt|,
name|sock
init|=
operator|-
literal|1
decl_stmt|;
name|remote_id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|host
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|host_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|packet_get_protocol_flags
argument_list|()
operator|&
name|SSH_PROTOFLAG_HOST_IN_FWD_OPEN
condition|)
block|{
name|originator_string
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|originator_string
operator|=
name|xstrdup
argument_list|(
literal|"unknown (remote did not supply name)"
argument_list|)
expr_stmt|;
block|}
name|packet_check_eom
argument_list|()
expr_stmt|;
name|sock
operator|=
name|channel_connect_to
argument_list|(
name|host
argument_list|,
name|host_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|channel_new
argument_list|(
literal|"connected socket"
argument_list|,
name|SSH_CHANNEL_CONNECTING
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|originator_string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
name|remote_id
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|xfree
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -- tcp forwarding */
end_comment

begin_function
name|void
name|channel_set_af
parameter_list|(
name|int
name|af
parameter_list|)
block|{
name|IPv4or6
operator|=
name|af
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|channel_setup_fwd_listener
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|listen_addr
parameter_list|,
name|u_short
name|listen_port
parameter_list|,
specifier|const
name|char
modifier|*
name|host_to_connect
parameter_list|,
name|u_short
name|port_to_connect
parameter_list|,
name|int
name|gateway_ports
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
name|int
name|success
decl_stmt|,
name|sock
decl_stmt|,
name|on
init|=
literal|1
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
decl_stmt|,
modifier|*
name|aitop
decl_stmt|;
specifier|const
name|char
modifier|*
name|host
decl_stmt|;
name|char
name|ntop
index|[
name|NI_MAXHOST
index|]
decl_stmt|,
name|strport
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|struct
name|linger
name|linger
decl_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
name|host
operator|=
operator|(
name|type
operator|==
name|SSH_CHANNEL_RPORT_LISTENER
operator|)
condition|?
name|listen_addr
else|:
name|host_to_connect
expr_stmt|;
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No forward host name."
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|host
argument_list|)
operator|>
name|SSH_CHANNEL_PATH_LEN
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Forward host name too long."
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
comment|/* 	 * getaddrinfo returns a loopback address if the hostname is 	 * set to NULL and hints.ai_flags is not AI_PASSIVE 	 */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|IPv4or6
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|gateway_ports
condition|?
name|AI_PASSIVE
else|:
literal|0
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|snprintf
argument_list|(
name|strport
argument_list|,
sizeof|sizeof
name|strport
argument_list|,
literal|"%d"
argument_list|,
name|listen_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|getaddrinfo
argument_list|(
name|NULL
argument_list|,
name|strport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|aitop
argument_list|)
operator|!=
literal|0
condition|)
name|packet_disconnect
argument_list|(
literal|"getaddrinfo: fatal error"
argument_list|)
expr_stmt|;
for|for
control|(
name|ai
operator|=
name|aitop
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET
operator|&&
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
if|if
condition|(
name|getnameinfo
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|,
name|ntop
argument_list|,
sizeof|sizeof
argument_list|(
name|ntop
argument_list|)
argument_list|,
name|strport
argument_list|,
sizeof|sizeof
argument_list|(
name|strport
argument_list|)
argument_list|,
name|NI_NUMERICHOST
operator||
name|NI_NUMERICSERV
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"channel_setup_fwd_listener: getnameinfo failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Create a port to listen for the host. */
name|sock
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
comment|/* this is no error since kernel may not support ipv6 */
name|verbose
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Set socket options.  We would like the socket to disappear 		 * as soon as it has been closed for whatever reason. 		 */
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
name|linger
operator|.
name|l_onoff
operator|=
literal|1
expr_stmt|;
name|linger
operator|.
name|l_linger
operator|=
literal|5
expr_stmt|;
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_LINGER
argument_list|,
operator|&
name|linger
argument_list|,
sizeof|sizeof
argument_list|(
name|linger
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Local forwarding listening on %s port %s."
argument_list|,
name|ntop
argument_list|,
name|strport
argument_list|)
expr_stmt|;
comment|/* Bind the socket to the address. */
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* address can be in use ipv6 address is already bound */
name|verbose
argument_list|(
literal|"bind: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Start listening for connections on the socket. */
if|if
condition|(
name|listen
argument_list|(
name|sock
argument_list|,
literal|5
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"listen: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate a channel number for the socket. */
name|c
operator|=
name|channel_new
argument_list|(
literal|"port listener"
argument_list|,
name|type
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_TCP_WINDOW_DEFAULT
argument_list|,
name|CHAN_TCP_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
name|xstrdup
argument_list|(
literal|"port listener"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|c
operator|->
name|path
argument_list|,
name|host
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|host_port
operator|=
name|port_to_connect
expr_stmt|;
name|c
operator|->
name|listening_port
operator|=
name|listen_port
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|success
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"channel_setup_fwd_listener: cannot listen to port: %d"
argument_list|,
name|listen_port
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|aitop
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/* protocol local port fwd, used by ssh (and sshd in v1) */
end_comment

begin_function
name|int
name|channel_setup_local_fwd_listener
parameter_list|(
name|u_short
name|listen_port
parameter_list|,
specifier|const
name|char
modifier|*
name|host_to_connect
parameter_list|,
name|u_short
name|port_to_connect
parameter_list|,
name|int
name|gateway_ports
parameter_list|)
block|{
return|return
name|channel_setup_fwd_listener
argument_list|(
name|SSH_CHANNEL_PORT_LISTENER
argument_list|,
name|NULL
argument_list|,
name|listen_port
argument_list|,
name|host_to_connect
argument_list|,
name|port_to_connect
argument_list|,
name|gateway_ports
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* protocol v2 remote port fwd, used by sshd */
end_comment

begin_function
name|int
name|channel_setup_remote_fwd_listener
parameter_list|(
specifier|const
name|char
modifier|*
name|listen_address
parameter_list|,
name|u_short
name|listen_port
parameter_list|,
name|int
name|gateway_ports
parameter_list|)
block|{
return|return
name|channel_setup_fwd_listener
argument_list|(
name|SSH_CHANNEL_RPORT_LISTENER
argument_list|,
name|listen_address
argument_list|,
name|listen_port
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|gateway_ports
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initiate forwarding of connections to port "port" on remote host through  * the secure channel to host:port from local side.  */
end_comment

begin_function
name|void
name|channel_request_remote_forwarding
parameter_list|(
name|u_short
name|listen_port
parameter_list|,
specifier|const
name|char
modifier|*
name|host_to_connect
parameter_list|,
name|u_short
name|port_to_connect
parameter_list|)
block|{
name|int
name|type
decl_stmt|,
name|success
init|=
literal|0
decl_stmt|;
comment|/* Record locally that connection to this host/port is permitted. */
if|if
condition|(
name|num_permitted_opens
operator|>=
name|SSH_MAX_FORWARDS_PER_DIRECTION
condition|)
name|fatal
argument_list|(
literal|"channel_request_remote_forwarding: too many forwards"
argument_list|)
expr_stmt|;
comment|/* Send the forward request to the remote side. */
if|if
condition|(
name|compat20
condition|)
block|{
specifier|const
name|char
modifier|*
name|address_to_bind
init|=
literal|"0.0.0.0"
decl_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_GLOBAL_REQUEST
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"tcpip-forward"
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* boolean: want reply */
name|packet_put_cstring
argument_list|(
name|address_to_bind
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|listen_port
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Assume that server accepts the request */
name|success
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_PORT_FORWARD_REQUEST
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|listen_port
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|host_to_connect
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|port_to_connect
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Wait for response from the remote side. */
name|type
operator|=
name|packet_read
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SSH_SMSG_SUCCESS
case|:
name|success
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SSH_SMSG_FAILURE
case|:
name|log
argument_list|(
literal|"Warning: Server denied remote port forwarding."
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Unknown packet */
name|packet_disconnect
argument_list|(
literal|"Protocol error for port forward request:"
literal|"received packet type %d."
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|success
condition|)
block|{
name|permitted_opens
index|[
name|num_permitted_opens
index|]
operator|.
name|host_to_connect
operator|=
name|xstrdup
argument_list|(
name|host_to_connect
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|num_permitted_opens
index|]
operator|.
name|port_to_connect
operator|=
name|port_to_connect
expr_stmt|;
name|permitted_opens
index|[
name|num_permitted_opens
index|]
operator|.
name|listen_port
operator|=
name|listen_port
expr_stmt|;
name|num_permitted_opens
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called after receiving CHANNEL_FORWARDING_REQUEST.  This initates  * listening for the port, and sends back a success reply (or disconnect  * message if there was an error).  This never returns if there was an error.  */
end_comment

begin_function
name|void
name|channel_input_port_forward_request
parameter_list|(
name|int
name|is_root
parameter_list|,
name|int
name|gateway_ports
parameter_list|)
block|{
name|u_short
name|port
decl_stmt|,
name|host_port
decl_stmt|;
name|char
modifier|*
name|hostname
decl_stmt|;
comment|/* Get arguments from the packet. */
name|port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|hostname
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|host_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
comment|/* 	 * Check that an unprivileged user is not trying to forward a 	 * privileged port. 	 */
if|if
condition|(
name|port
operator|<
name|IPPORT_RESERVED
operator|&&
operator|!
name|is_root
condition|)
name|packet_disconnect
argument_list|(
literal|"Requested forwarding of port %d but user is not root."
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* Initiate forwarding */
name|channel_setup_local_fwd_listener
argument_list|(
name|port
argument_list|,
name|hostname
argument_list|,
name|host_port
argument_list|,
name|gateway_ports
argument_list|)
expr_stmt|;
comment|/* Free the argument string. */
name|xfree
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Permits opening to any host/port if permitted_opens[] is empty.  This is  * usually called by the server, because the user could connect to any port  * anyway, and the server has no way to know but to trust the client anyway.  */
end_comment

begin_function
name|void
name|channel_permit_all_opens
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|num_permitted_opens
operator|==
literal|0
condition|)
name|all_opens_permitted
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_add_permitted_opens
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
name|num_permitted_opens
operator|>=
name|SSH_MAX_FORWARDS_PER_DIRECTION
condition|)
name|fatal
argument_list|(
literal|"channel_request_remote_forwarding: too many forwards"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"allow port forwarding to host %s port %d"
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|num_permitted_opens
index|]
operator|.
name|host_to_connect
operator|=
name|xstrdup
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|permitted_opens
index|[
name|num_permitted_opens
index|]
operator|.
name|port_to_connect
operator|=
name|port
expr_stmt|;
name|num_permitted_opens
operator|++
expr_stmt|;
name|all_opens_permitted
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|channel_clear_permitted_opens
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_permitted_opens
condition|;
name|i
operator|++
control|)
name|xfree
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
argument_list|)
expr_stmt|;
name|num_permitted_opens
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return socket to remote host, port */
end_comment

begin_function
specifier|static
name|int
name|connect_to
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
decl_stmt|,
modifier|*
name|aitop
decl_stmt|;
name|char
name|ntop
index|[
name|NI_MAXHOST
index|]
decl_stmt|,
name|strport
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|int
name|gaierr
decl_stmt|;
name|int
name|sock
init|=
operator|-
literal|1
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|IPv4or6
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|snprintf
argument_list|(
name|strport
argument_list|,
sizeof|sizeof
name|strport
argument_list|,
literal|"%d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gaierr
operator|=
name|getaddrinfo
argument_list|(
name|host
argument_list|,
name|strport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|aitop
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"connect_to %.100s: unknown host (%s)"
argument_list|,
name|host
argument_list|,
name|gai_strerror
argument_list|(
name|gaierr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|ai
operator|=
name|aitop
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET
operator|&&
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
if|if
condition|(
name|getnameinfo
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|,
name|ntop
argument_list|,
sizeof|sizeof
argument_list|(
name|ntop
argument_list|)
argument_list|,
name|strport
argument_list|,
sizeof|sizeof
argument_list|(
name|strport
argument_list|)
argument_list|,
name|NI_NUMERICHOST
operator||
name|NI_NUMERICSERV
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"connect_to: getnameinfo failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sock
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|sock
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"connect_to: F_SETFL: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|sock
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINPROGRESS
condition|)
block|{
name|error
argument_list|(
literal|"connect_to %.100s port %s: %.100s"
argument_list|,
name|ntop
argument_list|,
name|strport
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
continue|continue;
comment|/* fail -- try next */
block|}
break|break;
comment|/* success */
block|}
name|freeaddrinfo
argument_list|(
name|aitop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ai
condition|)
block|{
name|error
argument_list|(
literal|"connect_to %.100s port %d: failed."
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* success */
name|set_nodelay
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|sock
return|;
block|}
end_function

begin_function
name|int
name|channel_connect_by_listen_address
parameter_list|(
name|u_short
name|listen_port
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_permitted_opens
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|listen_port
operator|==
name|listen_port
condition|)
return|return
name|connect_to
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
argument_list|,
name|permitted_opens
index|[
name|i
index|]
operator|.
name|port_to_connect
argument_list|)
return|;
name|error
argument_list|(
literal|"WARNING: Server requests forwarding for unknown listen_port %d"
argument_list|,
name|listen_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check if connecting to that port is permitted and connect. */
end_comment

begin_function
name|int
name|channel_connect_to
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|permit
decl_stmt|;
name|permit
operator|=
name|all_opens_permitted
expr_stmt|;
if|if
condition|(
operator|!
name|permit
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_permitted_opens
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|port_to_connect
operator|==
name|port
operator|&&
name|strcmp
argument_list|(
name|permitted_opens
index|[
name|i
index|]
operator|.
name|host_to_connect
argument_list|,
name|host
argument_list|)
operator|==
literal|0
condition|)
name|permit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|permit
condition|)
block|{
name|log
argument_list|(
literal|"Received request to connect to host %.100s port %d, "
literal|"but the request was denied."
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|connect_to
argument_list|(
name|host
argument_list|,
name|port
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* -- X11 forwarding */
end_comment

begin_comment
comment|/*  * Creates an internet domain socket for listening for X11 connections.  * Returns a suitable display number for the DISPLAY variable, or -1 if  * an error occurs.  */
end_comment

begin_function
name|int
name|x11_create_display_inet
parameter_list|(
name|int
name|x11_display_offset
parameter_list|,
name|int
name|x11_use_localhost
parameter_list|,
name|int
name|single_connection
parameter_list|)
block|{
name|Channel
modifier|*
name|nc
init|=
name|NULL
decl_stmt|;
name|int
name|display_number
decl_stmt|,
name|sock
decl_stmt|;
name|u_short
name|port
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
decl_stmt|,
modifier|*
name|aitop
decl_stmt|;
name|char
name|strport
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|int
name|gaierr
decl_stmt|,
name|n
decl_stmt|,
name|num_socks
init|=
literal|0
decl_stmt|,
name|socks
index|[
name|NUM_SOCKS
index|]
decl_stmt|;
for|for
control|(
name|display_number
operator|=
name|x11_display_offset
init|;
name|display_number
operator|<
name|MAX_DISPLAYS
condition|;
name|display_number
operator|++
control|)
block|{
name|port
operator|=
literal|6000
operator|+
name|display_number
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|IPv4or6
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|x11_use_localhost
condition|?
literal|0
else|:
name|AI_PASSIVE
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|snprintf
argument_list|(
name|strport
argument_list|,
sizeof|sizeof
name|strport
argument_list|,
literal|"%d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gaierr
operator|=
name|getaddrinfo
argument_list|(
name|NULL
argument_list|,
name|strport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|aitop
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"getaddrinfo: %.100s"
argument_list|,
name|gai_strerror
argument_list|(
name|gaierr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|ai
operator|=
name|aitop
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET
operator|&&
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|sock
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"bind port %d: %.100s"
argument_list|,
name|port
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_socks
condition|;
name|n
operator|++
control|)
block|{
name|close
argument_list|(
name|socks
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
name|num_socks
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|socks
index|[
name|num_socks
operator|++
index|]
operator|=
name|sock
expr_stmt|;
if|if
condition|(
name|num_socks
operator|==
name|NUM_SOCKS
condition|)
break|break;
block|}
name|freeaddrinfo
argument_list|(
name|aitop
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_socks
operator|>
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|display_number
operator|>=
name|MAX_DISPLAYS
condition|)
block|{
name|error
argument_list|(
literal|"Failed to allocate internet-domain X11 display socket."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Start listening for connections on the socket. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_socks
condition|;
name|n
operator|++
control|)
block|{
name|sock
operator|=
name|socks
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|listen
argument_list|(
name|sock
argument_list|,
literal|5
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"listen: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Allocate a channel for each socket. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_socks
condition|;
name|n
operator|++
control|)
block|{
name|sock
operator|=
name|socks
index|[
name|n
index|]
expr_stmt|;
name|nc
operator|=
name|channel_new
argument_list|(
literal|"x11 listener"
argument_list|,
name|SSH_CHANNEL_X11_LISTENER
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_X11_WINDOW_DEFAULT
argument_list|,
name|CHAN_X11_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
name|xstrdup
argument_list|(
literal|"X11 inet listener"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nc
operator|->
name|single_connection
operator|=
name|single_connection
expr_stmt|;
block|}
comment|/* Return the display number for the DISPLAY environment variable. */
return|return
name|display_number
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|connect_local_xsocket
parameter_list|(
name|u_int
name|dnr
parameter_list|)
block|{
name|int
name|sock
decl_stmt|;
name|struct
name|sockaddr_un
name|addr
decl_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|snprintf
argument_list|(
name|addr
operator|.
name|sun_path
argument_list|,
sizeof|sizeof
name|addr
operator|.
name|sun_path
argument_list|,
name|_PATH_UNIX_X
argument_list|,
name|dnr
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sock
return|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"connect %.100s: %.100s"
argument_list|,
name|addr
operator|.
name|sun_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|x11_connect_display
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|display_number
decl_stmt|,
name|sock
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|display
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
decl_stmt|,
modifier|*
name|aitop
decl_stmt|;
name|char
name|strport
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|int
name|gaierr
decl_stmt|;
comment|/* Try to open a socket for the local X server. */
name|display
operator|=
name|getenv
argument_list|(
literal|"DISPLAY"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|display
condition|)
block|{
name|error
argument_list|(
literal|"DISPLAY not set."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Now we decode the value of the DISPLAY variable and make a 	 * connection to the real X server. 	 */
comment|/* 	 * Check if it is a unix domain socket.  Unix domain displays are in 	 * one of the following formats: unix:d[.s], :d[.s], ::d[.s] 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|display
argument_list|,
literal|"unix:"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|display
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* Connect to the unix domain socket. */
if|if
condition|(
name|sscanf
argument_list|(
name|strrchr
argument_list|(
name|display
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|display_number
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Could not parse display number from DISPLAY: %.100s"
argument_list|,
name|display
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Create a socket. */
name|sock
operator|=
name|connect_local_xsocket
argument_list|(
name|display_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* OK, we now have a connection to the display. */
return|return
name|sock
return|;
block|}
comment|/* 	 * Connect to an inet socket.  The DISPLAY value is supposedly 	 * hostname:d[.s], where hostname may also be numeric IP address. 	 */
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|display
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|error
argument_list|(
literal|"Could not find ':' in DISPLAY: %.100s"
argument_list|,
name|display
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
comment|/* buf now contains the host name.  But first we parse the display number. */
if|if
condition|(
name|sscanf
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|display_number
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Could not parse display number from DISPLAY: %.100s"
argument_list|,
name|display
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Look up the host address */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|IPv4or6
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|snprintf
argument_list|(
name|strport
argument_list|,
sizeof|sizeof
name|strport
argument_list|,
literal|"%d"
argument_list|,
literal|6000
operator|+
name|display_number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gaierr
operator|=
name|getaddrinfo
argument_list|(
name|buf
argument_list|,
name|strport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|aitop
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%.100s: unknown host. (%s)"
argument_list|,
name|buf
argument_list|,
name|gai_strerror
argument_list|(
name|gaierr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|ai
operator|=
name|aitop
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
comment|/* Create a socket. */
name|sock
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Connect it to the display. */
if|if
condition|(
name|connect
argument_list|(
name|sock
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"connect %.100s port %d: %.100s"
argument_list|,
name|buf
argument_list|,
literal|6000
operator|+
name|display_number
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Success */
break|break;
block|}
name|freeaddrinfo
argument_list|(
name|aitop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ai
condition|)
block|{
name|error
argument_list|(
literal|"connect %.100s port %d: %.100s"
argument_list|,
name|buf
argument_list|,
literal|6000
operator|+
name|display_number
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|set_nodelay
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|sock
return|;
block|}
end_function

begin_comment
comment|/*  * This is called when SSH_SMSG_X11_OPEN is received.  The packet contains  * the remote channel number.  We should do whatever we want, and respond  * with either SSH_MSG_OPEN_CONFIRMATION or SSH_MSG_OPEN_FAILURE.  */
end_comment

begin_function
name|void
name|x11_input_open
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|int
name|remote_id
decl_stmt|,
name|sock
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|remote_host
decl_stmt|;
name|debug
argument_list|(
literal|"Received X11 open request."
argument_list|)
expr_stmt|;
name|remote_id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|packet_get_protocol_flags
argument_list|()
operator|&
name|SSH_PROTOFLAG_HOST_IN_FWD_OPEN
condition|)
block|{
name|remote_host
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|remote_host
operator|=
name|xstrdup
argument_list|(
literal|"unknown (remote did not supply name)"
argument_list|)
expr_stmt|;
block|}
name|packet_check_eom
argument_list|()
expr_stmt|;
comment|/* Obtain a connection to the real X display. */
name|sock
operator|=
name|x11_connect_display
argument_list|()
expr_stmt|;
if|if
condition|(
name|sock
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Allocate a channel for this connection. */
name|c
operator|=
name|channel_new
argument_list|(
literal|"connected x11 socket"
argument_list|,
name|SSH_CHANNEL_X11_OPEN
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|remote_host
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
name|remote_id
expr_stmt|;
name|c
operator|->
name|force_drain
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
comment|/* Send refusal to the remote host. */
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Send a confirmation to the remote host. */
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dummy protocol handler that denies SSH-1 requests (agent/x11) */
end_comment

begin_function
name|void
name|deny_input_open
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|rchan
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SSH_SMSG_AGENT_OPEN
case|:
name|error
argument_list|(
literal|"Warning: ssh server tried agent forwarding."
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_SMSG_X11_OPEN
case|:
name|error
argument_list|(
literal|"Warning: ssh server tried X11 forwarding."
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"deny_input_open: type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
argument_list|(
literal|"Warning: this is probably a break in attempt by a malicious server."
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|rchan
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Requests forwarding of X11 connections, generates fake authentication  * data, and enables authentication spoofing.  * This should be called in the client only.  */
end_comment

begin_function
name|void
name|x11_request_forwarding_with_spoofing
parameter_list|(
name|int
name|client_session_id
parameter_list|,
specifier|const
name|char
modifier|*
name|proto
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|u_int
name|data_len
init|=
operator|(
name|u_int
operator|)
name|strlen
argument_list|(
name|data
argument_list|)
operator|/
literal|2
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|value
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|new_data
decl_stmt|;
name|int
name|screen_number
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|u_int32_t
name|rand
init|=
literal|0
decl_stmt|;
name|cp
operator|=
name|getenv
argument_list|(
literal|"DISPLAY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|screen_number
operator|=
name|atoi
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|screen_number
operator|=
literal|0
expr_stmt|;
comment|/* Save protocol name. */
name|x11_saved_proto
operator|=
name|xstrdup
argument_list|(
name|proto
argument_list|)
expr_stmt|;
comment|/* 	 * Extract real authentication data and generate fake data of the 	 * same length. 	 */
name|x11_saved_data
operator|=
name|xmalloc
argument_list|(
name|data_len
argument_list|)
expr_stmt|;
name|x11_fake_data
operator|=
name|xmalloc
argument_list|(
name|data_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|data
operator|+
literal|2
operator|*
name|i
argument_list|,
literal|"%2x"
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"x11_request_forwarding: bad authentication data: %.100s"
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|4
operator|==
literal|0
condition|)
name|rand
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|x11_saved_data
index|[
name|i
index|]
operator|=
name|value
expr_stmt|;
name|x11_fake_data
index|[
name|i
index|]
operator|=
name|rand
operator|&
literal|0xff
expr_stmt|;
name|rand
operator|>>=
literal|8
expr_stmt|;
block|}
name|x11_saved_data_len
operator|=
name|data_len
expr_stmt|;
name|x11_fake_data_len
operator|=
name|data_len
expr_stmt|;
comment|/* Convert the fake data into hex. */
name|len
operator|=
literal|2
operator|*
name|data_len
operator|+
literal|1
expr_stmt|;
name|new_data
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data_len
condition|;
name|i
operator|++
control|)
name|snprintf
argument_list|(
name|new_data
operator|+
literal|2
operator|*
name|i
argument_list|,
name|len
operator|-
literal|2
operator|*
name|i
argument_list|,
literal|"%02x"
argument_list|,
operator|(
name|u_char
operator|)
name|x11_fake_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Send the request packet. */
if|if
condition|(
name|compat20
condition|)
block|{
name|channel_request_start
argument_list|(
name|client_session_id
argument_list|,
literal|"x11-req"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX bool single connection */
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_X11_REQUEST_FORWARDING
argument_list|)
expr_stmt|;
block|}
name|packet_put_cstring
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|new_data
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|screen_number
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
name|xfree
argument_list|(
name|new_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -- agent forwarding */
end_comment

begin_comment
comment|/* Sends a message to the server to request authentication fd forwarding. */
end_comment

begin_function
name|void
name|auth_request_forwarding
parameter_list|(
name|void
parameter_list|)
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_AGENT_REQUEST_FORWARDING
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns the name of the forwarded authentication socket.  Returns NULL if  * there is no forwarded authentication socket.  The returned value points to  * a static buffer.  */
end_comment

begin_function
name|char
modifier|*
name|auth_get_socket_name
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|auth_sock_name
return|;
block|}
end_function

begin_comment
comment|/* removes the agent forwarding socket */
end_comment

begin_function
name|void
name|auth_sock_cleanup_proc
parameter_list|(
name|void
modifier|*
name|_pw
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pw
init|=
name|_pw
decl_stmt|;
if|if
condition|(
name|auth_sock_name
condition|)
block|{
name|temporarily_use_uid
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|auth_sock_name
argument_list|)
expr_stmt|;
name|rmdir
argument_list|(
name|auth_sock_dir
argument_list|)
expr_stmt|;
name|auth_sock_name
operator|=
name|NULL
expr_stmt|;
name|restore_uid
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called to process SSH_CMSG_AGENT_REQUEST_FORWARDING on the server.  * This starts forwarding authentication requests.  */
end_comment

begin_function
name|int
name|auth_input_request_forwarding
parameter_list|(
name|struct
name|passwd
modifier|*
name|pw
parameter_list|)
block|{
name|Channel
modifier|*
name|nc
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|struct
name|sockaddr_un
name|sunaddr
decl_stmt|;
if|if
condition|(
name|auth_get_socket_name
argument_list|()
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"authentication forwarding requested twice."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Temporarily drop privileged uid for mkdir/bind. */
name|temporarily_use_uid
argument_list|(
name|pw
argument_list|)
expr_stmt|;
comment|/* Allocate a buffer for the socket name, and format the name. */
name|auth_sock_name
operator|=
name|xmalloc
argument_list|(
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|auth_sock_dir
operator|=
name|xmalloc
argument_list|(
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|auth_sock_dir
argument_list|,
literal|"/tmp/ssh-XXXXXXXX"
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
comment|/* Create private directory for socket */
if|if
condition|(
name|mkdtemp
argument_list|(
name|auth_sock_dir
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|packet_send_debug
argument_list|(
literal|"Agent forwarding disabled: "
literal|"mkdtemp() failed: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|restore_uid
argument_list|()
expr_stmt|;
name|xfree
argument_list|(
name|auth_sock_name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|auth_sock_dir
argument_list|)
expr_stmt|;
name|auth_sock_name
operator|=
name|NULL
expr_stmt|;
name|auth_sock_dir
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|snprintf
argument_list|(
name|auth_sock_name
argument_list|,
name|MAXPATHLEN
argument_list|,
literal|"%s/agent.%d"
argument_list|,
name|auth_sock_dir
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* delete agent socket on fatal() */
name|fatal_add_cleanup
argument_list|(
name|auth_sock_cleanup_proc
argument_list|,
name|pw
argument_list|)
expr_stmt|;
comment|/* Create the socket. */
name|sock
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
name|packet_disconnect
argument_list|(
literal|"socket: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Bind it to the name. */
name|memset
argument_list|(
operator|&
name|sunaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sunaddr
argument_list|)
argument_list|)
expr_stmt|;
name|sunaddr
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|strlcpy
argument_list|(
name|sunaddr
operator|.
name|sun_path
argument_list|,
name|auth_sock_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sunaddr
operator|.
name|sun_path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sunaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sunaddr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|packet_disconnect
argument_list|(
literal|"bind: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the privileged uid. */
name|restore_uid
argument_list|()
expr_stmt|;
comment|/* Start listening on the socket. */
if|if
condition|(
name|listen
argument_list|(
name|sock
argument_list|,
literal|5
argument_list|)
operator|<
literal|0
condition|)
name|packet_disconnect
argument_list|(
literal|"listen: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate a channel for the authentication agent socket. */
name|nc
operator|=
name|channel_new
argument_list|(
literal|"auth socket"
argument_list|,
name|SSH_CHANNEL_AUTH_SOCKET
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_X11_WINDOW_DEFAULT
argument_list|,
name|CHAN_X11_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
name|xstrdup
argument_list|(
literal|"auth socket"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|nc
operator|->
name|path
argument_list|,
name|auth_sock_name
argument_list|,
sizeof|sizeof
argument_list|(
name|nc
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This is called to process an SSH_SMSG_AGENT_OPEN message. */
end_comment

begin_function
name|void
name|auth_input_open_request
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|int
name|remote_id
decl_stmt|,
name|sock
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Read the remote channel number from the message. */
name|remote_id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
comment|/* 	 * Get a connection to the local authentication agent (this may again 	 * get forwarded). 	 */
name|sock
operator|=
name|ssh_get_authentication_socket
argument_list|()
expr_stmt|;
comment|/* 	 * If we could not connect the agent, send an error message back to 	 * the server. This should never happen unless the agent dies, 	 * because authentication forwarding is only enabled if we have an 	 * agent. 	 */
if|if
condition|(
name|sock
operator|>=
literal|0
condition|)
block|{
name|name
operator|=
name|xstrdup
argument_list|(
literal|"authentication agent connection"
argument_list|)
expr_stmt|;
name|c
operator|=
name|channel_new
argument_list|(
literal|""
argument_list|,
name|SSH_CHANNEL_OPEN
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
name|remote_id
expr_stmt|;
name|c
operator|->
name|force_drain
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Send a confirmation to the remote host. */
name|debug
argument_list|(
literal|"Forwarding authentication connection."
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

