begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   * clientloop.c  *   * Author: Tatu Ylonen<ylo@cs.hut.fi>  *   * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  *   *   * Created: Sat Sep 23 12:23:57 1995 ylo  *   * The main loop for the interactive session (client side).  *   */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: clientloop.c,v 1.14 1999/12/06 20:15:26 deraadt Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"authfd.h"
end_include

begin_include
include|#
directive|include
file|"readconf.h"
end_include

begin_comment
comment|/* Flag indicating that stdin should be redirected from /dev/null. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stdin_null_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Name of the host we are connecting to.  This is the name given on the  * command line, or the HostName specified for the user-supplied name in a  * configuration file.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|host
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flag to indicate that we have received a window change signal which has  * not yet been processed.  This will cause a message indicating the new  * window size to be sent to the server a little later.  This is volatile  * because this is updated in a signal handler.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|received_window_change_signal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Terminal modes, as saved by enter_raw_mode. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|termios
name|saved_tio
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flag indicating whether we are in raw mode.  This is used by  * enter_raw_mode and leave_raw_mode.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_raw_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating whether the user\'s terminal is in non-blocking mode. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_non_blocking_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Common data for the client loop code. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|escape_pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last character was the escape character */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_was_cr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last character was a newline. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exit_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to store the exit status of the command. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdin_eof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF has been encountered on standard error. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stdin_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stdin data. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stdout_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stdout data. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stderr_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stderr data. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|buffer_high
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Soft max buffer size. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum file descriptor number in select(). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|connection_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to server (input). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|connection_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to server (output). */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|stdin_bytes
decl_stmt|,
name|stdout_bytes
decl_stmt|,
name|stderr_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|quit_pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to non-zero to quit the client loop. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|escape_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Escape character. */
end_comment

begin_comment
comment|/* Returns the user\'s terminal to normal mode if it had been put in raw mode. */
end_comment

begin_function
name|void
name|leave_raw_mode
parameter_list|()
block|{
if|if
condition|(
operator|!
name|in_raw_mode
condition|)
return|return;
name|in_raw_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|saved_tio
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"tcsetattr"
argument_list|)
expr_stmt|;
name|fatal_remove_cleanup
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|leave_raw_mode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Puts the user\'s terminal in raw mode. */
end_comment

begin_function
name|void
name|enter_raw_mode
parameter_list|()
block|{
name|struct
name|termios
name|tio
decl_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|tio
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"tcgetattr"
argument_list|)
expr_stmt|;
name|saved_tio
operator|=
name|tio
expr_stmt|;
name|tio
operator|.
name|c_iflag
operator||=
name|IGNPAR
expr_stmt|;
name|tio
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|ISTRIP
operator||
name|INLCR
operator||
name|IGNCR
operator||
name|ICRNL
operator||
name|IXON
operator||
name|IXANY
operator||
name|IXOFF
operator|)
expr_stmt|;
name|tio
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ISIG
operator||
name|ICANON
operator||
name|ECHO
operator||
name|ECHOE
operator||
name|ECHOK
operator||
name|ECHONL
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEXTEN
name|tio
operator|.
name|c_lflag
operator|&=
operator|~
name|IEXTEN
expr_stmt|;
endif|#
directive|endif
comment|/* IEXTEN */
name|tio
operator|.
name|c_oflag
operator|&=
operator|~
name|OPOST
expr_stmt|;
name|tio
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|tio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|tio
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"tcsetattr"
argument_list|)
expr_stmt|;
name|in_raw_mode
operator|=
literal|1
expr_stmt|;
name|fatal_add_cleanup
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|leave_raw_mode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restores stdin to blocking mode. */
end_comment

begin_function
name|void
name|leave_non_blocking
parameter_list|()
block|{
if|if
condition|(
name|in_non_blocking_mode
condition|)
block|{
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|in_non_blocking_mode
operator|=
literal|0
expr_stmt|;
name|fatal_remove_cleanup
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|leave_non_blocking
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Puts stdin terminal in non-blocking mode. */
end_comment

begin_function
name|void
name|enter_non_blocking
parameter_list|()
block|{
name|in_non_blocking_mode
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
name|fatal_add_cleanup
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|leave_non_blocking
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Signal handler for the window change signal (SIGWINCH).  This just sets a  * flag indicating that the window has changed.  */
end_comment

begin_function
name|void
name|window_change_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|received_window_change_signal
operator|=
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|window_change_handler
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Signal handler for signals that cause the program to terminate.  These  * signals must be trapped to restore terminal modes.  */
end_comment

begin_function
name|void
name|signal_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|in_raw_mode
condition|)
name|leave_raw_mode
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_non_blocking_mode
condition|)
name|leave_non_blocking
argument_list|()
expr_stmt|;
name|channel_stop_listening
argument_list|()
expr_stmt|;
name|packet_close
argument_list|()
expr_stmt|;
name|fatal
argument_list|(
literal|"Killed by signal %d."
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns current time in seconds from Jan 1, 1970 with the maximum  * available resolution.  */
end_comment

begin_function
name|double
name|get_current_time
parameter_list|()
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|double
operator|)
name|tv
operator|.
name|tv_sec
operator|+
operator|(
name|double
operator|)
name|tv
operator|.
name|tv_usec
operator|/
literal|1000000.0
return|;
block|}
end_function

begin_comment
comment|/*  * This is called when the interactive is entered.  This checks if there is  * an EOF coming on stdin.  We must check this explicitly, as select() does  * not appear to wake up when redirecting from /dev/null.  */
end_comment

begin_function
name|void
name|client_check_initial_eof_on_stdin
parameter_list|()
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
comment|/* 	 * If standard input is to be "redirected from /dev/null", we simply 	 * mark that we have seen an EOF and send an EOF message to the 	 * server. Otherwise, we try to read a single character; it appears 	 * that for some files, such /dev/null, select() never wakes up for 	 * read for this descriptor, which means that we never get EOF.  This 	 * way we will get the EOF if stdin comes from /dev/null or similar. 	 */
if|if
condition|(
name|stdin_null_flag
condition|)
block|{
comment|/* Fake EOF on stdin. */
name|debug
argument_list|(
literal|"Sending eof."
argument_list|)
expr_stmt|;
name|stdin_eof
operator|=
literal|1
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|enter_non_blocking
argument_list|()
expr_stmt|;
comment|/* Check for immediate EOF on stdin. */
name|len
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* EOF.  Record that we have seen it and send EOF to server. */
name|debug
argument_list|(
literal|"Sending eof."
argument_list|)
expr_stmt|;
name|stdin_eof
operator|=
literal|1
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Got data.  We must store the data in the buffer, 			 * and also process it as an escape character if 			 * appropriate. 			 */
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
literal|0
index|]
operator|==
name|escape_char
condition|)
name|escape_pending
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|buffer_append
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stdin_bytes
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|leave_non_blocking
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get packets from the connection input buffer, and process them as long as  * there are packets available.  */
end_comment

begin_function
name|void
name|client_process_buffered_input_packets
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|data_len
decl_stmt|;
name|int
name|payload_len
decl_stmt|;
comment|/* Process any buffered packets from the server. */
while|while
condition|(
operator|!
name|quit_pending
operator|&&
operator|(
name|type
operator|=
name|packet_read_poll
argument_list|(
operator|&
name|payload_len
argument_list|)
operator|)
operator|!=
name|SSH_MSG_NONE
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SSH_SMSG_STDOUT_DATA
case|:
name|data
operator|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
expr_stmt|;
name|packet_integrity_check
argument_list|(
name|payload_len
argument_list|,
literal|4
operator|+
name|data_len
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|stdout_bytes
operator|+=
name|data_len
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_SMSG_STDERR_DATA
case|:
name|data
operator|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
expr_stmt|;
name|packet_integrity_check
argument_list|(
name|payload_len
argument_list|,
literal|4
operator|+
name|data_len
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|stdout_bytes
operator|+=
name|data_len
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_SMSG_EXITSTATUS
case|:
name|packet_integrity_check
argument_list|(
name|payload_len
argument_list|,
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|exit_status
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
comment|/* Acknowledge the exit. */
name|packet_start
argument_list|(
name|SSH_CMSG_EXIT_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* 			 * Must wait for packet to be sent since we are 			 * exiting the loop. 			 */
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Flag that we want to exit. */
name|quit_pending
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SSH_SMSG_X11_OPEN
case|:
name|x11_input_open
argument_list|(
name|payload_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_MSG_PORT_OPEN
case|:
name|channel_input_port_open
argument_list|(
name|payload_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_SMSG_AGENT_OPEN
case|:
name|packet_integrity_check
argument_list|(
name|payload_len
argument_list|,
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|auth_input_open_request
argument_list|()
expr_stmt|;
break|break;
case|case
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
case|:
name|packet_integrity_check
argument_list|(
name|payload_len
argument_list|,
literal|4
operator|+
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|channel_input_open_confirmation
argument_list|()
expr_stmt|;
break|break;
case|case
name|SSH_MSG_CHANNEL_OPEN_FAILURE
case|:
name|packet_integrity_check
argument_list|(
name|payload_len
argument_list|,
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|channel_input_open_failure
argument_list|()
expr_stmt|;
break|break;
case|case
name|SSH_MSG_CHANNEL_DATA
case|:
name|channel_input_data
argument_list|(
name|payload_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_MSG_CHANNEL_CLOSE
case|:
name|packet_integrity_check
argument_list|(
name|payload_len
argument_list|,
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|channel_input_close
argument_list|()
expr_stmt|;
break|break;
case|case
name|SSH_MSG_CHANNEL_CLOSE_CONFIRMATION
case|:
name|packet_integrity_check
argument_list|(
name|payload_len
argument_list|,
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|channel_input_close_confirmation
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Any unknown packets received during the actual 			 * session cause the session to terminate.  This is 			 * intended to make debugging easier since no 			 * confirmations are sent.  Any compatible protocol 			 * extensions must be negotiated during the 			 * preparatory phase. 			 */
name|packet_disconnect
argument_list|(
literal|"Protocol error during session: type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Make packets from buffered stdin data, and buffer them for sending to the  * connection.  */
end_comment

begin_function
name|void
name|client_make_packets_from_stdin_data
parameter_list|()
block|{
name|unsigned
name|int
name|len
decl_stmt|;
comment|/* Send buffered stdin data to the server. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|>
literal|0
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
block|{
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
comment|/* Keep the packets at reasonable size. */
if|if
condition|(
name|len
operator|>
name|packet_get_maxsize
argument_list|()
condition|)
name|len
operator|=
name|packet_get_maxsize
argument_list|()
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_CMSG_STDIN_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* If we have a pending EOF, send it now. */
if|if
condition|(
name|stdin_eof
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Checks if the client window has changed, and sends a packet about it to  * the server if so.  The actual change is detected elsewhere (by a software  * interrupt on Unix); this just checks the flag and sends a message if  * appropriate.  */
end_comment

begin_function
name|void
name|client_check_window_change
parameter_list|()
block|{
comment|/* Send possible window change message to the server. */
if|if
condition|(
name|received_window_change_signal
condition|)
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
comment|/* Clear the window change indicator. */
name|received_window_change_signal
operator|=
literal|0
expr_stmt|;
comment|/* Read new window size. */
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Successful, send the packet now. */
name|packet_start
argument_list|(
name|SSH_CMSG_WINDOW_SIZE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_row
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_col
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_xpixel
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_ypixel
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Waits until the client can do something (some data becomes available on  * one of the file descriptors).  */
end_comment

begin_function
name|void
name|client_wait_until_can_do_something
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
comment|/* Initialize select masks. */
name|FD_ZERO
argument_list|(
name|readset
argument_list|)
expr_stmt|;
comment|/* Read from the connection, unless our buffers are full. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|<
name|buffer_high
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|<
name|buffer_high
operator|&&
name|channel_not_very_much_buffered_data
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_in
argument_list|,
name|readset
argument_list|)
expr_stmt|;
comment|/* 	 * Read from stdin, unless we have seen EOF or have very much 	 * buffered data to send to the server. 	 */
if|if
condition|(
operator|!
name|stdin_eof
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|readset
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
name|writeset
argument_list|)
expr_stmt|;
comment|/* Add any selections by the channel mechanism. */
name|channel_prepare_select
argument_list|(
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
comment|/* Select server connection if have data to write to the server. */
if|if
condition|(
name|packet_have_data_to_write
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_out
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
comment|/* Select stdout if have data in buffer. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
comment|/* Select stderr if have data in buffer. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
comment|/* Update maximum file descriptor number, if appropriate. */
if|if
condition|(
name|channel_max_fd
argument_list|()
operator|>
name|max_fd
condition|)
name|max_fd
operator|=
name|channel_max_fd
argument_list|()
expr_stmt|;
comment|/* 	 * Wait for something to happen.  This will suspend the process until 	 * some selected descriptor can be read, written, or has some other 	 * event pending. Note: if you want to implement SSH_MSG_IGNORE 	 * messages to fool traffic analysis, this might be the place to do 	 * it: just have a random timeout for the select, and send a random 	 * SSH_MSG_IGNORE packet when the timeout expires. 	 */
if|if
condition|(
name|select
argument_list|(
name|max_fd
operator|+
literal|1
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* Some systems fail to clear these automatically. */
name|FD_ZERO
argument_list|(
name|readset
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
name|writeset
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
return|return;
comment|/* Note: we might still have data in the buffers. */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"select: %s\r\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|client_suspend_self
parameter_list|()
block|{
name|struct
name|winsize
name|oldws
decl_stmt|,
name|newws
decl_stmt|;
comment|/* Flush stdout and stderr buffers. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|>
literal|0
condition|)
name|atomicio
argument_list|(
name|write
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|>
literal|0
condition|)
name|atomicio
argument_list|(
name|write
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|leave_raw_mode
argument_list|()
expr_stmt|;
comment|/* 	 * Free (and clear) the buffer to reduce the amount of data that gets 	 * written to swap. 	 */
name|buffer_free
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
comment|/* Save old window size. */
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|oldws
argument_list|)
expr_stmt|;
comment|/* Send the suspend signal to the program itself. */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* Check if the window size has changed. */
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|newws
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|oldws
operator|.
name|ws_row
operator|!=
name|newws
operator|.
name|ws_row
operator|||
name|oldws
operator|.
name|ws_col
operator|!=
name|newws
operator|.
name|ws_col
operator|||
name|oldws
operator|.
name|ws_xpixel
operator|!=
name|newws
operator|.
name|ws_xpixel
operator|||
name|oldws
operator|.
name|ws_ypixel
operator|!=
name|newws
operator|.
name|ws_ypixel
operator|)
condition|)
name|received_window_change_signal
operator|=
literal|1
expr_stmt|;
comment|/* OK, we have been continued by the user. Reinitialize buffers. */
name|buffer_init
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
name|enter_raw_mode
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_process_input
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|pid
decl_stmt|;
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|;
comment|/* 	 * Read input from the server, and add any such data to the buffer of 	 * the packet subsystem. 	 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_in
argument_list|,
name|readset
argument_list|)
condition|)
block|{
comment|/* Read as much as possible. */
name|len
operator|=
name|read
argument_list|(
name|connection_in
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* Received EOF.  The remote host has closed the connection. */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"Connection to %.300s closed by remote host.\r\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 		 * There is a kernel bug on Solaris that causes select to 		 * sometimes wake up even though there is no data available. 		 */
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
comment|/* An error has encountered.  Perhaps there is a network problem. */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"Read from remote host %.300s: %.100s\r\n"
argument_list|,
name|host
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|packet_process_incoming
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Read input from stdin. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|readset
argument_list|)
condition|)
block|{
comment|/* Read as much as possible. */
name|len
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
comment|/* 			 * Received EOF or error.  They are treated 			 * similarly, except that an error message is printed 			 * if it was an error condition. 			 */
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"read: %.100s\r\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Mark that we have seen EOF. */
name|stdin_eof
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Send an EOF message to the server unless there is 			 * data in the buffer.  If there is data in the 			 * buffer, no message will be sent now.  Code 			 * elsewhere will send the EOF when the buffer 			 * becomes empty if stdin_eof is set. 			 */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|escape_char
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Normal successful read, and no escape character. 			 * Just append the data to buffer. 			 */
name|buffer_append
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stdin_bytes
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Normal, successful read.  But we have an escape character 			 * and have to process the characters one by one. 			 */
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|ch
decl_stmt|;
comment|/* Get one character at a time. */
name|ch
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|escape_pending
condition|)
block|{
comment|/* We have previously seen an escape character. */
comment|/* Clear the flag now. */
name|escape_pending
operator|=
literal|0
expr_stmt|;
comment|/* Process the escaped character. */
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'.'
case|:
comment|/* Terminate the connection. */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%c.\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
case|case
literal|'Z'
operator|-
literal|64
case|:
comment|/* Suspend the program. */
comment|/* Print a message to that effect to the user. */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%c^Z\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Restore terminal modes and suspend. */
name|client_suspend_self
argument_list|()
expr_stmt|;
comment|/* We have been continued. */
continue|continue;
case|case
literal|'&'
case|:
comment|/* 						 * Detach the program (continue to serve connections, 						 * but put in background and no more new connections). 						 */
if|if
condition|(
operator|!
name|stdin_eof
condition|)
block|{
comment|/* 							 * Sending SSH_CMSG_EOF alone does not always appear 							 * to be enough.  So we try to send an EOF character 							 * first. 							 */
name|packet_start
argument_list|(
name|SSH_CMSG_STDIN_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
literal|"\004"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* Close stdin. */
name|stdin_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Restore tty modes. */
name|leave_raw_mode
argument_list|()
expr_stmt|;
comment|/* Stop listening for new connections. */
name|channel_stop_listening
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%c& [backgrounded]\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
comment|/* Fork into background. */
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"fork: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pid
operator|!=
literal|0
condition|)
block|{
comment|/* This is the parent. */
comment|/* The parent just exits. */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The child continues serving connections. */
continue|continue;
case|case
literal|'?'
case|:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%c?\r\n\ Supported escape sequences:\r\n\ ~.  - terminate connection\r\n\ ~^Z - suspend ssh\r\n\ ~#  - list forwarded connections\r\n\ ~&  - background ssh (when waiting for connections to terminate)\r\n\ ~?  - this message\r\n\ ~~  - send the escape character by typing it twice\r\n\ (Note that escapes are only recognized immediately after newline.)\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'#'
case|:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%c#\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|channel_open_message
argument_list|()
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
name|ch
operator|!=
name|escape_char
condition|)
block|{
comment|/* 							 * Escape character followed by non-special character. 							 * Append both to the input buffer. 							 */
name|buf
index|[
literal|0
index|]
operator|=
name|escape_char
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|ch
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|stdin_bytes
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
comment|/* 						 * Note that escape character typed twice 						 * falls through here; the latter gets processed 						 * as a normal character below. 						 */
break|break;
block|}
block|}
else|else
block|{
comment|/* 					 * The previous character was not an escape char. Check if this 					 * is an escape. 					 */
if|if
condition|(
name|last_was_cr
operator|&&
name|ch
operator|==
name|escape_char
condition|)
block|{
comment|/* It is. Set the flag and continue to next character. */
name|escape_pending
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 				 * Normal character.  Record whether it was a newline, 				 * and append it to the buffer. 				 */
name|last_was_cr
operator|=
operator|(
name|ch
operator|==
literal|'\r'
operator|||
name|ch
operator|==
literal|'\n'
operator|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stdin_bytes
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|client_process_output
parameter_list|(
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* Write buffered output to stdout. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|writeset
argument_list|)
condition|)
block|{
comment|/* Write as much data as possible. */
name|len
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
name|len
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 				 * An error or EOF was encountered.  Put an 				 * error message to stderr buffer. 				 */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"write stdout: %.50s\r\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
comment|/* Consume printed data from the buffer. */
name|buffer_consume
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Write buffered output to stderr. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|writeset
argument_list|)
condition|)
block|{
comment|/* Write as much data as possible. */
name|len
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
name|len
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* EOF or error, but can't even print error message. */
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
comment|/* Consume printed characters from the buffer. */
name|buffer_consume
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Implements the interactive session with the server.  This is called after  * the user has been authenticated, and a command has been started on the  * remote host.  If escape_char != -1, it is the character used as an escape  * character for terminating or suspending the session.  */
end_comment

begin_function
name|int
name|client_loop
parameter_list|(
name|int
name|have_pty
parameter_list|,
name|int
name|escape_char_arg
parameter_list|)
block|{
specifier|extern
name|Options
name|options
decl_stmt|;
name|double
name|start_time
decl_stmt|,
name|total_time
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|debug
argument_list|(
literal|"Entering interactive session."
argument_list|)
expr_stmt|;
name|start_time
operator|=
name|get_current_time
argument_list|()
expr_stmt|;
comment|/* Initialize variables. */
name|escape_pending
operator|=
literal|0
expr_stmt|;
name|last_was_cr
operator|=
literal|1
expr_stmt|;
name|exit_status
operator|=
operator|-
literal|1
expr_stmt|;
name|stdin_eof
operator|=
literal|0
expr_stmt|;
name|buffer_high
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
name|connection_in
operator|=
name|packet_get_connection_in
argument_list|()
expr_stmt|;
name|connection_out
operator|=
name|packet_get_connection_out
argument_list|()
expr_stmt|;
name|max_fd
operator|=
name|connection_in
expr_stmt|;
if|if
condition|(
name|connection_out
operator|>
name|max_fd
condition|)
name|max_fd
operator|=
name|connection_out
expr_stmt|;
name|stdin_bytes
operator|=
literal|0
expr_stmt|;
name|stdout_bytes
operator|=
literal|0
expr_stmt|;
name|stderr_bytes
operator|=
literal|0
expr_stmt|;
name|quit_pending
operator|=
literal|0
expr_stmt|;
name|escape_char
operator|=
name|escape_char_arg
expr_stmt|;
comment|/* Initialize buffers. */
name|buffer_init
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
comment|/* Set signal handlers to restore non-blocking mode.  */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_pty
condition|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|window_change_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_pty
condition|)
name|enter_raw_mode
argument_list|()
expr_stmt|;
comment|/* Check if we should immediately send of on stdin. */
name|client_check_initial_eof_on_stdin
argument_list|()
expr_stmt|;
comment|/* Main loop of the client for the interactive session mode. */
while|while
condition|(
operator|!
name|quit_pending
condition|)
block|{
name|fd_set
name|readset
decl_stmt|,
name|writeset
decl_stmt|;
comment|/* Process buffered packets sent by the server. */
name|client_process_buffered_input_packets
argument_list|()
expr_stmt|;
comment|/* 		 * Make packets of buffered stdin data, and buffer them for 		 * sending to the server. 		 */
name|client_make_packets_from_stdin_data
argument_list|()
expr_stmt|;
comment|/* 		 * Make packets from buffered channel data, and buffer them 		 * for sending to the server. 		 */
if|if
condition|(
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
name|channel_output_poll
argument_list|()
expr_stmt|;
comment|/* 		 * Check if the window size has changed, and buffer a message 		 * about it to the server if so. 		 */
name|client_check_window_change
argument_list|()
expr_stmt|;
if|if
condition|(
name|quit_pending
condition|)
break|break;
comment|/* 		 * Wait until we have something to do (something becomes 		 * available on one of the descriptors). 		 */
name|client_wait_until_can_do_something
argument_list|(
operator|&
name|readset
argument_list|,
operator|&
name|writeset
argument_list|)
expr_stmt|;
if|if
condition|(
name|quit_pending
condition|)
break|break;
comment|/* Do channel operations. */
name|channel_after_select
argument_list|(
operator|&
name|readset
argument_list|,
operator|&
name|writeset
argument_list|)
expr_stmt|;
comment|/* 		 * Process input from the connection and from stdin. Buffer 		 * any data that is available. 		 */
name|client_process_input
argument_list|(
operator|&
name|readset
argument_list|)
expr_stmt|;
comment|/* 		 * Process output to stdout and stderr.   Output to the 		 * connection is processed elsewhere (above). 		 */
name|client_process_output
argument_list|(
operator|&
name|writeset
argument_list|)
expr_stmt|;
comment|/* Send as much buffered packet data as possible to the sender. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_out
argument_list|,
operator|&
name|writeset
argument_list|)
condition|)
name|packet_write_poll
argument_list|()
expr_stmt|;
block|}
comment|/* Terminate the session. */
comment|/* Stop watching for window change. */
if|if
condition|(
name|have_pty
condition|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* Stop listening for connections. */
name|channel_stop_listening
argument_list|()
expr_stmt|;
comment|/* 	 * In interactive mode (with pseudo tty) display a message indicating 	 * that the connection has been closed. 	 */
if|if
condition|(
name|have_pty
operator|&&
name|options
operator|.
name|log_level
operator|!=
name|SYSLOG_LEVEL_QUIET
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"Connection to %.64s closed.\r\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Output any buffered data for stdout. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Write failed flushing stdout buffer."
argument_list|)
expr_stmt|;
break|break;
block|}
name|buffer_consume
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Output any buffered data for stderr. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Write failed flushing stderr buffer."
argument_list|)
expr_stmt|;
break|break;
block|}
name|buffer_consume
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|have_pty
condition|)
name|leave_raw_mode
argument_list|()
expr_stmt|;
comment|/* Clear and free any buffers. */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
comment|/* Report bytes transferred, and transfer rates. */
name|total_time
operator|=
name|get_current_time
argument_list|()
operator|-
name|start_time
expr_stmt|;
name|debug
argument_list|(
literal|"Transferred: stdin %lu, stdout %lu, stderr %lu bytes in %.1f seconds"
argument_list|,
name|stdin_bytes
argument_list|,
name|stdout_bytes
argument_list|,
name|stderr_bytes
argument_list|,
name|total_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_time
operator|>
literal|0
condition|)
name|debug
argument_list|(
literal|"Bytes per second: stdin %.1f, stdout %.1f, stderr %.1f"
argument_list|,
name|stdin_bytes
operator|/
name|total_time
argument_list|,
name|stdout_bytes
operator|/
name|total_time
argument_list|,
name|stderr_bytes
operator|/
name|total_time
argument_list|)
expr_stmt|;
comment|/* Return the exit status of the program. */
name|debug
argument_list|(
literal|"Exit status %d"
argument_list|,
name|exit_status
argument_list|)
expr_stmt|;
return|return
name|exit_status
return|;
block|}
end_function

end_unit

