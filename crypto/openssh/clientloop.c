begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  * The main loop for the interactive session (client side).  *  * As far as I am concerned, the code I have written for this software  * can be used freely for any purpose.  Any derived versions of this  * software must be clearly marked as such, and if the derived work is  * incompatible with the protocol description in the RFC file, it must be  * called by a name other than "ssh" or "Secure Shell".  *  *  * Copyright (c) 1999 Theo de Raadt.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * SSH2 support added by Markus Friedl.  * Copyright (c) 1999, 2000, 2001 Markus Friedl.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$OpenBSD: clientloop.c,v 1.130 2004/08/11 21:43:04 avsm Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"ssh1.h"
end_include

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|"channels.h"
end_include

begin_include
include|#
directive|include
file|"dispatch.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"bufaux.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"kex.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"readconf.h"
end_include

begin_include
include|#
directive|include
file|"clientloop.h"
end_include

begin_include
include|#
directive|include
file|"authfd.h"
end_include

begin_include
include|#
directive|include
file|"atomicio.h"
end_include

begin_include
include|#
directive|include
file|"sshpty.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"monitor_fdpass.h"
end_include

begin_include
include|#
directive|include
file|"match.h"
end_include

begin_include
include|#
directive|include
file|"msg.h"
end_include

begin_comment
comment|/* import options */
end_comment

begin_decl_stmt
specifier|extern
name|Options
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating that stdin should be redirected from /dev/null. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stdin_null_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating that no shell has been requested */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|no_shell_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Control socket */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|control_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Name of the host we are connecting to.  This is the name given on the  * command line, or the HostName specified for the user-supplied name in a  * configuration file.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|host
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flag to indicate that we have received a window change signal which has  * not yet been processed.  This will cause a message indicating the new  * window size to be sent to the server a little later.  This is volatile  * because this is updated in a signal handler.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|received_window_change_signal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|received_signal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating whether the user\'s terminal is in non-blocking mode. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_non_blocking_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Common data for the client loop code. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|quit_pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to non-zero to quit the client loop. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|escape_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Escape character. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|escape_pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last character was the escape character */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_was_cr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last character was a newline. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exit_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to store the exit status of the command. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdin_eof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF has been encountered on standard error. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stdin_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stdin data. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stdout_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stdout data. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stderr_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stderr data. */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|stdin_bytes
decl_stmt|,
name|stdout_bytes
decl_stmt|,
name|stderr_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|buffer_high
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Soft max buffer size. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|connection_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to server (input). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|connection_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to server (output). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|need_rekeying
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to non-zero if rekeying is requested. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|session_closed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In SSH2: login session closed. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|server_alive_timeouts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|client_init_dispatch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|session_ident
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|confirm_ctx
block|{
name|int
name|want_tty
decl_stmt|;
name|int
name|want_subsys
decl_stmt|;
name|Buffer
name|cmd
decl_stmt|;
name|char
modifier|*
name|term
decl_stmt|;
name|struct
name|termios
name|tio
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*XXX*/
end_comment

begin_decl_stmt
specifier|extern
name|Kex
modifier|*
name|xxx_kex
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ssh_process_session2_setup
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Restores stdin to blocking mode. */
end_comment

begin_function
specifier|static
name|void
name|leave_non_blocking
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|in_non_blocking_mode
condition|)
block|{
name|unset_nonblock
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|in_non_blocking_mode
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Puts stdin terminal in non-blocking mode. */
end_comment

begin_function
specifier|static
name|void
name|enter_non_blocking
parameter_list|(
name|void
parameter_list|)
block|{
name|in_non_blocking_mode
operator|=
literal|1
expr_stmt|;
name|set_nonblock
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Signal handler for the window change signal (SIGWINCH).  This just sets a  * flag indicating that the window has changed.  */
end_comment

begin_function
specifier|static
name|void
name|window_change_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|received_window_change_signal
operator|=
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|window_change_handler
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Signal handler for signals that cause the program to terminate.  These  * signals must be trapped to restore terminal modes.  */
end_comment

begin_function
specifier|static
name|void
name|signal_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|received_signal
operator|=
name|sig
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns current time in seconds from Jan 1, 1970 with the maximum  * available resolution.  */
end_comment

begin_function
specifier|static
name|double
name|get_current_time
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|double
operator|)
name|tv
operator|.
name|tv_sec
operator|+
operator|(
name|double
operator|)
name|tv
operator|.
name|tv_usec
operator|/
literal|1000000.0
return|;
block|}
end_function

begin_comment
comment|/*  * This is called when the interactive is entered.  This checks if there is  * an EOF coming on stdin.  We must check this explicitly, as select() does  * not appear to wake up when redirecting from /dev/null.  */
end_comment

begin_function
specifier|static
name|void
name|client_check_initial_eof_on_stdin
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
comment|/* 	 * If standard input is to be "redirected from /dev/null", we simply 	 * mark that we have seen an EOF and send an EOF message to the 	 * server. Otherwise, we try to read a single character; it appears 	 * that for some files, such /dev/null, select() never wakes up for 	 * read for this descriptor, which means that we never get EOF.  This 	 * way we will get the EOF if stdin comes from /dev/null or similar. 	 */
if|if
condition|(
name|stdin_null_flag
condition|)
block|{
comment|/* Fake EOF on stdin. */
name|debug
argument_list|(
literal|"Sending eof."
argument_list|)
expr_stmt|;
name|stdin_eof
operator|=
literal|1
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|enter_non_blocking
argument_list|()
expr_stmt|;
comment|/* Check for immediate EOF on stdin. */
name|len
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* EOF.  Record that we have seen it and send EOF to server. */
name|debug
argument_list|(
literal|"Sending eof."
argument_list|)
expr_stmt|;
name|stdin_eof
operator|=
literal|1
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Got data.  We must store the data in the buffer, 			 * and also process it as an escape character if 			 * appropriate. 			 */
if|if
condition|(
operator|(
name|u_char
operator|)
name|buf
index|[
literal|0
index|]
operator|==
name|escape_char
condition|)
name|escape_pending
operator|=
literal|1
expr_stmt|;
else|else
name|buffer_append
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|leave_non_blocking
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Make packets from buffered stdin data, and buffer them for sending to the  * connection.  */
end_comment

begin_function
specifier|static
name|void
name|client_make_packets_from_stdin_data
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|len
decl_stmt|;
comment|/* Send buffered stdin data to the server. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|>
literal|0
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
block|{
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
comment|/* Keep the packets at reasonable size. */
if|if
condition|(
name|len
operator|>
name|packet_get_maxsize
argument_list|()
condition|)
name|len
operator|=
name|packet_get_maxsize
argument_list|()
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_CMSG_STDIN_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stdin_bytes
operator|+=
name|len
expr_stmt|;
comment|/* If we have a pending EOF, send it now. */
if|if
condition|(
name|stdin_eof
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Checks if the client window has changed, and sends a packet about it to  * the server if so.  The actual change is detected elsewhere (by a software  * interrupt on Unix); this just checks the flag and sends a message if  * appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|client_check_window_change
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
if|if
condition|(
operator|!
name|received_window_change_signal
condition|)
return|return;
comment|/** XXX race */
name|received_window_change_signal
operator|=
literal|0
expr_stmt|;
name|debug2
argument_list|(
literal|"client_check_window_change: changed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|channel_send_window_changes
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|packet_start
argument_list|(
name|SSH_CMSG_WINDOW_SIZE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_row
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_col
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_xpixel
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_ypixel
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|client_global_request_reply
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|server_alive_timeouts
operator|=
literal|0
expr_stmt|;
name|client_global_request_reply_fwd
argument_list|(
name|type
argument_list|,
name|seq
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_alive_check
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|++
name|server_alive_timeouts
operator|>
name|options
operator|.
name|server_alive_count_max
condition|)
name|packet_disconnect
argument_list|(
literal|"Timeout, server not responding."
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_GLOBAL_REQUEST
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"keepalive@openssh.com"
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* boolean: want reply */
name|packet_send
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Waits until the client can do something (some data becomes available on  * one of the file descriptors).  */
end_comment

begin_function
specifier|static
name|void
name|client_wait_until_can_do_something
parameter_list|(
name|fd_set
modifier|*
modifier|*
name|readsetp
parameter_list|,
name|fd_set
modifier|*
modifier|*
name|writesetp
parameter_list|,
name|int
modifier|*
name|maxfdp
parameter_list|,
name|u_int
modifier|*
name|nallocp
parameter_list|,
name|int
name|rekeying
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Add any selections by the channel mechanism. */
name|channel_prepare_select
argument_list|(
name|readsetp
argument_list|,
name|writesetp
argument_list|,
name|maxfdp
argument_list|,
name|nallocp
argument_list|,
name|rekeying
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compat20
condition|)
block|{
comment|/* Read from the connection, unless our buffers are full. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|<
name|buffer_high
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|<
name|buffer_high
operator|&&
name|channel_not_very_much_buffered_data
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_in
argument_list|,
operator|*
name|readsetp
argument_list|)
expr_stmt|;
comment|/* 		 * Read from stdin, unless we have seen EOF or have very much 		 * buffered data to send to the server. 		 */
if|if
condition|(
operator|!
name|stdin_eof
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|*
name|readsetp
argument_list|)
expr_stmt|;
comment|/* Select stdout/stderr if have data in buffer. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
operator|*
name|writesetp
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
operator|*
name|writesetp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* channel_prepare_select could have closed the last channel */
if|if
condition|(
name|session_closed
operator|&&
operator|!
name|channel_still_open
argument_list|()
operator|&&
operator|!
name|packet_have_data_to_write
argument_list|()
condition|)
block|{
comment|/* clear mask since we did not call select() */
name|memset
argument_list|(
operator|*
name|readsetp
argument_list|,
literal|0
argument_list|,
operator|*
name|nallocp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|writesetp
argument_list|,
literal|0
argument_list|,
operator|*
name|nallocp
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|FD_SET
argument_list|(
name|connection_in
argument_list|,
operator|*
name|readsetp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Select server connection if have data to write to the server. */
if|if
condition|(
name|packet_have_data_to_write
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_out
argument_list|,
operator|*
name|writesetp
argument_list|)
expr_stmt|;
if|if
condition|(
name|control_fd
operator|!=
operator|-
literal|1
condition|)
name|FD_SET
argument_list|(
name|control_fd
argument_list|,
operator|*
name|readsetp
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for something to happen.  This will suspend the process until 	 * some selected descriptor can be read, written, or has some other 	 * event pending. 	 */
if|if
condition|(
name|options
operator|.
name|server_alive_interval
operator|==
literal|0
operator|||
operator|!
name|compat20
condition|)
name|tvp
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|options
operator|.
name|server_alive_interval
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tvp
operator|=
operator|&
name|tv
expr_stmt|;
block|}
name|ret
operator|=
name|select
argument_list|(
operator|(
operator|*
name|maxfdp
operator|)
operator|+
literal|1
argument_list|,
operator|*
name|readsetp
argument_list|,
operator|*
name|writesetp
argument_list|,
name|NULL
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* 		 * We have to clear the select masks, because we return. 		 * We have to return, because the mainloop checks for the flags 		 * set by the signal handlers. 		 */
name|memset
argument_list|(
operator|*
name|readsetp
argument_list|,
literal|0
argument_list|,
operator|*
name|nallocp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|writesetp
argument_list|,
literal|0
argument_list|,
operator|*
name|nallocp
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
return|return;
comment|/* Note: we might still have data in the buffers. */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"select: %s\r\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|server_alive_check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_suspend_self
parameter_list|(
name|Buffer
modifier|*
name|bin
parameter_list|,
name|Buffer
modifier|*
name|bout
parameter_list|,
name|Buffer
modifier|*
name|berr
parameter_list|)
block|{
name|struct
name|winsize
name|oldws
decl_stmt|,
name|newws
decl_stmt|;
comment|/* Flush stdout and stderr buffers. */
if|if
condition|(
name|buffer_len
argument_list|(
name|bout
argument_list|)
operator|>
literal|0
condition|)
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
name|bout
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
name|bout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
name|berr
argument_list|)
operator|>
literal|0
condition|)
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
name|berr
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
name|berr
argument_list|)
argument_list|)
expr_stmt|;
name|leave_raw_mode
argument_list|()
expr_stmt|;
comment|/* 	 * Free (and clear) the buffer to reduce the amount of data that gets 	 * written to swap. 	 */
name|buffer_free
argument_list|(
name|bin
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
name|bout
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
name|berr
argument_list|)
expr_stmt|;
comment|/* Save old window size. */
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|oldws
argument_list|)
expr_stmt|;
comment|/* Send the suspend signal to the program itself. */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* Check if the window size has changed. */
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|newws
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|oldws
operator|.
name|ws_row
operator|!=
name|newws
operator|.
name|ws_row
operator|||
name|oldws
operator|.
name|ws_col
operator|!=
name|newws
operator|.
name|ws_col
operator|||
name|oldws
operator|.
name|ws_xpixel
operator|!=
name|newws
operator|.
name|ws_xpixel
operator|||
name|oldws
operator|.
name|ws_ypixel
operator|!=
name|newws
operator|.
name|ws_ypixel
operator|)
condition|)
name|received_window_change_signal
operator|=
literal|1
expr_stmt|;
comment|/* OK, we have been continued by the user. Reinitialize buffers. */
name|buffer_init
argument_list|(
name|bin
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
name|bout
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
name|berr
argument_list|)
expr_stmt|;
name|enter_raw_mode
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_process_net_input
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
comment|/* 	 * Read input from the server, and add any such data to the buffer of 	 * the packet subsystem. 	 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_in
argument_list|,
name|readset
argument_list|)
condition|)
block|{
comment|/* Read as much as possible. */
name|len
operator|=
name|read
argument_list|(
name|connection_in
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* Received EOF.  The remote host has closed the connection. */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"Connection to %.300s closed by remote host.\r\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 		 * There is a kernel bug on Solaris that causes select to 		 * sometimes wake up even though there is no data available. 		 */
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EINTR
operator|)
condition|)
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
comment|/* An error has encountered.  Perhaps there is a network problem. */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"Read from remote host %.300s: %.100s\r\n"
argument_list|,
name|host
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|packet_process_incoming
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|client_subsystem_reply
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: no channel for id %d"
argument_list|,
name|__func__
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|type
operator|==
name|SSH2_MSG_CHANNEL_SUCCESS
condition|)
name|debug2
argument_list|(
literal|"Request suceeded on channel %d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|SSH2_MSG_CHANNEL_FAILURE
condition|)
block|{
name|error
argument_list|(
literal|"Request failed on channel %d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|client_extra_session2_setup
parameter_list|(
name|int
name|id
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|confirm_ctx
modifier|*
name|cctx
init|=
name|arg
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cctx
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: cctx == NULL"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: no channel for id %d"
argument_list|,
name|__func__
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|client_session2_setup
argument_list|(
name|id
argument_list|,
name|cctx
operator|->
name|want_tty
argument_list|,
name|cctx
operator|->
name|want_subsys
argument_list|,
name|cctx
operator|->
name|term
argument_list|,
operator|&
name|cctx
operator|->
name|tio
argument_list|,
name|c
operator|->
name|rfd
argument_list|,
operator|&
name|cctx
operator|->
name|cmd
argument_list|,
name|cctx
operator|->
name|env
argument_list|,
name|client_subsystem_reply
argument_list|)
expr_stmt|;
name|c
operator|->
name|confirm_ctx
operator|=
name|NULL
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|cctx
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|cctx
operator|->
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|cctx
operator|->
name|env
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cctx
operator|->
name|env
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|xfree
argument_list|(
name|cctx
operator|->
name|env
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|cctx
operator|->
name|env
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|cctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_process_control
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|)
block|{
name|Buffer
name|m
decl_stmt|;
name|Channel
modifier|*
name|c
decl_stmt|;
name|int
name|client_fd
decl_stmt|,
name|new_fd
index|[
literal|3
index|]
decl_stmt|,
name|ver
decl_stmt|,
name|i
decl_stmt|,
name|allowed
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|struct
name|confirm_ctx
modifier|*
name|cctx
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|u_int
name|len
decl_stmt|,
name|env_len
decl_stmt|;
name|uid_t
name|euid
decl_stmt|;
name|gid_t
name|egid
decl_stmt|;
comment|/* 	 * Accept connection on control socket 	 */
if|if
condition|(
name|control_fd
operator|==
operator|-
literal|1
operator|||
operator|!
name|FD_ISSET
argument_list|(
name|control_fd
argument_list|,
name|readset
argument_list|)
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|client_fd
operator|=
name|accept
argument_list|(
name|control_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s accept: %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|getpeereid
argument_list|(
name|client_fd
argument_list|,
operator|&
name|euid
argument_list|,
operator|&
name|egid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s getpeereid failed: %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|client_fd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|euid
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|getuid
argument_list|()
operator|!=
name|euid
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"control mode uid mismatch: peer euid %u != uid %u"
argument_list|,
operator|(
name|u_int
operator|)
name|euid
argument_list|,
operator|(
name|u_int
operator|)
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|client_fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|allowed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|control_master
operator|==
literal|2
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
name|prompt
index|[
literal|1024
index|]
decl_stmt|;
name|allowed
operator|=
literal|0
expr_stmt|;
name|snprintf
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
argument_list|(
name|prompt
argument_list|)
argument_list|,
literal|"Allow shared connection to %s? "
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|p
operator|=
name|read_passphrase
argument_list|(
name|prompt
argument_list|,
name|RP_USE_ASKPASS
operator||
name|RP_ALLOW_EOF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Accept empty responses and responses consisting 			 * of the word "yes" as affirmative. 			 */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
name|strcasecmp
argument_list|(
name|p
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
condition|)
name|allowed
operator|=
literal|1
expr_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|unset_nonblock
argument_list|(
name|client_fd
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
operator|&
name|m
argument_list|,
name|allowed
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
operator|&
name|m
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssh_msg_send
argument_list|(
name|client_fd
argument_list|,
comment|/* version */
literal|0
argument_list|,
operator|&
name|m
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: client msg_send failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|client_fd
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|buffer_clear
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowed
condition|)
block|{
name|error
argument_list|(
literal|"Refused control connection"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|client_fd
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ssh_msg_recv
argument_list|(
name|client_fd
argument_list|,
operator|&
name|m
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: client msg_recv failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|client_fd
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ver
operator|=
name|buffer_get_char
argument_list|(
operator|&
name|m
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: wrong client version %d"
argument_list|,
name|__func__
argument_list|,
name|ver
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|client_fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|cctx
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cctx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cctx
argument_list|)
argument_list|)
expr_stmt|;
name|cctx
operator|->
name|want_tty
operator|=
name|buffer_get_int
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|cctx
operator|->
name|want_subsys
operator|=
name|buffer_get_int
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|cctx
operator|->
name|term
operator|=
name|buffer_get_string
argument_list|(
operator|&
name|m
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|buffer_get_string
argument_list|(
operator|&
name|m
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|cctx
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|cctx
operator|->
name|cmd
argument_list|,
name|cmd
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|env_len
operator|=
name|buffer_get_int
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|env_len
operator|=
name|MIN
argument_list|(
name|env_len
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: receiving %d env vars"
argument_list|,
name|__func__
argument_list|,
name|env_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_len
operator|!=
literal|0
condition|)
block|{
name|cctx
operator|->
name|env
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cctx
operator|->
name|env
argument_list|)
operator|*
operator|(
name|env_len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env_len
condition|;
name|i
operator|++
control|)
name|cctx
operator|->
name|env
index|[
name|i
index|]
operator|=
name|buffer_get_string
argument_list|(
operator|&
name|m
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|cctx
operator|->
name|env
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|debug2
argument_list|(
literal|"%s: accepted tty %d, subsys %d, cmd %s"
argument_list|,
name|__func__
argument_list|,
name|cctx
operator|->
name|want_tty
argument_list|,
name|cctx
operator|->
name|want_subsys
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* Gather fds from client */
name|new_fd
index|[
literal|0
index|]
operator|=
name|mm_receive_fd
argument_list|(
name|client_fd
argument_list|)
expr_stmt|;
name|new_fd
index|[
literal|1
index|]
operator|=
name|mm_receive_fd
argument_list|(
name|client_fd
argument_list|)
expr_stmt|;
name|new_fd
index|[
literal|2
index|]
operator|=
name|mm_receive_fd
argument_list|(
name|client_fd
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"%s: got fds stdin %d, stdout %d, stderr %d"
argument_list|,
name|__func__
argument_list|,
name|new_fd
index|[
literal|0
index|]
argument_list|,
name|new_fd
index|[
literal|1
index|]
argument_list|,
name|new_fd
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Try to pick up ttymodes from client before it goes raw */
if|if
condition|(
name|cctx
operator|->
name|want_tty
operator|&&
name|tcgetattr
argument_list|(
name|new_fd
index|[
literal|0
index|]
argument_list|,
operator|&
name|cctx
operator|->
name|tio
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"%s: tcgetattr: %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssh_msg_send
argument_list|(
name|client_fd
argument_list|,
comment|/* version */
literal|0
argument_list|,
operator|&
name|m
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: client msg_send failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|client_fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|new_fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|new_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|new_fd
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|buffer_free
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
comment|/* enable nonblocking unless tty */
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|new_fd
index|[
literal|0
index|]
argument_list|)
condition|)
name|set_nonblock
argument_list|(
name|new_fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|new_fd
index|[
literal|1
index|]
argument_list|)
condition|)
name|set_nonblock
argument_list|(
name|new_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|new_fd
index|[
literal|2
index|]
argument_list|)
condition|)
name|set_nonblock
argument_list|(
name|new_fd
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
name|client_fd
argument_list|)
expr_stmt|;
name|c
operator|=
name|channel_new
argument_list|(
literal|"session"
argument_list|,
name|SSH_CHANNEL_OPENING
argument_list|,
name|new_fd
index|[
literal|0
index|]
argument_list|,
name|new_fd
index|[
literal|1
index|]
argument_list|,
name|new_fd
index|[
literal|2
index|]
argument_list|,
name|CHAN_SES_WINDOW_DEFAULT
argument_list|,
name|CHAN_SES_PACKET_DEFAULT
argument_list|,
name|CHAN_EXTENDED_WRITE
argument_list|,
literal|"client-session"
argument_list|,
comment|/*nonblock*/
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
name|c
operator|->
name|ctl_fd
operator|=
name|client_fd
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: channel_new: %d"
argument_list|,
name|__func__
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|channel_send_open
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|channel_register_confirm
argument_list|(
name|c
operator|->
name|self
argument_list|,
name|client_extra_session2_setup
argument_list|,
name|cctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_cmdline
parameter_list|(
name|void
parameter_list|)
block|{
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|cmd
decl_stmt|;
name|u_short
name|fwd_port
decl_stmt|,
name|fwd_host_port
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
name|sfwd_port
index|[
literal|6
index|]
decl_stmt|,
name|sfwd_host_port
index|[
literal|6
index|]
decl_stmt|;
name|int
name|delete
init|=
literal|0
decl_stmt|;
name|int
name|local
init|=
literal|0
decl_stmt|;
name|leave_raw_mode
argument_list|()
expr_stmt|;
name|handler
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|s
operator|=
name|read_passphrase
argument_list|(
literal|"\r\nssh> "
argument_list|,
name|RP_ECHO
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
while|while
condition|(
operator|*
name|s
operator|&&
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Skip cmdline '-', if any */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'h'
operator|||
operator|*
name|s
operator|==
literal|'H'
operator|||
operator|*
name|s
operator|==
literal|'?'
condition|)
block|{
name|logit
argument_list|(
literal|"Commands:"
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"      -Lport:host:hostport    Request local forward"
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"      -Rport:host:hostport    Request remote forward"
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"      -KRhostport             Cancel remote forward"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'K'
condition|)
block|{
name|delete
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|!=
literal|'L'
operator|&&
operator|*
name|s
operator|!=
literal|'R'
condition|)
block|{
name|logit
argument_list|(
literal|"Invalid command."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'L'
condition|)
name|local
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|local
operator|&&
name|delete
condition|)
block|{
name|logit
argument_list|(
literal|"Not supported."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
operator|!
name|local
operator|||
name|delete
operator|)
operator|&&
operator|!
name|compat20
condition|)
block|{
name|logit
argument_list|(
literal|"Not supported for SSH protocol version 1."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|delete
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|s
argument_list|,
literal|"%5[0-9]"
argument_list|,
name|sfwd_host_port
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|logit
argument_list|(
literal|"Bad forwarding specification."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|fwd_host_port
operator|=
name|a2port
argument_list|(
name|sfwd_host_port
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"Bad forwarding port(s)."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|channel_request_rforward_cancel
argument_list|(
name|fwd_host_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|s
argument_list|,
literal|"%5[0-9]:%255[^:]:%5[0-9]"
argument_list|,
name|sfwd_port
argument_list|,
name|buf
argument_list|,
name|sfwd_host_port
argument_list|)
operator|!=
literal|3
operator|&&
name|sscanf
argument_list|(
name|s
argument_list|,
literal|"%5[0-9]/%255[^/]/%5[0-9]"
argument_list|,
name|sfwd_port
argument_list|,
name|buf
argument_list|,
name|sfwd_host_port
argument_list|)
operator|!=
literal|3
condition|)
block|{
name|logit
argument_list|(
literal|"Bad forwarding specification."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|fwd_port
operator|=
name|a2port
argument_list|(
name|sfwd_port
argument_list|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|fwd_host_port
operator|=
name|a2port
argument_list|(
name|sfwd_host_port
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"Bad forwarding port(s)."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|local
condition|)
block|{
if|if
condition|(
name|channel_setup_local_fwd_listener
argument_list|(
name|fwd_port
argument_list|,
name|buf
argument_list|,
name|fwd_host_port
argument_list|,
name|options
operator|.
name|gateway_ports
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"Port forwarding failed."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
name|channel_request_remote_forwarding
argument_list|(
name|fwd_port
argument_list|,
name|buf
argument_list|,
name|fwd_host_port
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"Forwarding port."
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|enter_raw_mode
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmd
condition|)
name|xfree
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* process the characters one by one */
end_comment

begin_function
specifier|static
name|int
name|process_escapes
parameter_list|(
name|Buffer
modifier|*
name|bin
parameter_list|,
name|Buffer
modifier|*
name|bout
parameter_list|,
name|Buffer
modifier|*
name|berr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
name|string
index|[
literal|1024
index|]
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|bytes
init|=
literal|0
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_char
name|ch
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get one character at a time. */
name|ch
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|escape_pending
condition|)
block|{
comment|/* We have previously seen an escape character. */
comment|/* Clear the flag now. */
name|escape_pending
operator|=
literal|0
expr_stmt|;
comment|/* Process the escaped character. */
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'.'
case|:
comment|/* Terminate the connection. */
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c.\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|'Z'
operator|-
literal|64
case|:
comment|/* Suspend the program. */
comment|/* Print a message to that effect to the user. */
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c^Z [suspend ssh]\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore terminal modes and suspend. */
name|client_suspend_self
argument_list|(
name|bin
argument_list|,
name|bout
argument_list|,
name|berr
argument_list|)
expr_stmt|;
comment|/* We have been continued. */
continue|continue;
case|case
literal|'B'
case|:
if|if
condition|(
name|compat20
condition|)
block|{
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%cB\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|channel_request_start
argument_list|(
name|session_ident
argument_list|,
literal|"break"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
continue|continue;
case|case
literal|'R'
case|:
if|if
condition|(
name|compat20
condition|)
block|{
if|if
condition|(
name|datafellows
operator|&
name|SSH_BUG_NOREKEY
condition|)
name|logit
argument_list|(
literal|"Server does not support re-keying"
argument_list|)
expr_stmt|;
else|else
name|need_rekeying
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'&'
case|:
comment|/* 				 * Detach the program (continue to serve connections, 				 * but put in background and no more new connections). 				 */
comment|/* Restore tty modes. */
name|leave_raw_mode
argument_list|()
expr_stmt|;
comment|/* Stop listening for new connections. */
name|channel_stop_listening
argument_list|()
expr_stmt|;
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c& [backgrounded]\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fork into background. */
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"fork: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pid
operator|!=
literal|0
condition|)
block|{
comment|/* This is the parent. */
comment|/* The parent just exits. */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The child continues serving connections. */
if|if
condition|(
name|compat20
condition|)
block|{
name|buffer_append
argument_list|(
name|bin
argument_list|,
literal|"\004"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* fake EOF on stdin */
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|stdin_eof
condition|)
block|{
comment|/* 					 * Sending SSH_CMSG_EOF alone does not always appear 					 * to be enough.  So we try to send an EOF character 					 * first. 					 */
name|packet_start
argument_list|(
name|SSH_CMSG_STDIN_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
literal|"\004"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* Close stdin. */
name|stdin_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
name|bin
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
continue|continue;
case|case
literal|'?'
case|:
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c?\r\n\ Supported escape sequences:\r\n\ %c.  - terminate connection\r\n\ %cB  - send a BREAK to the remote system\r\n\ %cC  - open a command line\r\n\ %cR  - Request rekey (SSH protocol 2 only)\r\n\ %c^Z - suspend ssh\r\n\ %c#  - list forwarded connections\r\n\ %c&  - background ssh (when waiting for connections to terminate)\r\n\ %c?  - this message\r\n\ %c%c  - send the escape character by typing it twice\r\n\ (Note that escapes are only recognized immediately after newline.)\r\n"
argument_list|,
name|escape_char
argument_list|,
name|escape_char
argument_list|,
name|escape_char
argument_list|,
name|escape_char
argument_list|,
name|escape_char
argument_list|,
name|escape_char
argument_list|,
name|escape_char
argument_list|,
name|escape_char
argument_list|,
name|escape_char
argument_list|,
name|escape_char
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'#'
case|:
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c#\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|channel_open_message
argument_list|()
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'C'
case|:
name|process_cmdline
argument_list|()
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
name|ch
operator|!=
name|escape_char
condition|)
block|{
name|buffer_put_char
argument_list|(
name|bin
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
block|}
comment|/* Escaped characters fall through here */
break|break;
block|}
block|}
else|else
block|{
comment|/* 			 * The previous character was not an escape char. Check if this 			 * is an escape. 			 */
if|if
condition|(
name|last_was_cr
operator|&&
name|ch
operator|==
name|escape_char
condition|)
block|{
comment|/* It is. Set the flag and continue to next character. */
name|escape_pending
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Normal character.  Record whether it was a newline, 		 * and append it to the buffer. 		 */
name|last_was_cr
operator|=
operator|(
name|ch
operator|==
literal|'\r'
operator|||
name|ch
operator|==
literal|'\n'
operator|)
expr_stmt|;
name|buffer_put_char
argument_list|(
name|bin
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_process_input
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
comment|/* Read input from stdin. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|readset
argument_list|)
condition|)
block|{
comment|/* Read as much as possible. */
name|len
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EINTR
operator|)
condition|)
return|return;
comment|/* we'll try again later */
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
comment|/* 			 * Received EOF or error.  They are treated 			 * similarly, except that an error message is printed 			 * if it was an error condition. 			 */
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"read: %.100s\r\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Mark that we have seen EOF. */
name|stdin_eof
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Send an EOF message to the server unless there is 			 * data in the buffer.  If there is data in the 			 * buffer, no message will be sent now.  Code 			 * elsewhere will send the EOF when the buffer 			 * becomes empty if stdin_eof is set. 			 */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|escape_char
operator|==
name|SSH_ESCAPECHAR_NONE
condition|)
block|{
comment|/* 			 * Normal successful read, and no escape character. 			 * Just append the data to buffer. 			 */
name|buffer_append
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Normal, successful read.  But we have an escape character 			 * and have to process the characters one by one. 			 */
if|if
condition|(
name|process_escapes
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
operator|&
name|stdout_buffer
argument_list|,
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|client_process_output
parameter_list|(
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* Write buffered output to stdout. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|writeset
argument_list|)
condition|)
block|{
comment|/* Write as much data as possible. */
name|len
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
name|len
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 				 * An error or EOF was encountered.  Put an 				 * error message to stderr buffer. 				 */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"write stdout: %.50s\r\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
comment|/* Consume printed data from the buffer. */
name|buffer_consume
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stdout_bytes
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Write buffered output to stderr. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|writeset
argument_list|)
condition|)
block|{
comment|/* Write as much data as possible. */
name|len
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
name|len
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* EOF or error, but can't even print error message. */
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
comment|/* Consume printed characters from the buffer. */
name|buffer_consume
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get packets from the connection input buffer, and process them as long as  * there are packets available.  *  * Any unknown packets received during the actual  * session cause the session to terminate.  This is  * intended to make debugging easier since no  * confirmations are sent.  Any compatible protocol  * extensions must be negotiated during the  * preparatory phase.  */
end_comment

begin_function
specifier|static
name|void
name|client_process_buffered_input_packets
parameter_list|(
name|void
parameter_list|)
block|{
name|dispatch_run
argument_list|(
name|DISPATCH_NONBLOCK
argument_list|,
operator|&
name|quit_pending
argument_list|,
name|compat20
condition|?
name|xxx_kex
else|:
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* scan buf[] for '~' before sending data to the peer */
end_comment

begin_function
specifier|static
name|int
name|simple_escape_filter
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|/* XXX we assume c->extended is writeable */
return|return
name|process_escapes
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
operator|&
name|c
operator|->
name|output
argument_list|,
operator|&
name|c
operator|->
name|extended
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_channel_closed
parameter_list|(
name|int
name|id
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|channel_cancel_cleanup
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|session_closed
operator|=
literal|1
expr_stmt|;
name|leave_raw_mode
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Implements the interactive session with the server.  This is called after  * the user has been authenticated, and a command has been started on the  * remote host.  If escape_char != SSH_ESCAPECHAR_NONE, it is the character  * used as an escape character for terminating or suspending the session.  */
end_comment

begin_function
name|int
name|client_loop
parameter_list|(
name|int
name|have_pty
parameter_list|,
name|int
name|escape_char_arg
parameter_list|,
name|int
name|ssh2_chan_id
parameter_list|)
block|{
name|fd_set
modifier|*
name|readset
init|=
name|NULL
decl_stmt|,
modifier|*
name|writeset
init|=
name|NULL
decl_stmt|;
name|double
name|start_time
decl_stmt|,
name|total_time
decl_stmt|;
name|int
name|max_fd
init|=
literal|0
decl_stmt|,
name|max_fd2
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|,
name|rekeying
init|=
literal|0
decl_stmt|;
name|u_int
name|nalloc
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|debug
argument_list|(
literal|"Entering interactive session."
argument_list|)
expr_stmt|;
name|start_time
operator|=
name|get_current_time
argument_list|()
expr_stmt|;
comment|/* Initialize variables. */
name|escape_pending
operator|=
literal|0
expr_stmt|;
name|last_was_cr
operator|=
literal|1
expr_stmt|;
name|exit_status
operator|=
operator|-
literal|1
expr_stmt|;
name|stdin_eof
operator|=
literal|0
expr_stmt|;
name|buffer_high
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
name|connection_in
operator|=
name|packet_get_connection_in
argument_list|()
expr_stmt|;
name|connection_out
operator|=
name|packet_get_connection_out
argument_list|()
expr_stmt|;
name|max_fd
operator|=
name|MAX
argument_list|(
name|connection_in
argument_list|,
name|connection_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|control_fd
operator|!=
operator|-
literal|1
condition|)
name|max_fd
operator|=
name|MAX
argument_list|(
name|max_fd
argument_list|,
name|control_fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compat20
condition|)
block|{
comment|/* enable nonblocking unless tty */
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|set_nonblock
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
condition|)
name|set_nonblock
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
condition|)
name|set_nonblock
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
expr_stmt|;
name|max_fd
operator|=
name|MAX
argument_list|(
name|max_fd
argument_list|,
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|max_fd
operator|=
name|MAX
argument_list|(
name|max_fd
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|max_fd
operator|=
name|MAX
argument_list|(
name|max_fd
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stdin_bytes
operator|=
literal|0
expr_stmt|;
name|stdout_bytes
operator|=
literal|0
expr_stmt|;
name|stderr_bytes
operator|=
literal|0
expr_stmt|;
name|quit_pending
operator|=
literal|0
expr_stmt|;
name|escape_char
operator|=
name|escape_char_arg
expr_stmt|;
comment|/* Initialize buffers. */
name|buffer_init
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
name|client_init_dispatch
argument_list|()
expr_stmt|;
comment|/* 	 * Set signal handlers, (e.g. to restore non-blocking mode) 	 * but don't overwrite SIG_IGN, matches behaviour from rsh(1) 	 */
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_pty
condition|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|window_change_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_pty
condition|)
name|enter_raw_mode
argument_list|()
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|session_ident
operator|=
name|ssh2_chan_id
expr_stmt|;
if|if
condition|(
name|escape_char
operator|!=
name|SSH_ESCAPECHAR_NONE
condition|)
name|channel_register_filter
argument_list|(
name|session_ident
argument_list|,
name|simple_escape_filter
argument_list|)
expr_stmt|;
if|if
condition|(
name|session_ident
operator|!=
operator|-
literal|1
condition|)
name|channel_register_cleanup
argument_list|(
name|session_ident
argument_list|,
name|client_channel_closed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check if we should immediately send eof on stdin. */
name|client_check_initial_eof_on_stdin
argument_list|()
expr_stmt|;
block|}
comment|/* Main loop of the client for the interactive session mode. */
while|while
condition|(
operator|!
name|quit_pending
condition|)
block|{
comment|/* Process buffered packets sent by the server. */
name|client_process_buffered_input_packets
argument_list|()
expr_stmt|;
if|if
condition|(
name|compat20
operator|&&
name|session_closed
operator|&&
operator|!
name|channel_still_open
argument_list|()
condition|)
break|break;
name|rekeying
operator|=
operator|(
name|xxx_kex
operator|!=
name|NULL
operator|&&
operator|!
name|xxx_kex
operator|->
name|done
operator|)
expr_stmt|;
if|if
condition|(
name|rekeying
condition|)
block|{
name|debug
argument_list|(
literal|"rekeying in progress"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Make packets of buffered stdin data, and buffer 			 * them for sending to the server. 			 */
if|if
condition|(
operator|!
name|compat20
condition|)
name|client_make_packets_from_stdin_data
argument_list|()
expr_stmt|;
comment|/* 			 * Make packets from buffered channel data, and 			 * enqueue them for sending to the server. 			 */
if|if
condition|(
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
name|channel_output_poll
argument_list|()
expr_stmt|;
comment|/* 			 * Check if the window size has changed, and buffer a 			 * message about it to the server if so. 			 */
name|client_check_window_change
argument_list|()
expr_stmt|;
if|if
condition|(
name|quit_pending
condition|)
break|break;
block|}
comment|/* 		 * Wait until we have something to do (something becomes 		 * available on one of the descriptors). 		 */
name|max_fd2
operator|=
name|max_fd
expr_stmt|;
name|client_wait_until_can_do_something
argument_list|(
operator|&
name|readset
argument_list|,
operator|&
name|writeset
argument_list|,
operator|&
name|max_fd2
argument_list|,
operator|&
name|nalloc
argument_list|,
name|rekeying
argument_list|)
expr_stmt|;
if|if
condition|(
name|quit_pending
condition|)
break|break;
comment|/* Do channel operations unless rekeying in progress. */
if|if
condition|(
operator|!
name|rekeying
condition|)
block|{
name|channel_after_select
argument_list|(
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_rekeying
operator|||
name|packet_need_rekeying
argument_list|()
condition|)
block|{
name|debug
argument_list|(
literal|"need rekeying"
argument_list|)
expr_stmt|;
name|xxx_kex
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|kex_send_kexinit
argument_list|(
name|xxx_kex
argument_list|)
expr_stmt|;
name|need_rekeying
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Buffer input from the connection.  */
name|client_process_net_input
argument_list|(
name|readset
argument_list|)
expr_stmt|;
comment|/* Accept control connections.  */
name|client_process_control
argument_list|(
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
name|quit_pending
condition|)
break|break;
if|if
condition|(
operator|!
name|compat20
condition|)
block|{
comment|/* Buffer data from stdin */
name|client_process_input
argument_list|(
name|readset
argument_list|)
expr_stmt|;
comment|/* 			 * Process output to stdout and stderr.  Output to 			 * the connection is processed elsewhere (above). 			 */
name|client_process_output
argument_list|(
name|writeset
argument_list|)
expr_stmt|;
block|}
comment|/* Send as much buffered packet data as possible to the sender. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_out
argument_list|,
name|writeset
argument_list|)
condition|)
name|packet_write_poll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|readset
condition|)
name|xfree
argument_list|(
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeset
condition|)
name|xfree
argument_list|(
name|writeset
argument_list|)
expr_stmt|;
comment|/* Terminate the session. */
comment|/* Stop watching for window change. */
if|if
condition|(
name|have_pty
condition|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|channel_free_all
argument_list|()
expr_stmt|;
if|if
condition|(
name|have_pty
condition|)
name|leave_raw_mode
argument_list|()
expr_stmt|;
comment|/* restore blocking io */
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|unset_nonblock
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
condition|)
name|unset_nonblock
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
condition|)
name|unset_nonblock
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If there was no shell or command requested, there will be no remote 	 * exit status to be returned.  In that case, clear error code if the 	 * connection was deliberately terminated at this end. 	 */
if|if
condition|(
name|no_shell_flag
operator|&&
name|received_signal
operator|==
name|SIGTERM
condition|)
block|{
name|received_signal
operator|=
literal|0
expr_stmt|;
name|exit_status
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|received_signal
condition|)
name|fatal
argument_list|(
literal|"Killed by signal %d."
argument_list|,
operator|(
name|int
operator|)
name|received_signal
argument_list|)
expr_stmt|;
comment|/* 	 * In interactive mode (with pseudo tty) display a message indicating 	 * that the connection has been closed. 	 */
if|if
condition|(
name|have_pty
operator|&&
name|options
operator|.
name|log_level
operator|!=
name|SYSLOG_LEVEL_QUIET
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"Connection to %.64s closed.\r\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Output any buffered data for stdout. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Write failed flushing stdout buffer."
argument_list|)
expr_stmt|;
break|break;
block|}
name|buffer_consume
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stdout_bytes
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Output any buffered data for stderr. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Write failed flushing stderr buffer."
argument_list|)
expr_stmt|;
break|break;
block|}
name|buffer_consume
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Clear and free any buffers. */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
comment|/* Report bytes transferred, and transfer rates. */
name|total_time
operator|=
name|get_current_time
argument_list|()
operator|-
name|start_time
expr_stmt|;
name|debug
argument_list|(
literal|"Transferred: stdin %lu, stdout %lu, stderr %lu bytes in %.1f seconds"
argument_list|,
name|stdin_bytes
argument_list|,
name|stdout_bytes
argument_list|,
name|stderr_bytes
argument_list|,
name|total_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_time
operator|>
literal|0
condition|)
name|debug
argument_list|(
literal|"Bytes per second: stdin %.1f, stdout %.1f, stderr %.1f"
argument_list|,
name|stdin_bytes
operator|/
name|total_time
argument_list|,
name|stdout_bytes
operator|/
name|total_time
argument_list|,
name|stderr_bytes
operator|/
name|total_time
argument_list|)
expr_stmt|;
comment|/* Return the exit status of the program. */
name|debug
argument_list|(
literal|"Exit status %d"
argument_list|,
name|exit_status
argument_list|)
expr_stmt|;
return|return
name|exit_status
return|;
block|}
end_function

begin_comment
comment|/*********/
end_comment

begin_function
specifier|static
name|void
name|client_input_stdout_data
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|u_int
name|data_len
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
decl_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_input_stderr_data
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|u_int
name|data_len
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
decl_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_input_exit_status
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|exit_status
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
comment|/* Acknowledge the exit. */
name|packet_start
argument_list|(
name|SSH_CMSG_EXIT_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* 	 * Must wait for packet to be sent since we are 	 * exiting the loop. 	 */
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Flag that we want to exit. */
name|quit_pending
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_input_agent_open
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|int
name|remote_id
decl_stmt|,
name|sock
decl_stmt|;
comment|/* Read the remote channel number from the message. */
name|remote_id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
comment|/* 	 * Get a connection to the local authentication agent (this may again 	 * get forwarded). 	 */
name|sock
operator|=
name|ssh_get_authentication_socket
argument_list|()
expr_stmt|;
comment|/* 	 * If we could not connect the agent, send an error message back to 	 * the server. This should never happen unless the agent dies, 	 * because authentication forwarding is only enabled if we have an 	 * agent. 	 */
if|if
condition|(
name|sock
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|channel_new
argument_list|(
literal|""
argument_list|,
name|SSH_CHANNEL_OPEN
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"authentication agent connection"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
name|remote_id
expr_stmt|;
name|c
operator|->
name|force_drain
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Send a confirmation to the remote host. */
name|debug
argument_list|(
literal|"Forwarding authentication connection."
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Channel
modifier|*
name|client_request_forwarded_tcpip
parameter_list|(
specifier|const
name|char
modifier|*
name|request_type
parameter_list|,
name|int
name|rchan
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|listen_address
decl_stmt|,
modifier|*
name|originator_address
decl_stmt|;
name|int
name|listen_port
decl_stmt|,
name|originator_port
decl_stmt|;
name|int
name|sock
decl_stmt|;
comment|/* Get rest of the packet */
name|listen_address
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|listen_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|originator_address
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|originator_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"client_request_forwarded_tcpip: listen %s port %d, originator %s port %d"
argument_list|,
name|listen_address
argument_list|,
name|listen_port
argument_list|,
name|originator_address
argument_list|,
name|originator_port
argument_list|)
expr_stmt|;
name|sock
operator|=
name|channel_connect_by_listen_address
argument_list|(
name|listen_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|originator_address
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|listen_address
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|=
name|channel_new
argument_list|(
literal|"forwarded-tcpip"
argument_list|,
name|SSH_CHANNEL_CONNECTING
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_TCP_WINDOW_DEFAULT
argument_list|,
name|CHAN_TCP_WINDOW_DEFAULT
argument_list|,
literal|0
argument_list|,
name|originator_address
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|originator_address
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|listen_address
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|Channel
modifier|*
name|client_request_x11
parameter_list|(
specifier|const
name|char
modifier|*
name|request_type
parameter_list|,
name|int
name|rchan
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|originator
decl_stmt|;
name|int
name|originator_port
decl_stmt|;
name|int
name|sock
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|forward_x11
condition|)
block|{
name|error
argument_list|(
literal|"Warning: ssh server tried X11 forwarding."
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Warning: this is probably a break in attempt by a malicious server."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|originator
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|datafellows
operator|&
name|SSH_BUG_X11FWD
condition|)
block|{
name|debug2
argument_list|(
literal|"buggy server: x11 request w/o originator_port"
argument_list|)
expr_stmt|;
name|originator_port
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|originator_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
block|}
name|packet_check_eom
argument_list|()
expr_stmt|;
comment|/* XXX check permission */
name|debug
argument_list|(
literal|"client_request_x11: request from %s %d"
argument_list|,
name|originator
argument_list|,
name|originator_port
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|originator
argument_list|)
expr_stmt|;
name|sock
operator|=
name|x11_connect_display
argument_list|()
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|c
operator|=
name|channel_new
argument_list|(
literal|"x11"
argument_list|,
name|SSH_CHANNEL_X11_OPEN
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_TCP_WINDOW_DEFAULT
argument_list|,
name|CHAN_X11_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|"x11"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|force_drain
operator|=
literal|1
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|Channel
modifier|*
name|client_request_agent
parameter_list|(
specifier|const
name|char
modifier|*
name|request_type
parameter_list|,
name|int
name|rchan
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|int
name|sock
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|forward_agent
condition|)
block|{
name|error
argument_list|(
literal|"Warning: ssh server tried agent forwarding."
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Warning: this is probably a break in attempt by a malicious server."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sock
operator|=
name|ssh_get_authentication_socket
argument_list|()
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|c
operator|=
name|channel_new
argument_list|(
literal|"authentication agent connection"
argument_list|,
name|SSH_CHANNEL_OPEN
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_X11_WINDOW_DEFAULT
argument_list|,
name|CHAN_TCP_WINDOW_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|"authentication agent connection"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|force_drain
operator|=
literal|1
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* XXXX move to generic input handler */
end_comment

begin_function
specifier|static
name|void
name|client_input_channel_open
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ctype
decl_stmt|;
name|int
name|rchan
decl_stmt|;
name|u_int
name|rmaxpack
decl_stmt|,
name|rwindow
decl_stmt|,
name|len
decl_stmt|;
name|ctype
operator|=
name|packet_get_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|rchan
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|rwindow
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|rmaxpack
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"client_input_channel_open: ctype %s rchan %d win %d max %d"
argument_list|,
name|ctype
argument_list|,
name|rchan
argument_list|,
name|rwindow
argument_list|,
name|rmaxpack
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"forwarded-tcpip"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|client_request_forwarded_tcpip
argument_list|(
name|ctype
argument_list|,
name|rchan
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"x11"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|client_request_x11
argument_list|(
name|ctype
argument_list|,
name|rchan
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"auth-agent@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|client_request_agent
argument_list|(
name|ctype
argument_list|,
name|rchan
argument_list|)
expr_stmt|;
block|}
comment|/* XXX duplicate : */
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"confirm %s"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
name|rchan
expr_stmt|;
name|c
operator|->
name|remote_window
operator|=
name|rwindow
expr_stmt|;
name|c
operator|->
name|remote_maxpacket
operator|=
name|rmaxpack
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_CONNECTING
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|debug
argument_list|(
literal|"failure %s"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|rchan
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|datafellows
operator|&
name|SSH_BUG_OPENFAILURE
operator|)
condition|)
block|{
name|packet_put_cstring
argument_list|(
literal|"open failed"
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|xfree
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_input_channel_req
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|int
name|exitval
decl_stmt|,
name|id
decl_stmt|,
name|reply
decl_stmt|,
name|success
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|rtype
decl_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|rtype
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|reply
operator|=
name|packet_get_char
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"client_input_channel_req: channel %d rtype %s reply %d"
argument_list|,
name|id
argument_list|,
name|rtype
argument_list|,
name|reply
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"client_input_channel_req: request for channel -1"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"client_input_channel_req: channel %d: unknown channel"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"exit-status"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|exitval
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|session_ident
condition|)
block|{
name|success
operator|=
literal|1
expr_stmt|;
name|exit_status
operator|=
name|exitval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|ctl_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"client_input_channel_req: unexpected channel %d"
argument_list|,
name|session_ident
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|c
operator|->
name|ctl_fd
argument_list|,
operator|&
name|exitval
argument_list|,
sizeof|sizeof
argument_list|(
name|exitval
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
name|packet_check_eom
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reply
condition|)
block|{
name|packet_start
argument_list|(
name|success
condition|?
name|SSH2_MSG_CHANNEL_SUCCESS
else|:
name|SSH2_MSG_CHANNEL_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|xfree
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_input_global_request
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|char
modifier|*
name|rtype
decl_stmt|;
name|int
name|want_reply
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|rtype
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|want_reply
operator|=
name|packet_get_char
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"client_input_global_request: rtype %s want_reply %d"
argument_list|,
name|rtype
argument_list|,
name|want_reply
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_reply
condition|)
block|{
name|packet_start
argument_list|(
name|success
condition|?
name|SSH2_MSG_REQUEST_SUCCESS
else|:
name|SSH2_MSG_REQUEST_FAILURE
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
block|}
name|xfree
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_session2_setup
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|want_tty
parameter_list|,
name|int
name|want_subsystem
parameter_list|,
specifier|const
name|char
modifier|*
name|term
parameter_list|,
name|struct
name|termios
modifier|*
name|tiop
parameter_list|,
name|int
name|in_fd
parameter_list|,
name|Buffer
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|,
name|dispatch_fn
modifier|*
name|subsys_repl
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|debug2
argument_list|(
literal|"%s: id %d"
argument_list|,
name|__func__
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_tty
condition|)
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
name|struct
name|termios
name|tio
decl_stmt|;
comment|/* Store window size in the packet. */
if|if
condition|(
name|ioctl
argument_list|(
name|in_fd
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|<
literal|0
condition|)
name|memset
argument_list|(
operator|&
name|ws
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ws
argument_list|)
argument_list|)
expr_stmt|;
name|channel_request_start
argument_list|(
name|id
argument_list|,
literal|"pty-req"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|term
operator|!=
name|NULL
condition|?
name|term
else|:
literal|""
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_col
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_row
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_xpixel
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_ypixel
argument_list|)
expr_stmt|;
name|tio
operator|=
name|get_saved_tio
argument_list|()
expr_stmt|;
name|tty_make_modes
argument_list|(
operator|-
literal|1
argument_list|,
name|tiop
operator|!=
name|NULL
condition|?
name|tiop
else|:
operator|&
name|tio
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* XXX wait for reply */
block|}
comment|/* Transfer any environment variables from client to server */
if|if
condition|(
name|options
operator|.
name|num_send_env
operator|!=
literal|0
operator|&&
name|env
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|matched
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|val
decl_stmt|;
name|debug
argument_list|(
literal|"Sending environment."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|env
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
comment|/* Split */
name|name
operator|=
name|xstrdup
argument_list|(
name|env
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|val
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|matched
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|options
operator|.
name|num_send_env
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|match_pattern
argument_list|(
name|name
argument_list|,
name|options
operator|.
name|send_env
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|matched
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
name|debug3
argument_list|(
literal|"Ignored env %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|debug
argument_list|(
literal|"Sending env %s = %s"
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|channel_request_start
argument_list|(
name|id
argument_list|,
literal|"env"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|len
operator|=
name|buffer_len
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|900
condition|)
name|len
operator|=
literal|900
expr_stmt|;
if|if
condition|(
name|want_subsystem
condition|)
block|{
name|debug
argument_list|(
literal|"Sending subsystem: %.*s"
argument_list|,
name|len
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|buffer_ptr
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|channel_request_start
argument_list|(
name|id
argument_list|,
literal|"subsystem"
argument_list|,
name|subsys_repl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|subsys_repl
operator|!=
name|NULL
condition|)
block|{
comment|/* register callback for reply */
comment|/* XXX we assume that client_loop has already been called */
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_FAILURE
argument_list|,
name|subsys_repl
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_SUCCESS
argument_list|,
name|subsys_repl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|debug
argument_list|(
literal|"Sending command: %.*s"
argument_list|,
name|len
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|buffer_ptr
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|channel_request_start
argument_list|(
name|id
argument_list|,
literal|"exec"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|channel_request_start
argument_list|(
name|id
argument_list|,
literal|"shell"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|client_init_dispatch_20
parameter_list|(
name|void
parameter_list|)
block|{
name|dispatch_init
argument_list|(
operator|&
name|dispatch_protocol_error
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_oclose
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_DATA
argument_list|,
operator|&
name|channel_input_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_EOF
argument_list|,
operator|&
name|channel_input_ieof
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_EXTENDED_DATA
argument_list|,
operator|&
name|channel_input_extended_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|,
operator|&
name|client_input_channel_open
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|,
operator|&
name|channel_input_open_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_FAILURE
argument_list|,
operator|&
name|channel_input_open_failure
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_REQUEST
argument_list|,
operator|&
name|client_input_channel_req
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_WINDOW_ADJUST
argument_list|,
operator|&
name|channel_input_window_adjust
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_GLOBAL_REQUEST
argument_list|,
operator|&
name|client_input_global_request
argument_list|)
expr_stmt|;
comment|/* rekeying */
name|dispatch_set
argument_list|(
name|SSH2_MSG_KEXINIT
argument_list|,
operator|&
name|kex_input_kexinit
argument_list|)
expr_stmt|;
comment|/* global request reply messages */
name|dispatch_set
argument_list|(
name|SSH2_MSG_REQUEST_FAILURE
argument_list|,
operator|&
name|client_global_request_reply
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_REQUEST_SUCCESS
argument_list|,
operator|&
name|client_global_request_reply
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_init_dispatch_13
parameter_list|(
name|void
parameter_list|)
block|{
name|dispatch_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_close
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE_CONFIRMATION
argument_list|,
operator|&
name|channel_input_close_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_DATA
argument_list|,
operator|&
name|channel_input_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|,
operator|&
name|channel_input_open_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|,
operator|&
name|channel_input_open_failure
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_PORT_OPEN
argument_list|,
operator|&
name|channel_input_port_open
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_SMSG_EXITSTATUS
argument_list|,
operator|&
name|client_input_exit_status
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_SMSG_STDERR_DATA
argument_list|,
operator|&
name|client_input_stderr_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_SMSG_STDOUT_DATA
argument_list|,
operator|&
name|client_input_stdout_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_SMSG_AGENT_OPEN
argument_list|,
name|options
operator|.
name|forward_agent
condition|?
operator|&
name|client_input_agent_open
else|:
operator|&
name|deny_input_open
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_SMSG_X11_OPEN
argument_list|,
name|options
operator|.
name|forward_x11
condition|?
operator|&
name|x11_input_open
else|:
operator|&
name|deny_input_open
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_init_dispatch_15
parameter_list|(
name|void
parameter_list|)
block|{
name|client_init_dispatch_13
argument_list|()
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_ieof
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE_CONFIRMATION
argument_list|,
operator|&
name|channel_input_oclose
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_init_dispatch
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|compat20
condition|)
name|client_init_dispatch_20
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|compat13
condition|)
name|client_init_dispatch_13
argument_list|()
expr_stmt|;
else|else
name|client_init_dispatch_15
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* client specific fatal cleanup */
end_comment

begin_function
name|void
name|cleanup_exit
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|leave_raw_mode
argument_list|()
expr_stmt|;
name|leave_non_blocking
argument_list|()
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|control_path
operator|!=
name|NULL
operator|&&
name|control_fd
operator|!=
operator|-
literal|1
condition|)
name|unlink
argument_list|(
name|options
operator|.
name|control_path
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

