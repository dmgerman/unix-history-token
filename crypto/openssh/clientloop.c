begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: clientloop.c,v 1.291 2017/03/10 05:01:13 djm Exp $ */
end_comment

begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  * The main loop for the interactive session (client side).  *  * As far as I am concerned, the code I have written for this software  * can be used freely for any purpose.  Any derived versions of this  * software must be clearly marked as such, and if the derived work is  * incompatible with the protocol description in the RFC file, it must be  * called by a name other than "ssh" or "Secure Shell".  *  *  * Copyright (c) 1999 Theo de Raadt.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * SSH2 support added by Markus Friedl.  * Copyright (c) 1999, 2000, 2001 Markus Friedl.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PATHS_H
end_ifdef

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|"openbsd-compat/sys-queue.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"ssh1.h"
end_include

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|"channels.h"
end_include

begin_include
include|#
directive|include
file|"dispatch.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"cipher.h"
end_include

begin_include
include|#
directive|include
file|"kex.h"
end_include

begin_include
include|#
directive|include
file|"myproposal.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"readconf.h"
end_include

begin_include
include|#
directive|include
file|"clientloop.h"
end_include

begin_include
include|#
directive|include
file|"sshconnect.h"
end_include

begin_include
include|#
directive|include
file|"authfd.h"
end_include

begin_include
include|#
directive|include
file|"atomicio.h"
end_include

begin_include
include|#
directive|include
file|"sshpty.h"
end_include

begin_include
include|#
directive|include
file|"match.h"
end_include

begin_include
include|#
directive|include
file|"msg.h"
end_include

begin_include
include|#
directive|include
file|"ssherr.h"
end_include

begin_include
include|#
directive|include
file|"hostfile.h"
end_include

begin_comment
comment|/* import options */
end_comment

begin_decl_stmt
specifier|extern
name|Options
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating that stdin should be redirected from /dev/null. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stdin_null_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating that no shell has been requested */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|no_shell_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating that ssh should daemonise after authentication is complete */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fork_after_authentication_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Control socket */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|muxserver_sock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX use mux_client_cleanup() instead */
end_comment

begin_comment
comment|/*  * Name of the host we are connecting to.  This is the name given on the  * command line, or the HostName specified for the user-supplied name in a  * configuration file.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|host
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flag to indicate that we have received a window change signal which has  * not yet been processed.  This will cause a message indicating the new  * window size to be sent to the server a little later.  This is volatile  * because this is updated in a signal handler.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|received_window_change_signal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|received_signal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating whether the user's terminal is in non-blocking mode. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_non_blocking_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Time when backgrounded control master using ControlPersist should exit */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|control_persist_exit_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Common data for the client loop code. */
end_comment

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|quit_pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set non-zero to quit the loop. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|escape_char1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Escape character. (proto1 only) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|escape_pending1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last character was an escape (proto1 only) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_was_cr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last character was a newline. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exit_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to store the command exit status. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdin_eof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF has been encountered on stderr. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stdin_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stdin data. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stdout_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stdout data. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stderr_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stderr data. */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|buffer_high
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Soft max buffer size. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|connection_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to server (input). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|connection_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to server (output). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|need_rekeying
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to non-zero if rekeying is requested. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|session_closed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In SSH2: login session closed. */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|x11_refuse_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If>0, refuse x11 opens after this time. */
end_comment

begin_function_decl
specifier|static
name|void
name|client_init_dispatch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|session_ident
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Track escape per proto2 channel */
end_comment

begin_struct
struct|struct
name|escape_filter_ctx
block|{
name|int
name|escape_pending
decl_stmt|;
name|int
name|escape_char
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Context for channel confirmation replies */
end_comment

begin_struct
struct|struct
name|channel_reply_ctx
block|{
specifier|const
name|char
modifier|*
name|request_type
decl_stmt|;
name|int
name|id
decl_stmt|;
name|enum
name|confirm_action
name|action
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Global request success/failure callbacks */
end_comment

begin_struct
struct|struct
name|global_confirm
block|{
name|TAILQ_ENTRY
argument_list|(
argument|global_confirm
argument_list|)
name|entry
expr_stmt|;
name|global_confirm_cb
modifier|*
name|cb
decl_stmt|;
name|void
modifier|*
name|ctx
decl_stmt|;
name|int
name|ref_count
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|global_confirms
argument_list|,
name|global_confirm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|global_confirms
name|global_confirms
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|global_confirms
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ssh_process_session2_setup
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Restores stdin to blocking mode. */
end_comment

begin_function
specifier|static
name|void
name|leave_non_blocking
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|in_non_blocking_mode
condition|)
block|{
name|unset_nonblock
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|in_non_blocking_mode
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Puts stdin terminal in non-blocking mode. */
end_comment

begin_function
specifier|static
name|void
name|enter_non_blocking
parameter_list|(
name|void
parameter_list|)
block|{
name|in_non_blocking_mode
operator|=
literal|1
expr_stmt|;
name|set_nonblock
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Signal handler for the window change signal (SIGWINCH).  This just sets a  * flag indicating that the window has changed.  */
end_comment

begin_comment
comment|/*ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|window_change_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|received_window_change_signal
operator|=
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|window_change_handler
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Signal handler for signals that cause the program to terminate.  These  * signals must be trapped to restore terminal modes.  */
end_comment

begin_comment
comment|/*ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|signal_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|received_signal
operator|=
name|sig
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns current time in seconds from Jan 1, 1970 with the maximum  * available resolution.  */
end_comment

begin_function
specifier|static
name|double
name|get_current_time
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|double
operator|)
name|tv
operator|.
name|tv_sec
operator|+
operator|(
name|double
operator|)
name|tv
operator|.
name|tv_usec
operator|/
literal|1000000.0
return|;
block|}
end_function

begin_comment
comment|/*  * Sets control_persist_exit_time to the absolute time when the  * backgrounded control master should exit due to expiry of the  * ControlPersist timeout.  Sets it to 0 if we are not a backgrounded  * control master process, or if there is no ControlPersist timeout.  */
end_comment

begin_function
specifier|static
name|void
name|set_control_persist_exit_time
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|muxserver_sock
operator|==
operator|-
literal|1
operator|||
operator|!
name|options
operator|.
name|control_persist
operator|||
name|options
operator|.
name|control_persist_timeout
operator|==
literal|0
condition|)
block|{
comment|/* not using a ControlPersist timeout */
name|control_persist_exit_time
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|channel_still_open
argument_list|()
condition|)
block|{
comment|/* some client connections are still open */
if|if
condition|(
name|control_persist_exit_time
operator|>
literal|0
condition|)
name|debug2
argument_list|(
literal|"%s: cancel scheduled exit"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|control_persist_exit_time
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|control_persist_exit_time
operator|<=
literal|0
condition|)
block|{
comment|/* a client connection has recently closed */
name|control_persist_exit_time
operator|=
name|monotime
argument_list|()
operator|+
operator|(
name|time_t
operator|)
name|options
operator|.
name|control_persist_timeout
expr_stmt|;
name|debug2
argument_list|(
literal|"%s: schedule exit in %d seconds"
argument_list|,
name|__func__
argument_list|,
name|options
operator|.
name|control_persist_timeout
argument_list|)
expr_stmt|;
block|}
comment|/* else we are already counting down to the timeout */
block|}
end_function

begin_define
define|#
directive|define
name|SSH_X11_VALID_DISPLAY_CHARS
value|":/.-_"
end_define

begin_function
specifier|static
name|int
name|client_x11_display_valid
parameter_list|(
specifier|const
name|char
modifier|*
name|display
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|dlen
decl_stmt|;
if|if
condition|(
name|display
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|dlen
operator|=
name|strlen
argument_list|(
name|display
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dlen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|(
name|u_char
operator|)
name|display
index|[
name|i
index|]
argument_list|)
operator|&&
name|strchr
argument_list|(
name|SSH_X11_VALID_DISPLAY_CHARS
argument_list|,
name|display
index|[
name|i
index|]
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"Invalid character '%c' in DISPLAY"
argument_list|,
name|display
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SSH_X11_PROTO
value|"MIT-MAGIC-COOKIE-1"
end_define

begin_define
define|#
directive|define
name|X11_TIMEOUT_SLACK
value|60
end_define

begin_function
name|int
name|client_x11_get_proto
parameter_list|(
specifier|const
name|char
modifier|*
name|display
parameter_list|,
specifier|const
name|char
modifier|*
name|xauth_path
parameter_list|,
name|u_int
name|trusted
parameter_list|,
name|u_int
name|timeout
parameter_list|,
name|char
modifier|*
modifier|*
name|_proto
parameter_list|,
name|char
modifier|*
modifier|*
name|_data
parameter_list|)
block|{
name|char
name|cmd
index|[
literal|1024
index|]
decl_stmt|,
name|line
index|[
literal|512
index|]
decl_stmt|,
name|xdisplay
index|[
literal|512
index|]
decl_stmt|;
name|char
name|xauthfile
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|xauthdir
index|[
name|PATH_MAX
index|]
decl_stmt|;
specifier|static
name|char
name|proto
index|[
literal|512
index|]
decl_stmt|,
name|data
index|[
literal|512
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|got_data
init|=
literal|0
decl_stmt|,
name|generated
init|=
literal|0
decl_stmt|,
name|do_unlink
init|=
literal|0
decl_stmt|,
name|r
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|u_int
name|now
decl_stmt|,
name|x11_timeout_real
decl_stmt|;
operator|*
name|_proto
operator|=
name|proto
expr_stmt|;
operator|*
name|_data
operator|=
name|data
expr_stmt|;
name|proto
index|[
literal|0
index|]
operator|=
name|data
index|[
literal|0
index|]
operator|=
name|xauthfile
index|[
literal|0
index|]
operator|=
name|xauthdir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|client_x11_display_valid
argument_list|(
name|display
argument_list|)
condition|)
block|{
if|if
condition|(
name|display
operator|!=
name|NULL
condition|)
name|logit
argument_list|(
literal|"DISPLAY \"%s\" invalid; disabling X11 forwarding"
argument_list|,
name|display
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|xauth_path
operator|!=
name|NULL
operator|&&
name|stat
argument_list|(
name|xauth_path
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|debug
argument_list|(
literal|"No xauth program."
argument_list|)
expr_stmt|;
name|xauth_path
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|xauth_path
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Handle FamilyLocal case where $DISPLAY does 		 * not match an authorization entry.  For this we 		 * just try "xauth list unix:displaynum.screennum". 		 * XXX: "localhost" match to determine FamilyLocal 		 *      is not perfect. 		 */
if|if
condition|(
name|strncmp
argument_list|(
name|display
argument_list|,
literal|"localhost:"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|snprintf
argument_list|(
name|xdisplay
argument_list|,
sizeof|sizeof
argument_list|(
name|xdisplay
argument_list|)
argument_list|,
literal|"unix:%s"
argument_list|,
name|display
operator|+
literal|10
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|r
operator|>=
sizeof|sizeof
argument_list|(
name|xdisplay
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%s: display name too long"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|display
operator|=
name|xdisplay
expr_stmt|;
block|}
if|if
condition|(
name|trusted
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Generate an untrusted X11 auth cookie. 			 * 			 * The authentication cookie should briefly outlive 			 * ssh's willingness to forward X11 connections to 			 * avoid nasty fail-open behaviour in the X server. 			 */
name|mktemp_proto
argument_list|(
name|xauthdir
argument_list|,
sizeof|sizeof
argument_list|(
name|xauthdir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdtemp
argument_list|(
name|xauthdir
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: mkdtemp: %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|do_unlink
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|snprintf
argument_list|(
name|xauthfile
argument_list|,
sizeof|sizeof
argument_list|(
name|xauthfile
argument_list|)
argument_list|,
literal|"%s/xauthfile"
argument_list|,
name|xauthdir
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|r
operator|>=
sizeof|sizeof
argument_list|(
name|xauthfile
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%s: xauthfile path too long"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|xauthfile
argument_list|)
expr_stmt|;
name|rmdir
argument_list|(
name|xauthdir
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|timeout
operator|>=
name|UINT_MAX
operator|-
name|X11_TIMEOUT_SLACK
condition|)
name|x11_timeout_real
operator|=
name|UINT_MAX
expr_stmt|;
else|else
name|x11_timeout_real
operator|=
name|timeout
operator|+
name|X11_TIMEOUT_SLACK
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|snprintf
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
literal|"%s -f %s generate %s "
name|SSH_X11_PROTO
literal|" untrusted timeout %u 2>"
name|_PATH_DEVNULL
argument_list|,
name|xauth_path
argument_list|,
name|xauthfile
argument_list|,
name|display
argument_list|,
name|x11_timeout_real
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|r
operator|>=
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"%s: cmd too long"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"%s: %s"
argument_list|,
name|__func__
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|x11_refuse_time
operator|==
literal|0
condition|)
block|{
name|now
operator|=
name|monotime
argument_list|()
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|UINT_MAX
operator|-
name|timeout
operator|<
name|now
condition|)
name|x11_refuse_time
operator|=
name|UINT_MAX
expr_stmt|;
else|else
name|x11_refuse_time
operator|=
name|now
operator|+
name|timeout
expr_stmt|;
name|channel_set_x11_refuse_time
argument_list|(
name|x11_refuse_time
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|system
argument_list|(
name|cmd
argument_list|)
operator|==
literal|0
condition|)
name|generated
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * When in untrusted mode, we read the cookie only if it was 		 * successfully generated as an untrusted one in the step 		 * above. 		 */
if|if
condition|(
name|trusted
operator|||
name|generated
condition|)
block|{
name|snprintf
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
literal|"%s %s%s list %s 2>"
name|_PATH_DEVNULL
argument_list|,
name|xauth_path
argument_list|,
name|generated
condition|?
literal|"-f "
else|:
literal|""
argument_list|,
name|generated
condition|?
name|xauthfile
else|:
literal|""
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"x11_get_proto: %s"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|f
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&&
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
operator|&&
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"%*s %511s %511s"
argument_list|,
name|proto
argument_list|,
name|data
argument_list|)
operator|==
literal|2
condition|)
name|got_data
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|f
condition|)
name|pclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_unlink
condition|)
block|{
name|unlink
argument_list|(
name|xauthfile
argument_list|)
expr_stmt|;
name|rmdir
argument_list|(
name|xauthdir
argument_list|)
expr_stmt|;
block|}
comment|/* Don't fall back to fake X11 data for untrusted forwarding */
if|if
condition|(
operator|!
name|trusted
operator|&&
operator|!
name|got_data
condition|)
block|{
name|error
argument_list|(
literal|"Warning: untrusted X11 forwarding setup failed: "
literal|"xauth key data not generated"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * If we didn't get authentication data, just make up some 	 * data.  The forwarding code will check the validity of the 	 * response anyway, and substitute this data.  The X11 	 * server, however, will ignore this fake data and use 	 * whatever authentication mechanisms it was using otherwise 	 * for the local connection. 	 */
if|if
condition|(
operator|!
name|got_data
condition|)
block|{
name|u_int8_t
name|rnd
index|[
literal|16
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|logit
argument_list|(
literal|"Warning: No xauth data; "
literal|"using fake authentication data for X11 forwarding."
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|proto
argument_list|,
name|SSH_X11_PROTO
argument_list|,
sizeof|sizeof
name|proto
argument_list|)
expr_stmt|;
name|arc4random_buf
argument_list|(
name|rnd
argument_list|,
sizeof|sizeof
argument_list|(
name|rnd
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|rnd
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|data
operator|+
literal|2
operator|*
name|i
argument_list|,
sizeof|sizeof
name|data
operator|-
literal|2
operator|*
name|i
argument_list|,
literal|"%02x"
argument_list|,
name|rnd
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This is called when the interactive is entered.  This checks if there is  * an EOF coming on stdin.  We must check this explicitly, as select() does  * not appear to wake up when redirecting from /dev/null.  */
end_comment

begin_function
specifier|static
name|void
name|client_check_initial_eof_on_stdin
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
comment|/* 	 * If standard input is to be "redirected from /dev/null", we simply 	 * mark that we have seen an EOF and send an EOF message to the 	 * server. Otherwise, we try to read a single character; it appears 	 * that for some files, such /dev/null, select() never wakes up for 	 * read for this descriptor, which means that we never get EOF.  This 	 * way we will get the EOF if stdin comes from /dev/null or similar. 	 */
if|if
condition|(
name|stdin_null_flag
condition|)
block|{
comment|/* Fake EOF on stdin. */
name|debug
argument_list|(
literal|"Sending eof."
argument_list|)
expr_stmt|;
name|stdin_eof
operator|=
literal|1
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|enter_non_blocking
argument_list|()
expr_stmt|;
comment|/* Check for immediate EOF on stdin. */
name|len
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* 			 * EOF.  Record that we have seen it and send 			 * EOF to server. 			 */
name|debug
argument_list|(
literal|"Sending eof."
argument_list|)
expr_stmt|;
name|stdin_eof
operator|=
literal|1
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Got data.  We must store the data in the buffer, 			 * and also process it as an escape character if 			 * appropriate. 			 */
if|if
condition|(
operator|(
name|u_char
operator|)
name|buf
index|[
literal|0
index|]
operator|==
name|escape_char1
condition|)
name|escape_pending1
operator|=
literal|1
expr_stmt|;
else|else
name|buffer_append
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|leave_non_blocking
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Make packets from buffered stdin data, and buffer them for sending to the  * connection.  */
end_comment

begin_function
specifier|static
name|void
name|client_make_packets_from_stdin_data
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|len
decl_stmt|;
comment|/* Send buffered stdin data to the server. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|>
literal|0
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
block|{
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
comment|/* Keep the packets at reasonable size. */
if|if
condition|(
name|len
operator|>
name|packet_get_maxsize
argument_list|()
condition|)
name|len
operator|=
name|packet_get_maxsize
argument_list|()
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_CMSG_STDIN_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* If we have a pending EOF, send it now. */
if|if
condition|(
name|stdin_eof
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Checks if the client window has changed, and sends a packet about it to  * the server if so.  The actual change is detected elsewhere (by a software  * interrupt on Unix); this just checks the flag and sends a message if  * appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|client_check_window_change
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
if|if
condition|(
operator|!
name|received_window_change_signal
condition|)
return|return;
comment|/** XXX race */
name|received_window_change_signal
operator|=
literal|0
expr_stmt|;
name|debug2
argument_list|(
literal|"client_check_window_change: changed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|channel_send_window_changes
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|packet_start
argument_list|(
name|SSH_CMSG_WINDOW_SIZE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
operator|(
name|u_int
operator|)
name|ws
operator|.
name|ws_row
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
operator|(
name|u_int
operator|)
name|ws
operator|.
name|ws_col
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
operator|(
name|u_int
operator|)
name|ws
operator|.
name|ws_xpixel
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
operator|(
name|u_int
operator|)
name|ws
operator|.
name|ws_ypixel
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|client_global_request_reply
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|struct
name|global_confirm
modifier|*
name|gc
decl_stmt|;
if|if
condition|(
operator|(
name|gc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|global_confirms
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|gc
operator|->
name|cb
operator|!=
name|NULL
condition|)
name|gc
operator|->
name|cb
argument_list|(
name|type
argument_list|,
name|seq
argument_list|,
name|gc
operator|->
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|gc
operator|->
name|ref_count
operator|<=
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|global_confirms
argument_list|,
name|gc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|gc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gc
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gc
argument_list|)
expr_stmt|;
block|}
name|packet_set_alive_timeouts
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_alive_check
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|packet_inc_alive_timeouts
argument_list|()
operator|>
name|options
operator|.
name|server_alive_count_max
condition|)
block|{
name|logit
argument_list|(
literal|"Timeout, server %s not responding."
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|cleanup_exit
argument_list|(
literal|255
argument_list|)
expr_stmt|;
block|}
name|packet_start
argument_list|(
name|SSH2_MSG_GLOBAL_REQUEST
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"keepalive@openssh.com"
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* boolean: want reply */
name|packet_send
argument_list|()
expr_stmt|;
comment|/* Insert an empty placeholder to maintain ordering */
name|client_register_global_confirm
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Waits until the client can do something (some data becomes available on  * one of the file descriptors).  */
end_comment

begin_function
specifier|static
name|void
name|client_wait_until_can_do_something
parameter_list|(
name|fd_set
modifier|*
modifier|*
name|readsetp
parameter_list|,
name|fd_set
modifier|*
modifier|*
name|writesetp
parameter_list|,
name|int
modifier|*
name|maxfdp
parameter_list|,
name|u_int
modifier|*
name|nallocp
parameter_list|,
name|int
name|rekeying
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|int
name|timeout_secs
decl_stmt|;
name|time_t
name|minwait_secs
init|=
literal|0
decl_stmt|,
name|server_alive_time
init|=
literal|0
decl_stmt|,
name|now
init|=
name|monotime
argument_list|()
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Add any selections by the channel mechanism. */
name|channel_prepare_select
argument_list|(
name|readsetp
argument_list|,
name|writesetp
argument_list|,
name|maxfdp
argument_list|,
name|nallocp
argument_list|,
operator|&
name|minwait_secs
argument_list|,
name|rekeying
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compat20
condition|)
block|{
comment|/* Read from the connection, unless our buffers are full. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|<
name|buffer_high
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|<
name|buffer_high
operator|&&
name|channel_not_very_much_buffered_data
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_in
argument_list|,
operator|*
name|readsetp
argument_list|)
expr_stmt|;
comment|/* 		 * Read from stdin, unless we have seen EOF or have very much 		 * buffered data to send to the server. 		 */
if|if
condition|(
operator|!
name|stdin_eof
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|*
name|readsetp
argument_list|)
expr_stmt|;
comment|/* Select stdout/stderr if have data in buffer. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
operator|*
name|writesetp
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
operator|*
name|writesetp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* channel_prepare_select could have closed the last channel */
if|if
condition|(
name|session_closed
operator|&&
operator|!
name|channel_still_open
argument_list|()
operator|&&
operator|!
name|packet_have_data_to_write
argument_list|()
condition|)
block|{
comment|/* clear mask since we did not call select() */
name|memset
argument_list|(
operator|*
name|readsetp
argument_list|,
literal|0
argument_list|,
operator|*
name|nallocp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|writesetp
argument_list|,
literal|0
argument_list|,
operator|*
name|nallocp
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|FD_SET
argument_list|(
name|connection_in
argument_list|,
operator|*
name|readsetp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Select server connection if have data to write to the server. */
if|if
condition|(
name|packet_have_data_to_write
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_out
argument_list|,
operator|*
name|writesetp
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for something to happen.  This will suspend the process until 	 * some selected descriptor can be read, written, or has some other 	 * event pending, or a timeout expires. 	 */
name|timeout_secs
operator|=
name|INT_MAX
expr_stmt|;
comment|/* we use INT_MAX to mean no timeout */
if|if
condition|(
name|options
operator|.
name|server_alive_interval
operator|>
literal|0
operator|&&
name|compat20
condition|)
block|{
name|timeout_secs
operator|=
name|options
operator|.
name|server_alive_interval
expr_stmt|;
name|server_alive_time
operator|=
name|now
operator|+
name|options
operator|.
name|server_alive_interval
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|.
name|rekey_interval
operator|>
literal|0
operator|&&
name|compat20
operator|&&
operator|!
name|rekeying
condition|)
name|timeout_secs
operator|=
name|MINIMUM
argument_list|(
name|timeout_secs
argument_list|,
name|packet_get_rekey_timeout
argument_list|()
argument_list|)
expr_stmt|;
name|set_control_persist_exit_time
argument_list|()
expr_stmt|;
if|if
condition|(
name|control_persist_exit_time
operator|>
literal|0
condition|)
block|{
name|timeout_secs
operator|=
name|MINIMUM
argument_list|(
name|timeout_secs
argument_list|,
name|control_persist_exit_time
operator|-
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout_secs
operator|<
literal|0
condition|)
name|timeout_secs
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|minwait_secs
operator|!=
literal|0
condition|)
name|timeout_secs
operator|=
name|MINIMUM
argument_list|(
name|timeout_secs
argument_list|,
operator|(
name|int
operator|)
name|minwait_secs
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout_secs
operator|==
name|INT_MAX
condition|)
name|tvp
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|timeout_secs
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tvp
operator|=
operator|&
name|tv
expr_stmt|;
block|}
name|ret
operator|=
name|select
argument_list|(
operator|(
operator|*
name|maxfdp
operator|)
operator|+
literal|1
argument_list|,
operator|*
name|readsetp
argument_list|,
operator|*
name|writesetp
argument_list|,
name|NULL
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* 		 * We have to clear the select masks, because we return. 		 * We have to return, because the mainloop checks for the flags 		 * set by the signal handlers. 		 */
name|memset
argument_list|(
operator|*
name|readsetp
argument_list|,
literal|0
argument_list|,
operator|*
name|nallocp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|writesetp
argument_list|,
literal|0
argument_list|,
operator|*
name|nallocp
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
return|return;
comment|/* Note: we might still have data in the buffers. */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"select: %s\r\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Timeout.  Could have been either keepalive or rekeying. 		 * Keepalive we check here, rekeying is checked in clientloop. 		 */
if|if
condition|(
name|server_alive_time
operator|!=
literal|0
operator|&&
name|server_alive_time
operator|<=
name|monotime
argument_list|()
condition|)
name|server_alive_check
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|client_suspend_self
parameter_list|(
name|Buffer
modifier|*
name|bin
parameter_list|,
name|Buffer
modifier|*
name|bout
parameter_list|,
name|Buffer
modifier|*
name|berr
parameter_list|)
block|{
comment|/* Flush stdout and stderr buffers. */
if|if
condition|(
name|buffer_len
argument_list|(
name|bout
argument_list|)
operator|>
literal|0
condition|)
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
name|bout
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
name|bout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
name|berr
argument_list|)
operator|>
literal|0
condition|)
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
name|berr
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
name|berr
argument_list|)
argument_list|)
expr_stmt|;
name|leave_raw_mode
argument_list|(
name|options
operator|.
name|request_tty
operator|==
name|REQUEST_TTY_FORCE
argument_list|)
expr_stmt|;
comment|/* 	 * Free (and clear) the buffer to reduce the amount of data that gets 	 * written to swap. 	 */
name|buffer_free
argument_list|(
name|bin
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
name|bout
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
name|berr
argument_list|)
expr_stmt|;
comment|/* Send the suspend signal to the program itself. */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* Reset window sizes in case they have changed */
name|received_window_change_signal
operator|=
literal|1
expr_stmt|;
comment|/* OK, we have been continued by the user. Reinitialize buffers. */
name|buffer_init
argument_list|(
name|bin
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
name|bout
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
name|berr
argument_list|)
expr_stmt|;
name|enter_raw_mode
argument_list|(
name|options
operator|.
name|request_tty
operator|==
name|REQUEST_TTY_FORCE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_process_net_input
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
name|SSH_IOBUFSZ
index|]
decl_stmt|;
comment|/* 	 * Read input from the server, and add any such data to the buffer of 	 * the packet subsystem. 	 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_in
argument_list|,
name|readset
argument_list|)
condition|)
block|{
comment|/* Read as much as possible. */
name|len
operator|=
name|read
argument_list|(
name|connection_in
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Received EOF.  The remote host has closed the 			 * connection. 			 */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"Connection to %.300s closed by remote host.\r\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 		 * There is a kernel bug on Solaris that causes select to 		 * sometimes wake up even though there is no data available. 		 */
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
condition|)
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
comment|/* 			 * An error has encountered.  Perhaps there is a 			 * network problem. 			 */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"Read from remote host %.300s: %.100s\r\n"
argument_list|,
name|host
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|packet_process_incoming
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|client_status_confirm
parameter_list|(
name|int
name|type
parameter_list|,
name|Channel
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|channel_reply_ctx
modifier|*
name|cr
init|=
operator|(
expr|struct
name|channel_reply_ctx
operator|*
operator|)
name|ctx
decl_stmt|;
name|char
name|errmsg
index|[
literal|256
index|]
decl_stmt|;
name|int
name|tochan
decl_stmt|;
comment|/* 	 * If a TTY was explicitly requested, then a failure to allocate 	 * one is fatal. 	 */
if|if
condition|(
name|cr
operator|->
name|action
operator|==
name|CONFIRM_TTY
operator|&&
operator|(
name|options
operator|.
name|request_tty
operator|==
name|REQUEST_TTY_FORCE
operator|||
name|options
operator|.
name|request_tty
operator|==
name|REQUEST_TTY_YES
operator|)
condition|)
name|cr
operator|->
name|action
operator|=
name|CONFIRM_CLOSE
expr_stmt|;
comment|/* XXX supress on mux _client_ quietmode */
name|tochan
operator|=
name|options
operator|.
name|log_level
operator|>=
name|SYSLOG_LEVEL_ERROR
operator|&&
name|c
operator|->
name|ctl_chan
operator|!=
operator|-
literal|1
operator|&&
name|c
operator|->
name|extended_usage
operator|==
name|CHAN_EXTENDED_WRITE
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SSH2_MSG_CHANNEL_SUCCESS
condition|)
block|{
name|debug2
argument_list|(
literal|"%s request accepted on channel %d"
argument_list|,
name|cr
operator|->
name|request_type
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SSH2_MSG_CHANNEL_FAILURE
condition|)
block|{
if|if
condition|(
name|tochan
condition|)
block|{
name|snprintf
argument_list|(
name|errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|errmsg
argument_list|)
argument_list|,
literal|"%s request failed\r\n"
argument_list|,
name|cr
operator|->
name|request_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|errmsg
argument_list|)
argument_list|,
literal|"%s request failed on channel %d"
argument_list|,
name|cr
operator|->
name|request_type
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
comment|/* If error occurred on primary session channel, then exit */
if|if
condition|(
name|cr
operator|->
name|action
operator|==
name|CONFIRM_CLOSE
operator|&&
name|c
operator|->
name|self
operator|==
name|session_ident
condition|)
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
comment|/* 		 * If error occurred on mux client, append to 		 * their stderr. 		 */
if|if
condition|(
name|tochan
condition|)
block|{
name|buffer_append
argument_list|(
operator|&
name|c
operator|->
name|extended
argument_list|,
name|errmsg
argument_list|,
name|strlen
argument_list|(
name|errmsg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|action
operator|==
name|CONFIRM_TTY
condition|)
block|{
comment|/* 			 * If a TTY allocation error occurred, then arrange 			 * for the correct TTY to leave raw mode. 			 */
if|if
condition|(
name|c
operator|->
name|self
operator|==
name|session_ident
condition|)
name|leave_raw_mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|mux_tty_alloc_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cr
operator|->
name|action
operator|==
name|CONFIRM_CLOSE
condition|)
block|{
name|chan_read_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|chan_write_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_abandon_status_confirm
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_expect_confirm
parameter_list|(
name|int
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|request
parameter_list|,
name|enum
name|confirm_action
name|action
parameter_list|)
block|{
name|struct
name|channel_reply_ctx
modifier|*
name|cr
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cr
argument_list|)
argument_list|)
decl_stmt|;
name|cr
operator|->
name|request_type
operator|=
name|request
expr_stmt|;
name|cr
operator|->
name|action
operator|=
name|action
expr_stmt|;
name|channel_register_status_confirm
argument_list|(
name|id
argument_list|,
name|client_status_confirm
argument_list|,
name|client_abandon_status_confirm
argument_list|,
name|cr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_register_global_confirm
parameter_list|(
name|global_confirm_cb
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|global_confirm
modifier|*
name|gc
decl_stmt|,
modifier|*
name|last_gc
decl_stmt|;
comment|/* Coalesce identical callbacks */
name|last_gc
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|global_confirms
argument_list|,
name|global_confirms
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_gc
operator|&&
name|last_gc
operator|->
name|cb
operator|==
name|cb
operator|&&
name|last_gc
operator|->
name|ctx
operator|==
name|ctx
condition|)
block|{
if|if
condition|(
operator|++
name|last_gc
operator|->
name|ref_count
operator|>=
name|INT_MAX
condition|)
name|fatal
argument_list|(
literal|"%s: last_gc->ref_count = %d"
argument_list|,
name|__func__
argument_list|,
name|last_gc
operator|->
name|ref_count
argument_list|)
expr_stmt|;
return|return;
block|}
name|gc
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gc
argument_list|)
argument_list|)
expr_stmt|;
name|gc
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|gc
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
name|gc
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|global_confirms
argument_list|,
name|gc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_cmdline
parameter_list|(
name|void
parameter_list|)
block|{
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|cmd
decl_stmt|;
name|int
name|ok
decl_stmt|,
name|delete
init|=
literal|0
decl_stmt|,
name|local
init|=
literal|0
decl_stmt|,
name|remote
init|=
literal|0
decl_stmt|,
name|dynamic
init|=
literal|0
decl_stmt|;
name|struct
name|Forward
name|fwd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fwd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fwd
argument_list|)
argument_list|)
expr_stmt|;
name|leave_raw_mode
argument_list|(
name|options
operator|.
name|request_tty
operator|==
name|REQUEST_TTY_FORCE
argument_list|)
expr_stmt|;
name|handler
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|s
operator|=
name|read_passphrase
argument_list|(
literal|"\r\nssh> "
argument_list|,
name|RP_ECHO
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Skip cmdline '-', if any */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'h'
operator|||
operator|*
name|s
operator|==
literal|'H'
operator|||
operator|*
name|s
operator|==
literal|'?'
condition|)
block|{
name|logit
argument_list|(
literal|"Commands:"
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"      -L[bind_address:]port:host:hostport    "
literal|"Request local forward"
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"      -R[bind_address:]port:host:hostport    "
literal|"Request remote forward"
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"      -D[bind_address:]port                  "
literal|"Request dynamic forward"
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"      -KL[bind_address:]port                 "
literal|"Cancel local forward"
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"      -KR[bind_address:]port                 "
literal|"Cancel remote forward"
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"      -KD[bind_address:]port                 "
literal|"Cancel dynamic forward"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|permit_local_command
condition|)
goto|goto
name|out
goto|;
name|logit
argument_list|(
literal|"      !args                                  "
literal|"Execute local command"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'!'
operator|&&
name|options
operator|.
name|permit_local_command
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|ssh_local_cmd
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'K'
condition|)
block|{
name|delete
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'L'
condition|)
name|local
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'R'
condition|)
name|remote
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'D'
condition|)
name|dynamic
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|logit
argument_list|(
literal|"Invalid command."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|delete
operator|&&
operator|!
name|compat20
condition|)
block|{
name|logit
argument_list|(
literal|"Not supported for SSH protocol version 1."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
operator|*
operator|++
name|s
argument_list|)
condition|)
empty_stmt|;
comment|/* XXX update list of forwards in options */
if|if
condition|(
name|delete
condition|)
block|{
comment|/* We pass 1 for dynamicfwd to restrict to 1 or 2 fields. */
if|if
condition|(
operator|!
name|parse_forward
argument_list|(
operator|&
name|fwd
argument_list|,
name|s
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"Bad forwarding close specification."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|remote
condition|)
name|ok
operator|=
name|channel_request_rforward_cancel
argument_list|(
operator|&
name|fwd
argument_list|)
operator|==
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dynamic
condition|)
name|ok
operator|=
name|channel_cancel_lport_listener
argument_list|(
operator|&
name|fwd
argument_list|,
literal|0
argument_list|,
operator|&
name|options
operator|.
name|fwd_opts
argument_list|)
operator|>
literal|0
expr_stmt|;
else|else
name|ok
operator|=
name|channel_cancel_lport_listener
argument_list|(
operator|&
name|fwd
argument_list|,
name|CHANNEL_CANCEL_PORT_STATIC
argument_list|,
operator|&
name|options
operator|.
name|fwd_opts
argument_list|)
operator|>
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|logit
argument_list|(
literal|"Unknown port forwarding."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|logit
argument_list|(
literal|"Canceled forwarding."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|parse_forward
argument_list|(
operator|&
name|fwd
argument_list|,
name|s
argument_list|,
name|dynamic
argument_list|,
name|remote
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"Bad forwarding specification."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|local
operator|||
name|dynamic
condition|)
block|{
if|if
condition|(
operator|!
name|channel_setup_local_fwd_listener
argument_list|(
operator|&
name|fwd
argument_list|,
operator|&
name|options
operator|.
name|fwd_opts
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"Port forwarding failed."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|channel_request_remote_forwarding
argument_list|(
operator|&
name|fwd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"Port forwarding failed."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|logit
argument_list|(
literal|"Forwarding port."
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|enter_raw_mode
argument_list|(
name|options
operator|.
name|request_tty
operator|==
name|REQUEST_TTY_FORCE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fwd
operator|.
name|listen_host
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fwd
operator|.
name|listen_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fwd
operator|.
name|connect_host
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fwd
operator|.
name|connect_path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* reasons to suppress output of an escape command in help output */
end_comment

begin_define
define|#
directive|define
name|SUPPRESS_NEVER
value|0
end_define

begin_comment
comment|/* never suppress, always show */
end_comment

begin_define
define|#
directive|define
name|SUPPRESS_PROTO1
value|1
end_define

begin_comment
comment|/* don't show in protocol 1 sessions */
end_comment

begin_define
define|#
directive|define
name|SUPPRESS_MUXCLIENT
value|2
end_define

begin_comment
comment|/* don't show in mux client sessions */
end_comment

begin_define
define|#
directive|define
name|SUPPRESS_MUXMASTER
value|4
end_define

begin_comment
comment|/* don't show in mux master sessions */
end_comment

begin_define
define|#
directive|define
name|SUPPRESS_SYSLOG
value|8
end_define

begin_comment
comment|/* don't show when logging to syslog */
end_comment

begin_struct
struct|struct
name|escape_help_text
block|{
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|escape_help_text
name|esc_txt
index|[]
init|=
block|{
block|{
literal|"."
block|,
literal|"terminate session"
block|,
name|SUPPRESS_MUXMASTER
block|}
block|,
block|{
literal|"."
block|,
literal|"terminate connection (and any multiplexed sessions)"
block|,
name|SUPPRESS_MUXCLIENT
block|}
block|,
block|{
literal|"B"
block|,
literal|"send a BREAK to the remote system"
block|,
name|SUPPRESS_PROTO1
block|}
block|,
block|{
literal|"C"
block|,
literal|"open a command line"
block|,
name|SUPPRESS_MUXCLIENT
block|}
block|,
block|{
literal|"R"
block|,
literal|"request rekey"
block|,
name|SUPPRESS_PROTO1
block|}
block|,
block|{
literal|"V/v"
block|,
literal|"decrease/increase verbosity (LogLevel)"
block|,
name|SUPPRESS_MUXCLIENT
block|}
block|,
block|{
literal|"^Z"
block|,
literal|"suspend ssh"
block|,
name|SUPPRESS_MUXCLIENT
block|}
block|,
block|{
literal|"#"
block|,
literal|"list forwarded connections"
block|,
name|SUPPRESS_NEVER
block|}
block|,
block|{
literal|"&"
block|,
literal|"background ssh (when waiting for connections to terminate)"
block|,
name|SUPPRESS_MUXCLIENT
block|}
block|,
block|{
literal|"?"
block|,
literal|"this message"
block|,
name|SUPPRESS_NEVER
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|print_escape_help
parameter_list|(
name|Buffer
modifier|*
name|b
parameter_list|,
name|int
name|escape_char
parameter_list|,
name|int
name|protocol2
parameter_list|,
name|int
name|mux_client
parameter_list|,
name|int
name|using_stderr
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|suppress_flags
decl_stmt|;
name|char
name|string
index|[
literal|1024
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c?\r\n"
literal|"Supported escape sequences:\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|b
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|suppress_flags
operator|=
operator|(
name|protocol2
condition|?
literal|0
else|:
name|SUPPRESS_PROTO1
operator|)
operator||
operator|(
name|mux_client
condition|?
name|SUPPRESS_MUXCLIENT
else|:
literal|0
operator|)
operator||
operator|(
name|mux_client
condition|?
literal|0
else|:
name|SUPPRESS_MUXMASTER
operator|)
operator||
operator|(
name|using_stderr
condition|?
literal|0
else|:
name|SUPPRESS_SYSLOG
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|esc_txt
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|esc_txt
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|esc_txt
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|suppress_flags
condition|)
continue|continue;
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|" %c%-3s - %s\r\n"
argument_list|,
name|escape_char
argument_list|,
name|esc_txt
index|[
name|i
index|]
operator|.
name|cmd
argument_list|,
name|esc_txt
index|[
name|i
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|b
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|" %c%c   - send the escape character by typing it twice\r\n"
literal|"(Note that escapes are only recognized immediately after "
literal|"newline.)\r\n"
argument_list|,
name|escape_char
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|b
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Process the characters one by one, call with c==NULL for proto1 case.  */
end_comment

begin_function
specifier|static
name|int
name|process_escapes
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|Buffer
modifier|*
name|bin
parameter_list|,
name|Buffer
modifier|*
name|bout
parameter_list|,
name|Buffer
modifier|*
name|berr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
name|string
index|[
literal|1024
index|]
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|bytes
init|=
literal|0
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_char
name|ch
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
modifier|*
name|escape_pendingp
decl_stmt|,
name|escape_char
decl_stmt|;
name|struct
name|escape_filter_ctx
modifier|*
name|efc
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|escape_pendingp
operator|=
operator|&
name|escape_pending1
expr_stmt|;
name|escape_char
operator|=
name|escape_char1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|filter_ctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|efc
operator|=
operator|(
expr|struct
name|escape_filter_ctx
operator|*
operator|)
name|c
operator|->
name|filter_ctx
expr_stmt|;
name|escape_pendingp
operator|=
operator|&
name|efc
operator|->
name|escape_pending
expr_stmt|;
name|escape_char
operator|=
name|efc
operator|->
name|escape_char
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|u_int
operator|)
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get one character at a time. */
name|ch
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|escape_pendingp
condition|)
block|{
comment|/* We have previously seen an escape character. */
comment|/* Clear the flag now. */
operator|*
name|escape_pendingp
operator|=
literal|0
expr_stmt|;
comment|/* Process the escaped character. */
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'.'
case|:
comment|/* Terminate the connection. */
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c.\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&&
name|c
operator|->
name|ctl_chan
operator|!=
operator|-
literal|1
condition|)
block|{
name|chan_read_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|chan_write_failed
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|detach_user
condition|)
name|c
operator|->
name|detach_user
argument_list|(
name|c
operator|->
name|self
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|SSH_CHANNEL_ABANDONED
expr_stmt|;
name|buffer_clear
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|)
expr_stmt|;
name|chan_ibuf_empty
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|'Z'
operator|-
literal|64
case|:
comment|/* XXX support this for mux clients */
if|if
condition|(
name|c
operator|&&
name|c
operator|->
name|ctl_chan
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
name|b
index|[
literal|16
index|]
decl_stmt|;
name|noescape
label|:
if|if
condition|(
name|ch
operator|==
literal|'Z'
operator|-
literal|64
condition|)
name|snprintf
argument_list|(
name|b
argument_list|,
sizeof|sizeof
name|b
argument_list|,
literal|"^Z"
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|b
argument_list|,
sizeof|sizeof
name|b
argument_list|,
literal|"%c"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c%s escape not available to "
literal|"multiplexed sessions\r\n"
argument_list|,
name|escape_char
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Suspend the program. Inform the user */
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c^Z [suspend ssh]\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore terminal modes and suspend. */
name|client_suspend_self
argument_list|(
name|bin
argument_list|,
name|bout
argument_list|,
name|berr
argument_list|)
expr_stmt|;
comment|/* We have been continued. */
continue|continue;
case|case
literal|'B'
case|:
if|if
condition|(
name|compat20
condition|)
block|{
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%cB\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|channel_request_start
argument_list|(
name|c
operator|->
name|self
argument_list|,
literal|"break"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
continue|continue;
case|case
literal|'R'
case|:
if|if
condition|(
name|compat20
condition|)
block|{
if|if
condition|(
name|datafellows
operator|&
name|SSH_BUG_NOREKEY
condition|)
name|logit
argument_list|(
literal|"Server does not "
literal|"support re-keying"
argument_list|)
expr_stmt|;
else|else
name|need_rekeying
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'V'
case|:
comment|/* FALLTHROUGH */
case|case
literal|'v'
case|:
if|if
condition|(
name|c
operator|&&
name|c
operator|->
name|ctl_chan
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|noescape
goto|;
if|if
condition|(
operator|!
name|log_is_on_stderr
argument_list|()
condition|)
block|{
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c%c [Logging to syslog]\r\n"
argument_list|,
name|escape_char
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ch
operator|==
literal|'V'
operator|&&
name|options
operator|.
name|log_level
operator|>
name|SYSLOG_LEVEL_QUIET
condition|)
name|log_change_level
argument_list|(
operator|--
name|options
operator|.
name|log_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'v'
operator|&&
name|options
operator|.
name|log_level
operator|<
name|SYSLOG_LEVEL_DEBUG3
condition|)
name|log_change_level
argument_list|(
operator|++
name|options
operator|.
name|log_level
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c%c [LogLevel %s]\r\n"
argument_list|,
name|escape_char
argument_list|,
name|ch
argument_list|,
name|log_level_name
argument_list|(
name|options
operator|.
name|log_level
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'&'
case|:
if|if
condition|(
name|c
operator|&&
name|c
operator|->
name|ctl_chan
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|noescape
goto|;
comment|/* 				 * Detach the program (continue to serve 				 * connections, but put in background and no 				 * more new connections). 				 */
comment|/* Restore tty modes. */
name|leave_raw_mode
argument_list|(
name|options
operator|.
name|request_tty
operator|==
name|REQUEST_TTY_FORCE
argument_list|)
expr_stmt|;
comment|/* Stop listening for new connections. */
name|channel_stop_listening
argument_list|()
expr_stmt|;
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c& [backgrounded]\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fork into background. */
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"fork: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pid
operator|!=
literal|0
condition|)
block|{
comment|/* This is the parent. */
comment|/* The parent just exits. */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The child continues serving connections. */
if|if
condition|(
name|compat20
condition|)
block|{
name|buffer_append
argument_list|(
name|bin
argument_list|,
literal|"\004"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* fake EOF on stdin */
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|stdin_eof
condition|)
block|{
comment|/* 					 * Sending SSH_CMSG_EOF alone does not 					 * always appear to be enough.  So we 					 * try to send an EOF character first. 					 */
name|packet_start
argument_list|(
name|SSH_CMSG_STDIN_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
literal|"\004"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* Close stdin. */
name|stdin_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
name|bin
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
continue|continue;
case|case
literal|'?'
case|:
name|print_escape_help
argument_list|(
name|berr
argument_list|,
name|escape_char
argument_list|,
name|compat20
argument_list|,
operator|(
name|c
operator|&&
name|c
operator|->
name|ctl_chan
operator|!=
operator|-
literal|1
operator|)
argument_list|,
name|log_is_on_stderr
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'#'
case|:
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c#\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|channel_open_message
argument_list|()
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'C'
case|:
if|if
condition|(
name|c
operator|&&
name|c
operator|->
name|ctl_chan
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|noescape
goto|;
name|process_cmdline
argument_list|()
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
name|ch
operator|!=
name|escape_char
condition|)
block|{
name|buffer_put_char
argument_list|(
name|bin
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
block|}
comment|/* Escaped characters fall through here */
break|break;
block|}
block|}
else|else
block|{
comment|/* 			 * The previous character was not an escape char. 			 * Check if this is an escape. 			 */
if|if
condition|(
name|last_was_cr
operator|&&
name|ch
operator|==
name|escape_char
condition|)
block|{
comment|/* 				 * It is. Set the flag and continue to 				 * next character. 				 */
operator|*
name|escape_pendingp
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Normal character.  Record whether it was a newline, 		 * and append it to the buffer. 		 */
name|last_was_cr
operator|=
operator|(
name|ch
operator|==
literal|'\r'
operator|||
name|ch
operator|==
literal|'\n'
operator|)
expr_stmt|;
name|buffer_put_char
argument_list|(
name|bin
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_process_input
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
name|SSH_IOBUFSZ
index|]
decl_stmt|;
comment|/* Read input from stdin. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|readset
argument_list|)
condition|)
block|{
comment|/* Read as much as possible. */
name|len
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
condition|)
return|return;
comment|/* we'll try again later */
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
comment|/* 			 * Received EOF or error.  They are treated 			 * similarly, except that an error message is printed 			 * if it was an error condition. 			 */
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"read: %.100s\r\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Mark that we have seen EOF. */
name|stdin_eof
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Send an EOF message to the server unless there is 			 * data in the buffer.  If there is data in the 			 * buffer, no message will be sent now.  Code 			 * elsewhere will send the EOF when the buffer 			 * becomes empty if stdin_eof is set. 			 */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|escape_char1
operator|==
name|SSH_ESCAPECHAR_NONE
condition|)
block|{
comment|/* 			 * Normal successful read, and no escape character. 			 * Just append the data to buffer. 			 */
name|buffer_append
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Normal, successful read.  But we have an escape 			 * character and have to process the characters one 			 * by one. 			 */
if|if
condition|(
name|process_escapes
argument_list|(
name|NULL
argument_list|,
operator|&
name|stdin_buffer
argument_list|,
operator|&
name|stdout_buffer
argument_list|,
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|client_process_output
parameter_list|(
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* Write buffered output to stdout. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|writeset
argument_list|)
condition|)
block|{
comment|/* Write as much data as possible. */
name|len
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|)
name|len
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 				 * An error or EOF was encountered.  Put an 				 * error message to stderr buffer. 				 */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"write stdout: %.50s\r\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
comment|/* Consume printed data from the buffer. */
name|buffer_consume
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Write buffered output to stderr. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|writeset
argument_list|)
condition|)
block|{
comment|/* Write as much data as possible. */
name|len
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|)
name|len
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 				 * EOF or error, but can't even print 				 * error message. 				 */
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
comment|/* Consume printed characters from the buffer. */
name|buffer_consume
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get packets from the connection input buffer, and process them as long as  * there are packets available.  *  * Any unknown packets received during the actual  * session cause the session to terminate.  This is  * intended to make debugging easier since no  * confirmations are sent.  Any compatible protocol  * extensions must be negotiated during the  * preparatory phase.  */
end_comment

begin_function
specifier|static
name|void
name|client_process_buffered_input_packets
parameter_list|(
name|void
parameter_list|)
block|{
name|dispatch_run
argument_list|(
name|DISPATCH_NONBLOCK
argument_list|,
operator|&
name|quit_pending
argument_list|,
name|active_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* scan buf[] for '~' before sending data to the peer */
end_comment

begin_comment
comment|/* Helper: allocate a new escape_filter_ctx and fill in its escape char */
end_comment

begin_function
name|void
modifier|*
name|client_new_escape_filter_ctx
parameter_list|(
name|int
name|escape_char
parameter_list|)
block|{
name|struct
name|escape_filter_ctx
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|escape_pending
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|escape_char
operator|=
name|escape_char
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Free the escape filter context on channel free */
end_comment

begin_function
name|void
name|client_filter_cleanup
parameter_list|(
name|int
name|cid
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|client_simple_escape_filter
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|extended_usage
operator|!=
name|CHAN_EXTENDED_WRITE
condition|)
return|return
literal|0
return|;
return|return
name|process_escapes
argument_list|(
name|c
argument_list|,
operator|&
name|c
operator|->
name|input
argument_list|,
operator|&
name|c
operator|->
name|output
argument_list|,
operator|&
name|c
operator|->
name|extended
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_channel_closed
parameter_list|(
name|int
name|id
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|channel_cancel_cleanup
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|session_closed
operator|=
literal|1
expr_stmt|;
name|leave_raw_mode
argument_list|(
name|options
operator|.
name|request_tty
operator|==
name|REQUEST_TTY_FORCE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Implements the interactive session with the server.  This is called after  * the user has been authenticated, and a command has been started on the  * remote host.  If escape_char != SSH_ESCAPECHAR_NONE, it is the character  * used as an escape character for terminating or suspending the session.  */
end_comment

begin_function
name|int
name|client_loop
parameter_list|(
name|int
name|have_pty
parameter_list|,
name|int
name|escape_char_arg
parameter_list|,
name|int
name|ssh2_chan_id
parameter_list|)
block|{
name|fd_set
modifier|*
name|readset
init|=
name|NULL
decl_stmt|,
modifier|*
name|writeset
init|=
name|NULL
decl_stmt|;
name|double
name|start_time
decl_stmt|,
name|total_time
decl_stmt|;
name|int
name|r
decl_stmt|,
name|max_fd
init|=
literal|0
decl_stmt|,
name|max_fd2
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
name|u_int64_t
name|ibytes
decl_stmt|,
name|obytes
decl_stmt|;
name|u_int
name|nalloc
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|debug
argument_list|(
literal|"Entering interactive session."
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|control_master
operator|&&
operator|!
name|option_clear_or_none
argument_list|(
name|options
operator|.
name|control_path
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"pledge: id"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pledge
argument_list|(
literal|"stdio rpath wpath cpath unix inet dns recvfd proc exec id tty"
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s pledge(): %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|options
operator|.
name|forward_x11
operator|||
name|options
operator|.
name|permit_local_command
condition|)
block|{
name|debug
argument_list|(
literal|"pledge: exec"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pledge
argument_list|(
literal|"stdio rpath wpath cpath unix inet dns proc exec tty"
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s pledge(): %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|options
operator|.
name|update_hostkeys
condition|)
block|{
name|debug
argument_list|(
literal|"pledge: filesystem full"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pledge
argument_list|(
literal|"stdio rpath wpath cpath unix inet dns proc tty"
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s pledge(): %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|option_clear_or_none
argument_list|(
name|options
operator|.
name|proxy_command
argument_list|)
operator|||
name|fork_after_authentication_flag
condition|)
block|{
name|debug
argument_list|(
literal|"pledge: proc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pledge
argument_list|(
literal|"stdio cpath unix inet dns proc tty"
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s pledge(): %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"pledge: network"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pledge
argument_list|(
literal|"stdio unix inet dns tty"
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s pledge(): %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|start_time
operator|=
name|get_current_time
argument_list|()
expr_stmt|;
comment|/* Initialize variables. */
name|escape_pending1
operator|=
literal|0
expr_stmt|;
name|last_was_cr
operator|=
literal|1
expr_stmt|;
name|exit_status
operator|=
operator|-
literal|1
expr_stmt|;
name|stdin_eof
operator|=
literal|0
expr_stmt|;
name|buffer_high
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
name|connection_in
operator|=
name|packet_get_connection_in
argument_list|()
expr_stmt|;
name|connection_out
operator|=
name|packet_get_connection_out
argument_list|()
expr_stmt|;
name|max_fd
operator|=
name|MAXIMUM
argument_list|(
name|connection_in
argument_list|,
name|connection_out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compat20
condition|)
block|{
comment|/* enable nonblocking unless tty */
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|set_nonblock
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
condition|)
name|set_nonblock
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
condition|)
name|set_nonblock
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
expr_stmt|;
name|max_fd
operator|=
name|MAXIMUM
argument_list|(
name|max_fd
argument_list|,
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|max_fd
operator|=
name|MAXIMUM
argument_list|(
name|max_fd
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|max_fd
operator|=
name|MAXIMUM
argument_list|(
name|max_fd
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|quit_pending
operator|=
literal|0
expr_stmt|;
name|escape_char1
operator|=
name|escape_char_arg
expr_stmt|;
comment|/* Initialize buffers. */
name|buffer_init
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
name|client_init_dispatch
argument_list|()
expr_stmt|;
comment|/* 	 * Set signal handlers, (e.g. to restore non-blocking mode) 	 * but don't overwrite SIG_IGN, matches behaviour from rsh(1) 	 */
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|window_change_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_pty
condition|)
name|enter_raw_mode
argument_list|(
name|options
operator|.
name|request_tty
operator|==
name|REQUEST_TTY_FORCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|session_ident
operator|=
name|ssh2_chan_id
expr_stmt|;
if|if
condition|(
name|session_ident
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|escape_char_arg
operator|!=
name|SSH_ESCAPECHAR_NONE
condition|)
block|{
name|channel_register_filter
argument_list|(
name|session_ident
argument_list|,
name|client_simple_escape_filter
argument_list|,
name|NULL
argument_list|,
name|client_filter_cleanup
argument_list|,
name|client_new_escape_filter_ctx
argument_list|(
name|escape_char_arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|channel_register_cleanup
argument_list|(
name|session_ident
argument_list|,
name|client_channel_closed
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Check if we should immediately send eof on stdin. */
name|client_check_initial_eof_on_stdin
argument_list|()
expr_stmt|;
block|}
comment|/* Main loop of the client for the interactive session mode. */
while|while
condition|(
operator|!
name|quit_pending
condition|)
block|{
comment|/* Process buffered packets sent by the server. */
name|client_process_buffered_input_packets
argument_list|()
expr_stmt|;
if|if
condition|(
name|compat20
operator|&&
name|session_closed
operator|&&
operator|!
name|channel_still_open
argument_list|()
condition|)
break|break;
if|if
condition|(
name|ssh_packet_is_rekeying
argument_list|(
name|active_state
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"rekeying in progress"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|need_rekeying
condition|)
block|{
comment|/* manual rekey request */
name|debug
argument_list|(
literal|"need rekeying"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|kex_start_rekex
argument_list|(
name|active_state
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: kex_start_rekex: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|need_rekeying
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Make packets of buffered stdin data, and buffer 			 * them for sending to the server. 			 */
if|if
condition|(
operator|!
name|compat20
condition|)
name|client_make_packets_from_stdin_data
argument_list|()
expr_stmt|;
comment|/* 			 * Make packets from buffered channel data, and 			 * enqueue them for sending to the server. 			 */
if|if
condition|(
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
name|channel_output_poll
argument_list|()
expr_stmt|;
comment|/* 			 * Check if the window size has changed, and buffer a 			 * message about it to the server if so. 			 */
name|client_check_window_change
argument_list|()
expr_stmt|;
if|if
condition|(
name|quit_pending
condition|)
break|break;
block|}
comment|/* 		 * Wait until we have something to do (something becomes 		 * available on one of the descriptors). 		 */
name|max_fd2
operator|=
name|max_fd
expr_stmt|;
name|client_wait_until_can_do_something
argument_list|(
operator|&
name|readset
argument_list|,
operator|&
name|writeset
argument_list|,
operator|&
name|max_fd2
argument_list|,
operator|&
name|nalloc
argument_list|,
name|ssh_packet_is_rekeying
argument_list|(
name|active_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|quit_pending
condition|)
break|break;
comment|/* Do channel operations unless rekeying in progress. */
if|if
condition|(
operator|!
name|ssh_packet_is_rekeying
argument_list|(
name|active_state
argument_list|)
condition|)
name|channel_after_select
argument_list|(
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
comment|/* Buffer input from the connection.  */
name|client_process_net_input
argument_list|(
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
name|quit_pending
condition|)
break|break;
if|if
condition|(
operator|!
name|compat20
condition|)
block|{
comment|/* Buffer data from stdin */
name|client_process_input
argument_list|(
name|readset
argument_list|)
expr_stmt|;
comment|/* 			 * Process output to stdout and stderr.  Output to 			 * the connection is processed elsewhere (above). 			 */
name|client_process_output
argument_list|(
name|writeset
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Send as much buffered packet data as possible to the 		 * sender. 		 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_out
argument_list|,
name|writeset
argument_list|)
condition|)
name|packet_write_poll
argument_list|()
expr_stmt|;
comment|/* 		 * If we are a backgrounded control master, and the 		 * timeout has expired without any active client 		 * connections, then quit. 		 */
if|if
condition|(
name|control_persist_exit_time
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|monotime
argument_list|()
operator|>=
name|control_persist_exit_time
condition|)
block|{
name|debug
argument_list|(
literal|"ControlPersist timeout expired"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|free
argument_list|(
name|readset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|writeset
argument_list|)
expr_stmt|;
comment|/* Terminate the session. */
comment|/* Stop watching for window change. */
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_DISCONNECT
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|SSH2_DISCONNECT_BY_APPLICATION
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"disconnected by user"
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* language tag */
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
block|}
name|channel_free_all
argument_list|()
expr_stmt|;
if|if
condition|(
name|have_pty
condition|)
name|leave_raw_mode
argument_list|(
name|options
operator|.
name|request_tty
operator|==
name|REQUEST_TTY_FORCE
argument_list|)
expr_stmt|;
comment|/* restore blocking io */
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|unset_nonblock
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
condition|)
name|unset_nonblock
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
condition|)
name|unset_nonblock
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If there was no shell or command requested, there will be no remote 	 * exit status to be returned.  In that case, clear error code if the 	 * connection was deliberately terminated at this end. 	 */
if|if
condition|(
name|no_shell_flag
operator|&&
name|received_signal
operator|==
name|SIGTERM
condition|)
block|{
name|received_signal
operator|=
literal|0
expr_stmt|;
name|exit_status
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|received_signal
condition|)
name|fatal
argument_list|(
literal|"Killed by signal %d."
argument_list|,
operator|(
name|int
operator|)
name|received_signal
argument_list|)
expr_stmt|;
comment|/* 	 * In interactive mode (with pseudo tty) display a message indicating 	 * that the connection has been closed. 	 */
if|if
condition|(
name|have_pty
operator|&&
name|options
operator|.
name|log_level
operator|!=
name|SYSLOG_LEVEL_QUIET
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"Connection to %.64s closed.\r\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Output any buffered data for stdout. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
operator|(
name|u_int
operator|)
name|len
operator|!=
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
condition|)
name|error
argument_list|(
literal|"Write failed flushing stdout buffer."
argument_list|)
expr_stmt|;
else|else
name|buffer_consume
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Output any buffered data for stderr. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
operator|(
name|u_int
operator|)
name|len
operator|!=
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
condition|)
name|error
argument_list|(
literal|"Write failed flushing stderr buffer."
argument_list|)
expr_stmt|;
else|else
name|buffer_consume
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Clear and free any buffers. */
name|explicit_bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
comment|/* Report bytes transferred, and transfer rates. */
name|total_time
operator|=
name|get_current_time
argument_list|()
operator|-
name|start_time
expr_stmt|;
name|packet_get_bytes
argument_list|(
operator|&
name|ibytes
argument_list|,
operator|&
name|obytes
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
literal|"Transferred: sent %llu, received %llu bytes, in %.1f seconds"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|obytes
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ibytes
argument_list|,
name|total_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_time
operator|>
literal|0
condition|)
name|verbose
argument_list|(
literal|"Bytes per second: sent %.1f, received %.1f"
argument_list|,
name|obytes
operator|/
name|total_time
argument_list|,
name|ibytes
operator|/
name|total_time
argument_list|)
expr_stmt|;
comment|/* Return the exit status of the program. */
name|debug
argument_list|(
literal|"Exit status %d"
argument_list|,
name|exit_status
argument_list|)
expr_stmt|;
return|return
name|exit_status
return|;
block|}
end_function

begin_comment
comment|/*********/
end_comment

begin_function
specifier|static
name|int
name|client_input_stdout_data
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|u_int
name|data_len
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
decl_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|client_input_stderr_data
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|u_int
name|data_len
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
decl_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|client_input_exit_status
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|exit_status
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
comment|/* Acknowledge the exit. */
name|packet_start
argument_list|(
name|SSH_CMSG_EXIT_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* 	 * Must wait for packet to be sent since we are 	 * exiting the loop. 	 */
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Flag that we want to exit. */
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|client_input_agent_open
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|int
name|r
decl_stmt|,
name|remote_id
decl_stmt|,
name|sock
decl_stmt|;
comment|/* Read the remote channel number from the message. */
name|remote_id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
comment|/* 	 * Get a connection to the local authentication agent (this may again 	 * get forwarded). 	 */
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_get_authentication_socket
argument_list|(
operator|&
name|sock
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|r
operator|!=
name|SSH_ERR_AGENT_NOT_PRESENT
condition|)
name|debug
argument_list|(
literal|"%s: ssh_get_authentication_socket: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we could not connect the agent, send an error message back to 	 * the server. This should never happen unless the agent dies, 	 * because authentication forwarding is only enabled if we have an 	 * agent. 	 */
if|if
condition|(
name|sock
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|channel_new
argument_list|(
literal|""
argument_list|,
name|SSH_CHANNEL_OPEN
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"authentication agent connection"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
name|remote_id
expr_stmt|;
name|c
operator|->
name|force_drain
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Send a confirmation to the remote host. */
name|debug
argument_list|(
literal|"Forwarding authentication connection."
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|Channel
modifier|*
name|client_request_forwarded_tcpip
parameter_list|(
specifier|const
name|char
modifier|*
name|request_type
parameter_list|,
name|int
name|rchan
parameter_list|,
name|u_int
name|rwindow
parameter_list|,
name|u_int
name|rmaxpack
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|listen_address
decl_stmt|,
modifier|*
name|originator_address
decl_stmt|;
name|u_short
name|listen_port
decl_stmt|,
name|originator_port
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Get rest of the packet */
name|listen_address
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|listen_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|originator_address
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|originator_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"%s: listen %s port %d, originator %s port %d"
argument_list|,
name|__func__
argument_list|,
name|listen_address
argument_list|,
name|listen_port
argument_list|,
name|originator_address
argument_list|,
name|originator_port
argument_list|)
expr_stmt|;
name|c
operator|=
name|channel_connect_by_listen_address
argument_list|(
name|listen_address
argument_list|,
name|listen_port
argument_list|,
literal|"forwarded-tcpip"
argument_list|,
name|originator_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_MUX_CLIENT
condition|)
block|{
if|if
condition|(
operator|(
name|b
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: alloc reply"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* reconstruct and send to muxclient */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|||
comment|/* padlen */
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|b
argument_list|,
name|SSH2_MSG_CHANNEL_OPEN
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_cstring
argument_list|(
name|b
argument_list|,
name|request_type
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|b
argument_list|,
name|rchan
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|b
argument_list|,
name|rwindow
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|b
argument_list|,
name|rmaxpack
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_cstring
argument_list|(
name|b
argument_list|,
name|listen_address
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|b
argument_list|,
name|listen_port
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_cstring
argument_list|(
name|b
argument_list|,
name|originator_address
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|b
argument_list|,
name|originator_port
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_stringb
argument_list|(
operator|&
name|c
operator|->
name|output
argument_list|,
name|b
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: compose for muxclient %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
name|sshbuf_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|originator_address
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|listen_address
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|Channel
modifier|*
name|client_request_forwarded_streamlocal
parameter_list|(
specifier|const
name|char
modifier|*
name|request_type
parameter_list|,
name|int
name|rchan
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|listen_path
decl_stmt|;
comment|/* Get the remote path. */
name|listen_path
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX: Skip reserved field for now. */
if|if
condition|(
name|packet_get_string_ptr
argument_list|(
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: packet_get_string_ptr failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"%s: %s"
argument_list|,
name|__func__
argument_list|,
name|listen_path
argument_list|)
expr_stmt|;
name|c
operator|=
name|channel_connect_by_listen_path
argument_list|(
name|listen_path
argument_list|,
literal|"forwarded-streamlocal@openssh.com"
argument_list|,
literal|"forwarded-streamlocal"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|listen_path
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|Channel
modifier|*
name|client_request_x11
parameter_list|(
specifier|const
name|char
modifier|*
name|request_type
parameter_list|,
name|int
name|rchan
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|originator
decl_stmt|;
name|u_short
name|originator_port
decl_stmt|;
name|int
name|sock
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|forward_x11
condition|)
block|{
name|error
argument_list|(
literal|"Warning: ssh server tried X11 forwarding."
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Warning: this is probably a break-in attempt by a "
literal|"malicious server."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|x11_refuse_time
operator|!=
literal|0
operator|&&
operator|(
name|u_int
operator|)
name|monotime
argument_list|()
operator|>=
name|x11_refuse_time
condition|)
block|{
name|verbose
argument_list|(
literal|"Rejected X11 connection after ForwardX11Timeout "
literal|"expired"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|originator
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|datafellows
operator|&
name|SSH_BUG_X11FWD
condition|)
block|{
name|debug2
argument_list|(
literal|"buggy server: x11 request w/o originator_port"
argument_list|)
expr_stmt|;
name|originator_port
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|originator_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
block|}
name|packet_check_eom
argument_list|()
expr_stmt|;
comment|/* XXX check permission */
name|debug
argument_list|(
literal|"client_request_x11: request from %s %d"
argument_list|,
name|originator
argument_list|,
name|originator_port
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|originator
argument_list|)
expr_stmt|;
name|sock
operator|=
name|x11_connect_display
argument_list|()
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|c
operator|=
name|channel_new
argument_list|(
literal|"x11"
argument_list|,
name|SSH_CHANNEL_X11_OPEN
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_TCP_WINDOW_DEFAULT
argument_list|,
name|CHAN_X11_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|"x11"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|force_drain
operator|=
literal|1
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|Channel
modifier|*
name|client_request_agent
parameter_list|(
specifier|const
name|char
modifier|*
name|request_type
parameter_list|,
name|int
name|rchan
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|int
name|r
decl_stmt|,
name|sock
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|forward_agent
condition|)
block|{
name|error
argument_list|(
literal|"Warning: ssh server tried agent forwarding."
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Warning: this is probably a break-in attempt by a "
literal|"malicious server."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_get_authentication_socket
argument_list|(
operator|&
name|sock
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|!=
name|SSH_ERR_AGENT_NOT_PRESENT
condition|)
name|debug
argument_list|(
literal|"%s: ssh_get_authentication_socket: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|=
name|channel_new
argument_list|(
literal|"authentication agent connection"
argument_list|,
name|SSH_CHANNEL_OPEN
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_X11_WINDOW_DEFAULT
argument_list|,
name|CHAN_TCP_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|"authentication agent connection"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|force_drain
operator|=
literal|1
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|int
name|client_request_tun_fwd
parameter_list|(
name|int
name|tun_mode
parameter_list|,
name|int
name|local_tun
parameter_list|,
name|int
name|remote_tun
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|tun_mode
operator|==
name|SSH_TUNMODE_NO
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|compat20
condition|)
block|{
name|error
argument_list|(
literal|"Tunnel forwarding is not supported for protocol 1"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|debug
argument_list|(
literal|"Requesting tun unit %d in mode %d"
argument_list|,
name|local_tun
argument_list|,
name|tun_mode
argument_list|)
expr_stmt|;
comment|/* Open local tunnel device */
if|if
condition|(
operator|(
name|fd
operator|=
name|tun_open
argument_list|(
name|local_tun
argument_list|,
name|tun_mode
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Tunnel device open failed."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|c
operator|=
name|channel_new
argument_list|(
literal|"tun"
argument_list|,
name|SSH_CHANNEL_OPENING
argument_list|,
name|fd
argument_list|,
name|fd
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_TCP_WINDOW_DEFAULT
argument_list|,
name|CHAN_TCP_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|"tun"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|datagram
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SSH_TUN_FILTER
argument_list|)
if|if
condition|(
name|options
operator|.
name|tun_open
operator|==
name|SSH_TUNMODE_POINTOPOINT
condition|)
name|channel_register_filter
argument_list|(
name|c
operator|->
name|self
argument_list|,
name|sys_tun_infilter
argument_list|,
name|sys_tun_outfilter
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"tun@openssh.com"
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window_max
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|tun_mode
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|remote_tun
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* XXXX move to generic input handler */
end_comment

begin_function
specifier|static
name|int
name|client_input_channel_open
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ctype
decl_stmt|;
name|int
name|rchan
decl_stmt|;
name|u_int
name|rmaxpack
decl_stmt|,
name|rwindow
decl_stmt|,
name|len
decl_stmt|;
name|ctype
operator|=
name|packet_get_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|rchan
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|rwindow
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|rmaxpack
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"client_input_channel_open: ctype %s rchan %d win %d max %d"
argument_list|,
name|ctype
argument_list|,
name|rchan
argument_list|,
name|rwindow
argument_list|,
name|rmaxpack
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"forwarded-tcpip"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|client_request_forwarded_tcpip
argument_list|(
name|ctype
argument_list|,
name|rchan
argument_list|,
name|rwindow
argument_list|,
name|rmaxpack
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"forwarded-streamlocal@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|client_request_forwarded_streamlocal
argument_list|(
name|ctype
argument_list|,
name|rchan
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"x11"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|client_request_x11
argument_list|(
name|ctype
argument_list|,
name|rchan
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"auth-agent@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|client_request_agent
argument_list|(
name|ctype
argument_list|,
name|rchan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_MUX_CLIENT
condition|)
block|{
name|debug3
argument_list|(
literal|"proxied to downstream: %s"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"confirm %s"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
name|rchan
expr_stmt|;
name|c
operator|->
name|remote_window
operator|=
name|rwindow
expr_stmt|;
name|c
operator|->
name|remote_maxpacket
operator|=
name|rmaxpack
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_CONNECTING
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|debug
argument_list|(
literal|"failure %s"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|rchan
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|datafellows
operator|&
name|SSH_BUG_OPENFAILURE
operator|)
condition|)
block|{
name|packet_put_cstring
argument_list|(
literal|"open failed"
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|client_input_channel_req
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|int
name|exitval
decl_stmt|,
name|id
decl_stmt|,
name|reply
decl_stmt|,
name|success
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|rtype
decl_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel_proxy_upstream
argument_list|(
name|c
argument_list|,
name|type
argument_list|,
name|seq
argument_list|,
name|ctxt
argument_list|)
condition|)
return|return
literal|0
return|;
name|rtype
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|reply
operator|=
name|packet_get_char
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"client_input_channel_req: channel %d rtype %s reply %d"
argument_list|,
name|id
argument_list|,
name|rtype
argument_list|,
name|reply
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"client_input_channel_req: request for channel -1"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"client_input_channel_req: channel %d: "
literal|"unknown channel"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"eow@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_check_eom
argument_list|()
expr_stmt|;
name|chan_rcvd_eow
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"exit-status"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|exitval
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ctl_chan
operator|!=
operator|-
literal|1
condition|)
block|{
name|mux_exit_message
argument_list|(
name|c
argument_list|,
name|exitval
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|session_ident
condition|)
block|{
comment|/* Record exit value of local session */
name|success
operator|=
literal|1
expr_stmt|;
name|exit_status
operator|=
name|exitval
expr_stmt|;
block|}
else|else
block|{
comment|/* Probably for a mux channel that has already closed */
name|debug
argument_list|(
literal|"%s: no sink for exit-status on channel %d"
argument_list|,
name|__func__
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|packet_check_eom
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reply
operator|&&
name|c
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHAN_CLOSE_SENT
operator|)
condition|)
block|{
name|packet_start
argument_list|(
name|success
condition|?
name|SSH2_MSG_CHANNEL_SUCCESS
else|:
name|SSH2_MSG_CHANNEL_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|hostkeys_update_ctx
block|{
comment|/* The hostname and (optionally) IP address string for the server */
name|char
modifier|*
name|host_str
decl_stmt|,
modifier|*
name|ip_str
decl_stmt|;
comment|/* 	 * Keys received from the server and a flag for each indicating 	 * whether they already exist in known_hosts. 	 * keys_seen is filled in by hostkeys_find() and later (for new 	 * keys) by client_global_hostkeys_private_confirm(). 	 */
name|struct
name|sshkey
modifier|*
modifier|*
name|keys
decl_stmt|;
name|int
modifier|*
name|keys_seen
decl_stmt|;
name|size_t
name|nkeys
decl_stmt|;
name|size_t
name|nnew
decl_stmt|;
comment|/* 	 * Keys that are in known_hosts, but were not present in the update 	 * from the server (i.e. scheduled to be deleted). 	 * Filled in by hostkeys_find(). 	 */
name|struct
name|sshkey
modifier|*
modifier|*
name|old_keys
decl_stmt|;
name|size_t
name|nold
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|hostkeys_update_ctx_free
parameter_list|(
name|struct
name|hostkeys_update_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|nkeys
condition|;
name|i
operator|++
control|)
name|sshkey_free
argument_list|(
name|ctx
operator|->
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|->
name|keys
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|->
name|keys_seen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|nold
condition|;
name|i
operator|++
control|)
name|sshkey_free
argument_list|(
name|ctx
operator|->
name|old_keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|->
name|old_keys
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|->
name|host_str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|->
name|ip_str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hostkeys_find
parameter_list|(
name|struct
name|hostkey_foreach_line
modifier|*
name|l
parameter_list|,
name|void
modifier|*
name|_ctx
parameter_list|)
block|{
name|struct
name|hostkeys_update_ctx
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|hostkeys_update_ctx
operator|*
operator|)
name|_ctx
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|struct
name|sshkey
modifier|*
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|l
operator|->
name|status
operator|!=
name|HKF_STATUS_MATCHED
operator|||
name|l
operator|->
name|key
operator|==
name|NULL
operator|||
name|l
operator|->
name|key
operator|->
name|type
operator|==
name|KEY_RSA1
condition|)
return|return
literal|0
return|;
comment|/* Mark off keys we've already seen for this host */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sshkey_equal
argument_list|(
name|l
operator|->
name|key
argument_list|,
name|ctx
operator|->
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|debug3
argument_list|(
literal|"%s: found %s key at %s:%ld"
argument_list|,
name|__func__
argument_list|,
name|sshkey_ssh_name
argument_list|(
name|ctx
operator|->
name|keys
index|[
name|i
index|]
argument_list|)
argument_list|,
name|l
operator|->
name|path
argument_list|,
name|l
operator|->
name|linenum
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|keys_seen
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* This line contained a key that not offered by the server */
name|debug3
argument_list|(
literal|"%s: deprecated %s key at %s:%ld"
argument_list|,
name|__func__
argument_list|,
name|sshkey_ssh_name
argument_list|(
name|l
operator|->
name|key
argument_list|)
argument_list|,
name|l
operator|->
name|path
argument_list|,
name|l
operator|->
name|linenum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|reallocarray
argument_list|(
name|ctx
operator|->
name|old_keys
argument_list|,
name|ctx
operator|->
name|nold
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
operator|->
name|old_keys
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: reallocarray failed nold = %zu"
argument_list|,
name|__func__
argument_list|,
name|ctx
operator|->
name|nold
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|old_keys
operator|=
name|tmp
expr_stmt|;
name|ctx
operator|->
name|old_keys
index|[
name|ctx
operator|->
name|nold
operator|++
index|]
operator|=
name|l
operator|->
name|key
expr_stmt|;
name|l
operator|->
name|key
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_known_hosts
parameter_list|(
name|struct
name|hostkeys_update_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|was_raw
init|=
literal|0
decl_stmt|;
name|int
name|loglevel
init|=
name|options
operator|.
name|update_hostkeys
operator|==
name|SSH_UPDATE_HOSTKEYS_ASK
condition|?
name|SYSLOG_LEVEL_INFO
else|:
name|SYSLOG_LEVEL_VERBOSE
decl_stmt|;
name|char
modifier|*
name|fp
decl_stmt|,
modifier|*
name|response
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctx
operator|->
name|keys_seen
index|[
name|i
index|]
operator|!=
literal|2
condition|)
continue|continue;
if|if
condition|(
operator|(
name|fp
operator|=
name|sshkey_fingerprint
argument_list|(
name|ctx
operator|->
name|keys
index|[
name|i
index|]
argument_list|,
name|options
operator|.
name|fingerprint_hash
argument_list|,
name|SSH_FP_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: sshkey_fingerprint failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|do_log2
argument_list|(
name|loglevel
argument_list|,
literal|"Learned new hostkey: %s %s"
argument_list|,
name|sshkey_type
argument_list|(
name|ctx
operator|->
name|keys
index|[
name|i
index|]
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|nold
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|sshkey_fingerprint
argument_list|(
name|ctx
operator|->
name|old_keys
index|[
name|i
index|]
argument_list|,
name|options
operator|.
name|fingerprint_hash
argument_list|,
name|SSH_FP_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: sshkey_fingerprint failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|do_log2
argument_list|(
name|loglevel
argument_list|,
literal|"Deprecating obsolete hostkey: %s %s"
argument_list|,
name|sshkey_type
argument_list|(
name|ctx
operator|->
name|old_keys
index|[
name|i
index|]
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|.
name|update_hostkeys
operator|==
name|SSH_UPDATE_HOSTKEYS_ASK
condition|)
block|{
if|if
condition|(
name|get_saved_tio
argument_list|()
operator|!=
name|NULL
condition|)
block|{
name|leave_raw_mode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|was_raw
operator|=
literal|1
expr_stmt|;
block|}
name|response
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|quit_pending
operator|&&
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|response
operator|=
name|read_passphrase
argument_list|(
literal|"Accept updated hostkeys? "
literal|"(yes/no): "
argument_list|,
name|RP_ECHO
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|response
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|quit_pending
operator|||
name|response
operator|==
name|NULL
operator|||
name|strcasecmp
argument_list|(
name|response
argument_list|,
literal|"no"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|options
operator|.
name|update_hostkeys
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
block|{
name|do_log2
argument_list|(
name|loglevel
argument_list|,
literal|"Please enter "
literal|"\"yes\" or \"no\""
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quit_pending
operator|||
name|i
operator|>=
literal|3
operator|||
name|response
operator|==
name|NULL
condition|)
name|options
operator|.
name|update_hostkeys
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_raw
condition|)
name|enter_raw_mode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now that all the keys are verified, we can go ahead and replace 	 * them in known_hosts (assuming SSH_UPDATE_HOSTKEYS_ASK didn't 	 * cancel the operation). 	 */
if|if
condition|(
name|options
operator|.
name|update_hostkeys
operator|!=
literal|0
operator|&&
operator|(
name|r
operator|=
name|hostfile_replace_entries
argument_list|(
name|options
operator|.
name|user_hostfiles
index|[
literal|0
index|]
argument_list|,
name|ctx
operator|->
name|host_str
argument_list|,
name|ctx
operator|->
name|ip_str
argument_list|,
name|ctx
operator|->
name|keys
argument_list|,
name|ctx
operator|->
name|nkeys
argument_list|,
name|options
operator|.
name|hash_known_hosts
argument_list|,
literal|0
argument_list|,
name|options
operator|.
name|fingerprint_hash
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"%s: hostfile_replace_entries failed: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_global_hostkeys_private_confirm
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|_ctx
parameter_list|)
block|{
name|struct
name|ssh
modifier|*
name|ssh
init|=
name|active_state
decl_stmt|;
comment|/* XXX */
name|struct
name|hostkeys_update_ctx
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|hostkeys_update_ctx
operator|*
operator|)
name|_ctx
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|ndone
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|signdata
decl_stmt|;
name|int
name|r
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|sig
decl_stmt|;
name|size_t
name|siglen
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|nnew
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: ctx->nnew == 0"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* sanity */
if|if
condition|(
name|type
operator|!=
name|SSH2_MSG_REQUEST_SUCCESS
condition|)
block|{
name|error
argument_list|(
literal|"Server failed to confirm ownership of "
literal|"private host keys"
argument_list|)
expr_stmt|;
name|hostkeys_update_ctx_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|signdata
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: sshbuf_new failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Don't want to accidentally accept an unbound signature */
if|if
condition|(
name|ssh
operator|->
name|kex
operator|->
name|session_id_len
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: ssh->kex->session_id_len == 0"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Expect a signature for each of the ctx->nnew private keys we 	 * haven't seen before. They will be in the same order as the 	 * ctx->keys where the corresponding ctx->keys_seen[i] == 0. 	 */
for|for
control|(
name|ndone
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctx
operator|->
name|keys_seen
index|[
name|i
index|]
condition|)
continue|continue;
comment|/* Prepare data to be signed: session ID, unique string, key */
name|sshbuf_reset
argument_list|(
name|signdata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_cstring
argument_list|(
name|signdata
argument_list|,
literal|"hostkeys-prove-00@openssh.com"
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|signdata
argument_list|,
name|ssh
operator|->
name|kex
operator|->
name|session_id
argument_list|,
name|ssh
operator|->
name|kex
operator|->
name|session_id_len
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshkey_puts
argument_list|(
name|ctx
operator|->
name|keys
index|[
name|i
index|]
argument_list|,
name|signdata
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: failed to prepare signature: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Extract and verify signature */
if|if
condition|(
operator|(
name|r
operator|=
name|sshpkt_get_string_direct
argument_list|(
name|ssh
argument_list|,
operator|&
name|sig
argument_list|,
operator|&
name|siglen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: couldn't parse message: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_verify
argument_list|(
name|ctx
operator|->
name|keys
index|[
name|i
index|]
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|,
name|sshbuf_ptr
argument_list|(
name|signdata
argument_list|)
argument_list|,
name|sshbuf_len
argument_list|(
name|signdata
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: server gave bad signature for %s key %zu"
argument_list|,
name|__func__
argument_list|,
name|sshkey_type
argument_list|(
name|ctx
operator|->
name|keys
index|[
name|i
index|]
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Key is good. Mark it as 'seen' */
name|ctx
operator|->
name|keys_seen
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
name|ndone
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ndone
operator|!=
name|ctx
operator|->
name|nnew
condition|)
name|fatal
argument_list|(
literal|"%s: ndone != ctx->nnew (%zu / %zu)"
argument_list|,
name|__func__
argument_list|,
name|ndone
argument_list|,
name|ctx
operator|->
name|nnew
argument_list|)
expr_stmt|;
comment|/* Shouldn't happen */
name|ssh_packet_check_eom
argument_list|(
name|ssh
argument_list|)
expr_stmt|;
comment|/* Make the edits to known_hosts */
name|update_known_hosts
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|out
label|:
name|hostkeys_update_ctx_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the key is accepted by HostkeyAlgorithms.  * Made slightly less trivial by the multiple RSA signature algorithm names.  */
end_comment

begin_function
specifier|static
name|int
name|key_accepted_by_hostkeyalgs
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ktype
init|=
name|sshkey_ssh_name
argument_list|(
name|key
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostkeyalgs
init|=
name|options
operator|.
name|hostkeyalgorithms
operator|!=
name|NULL
condition|?
name|options
operator|.
name|hostkeyalgorithms
else|:
name|KEX_DEFAULT_PK_ALG
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
operator|||
name|key
operator|->
name|type
operator|==
name|KEY_UNSPEC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|key
operator|->
name|type
operator|==
name|KEY_RSA
operator|&&
operator|(
name|match_pattern_list
argument_list|(
literal|"rsa-sha2-256"
argument_list|,
name|hostkeyalgs
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
operator|||
name|match_pattern_list
argument_list|(
literal|"rsa-sha2-512"
argument_list|,
name|hostkeyalgs
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
operator|)
condition|)
return|return
literal|1
return|;
return|return
name|match_pattern_list
argument_list|(
name|ktype
argument_list|,
name|hostkeyalgs
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Handle hostkeys-00@openssh.com global request to inform the client of all  * the server's hostkeys. The keys are checked against the user's  * HostkeyAlgorithms preference before they are accepted.  */
end_comment

begin_function
specifier|static
name|int
name|client_input_hostkeys
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ssh
modifier|*
name|ssh
init|=
name|active_state
decl_stmt|;
comment|/* XXX */
specifier|const
name|u_char
modifier|*
name|blob
init|=
name|NULL
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|struct
name|sshkey
modifier|*
name|key
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|tmp
decl_stmt|;
name|int
name|r
decl_stmt|;
name|char
modifier|*
name|fp
decl_stmt|;
specifier|static
name|int
name|hostkeys_seen
init|=
literal|0
decl_stmt|;
comment|/* XXX use struct ssh */
specifier|extern
name|struct
name|sockaddr_storage
name|hostaddr
decl_stmt|;
comment|/* XXX from ssh.c */
name|struct
name|hostkeys_update_ctx
modifier|*
name|ctx
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|hostkeys_seen
condition|)
name|fatal
argument_list|(
literal|"%s: server already sent hostkeys"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|update_hostkeys
operator|==
name|SSH_UPDATE_HOSTKEYS_ASK
operator|&&
name|options
operator|.
name|batch_mode
condition|)
return|return
literal|1
return|;
comment|/* won't ask in batchmode, so don't even try */
if|if
condition|(
operator|!
name|options
operator|.
name|update_hostkeys
operator|||
name|options
operator|.
name|num_user_hostfiles
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
name|ctx
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|ssh_packet_remaining
argument_list|(
name|ssh
argument_list|)
operator|>
literal|0
condition|)
block|{
name|sshkey_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshpkt_get_string_direct
argument_list|(
name|ssh
argument_list|,
operator|&
name|blob
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: couldn't parse message: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_from_blob
argument_list|(
name|blob
argument_list|,
name|len
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: parse key: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fp
operator|=
name|sshkey_fingerprint
argument_list|(
name|key
argument_list|,
name|options
operator|.
name|fingerprint_hash
argument_list|,
name|SSH_FP_DEFAULT
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: received %s key %s"
argument_list|,
name|__func__
argument_list|,
name|sshkey_type
argument_list|(
name|key
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key_accepted_by_hostkeyalgs
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|debug3
argument_list|(
literal|"%s: %s key not permitted by HostkeyAlgorithms"
argument_list|,
name|__func__
argument_list|,
name|sshkey_ssh_name
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Skip certs */
if|if
condition|(
name|sshkey_is_cert
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|debug3
argument_list|(
literal|"%s: %s key is a certificate; skipping"
argument_list|,
name|__func__
argument_list|,
name|sshkey_ssh_name
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Ensure keys are unique */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sshkey_equal
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%s: received duplicated %s host key"
argument_list|,
name|__func__
argument_list|,
name|sshkey_ssh_name
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* Key is good, record it */
if|if
condition|(
operator|(
name|tmp
operator|=
name|reallocarray
argument_list|(
name|ctx
operator|->
name|keys
argument_list|,
name|ctx
operator|->
name|nkeys
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
operator|->
name|keys
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: reallocarray failed nkeys = %zu"
argument_list|,
name|__func__
argument_list|,
name|ctx
operator|->
name|nkeys
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|keys
operator|=
name|tmp
expr_stmt|;
name|ctx
operator|->
name|keys
index|[
name|ctx
operator|->
name|nkeys
operator|++
index|]
operator|=
name|key
expr_stmt|;
name|key
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|nkeys
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"%s: server sent no hostkeys"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|ctx
operator|->
name|keys_seen
operator|=
name|calloc
argument_list|(
name|ctx
operator|->
name|nkeys
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
operator|->
name|keys_seen
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: calloc failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|get_hostfile_hostname_ipaddr
argument_list|(
name|host
argument_list|,
name|options
operator|.
name|check_host_ip
condition|?
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|hostaddr
else|:
name|NULL
argument_list|,
name|options
operator|.
name|port
argument_list|,
operator|&
name|ctx
operator|->
name|host_str
argument_list|,
name|options
operator|.
name|check_host_ip
condition|?
operator|&
name|ctx
operator|->
name|ip_str
else|:
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find which keys we already know about. */
if|if
condition|(
operator|(
name|r
operator|=
name|hostkeys_foreach
argument_list|(
name|options
operator|.
name|user_hostfiles
index|[
literal|0
index|]
argument_list|,
name|hostkeys_find
argument_list|,
name|ctx
argument_list|,
name|ctx
operator|->
name|host_str
argument_list|,
name|ctx
operator|->
name|ip_str
argument_list|,
name|HKF_WANT_PARSE_KEY
operator||
name|HKF_WANT_MATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: hostkeys_foreach failed: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Figure out if we have any new keys to add */
name|ctx
operator|->
name|nnew
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ctx
operator|->
name|keys_seen
index|[
name|i
index|]
condition|)
name|ctx
operator|->
name|nnew
operator|++
expr_stmt|;
block|}
name|debug3
argument_list|(
literal|"%s: %zu keys from server: %zu new, %zu retained. %zu to remove"
argument_list|,
name|__func__
argument_list|,
name|ctx
operator|->
name|nkeys
argument_list|,
name|ctx
operator|->
name|nnew
argument_list|,
name|ctx
operator|->
name|nkeys
operator|-
name|ctx
operator|->
name|nnew
argument_list|,
name|ctx
operator|->
name|nold
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|nnew
operator|==
literal|0
operator|&&
name|ctx
operator|->
name|nold
operator|!=
literal|0
condition|)
block|{
comment|/* We have some keys to remove. Just do it. */
name|update_known_hosts
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|nnew
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We have received hitherto-unseen keys from the server. 		 * Ask the server to confirm ownership of the private halves. 		 */
name|debug3
argument_list|(
literal|"%s: asking server to prove ownership for %zu keys"
argument_list|,
name|__func__
argument_list|,
name|ctx
operator|->
name|nnew
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshpkt_start
argument_list|(
name|ssh
argument_list|,
name|SSH2_MSG_GLOBAL_REQUEST
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshpkt_put_cstring
argument_list|(
name|ssh
argument_list|,
literal|"hostkeys-prove-00@openssh.com"
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshpkt_put_u8
argument_list|(
name|ssh
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
comment|/* bool: want reply */
name|fatal
argument_list|(
literal|"%s: cannot prepare packet: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: sshbuf_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctx
operator|->
name|keys_seen
index|[
name|i
index|]
condition|)
continue|continue;
name|sshbuf_reset
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_putb
argument_list|(
name|ctx
operator|->
name|keys
index|[
name|i
index|]
argument_list|,
name|buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: sshkey_putb: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshpkt_put_stringb
argument_list|(
name|ssh
argument_list|,
name|buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: sshpkt_put_string: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshpkt_send
argument_list|(
name|ssh
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: sshpkt_send: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|client_register_global_confirm
argument_list|(
name|client_global_hostkeys_private_confirm
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|NULL
expr_stmt|;
comment|/* will be freed in callback */
block|}
comment|/* Success */
name|out
label|:
name|hostkeys_update_ctx_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|sshkey_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* 	 * NB. Return success for all cases. The server doesn't need to know 	 * what the client does with its hosts file. 	 */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|client_input_global_request
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|char
modifier|*
name|rtype
decl_stmt|;
name|int
name|want_reply
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|rtype
operator|=
name|packet_get_cstring
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|want_reply
operator|=
name|packet_get_char
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"client_input_global_request: rtype %s want_reply %d"
argument_list|,
name|rtype
argument_list|,
name|want_reply
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"hostkeys-00@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
name|success
operator|=
name|client_input_hostkeys
argument_list|()
expr_stmt|;
if|if
condition|(
name|want_reply
condition|)
block|{
name|packet_start
argument_list|(
name|success
condition|?
name|SSH2_MSG_REQUEST_SUCCESS
else|:
name|SSH2_MSG_REQUEST_FAILURE
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|client_session2_setup
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|want_tty
parameter_list|,
name|int
name|want_subsystem
parameter_list|,
specifier|const
name|char
modifier|*
name|term
parameter_list|,
name|struct
name|termios
modifier|*
name|tiop
parameter_list|,
name|int
name|in_fd
parameter_list|,
name|Buffer
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|debug2
argument_list|(
literal|"%s: id %d"
argument_list|,
name|__func__
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"client_session2_setup: channel %d: unknown channel"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|packet_set_interactive
argument_list|(
name|want_tty
argument_list|,
name|options
operator|.
name|ip_qos_interactive
argument_list|,
name|options
operator|.
name|ip_qos_bulk
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_tty
condition|)
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
comment|/* Store window size in the packet. */
if|if
condition|(
name|ioctl
argument_list|(
name|in_fd
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|<
literal|0
condition|)
name|memset
argument_list|(
operator|&
name|ws
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ws
argument_list|)
argument_list|)
expr_stmt|;
name|channel_request_start
argument_list|(
name|id
argument_list|,
literal|"pty-req"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|client_expect_confirm
argument_list|(
name|id
argument_list|,
literal|"PTY allocation"
argument_list|,
name|CONFIRM_TTY
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|term
operator|!=
name|NULL
condition|?
name|term
else|:
literal|""
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
operator|(
name|u_int
operator|)
name|ws
operator|.
name|ws_col
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
operator|(
name|u_int
operator|)
name|ws
operator|.
name|ws_row
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
operator|(
name|u_int
operator|)
name|ws
operator|.
name|ws_xpixel
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
operator|(
name|u_int
operator|)
name|ws
operator|.
name|ws_ypixel
argument_list|)
expr_stmt|;
if|if
condition|(
name|tiop
operator|==
name|NULL
condition|)
name|tiop
operator|=
name|get_saved_tio
argument_list|()
expr_stmt|;
name|tty_make_modes
argument_list|(
operator|-
literal|1
argument_list|,
name|tiop
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* XXX wait for reply */
name|c
operator|->
name|client_tty
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Transfer any environment variables from client to server */
if|if
condition|(
name|options
operator|.
name|num_send_env
operator|!=
literal|0
operator|&&
name|env
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|matched
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|val
decl_stmt|;
name|debug
argument_list|(
literal|"Sending environment."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|env
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
comment|/* Split */
name|name
operator|=
name|xstrdup
argument_list|(
name|env
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|val
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|matched
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|options
operator|.
name|num_send_env
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|match_pattern
argument_list|(
name|name
argument_list|,
name|options
operator|.
name|send_env
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|matched
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
name|debug3
argument_list|(
literal|"Ignored env %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|debug
argument_list|(
literal|"Sending env %s = %s"
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|channel_request_start
argument_list|(
name|id
argument_list|,
literal|"env"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|len
operator|=
name|buffer_len
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|900
condition|)
name|len
operator|=
literal|900
expr_stmt|;
if|if
condition|(
name|want_subsystem
condition|)
block|{
name|debug
argument_list|(
literal|"Sending subsystem: %.*s"
argument_list|,
name|len
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|buffer_ptr
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|channel_request_start
argument_list|(
name|id
argument_list|,
literal|"subsystem"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|client_expect_confirm
argument_list|(
name|id
argument_list|,
literal|"subsystem"
argument_list|,
name|CONFIRM_CLOSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"Sending command: %.*s"
argument_list|,
name|len
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|buffer_ptr
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|channel_request_start
argument_list|(
name|id
argument_list|,
literal|"exec"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|client_expect_confirm
argument_list|(
name|id
argument_list|,
literal|"exec"
argument_list|,
name|CONFIRM_CLOSE
argument_list|)
expr_stmt|;
block|}
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|channel_request_start
argument_list|(
name|id
argument_list|,
literal|"shell"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|client_expect_confirm
argument_list|(
name|id
argument_list|,
literal|"shell"
argument_list|,
name|CONFIRM_CLOSE
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|client_init_dispatch_20
parameter_list|(
name|void
parameter_list|)
block|{
name|dispatch_init
argument_list|(
operator|&
name|dispatch_protocol_error
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_oclose
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_DATA
argument_list|,
operator|&
name|channel_input_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_EOF
argument_list|,
operator|&
name|channel_input_ieof
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_EXTENDED_DATA
argument_list|,
operator|&
name|channel_input_extended_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|,
operator|&
name|client_input_channel_open
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|,
operator|&
name|channel_input_open_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_FAILURE
argument_list|,
operator|&
name|channel_input_open_failure
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_REQUEST
argument_list|,
operator|&
name|client_input_channel_req
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_WINDOW_ADJUST
argument_list|,
operator|&
name|channel_input_window_adjust
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_SUCCESS
argument_list|,
operator|&
name|channel_input_status_confirm
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_FAILURE
argument_list|,
operator|&
name|channel_input_status_confirm
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_GLOBAL_REQUEST
argument_list|,
operator|&
name|client_input_global_request
argument_list|)
expr_stmt|;
comment|/* rekeying */
name|dispatch_set
argument_list|(
name|SSH2_MSG_KEXINIT
argument_list|,
operator|&
name|kex_input_kexinit
argument_list|)
expr_stmt|;
comment|/* global request reply messages */
name|dispatch_set
argument_list|(
name|SSH2_MSG_REQUEST_FAILURE
argument_list|,
operator|&
name|client_global_request_reply
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_REQUEST_SUCCESS
argument_list|,
operator|&
name|client_global_request_reply
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_init_dispatch_13
parameter_list|(
name|void
parameter_list|)
block|{
name|dispatch_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_close
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE_CONFIRMATION
argument_list|,
operator|&
name|channel_input_close_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_DATA
argument_list|,
operator|&
name|channel_input_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|,
operator|&
name|channel_input_open_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|,
operator|&
name|channel_input_open_failure
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_PORT_OPEN
argument_list|,
operator|&
name|channel_input_port_open
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_SMSG_EXITSTATUS
argument_list|,
operator|&
name|client_input_exit_status
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_SMSG_STDERR_DATA
argument_list|,
operator|&
name|client_input_stderr_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_SMSG_STDOUT_DATA
argument_list|,
operator|&
name|client_input_stdout_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_SMSG_AGENT_OPEN
argument_list|,
name|options
operator|.
name|forward_agent
condition|?
operator|&
name|client_input_agent_open
else|:
operator|&
name|deny_input_open
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_SMSG_X11_OPEN
argument_list|,
name|options
operator|.
name|forward_x11
condition|?
operator|&
name|x11_input_open
else|:
operator|&
name|deny_input_open
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_init_dispatch_15
parameter_list|(
name|void
parameter_list|)
block|{
name|client_init_dispatch_13
argument_list|()
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_ieof
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE_CONFIRMATION
argument_list|,
operator|&
name|channel_input_oclose
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_init_dispatch
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|compat20
condition|)
name|client_init_dispatch_20
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|compat13
condition|)
name|client_init_dispatch_13
argument_list|()
expr_stmt|;
else|else
name|client_init_dispatch_15
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_stop_mux
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|options
operator|.
name|control_path
operator|!=
name|NULL
operator|&&
name|muxserver_sock
operator|!=
operator|-
literal|1
condition|)
name|unlink
argument_list|(
name|options
operator|.
name|control_path
argument_list|)
expr_stmt|;
comment|/* 	 * If we are in persist mode, or don't have a shell, signal that we 	 * should close when all active channels are closed. 	 */
if|if
condition|(
name|options
operator|.
name|control_persist
operator|||
name|no_shell_flag
condition|)
block|{
name|session_closed
operator|=
literal|1
expr_stmt|;
name|setproctitle
argument_list|(
literal|"[stopped mux]"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* client specific fatal cleanup */
end_comment

begin_function
name|void
name|cleanup_exit
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|leave_raw_mode
argument_list|(
name|options
operator|.
name|request_tty
operator|==
name|REQUEST_TTY_FORCE
argument_list|)
expr_stmt|;
name|leave_non_blocking
argument_list|()
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|control_path
operator|!=
name|NULL
operator|&&
name|muxserver_sock
operator|!=
operator|-
literal|1
condition|)
name|unlink
argument_list|(
name|options
operator|.
name|control_path
argument_list|)
expr_stmt|;
name|ssh_kill_proxy_command
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

