begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  * The main loop for the interactive session (client side).  *  * As far as I am concerned, the code I have written for this software  * can be used freely for any purpose.  Any derived versions of this  * software must be clearly marked as such, and if the derived work is  * incompatible with the protocol description in the RFC file, it must be  * called by a name other than "ssh" or "Secure Shell".  *  *  * Copyright (c) 1999 Theo de Raadt.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * SSH2 support added by Markus Friedl.  * Copyright (c) 1999,2000 Markus Friedl.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$OpenBSD: clientloop.c,v 1.34 2000/09/07 20:40:30 markus Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"readconf.h"
end_include

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|"channels.h"
end_include

begin_include
include|#
directive|include
file|"dispatch.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"bufaux.h"
end_include

begin_decl_stmt
specifier|extern
name|Options
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating that stdin should be redirected from /dev/null. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stdin_null_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Name of the host we are connecting to.  This is the name given on the  * command line, or the HostName specified for the user-supplied name in a  * configuration file.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|host
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flag to indicate that we have received a window change signal which has  * not yet been processed.  This will cause a message indicating the new  * window size to be sent to the server a little later.  This is volatile  * because this is updated in a signal handler.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|received_window_change_signal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Terminal modes, as saved by enter_raw_mode. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|termios
name|saved_tio
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flag indicating whether we are in raw mode.  This is used by  * enter_raw_mode and leave_raw_mode.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_raw_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating whether the user\'s terminal is in non-blocking mode. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_non_blocking_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Common data for the client loop code. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|quit_pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to non-zero to quit the client loop. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|escape_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Escape character. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|escape_pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last character was the escape character */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_was_cr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last character was a newline. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exit_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to store the exit status of the command. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdin_eof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF has been encountered on standard error. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stdin_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stdin data. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stdout_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stdout data. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stderr_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stderr data. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|stdin_bytes
decl_stmt|,
name|stdout_bytes
decl_stmt|,
name|stderr_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|buffer_high
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Soft max buffer size. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum file descriptor number in select(). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|connection_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to server (input). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|connection_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to server (output). */
end_comment

begin_function_decl
name|void
name|client_init_dispatch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|session_ident
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns the user\'s terminal to normal mode if it had been put in raw mode. */
end_comment

begin_function
name|void
name|leave_raw_mode
parameter_list|()
block|{
if|if
condition|(
operator|!
name|in_raw_mode
condition|)
return|return;
name|in_raw_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|saved_tio
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"tcsetattr"
argument_list|)
expr_stmt|;
name|fatal_remove_cleanup
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|leave_raw_mode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Puts the user\'s terminal in raw mode. */
end_comment

begin_function
name|void
name|enter_raw_mode
parameter_list|()
block|{
name|struct
name|termios
name|tio
decl_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|tio
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"tcgetattr"
argument_list|)
expr_stmt|;
name|saved_tio
operator|=
name|tio
expr_stmt|;
name|tio
operator|.
name|c_iflag
operator||=
name|IGNPAR
expr_stmt|;
name|tio
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|ISTRIP
operator||
name|INLCR
operator||
name|IGNCR
operator||
name|ICRNL
operator||
name|IXON
operator||
name|IXANY
operator||
name|IXOFF
operator|)
expr_stmt|;
name|tio
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ISIG
operator||
name|ICANON
operator||
name|ECHO
operator||
name|ECHOE
operator||
name|ECHOK
operator||
name|ECHONL
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEXTEN
name|tio
operator|.
name|c_lflag
operator|&=
operator|~
name|IEXTEN
expr_stmt|;
endif|#
directive|endif
comment|/* IEXTEN */
name|tio
operator|.
name|c_oflag
operator|&=
operator|~
name|OPOST
expr_stmt|;
name|tio
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|tio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|tio
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"tcsetattr"
argument_list|)
expr_stmt|;
name|in_raw_mode
operator|=
literal|1
expr_stmt|;
name|fatal_add_cleanup
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|leave_raw_mode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restores stdin to blocking mode. */
end_comment

begin_function
name|void
name|leave_non_blocking
parameter_list|()
block|{
if|if
condition|(
name|in_non_blocking_mode
condition|)
block|{
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|in_non_blocking_mode
operator|=
literal|0
expr_stmt|;
name|fatal_remove_cleanup
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|leave_non_blocking
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Puts stdin terminal in non-blocking mode. */
end_comment

begin_function
name|void
name|enter_non_blocking
parameter_list|()
block|{
name|in_non_blocking_mode
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
name|fatal_add_cleanup
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|leave_non_blocking
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Signal handler for the window change signal (SIGWINCH).  This just sets a  * flag indicating that the window has changed.  */
end_comment

begin_function
name|void
name|window_change_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|received_window_change_signal
operator|=
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|window_change_handler
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Signal handler for signals that cause the program to terminate.  These  * signals must be trapped to restore terminal modes.  */
end_comment

begin_function
name|void
name|signal_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|in_raw_mode
condition|)
name|leave_raw_mode
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_non_blocking_mode
condition|)
name|leave_non_blocking
argument_list|()
expr_stmt|;
name|channel_stop_listening
argument_list|()
expr_stmt|;
name|packet_close
argument_list|()
expr_stmt|;
name|fatal
argument_list|(
literal|"Killed by signal %d."
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns current time in seconds from Jan 1, 1970 with the maximum  * available resolution.  */
end_comment

begin_function
name|double
name|get_current_time
parameter_list|()
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|double
operator|)
name|tv
operator|.
name|tv_sec
operator|+
operator|(
name|double
operator|)
name|tv
operator|.
name|tv_usec
operator|/
literal|1000000.0
return|;
block|}
end_function

begin_comment
comment|/*  * This is called when the interactive is entered.  This checks if there is  * an EOF coming on stdin.  We must check this explicitly, as select() does  * not appear to wake up when redirecting from /dev/null.  */
end_comment

begin_function
name|void
name|client_check_initial_eof_on_stdin
parameter_list|()
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
comment|/* 	 * If standard input is to be "redirected from /dev/null", we simply 	 * mark that we have seen an EOF and send an EOF message to the 	 * server. Otherwise, we try to read a single character; it appears 	 * that for some files, such /dev/null, select() never wakes up for 	 * read for this descriptor, which means that we never get EOF.  This 	 * way we will get the EOF if stdin comes from /dev/null or similar. 	 */
if|if
condition|(
name|stdin_null_flag
condition|)
block|{
comment|/* Fake EOF on stdin. */
name|debug
argument_list|(
literal|"Sending eof."
argument_list|)
expr_stmt|;
name|stdin_eof
operator|=
literal|1
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|enter_non_blocking
argument_list|()
expr_stmt|;
comment|/* Check for immediate EOF on stdin. */
name|len
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* EOF.  Record that we have seen it and send EOF to server. */
name|debug
argument_list|(
literal|"Sending eof."
argument_list|)
expr_stmt|;
name|stdin_eof
operator|=
literal|1
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Got data.  We must store the data in the buffer, 			 * and also process it as an escape character if 			 * appropriate. 			 */
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
literal|0
index|]
operator|==
name|escape_char
condition|)
name|escape_pending
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|buffer_append
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stdin_bytes
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|leave_non_blocking
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Make packets from buffered stdin data, and buffer them for sending to the  * connection.  */
end_comment

begin_function
name|void
name|client_make_packets_from_stdin_data
parameter_list|()
block|{
name|unsigned
name|int
name|len
decl_stmt|;
comment|/* Send buffered stdin data to the server. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|>
literal|0
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
block|{
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
comment|/* Keep the packets at reasonable size. */
if|if
condition|(
name|len
operator|>
name|packet_get_maxsize
argument_list|()
condition|)
name|len
operator|=
name|packet_get_maxsize
argument_list|()
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_CMSG_STDIN_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* If we have a pending EOF, send it now. */
if|if
condition|(
name|stdin_eof
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Checks if the client window has changed, and sends a packet about it to  * the server if so.  The actual change is detected elsewhere (by a software  * interrupt on Unix); this just checks the flag and sends a message if  * appropriate.  */
end_comment

begin_function
name|void
name|client_check_window_change
parameter_list|()
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
if|if
condition|(
operator|!
name|received_window_change_signal
condition|)
return|return;
comment|/** XXX race */
name|received_window_change_signal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|debug
argument_list|(
literal|"client_check_window_change: changed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
name|channel_request_start
argument_list|(
name|session_ident
argument_list|,
literal|"window-change"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_col
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_row
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_xpixel
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_ypixel
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_WINDOW_SIZE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_row
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_col
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_xpixel
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|ws
operator|.
name|ws_ypixel
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Waits until the client can do something (some data becomes available on  * one of the file descriptors).  */
end_comment

begin_function
name|void
name|client_wait_until_can_do_something
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
comment|/*debug("client_wait_until_can_do_something"); */
comment|/* Initialize select masks. */
name|FD_ZERO
argument_list|(
name|readset
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
name|writeset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compat20
condition|)
block|{
comment|/* Read from the connection, unless our buffers are full. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|<
name|buffer_high
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|<
name|buffer_high
operator|&&
name|channel_not_very_much_buffered_data
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_in
argument_list|,
name|readset
argument_list|)
expr_stmt|;
comment|/* 		 * Read from stdin, unless we have seen EOF or have very much 		 * buffered data to send to the server. 		 */
if|if
condition|(
operator|!
name|stdin_eof
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|readset
argument_list|)
expr_stmt|;
comment|/* Select stdout/stderr if have data in buffer. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FD_SET
argument_list|(
name|connection_in
argument_list|,
name|readset
argument_list|)
expr_stmt|;
block|}
comment|/* Add any selections by the channel mechanism. */
name|channel_prepare_select
argument_list|(
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
comment|/* Select server connection if have data to write to the server. */
if|if
condition|(
name|packet_have_data_to_write
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_out
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
comment|/* move UP XXX */
comment|/* Update maximum file descriptor number, if appropriate. */
if|if
condition|(
name|channel_max_fd
argument_list|()
operator|>
name|max_fd
condition|)
name|max_fd
operator|=
name|channel_max_fd
argument_list|()
expr_stmt|;
comment|/* 	 * Wait for something to happen.  This will suspend the process until 	 * some selected descriptor can be read, written, or has some other 	 * event pending. Note: if you want to implement SSH_MSG_IGNORE 	 * messages to fool traffic analysis, this might be the place to do 	 * it: just have a random timeout for the select, and send a random 	 * SSH_MSG_IGNORE packet when the timeout expires. 	 */
if|if
condition|(
name|select
argument_list|(
name|max_fd
operator|+
literal|1
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* Some systems fail to clear these automatically. */
name|FD_ZERO
argument_list|(
name|readset
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
name|writeset
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
return|return;
comment|/* Note: we might still have data in the buffers. */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"select: %s\r\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|client_suspend_self
parameter_list|(
name|Buffer
modifier|*
name|bin
parameter_list|,
name|Buffer
modifier|*
name|bout
parameter_list|,
name|Buffer
modifier|*
name|berr
parameter_list|)
block|{
name|struct
name|winsize
name|oldws
decl_stmt|,
name|newws
decl_stmt|;
comment|/* Flush stdout and stderr buffers. */
if|if
condition|(
name|buffer_len
argument_list|(
name|bout
argument_list|)
operator|>
literal|0
condition|)
name|atomicio
argument_list|(
name|write
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
name|bout
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
name|bout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
name|berr
argument_list|)
operator|>
literal|0
condition|)
name|atomicio
argument_list|(
name|write
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
name|berr
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
name|berr
argument_list|)
argument_list|)
expr_stmt|;
name|leave_raw_mode
argument_list|()
expr_stmt|;
comment|/* 	 * Free (and clear) the buffer to reduce the amount of data that gets 	 * written to swap. 	 */
name|buffer_free
argument_list|(
name|bin
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
name|bout
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
name|berr
argument_list|)
expr_stmt|;
comment|/* Save old window size. */
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|oldws
argument_list|)
expr_stmt|;
comment|/* Send the suspend signal to the program itself. */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* Check if the window size has changed. */
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|newws
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|oldws
operator|.
name|ws_row
operator|!=
name|newws
operator|.
name|ws_row
operator|||
name|oldws
operator|.
name|ws_col
operator|!=
name|newws
operator|.
name|ws_col
operator|||
name|oldws
operator|.
name|ws_xpixel
operator|!=
name|newws
operator|.
name|ws_xpixel
operator|||
name|oldws
operator|.
name|ws_ypixel
operator|!=
name|newws
operator|.
name|ws_ypixel
operator|)
condition|)
name|received_window_change_signal
operator|=
literal|1
expr_stmt|;
comment|/* OK, we have been continued by the user. Reinitialize buffers. */
name|buffer_init
argument_list|(
name|bin
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
name|bout
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
name|berr
argument_list|)
expr_stmt|;
name|enter_raw_mode
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_process_net_input
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
comment|/* 	 * Read input from the server, and add any such data to the buffer of 	 * the packet subsystem. 	 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_in
argument_list|,
name|readset
argument_list|)
condition|)
block|{
comment|/* Read as much as possible. */
name|len
operator|=
name|read
argument_list|(
name|connection_in
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/*debug("read connection_in len %d", len); XXX */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* Received EOF.  The remote host has closed the connection. */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"Connection to %.300s closed by remote host.\r\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 		 * There is a kernel bug on Solaris that causes select to 		 * sometimes wake up even though there is no data available. 		 */
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
comment|/* An error has encountered.  Perhaps there is a network problem. */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"Read from remote host %.300s: %.100s\r\n"
argument_list|,
name|host
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|packet_process_incoming
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* process the characters one by one */
end_comment

begin_function
name|int
name|process_escapes
parameter_list|(
name|Buffer
modifier|*
name|bin
parameter_list|,
name|Buffer
modifier|*
name|bout
parameter_list|,
name|Buffer
modifier|*
name|berr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
name|string
index|[
literal|1024
index|]
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|bytes
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get one character at a time. */
name|ch
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|escape_pending
condition|)
block|{
comment|/* We have previously seen an escape character. */
comment|/* Clear the flag now. */
name|escape_pending
operator|=
literal|0
expr_stmt|;
comment|/* Process the escaped character. */
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'.'
case|:
comment|/* Terminate the connection. */
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c.\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
comment|/*stderr_bytes += strlen(string); XXX*/
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|'Z'
operator|-
literal|64
case|:
comment|/* Suspend the program. */
comment|/* Print a message to that effect to the user. */
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c^Z [suspend ssh]\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
comment|/*stderr_bytes += strlen(string); XXX*/
comment|/* Restore terminal modes and suspend. */
name|client_suspend_self
argument_list|(
name|bin
argument_list|,
name|bout
argument_list|,
name|berr
argument_list|)
expr_stmt|;
comment|/* We have been continued. */
continue|continue;
case|case
literal|'&'
case|:
comment|/* XXX does not work yet with proto 2 */
if|if
condition|(
name|compat20
condition|)
continue|continue;
comment|/* 				 * Detach the program (continue to serve connections, 				 * but put in background and no more new connections). 				 */
if|if
condition|(
operator|!
name|stdin_eof
condition|)
block|{
comment|/* 					 * Sending SSH_CMSG_EOF alone does not always appear 					 * to be enough.  So we try to send an EOF character 					 * first. 					 */
name|packet_start
argument_list|(
name|SSH_CMSG_STDIN_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
literal|"\004"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* Close stdin. */
name|stdin_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
name|bin
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Restore tty modes. */
name|leave_raw_mode
argument_list|()
expr_stmt|;
comment|/* Stop listening for new connections. */
name|channel_stop_listening
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%c& [backgrounded]\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
comment|/* Fork into background. */
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"fork: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pid
operator|!=
literal|0
condition|)
block|{
comment|/* This is the parent. */
comment|/* The parent just exits. */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The child continues serving connections. */
continue|continue;
comment|/*XXX ? */
case|case
literal|'?'
case|:
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c?\r\n\ Supported escape sequences:\r\n\ ~.  - terminate connection\r\n\ ~^Z - suspend ssh\r\n\ ~#  - list forwarded connections\r\n\ ~&  - background ssh (when waiting for connections to terminate)\r\n\ ~?  - this message\r\n\ ~~  - send the escape character by typing it twice\r\n\ (Note that escapes are only recognized immediately after newline.)\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'#'
case|:
name|snprintf
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
literal|"%c#\r\n"
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|channel_open_message
argument_list|()
expr_stmt|;
name|buffer_append
argument_list|(
name|berr
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
name|ch
operator|!=
name|escape_char
condition|)
block|{
name|buffer_put_char
argument_list|(
name|bin
argument_list|,
name|escape_char
argument_list|)
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
block|}
comment|/* Escaped characters fall through here */
break|break;
block|}
block|}
else|else
block|{
comment|/* 			 * The previous character was not an escape char. Check if this 			 * is an escape. 			 */
if|if
condition|(
name|last_was_cr
operator|&&
name|ch
operator|==
name|escape_char
condition|)
block|{
comment|/* It is. Set the flag and continue to next character. */
name|escape_pending
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Normal character.  Record whether it was a newline, 		 * and append it to the buffer. 		 */
name|last_was_cr
operator|=
operator|(
name|ch
operator|==
literal|'\r'
operator|||
name|ch
operator|==
literal|'\n'
operator|)
expr_stmt|;
name|buffer_put_char
argument_list|(
name|bin
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
end_function

begin_function
name|void
name|client_process_input
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
comment|/* Read input from stdin. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|readset
argument_list|)
condition|)
block|{
comment|/* Read as much as possible. */
name|len
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
comment|/* 			 * Received EOF or error.  They are treated 			 * similarly, except that an error message is printed 			 * if it was an error condition. 			 */
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"read: %.100s\r\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Mark that we have seen EOF. */
name|stdin_eof
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Send an EOF message to the server unless there is 			 * data in the buffer.  If there is data in the 			 * buffer, no message will be sent now.  Code 			 * elsewhere will send the EOF when the buffer 			 * becomes empty if stdin_eof is set. 			 */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_CMSG_EOF
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|escape_char
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Normal successful read, and no escape character. 			 * Just append the data to buffer. 			 */
name|buffer_append
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stdin_bytes
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Normal, successful read.  But we have an escape character 			 * and have to process the characters one by one. 			 */
name|ret
operator|=
name|process_escapes
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
operator|&
name|stdout_buffer
argument_list|,
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return;
name|stdout_bytes
operator|+=
name|ret
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|client_process_output
parameter_list|(
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* Write buffered output to stdout. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|writeset
argument_list|)
condition|)
block|{
comment|/* Write as much data as possible. */
name|len
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
name|len
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 				 * An error or EOF was encountered.  Put an 				 * error message to stderr buffer. 				 */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"write stdout: %.50s\r\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
comment|/* Consume printed data from the buffer. */
name|buffer_consume
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Write buffered output to stderr. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|writeset
argument_list|)
condition|)
block|{
comment|/* Write as much data as possible. */
name|len
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
name|len
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* EOF or error, but can't even print error message. */
name|quit_pending
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
comment|/* Consume printed characters from the buffer. */
name|buffer_consume
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get packets from the connection input buffer, and process them as long as  * there are packets available.  *  * Any unknown packets received during the actual  * session cause the session to terminate.  This is  * intended to make debugging easier since no  * confirmations are sent.  Any compatible protocol  * extensions must be negotiated during the  * preparatory phase.  */
end_comment

begin_function
name|void
name|client_process_buffered_input_packets
parameter_list|()
block|{
name|dispatch_run
argument_list|(
name|DISPATCH_NONBLOCK
argument_list|,
operator|&
name|quit_pending
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* scan buf[] for '~' before sending data to the peer */
end_comment

begin_function
name|int
name|simple_escape_filter
parameter_list|(
name|Channel
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|/* XXX we assume c->extended is writeable */
return|return
name|process_escapes
argument_list|(
operator|&
name|c
operator|->
name|input
argument_list|,
operator|&
name|c
operator|->
name|output
argument_list|,
operator|&
name|c
operator|->
name|extended
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implements the interactive session with the server.  This is called after  * the user has been authenticated, and a command has been started on the  * remote host.  If escape_char != -1, it is the character used as an escape  * character for terminating or suspending the session.  */
end_comment

begin_function
name|int
name|client_loop
parameter_list|(
name|int
name|have_pty
parameter_list|,
name|int
name|escape_char_arg
parameter_list|,
name|int
name|ssh2_chan_id
parameter_list|)
block|{
name|double
name|start_time
decl_stmt|,
name|total_time
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|debug
argument_list|(
literal|"Entering interactive session."
argument_list|)
expr_stmt|;
name|start_time
operator|=
name|get_current_time
argument_list|()
expr_stmt|;
comment|/* Initialize variables. */
name|escape_pending
operator|=
literal|0
expr_stmt|;
name|last_was_cr
operator|=
literal|1
expr_stmt|;
name|exit_status
operator|=
operator|-
literal|1
expr_stmt|;
name|stdin_eof
operator|=
literal|0
expr_stmt|;
name|buffer_high
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
name|connection_in
operator|=
name|packet_get_connection_in
argument_list|()
expr_stmt|;
name|connection_out
operator|=
name|packet_get_connection_out
argument_list|()
expr_stmt|;
name|max_fd
operator|=
name|connection_in
expr_stmt|;
if|if
condition|(
name|connection_out
operator|>
name|max_fd
condition|)
name|max_fd
operator|=
name|connection_out
expr_stmt|;
name|stdin_bytes
operator|=
literal|0
expr_stmt|;
name|stdout_bytes
operator|=
literal|0
expr_stmt|;
name|stderr_bytes
operator|=
literal|0
expr_stmt|;
name|quit_pending
operator|=
literal|0
expr_stmt|;
name|escape_char
operator|=
name|escape_char_arg
expr_stmt|;
comment|/* Initialize buffers. */
name|buffer_init
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
name|client_init_dispatch
argument_list|()
expr_stmt|;
comment|/* Set signal handlers to restore non-blocking mode.  */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_pty
condition|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|window_change_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_pty
condition|)
name|enter_raw_mode
argument_list|()
expr_stmt|;
comment|/* Check if we should immediately send eof on stdin. */
if|if
condition|(
operator|!
name|compat20
condition|)
name|client_check_initial_eof_on_stdin
argument_list|()
expr_stmt|;
if|if
condition|(
name|compat20
operator|&&
name|escape_char
operator|!=
operator|-
literal|1
condition|)
name|channel_register_filter
argument_list|(
name|ssh2_chan_id
argument_list|,
name|simple_escape_filter
argument_list|)
expr_stmt|;
comment|/* Main loop of the client for the interactive session mode. */
while|while
condition|(
operator|!
name|quit_pending
condition|)
block|{
name|fd_set
name|readset
decl_stmt|,
name|writeset
decl_stmt|;
comment|/* Process buffered packets sent by the server. */
name|client_process_buffered_input_packets
argument_list|()
expr_stmt|;
if|if
condition|(
name|compat20
operator|&&
operator|!
name|channel_still_open
argument_list|()
condition|)
block|{
name|debug
argument_list|(
literal|"!channel_still_open."
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Make packets of buffered stdin data, and buffer them for 		 * sending to the server. 		 */
if|if
condition|(
operator|!
name|compat20
condition|)
name|client_make_packets_from_stdin_data
argument_list|()
expr_stmt|;
comment|/* 		 * Make packets from buffered channel data, and buffer them 		 * for sending to the server. 		 */
if|if
condition|(
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
name|channel_output_poll
argument_list|()
expr_stmt|;
comment|/* 		 * Check if the window size has changed, and buffer a message 		 * about it to the server if so. 		 */
name|client_check_window_change
argument_list|()
expr_stmt|;
if|if
condition|(
name|quit_pending
condition|)
break|break;
comment|/* 		 * Wait until we have something to do (something becomes 		 * available on one of the descriptors). 		 */
name|client_wait_until_can_do_something
argument_list|(
operator|&
name|readset
argument_list|,
operator|&
name|writeset
argument_list|)
expr_stmt|;
if|if
condition|(
name|quit_pending
condition|)
break|break;
comment|/* Do channel operations. */
name|channel_after_select
argument_list|(
operator|&
name|readset
argument_list|,
operator|&
name|writeset
argument_list|)
expr_stmt|;
comment|/* Buffer input from the connection.  */
name|client_process_net_input
argument_list|(
operator|&
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
name|quit_pending
condition|)
break|break;
if|if
condition|(
operator|!
name|compat20
condition|)
block|{
comment|/* Buffer data from stdin */
name|client_process_input
argument_list|(
operator|&
name|readset
argument_list|)
expr_stmt|;
comment|/* 			 * Process output to stdout and stderr.  Output to 			 * the connection is processed elsewhere (above). 			 */
name|client_process_output
argument_list|(
operator|&
name|writeset
argument_list|)
expr_stmt|;
block|}
comment|/* Send as much buffered packet data as possible to the sender. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_out
argument_list|,
operator|&
name|writeset
argument_list|)
condition|)
name|packet_write_poll
argument_list|()
expr_stmt|;
block|}
comment|/* Terminate the session. */
comment|/* Stop watching for window change. */
if|if
condition|(
name|have_pty
condition|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* Stop listening for connections. */
name|channel_stop_listening
argument_list|()
expr_stmt|;
comment|/* 	 * In interactive mode (with pseudo tty) display a message indicating 	 * that the connection has been closed. 	 */
if|if
condition|(
name|have_pty
operator|&&
name|options
operator|.
name|log_level
operator|!=
name|SYSLOG_LEVEL_QUIET
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"Connection to %.64s closed.\r\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Output any buffered data for stdout. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Write failed flushing stdout buffer."
argument_list|)
expr_stmt|;
break|break;
block|}
name|buffer_consume
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Output any buffered data for stderr. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Write failed flushing stderr buffer."
argument_list|)
expr_stmt|;
break|break;
block|}
name|buffer_consume
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|have_pty
condition|)
name|leave_raw_mode
argument_list|()
expr_stmt|;
comment|/* Clear and free any buffers. */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
comment|/* Report bytes transferred, and transfer rates. */
name|total_time
operator|=
name|get_current_time
argument_list|()
operator|-
name|start_time
expr_stmt|;
name|debug
argument_list|(
literal|"Transferred: stdin %lu, stdout %lu, stderr %lu bytes in %.1f seconds"
argument_list|,
name|stdin_bytes
argument_list|,
name|stdout_bytes
argument_list|,
name|stderr_bytes
argument_list|,
name|total_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_time
operator|>
literal|0
condition|)
name|debug
argument_list|(
literal|"Bytes per second: stdin %.1f, stdout %.1f, stderr %.1f"
argument_list|,
name|stdin_bytes
operator|/
name|total_time
argument_list|,
name|stdout_bytes
operator|/
name|total_time
argument_list|,
name|stderr_bytes
operator|/
name|total_time
argument_list|)
expr_stmt|;
comment|/* Return the exit status of the program. */
name|debug
argument_list|(
literal|"Exit status %d"
argument_list|,
name|exit_status
argument_list|)
expr_stmt|;
return|return
name|exit_status
return|;
block|}
end_function

begin_comment
comment|/*********/
end_comment

begin_function
name|void
name|client_input_stdout_data
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|)
block|{
name|unsigned
name|int
name|data_len
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
decl_stmt|;
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
literal|4
operator|+
name|data_len
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|stdout_bytes
operator|+=
name|data_len
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_input_stderr_data
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|)
block|{
name|unsigned
name|int
name|data_len
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
decl_stmt|;
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
literal|4
operator|+
name|data_len
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|stdout_bytes
operator|+=
name|data_len
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_input_exit_status
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|)
block|{
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|exit_status
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
comment|/* Acknowledge the exit. */
name|packet_start
argument_list|(
name|SSH_CMSG_EXIT_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* 	 * Must wait for packet to be sent since we are 	 * exiting the loop. 	 */
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Flag that we want to exit. */
name|quit_pending
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXXX move to generic input handler */
end_comment

begin_function
name|void
name|client_input_channel_open
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ctype
decl_stmt|;
name|int
name|id
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|int
name|rchan
decl_stmt|;
name|int
name|rmaxpack
decl_stmt|;
name|int
name|rwindow
decl_stmt|;
name|ctype
operator|=
name|packet_get_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|rchan
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|rwindow
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|rmaxpack
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"client_input_channel_open: ctype %s rchan %d win %d max %d"
argument_list|,
name|ctype
argument_list|,
name|rchan
argument_list|,
name|rwindow
argument_list|,
name|rmaxpack
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"x11"
argument_list|)
operator|==
literal|0
operator|&&
name|options
operator|.
name|forward_x11
condition|)
block|{
name|int
name|sock
decl_stmt|;
name|char
modifier|*
name|originator
decl_stmt|;
name|int
name|originator_port
decl_stmt|;
name|originator
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|datafellows
operator|&
name|SSH_BUG_X11FWD
condition|)
block|{
name|debug
argument_list|(
literal|"buggy server: x11 request w/o originator_port"
argument_list|)
expr_stmt|;
name|originator_port
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|originator_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
block|}
name|packet_done
argument_list|()
expr_stmt|;
comment|/* XXX check permission */
name|xfree
argument_list|(
name|originator
argument_list|)
expr_stmt|;
comment|/* XXX move to channels.c */
name|sock
operator|=
name|x11_connect_display
argument_list|()
expr_stmt|;
if|if
condition|(
name|sock
operator|>=
literal|0
condition|)
block|{
name|id
operator|=
name|channel_new
argument_list|(
literal|"x11"
argument_list|,
name|SSH_CHANNEL_X11_OPEN
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_X11_WINDOW_DEFAULT
argument_list|,
name|CHAN_X11_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
name|xstrdup
argument_list|(
literal|"x11"
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* XXX duplicate : */
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"confirm %s"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
name|rchan
expr_stmt|;
name|c
operator|->
name|remote_window
operator|=
name|rwindow
expr_stmt|;
name|c
operator|->
name|remote_maxpacket
operator|=
name|rmaxpack
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"failure %s"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|rchan
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"bla bla"
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|xfree
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_init_dispatch_20
parameter_list|()
block|{
name|dispatch_init
argument_list|(
operator|&
name|dispatch_protocol_error
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_oclose
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_DATA
argument_list|,
operator|&
name|channel_input_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_EOF
argument_list|,
operator|&
name|channel_input_ieof
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_EXTENDED_DATA
argument_list|,
operator|&
name|channel_input_extended_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|,
operator|&
name|client_input_channel_open
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|,
operator|&
name|channel_input_open_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_FAILURE
argument_list|,
operator|&
name|channel_input_open_failure
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_REQUEST
argument_list|,
operator|&
name|channel_input_channel_request
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_WINDOW_ADJUST
argument_list|,
operator|&
name|channel_input_window_adjust
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_init_dispatch_13
parameter_list|()
block|{
name|dispatch_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_close
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE_CONFIRMATION
argument_list|,
operator|&
name|channel_input_close_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_DATA
argument_list|,
operator|&
name|channel_input_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|,
operator|&
name|channel_input_open_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|,
operator|&
name|channel_input_open_failure
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_PORT_OPEN
argument_list|,
operator|&
name|channel_input_port_open
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_SMSG_EXITSTATUS
argument_list|,
operator|&
name|client_input_exit_status
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_SMSG_STDERR_DATA
argument_list|,
operator|&
name|client_input_stderr_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_SMSG_STDOUT_DATA
argument_list|,
operator|&
name|client_input_stdout_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_SMSG_AGENT_OPEN
argument_list|,
name|options
operator|.
name|forward_agent
condition|?
operator|&
name|auth_input_open_request
else|:
name|NULL
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_SMSG_X11_OPEN
argument_list|,
name|options
operator|.
name|forward_x11
condition|?
operator|&
name|x11_input_open
else|:
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_init_dispatch_15
parameter_list|()
block|{
name|client_init_dispatch_13
argument_list|()
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_ieof
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE_CONFIRMATION
argument_list|,
operator|&
name|channel_input_oclose
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_init_dispatch
parameter_list|()
block|{
if|if
condition|(
name|compat20
condition|)
name|client_init_dispatch_20
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|compat13
condition|)
name|client_init_dispatch_13
argument_list|()
expr_stmt|;
else|else
name|client_init_dispatch_15
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_input_channel_req
parameter_list|(
name|int
name|id
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|int
name|reply
decl_stmt|;
name|char
modifier|*
name|rtype
decl_stmt|;
name|rtype
operator|=
name|packet_get_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|reply
operator|=
name|packet_get_char
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"client_input_channel_req: rtype %s reply %d"
argument_list|,
name|rtype
argument_list|,
name|reply
argument_list|)
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"session_input_channel_req: channel %d: bad channel"
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|session_ident
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"client_input_channel_req: no channel %d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|!=
name|session_ident
condition|)
block|{
name|error
argument_list|(
literal|"client_input_channel_req: bad channel %d != %d"
argument_list|,
name|id
argument_list|,
name|session_ident
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"exit-status"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|success
operator|=
literal|1
expr_stmt|;
name|exit_status
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_done
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reply
condition|)
block|{
name|packet_start
argument_list|(
name|success
condition|?
name|SSH2_MSG_CHANNEL_SUCCESS
else|:
name|SSH2_MSG_CHANNEL_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|xfree
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_set_session_ident
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|debug
argument_list|(
literal|"client_set_session_ident: id %d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|session_ident
operator|=
name|id
expr_stmt|;
name|channel_register_callback
argument_list|(
name|id
argument_list|,
name|SSH2_MSG_CHANNEL_REQUEST
argument_list|,
name|client_input_channel_req
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

