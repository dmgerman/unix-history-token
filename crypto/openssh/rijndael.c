begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: rijndael.c,v 1.7 2001/02/04 15:32:24 stevesk Exp $	*/
end_comment

begin_comment
comment|/* This is an independent implementation of the encryption algorithm:   */
end_comment

begin_comment
comment|/*                                                                      */
end_comment

begin_comment
comment|/*         RIJNDAEL by Joan Daemen and Vincent Rijmen                   */
end_comment

begin_comment
comment|/*                                                                      */
end_comment

begin_comment
comment|/* which is a candidate algorithm in the Advanced Encryption Standard   */
end_comment

begin_comment
comment|/* programme of the US National Institute of Standards and Technology.  */
end_comment

begin_comment
comment|/*                                                                      */
end_comment

begin_comment
comment|/* Copyright in this implementation is held by Dr B R Gladman but I     */
end_comment

begin_comment
comment|/* hereby give permission for its free direct or derivative use subject */
end_comment

begin_comment
comment|/* to acknowledgment of its origin and compliance with any conditions   */
end_comment

begin_comment
comment|/* that the originators of the algorithm place on its exploitation.     */
end_comment

begin_comment
comment|/*                                                                      */
end_comment

begin_comment
comment|/* Dr Brian Gladman (gladman@seven77.demon.co.uk) 14th January 1999     */
end_comment

begin_comment
comment|/* Timing data for Rijndael (rijndael.c)  Algorithm: rijndael (rijndael.c)  128 bit key: Key Setup:    305/1389 cycles (encrypt/decrypt) Encrypt:       374 cycles =    68.4 mbits/sec Decrypt:       352 cycles =    72.7 mbits/sec Mean:          363 cycles =    70.5 mbits/sec  192 bit key: Key Setup:    277/1595 cycles (encrypt/decrypt) Encrypt:       439 cycles =    58.3 mbits/sec Decrypt:       425 cycles =    60.2 mbits/sec Mean:          432 cycles =    59.3 mbits/sec  256 bit key: Key Setup:    374/1960 cycles (encrypt/decrypt) Encrypt:       502 cycles =    51.0 mbits/sec Decrypt:       498 cycles =    51.4 mbits/sec Mean:          500 cycles =    51.2 mbits/sec  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"rijndael.h"
end_include

begin_decl_stmt
name|void
name|gen_tabs
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3. Basic macros for speeding up generic operations               */
end_comment

begin_comment
comment|/* Circular rotate of 32 bit values                                 */
end_comment

begin_define
define|#
directive|define
name|rotr
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|(((x)>> ((int)(n))) | ((x)<< (32 - (int)(n))))
end_define

begin_define
define|#
directive|define
name|rotl
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|(((x)<< ((int)(n))) | ((x)>> (32 - (int)(n))))
end_define

begin_comment
comment|/* Invert byte order in a 32 bit variable                           */
end_comment

begin_define
define|#
directive|define
name|bswap
parameter_list|(
name|x
parameter_list|)
value|((rotl(x, 8)& 0x00ff00ff) | (rotr(x, 8)& 0xff00ff00))
end_define

begin_comment
comment|/* Extract byte from a 32 bit quantity (little endian notation)     */
end_comment

begin_define
define|#
directive|define
name|byte
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|((u1byte)((x)>> (8 * n)))
end_define

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|!=
name|LITTLE_ENDIAN
end_if

begin_define
define|#
directive|define
name|BYTE_SWAP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BYTE_SWAP
end_ifdef

begin_define
define|#
directive|define
name|io_swap
parameter_list|(
name|x
parameter_list|)
value|bswap(x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|io_swap
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LARGE_TABLES
end_define

begin_decl_stmt
name|u1byte
name|pow_tab
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u1byte
name|log_tab
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u1byte
name|sbx_tab
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u1byte
name|isb_tab
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u4byte
name|rco_tab
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u4byte
name|ft_tab
index|[
literal|4
index|]
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u4byte
name|it_tab
index|[
literal|4
index|]
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LARGE_TABLES
end_ifdef

begin_decl_stmt
name|u4byte
name|fl_tab
index|[
literal|4
index|]
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u4byte
name|il_tab
index|[
literal|4
index|]
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|u4byte
name|tab_gen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ff_mult
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a&& b ? pow_tab[(log_tab[a] + log_tab[b]) % 255] : 0)
end_define

begin_define
define|#
directive|define
name|f_rn
parameter_list|(
name|bo
parameter_list|,
name|bi
parameter_list|,
name|n
parameter_list|,
name|k
parameter_list|)
define|\
value|bo[n] =  ft_tab[0][byte(bi[n],0)] ^             \ 	     ft_tab[1][byte(bi[(n + 1)& 3],1)] ^   \ 	     ft_tab[2][byte(bi[(n + 2)& 3],2)] ^   \ 	     ft_tab[3][byte(bi[(n + 3)& 3],3)] ^ *(k + n)
end_define

begin_define
define|#
directive|define
name|i_rn
parameter_list|(
name|bo
parameter_list|,
name|bi
parameter_list|,
name|n
parameter_list|,
name|k
parameter_list|)
define|\
value|bo[n] =  it_tab[0][byte(bi[n],0)] ^             \ 	     it_tab[1][byte(bi[(n + 3)& 3],1)] ^   \ 	     it_tab[2][byte(bi[(n + 2)& 3],2)] ^   \ 	     it_tab[3][byte(bi[(n + 1)& 3],3)] ^ *(k + n)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|LARGE_TABLES
end_ifdef

begin_define
define|#
directive|define
name|ls_box
parameter_list|(
name|x
parameter_list|)
define|\
value|( fl_tab[0][byte(x, 0)] ^    \       fl_tab[1][byte(x, 1)] ^    \       fl_tab[2][byte(x, 2)] ^    \       fl_tab[3][byte(x, 3)] )
end_define

begin_define
define|#
directive|define
name|f_rl
parameter_list|(
name|bo
parameter_list|,
name|bi
parameter_list|,
name|n
parameter_list|,
name|k
parameter_list|)
define|\
value|bo[n] =  fl_tab[0][byte(bi[n],0)] ^             \ 	     fl_tab[1][byte(bi[(n + 1)& 3],1)] ^   \ 	     fl_tab[2][byte(bi[(n + 2)& 3],2)] ^   \ 	     fl_tab[3][byte(bi[(n + 3)& 3],3)] ^ *(k + n)
end_define

begin_define
define|#
directive|define
name|i_rl
parameter_list|(
name|bo
parameter_list|,
name|bi
parameter_list|,
name|n
parameter_list|,
name|k
parameter_list|)
define|\
value|bo[n] =  il_tab[0][byte(bi[n],0)] ^             \ 	     il_tab[1][byte(bi[(n + 3)& 3],1)] ^   \ 	     il_tab[2][byte(bi[(n + 2)& 3],2)] ^   \ 	     il_tab[3][byte(bi[(n + 1)& 3],3)] ^ *(k + n)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ls_box
parameter_list|(
name|x
parameter_list|)
define|\
value|((u4byte)sbx_tab[byte(x, 0)]<<  0) ^    \     ((u4byte)sbx_tab[byte(x, 1)]<<  8) ^    \     ((u4byte)sbx_tab[byte(x, 2)]<< 16) ^    \     ((u4byte)sbx_tab[byte(x, 3)]<< 24)
end_define

begin_define
define|#
directive|define
name|f_rl
parameter_list|(
name|bo
parameter_list|,
name|bi
parameter_list|,
name|n
parameter_list|,
name|k
parameter_list|)
define|\
value|bo[n] = (u4byte)sbx_tab[byte(bi[n],0)] ^                    \ 	rotl(((u4byte)sbx_tab[byte(bi[(n + 1)& 3],1)]),  8) ^  \ 	rotl(((u4byte)sbx_tab[byte(bi[(n + 2)& 3],2)]), 16) ^  \ 	rotl(((u4byte)sbx_tab[byte(bi[(n + 3)& 3],3)]), 24) ^ *(k + n)
end_define

begin_define
define|#
directive|define
name|i_rl
parameter_list|(
name|bo
parameter_list|,
name|bi
parameter_list|,
name|n
parameter_list|,
name|k
parameter_list|)
define|\
value|bo[n] = (u4byte)isb_tab[byte(bi[n],0)] ^                    \ 	rotl(((u4byte)isb_tab[byte(bi[(n + 3)& 3],1)]),  8) ^  \ 	rotl(((u4byte)isb_tab[byte(bi[(n + 2)& 3],2)]), 16) ^  \ 	rotl(((u4byte)isb_tab[byte(bi[(n + 1)& 3],3)]), 24) ^ *(k + n)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|gen_tabs
parameter_list|(
name|void
parameter_list|)
block|{
name|u4byte
name|i
decl_stmt|,
name|t
decl_stmt|;
name|u1byte
name|p
decl_stmt|,
name|q
decl_stmt|;
comment|/* log and power tables for GF(2**8) finite field with  */
comment|/* 0x11b as modular polynomial - the simplest prmitive  */
comment|/* root is 0x11, used here to generate the tables       */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
literal|1
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
name|pow_tab
index|[
name|i
index|]
operator|=
operator|(
name|u1byte
operator|)
name|p
expr_stmt|;
name|log_tab
index|[
name|p
index|]
operator|=
operator|(
name|u1byte
operator|)
name|i
expr_stmt|;
name|p
operator|=
name|p
operator|^
operator|(
name|p
operator|<<
literal|1
operator|)
operator|^
operator|(
name|p
operator|&
literal|0x80
condition|?
literal|0x01b
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|log_tab
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
block|{
name|rco_tab
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|=
operator|(
name|p
operator|<<
literal|1
operator|)
operator|^
operator|(
name|p
operator|&
literal|0x80
condition|?
literal|0x1b
else|:
literal|0
operator|)
expr_stmt|;
block|}
comment|/* note that the affine byte transformation matrix in   */
comment|/* rijndael specification is in big endian format with  */
comment|/* bit 0 as the most significant bit. In the remainder  */
comment|/* of the specification the bits are numbered from the  */
comment|/* least significant end of a byte.                     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
operator|(
name|i
condition|?
name|pow_tab
index|[
literal|255
operator|-
name|log_tab
index|[
name|i
index|]
index|]
else|:
literal|0
operator|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
name|q
operator|=
operator|(
name|q
operator|>>
literal|7
operator|)
operator||
operator|(
name|q
operator|<<
literal|1
operator|)
expr_stmt|;
name|p
operator|^=
name|q
expr_stmt|;
name|q
operator|=
operator|(
name|q
operator|>>
literal|7
operator|)
operator||
operator|(
name|q
operator|<<
literal|1
operator|)
expr_stmt|;
name|p
operator|^=
name|q
expr_stmt|;
name|q
operator|=
operator|(
name|q
operator|>>
literal|7
operator|)
operator||
operator|(
name|q
operator|<<
literal|1
operator|)
expr_stmt|;
name|p
operator|^=
name|q
expr_stmt|;
name|q
operator|=
operator|(
name|q
operator|>>
literal|7
operator|)
operator||
operator|(
name|q
operator|<<
literal|1
operator|)
expr_stmt|;
name|p
operator|^=
name|q
operator|^
literal|0x63
expr_stmt|;
name|sbx_tab
index|[
name|i
index|]
operator|=
operator|(
name|u1byte
operator|)
name|p
expr_stmt|;
name|isb_tab
index|[
name|p
index|]
operator|=
operator|(
name|u1byte
operator|)
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
name|sbx_tab
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|LARGE_TABLES
name|t
operator|=
name|p
expr_stmt|;
name|fl_tab
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
name|fl_tab
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
name|rotl
argument_list|(
name|t
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|fl_tab
index|[
literal|2
index|]
index|[
name|i
index|]
operator|=
name|rotl
argument_list|(
name|t
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|fl_tab
index|[
literal|3
index|]
index|[
name|i
index|]
operator|=
name|rotl
argument_list|(
name|t
argument_list|,
literal|24
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t
operator|=
operator|(
operator|(
name|u4byte
operator|)
name|ff_mult
argument_list|(
literal|2
argument_list|,
name|p
argument_list|)
operator|)
operator||
operator|(
operator|(
name|u4byte
operator|)
name|p
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u4byte
operator|)
name|p
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u4byte
operator|)
name|ff_mult
argument_list|(
literal|3
argument_list|,
name|p
argument_list|)
operator|<<
literal|24
operator|)
expr_stmt|;
name|ft_tab
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
name|ft_tab
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
name|rotl
argument_list|(
name|t
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ft_tab
index|[
literal|2
index|]
index|[
name|i
index|]
operator|=
name|rotl
argument_list|(
name|t
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|ft_tab
index|[
literal|3
index|]
index|[
name|i
index|]
operator|=
name|rotl
argument_list|(
name|t
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|p
operator|=
name|isb_tab
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|LARGE_TABLES
name|t
operator|=
name|p
expr_stmt|;
name|il_tab
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
name|il_tab
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
name|rotl
argument_list|(
name|t
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|il_tab
index|[
literal|2
index|]
index|[
name|i
index|]
operator|=
name|rotl
argument_list|(
name|t
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|il_tab
index|[
literal|3
index|]
index|[
name|i
index|]
operator|=
name|rotl
argument_list|(
name|t
argument_list|,
literal|24
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t
operator|=
operator|(
operator|(
name|u4byte
operator|)
name|ff_mult
argument_list|(
literal|14
argument_list|,
name|p
argument_list|)
operator|)
operator||
operator|(
operator|(
name|u4byte
operator|)
name|ff_mult
argument_list|(
literal|9
argument_list|,
name|p
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u4byte
operator|)
name|ff_mult
argument_list|(
literal|13
argument_list|,
name|p
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u4byte
operator|)
name|ff_mult
argument_list|(
literal|11
argument_list|,
name|p
argument_list|)
operator|<<
literal|24
operator|)
expr_stmt|;
name|it_tab
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
name|it_tab
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
name|rotl
argument_list|(
name|t
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|it_tab
index|[
literal|2
index|]
index|[
name|i
index|]
operator|=
name|rotl
argument_list|(
name|t
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|it_tab
index|[
literal|3
index|]
index|[
name|i
index|]
operator|=
name|rotl
argument_list|(
name|t
argument_list|,
literal|24
argument_list|)
expr_stmt|;
block|}
name|tab_gen
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|star_x
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x7f7f7f7f)<< 1) ^ ((((x)& 0x80808080)>> 7) * 0x1b)
end_define

begin_define
define|#
directive|define
name|imix_col
parameter_list|(
name|y
parameter_list|,
name|x
parameter_list|)
define|\
value|u   = star_x(x);        \     v   = star_x(u);        \     w   = star_x(v);        \     t   = w ^ (x);          \    (y)  = u ^ v ^ w;        \    (y) ^= rotr(u ^ t,  8) ^ \ 	  rotr(v ^ t, 16) ^ \ 	  rotr(t,24)
end_define

begin_comment
comment|/* initialise the key schedule from the user supplied key   */
end_comment

begin_define
define|#
directive|define
name|loop4
parameter_list|(
name|i
parameter_list|)
define|\
value|{   t = ls_box(rotr(t,  8)) ^ rco_tab[i];           \     t ^= e_key[4 * i];     e_key[4 * i + 4] = t;    \     t ^= e_key[4 * i + 1]; e_key[4 * i + 5] = t;    \     t ^= e_key[4 * i + 2]; e_key[4 * i + 6] = t;    \     t ^= e_key[4 * i + 3]; e_key[4 * i + 7] = t;    \ }
end_define

begin_define
define|#
directive|define
name|loop6
parameter_list|(
name|i
parameter_list|)
define|\
value|{   t = ls_box(rotr(t,  8)) ^ rco_tab[i];           \     t ^= e_key[6 * i];     e_key[6 * i + 6] = t;    \     t ^= e_key[6 * i + 1]; e_key[6 * i + 7] = t;    \     t ^= e_key[6 * i + 2]; e_key[6 * i + 8] = t;    \     t ^= e_key[6 * i + 3]; e_key[6 * i + 9] = t;    \     t ^= e_key[6 * i + 4]; e_key[6 * i + 10] = t;   \     t ^= e_key[6 * i + 5]; e_key[6 * i + 11] = t;   \ }
end_define

begin_define
define|#
directive|define
name|loop8
parameter_list|(
name|i
parameter_list|)
define|\
value|{   t = ls_box(rotr(t,  8)) ^ rco_tab[i];           \     t ^= e_key[8 * i];     e_key[8 * i + 8] = t;    \     t ^= e_key[8 * i + 1]; e_key[8 * i + 9] = t;    \     t ^= e_key[8 * i + 2]; e_key[8 * i + 10] = t;   \     t ^= e_key[8 * i + 3]; e_key[8 * i + 11] = t;   \     t  = e_key[8 * i + 4] ^ ls_box(t);              \     e_key[8 * i + 12] = t;                          \     t ^= e_key[8 * i + 5]; e_key[8 * i + 13] = t;   \     t ^= e_key[8 * i + 6]; e_key[8 * i + 14] = t;   \     t ^= e_key[8 * i + 7]; e_key[8 * i + 15] = t;   \ }
end_define

begin_function
name|rijndael_ctx
modifier|*
name|rijndael_set_key
parameter_list|(
name|rijndael_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u4byte
modifier|*
name|in_key
parameter_list|,
specifier|const
name|u4byte
name|key_len
parameter_list|,
name|int
name|encrypt
parameter_list|)
block|{
name|u4byte
name|i
decl_stmt|,
name|t
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|w
decl_stmt|;
name|u4byte
modifier|*
name|e_key
init|=
name|ctx
operator|->
name|e_key
decl_stmt|;
name|u4byte
modifier|*
name|d_key
init|=
name|ctx
operator|->
name|d_key
decl_stmt|;
name|ctx
operator|->
name|decrypt
operator|=
operator|!
name|encrypt
expr_stmt|;
if|if
condition|(
operator|!
name|tab_gen
condition|)
name|gen_tabs
argument_list|()
expr_stmt|;
name|ctx
operator|->
name|k_len
operator|=
operator|(
name|key_len
operator|+
literal|31
operator|)
operator|/
literal|32
expr_stmt|;
name|e_key
index|[
literal|0
index|]
operator|=
name|io_swap
argument_list|(
name|in_key
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|e_key
index|[
literal|1
index|]
operator|=
name|io_swap
argument_list|(
name|in_key
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|e_key
index|[
literal|2
index|]
operator|=
name|io_swap
argument_list|(
name|in_key
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|e_key
index|[
literal|3
index|]
operator|=
name|io_swap
argument_list|(
name|in_key
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ctx
operator|->
name|k_len
condition|)
block|{
case|case
literal|4
case|:
name|t
operator|=
name|e_key
index|[
literal|3
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
name|loop4
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|e_key
index|[
literal|4
index|]
operator|=
name|io_swap
argument_list|(
name|in_key
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|t
operator|=
name|e_key
index|[
literal|5
index|]
operator|=
name|io_swap
argument_list|(
name|in_key
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|loop6
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|e_key
index|[
literal|4
index|]
operator|=
name|io_swap
argument_list|(
name|in_key
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|e_key
index|[
literal|5
index|]
operator|=
name|io_swap
argument_list|(
name|in_key
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|e_key
index|[
literal|6
index|]
operator|=
name|io_swap
argument_list|(
name|in_key
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|t
operator|=
name|e_key
index|[
literal|7
index|]
operator|=
name|io_swap
argument_list|(
name|in_key
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
operator|++
name|i
control|)
name|loop8
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|encrypt
condition|)
block|{
name|d_key
index|[
literal|0
index|]
operator|=
name|e_key
index|[
literal|0
index|]
expr_stmt|;
name|d_key
index|[
literal|1
index|]
operator|=
name|e_key
index|[
literal|1
index|]
expr_stmt|;
name|d_key
index|[
literal|2
index|]
operator|=
name|e_key
index|[
literal|2
index|]
expr_stmt|;
name|d_key
index|[
literal|3
index|]
operator|=
name|e_key
index|[
literal|3
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
literal|4
operator|*
name|ctx
operator|->
name|k_len
operator|+
literal|24
condition|;
operator|++
name|i
control|)
block|{
name|imix_col
argument_list|(
name|d_key
index|[
name|i
index|]
argument_list|,
name|e_key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ctx
return|;
block|}
end_function

begin_comment
comment|/* encrypt a block of text  */
end_comment

begin_define
define|#
directive|define
name|f_nround
parameter_list|(
name|bo
parameter_list|,
name|bi
parameter_list|,
name|k
parameter_list|)
define|\
value|f_rn(bo, bi, 0, k);     \     f_rn(bo, bi, 1, k);     \     f_rn(bo, bi, 2, k);     \     f_rn(bo, bi, 3, k);     \     k += 4
end_define

begin_define
define|#
directive|define
name|f_lround
parameter_list|(
name|bo
parameter_list|,
name|bi
parameter_list|,
name|k
parameter_list|)
define|\
value|f_rl(bo, bi, 0, k);     \     f_rl(bo, bi, 1, k);     \     f_rl(bo, bi, 2, k);     \     f_rl(bo, bi, 3, k)
end_define

begin_function
name|void
name|rijndael_encrypt
parameter_list|(
name|rijndael_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u4byte
modifier|*
name|in_blk
parameter_list|,
name|u4byte
modifier|*
name|out_blk
parameter_list|)
block|{
name|u4byte
name|k_len
init|=
name|ctx
operator|->
name|k_len
decl_stmt|;
name|u4byte
modifier|*
name|e_key
init|=
name|ctx
operator|->
name|e_key
decl_stmt|;
name|u4byte
name|b0
index|[
literal|4
index|]
decl_stmt|,
name|b1
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|kp
decl_stmt|;
name|b0
index|[
literal|0
index|]
operator|=
name|io_swap
argument_list|(
name|in_blk
index|[
literal|0
index|]
argument_list|)
operator|^
name|e_key
index|[
literal|0
index|]
expr_stmt|;
name|b0
index|[
literal|1
index|]
operator|=
name|io_swap
argument_list|(
name|in_blk
index|[
literal|1
index|]
argument_list|)
operator|^
name|e_key
index|[
literal|1
index|]
expr_stmt|;
name|b0
index|[
literal|2
index|]
operator|=
name|io_swap
argument_list|(
name|in_blk
index|[
literal|2
index|]
argument_list|)
operator|^
name|e_key
index|[
literal|2
index|]
expr_stmt|;
name|b0
index|[
literal|3
index|]
operator|=
name|io_swap
argument_list|(
name|in_blk
index|[
literal|3
index|]
argument_list|)
operator|^
name|e_key
index|[
literal|3
index|]
expr_stmt|;
name|kp
operator|=
name|e_key
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|k_len
operator|>
literal|6
condition|)
block|{
name|f_nround
argument_list|(
name|b1
argument_list|,
name|b0
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|f_nround
argument_list|(
name|b0
argument_list|,
name|b1
argument_list|,
name|kp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k_len
operator|>
literal|4
condition|)
block|{
name|f_nround
argument_list|(
name|b1
argument_list|,
name|b0
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|f_nround
argument_list|(
name|b0
argument_list|,
name|b1
argument_list|,
name|kp
argument_list|)
expr_stmt|;
block|}
name|f_nround
argument_list|(
name|b1
argument_list|,
name|b0
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|f_nround
argument_list|(
name|b0
argument_list|,
name|b1
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|f_nround
argument_list|(
name|b1
argument_list|,
name|b0
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|f_nround
argument_list|(
name|b0
argument_list|,
name|b1
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|f_nround
argument_list|(
name|b1
argument_list|,
name|b0
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|f_nround
argument_list|(
name|b0
argument_list|,
name|b1
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|f_nround
argument_list|(
name|b1
argument_list|,
name|b0
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|f_nround
argument_list|(
name|b0
argument_list|,
name|b1
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|f_nround
argument_list|(
name|b1
argument_list|,
name|b0
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|f_lround
argument_list|(
name|b0
argument_list|,
name|b1
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|out_blk
index|[
literal|0
index|]
operator|=
name|io_swap
argument_list|(
name|b0
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|out_blk
index|[
literal|1
index|]
operator|=
name|io_swap
argument_list|(
name|b0
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|out_blk
index|[
literal|2
index|]
operator|=
name|io_swap
argument_list|(
name|b0
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|out_blk
index|[
literal|3
index|]
operator|=
name|io_swap
argument_list|(
name|b0
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* decrypt a block of text  */
end_comment

begin_define
define|#
directive|define
name|i_nround
parameter_list|(
name|bo
parameter_list|,
name|bi
parameter_list|,
name|k
parameter_list|)
define|\
value|i_rn(bo, bi, 0, k);     \     i_rn(bo, bi, 1, k);     \     i_rn(bo, bi, 2, k);     \     i_rn(bo, bi, 3, k);     \     k -= 4
end_define

begin_define
define|#
directive|define
name|i_lround
parameter_list|(
name|bo
parameter_list|,
name|bi
parameter_list|,
name|k
parameter_list|)
define|\
value|i_rl(bo, bi, 0, k);     \     i_rl(bo, bi, 1, k);     \     i_rl(bo, bi, 2, k);     \     i_rl(bo, bi, 3, k)
end_define

begin_function
name|void
name|rijndael_decrypt
parameter_list|(
name|rijndael_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u4byte
modifier|*
name|in_blk
parameter_list|,
name|u4byte
modifier|*
name|out_blk
parameter_list|)
block|{
name|u4byte
name|b0
index|[
literal|4
index|]
decl_stmt|,
name|b1
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|kp
decl_stmt|;
name|u4byte
name|k_len
init|=
name|ctx
operator|->
name|k_len
decl_stmt|;
name|u4byte
modifier|*
name|e_key
init|=
name|ctx
operator|->
name|e_key
decl_stmt|;
name|u4byte
modifier|*
name|d_key
init|=
name|ctx
operator|->
name|d_key
decl_stmt|;
name|b0
index|[
literal|0
index|]
operator|=
name|io_swap
argument_list|(
name|in_blk
index|[
literal|0
index|]
argument_list|)
operator|^
name|e_key
index|[
literal|4
operator|*
name|k_len
operator|+
literal|24
index|]
expr_stmt|;
name|b0
index|[
literal|1
index|]
operator|=
name|io_swap
argument_list|(
name|in_blk
index|[
literal|1
index|]
argument_list|)
operator|^
name|e_key
index|[
literal|4
operator|*
name|k_len
operator|+
literal|25
index|]
expr_stmt|;
name|b0
index|[
literal|2
index|]
operator|=
name|io_swap
argument_list|(
name|in_blk
index|[
literal|2
index|]
argument_list|)
operator|^
name|e_key
index|[
literal|4
operator|*
name|k_len
operator|+
literal|26
index|]
expr_stmt|;
name|b0
index|[
literal|3
index|]
operator|=
name|io_swap
argument_list|(
name|in_blk
index|[
literal|3
index|]
argument_list|)
operator|^
name|e_key
index|[
literal|4
operator|*
name|k_len
operator|+
literal|27
index|]
expr_stmt|;
name|kp
operator|=
name|d_key
operator|+
literal|4
operator|*
operator|(
name|k_len
operator|+
literal|5
operator|)
expr_stmt|;
if|if
condition|(
name|k_len
operator|>
literal|6
condition|)
block|{
name|i_nround
argument_list|(
name|b1
argument_list|,
name|b0
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|i_nround
argument_list|(
name|b0
argument_list|,
name|b1
argument_list|,
name|kp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k_len
operator|>
literal|4
condition|)
block|{
name|i_nround
argument_list|(
name|b1
argument_list|,
name|b0
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|i_nround
argument_list|(
name|b0
argument_list|,
name|b1
argument_list|,
name|kp
argument_list|)
expr_stmt|;
block|}
name|i_nround
argument_list|(
name|b1
argument_list|,
name|b0
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|i_nround
argument_list|(
name|b0
argument_list|,
name|b1
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|i_nround
argument_list|(
name|b1
argument_list|,
name|b0
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|i_nround
argument_list|(
name|b0
argument_list|,
name|b1
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|i_nround
argument_list|(
name|b1
argument_list|,
name|b0
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|i_nround
argument_list|(
name|b0
argument_list|,
name|b1
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|i_nround
argument_list|(
name|b1
argument_list|,
name|b0
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|i_nround
argument_list|(
name|b0
argument_list|,
name|b1
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|i_nround
argument_list|(
name|b1
argument_list|,
name|b0
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|i_lround
argument_list|(
name|b0
argument_list|,
name|b1
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|out_blk
index|[
literal|0
index|]
operator|=
name|io_swap
argument_list|(
name|b0
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|out_blk
index|[
literal|1
index|]
operator|=
name|io_swap
argument_list|(
name|b0
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|out_blk
index|[
literal|2
index|]
operator|=
name|io_swap
argument_list|(
name|b0
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|out_blk
index|[
literal|3
index|]
operator|=
name|io_swap
argument_list|(
name|b0
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

