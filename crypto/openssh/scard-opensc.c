begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002 Juha Yrjölä.  All rights reserved.  * Copyright (c) 2001 Markus Friedl.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SMARTCARD
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_OPENSC
argument_list|)
end_if

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509.h>
end_include

begin_include
include|#
directive|include
file|<opensc/opensc.h>
end_include

begin_include
include|#
directive|include
file|<opensc/pkcs15.h>
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"readpass.h"
end_include

begin_include
include|#
directive|include
file|"scard.h"
end_include

begin_if
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|<
literal|0x00907000L
operator|&&
name|defined
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
end_if

begin_define
define|#
directive|define
name|USE_ENGINE
end_define

begin_define
define|#
directive|define
name|RSA_get_default_method
value|RSA_get_default_openssl_method
end_define

begin_else
else|#
directive|else
end_else

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ENGINE
end_ifdef

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_define
define|#
directive|define
name|sc_get_rsa
value|sc_get_engine
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|sc_get_rsa
value|sc_get_rsa_method
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|sc_reader_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sc_context_t
modifier|*
name|ctx
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sc_card_t
modifier|*
name|card
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sc_pkcs15_card_t
modifier|*
name|p15card
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sc_pin
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|sc_priv_data
block|{
name|struct
name|sc_pkcs15_id
name|cert_id
decl_stmt|;
name|int
name|ref_count
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|sc_close
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|p15card
condition|)
block|{
name|sc_pkcs15_unbind
argument_list|(
name|p15card
argument_list|)
expr_stmt|;
name|p15card
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|card
condition|)
block|{
name|sc_disconnect_card
argument_list|(
name|card
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|card
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ctx
condition|)
block|{
name|sc_release_context
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sc_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|sc_establish_context
argument_list|(
operator|&
name|ctx
argument_list|,
literal|"openssh"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|sc_reader_id
operator|>=
name|ctx
operator|->
name|reader_count
condition|)
block|{
name|r
operator|=
name|SC_ERROR_NO_READERS_FOUND
expr_stmt|;
name|error
argument_list|(
literal|"Illegal reader number %d (max %d)"
argument_list|,
name|sc_reader_id
argument_list|,
name|ctx
operator|->
name|reader_count
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|r
operator|=
name|sc_connect_card
argument_list|(
name|ctx
operator|->
name|reader
index|[
name|sc_reader_id
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|card
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
goto|goto
name|err
goto|;
name|r
operator|=
name|sc_pkcs15_bind
argument_list|(
name|card
argument_list|,
operator|&
name|p15card
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
goto|goto
name|err
goto|;
return|return
literal|0
return|;
name|err
label|:
name|sc_close
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* private key operations */
end_comment

begin_function
specifier|static
name|int
name|sc_prkey_op_init
parameter_list|(
name|RSA
modifier|*
name|rsa
parameter_list|,
name|struct
name|sc_pkcs15_object
modifier|*
modifier|*
name|key_obj_out
parameter_list|,
name|unsigned
name|int
name|usage
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|sc_priv_data
modifier|*
name|priv
decl_stmt|;
name|struct
name|sc_pkcs15_object
modifier|*
name|key_obj
decl_stmt|;
name|struct
name|sc_pkcs15_prkey_info
modifier|*
name|key
decl_stmt|;
name|struct
name|sc_pkcs15_object
modifier|*
name|pin_obj
decl_stmt|;
name|struct
name|sc_pkcs15_pin_info
modifier|*
name|pin
decl_stmt|;
name|priv
operator|=
operator|(
expr|struct
name|sc_priv_data
operator|*
operator|)
name|RSA_get_app_data
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|p15card
operator|==
name|NULL
condition|)
block|{
name|sc_close
argument_list|()
expr_stmt|;
name|r
operator|=
name|sc_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|error
argument_list|(
literal|"SmartCard init failed: %s"
argument_list|,
name|sc_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|r
operator|=
name|sc_pkcs15_find_prkey_by_id_usage
argument_list|(
name|p15card
argument_list|,
operator|&
name|priv
operator|->
name|cert_id
argument_list|,
name|usage
argument_list|,
operator|&
name|key_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|error
argument_list|(
literal|"Unable to find private key from SmartCard: %s"
argument_list|,
name|sc_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|key
operator|=
name|key_obj
operator|->
name|data
expr_stmt|;
name|r
operator|=
name|sc_pkcs15_find_pin_by_auth_id
argument_list|(
name|p15card
argument_list|,
operator|&
name|key_obj
operator|->
name|auth_id
argument_list|,
operator|&
name|pin_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|SC_ERROR_OBJECT_NOT_FOUND
condition|)
block|{
comment|/* no pin required */
name|r
operator|=
name|sc_lock
argument_list|(
name|card
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|error
argument_list|(
literal|"Unable to lock smartcard: %s"
argument_list|,
name|sc_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|*
name|key_obj_out
operator|=
name|key_obj
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|r
condition|)
block|{
name|error
argument_list|(
literal|"Unable to find PIN object from SmartCard: %s"
argument_list|,
name|sc_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|pin
operator|=
name|pin_obj
operator|->
name|data
expr_stmt|;
name|r
operator|=
name|sc_lock
argument_list|(
name|card
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|error
argument_list|(
literal|"Unable to lock smartcard: %s"
argument_list|,
name|sc_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|sc_pin
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|sc_pkcs15_verify_pin
argument_list|(
name|p15card
argument_list|,
name|pin
argument_list|,
name|sc_pin
argument_list|,
name|strlen
argument_list|(
name|sc_pin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|sc_unlock
argument_list|(
name|card
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIN code verification failed: %s"
argument_list|,
name|sc_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
operator|*
name|key_obj_out
operator|=
name|key_obj
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
name|sc_close
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SC_USAGE_DECRYPT
value|SC_PKCS15_PRKEY_USAGE_DECRYPT | \ 				SC_PKCS15_PRKEY_USAGE_UNWRAP
end_define

begin_function
specifier|static
name|int
name|sc_private_decrypt
parameter_list|(
name|int
name|flen
parameter_list|,
name|u_char
modifier|*
name|from
parameter_list|,
name|u_char
modifier|*
name|to
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|int
name|padding
parameter_list|)
block|{
name|struct
name|sc_pkcs15_object
modifier|*
name|key_obj
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|padding
operator|!=
name|RSA_PKCS1_PADDING
condition|)
return|return
operator|-
literal|1
return|;
name|r
operator|=
name|sc_prkey_op_init
argument_list|(
name|rsa
argument_list|,
operator|&
name|key_obj
argument_list|,
name|SC_USAGE_DECRYPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
operator|-
literal|1
return|;
name|r
operator|=
name|sc_pkcs15_decipher
argument_list|(
name|p15card
argument_list|,
name|key_obj
argument_list|,
name|SC_ALGORITHM_RSA_PAD_PKCS1
argument_list|,
name|from
argument_list|,
name|flen
argument_list|,
name|to
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|sc_unlock
argument_list|(
name|card
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"sc_pkcs15_decipher() failed: %s"
argument_list|,
name|sc_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
name|r
return|;
name|err
label|:
name|sc_close
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SC_USAGE_SIGN
value|SC_PKCS15_PRKEY_USAGE_SIGN | \ 				SC_PKCS15_PRKEY_USAGE_SIGNRECOVER
end_define

begin_function
specifier|static
name|int
name|sc_sign
parameter_list|(
name|int
name|type
parameter_list|,
name|u_char
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|m_len
parameter_list|,
name|unsigned
name|char
modifier|*
name|sigret
parameter_list|,
name|unsigned
name|int
modifier|*
name|siglen
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|)
block|{
name|struct
name|sc_pkcs15_object
modifier|*
name|key_obj
decl_stmt|;
name|int
name|r
decl_stmt|;
name|unsigned
name|long
name|flags
init|=
literal|0
decl_stmt|;
comment|/* XXX: sc_prkey_op_init will search for a pkcs15 private 	 * key object with the sign or signrecover usage flag set. 	 * If the signing key has only the non-repudiation flag set 	 * the key will be rejected as using a non-repudiation key 	 * for authentication is not recommended. Note: This does not 	 * prevent the use of a non-repudiation key for authentication 	 * if the sign or signrecover flag is set as well.  	 */
name|r
operator|=
name|sc_prkey_op_init
argument_list|(
name|rsa
argument_list|,
operator|&
name|key_obj
argument_list|,
name|SC_USAGE_SIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
operator|-
literal|1
return|;
comment|/* FIXME: length of sigret correct? */
comment|/* FIXME: check 'type' and modify flags accordingly */
name|flags
operator|=
name|SC_ALGORITHM_RSA_PAD_PKCS1
operator||
name|SC_ALGORITHM_RSA_HASH_SHA1
expr_stmt|;
name|r
operator|=
name|sc_pkcs15_compute_signature
argument_list|(
name|p15card
argument_list|,
name|key_obj
argument_list|,
name|flags
argument_list|,
name|m
argument_list|,
name|m_len
argument_list|,
name|sigret
argument_list|,
name|RSA_size
argument_list|(
name|rsa
argument_list|)
argument_list|)
expr_stmt|;
name|sc_unlock
argument_list|(
name|card
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"sc_pkcs15_compute_signature() failed: %s"
argument_list|,
name|sc_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|*
name|siglen
operator|=
name|r
expr_stmt|;
return|return
literal|1
return|;
name|err
label|:
name|sc_close
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sc_private_encrypt
parameter_list|(
name|int
name|flen
parameter_list|,
name|u_char
modifier|*
name|from
parameter_list|,
name|u_char
modifier|*
name|to
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|int
name|padding
parameter_list|)
block|{
name|error
argument_list|(
literal|"Private key encryption not supported"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* called on free */
end_comment

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|orig_finish
function_decl|)
parameter_list|(
name|RSA
modifier|*
name|rsa
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|sc_finish
parameter_list|(
name|RSA
modifier|*
name|rsa
parameter_list|)
block|{
name|struct
name|sc_priv_data
modifier|*
name|priv
decl_stmt|;
name|priv
operator|=
name|RSA_get_app_data
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
name|priv
operator|->
name|ref_count
operator|--
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|ref_count
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|sc_close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|orig_finish
condition|)
name|orig_finish
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* engine for overloading private key operations */
end_comment

begin_function
specifier|static
name|RSA_METHOD
modifier|*
name|sc_get_rsa_method
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|RSA_METHOD
name|smart_rsa
decl_stmt|;
specifier|const
name|RSA_METHOD
modifier|*
name|def
init|=
name|RSA_get_default_method
argument_list|()
decl_stmt|;
comment|/* use the OpenSSL version */
name|memcpy
argument_list|(
operator|&
name|smart_rsa
argument_list|,
name|def
argument_list|,
sizeof|sizeof
argument_list|(
name|smart_rsa
argument_list|)
argument_list|)
expr_stmt|;
name|smart_rsa
operator|.
name|name
operator|=
literal|"opensc"
expr_stmt|;
comment|/* overload */
name|smart_rsa
operator|.
name|rsa_priv_enc
operator|=
name|sc_private_encrypt
expr_stmt|;
name|smart_rsa
operator|.
name|rsa_priv_dec
operator|=
name|sc_private_decrypt
expr_stmt|;
name|smart_rsa
operator|.
name|rsa_sign
operator|=
name|sc_sign
expr_stmt|;
comment|/* save original */
name|orig_finish
operator|=
name|def
operator|->
name|finish
expr_stmt|;
name|smart_rsa
operator|.
name|finish
operator|=
name|sc_finish
expr_stmt|;
return|return
operator|&
name|smart_rsa
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ENGINE
end_ifdef

begin_function
specifier|static
name|ENGINE
modifier|*
name|sc_get_engine
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|ENGINE
modifier|*
name|smart_engine
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|smart_engine
operator|=
name|ENGINE_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"ENGINE_new failed"
argument_list|)
expr_stmt|;
name|ENGINE_set_id
argument_list|(
name|smart_engine
argument_list|,
literal|"opensc"
argument_list|)
expr_stmt|;
name|ENGINE_set_name
argument_list|(
name|smart_engine
argument_list|,
literal|"OpenSC"
argument_list|)
expr_stmt|;
name|ENGINE_set_RSA
argument_list|(
name|smart_engine
argument_list|,
name|sc_get_rsa_method
argument_list|()
argument_list|)
expr_stmt|;
name|ENGINE_set_DSA
argument_list|(
name|smart_engine
argument_list|,
name|DSA_get_default_openssl_method
argument_list|()
argument_list|)
expr_stmt|;
name|ENGINE_set_DH
argument_list|(
name|smart_engine
argument_list|,
name|DH_get_default_openssl_method
argument_list|()
argument_list|)
expr_stmt|;
name|ENGINE_set_RAND
argument_list|(
name|smart_engine
argument_list|,
name|RAND_SSLeay
argument_list|()
argument_list|)
expr_stmt|;
name|ENGINE_set_BN_mod_exp
argument_list|(
name|smart_engine
argument_list|,
name|BN_mod_exp
argument_list|)
expr_stmt|;
return|return
name|smart_engine
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|convert_rsa_to_rsa1
parameter_list|(
name|Key
modifier|*
name|in
parameter_list|,
name|Key
modifier|*
name|out
parameter_list|)
block|{
name|struct
name|sc_priv_data
modifier|*
name|priv
decl_stmt|;
name|out
operator|->
name|rsa
operator|->
name|flags
operator|=
name|in
operator|->
name|rsa
operator|->
name|flags
expr_stmt|;
name|out
operator|->
name|flags
operator|=
name|in
operator|->
name|flags
expr_stmt|;
name|RSA_set_method
argument_list|(
name|out
operator|->
name|rsa
argument_list|,
name|RSA_get_method
argument_list|(
name|in
operator|->
name|rsa
argument_list|)
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|out
operator|->
name|rsa
operator|->
name|n
argument_list|,
name|in
operator|->
name|rsa
operator|->
name|n
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|out
operator|->
name|rsa
operator|->
name|e
argument_list|,
name|in
operator|->
name|rsa
operator|->
name|e
argument_list|)
expr_stmt|;
name|priv
operator|=
name|RSA_get_app_data
argument_list|(
name|in
operator|->
name|rsa
argument_list|)
expr_stmt|;
name|priv
operator|->
name|ref_count
operator|++
expr_stmt|;
name|RSA_set_app_data
argument_list|(
name|out
operator|->
name|rsa
argument_list|,
name|priv
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|sc_read_pubkey
parameter_list|(
name|Key
modifier|*
name|k
parameter_list|,
specifier|const
name|struct
name|sc_pkcs15_object
modifier|*
name|cert_obj
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|sc_pkcs15_cert_t
modifier|*
name|cert
init|=
name|NULL
decl_stmt|;
name|struct
name|sc_priv_data
modifier|*
name|priv
init|=
name|NULL
decl_stmt|;
name|sc_pkcs15_cert_info_t
modifier|*
name|cinfo
init|=
name|cert_obj
operator|->
name|data
decl_stmt|;
name|X509
modifier|*
name|x509
init|=
name|NULL
decl_stmt|;
name|EVP_PKEY
modifier|*
name|pubkey
init|=
name|NULL
decl_stmt|;
name|u8
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|debug
argument_list|(
literal|"sc_read_pubkey() with cert id %02X"
argument_list|,
name|cinfo
operator|->
name|id
operator|.
name|value
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|r
operator|=
name|sc_pkcs15_read_certificate
argument_list|(
name|p15card
argument_list|,
name|cinfo
argument_list|,
operator|&
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|logit
argument_list|(
literal|"Certificate read failed: %s"
argument_list|,
name|sc_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|x509
operator|=
name|X509_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|x509
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|=
name|cert
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|d2i_X509
argument_list|(
operator|&
name|x509
argument_list|,
operator|&
name|p
argument_list|,
name|cert
operator|->
name|data_len
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"Unable to parse X.509 certificate"
argument_list|)
expr_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|sc_pkcs15_free_certificate
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|cert
operator|=
name|NULL
expr_stmt|;
name|pubkey
operator|=
name|X509_get_pubkey
argument_list|(
name|x509
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
name|x509
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pubkey
operator|->
name|type
operator|!=
name|EVP_PKEY_RSA
condition|)
block|{
name|logit
argument_list|(
literal|"Public key is of unknown type"
argument_list|)
expr_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|k
operator|->
name|rsa
operator|=
name|EVP_PKEY_get1_RSA
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
name|k
operator|->
name|rsa
operator|->
name|flags
operator||=
name|RSA_FLAG_SIGN_VER
expr_stmt|;
name|RSA_set_method
argument_list|(
name|k
operator|->
name|rsa
argument_list|,
name|sc_get_rsa_method
argument_list|()
argument_list|)
expr_stmt|;
name|priv
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sc_priv_data
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|cert_id
operator|=
name|cinfo
operator|->
name|id
expr_stmt|;
name|priv
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
name|RSA_set_app_data
argument_list|(
name|k
operator|->
name|rsa
argument_list|,
name|priv
argument_list|)
expr_stmt|;
name|k
operator|->
name|flags
operator|=
name|KEY_FLAG_EXT
expr_stmt|;
name|tmp
operator|=
name|key_fingerprint
argument_list|(
name|k
argument_list|,
name|SSH_FP_MD5
argument_list|,
name|SSH_FP_HEX
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"fingerprint %d %s"
argument_list|,
name|key_size
argument_list|(
name|k
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
if|if
condition|(
name|cert
condition|)
name|sc_pkcs15_free_certificate
argument_list|(
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|pubkey
condition|)
name|EVP_PKEY_free
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|x509
condition|)
name|X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|Key
modifier|*
modifier|*
name|sc_get_keys
parameter_list|(
specifier|const
name|char
modifier|*
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|pin
parameter_list|)
block|{
name|Key
modifier|*
name|k
decl_stmt|,
modifier|*
modifier|*
name|keys
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|real_count
init|=
literal|0
decl_stmt|,
name|key_count
decl_stmt|;
name|sc_pkcs15_id_t
name|cert_id
decl_stmt|;
name|sc_pkcs15_object_t
modifier|*
name|certs
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xstrdup
argument_list|(
name|id
argument_list|)
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|debug
argument_list|(
literal|"sc_get_keys called: id = %s"
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_pin
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|sc_pin
argument_list|)
expr_stmt|;
name|sc_pin
operator|=
operator|(
name|pin
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|xstrdup
argument_list|(
name|pin
argument_list|)
expr_stmt|;
name|cert_id
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|sc_pkcs15_hex_string_to_id
argument_list|(
name|p
argument_list|,
operator|&
name|cert_id
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|sc_reader_id
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|1
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|p15card
operator|==
name|NULL
condition|)
block|{
name|sc_close
argument_list|()
expr_stmt|;
name|r
operator|=
name|sc_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|error
argument_list|(
literal|"Smartcard init failed: %s"
argument_list|,
name|sc_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|cert_id
operator|.
name|len
condition|)
block|{
name|r
operator|=
name|sc_pkcs15_find_cert_by_id
argument_list|(
name|p15card
argument_list|,
operator|&
name|cert_id
argument_list|,
operator|&
name|certs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
name|key_count
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|sc_pkcs15_get_objects
argument_list|(
name|p15card
argument_list|,
name|SC_PKCS15_TYPE_CERT_X509
argument_list|,
name|certs
argument_list|,
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"No certificates found on smartcard"
argument_list|)
expr_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Certificate enumeration failed: %s"
argument_list|,
name|sc_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|key_count
operator|=
name|r
expr_stmt|;
block|}
name|keys
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Key
operator|*
argument_list|)
operator|*
operator|(
name|key_count
operator|*
literal|2
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|key_count
condition|;
name|i
operator|++
control|)
block|{
name|sc_pkcs15_object_t
modifier|*
name|tmp_obj
init|=
name|NULL
decl_stmt|;
name|cert_id
operator|=
operator|(
operator|(
name|sc_pkcs15_cert_info_t
operator|*
operator|)
operator|(
name|certs
index|[
name|i
index|]
operator|->
name|data
operator|)
operator|)
operator|->
name|id
expr_stmt|;
if|if
condition|(
name|sc_pkcs15_find_prkey_by_id
argument_list|(
name|p15card
argument_list|,
operator|&
name|cert_id
argument_list|,
operator|&
name|tmp_obj
argument_list|)
condition|)
comment|/* skip the public key (certificate) if no 			 * corresponding private key is present */
continue|continue;
name|k
operator|=
name|key_new
argument_list|(
name|KEY_RSA
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
break|break;
name|r
operator|=
name|sc_read_pubkey
argument_list|(
name|k
argument_list|,
name|certs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|error
argument_list|(
literal|"sc_read_pubkey failed: %s"
argument_list|,
name|sc_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|key_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|keys
index|[
name|real_count
index|]
operator|=
name|k
expr_stmt|;
name|real_count
operator|++
expr_stmt|;
name|k
operator|=
name|key_new
argument_list|(
name|KEY_RSA1
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
break|break;
name|convert_rsa_to_rsa1
argument_list|(
name|keys
index|[
name|real_count
operator|-
literal|1
index|]
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|keys
index|[
name|real_count
index|]
operator|=
name|k
expr_stmt|;
name|real_count
operator|++
expr_stmt|;
block|}
name|keys
index|[
name|real_count
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|keys
return|;
name|err
label|:
name|sc_close
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|sc_put_key
parameter_list|(
name|Key
modifier|*
name|prv
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|error
argument_list|(
literal|"key uploading not yet supported"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|sc_get_key_label
parameter_list|(
name|Key
modifier|*
name|key
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
specifier|const
name|struct
name|sc_priv_data
modifier|*
name|priv
decl_stmt|;
name|struct
name|sc_pkcs15_object
modifier|*
name|key_obj
decl_stmt|;
name|priv
operator|=
operator|(
specifier|const
expr|struct
name|sc_priv_data
operator|*
operator|)
name|RSA_get_app_data
argument_list|(
name|key
operator|->
name|rsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
operator|||
name|p15card
operator|==
name|NULL
condition|)
block|{
name|logit
argument_list|(
literal|"SmartCard key not loaded"
argument_list|)
expr_stmt|;
comment|/* internal error => return default label */
return|return
name|xstrdup
argument_list|(
literal|"smartcard key"
argument_list|)
return|;
block|}
name|r
operator|=
name|sc_pkcs15_find_prkey_by_id
argument_list|(
name|p15card
argument_list|,
operator|&
name|priv
operator|->
name|cert_id
argument_list|,
operator|&
name|key_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|logit
argument_list|(
literal|"Unable to find private key from SmartCard: %s"
argument_list|,
name|sc_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
literal|"smartcard key"
argument_list|)
return|;
block|}
if|if
condition|(
name|key_obj
operator|==
name|NULL
operator|||
name|key_obj
operator|->
name|label
operator|==
name|NULL
condition|)
comment|/* the optional PKCS#15 label does not exists 		 * => return the default label */
return|return
name|xstrdup
argument_list|(
literal|"smartcard key"
argument_list|)
return|;
return|return
name|xstrdup
argument_list|(
name|key_obj
operator|->
name|label
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMARTCARD */
end_comment

end_unit

