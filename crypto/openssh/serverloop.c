begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: serverloop.c,v 1.191 2017/02/01 02:59:09 dtucker Exp $ */
end_comment

begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  * Server main loop for handling the interactive session.  *  * As far as I am concerned, the code I have written for this software  * can be used freely for any purpose.  Any derived versions of this  * software must be clearly marked as such, and if the derived work is  * incompatible with the protocol description in the RFC file, it must be  * called by a name other than "ssh" or "Secure Shell".  *  * SSH2 support by Markus Friedl.  * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"openbsd-compat/sys-queue.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"servconf.h"
end_include

begin_include
include|#
directive|include
file|"canohost.h"
end_include

begin_include
include|#
directive|include
file|"sshpty.h"
end_include

begin_include
include|#
directive|include
file|"channels.h"
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"cipher.h"
end_include

begin_include
include|#
directive|include
file|"kex.h"
end_include

begin_include
include|#
directive|include
file|"hostfile.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"session.h"
end_include

begin_include
include|#
directive|include
file|"dispatch.h"
end_include

begin_include
include|#
directive|include
file|"auth-options.h"
end_include

begin_include
include|#
directive|include
file|"serverloop.h"
end_include

begin_include
include|#
directive|include
file|"ssherr.h"
end_include

begin_decl_stmt
specifier|extern
name|ServerOptions
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
specifier|extern
name|Authctxt
modifier|*
name|the_authctxt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|use_privsep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|no_more_sessions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Disallow further sessions. */
end_comment

begin_comment
comment|/*  * This SIGCHLD kludge is used to detect when the child exits.  The server  * will exit after that, as soon as forwarded connections have terminated.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|child_terminated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The child has terminated. */
end_comment

begin_comment
comment|/* Cleanup on signals (!use_privsep case only) */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|received_sigterm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|server_init_dispatch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * we write to this pipe if a SIGCHLD is caught in order to avoid  * the race between select() and child_terminated  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|notify_pipe
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|notify_setup
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|pipe
argument_list|(
name|notify_pipe
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"pipe(notify_pipe) failed %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fcntl
argument_list|(
name|notify_pipe
index|[
literal|0
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|fcntl
argument_list|(
name|notify_pipe
index|[
literal|1
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"fcntl(notify_pipe, F_SETFD) failed %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|notify_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|notify_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_nonblock
argument_list|(
name|notify_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
name|notify_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|notify_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* read end */
name|notify_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* write end */
block|}
end_function

begin_function
specifier|static
name|void
name|notify_parent
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|notify_pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|write
argument_list|(
name|notify_pipe
index|[
literal|1
index|]
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_prepare
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|)
block|{
if|if
condition|(
name|notify_pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|FD_SET
argument_list|(
name|notify_pipe
index|[
literal|0
index|]
argument_list|,
name|readset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_done
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|notify_pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|notify_pipe
index|[
literal|0
index|]
argument_list|,
name|readset
argument_list|)
condition|)
while|while
condition|(
name|read
argument_list|(
name|notify_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|debug2
argument_list|(
literal|"notify_done: reading"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|sigchld_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|child_terminated
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|_UNICOS
name|mysignal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|notify_parent
argument_list|()
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|sigterm_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|received_sigterm
operator|=
name|sig
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_alive_check
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|channel_id
decl_stmt|;
comment|/* timeout, check to see how many we have had */
if|if
condition|(
name|packet_inc_alive_timeouts
argument_list|()
operator|>
name|options
operator|.
name|client_alive_count_max
condition|)
block|{
name|logit
argument_list|(
literal|"Timeout, client not responding."
argument_list|)
expr_stmt|;
name|cleanup_exit
argument_list|(
literal|255
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * send a bogus global/channel request with "wantreply", 	 * we should get back a failure 	 */
if|if
condition|(
operator|(
name|channel_id
operator|=
name|channel_find_open
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_GLOBAL_REQUEST
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"keepalive@openssh.com"
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* boolean: want reply */
block|}
else|else
block|{
name|channel_request_start
argument_list|(
name|channel_id
argument_list|,
literal|"keepalive@openssh.com"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sleep in select() until we can do something.  This will initialize the  * select masks.  Upon return, the masks will indicate which descriptors  * have data or can accept data.  Optionally, a maximum time can be specified  * for the duration of the wait (0 = infinite).  */
end_comment

begin_function
specifier|static
name|void
name|wait_until_can_do_something
parameter_list|(
name|int
name|connection_in
parameter_list|,
name|int
name|connection_out
parameter_list|,
name|fd_set
modifier|*
modifier|*
name|readsetp
parameter_list|,
name|fd_set
modifier|*
modifier|*
name|writesetp
parameter_list|,
name|int
modifier|*
name|maxfdp
parameter_list|,
name|u_int
modifier|*
name|nallocp
parameter_list|,
name|u_int64_t
name|max_time_ms
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|time_t
name|minwait_secs
init|=
literal|0
decl_stmt|;
name|int
name|client_alive_scheduled
init|=
literal|0
decl_stmt|;
comment|/* Allocate and update select() masks for channel descriptors. */
name|channel_prepare_select
argument_list|(
name|readsetp
argument_list|,
name|writesetp
argument_list|,
name|maxfdp
argument_list|,
name|nallocp
argument_list|,
operator|&
name|minwait_secs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX need proper deadline system for rekey/client alive */
if|if
condition|(
name|minwait_secs
operator|!=
literal|0
condition|)
name|max_time_ms
operator|=
name|MINIMUM
argument_list|(
name|max_time_ms
argument_list|,
operator|(
name|u_int
operator|)
name|minwait_secs
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* 	 * if using client_alive, set the max timeout accordingly, 	 * and indicate that this particular timeout was for client 	 * alive by setting the client_alive_scheduled flag. 	 * 	 * this could be randomized somewhat to make traffic 	 * analysis more difficult, but we're not doing it yet. 	 */
if|if
condition|(
name|options
operator|.
name|client_alive_interval
condition|)
block|{
name|uint64_t
name|keepalive_ms
init|=
operator|(
name|uint64_t
operator|)
name|options
operator|.
name|client_alive_interval
operator|*
literal|1000
decl_stmt|;
name|client_alive_scheduled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|max_time_ms
operator|==
literal|0
operator|||
name|max_time_ms
operator|>
name|keepalive_ms
condition|)
name|max_time_ms
operator|=
name|keepalive_ms
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* wrong: bad condition XXX */
block|if (channel_not_very_much_buffered_data())
endif|#
directive|endif
name|FD_SET
argument_list|(
name|connection_in
argument_list|,
operator|*
name|readsetp
argument_list|)
expr_stmt|;
name|notify_prepare
argument_list|(
operator|*
name|readsetp
argument_list|)
expr_stmt|;
comment|/* 	 * If we have buffered packet data going to the client, mark that 	 * descriptor. 	 */
if|if
condition|(
name|packet_have_data_to_write
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_out
argument_list|,
operator|*
name|writesetp
argument_list|)
expr_stmt|;
comment|/* 	 * If child has terminated and there is enough buffer space to read 	 * from it, then read as much as is available and exit. 	 */
if|if
condition|(
name|child_terminated
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
if|if
condition|(
name|max_time_ms
operator|==
literal|0
operator|||
name|client_alive_scheduled
condition|)
name|max_time_ms
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|max_time_ms
operator|==
literal|0
condition|)
name|tvp
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|max_time_ms
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|1000
operator|*
operator|(
name|max_time_ms
operator|%
literal|1000
operator|)
expr_stmt|;
name|tvp
operator|=
operator|&
name|tv
expr_stmt|;
block|}
comment|/* Wait for something to happen, or the timeout to expire. */
name|ret
operator|=
name|select
argument_list|(
operator|(
operator|*
name|maxfdp
operator|)
operator|+
literal|1
argument_list|,
operator|*
name|readsetp
argument_list|,
operator|*
name|writesetp
argument_list|,
name|NULL
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|memset
argument_list|(
operator|*
name|readsetp
argument_list|,
literal|0
argument_list|,
operator|*
name|nallocp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|writesetp
argument_list|,
literal|0
argument_list|,
operator|*
name|nallocp
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|error
argument_list|(
literal|"select: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|client_alive_scheduled
condition|)
name|client_alive_check
argument_list|()
expr_stmt|;
name|notify_done
argument_list|(
operator|*
name|readsetp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Processes input from the client and the program.  Input data is stored  * in buffers and processed later.  */
end_comment

begin_function
specifier|static
name|int
name|process_input
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|,
name|int
name|connection_in
parameter_list|)
block|{
name|struct
name|ssh
modifier|*
name|ssh
init|=
name|active_state
decl_stmt|;
comment|/* XXX */
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|16384
index|]
decl_stmt|;
comment|/* Read and buffer any input data from the client. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_in
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|len
operator|=
name|read
argument_list|(
name|connection_in
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
literal|"Connection closed by %.100s port %d"
argument_list|,
name|ssh_remote_ipaddr
argument_list|(
name|ssh
argument_list|)
argument_list|,
name|ssh_remote_port
argument_list|(
name|ssh
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
operator|&&
name|errno
operator|!=
name|EAGAIN
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
block|{
name|verbose
argument_list|(
literal|"Read error from remote host "
literal|"%.100s port %d: %.100s"
argument_list|,
name|ssh_remote_ipaddr
argument_list|(
name|ssh
argument_list|)
argument_list|,
name|ssh_remote_port
argument_list|(
name|ssh
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_exit
argument_list|(
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Buffer any received data. */
name|packet_process_incoming
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Sends data from internal buffers to client program stdin.  */
end_comment

begin_function
specifier|static
name|void
name|process_output
parameter_list|(
name|fd_set
modifier|*
name|writeset
parameter_list|,
name|int
name|connection_out
parameter_list|)
block|{
comment|/* Send any buffered packet data to the client. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_out
argument_list|,
name|writeset
argument_list|)
condition|)
name|packet_write_poll
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_buffered_input_packets
parameter_list|(
name|void
parameter_list|)
block|{
name|dispatch_run
argument_list|(
name|DISPATCH_NONBLOCK
argument_list|,
name|NULL
argument_list|,
name|active_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|collect_children
parameter_list|(
name|void
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|sigset_t
name|oset
decl_stmt|,
name|nset
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* block SIGCHLD while we check for dead children */
name|sigemptyset
argument_list|(
operator|&
name|nset
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|nset
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|nset
argument_list|,
operator|&
name|oset
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_terminated
condition|)
block|{
name|debug
argument_list|(
literal|"Received SIGCHLD."
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
name|waitpid
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
operator|)
operator|>
literal|0
operator|||
operator|(
name|pid
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
operator|)
condition|)
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
name|session_close_by_pid
argument_list|(
name|pid
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|child_terminated
operator|=
literal|0
expr_stmt|;
block|}
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_loop2
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|)
block|{
name|fd_set
modifier|*
name|readset
init|=
name|NULL
decl_stmt|,
modifier|*
name|writeset
init|=
name|NULL
decl_stmt|;
name|int
name|max_fd
decl_stmt|;
name|u_int
name|nalloc
init|=
literal|0
decl_stmt|,
name|connection_in
decl_stmt|,
name|connection_out
decl_stmt|;
name|u_int64_t
name|rekey_timeout_ms
init|=
literal|0
decl_stmt|;
name|debug
argument_list|(
literal|"Entering interactive session for SSH2."
argument_list|)
expr_stmt|;
name|mysignal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld_handler
argument_list|)
expr_stmt|;
name|child_terminated
operator|=
literal|0
expr_stmt|;
name|connection_in
operator|=
name|packet_get_connection_in
argument_list|()
expr_stmt|;
name|connection_out
operator|=
name|packet_get_connection_out
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|use_privsep
condition|)
block|{
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sigterm_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigterm_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|sigterm_handler
argument_list|)
expr_stmt|;
block|}
name|notify_setup
argument_list|()
expr_stmt|;
name|max_fd
operator|=
name|MAXIMUM
argument_list|(
name|connection_in
argument_list|,
name|connection_out
argument_list|)
expr_stmt|;
name|max_fd
operator|=
name|MAXIMUM
argument_list|(
name|max_fd
argument_list|,
name|notify_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|server_init_dispatch
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|process_buffered_input_packets
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ssh_packet_is_rekeying
argument_list|(
name|active_state
argument_list|)
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
name|channel_output_poll
argument_list|()
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|rekey_interval
operator|>
literal|0
operator|&&
operator|!
name|ssh_packet_is_rekeying
argument_list|(
name|active_state
argument_list|)
condition|)
name|rekey_timeout_ms
operator|=
name|packet_get_rekey_timeout
argument_list|()
operator|*
literal|1000
expr_stmt|;
else|else
name|rekey_timeout_ms
operator|=
literal|0
expr_stmt|;
name|wait_until_can_do_something
argument_list|(
name|connection_in
argument_list|,
name|connection_out
argument_list|,
operator|&
name|readset
argument_list|,
operator|&
name|writeset
argument_list|,
operator|&
name|max_fd
argument_list|,
operator|&
name|nalloc
argument_list|,
name|rekey_timeout_ms
argument_list|)
expr_stmt|;
if|if
condition|(
name|received_sigterm
condition|)
block|{
name|logit
argument_list|(
literal|"Exiting on signal %d"
argument_list|,
operator|(
name|int
operator|)
name|received_sigterm
argument_list|)
expr_stmt|;
comment|/* Clean up sessions, utmp, etc. */
name|cleanup_exit
argument_list|(
literal|255
argument_list|)
expr_stmt|;
block|}
name|collect_children
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ssh_packet_is_rekeying
argument_list|(
name|active_state
argument_list|)
condition|)
name|channel_after_select
argument_list|(
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
if|if
condition|(
name|process_input
argument_list|(
name|readset
argument_list|,
name|connection_in
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|process_output
argument_list|(
name|writeset
argument_list|,
name|connection_out
argument_list|)
expr_stmt|;
block|}
name|collect_children
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|readset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|writeset
argument_list|)
expr_stmt|;
comment|/* free all channels, no more reads and writes */
name|channel_free_all
argument_list|()
expr_stmt|;
comment|/* free remaining sessions, e.g. remove wtmp entries */
name|session_destroy_all
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|server_input_keep_alive
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|debug
argument_list|(
literal|"Got %d/%u for keepalive"
argument_list|,
name|type
argument_list|,
name|seq
argument_list|)
expr_stmt|;
comment|/* 	 * reset timeout, since we got a sane answer from the client. 	 * even if this was generated by something other than 	 * the bogus CHANNEL_REQUEST we send for keepalives. 	 */
name|packet_set_alive_timeouts
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|Channel
modifier|*
name|server_request_direct_tcpip
parameter_list|(
name|int
modifier|*
name|reason
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|,
modifier|*
name|originator
decl_stmt|;
name|u_short
name|target_port
decl_stmt|,
name|originator_port
decl_stmt|;
name|target
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|target_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|originator
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|originator_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"server_request_direct_tcpip: originator %s port %d, target %s "
literal|"port %d"
argument_list|,
name|originator
argument_list|,
name|originator_port
argument_list|,
name|target
argument_list|,
name|target_port
argument_list|)
expr_stmt|;
comment|/* XXX fine grained permissions */
if|if
condition|(
operator|(
name|options
operator|.
name|allow_tcp_forwarding
operator|&
name|FORWARD_LOCAL
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|no_port_forwarding_flag
operator|&&
operator|!
name|options
operator|.
name|disable_forwarding
condition|)
block|{
name|c
operator|=
name|channel_connect_to_port
argument_list|(
name|target
argument_list|,
name|target_port
argument_list|,
literal|"direct-tcpip"
argument_list|,
literal|"direct-tcpip"
argument_list|,
name|reason
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logit
argument_list|(
literal|"refused local port forward: "
literal|"originator %s port %d, target %s port %d"
argument_list|,
name|originator
argument_list|,
name|originator_port
argument_list|,
name|target
argument_list|,
name|target_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|!=
name|NULL
condition|)
operator|*
name|reason
operator|=
name|SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED
expr_stmt|;
block|}
name|free
argument_list|(
name|originator
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|Channel
modifier|*
name|server_request_direct_streamlocal
parameter_list|(
name|void
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|,
modifier|*
name|originator
decl_stmt|;
name|u_short
name|originator_port
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
init|=
name|the_authctxt
operator|->
name|pw
decl_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
operator|||
operator|!
name|the_authctxt
operator|->
name|valid
condition|)
name|fatal
argument_list|(
literal|"server_input_global_request: no/invalid user"
argument_list|)
expr_stmt|;
name|target
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|originator
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|originator_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"server_request_direct_streamlocal: originator %s port %d, target %s"
argument_list|,
name|originator
argument_list|,
name|originator_port
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* XXX fine grained permissions */
if|if
condition|(
operator|(
name|options
operator|.
name|allow_streamlocal_forwarding
operator|&
name|FORWARD_LOCAL
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|no_port_forwarding_flag
operator|&&
operator|!
name|options
operator|.
name|disable_forwarding
operator|&&
operator|(
name|pw
operator|->
name|pw_uid
operator|==
literal|0
operator|||
name|use_privsep
operator|)
condition|)
block|{
name|c
operator|=
name|channel_connect_to_path
argument_list|(
name|target
argument_list|,
literal|"direct-streamlocal@openssh.com"
argument_list|,
literal|"direct-streamlocal"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logit
argument_list|(
literal|"refused streamlocal port forward: "
literal|"originator %s port %d, target %s"
argument_list|,
name|originator
argument_list|,
name|originator_port
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|originator
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|Channel
modifier|*
name|server_request_tun
parameter_list|(
name|void
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|tun
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|mode
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SSH_TUNMODE_POINTOPOINT
case|:
case|case
name|SSH_TUNMODE_ETHERNET
case|:
break|break;
default|default:
name|packet_send_debug
argument_list|(
literal|"Unsupported tunnel device mode."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|options
operator|.
name|permit_tun
operator|&
name|mode
operator|)
operator|==
literal|0
condition|)
block|{
name|packet_send_debug
argument_list|(
literal|"Server has rejected tunnel device "
literal|"forwarding"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tun
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|forced_tun_device
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|tun
operator|!=
name|SSH_TUNID_ANY
operator|&&
name|forced_tun_device
operator|!=
name|tun
condition|)
goto|goto
name|done
goto|;
name|tun
operator|=
name|forced_tun_device
expr_stmt|;
block|}
name|sock
operator|=
name|tun_open
argument_list|(
name|tun
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
goto|goto
name|done
goto|;
name|c
operator|=
name|channel_new
argument_list|(
literal|"tun"
argument_list|,
name|SSH_CHANNEL_OPEN
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_TCP_WINDOW_DEFAULT
argument_list|,
name|CHAN_TCP_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|"tun"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|datagram
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SSH_TUN_FILTER
argument_list|)
if|if
condition|(
name|mode
operator|==
name|SSH_TUNMODE_POINTOPOINT
condition|)
name|channel_register_filter
argument_list|(
name|c
operator|->
name|self
argument_list|,
name|sys_tun_infilter
argument_list|,
name|sys_tun_outfilter
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|done
label|:
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_send_debug
argument_list|(
literal|"Failed to open the tunnel device."
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|Channel
modifier|*
name|server_request_session
parameter_list|(
name|void
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
name|debug
argument_list|(
literal|"input_session_request"
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
if|if
condition|(
name|no_more_sessions
condition|)
block|{
name|packet_disconnect
argument_list|(
literal|"Possible attack: attempt to open a session "
literal|"after additional sessions disabled"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * A server session has no fd to read or write until a 	 * CHANNEL_REQUEST for a shell is made, so we set the type to 	 * SSH_CHANNEL_LARVAL.  Additionally, a callback for handling all 	 * CHANNEL_REQUEST messages is registered. 	 */
name|c
operator|=
name|channel_new
argument_list|(
literal|"session"
argument_list|,
name|SSH_CHANNEL_LARVAL
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
comment|/*window size*/
literal|0
argument_list|,
name|CHAN_SES_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|"server-session"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|session_open
argument_list|(
name|the_authctxt
argument_list|,
name|c
operator|->
name|self
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|debug
argument_list|(
literal|"session open failed, free channel %d"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|channel_register_cleanup
argument_list|(
name|c
operator|->
name|self
argument_list|,
name|session_close_by_channel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|server_input_channel_open
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ctype
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|NULL
decl_stmt|;
name|int
name|rchan
decl_stmt|,
name|reason
init|=
name|SSH2_OPEN_CONNECT_FAILED
decl_stmt|;
name|u_int
name|rmaxpack
decl_stmt|,
name|rwindow
decl_stmt|,
name|len
decl_stmt|;
name|ctype
operator|=
name|packet_get_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|rchan
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|rwindow
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|rmaxpack
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"server_input_channel_open: ctype %s rchan %d win %d max %d"
argument_list|,
name|ctype
argument_list|,
name|rchan
argument_list|,
name|rwindow
argument_list|,
name|rmaxpack
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"session"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|server_request_session
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"direct-tcpip"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|server_request_direct_tcpip
argument_list|(
operator|&
name|reason
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"direct-streamlocal@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|server_request_direct_streamlocal
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"tun@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|server_request_tun
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"server_input_channel_open: confirm %s"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
name|rchan
expr_stmt|;
name|c
operator|->
name|remote_window
operator|=
name|rwindow
expr_stmt|;
name|c
operator|->
name|remote_maxpacket
operator|=
name|rmaxpack
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_CONNECTING
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|debug
argument_list|(
literal|"server_input_channel_open: failure %s"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|rchan
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|datafellows
operator|&
name|SSH_BUG_OPENFAILURE
operator|)
condition|)
block|{
name|packet_put_cstring
argument_list|(
name|errmsg
condition|?
name|errmsg
else|:
literal|"open failed"
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|server_input_hostkeys_prove
parameter_list|(
name|struct
name|sshbuf
modifier|*
modifier|*
name|respp
parameter_list|)
block|{
name|struct
name|ssh
modifier|*
name|ssh
init|=
name|active_state
decl_stmt|;
comment|/* XXX */
name|struct
name|sshbuf
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|sigbuf
init|=
name|NULL
decl_stmt|;
name|struct
name|sshkey
modifier|*
name|key
init|=
name|NULL
decl_stmt|,
modifier|*
name|key_pub
init|=
name|NULL
decl_stmt|,
modifier|*
name|key_prv
init|=
name|NULL
decl_stmt|;
name|int
name|r
decl_stmt|,
name|ndx
decl_stmt|,
name|success
init|=
literal|0
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|blob
decl_stmt|;
name|u_char
modifier|*
name|sig
init|=
literal|0
decl_stmt|;
name|size_t
name|blen
decl_stmt|,
name|slen
decl_stmt|;
if|if
condition|(
operator|(
name|resp
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|sigbuf
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: sshbuf_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
while|while
condition|(
name|ssh_packet_remaining
argument_list|(
name|ssh
argument_list|)
operator|>
literal|0
condition|)
block|{
name|sshkey_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshpkt_get_string_direct
argument_list|(
name|ssh
argument_list|,
operator|&
name|blob
argument_list|,
operator|&
name|blen
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshkey_from_blob
argument_list|(
name|blob
argument_list|,
name|blen
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: couldn't parse key: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Better check that this is actually one of our hostkeys 		 * before attempting to sign anything with it. 		 */
if|if
condition|(
operator|(
name|ndx
operator|=
name|ssh
operator|->
name|kex
operator|->
name|host_key_index
argument_list|(
name|key
argument_list|,
literal|1
argument_list|,
name|ssh
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: unknown host %s key"
argument_list|,
name|__func__
argument_list|,
name|sshkey_type
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * XXX refactor: make kex->sign just use an index rather 		 * than passing in public and private keys 		 */
if|if
condition|(
operator|(
name|key_prv
operator|=
name|get_hostkey_by_index
argument_list|(
name|ndx
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|key_pub
operator|=
name|get_hostkey_public_by_index
argument_list|(
name|ndx
argument_list|,
name|ssh
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: can't retrieve hostkey %d"
argument_list|,
name|__func__
argument_list|,
name|ndx
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sshbuf_reset
argument_list|(
name|sigbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|sig
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_cstring
argument_list|(
name|sigbuf
argument_list|,
literal|"hostkeys-prove-00@openssh.com"
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|sigbuf
argument_list|,
name|ssh
operator|->
name|kex
operator|->
name|session_id
argument_list|,
name|ssh
operator|->
name|kex
operator|->
name|session_id_len
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshkey_puts
argument_list|(
name|key
argument_list|,
name|sigbuf
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|ssh
operator|->
name|kex
operator|->
name|sign
argument_list|(
name|key_prv
argument_list|,
name|key_pub
argument_list|,
operator|&
name|sig
argument_list|,
operator|&
name|slen
argument_list|,
name|sshbuf_ptr
argument_list|(
name|sigbuf
argument_list|)
argument_list|,
name|sshbuf_len
argument_list|(
name|sigbuf
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|resp
argument_list|,
name|sig
argument_list|,
name|slen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: couldn't prepare signature: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* Success */
operator|*
name|respp
operator|=
name|resp
expr_stmt|;
name|resp
operator|=
name|NULL
expr_stmt|;
comment|/* don't free it */
name|success
operator|=
literal|1
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|sigbuf
argument_list|)
expr_stmt|;
name|sshkey_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|server_input_global_request
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|char
modifier|*
name|rtype
decl_stmt|;
name|int
name|want_reply
decl_stmt|;
name|int
name|r
decl_stmt|,
name|success
init|=
literal|0
decl_stmt|,
name|allocated_listen_port
init|=
literal|0
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
init|=
name|the_authctxt
operator|->
name|pw
decl_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
operator|||
operator|!
name|the_authctxt
operator|->
name|valid
condition|)
name|fatal
argument_list|(
literal|"server_input_global_request: no/invalid user"
argument_list|)
expr_stmt|;
name|rtype
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|want_reply
operator|=
name|packet_get_char
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"server_input_global_request: rtype %s want_reply %d"
argument_list|,
name|rtype
argument_list|,
name|want_reply
argument_list|)
expr_stmt|;
comment|/* -R style forwarding */
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"tcpip-forward"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|Forward
name|fwd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fwd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fwd
argument_list|)
argument_list|)
expr_stmt|;
name|fwd
operator|.
name|listen_host
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|fwd
operator|.
name|listen_port
operator|=
operator|(
name|u_short
operator|)
name|packet_get_int
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"server_input_global_request: tcpip-forward listen %s port %d"
argument_list|,
name|fwd
operator|.
name|listen_host
argument_list|,
name|fwd
operator|.
name|listen_port
argument_list|)
expr_stmt|;
comment|/* check permissions */
if|if
condition|(
operator|(
name|options
operator|.
name|allow_tcp_forwarding
operator|&
name|FORWARD_REMOTE
operator|)
operator|==
literal|0
operator|||
name|no_port_forwarding_flag
operator|||
name|options
operator|.
name|disable_forwarding
operator|||
operator|(
operator|!
name|want_reply
operator|&&
name|fwd
operator|.
name|listen_port
operator|==
literal|0
operator|)
operator|||
operator|(
name|fwd
operator|.
name|listen_port
operator|!=
literal|0
operator|&&
operator|!
name|bind_permitted
argument_list|(
name|fwd
operator|.
name|listen_port
argument_list|,
name|pw
operator|->
name|pw_uid
argument_list|)
operator|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
name|packet_send_debug
argument_list|(
literal|"Server has disabled port forwarding."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Start listening on the port */
name|success
operator|=
name|channel_setup_remote_fwd_listener
argument_list|(
operator|&
name|fwd
argument_list|,
operator|&
name|allocated_listen_port
argument_list|,
operator|&
name|options
operator|.
name|fwd_opts
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fwd
operator|.
name|listen_host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|resp
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: sshbuf_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated_listen_port
operator|!=
literal|0
operator|&&
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|resp
argument_list|,
name|allocated_listen_port
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: sshbuf_put_u32: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"cancel-tcpip-forward"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|Forward
name|fwd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fwd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fwd
argument_list|)
argument_list|)
expr_stmt|;
name|fwd
operator|.
name|listen_host
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|fwd
operator|.
name|listen_port
operator|=
operator|(
name|u_short
operator|)
name|packet_get_int
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"%s: cancel-tcpip-forward addr %s port %d"
argument_list|,
name|__func__
argument_list|,
name|fwd
operator|.
name|listen_host
argument_list|,
name|fwd
operator|.
name|listen_port
argument_list|)
expr_stmt|;
name|success
operator|=
name|channel_cancel_rport_listener
argument_list|(
operator|&
name|fwd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fwd
operator|.
name|listen_host
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"streamlocal-forward@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|Forward
name|fwd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fwd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fwd
argument_list|)
argument_list|)
expr_stmt|;
name|fwd
operator|.
name|listen_path
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"server_input_global_request: streamlocal-forward listen path %s"
argument_list|,
name|fwd
operator|.
name|listen_path
argument_list|)
expr_stmt|;
comment|/* check permissions */
if|if
condition|(
operator|(
name|options
operator|.
name|allow_streamlocal_forwarding
operator|&
name|FORWARD_REMOTE
operator|)
operator|==
literal|0
operator|||
name|no_port_forwarding_flag
operator|||
name|options
operator|.
name|disable_forwarding
operator|||
operator|(
name|pw
operator|->
name|pw_uid
operator|!=
literal|0
operator|&&
operator|!
name|use_privsep
operator|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
name|packet_send_debug
argument_list|(
literal|"Server has disabled "
literal|"streamlocal forwarding."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Start listening on the socket */
name|success
operator|=
name|channel_setup_remote_fwd_listener
argument_list|(
operator|&
name|fwd
argument_list|,
name|NULL
argument_list|,
operator|&
name|options
operator|.
name|fwd_opts
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fwd
operator|.
name|listen_path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"cancel-streamlocal-forward@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|Forward
name|fwd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fwd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fwd
argument_list|)
argument_list|)
expr_stmt|;
name|fwd
operator|.
name|listen_path
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"%s: cancel-streamlocal-forward path %s"
argument_list|,
name|__func__
argument_list|,
name|fwd
operator|.
name|listen_path
argument_list|)
expr_stmt|;
name|success
operator|=
name|channel_cancel_rport_listener
argument_list|(
operator|&
name|fwd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fwd
operator|.
name|listen_path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"no-more-sessions@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|no_more_sessions
operator|=
literal|1
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"hostkeys-prove-00@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|success
operator|=
name|server_input_hostkeys_prove
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|want_reply
condition|)
block|{
name|packet_start
argument_list|(
name|success
condition|?
name|SSH2_MSG_REQUEST_SUCCESS
else|:
name|SSH2_MSG_REQUEST_FAILURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|&&
name|resp
operator|!=
name|NULL
condition|)
name|ssh_packet_put_raw
argument_list|(
name|active_state
argument_list|,
name|sshbuf_ptr
argument_list|(
name|resp
argument_list|)
argument_list|,
name|sshbuf_len
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|server_input_channel_req
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
name|int
name|id
decl_stmt|,
name|reply
decl_stmt|,
name|success
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|rtype
decl_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|rtype
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|reply
operator|=
name|packet_get_char
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"server_input_channel_req: channel %d request %s reply %d"
argument_list|,
name|id
argument_list|,
name|rtype
argument_list|,
name|reply
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"server_input_channel_req: "
literal|"unknown channel %d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"eow@openssh.com"
argument_list|)
condition|)
block|{
name|packet_check_eom
argument_list|()
expr_stmt|;
name|chan_rcvd_eow
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_LARVAL
operator|||
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_OPEN
operator|)
operator|&&
name|strcmp
argument_list|(
name|c
operator|->
name|ctype
argument_list|,
literal|"session"
argument_list|)
operator|==
literal|0
condition|)
name|success
operator|=
name|session_input_channel_req
argument_list|(
name|c
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHAN_CLOSE_SENT
operator|)
condition|)
block|{
name|packet_start
argument_list|(
name|success
condition|?
name|SSH2_MSG_CHANNEL_SUCCESS
else|:
name|SSH2_MSG_CHANNEL_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_init_dispatch
parameter_list|(
name|void
parameter_list|)
block|{
name|debug
argument_list|(
literal|"server_init_dispatch"
argument_list|)
expr_stmt|;
name|dispatch_init
argument_list|(
operator|&
name|dispatch_protocol_error
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_oclose
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_DATA
argument_list|,
operator|&
name|channel_input_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_EOF
argument_list|,
operator|&
name|channel_input_ieof
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_EXTENDED_DATA
argument_list|,
operator|&
name|channel_input_extended_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|,
operator|&
name|server_input_channel_open
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|,
operator|&
name|channel_input_open_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_FAILURE
argument_list|,
operator|&
name|channel_input_open_failure
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_REQUEST
argument_list|,
operator|&
name|server_input_channel_req
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_WINDOW_ADJUST
argument_list|,
operator|&
name|channel_input_window_adjust
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_GLOBAL_REQUEST
argument_list|,
operator|&
name|server_input_global_request
argument_list|)
expr_stmt|;
comment|/* client_alive */
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_SUCCESS
argument_list|,
operator|&
name|server_input_keep_alive
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_FAILURE
argument_list|,
operator|&
name|server_input_keep_alive
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_REQUEST_SUCCESS
argument_list|,
operator|&
name|server_input_keep_alive
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_REQUEST_FAILURE
argument_list|,
operator|&
name|server_input_keep_alive
argument_list|)
expr_stmt|;
comment|/* rekeying */
name|dispatch_set
argument_list|(
name|SSH2_MSG_KEXINIT
argument_list|,
operator|&
name|kex_input_kexinit
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

