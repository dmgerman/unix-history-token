begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  * Created: Sun Sep 10 00:30:37 1995 ylo  * Server main loop for handling the interactive session.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"servconf.h"
end_include

begin_include
include|#
directive|include
file|"pty.h"
end_include

begin_decl_stmt
specifier|static
name|Buffer
name|stdin_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stdin data. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stdout_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stdout data. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stderr_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stderr data. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fdin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for stdin (for writing) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for stdout (for reading); 				   May be same number as fdin. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fderr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for stderr.  May be -1. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|stdin_bytes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes written to stdin. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|stdout_bytes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of stdout bytes sent to client. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|stderr_bytes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of stderr bytes sent to client. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|fdout_bytes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of stdout bytes read from program. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdin_eof
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF message received from client. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fdout_eof
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF encountered reading from fdout. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fderr_eof
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF encountered readung from fderr. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|connection_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to client (input). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|connection_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to client (output). */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|buffer_high
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "Soft" max buffer size. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max file descriptor number for select(). */
end_comment

begin_comment
comment|/*  * This SIGCHLD kludge is used to detect when the child exits.  The server  * will exit after that, as soon as forwarded connections have terminated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|child_pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pid of the child. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|child_terminated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The child has terminated. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|child_wait_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Status from wait(). */
end_comment

begin_function
name|void
name|sigchld_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|int
name|wait_pid
decl_stmt|;
name|debug
argument_list|(
literal|"Received SIGCHLD."
argument_list|)
expr_stmt|;
name|wait_pid
operator|=
name|wait
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|&
name|child_wait_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_pid
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|wait_pid
operator|!=
name|child_pid
condition|)
name|error
argument_list|(
literal|"Strange, got SIGCHLD and wait returned pid %d but child is %d"
argument_list|,
name|wait_pid
argument_list|,
name|child_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|child_wait_status
argument_list|)
operator|||
name|WIFSIGNALED
argument_list|(
name|child_wait_status
argument_list|)
condition|)
name|child_terminated
operator|=
literal|1
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld_handler
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process any buffered packets that have been received from the client.  */
end_comment

begin_function
name|void
name|process_buffered_input_packets
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|data_len
decl_stmt|;
name|int
name|row
decl_stmt|,
name|col
decl_stmt|,
name|xpixel
decl_stmt|,
name|ypixel
decl_stmt|;
name|int
name|payload_len
decl_stmt|;
comment|/* Process buffered packets from the client. */
while|while
condition|(
operator|(
name|type
operator|=
name|packet_read_poll
argument_list|(
operator|&
name|payload_len
argument_list|)
operator|)
operator|!=
name|SSH_MSG_NONE
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SSH_CMSG_STDIN_DATA
case|:
comment|/* Stdin data from the client.  Append it to the buffer. */
comment|/* Ignore any data if the client has closed stdin. */
if|if
condition|(
name|fdin
operator|==
operator|-
literal|1
condition|)
break|break;
name|data
operator|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
expr_stmt|;
name|packet_integrity_check
argument_list|(
name|payload_len
argument_list|,
operator|(
literal|4
operator|+
name|data_len
operator|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_CMSG_EOF
case|:
comment|/* 			 * Eof from the client.  The stdin descriptor to the 			 * program will be closed when all buffered data has 			 * drained. 			 */
name|debug
argument_list|(
literal|"EOF received for stdin."
argument_list|)
expr_stmt|;
name|packet_integrity_check
argument_list|(
name|payload_len
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|stdin_eof
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SSH_CMSG_WINDOW_SIZE
case|:
name|debug
argument_list|(
literal|"Window change received."
argument_list|)
expr_stmt|;
name|packet_integrity_check
argument_list|(
name|payload_len
argument_list|,
literal|4
operator|*
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|row
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|col
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|xpixel
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|ypixel
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|fdin
operator|!=
operator|-
literal|1
condition|)
name|pty_change_window_size
argument_list|(
name|fdin
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|xpixel
argument_list|,
name|ypixel
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_MSG_PORT_OPEN
case|:
name|debug
argument_list|(
literal|"Received port open request."
argument_list|)
expr_stmt|;
name|channel_input_port_open
argument_list|(
name|payload_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
case|:
name|debug
argument_list|(
literal|"Received channel open confirmation."
argument_list|)
expr_stmt|;
name|packet_integrity_check
argument_list|(
name|payload_len
argument_list|,
literal|4
operator|+
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|channel_input_open_confirmation
argument_list|()
expr_stmt|;
break|break;
case|case
name|SSH_MSG_CHANNEL_OPEN_FAILURE
case|:
name|debug
argument_list|(
literal|"Received channel open failure."
argument_list|)
expr_stmt|;
name|packet_integrity_check
argument_list|(
name|payload_len
argument_list|,
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|channel_input_open_failure
argument_list|()
expr_stmt|;
break|break;
case|case
name|SSH_MSG_CHANNEL_DATA
case|:
name|channel_input_data
argument_list|(
name|payload_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_MSG_CHANNEL_CLOSE
case|:
name|debug
argument_list|(
literal|"Received channel close."
argument_list|)
expr_stmt|;
name|packet_integrity_check
argument_list|(
name|payload_len
argument_list|,
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|channel_input_close
argument_list|()
expr_stmt|;
break|break;
case|case
name|SSH_MSG_CHANNEL_CLOSE_CONFIRMATION
case|:
name|debug
argument_list|(
literal|"Received channel close confirmation."
argument_list|)
expr_stmt|;
name|packet_integrity_check
argument_list|(
name|payload_len
argument_list|,
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|channel_input_close_confirmation
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|/* 			 * In this phase, any unexpected messages cause a 			 * protocol error.  This is to ease debugging; also, 			 * since no confirmations are sent messages, 			 * unprocessed unknown messages could cause strange 			 * problems.  Any compatible protocol extensions must 			 * be negotiated before entering the interactive 			 * session. 			 */
name|packet_disconnect
argument_list|(
literal|"Protocol error during session: type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Make packets from buffered stderr data, and buffer it for sending  * to the client.  */
end_comment

begin_function
name|void
name|make_packets_from_stderr_data
parameter_list|()
block|{
name|int
name|len
decl_stmt|;
comment|/* Send buffered stderr data to the client. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|>
literal|0
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
block|{
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_is_interactive
argument_list|()
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|512
condition|)
name|len
operator|=
literal|512
expr_stmt|;
block|}
else|else
block|{
comment|/* Keep the packets at reasonable size. */
if|if
condition|(
name|len
operator|>
name|packet_get_maxsize
argument_list|()
condition|)
name|len
operator|=
name|packet_get_maxsize
argument_list|()
expr_stmt|;
block|}
name|packet_start
argument_list|(
name|SSH_SMSG_STDERR_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Make packets from buffered stdout data, and buffer it for sending to the  * client.  */
end_comment

begin_function
name|void
name|make_packets_from_stdout_data
parameter_list|()
block|{
name|int
name|len
decl_stmt|;
comment|/* Send buffered stdout data to the client. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|>
literal|0
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
block|{
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_is_interactive
argument_list|()
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|512
condition|)
name|len
operator|=
literal|512
expr_stmt|;
block|}
else|else
block|{
comment|/* Keep the packets at reasonable size. */
if|if
condition|(
name|len
operator|>
name|packet_get_maxsize
argument_list|()
condition|)
name|len
operator|=
name|packet_get_maxsize
argument_list|()
expr_stmt|;
block|}
name|packet_start
argument_list|(
name|SSH_SMSG_STDOUT_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stdout_bytes
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Sleep in select() until we can do something.  This will initialize the  * select masks.  Upon return, the masks will indicate which descriptors  * have data or can accept data.  Optionally, a maximum time can be specified  * for the duration of the wait (0 = infinite).  */
end_comment

begin_function
name|void
name|wait_until_can_do_something
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|,
name|unsigned
name|int
name|max_time_milliseconds
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* When select fails we restart from here. */
name|retry_select
label|:
comment|/* Initialize select() masks. */
name|FD_ZERO
argument_list|(
name|readset
argument_list|)
expr_stmt|;
comment|/* 	 * Read packets from the client unless we have too much buffered 	 * stdin or channel data. 	 */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|<
literal|4096
operator|&&
name|channel_not_very_much_buffered_data
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_in
argument_list|,
name|readset
argument_list|)
expr_stmt|;
comment|/* 	 * If there is not too much data already buffered going to the 	 * client, try to get some more data from the program. 	 */
if|if
condition|(
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fdout_eof
condition|)
name|FD_SET
argument_list|(
name|fdout
argument_list|,
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fderr_eof
condition|)
name|FD_SET
argument_list|(
name|fderr
argument_list|,
name|readset
argument_list|)
expr_stmt|;
block|}
name|FD_ZERO
argument_list|(
name|writeset
argument_list|)
expr_stmt|;
comment|/* Set masks for channel descriptors. */
name|channel_prepare_select
argument_list|(
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
comment|/* 	 * If we have buffered packet data going to the client, mark that 	 * descriptor. 	 */
if|if
condition|(
name|packet_have_data_to_write
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_out
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
comment|/* If we have buffered data, try to write some of that data to the 	   program. */
if|if
condition|(
name|fdin
operator|!=
operator|-
literal|1
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|fdin
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
comment|/* Update the maximum descriptor number if appropriate. */
if|if
condition|(
name|channel_max_fd
argument_list|()
operator|>
name|max_fd
condition|)
name|max_fd
operator|=
name|channel_max_fd
argument_list|()
expr_stmt|;
comment|/* 	 * If child has terminated and there is enough buffer space to read 	 * from it, then read as much as is available and exit. 	 */
if|if
condition|(
name|child_terminated
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
if|if
condition|(
name|max_time_milliseconds
operator|==
literal|0
condition|)
name|max_time_milliseconds
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|max_time_milliseconds
operator|==
literal|0
condition|)
name|tvp
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|max_time_milliseconds
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|1000
operator|*
operator|(
name|max_time_milliseconds
operator|%
literal|1000
operator|)
expr_stmt|;
name|tvp
operator|=
operator|&
name|tv
expr_stmt|;
block|}
comment|/* Wait for something to happen, or the timeout to expire. */
name|ret
operator|=
name|select
argument_list|(
name|max_fd
operator|+
literal|1
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|,
name|NULL
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|error
argument_list|(
literal|"select: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
goto|goto
name|retry_select
goto|;
block|}
block|}
end_function

begin_comment
comment|/*  * Processes input from the client and the program.  Input data is stored  * in buffers and processed later.  */
end_comment

begin_function
name|void
name|process_input
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|16384
index|]
decl_stmt|;
comment|/* Read and buffer any input data from the client. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_in
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|len
operator|=
name|read
argument_list|(
name|connection_in
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
literal|"Connection closed by remote host."
argument_list|)
expr_stmt|;
name|fatal_cleanup
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * There is a kernel bug on Solaris that causes select to 		 * sometimes wake up even though there is no data available. 		 */
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|verbose
argument_list|(
literal|"Read error from remote host: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fatal_cleanup
argument_list|()
expr_stmt|;
block|}
comment|/* Buffer any received data. */
name|packet_process_incoming
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Read and buffer any available stdout data from the program. */
if|if
condition|(
operator|!
name|fdout_eof
operator|&&
name|FD_ISSET
argument_list|(
name|fdout
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|len
operator|=
name|read
argument_list|(
name|fdout
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|fdout_eof
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|buffer_append
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fdout_bytes
operator|+=
name|len
expr_stmt|;
block|}
block|}
comment|/* Read and buffer any available stderr data from the program. */
if|if
condition|(
operator|!
name|fderr_eof
operator|&&
name|FD_ISSET
argument_list|(
name|fderr
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|len
operator|=
name|read
argument_list|(
name|fderr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|fderr_eof
operator|=
literal|1
expr_stmt|;
else|else
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Sends data from internal buffers to client program stdin.  */
end_comment

begin_function
name|void
name|process_output
parameter_list|(
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* Write buffered data to program stdin. */
if|if
condition|(
name|fdin
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|fdin
argument_list|,
name|writeset
argument_list|)
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|fdin
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_PIPES
name|close
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|fdout
operator|==
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
else|else
name|shutdown
argument_list|(
name|fdin
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
comment|/* We will no longer send. */
endif|#
directive|endif
name|fdin
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Successful write.  Consume the data from the buffer. */
name|buffer_consume
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Update the count of bytes written to the program. */
name|stdin_bytes
operator|+=
name|len
expr_stmt|;
block|}
block|}
comment|/* Send any buffered packet data to the client. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_out
argument_list|,
name|writeset
argument_list|)
condition|)
name|packet_write_poll
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait until all buffered output has been sent to the client.  * This is used when the program terminates.  */
end_comment

begin_function
name|void
name|drain_output
parameter_list|()
block|{
comment|/* Send any buffered stdout data to the client. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_SMSG_STDOUT_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* Update the count of sent bytes. */
name|stdout_bytes
operator|+=
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
block|}
comment|/* Send any buffered stderr data to the client. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_SMSG_STDERR_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* Update the count of sent bytes. */
name|stderr_bytes
operator|+=
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
block|}
comment|/* Wait until all buffered data has been written to the client. */
name|packet_write_wait
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Performs the interactive session.  This handles data transmission between  * the client and the program.  Note that the notion of stdin, stdout, and  * stderr in this function is sort of reversed: this function writes to  * stdin (of the child program), and reads from stdout and stderr (of the  * child program).  */
end_comment

begin_function
name|void
name|server_loop
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|fdin_arg
parameter_list|,
name|int
name|fdout_arg
parameter_list|,
name|int
name|fderr_arg
parameter_list|)
block|{
name|int
name|wait_status
decl_stmt|,
name|wait_pid
decl_stmt|;
comment|/* Status and pid returned by wait(). */
name|int
name|waiting_termination
init|=
literal|0
decl_stmt|;
comment|/* Have displayed waiting close message. */
name|unsigned
name|int
name|max_time_milliseconds
decl_stmt|;
name|unsigned
name|int
name|previous_stdout_buffer_bytes
decl_stmt|;
name|unsigned
name|int
name|stdout_buffer_bytes
decl_stmt|;
name|int
name|type
decl_stmt|;
name|debug
argument_list|(
literal|"Entering interactive session."
argument_list|)
expr_stmt|;
comment|/* Initialize the SIGCHLD kludge. */
name|child_pid
operator|=
name|pid
expr_stmt|;
name|child_terminated
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld_handler
argument_list|)
expr_stmt|;
comment|/* Initialize our global variables. */
name|fdin
operator|=
name|fdin_arg
expr_stmt|;
name|fdout
operator|=
name|fdout_arg
expr_stmt|;
name|fderr
operator|=
name|fderr_arg
expr_stmt|;
name|connection_in
operator|=
name|packet_get_connection_in
argument_list|()
expr_stmt|;
name|connection_out
operator|=
name|packet_get_connection_out
argument_list|()
expr_stmt|;
name|previous_stdout_buffer_bytes
operator|=
literal|0
expr_stmt|;
comment|/* Set approximate I/O buffer size. */
if|if
condition|(
name|packet_is_interactive
argument_list|()
condition|)
name|buffer_high
operator|=
literal|4096
expr_stmt|;
else|else
name|buffer_high
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
comment|/* Initialize max_fd to the maximum of the known file descriptors. */
name|max_fd
operator|=
name|fdin
expr_stmt|;
if|if
condition|(
name|fdout
operator|>
name|max_fd
condition|)
name|max_fd
operator|=
name|fdout
expr_stmt|;
if|if
condition|(
name|fderr
operator|!=
operator|-
literal|1
operator|&&
name|fderr
operator|>
name|max_fd
condition|)
name|max_fd
operator|=
name|fderr
expr_stmt|;
if|if
condition|(
name|connection_in
operator|>
name|max_fd
condition|)
name|max_fd
operator|=
name|connection_in
expr_stmt|;
if|if
condition|(
name|connection_out
operator|>
name|max_fd
condition|)
name|max_fd
operator|=
name|connection_out
expr_stmt|;
comment|/* Initialize Initialize buffers. */
name|buffer_init
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
comment|/* 	 * If we have no separate fderr (which is the case when we have a pty 	 * - there we cannot make difference between data sent to stdout and 	 * stderr), indicate that we have seen an EOF from stderr.  This way 	 * we don\'t need to check the descriptor everywhere. 	 */
if|if
condition|(
name|fderr
operator|==
operator|-
literal|1
condition|)
name|fderr_eof
operator|=
literal|1
expr_stmt|;
comment|/* Main loop of the server for the interactive session mode. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|fd_set
name|readset
decl_stmt|,
name|writeset
decl_stmt|;
comment|/* Process buffered packets from the client. */
name|process_buffered_input_packets
argument_list|()
expr_stmt|;
comment|/* 		 * If we have received eof, and there is no more pending 		 * input data, cause a real eof by closing fdin. 		 */
if|if
condition|(
name|stdin_eof
operator|&&
name|fdin
operator|!=
operator|-
literal|1
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_PIPES
name|close
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|fdout
operator|==
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
else|else
name|shutdown
argument_list|(
name|fdin
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
comment|/* We will no longer send. */
endif|#
directive|endif
name|fdin
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Make packets from buffered stderr data to send to the client. */
name|make_packets_from_stderr_data
argument_list|()
expr_stmt|;
comment|/* 		 * Make packets from buffered stdout data to send to the 		 * client. If there is very little to send, this arranges to 		 * not send them now, but to wait a short while to see if we 		 * are getting more data. This is necessary, as some systems 		 * wake up readers from a pty after each separate character. 		 */
name|max_time_milliseconds
operator|=
literal|0
expr_stmt|;
name|stdout_buffer_bytes
operator|=
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdout_buffer_bytes
operator|!=
literal|0
operator|&&
name|stdout_buffer_bytes
operator|<
literal|256
operator|&&
name|stdout_buffer_bytes
operator|!=
name|previous_stdout_buffer_bytes
condition|)
block|{
comment|/* try again after a while */
name|max_time_milliseconds
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
comment|/* Send it now. */
name|make_packets_from_stdout_data
argument_list|()
expr_stmt|;
block|}
name|previous_stdout_buffer_bytes
operator|=
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
comment|/* Send channel data to the client. */
if|if
condition|(
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
name|channel_output_poll
argument_list|()
expr_stmt|;
comment|/* 		 * Bail out of the loop if the program has closed its output 		 * descriptors, and we have no more data to send to the 		 * client, and there is no pending buffered data. 		 */
if|if
condition|(
name|fdout_eof
operator|&&
name|fderr_eof
operator|&&
operator|!
name|packet_have_data_to_write
argument_list|()
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|==
literal|0
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|channel_still_open
argument_list|()
condition|)
goto|goto
name|quit
goto|;
if|if
condition|(
operator|!
name|waiting_termination
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
literal|"Waiting for forwarded connections to terminate...\r\n"
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|waiting_termination
operator|=
literal|1
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Display list of open channels. */
name|cp
operator|=
name|channel_open_message
argument_list|()
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Sleep in select() until we can do something. */
name|wait_until_can_do_something
argument_list|(
operator|&
name|readset
argument_list|,
operator|&
name|writeset
argument_list|,
name|max_time_milliseconds
argument_list|)
expr_stmt|;
comment|/* Process any channel events. */
name|channel_after_select
argument_list|(
operator|&
name|readset
argument_list|,
operator|&
name|writeset
argument_list|)
expr_stmt|;
comment|/* Process input from the client and from program stdout/stderr. */
name|process_input
argument_list|(
operator|&
name|readset
argument_list|)
expr_stmt|;
comment|/* Process output to the client and to program stdin. */
name|process_output
argument_list|(
operator|&
name|writeset
argument_list|)
expr_stmt|;
block|}
name|quit
label|:
comment|/* Cleanup and termination code. */
comment|/* Wait until all output has been sent to the client. */
name|drain_output
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes."
argument_list|,
name|stdin_bytes
argument_list|,
name|fdout_bytes
argument_list|,
name|stdout_bytes
argument_list|,
name|stderr_bytes
argument_list|)
expr_stmt|;
comment|/* Free and clear the buffers. */
name|buffer_free
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
comment|/* Close the file descriptors. */
if|if
condition|(
name|fdout
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fdout
argument_list|)
expr_stmt|;
name|fdout
operator|=
operator|-
literal|1
expr_stmt|;
name|fdout_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fderr
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fderr
argument_list|)
expr_stmt|;
name|fderr
operator|=
operator|-
literal|1
expr_stmt|;
name|fderr_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fdin
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
name|fdin
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Stop listening for channels; this removes unix domain sockets. */
name|channel_stop_listening
argument_list|()
expr_stmt|;
comment|/* Wait for the child to exit.  Get its exit status. */
name|wait_pid
operator|=
name|wait
argument_list|(
operator|&
name|wait_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_pid
operator|<
literal|0
condition|)
block|{
comment|/* 		 * It is possible that the wait was handled by SIGCHLD 		 * handler.  This may result in either: this call 		 * returning with EINTR, or: this call returning ECHILD. 		 */
if|if
condition|(
name|child_terminated
condition|)
name|wait_status
operator|=
name|child_wait_status
expr_stmt|;
else|else
name|packet_disconnect
argument_list|(
literal|"wait: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check if it matches the process we forked. */
if|if
condition|(
name|wait_pid
operator|!=
name|pid
condition|)
name|error
argument_list|(
literal|"Strange, wait returned pid %d, expected %d"
argument_list|,
name|wait_pid
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
comment|/* We no longer want our SIGCHLD handler to be called. */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* Check if it exited normally. */
if|if
condition|(
name|WIFEXITED
argument_list|(
name|wait_status
argument_list|)
condition|)
block|{
comment|/* Yes, normal exit.  Get exit status and send it to the client. */
name|debug
argument_list|(
literal|"Command exited with status %d."
argument_list|,
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_SMSG_EXITSTATUS
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* 		 * Wait for exit confirmation.  Note that there might be 		 * other packets coming before it; however, the program has 		 * already died so we just ignore them.  The client is 		 * supposed to respond with the confirmation when it receives 		 * the exit status. 		 */
do|do
block|{
name|int
name|plen
decl_stmt|;
name|type
operator|=
name|packet_read
argument_list|(
operator|&
name|plen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|type
operator|!=
name|SSH_CMSG_EXIT_CONFIRMATION
condition|)
do|;
name|debug
argument_list|(
literal|"Received exit confirmation."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check if the program terminated due to a signal. */
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|wait_status
argument_list|)
condition|)
name|packet_disconnect
argument_list|(
literal|"Command terminated on signal %d."
argument_list|,
name|WTERMSIG
argument_list|(
name|wait_status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some weird exit cause.  Just exit. */
name|packet_disconnect
argument_list|(
literal|"wait returned status %04x."
argument_list|,
name|wait_status
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

end_unit

