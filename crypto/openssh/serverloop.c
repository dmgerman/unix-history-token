begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  * Server main loop for handling the interactive session.  *  * As far as I am concerned, the code I have written for this software  * can be used freely for any purpose.  Any derived versions of this  * software must be clearly marked as such, and if the derived work is  * incompatible with the protocol description in the RFC file, it must be  * called by a name other than "ssh" or "Secure Shell".  *  * SSH2 support by Markus Friedl.  * Copyright (c) 2000 Markus Friedl. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$OpenBSD: serverloop.c,v 1.34 2000/10/27 07:32:18 markus Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"servconf.h"
end_include

begin_include
include|#
directive|include
file|"pty.h"
end_include

begin_include
include|#
directive|include
file|"channels.h"
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|"session.h"
end_include

begin_include
include|#
directive|include
file|"dispatch.h"
end_include

begin_include
include|#
directive|include
file|"auth-options.h"
end_include

begin_decl_stmt
specifier|extern
name|ServerOptions
name|options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Buffer
name|stdin_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stdin data. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stdout_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stdout data. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stderr_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stderr data. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fdin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for stdin (for writing) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for stdout (for reading); 				   May be same number as fdin. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fderr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for stderr.  May be -1. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|stdin_bytes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes written to stdin. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|stdout_bytes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of stdout bytes sent to client. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|stderr_bytes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of stderr bytes sent to client. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|fdout_bytes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of stdout bytes read from program. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdin_eof
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF message received from client. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fdout_eof
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF encountered reading from fdout. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fderr_eof
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF encountered readung from fderr. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fdin_is_tty
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fdin points to a tty. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|connection_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to client (input). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|connection_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to client (output). */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|buffer_high
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "Soft" max buffer size. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max file descriptor number for select(). */
end_comment

begin_comment
comment|/*  * This SIGCHLD kludge is used to detect when the child exits.  The server  * will exit after that, as soon as forwarded connections have terminated.  */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|child_pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pid of the child. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|child_terminated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The child has terminated. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|child_wait_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Status from wait(). */
end_comment

begin_function_decl
name|void
name|server_init_dispatch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|sigchld_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|pid_t
name|wait_pid
decl_stmt|;
name|debug
argument_list|(
literal|"Received SIGCHLD."
argument_list|)
expr_stmt|;
name|wait_pid
operator|=
name|wait
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|&
name|child_wait_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_pid
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|wait_pid
operator|!=
name|child_pid
condition|)
name|error
argument_list|(
literal|"Strange, got SIGCHLD and wait returned pid %d but child is %d"
argument_list|,
name|wait_pid
argument_list|,
name|child_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|child_wait_status
argument_list|)
operator|||
name|WIFSIGNALED
argument_list|(
name|child_wait_status
argument_list|)
condition|)
name|child_terminated
operator|=
literal|1
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld_handler
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sigchld_handler2
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|debug
argument_list|(
literal|"Received SIGCHLD."
argument_list|)
expr_stmt|;
name|child_terminated
operator|=
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld_handler2
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make packets from buffered stderr data, and buffer it for sending  * to the client.  */
end_comment

begin_function
name|void
name|make_packets_from_stderr_data
parameter_list|()
block|{
name|int
name|len
decl_stmt|;
comment|/* Send buffered stderr data to the client. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|>
literal|0
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
block|{
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_is_interactive
argument_list|()
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|512
condition|)
name|len
operator|=
literal|512
expr_stmt|;
block|}
else|else
block|{
comment|/* Keep the packets at reasonable size. */
if|if
condition|(
name|len
operator|>
name|packet_get_maxsize
argument_list|()
condition|)
name|len
operator|=
name|packet_get_maxsize
argument_list|()
expr_stmt|;
block|}
name|packet_start
argument_list|(
name|SSH_SMSG_STDERR_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Make packets from buffered stdout data, and buffer it for sending to the  * client.  */
end_comment

begin_function
name|void
name|make_packets_from_stdout_data
parameter_list|()
block|{
name|int
name|len
decl_stmt|;
comment|/* Send buffered stdout data to the client. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|>
literal|0
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
block|{
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_is_interactive
argument_list|()
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|512
condition|)
name|len
operator|=
literal|512
expr_stmt|;
block|}
else|else
block|{
comment|/* Keep the packets at reasonable size. */
if|if
condition|(
name|len
operator|>
name|packet_get_maxsize
argument_list|()
condition|)
name|len
operator|=
name|packet_get_maxsize
argument_list|()
expr_stmt|;
block|}
name|packet_start
argument_list|(
name|SSH_SMSG_STDOUT_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stdout_bytes
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Sleep in select() until we can do something.  This will initialize the  * select masks.  Upon return, the masks will indicate which descriptors  * have data or can accept data.  Optionally, a maximum time can be specified  * for the duration of the wait (0 = infinite).  */
end_comment

begin_function
name|void
name|wait_until_can_do_something
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|,
name|fd_set
modifier|*
name|writeset
parameter_list|,
name|unsigned
name|int
name|max_time_milliseconds
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* When select fails we restart from here. */
name|retry_select
label|:
comment|/* Initialize select() masks. */
name|FD_ZERO
argument_list|(
name|readset
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
name|writeset
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
block|{
comment|/* wrong: bad condition XXX */
if|if
condition|(
name|channel_not_very_much_buffered_data
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_in
argument_list|,
name|readset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Read packets from the client unless we have too much 		 * buffered stdin or channel data. 		 */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|<
name|buffer_high
operator|&&
name|channel_not_very_much_buffered_data
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_in
argument_list|,
name|readset
argument_list|)
expr_stmt|;
comment|/* 		 * If there is not too much data already buffered going to 		 * the client, try to get some more data from the program. 		 */
if|if
condition|(
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fdout_eof
condition|)
name|FD_SET
argument_list|(
name|fdout
argument_list|,
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fderr_eof
condition|)
name|FD_SET
argument_list|(
name|fderr
argument_list|,
name|readset
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we have buffered data, try to write some of that data 		 * to the program. 		 */
if|if
condition|(
name|fdin
operator|!=
operator|-
literal|1
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|fdin
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
block|}
comment|/* Set masks for channel descriptors. */
name|channel_prepare_select
argument_list|(
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
comment|/* 	 * If we have buffered packet data going to the client, mark that 	 * descriptor. 	 */
if|if
condition|(
name|packet_have_data_to_write
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_out
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
comment|/* Update the maximum descriptor number if appropriate. */
if|if
condition|(
name|channel_max_fd
argument_list|()
operator|>
name|max_fd
condition|)
name|max_fd
operator|=
name|channel_max_fd
argument_list|()
expr_stmt|;
comment|/* 	 * If child has terminated and there is enough buffer space to read 	 * from it, then read as much as is available and exit. 	 */
if|if
condition|(
name|child_terminated
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
if|if
condition|(
name|max_time_milliseconds
operator|==
literal|0
condition|)
name|max_time_milliseconds
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|max_time_milliseconds
operator|==
literal|0
condition|)
name|tvp
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|max_time_milliseconds
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|1000
operator|*
operator|(
name|max_time_milliseconds
operator|%
literal|1000
operator|)
expr_stmt|;
name|tvp
operator|=
operator|&
name|tv
expr_stmt|;
block|}
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
name|debug
argument_list|(
literal|"tvp!=NULL kid %d mili %d"
argument_list|,
name|child_terminated
argument_list|,
name|max_time_milliseconds
argument_list|)
expr_stmt|;
comment|/* Wait for something to happen, or the timeout to expire. */
name|ret
operator|=
name|select
argument_list|(
name|max_fd
operator|+
literal|1
argument_list|,
name|readset
argument_list|,
name|writeset
argument_list|,
name|NULL
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|error
argument_list|(
literal|"select: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
goto|goto
name|retry_select
goto|;
block|}
block|}
end_function

begin_comment
comment|/*  * Processes input from the client and the program.  Input data is stored  * in buffers and processed later.  */
end_comment

begin_function
name|void
name|process_input
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|16384
index|]
decl_stmt|;
comment|/* Read and buffer any input data from the client. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_in
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|len
operator|=
name|read
argument_list|(
name|connection_in
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
literal|"Connection closed by remote host."
argument_list|)
expr_stmt|;
name|fatal_cleanup
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
operator|&&
name|errno
operator|!=
name|EAGAIN
condition|)
block|{
name|verbose
argument_list|(
literal|"Read error from remote host: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fatal_cleanup
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Buffer any received data. */
name|packet_process_incoming
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|compat20
condition|)
return|return;
comment|/* Read and buffer any available stdout data from the program. */
if|if
condition|(
operator|!
name|fdout_eof
operator|&&
name|FD_ISSET
argument_list|(
name|fdout
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|len
operator|=
name|read
argument_list|(
name|fdout
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
block|{
comment|/* do nothing */
block|}
elseif|else
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|fdout_eof
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|buffer_append
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fdout_bytes
operator|+=
name|len
expr_stmt|;
block|}
block|}
comment|/* Read and buffer any available stderr data from the program. */
if|if
condition|(
operator|!
name|fderr_eof
operator|&&
name|FD_ISSET
argument_list|(
name|fderr
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|len
operator|=
name|read
argument_list|(
name|fderr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
block|{
comment|/* do nothing */
block|}
elseif|else
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|fderr_eof
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Sends data from internal buffers to client program stdin.  */
end_comment

begin_function
name|void
name|process_output
parameter_list|(
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|struct
name|termios
name|tio
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Write buffered data to program stdin. */
if|if
condition|(
operator|!
name|compat20
operator|&&
name|fdin
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|fdin
argument_list|,
name|writeset
argument_list|)
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|fdin
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
block|{
comment|/* do nothing */
block|}
elseif|else
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_PIPES
name|close
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|fdin
operator|!=
name|fdout
condition|)
name|close
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
else|else
name|shutdown
argument_list|(
name|fdin
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
comment|/* We will no longer send. */
endif|#
directive|endif
name|fdin
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Successful write. */
if|if
condition|(
name|fdin_is_tty
operator|&&
name|tcgetattr
argument_list|(
name|fdin
argument_list|,
operator|&
name|tio
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|tio
operator|.
name|c_lflag
operator|&
name|ECHO
operator|)
operator|&&
operator|(
name|tio
operator|.
name|c_lflag
operator|&
name|ICANON
operator|)
condition|)
block|{
comment|/* 				 * Simulate echo to reduce the impact of 				 * traffic analysis 				 */
name|packet_start
argument_list|(
name|SSH_MSG_IGNORE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
comment|/* Consume the data from the buffer. */
name|buffer_consume
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Update the count of bytes written to the program. */
name|stdin_bytes
operator|+=
name|len
expr_stmt|;
block|}
block|}
comment|/* Send any buffered packet data to the client. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_out
argument_list|,
name|writeset
argument_list|)
condition|)
name|packet_write_poll
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait until all buffered output has been sent to the client.  * This is used when the program terminates.  */
end_comment

begin_function
name|void
name|drain_output
parameter_list|()
block|{
comment|/* Send any buffered stdout data to the client. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_SMSG_STDOUT_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* Update the count of sent bytes. */
name|stdout_bytes
operator|+=
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
block|}
comment|/* Send any buffered stderr data to the client. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_SMSG_STDERR_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* Update the count of sent bytes. */
name|stderr_bytes
operator|+=
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
block|}
comment|/* Wait until all buffered data has been written to the client. */
name|packet_write_wait
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|process_buffered_input_packets
parameter_list|()
block|{
name|dispatch_run
argument_list|(
name|DISPATCH_NONBLOCK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Performs the interactive session.  This handles data transmission between  * the client and the program.  Note that the notion of stdin, stdout, and  * stderr in this function is sort of reversed: this function writes to  * stdin (of the child program), and reads from stdout and stderr (of the  * child program).  */
end_comment

begin_function
name|void
name|server_loop
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|int
name|fdin_arg
parameter_list|,
name|int
name|fdout_arg
parameter_list|,
name|int
name|fderr_arg
parameter_list|)
block|{
name|fd_set
name|readset
decl_stmt|,
name|writeset
decl_stmt|;
name|int
name|wait_status
decl_stmt|;
comment|/* Status returned by wait(). */
name|pid_t
name|wait_pid
decl_stmt|;
comment|/* pid returned by wait(). */
name|int
name|waiting_termination
init|=
literal|0
decl_stmt|;
comment|/* Have displayed waiting close message. */
name|unsigned
name|int
name|max_time_milliseconds
decl_stmt|;
name|unsigned
name|int
name|previous_stdout_buffer_bytes
decl_stmt|;
name|unsigned
name|int
name|stdout_buffer_bytes
decl_stmt|;
name|int
name|type
decl_stmt|;
name|debug
argument_list|(
literal|"Entering interactive session."
argument_list|)
expr_stmt|;
comment|/* Initialize the SIGCHLD kludge. */
name|child_pid
operator|=
name|pid
expr_stmt|;
name|child_terminated
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld_handler
argument_list|)
expr_stmt|;
comment|/* Initialize our global variables. */
name|fdin
operator|=
name|fdin_arg
expr_stmt|;
name|fdout
operator|=
name|fdout_arg
expr_stmt|;
name|fderr
operator|=
name|fderr_arg
expr_stmt|;
comment|/* nonblocking IO */
name|set_nonblock
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
name|fdout
argument_list|)
expr_stmt|;
comment|/* we don't have stderr for interactive terminal sessions, see below */
if|if
condition|(
name|fderr
operator|!=
operator|-
literal|1
condition|)
name|set_nonblock
argument_list|(
name|fderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|datafellows
operator|&
name|SSH_BUG_IGNOREMSG
operator|)
operator|&&
name|isatty
argument_list|(
name|fdin
argument_list|)
condition|)
name|fdin_is_tty
operator|=
literal|1
expr_stmt|;
name|connection_in
operator|=
name|packet_get_connection_in
argument_list|()
expr_stmt|;
name|connection_out
operator|=
name|packet_get_connection_out
argument_list|()
expr_stmt|;
name|previous_stdout_buffer_bytes
operator|=
literal|0
expr_stmt|;
comment|/* Set approximate I/O buffer size. */
if|if
condition|(
name|packet_is_interactive
argument_list|()
condition|)
name|buffer_high
operator|=
literal|4096
expr_stmt|;
else|else
name|buffer_high
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
comment|/* Initialize max_fd to the maximum of the known file descriptors. */
name|max_fd
operator|=
name|fdin
expr_stmt|;
if|if
condition|(
name|fdout
operator|>
name|max_fd
condition|)
name|max_fd
operator|=
name|fdout
expr_stmt|;
if|if
condition|(
name|fderr
operator|!=
operator|-
literal|1
operator|&&
name|fderr
operator|>
name|max_fd
condition|)
name|max_fd
operator|=
name|fderr
expr_stmt|;
if|if
condition|(
name|connection_in
operator|>
name|max_fd
condition|)
name|max_fd
operator|=
name|connection_in
expr_stmt|;
if|if
condition|(
name|connection_out
operator|>
name|max_fd
condition|)
name|max_fd
operator|=
name|connection_out
expr_stmt|;
comment|/* Initialize Initialize buffers. */
name|buffer_init
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
comment|/* 	 * If we have no separate fderr (which is the case when we have a pty 	 * - there we cannot make difference between data sent to stdout and 	 * stderr), indicate that we have seen an EOF from stderr.  This way 	 * we don\'t need to check the descriptor everywhere. 	 */
if|if
condition|(
name|fderr
operator|==
operator|-
literal|1
condition|)
name|fderr_eof
operator|=
literal|1
expr_stmt|;
name|server_init_dispatch
argument_list|()
expr_stmt|;
comment|/* Main loop of the server for the interactive session mode. */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Process buffered packets from the client. */
name|process_buffered_input_packets
argument_list|()
expr_stmt|;
comment|/* 		 * If we have received eof, and there is no more pending 		 * input data, cause a real eof by closing fdin. 		 */
if|if
condition|(
name|stdin_eof
operator|&&
name|fdin
operator|!=
operator|-
literal|1
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_PIPES
name|close
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|fdin
operator|!=
name|fdout
condition|)
name|close
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
else|else
name|shutdown
argument_list|(
name|fdin
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
comment|/* We will no longer send. */
endif|#
directive|endif
name|fdin
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Make packets from buffered stderr data to send to the client. */
name|make_packets_from_stderr_data
argument_list|()
expr_stmt|;
comment|/* 		 * Make packets from buffered stdout data to send to the 		 * client. If there is very little to send, this arranges to 		 * not send them now, but to wait a short while to see if we 		 * are getting more data. This is necessary, as some systems 		 * wake up readers from a pty after each separate character. 		 */
name|max_time_milliseconds
operator|=
literal|0
expr_stmt|;
name|stdout_buffer_bytes
operator|=
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdout_buffer_bytes
operator|!=
literal|0
operator|&&
name|stdout_buffer_bytes
operator|<
literal|256
operator|&&
name|stdout_buffer_bytes
operator|!=
name|previous_stdout_buffer_bytes
condition|)
block|{
comment|/* try again after a while */
name|max_time_milliseconds
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
comment|/* Send it now. */
name|make_packets_from_stdout_data
argument_list|()
expr_stmt|;
block|}
name|previous_stdout_buffer_bytes
operator|=
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
comment|/* Send channel data to the client. */
if|if
condition|(
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
name|channel_output_poll
argument_list|()
expr_stmt|;
comment|/* 		 * Bail out of the loop if the program has closed its output 		 * descriptors, and we have no more data to send to the 		 * client, and there is no pending buffered data. 		 */
if|if
condition|(
name|fdout_eof
operator|&&
name|fderr_eof
operator|&&
operator|!
name|packet_have_data_to_write
argument_list|()
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|==
literal|0
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|channel_still_open
argument_list|()
condition|)
break|break;
if|if
condition|(
operator|!
name|waiting_termination
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
literal|"Waiting for forwarded connections to terminate...\r\n"
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|waiting_termination
operator|=
literal|1
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Display list of open channels. */
name|cp
operator|=
name|channel_open_message
argument_list|()
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Sleep in select() until we can do something. */
name|wait_until_can_do_something
argument_list|(
operator|&
name|readset
argument_list|,
operator|&
name|writeset
argument_list|,
name|max_time_milliseconds
argument_list|)
expr_stmt|;
comment|/* Process any channel events. */
name|channel_after_select
argument_list|(
operator|&
name|readset
argument_list|,
operator|&
name|writeset
argument_list|)
expr_stmt|;
comment|/* Process input from the client and from program stdout/stderr. */
name|process_input
argument_list|(
operator|&
name|readset
argument_list|)
expr_stmt|;
comment|/* Process output to the client and to program stdin. */
name|process_output
argument_list|(
operator|&
name|writeset
argument_list|)
expr_stmt|;
block|}
comment|/* Cleanup and termination code. */
comment|/* Wait until all output has been sent to the client. */
name|drain_output
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes."
argument_list|,
name|stdin_bytes
argument_list|,
name|fdout_bytes
argument_list|,
name|stdout_bytes
argument_list|,
name|stderr_bytes
argument_list|)
expr_stmt|;
comment|/* Free and clear the buffers. */
name|buffer_free
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
comment|/* Close the file descriptors. */
if|if
condition|(
name|fdout
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fdout
argument_list|)
expr_stmt|;
name|fdout
operator|=
operator|-
literal|1
expr_stmt|;
name|fdout_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fderr
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fderr
argument_list|)
expr_stmt|;
name|fderr
operator|=
operator|-
literal|1
expr_stmt|;
name|fderr_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fdin
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
name|fdin
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Stop listening for channels; this removes unix domain sockets. */
name|channel_stop_listening
argument_list|()
expr_stmt|;
comment|/* Wait for the child to exit.  Get its exit status. */
name|wait_pid
operator|=
name|wait
argument_list|(
operator|&
name|wait_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_pid
operator|<
literal|0
condition|)
block|{
comment|/* 		 * It is possible that the wait was handled by SIGCHLD 		 * handler.  This may result in either: this call 		 * returning with EINTR, or: this call returning ECHILD. 		 */
if|if
condition|(
name|child_terminated
condition|)
name|wait_status
operator|=
name|child_wait_status
expr_stmt|;
else|else
name|packet_disconnect
argument_list|(
literal|"wait: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check if it matches the process we forked. */
if|if
condition|(
name|wait_pid
operator|!=
name|pid
condition|)
name|error
argument_list|(
literal|"Strange, wait returned pid %d, expected %d"
argument_list|,
name|wait_pid
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
comment|/* We no longer want our SIGCHLD handler to be called. */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* Check if it exited normally. */
if|if
condition|(
name|WIFEXITED
argument_list|(
name|wait_status
argument_list|)
condition|)
block|{
comment|/* Yes, normal exit.  Get exit status and send it to the client. */
name|debug
argument_list|(
literal|"Command exited with status %d."
argument_list|,
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_SMSG_EXITSTATUS
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* 		 * Wait for exit confirmation.  Note that there might be 		 * other packets coming before it; however, the program has 		 * already died so we just ignore them.  The client is 		 * supposed to respond with the confirmation when it receives 		 * the exit status. 		 */
do|do
block|{
name|int
name|plen
decl_stmt|;
name|type
operator|=
name|packet_read
argument_list|(
operator|&
name|plen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|type
operator|!=
name|SSH_CMSG_EXIT_CONFIRMATION
condition|)
do|;
name|debug
argument_list|(
literal|"Received exit confirmation."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check if the program terminated due to a signal. */
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|wait_status
argument_list|)
condition|)
name|packet_disconnect
argument_list|(
literal|"Command terminated on signal %d."
argument_list|,
name|WTERMSIG
argument_list|(
name|wait_status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some weird exit cause.  Just exit. */
name|packet_disconnect
argument_list|(
literal|"wait returned status %04x."
argument_list|,
name|wait_status
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|void
name|server_loop2
parameter_list|(
name|void
parameter_list|)
block|{
name|fd_set
name|readset
decl_stmt|,
name|writeset
decl_stmt|;
name|int
name|had_channel
init|=
literal|0
decl_stmt|;
name|int
name|status
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|debug
argument_list|(
literal|"Entering interactive session for SSH2."
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld_handler2
argument_list|)
expr_stmt|;
name|child_terminated
operator|=
literal|0
expr_stmt|;
name|connection_in
operator|=
name|packet_get_connection_in
argument_list|()
expr_stmt|;
name|connection_out
operator|=
name|packet_get_connection_out
argument_list|()
expr_stmt|;
name|max_fd
operator|=
name|connection_in
expr_stmt|;
if|if
condition|(
name|connection_out
operator|>
name|max_fd
condition|)
name|max_fd
operator|=
name|connection_out
expr_stmt|;
name|server_init_dispatch
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|process_buffered_input_packets
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|had_channel
operator|&&
name|channel_still_open
argument_list|()
condition|)
name|had_channel
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|had_channel
operator|&&
operator|!
name|channel_still_open
argument_list|()
condition|)
block|{
name|debug
argument_list|(
literal|"!channel_still_open."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
name|channel_output_poll
argument_list|()
expr_stmt|;
name|wait_until_can_do_something
argument_list|(
operator|&
name|readset
argument_list|,
operator|&
name|writeset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_terminated
condition|)
block|{
while|while
condition|(
operator|(
name|pid
operator|=
name|waitpid
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|session_close_by_pid
argument_list|(
name|pid
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|child_terminated
operator|=
literal|0
expr_stmt|;
block|}
name|channel_after_select
argument_list|(
operator|&
name|readset
argument_list|,
operator|&
name|writeset
argument_list|)
expr_stmt|;
name|process_input
argument_list|(
operator|&
name|readset
argument_list|)
expr_stmt|;
name|process_output
argument_list|(
operator|&
name|writeset
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
name|waitpid
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|session_close_by_pid
argument_list|(
name|pid
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|channel_stop_listening
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_input_stdin_data
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|data_len
decl_stmt|;
comment|/* Stdin data from the client.  Append it to the buffer. */
comment|/* Ignore any data if the client has closed stdin. */
if|if
condition|(
name|fdin
operator|==
operator|-
literal|1
condition|)
return|return;
name|data
operator|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
expr_stmt|;
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
operator|(
literal|4
operator|+
name|data_len
operator|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_input_eof
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
comment|/* 	 * Eof from the client.  The stdin descriptor to the 	 * program will be closed when all buffered data has 	 * drained. 	 */
name|debug
argument_list|(
literal|"EOF received for stdin."
argument_list|)
expr_stmt|;
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|stdin_eof
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_input_window_size
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|int
name|row
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
name|int
name|col
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
name|int
name|xpixel
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
name|int
name|ypixel
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
name|debug
argument_list|(
literal|"Window change received."
argument_list|)
expr_stmt|;
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
literal|4
operator|*
literal|4
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdin
operator|!=
operator|-
literal|1
condition|)
name|pty_change_window_size
argument_list|(
name|fdin
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|xpixel
argument_list|,
name|ypixel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|input_direct_tcpip
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|sock
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|,
modifier|*
name|originator
decl_stmt|;
name|int
name|target_port
decl_stmt|,
name|originator_port
decl_stmt|;
name|target
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|target_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|originator
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|originator_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_done
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"open direct-tcpip: from %s port %d to %s port %d"
argument_list|,
name|originator
argument_list|,
name|originator_port
argument_list|,
name|target
argument_list|,
name|target_port
argument_list|)
expr_stmt|;
comment|/* XXX check permission */
if|if
condition|(
name|no_port_forwarding_flag
operator|||
operator|!
name|options
operator|.
name|allow_tcp_forwarding
condition|)
block|{
name|xfree
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|originator
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sock
operator|=
name|channel_connect_to
argument_list|(
name|target
argument_list|,
name|target_port
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|originator
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|channel_new
argument_list|(
literal|"direct-tcpip"
argument_list|,
name|SSH_CHANNEL_OPEN
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_TCP_WINDOW_DEFAULT
argument_list|,
name|CHAN_TCP_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
name|xstrdup
argument_list|(
literal|"direct-tcpip"
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|server_input_channel_open
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|plen
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ctype
decl_stmt|;
name|int
name|id
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|int
name|rchan
decl_stmt|;
name|int
name|rmaxpack
decl_stmt|;
name|int
name|rwindow
decl_stmt|;
name|ctype
operator|=
name|packet_get_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|rchan
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|rwindow
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|rmaxpack
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"server_input_channel_open: ctype %s rchan %d win %d max %d"
argument_list|,
name|ctype
argument_list|,
name|rchan
argument_list|,
name|rwindow
argument_list|,
name|rmaxpack
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"session"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"open session"
argument_list|)
expr_stmt|;
name|packet_done
argument_list|()
expr_stmt|;
comment|/* 		 * A server session has no fd to read or write 		 * until a CHANNEL_REQUEST for a shell is made, 		 * so we set the type to SSH_CHANNEL_LARVAL. 		 * Additionally, a callback for handling all 		 * CHANNEL_REQUEST messages is registered. 		 */
name|id
operator|=
name|channel_new
argument_list|(
name|ctype
argument_list|,
name|SSH_CHANNEL_LARVAL
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|CHAN_SES_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
name|xstrdup
argument_list|(
literal|"server-session"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|session_open
argument_list|(
name|id
argument_list|)
operator|==
literal|1
condition|)
block|{
name|channel_register_callback
argument_list|(
name|id
argument_list|,
name|SSH2_MSG_CHANNEL_REQUEST
argument_list|,
name|session_input_channel_req
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|channel_register_cleanup
argument_list|(
name|id
argument_list|,
name|session_close_by_channel
argument_list|)
expr_stmt|;
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"session open failed, free channel %d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"direct-tcpip"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|id
operator|=
name|input_direct_tcpip
argument_list|()
expr_stmt|;
if|if
condition|(
name|id
operator|>=
literal|0
condition|)
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"confirm %s"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
name|rchan
expr_stmt|;
name|c
operator|->
name|remote_window
operator|=
name|rwindow
expr_stmt|;
name|c
operator|->
name|remote_maxpacket
operator|=
name|rmaxpack
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"failure %s"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|rchan
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"bla bla"
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|xfree
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_init_dispatch_20
parameter_list|()
block|{
name|debug
argument_list|(
literal|"server_init_dispatch_20"
argument_list|)
expr_stmt|;
name|dispatch_init
argument_list|(
operator|&
name|dispatch_protocol_error
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_oclose
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_DATA
argument_list|,
operator|&
name|channel_input_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_EOF
argument_list|,
operator|&
name|channel_input_ieof
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_EXTENDED_DATA
argument_list|,
operator|&
name|channel_input_extended_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|,
operator|&
name|server_input_channel_open
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|,
operator|&
name|channel_input_open_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_FAILURE
argument_list|,
operator|&
name|channel_input_open_failure
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_REQUEST
argument_list|,
operator|&
name|channel_input_channel_request
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_WINDOW_ADJUST
argument_list|,
operator|&
name|channel_input_window_adjust
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_init_dispatch_13
parameter_list|()
block|{
name|debug
argument_list|(
literal|"server_init_dispatch_13"
argument_list|)
expr_stmt|;
name|dispatch_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_CMSG_EOF
argument_list|,
operator|&
name|server_input_eof
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_CMSG_STDIN_DATA
argument_list|,
operator|&
name|server_input_stdin_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_CMSG_WINDOW_SIZE
argument_list|,
operator|&
name|server_input_window_size
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_close
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE_CONFIRMATION
argument_list|,
operator|&
name|channel_input_close_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_DATA
argument_list|,
operator|&
name|channel_input_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|,
operator|&
name|channel_input_open_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|,
operator|&
name|channel_input_open_failure
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_PORT_OPEN
argument_list|,
operator|&
name|channel_input_port_open
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_init_dispatch_15
parameter_list|()
block|{
name|server_init_dispatch_13
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"server_init_dispatch_15"
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_ieof
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE_CONFIRMATION
argument_list|,
operator|&
name|channel_input_oclose
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_init_dispatch
parameter_list|()
block|{
if|if
condition|(
name|compat20
condition|)
name|server_init_dispatch_20
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|compat13
condition|)
name|server_init_dispatch_13
argument_list|()
expr_stmt|;
else|else
name|server_init_dispatch_15
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

