begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1987, 1988 by the Massachusetts Institute of Technology.  *   * For copying and distribution information, please see the file  *<mit-copyright.h>.  *  * Kerberos database manipulation utility. This program allows you to  * dump a kerberos database to an ascii readable file and load this  * file into the database. Read locking of the database is done during a  * dump operation. NO LOCKING is done during a load operation. Loads  * should happen with other processes shutdown.   *  * Written July 9, 1987 by Jeffrey I. Schiller  */
end_comment

begin_include
include|#
directive|include
file|"adm_locl.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: kdb_util.c,v 1.42.2.1 2000/10/10 12:59:16 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|des_cblock
name|master_key
decl_stmt|,
name|new_master_key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|des_key_schedule
name|master_key_schedule
decl_stmt|,
name|new_master_key_schedule
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cv_key is a procedure which takes a principle and changes its key,     either for a new method of encrypting the keys, or a new master key.    if cv_key is null no transformation of key is done (other than net byte    order). */
end_comment

begin_struct
struct|struct
name|callback_args
block|{
name|void
function_decl|(
modifier|*
name|cv_key
function_decl|)
parameter_list|(
name|Principal
modifier|*
parameter_list|)
function_decl|;
name|FILE
modifier|*
name|output_file
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|print_time
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|time_t
name|timeval
parameter_list|)
block|{
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|timeval
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %04d%02d%02d%02d%02d"
argument_list|,
name|tm
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|time_explode
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|char
name|wbuf
index|[
literal|5
index|]
decl_stmt|;
name|struct
name|tm
name|tp
decl_stmt|;
name|int
name|local
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clear out the struct */
if|if
condition|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|>
literal|10
condition|)
block|{
comment|/* new format */
name|strlcpy
argument_list|(
name|wbuf
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|wbuf
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|.
name|tm_year
operator|=
name|atoi
argument_list|(
name|wbuf
argument_list|)
operator|-
literal|1900
expr_stmt|;
name|cp
operator|+=
literal|4
expr_stmt|;
comment|/* step over the year */
name|local
operator|=
literal|0
expr_stmt|;
comment|/* GMT */
block|}
else|else
block|{
comment|/* old format: local time,  					   year is 2 digits, assuming 19xx */
name|wbuf
index|[
literal|0
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|wbuf
index|[
literal|1
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|wbuf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tp
operator|.
name|tm_year
operator|=
name|atoi
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
name|local
operator|=
literal|1
expr_stmt|;
comment|/* local */
block|}
name|wbuf
index|[
literal|0
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|wbuf
index|[
literal|1
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|wbuf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tp
operator|.
name|tm_mon
operator|=
name|atoi
argument_list|(
name|wbuf
argument_list|)
operator|-
literal|1
expr_stmt|;
name|wbuf
index|[
literal|0
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|wbuf
index|[
literal|1
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|tp
operator|.
name|tm_mday
operator|=
name|atoi
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
name|wbuf
index|[
literal|0
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|wbuf
index|[
literal|1
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|tp
operator|.
name|tm_hour
operator|=
name|atoi
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
name|wbuf
index|[
literal|0
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|wbuf
index|[
literal|1
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|tp
operator|.
name|tm_min
operator|=
name|atoi
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|tm2time
argument_list|(
name|tp
argument_list|,
name|local
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_db_1
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|Principal
modifier|*
name|principal
parameter_list|)
comment|/* replace null strings with "*" */
block|{
name|struct
name|callback_args
modifier|*
name|a
init|=
operator|(
expr|struct
name|callback_args
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|principal
operator|->
name|instance
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|principal
operator|->
name|instance
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|principal
operator|->
name|instance
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|principal
operator|->
name|mod_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|principal
operator|->
name|mod_name
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|principal
operator|->
name|mod_name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|principal
operator|->
name|mod_instance
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|principal
operator|->
name|mod_instance
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|principal
operator|->
name|mod_instance
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|cv_key
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|a
operator|->
name|cv_key
call|)
argument_list|(
name|principal
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|a
operator|->
name|output_file
argument_list|,
literal|"%s %s %d %d %d %d %x %x"
argument_list|,
name|principal
operator|->
name|name
argument_list|,
name|principal
operator|->
name|instance
argument_list|,
name|principal
operator|->
name|max_life
argument_list|,
name|principal
operator|->
name|kdc_key_ver
argument_list|,
name|principal
operator|->
name|key_version
argument_list|,
name|principal
operator|->
name|attributes
argument_list|,
operator|(
name|int
operator|)
name|htonl
argument_list|(
name|principal
operator|->
name|key_low
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|htonl
argument_list|(
name|principal
operator|->
name|key_high
argument_list|)
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
name|a
operator|->
name|output_file
argument_list|,
name|principal
operator|->
name|exp_date
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
name|a
operator|->
name|output_file
argument_list|,
name|principal
operator|->
name|mod_date
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|a
operator|->
name|output_file
argument_list|,
literal|" %s %s\n"
argument_list|,
name|principal
operator|->
name|mod_name
argument_list|,
name|principal
operator|->
name|mod_instance
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_db
parameter_list|(
name|char
modifier|*
name|db_file
parameter_list|,
name|FILE
modifier|*
name|output_file
parameter_list|,
name|void
function_decl|(
modifier|*
name|cv_key
function_decl|)
parameter_list|(
name|Principal
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|callback_args
name|a
decl_stmt|;
name|a
operator|.
name|cv_key
operator|=
name|cv_key
expr_stmt|;
name|a
operator|.
name|output_file
operator|=
name|output_file
expr_stmt|;
name|kerb_db_iterate
argument_list|(
name|dump_db_1
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
return|return
name|fflush
argument_list|(
name|output_file
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_file
parameter_list|(
name|void
modifier|*
name|db
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|lineno
init|=
literal|0
decl_stmt|;
name|char
name|line
index|[
literal|1024
index|]
decl_stmt|;
name|unsigned
name|long
name|key
index|[
literal|2
index|]
decl_stmt|;
comment|/* yes, long */
name|Principal
name|pr
decl_stmt|;
name|char
name|exp_date
index|[
literal|64
index|]
decl_stmt|,
name|mod_date
index|[
literal|64
index|]
decl_stmt|;
name|int
name|life
decl_stmt|,
name|kkvno
decl_stmt|,
name|kvno
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|memset
argument_list|(
operator|&
name|pr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|file
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fgets"
argument_list|)
expr_stmt|;
break|break;
block|}
name|lineno
operator|++
expr_stmt|;
name|ret
operator|=
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"%s %s %d %d %d %hd %lx %lx %s %s %s %s"
argument_list|,
name|pr
operator|.
name|name
argument_list|,
name|pr
operator|.
name|instance
argument_list|,
operator|&
name|life
argument_list|,
operator|&
name|kkvno
argument_list|,
operator|&
name|kvno
argument_list|,
operator|&
name|pr
operator|.
name|attributes
argument_list|,
operator|&
name|key
index|[
literal|0
index|]
argument_list|,
operator|&
name|key
index|[
literal|1
index|]
argument_list|,
name|exp_date
argument_list|,
name|mod_date
argument_list|,
name|pr
operator|.
name|mod_name
argument_list|,
name|pr
operator|.
name|mod_instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|12
condition|)
block|{
name|warnx
argument_list|(
literal|"Line %d malformed (ignored)"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pr
operator|.
name|key_low
operator|=
name|ntohl
argument_list|(
name|key
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pr
operator|.
name|key_high
operator|=
name|ntohl
argument_list|(
name|key
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pr
operator|.
name|max_life
operator|=
name|life
expr_stmt|;
name|pr
operator|.
name|kdc_key_ver
operator|=
name|kkvno
expr_stmt|;
name|pr
operator|.
name|key_version
operator|=
name|kvno
expr_stmt|;
name|pr
operator|.
name|exp_date
operator|=
name|time_explode
argument_list|(
name|exp_date
argument_list|)
expr_stmt|;
name|pr
operator|.
name|mod_date
operator|=
name|time_explode
argument_list|(
name|mod_date
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|.
name|instance
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|pr
operator|.
name|instance
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pr
operator|.
name|mod_name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|pr
operator|.
name|mod_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pr
operator|.
name|mod_instance
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|pr
operator|.
name|mod_instance
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kerb_db_update
argument_list|(
name|db
argument_list|,
operator|&
name|pr
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"store %s.%s aborted"
argument_list|,
name|pr
operator|.
name|name
argument_list|,
name|pr
operator|.
name|instance
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|load_db
parameter_list|(
name|char
modifier|*
name|db_file
parameter_list|,
name|FILE
modifier|*
name|input_file
parameter_list|)
block|{
name|long
modifier|*
name|db
decl_stmt|;
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|temp_db_file
decl_stmt|;
name|asprintf
argument_list|(
operator|&
name|temp_db_file
argument_list|,
literal|"%s~"
argument_list|,
name|db_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_db_file
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
comment|/* Create the database */
if|if
condition|(
operator|(
name|code
operator|=
name|kerb_db_create
argument_list|(
name|temp_db_file
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"creating temp database %s"
argument_list|,
name|temp_db_file
argument_list|)
expr_stmt|;
name|kerb_db_set_name
argument_list|(
name|temp_db_file
argument_list|)
expr_stmt|;
name|db
operator|=
name|kerb_db_begin_update
argument_list|()
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"opening temp database %s"
argument_list|,
name|temp_db_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_file
argument_list|(
name|db
argument_list|,
name|input_file
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Load aborted"
argument_list|)
expr_stmt|;
name|kerb_db_end_update
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|kerb_db_rename
argument_list|(
name|temp_db_file
argument_list|,
name|db_file
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|warn
argument_list|(
literal|"database rename failed"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_db_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|merge_db
parameter_list|(
name|char
modifier|*
name|db_file
parameter_list|,
name|FILE
modifier|*
name|input_file
parameter_list|)
block|{
name|void
modifier|*
name|db
decl_stmt|;
name|db
operator|=
name|kerb_db_begin_update
argument_list|()
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Couldn't open database"
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_file
argument_list|(
name|db
argument_list|,
name|input_file
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Merge aborted"
argument_list|)
expr_stmt|;
name|kerb_db_end_update
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_ok_file
parameter_list|(
name|char
modifier|*
name|file_name
parameter_list|)
block|{
comment|/* handle slave locking/failure stuff */
name|char
modifier|*
name|file_ok
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|asprintf
argument_list|(
operator|&
name|file_ok
argument_list|,
literal|"%s.dump_ok"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_ok
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|file_ok
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Error creating %s"
argument_list|,
name|file_ok
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_ok
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/*      * Some versions of BSD don't update the mtime in the above open so      * we call utimes just in case.      */
if|if
condition|(
name|utime
argument_list|(
name|file_name
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"utime %s"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|convert_key_new_master
parameter_list|(
name|Principal
modifier|*
name|p
parameter_list|)
block|{
name|des_cblock
name|key
decl_stmt|;
comment|/* leave null keys alone */
if|if
condition|(
operator|(
name|p
operator|->
name|key_low
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p
operator|->
name|key_high
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* move current key to des_cblock for encryption, special case master key      since that's changing */
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|KERB_M_NAME
argument_list|,
name|ANAME_SZ
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|p
operator|->
name|instance
argument_list|,
name|KERB_M_INST
argument_list|,
name|INST_SZ
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|key
argument_list|,
name|new_master_key
argument_list|,
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|p
operator|->
name|key_version
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
name|copy_to_key
argument_list|(
operator|&
name|p
operator|->
name|key_low
argument_list|,
operator|&
name|p
operator|->
name|key_high
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|kdb_encrypt_key
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|master_key
argument_list|,
name|master_key_schedule
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
block|}
name|kdb_encrypt_key
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|new_master_key
argument_list|,
name|new_master_key_schedule
argument_list|,
name|DES_ENCRYPT
argument_list|)
expr_stmt|;
name|copy_from_key
argument_list|(
name|key
argument_list|,
operator|&
operator|(
name|p
operator|->
name|key_low
operator|)
argument_list|,
operator|&
operator|(
name|p
operator|->
name|key_high
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
comment|/* a little paranoia ... */
operator|(
name|p
operator|->
name|kdc_key_ver
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_secrets
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
name|master_key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|master_key_schedule
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|des_key_schedule
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_master_key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_master_key_schedule
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|des_key_schedule
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|convert_new_master_key
parameter_list|(
name|char
modifier|*
name|db_file
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RANDOM_MKEY
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Sorry, this function is not available with "
literal|"the new master key scheme."
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"\n\nEnter the CURRENT master key."
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdb_get_master_key
argument_list|(
name|KDB_GET_PROMPT
argument_list|,
operator|&
name|master_key
argument_list|,
name|master_key_schedule
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|clear_secrets
argument_list|()
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Couldn't get master key."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kdb_verify_master_key
argument_list|(
operator|&
name|master_key
argument_list|,
name|master_key_schedule
argument_list|,
name|stderr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|clear_secrets
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\nNow enter the NEW master key.  Do not forget it!!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdb_get_master_key
argument_list|(
name|KDB_GET_TWICE
argument_list|,
operator|&
name|new_master_key
argument_list|,
name|new_master_key_schedule
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|clear_secrets
argument_list|()
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Couldn't get new master key."
argument_list|)
expr_stmt|;
block|}
name|dump_db
argument_list|(
name|db_file
argument_list|,
name|out
argument_list|,
name|convert_key_new_master
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|asprintf
argument_list|(
operator|&
name|fname
argument_list|,
literal|"%s.new"
argument_list|,
name|MKEYFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|clear_secrets
argument_list|()
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc: failed"
argument_list|)
expr_stmt|;
block|}
name|kdb_kstash
argument_list|(
operator|&
name|new_master_key
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RANDOM_MKEY */
block|}
end_function

begin_function
specifier|static
name|void
name|convert_key_old_db
parameter_list|(
name|Principal
modifier|*
name|p
parameter_list|)
block|{
name|des_cblock
name|key
decl_stmt|;
comment|/* leave null keys alone */
if|if
condition|(
operator|(
name|p
operator|->
name|key_low
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p
operator|->
name|key_high
operator|==
literal|0
operator|)
condition|)
return|return;
name|copy_to_key
argument_list|(
operator|&
name|p
operator|->
name|key_low
argument_list|,
operator|&
name|p
operator|->
name|key_high
argument_list|,
name|key
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOENCRYPTION
name|des_pcbc_encrypt
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|key
argument_list|,
operator|(
name|des_cblock
operator|*
operator|)
name|key
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
argument_list|,
name|master_key_schedule
argument_list|,
operator|(
name|des_cblock
operator|*
operator|)
name|master_key_schedule
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* make new key, new style */
name|kdb_encrypt_key
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|master_key
argument_list|,
name|master_key_schedule
argument_list|,
name|DES_ENCRYPT
argument_list|)
expr_stmt|;
name|copy_from_key
argument_list|(
name|key
argument_list|,
operator|&
operator|(
name|p
operator|->
name|key_low
operator|)
argument_list|,
operator|&
operator|(
name|p
operator|->
name|key_high
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
comment|/* a little paranoia ... */
block|}
end_function

begin_function
specifier|static
name|void
name|convert_old_format_db
parameter_list|(
name|char
modifier|*
name|db_file
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|des_cblock
name|key_from_db
decl_stmt|;
name|Principal
name|principal_data
index|[
literal|1
index|]
decl_stmt|;
name|int
name|n
decl_stmt|,
name|more
decl_stmt|;
if|if
condition|(
name|kdb_get_master_key
argument_list|(
name|KDB_GET_PROMPT
argument_list|,
operator|&
name|master_key
argument_list|,
name|master_key_schedule
argument_list|)
operator|!=
literal|0L
condition|)
block|{
name|clear_secrets
argument_list|()
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Couldn't get master key."
argument_list|)
expr_stmt|;
block|}
comment|/* can't call kdb_verify_master_key because this is an old style db */
comment|/* lookup the master key version */
name|n
operator|=
name|kerb_get_principal
argument_list|(
name|KERB_M_NAME
argument_list|,
name|KERB_M_INST
argument_list|,
name|principal_data
argument_list|,
literal|1
comment|/* only one please */
argument_list|,
operator|&
name|more
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|!=
literal|1
operator|)
operator|||
name|more
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"verify_master_key: Kerberos error on master key lookup, %d found.\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* set up the master key */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Current Kerberos master key version is %d.\n"
argument_list|,
name|principal_data
index|[
literal|0
index|]
operator|.
name|kdc_key_ver
argument_list|)
expr_stmt|;
comment|/*    * now use the master key to decrypt (old style) the key in the db, had better    * be the same!     */
name|copy_to_key
argument_list|(
operator|&
name|principal_data
index|[
literal|0
index|]
operator|.
name|key_low
argument_list|,
operator|&
name|principal_data
index|[
literal|0
index|]
operator|.
name|key_high
argument_list|,
name|key_from_db
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOENCRYPTION
name|des_pcbc_encrypt
argument_list|(
operator|&
name|key_from_db
argument_list|,
operator|&
name|key_from_db
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|key_from_db
argument_list|)
argument_list|,
name|master_key_schedule
argument_list|,
operator|(
name|des_cblock
operator|*
operator|)
name|master_key_schedule
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* the decrypted database key had better equal the master key */
name|n
operator|=
name|memcmp
argument_list|(
name|master_key
argument_list|,
name|key_from_db
argument_list|,
sizeof|sizeof
argument_list|(
name|master_key
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|key_from_db
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key_from_db
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\07\07verify_master_key: Invalid master key, "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"does not match database.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Master key verified.\n"
argument_list|)
expr_stmt|;
name|dump_db
argument_list|(
name|db_file
argument_list|,
name|out
argument_list|,
name|convert_key_old_db
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
enum|enum
block|{
name|OP_LOAD
block|,
name|OP_MERGE
block|,
name|OP_DUMP
block|,
name|OP_SLAVE_DUMP
block|,
name|OP_NEW_MASTER
block|,
name|OP_CONVERT_OLD_DB
block|}
name|op
enum|;
name|char
modifier|*
name|file_name
decl_stmt|;
name|char
modifier|*
name|db_name
decl_stmt|;
name|set_progname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
operator|&&
name|argc
operator|!=
literal|4
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s operation file [database name].\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Operation is one of: "
literal|"load, merge, dump, slave_dump, new_master_key, "
literal|"convert_old_db\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"use file `-' for stdout\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
name|db_name
operator|=
name|DBM_FILE
expr_stmt|;
else|else
name|db_name
operator|=
name|argv
index|[
literal|3
index|]
expr_stmt|;
name|ret
operator|=
name|kerb_db_set_name
argument_list|(
name|db_name
argument_list|)
expr_stmt|;
comment|/* this makes starting slave servers ~14.3 times easier */
if|if
condition|(
name|ret
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"load"
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|kerb_db_create
argument_list|(
name|db_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Can't open database"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"load"
argument_list|)
condition|)
name|op
operator|=
name|OP_LOAD
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"merge"
argument_list|)
condition|)
name|op
operator|=
name|OP_MERGE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"dump"
argument_list|)
condition|)
name|op
operator|=
name|OP_DUMP
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"slave_dump"
argument_list|)
condition|)
name|op
operator|=
name|OP_SLAVE_DUMP
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"new_master_key"
argument_list|)
condition|)
name|op
operator|=
name|OP_NEW_MASTER
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"convert_old_db"
argument_list|)
condition|)
name|op
operator|=
name|OP_CONVERT_OLD_DB
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"%s is an invalid operation."
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"Valid operations are \"load\", \"merge\", "
literal|"\"dump\", \"slave_dump\", \"new_master_key\", "
literal|"and \"convert_old_db\""
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|file_name
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|file_name
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
operator|&&
name|op
operator|!=
name|OP_LOAD
operator|&&
name|op
operator|!=
name|OP_MERGE
condition|)
name|file
operator|=
name|stdout
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|mode
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_LOAD
operator|||
name|op
operator|==
name|OP_MERGE
condition|)
name|mode
operator|=
literal|"r"
expr_stmt|;
else|else
name|mode
operator|=
literal|"w"
expr_stmt|;
name|file
operator|=
name|fopen
argument_list|(
name|file_name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"open %s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_DUMP
case|:
if|if
condition|(
operator|(
name|dump_db
argument_list|(
name|db_name
argument_list|,
name|file
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|Principal
operator|*
argument_list|)
operator|)
literal|0
argument_list|)
operator|==
name|EOF
operator|)
operator|||
operator|(
name|fflush
argument_list|(
name|file
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|fsync
argument_list|(
name|fileno
argument_list|(
name|file
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|fclose
argument_list|(
name|file
argument_list|)
operator|==
name|EOF
operator|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SLAVE_DUMP
case|:
if|if
condition|(
operator|(
name|dump_db
argument_list|(
name|db_name
argument_list|,
name|file
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|Principal
operator|*
argument_list|)
operator|)
literal|0
argument_list|)
operator|==
name|EOF
operator|)
operator|||
operator|(
name|fflush
argument_list|(
name|file
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|fsync
argument_list|(
name|fileno
argument_list|(
name|file
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|fclose
argument_list|(
name|file
argument_list|)
operator|==
name|EOF
operator|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|update_ok_file
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LOAD
case|:
name|load_db
argument_list|(
name|db_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MERGE
case|:
name|merge_db
argument_list|(
name|db_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NEW_MASTER
case|:
name|convert_new_master_key
argument_list|(
name|db_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Don't forget to do a `kdb_util load %s' to reload the database!\n"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CONVERT_OLD_DB
case|:
name|convert_old_format_db
argument_list|(
name|db_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Don't forget to do a `kdb_util load %s' to reload the database!\n"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

