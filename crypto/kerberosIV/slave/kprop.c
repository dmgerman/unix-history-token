begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright 1987, 1988 by the Student Information Processing Board 	of the Massachusetts Institute of Technology  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the names of M.I.T. and the M.I.T. S.I.P.B. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission. M.I.T. and the M.I.T. S.I.P.B. make no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_include
include|#
directive|include
file|"slav_locl.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: kprop.c,v 1.29 1997/05/25 02:43:54 joda Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"kprop.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|kprop_version
index|[
name|KPROP_PROT_VERSION_LEN
index|]
init|=
name|KPROP_PROT_VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|my_realm
index|[
name|REALM_SZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|princ_data_size
init|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|+
literal|3
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|transfer_mode
decl_stmt|,
name|net_transfer_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|force_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ok
index|[]
init|=
literal|".dump_ok"
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|slave_host
block|{
name|u_int32_t
name|net_addr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|instance
decl_stmt|;
name|char
modifier|*
name|realm
decl_stmt|;
name|int
name|not_time_yet
decl_stmt|;
name|int
name|succeeded
decl_stmt|;
name|struct
name|slave_host
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|get_slaves
parameter_list|(
name|struct
name|slave_host
modifier|*
modifier|*
name|psl
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|time_t
name|ok_mtime
parameter_list|)
block|{
name|FILE
modifier|*
name|fin
decl_stmt|;
name|char
name|namebuf
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|inst
decl_stmt|;
name|char
modifier|*
name|pc
decl_stmt|;
name|struct
name|hostent
modifier|*
name|host
decl_stmt|;
name|struct
name|slave_host
modifier|*
modifier|*
name|th
decl_stmt|;
name|char
name|path
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|ppath
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"open(%s)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ppath
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
name|ppath
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ppath
operator|=
name|path
expr_stmt|;
block|}
name|th
operator|=
name|psl
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|,
name|fin
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pc
operator|=
name|strchr
argument_list|(
name|namebuf
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
block|{
operator|*
name|pc
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strlen
argument_list|(
name|namebuf
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"Hostname too long (>= %d chars) in '%s'."
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|fgets
argument_list|(
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|,
name|fin
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
do|while
condition|(
name|strchr
argument_list|(
name|namebuf
argument_list|,
literal|'\n'
argument_list|)
operator|==
name|NULL
condition|)
do|;
continue|continue;
block|}
block|}
if|if
condition|(
name|namebuf
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|namebuf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
name|host
operator|=
name|gethostbyname
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Ignoring host '%s' in '%s': %s"
argument_list|,
name|namebuf
argument_list|,
name|file
argument_list|,
ifdef|#
directive|ifdef
name|HAVE_H_ERRNO
name|hstrerror
argument_list|(
name|h_errno
argument_list|)
else|#
directive|else
literal|"unknown error"
endif|#
directive|endif
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
operator|*
name|th
operator|)
operator|=
operator|(
expr|struct
name|slave_host
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|slave_host
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|th
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"No memory reading host list from '%s'."
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|th
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|slave_host
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|th
operator|)
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|th
operator|)
operator|->
name|name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"No memory reading host list from '%s'."
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* get kerberos cannonical instance name */
name|inst
operator|=
name|krb_get_phost
argument_list|(
operator|(
operator|*
name|th
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|th
operator|)
operator|->
name|instance
operator|=
name|strdup
argument_list|(
name|inst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|th
operator|)
operator|->
name|instance
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"No memory reading host list from '%s'."
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* what a concept, slave servers in different realms! */
operator|(
operator|*
name|th
operator|)
operator|->
name|realm
operator|=
name|my_realm
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|*
name|th
operator|)
operator|->
name|net_addr
argument_list|,
name|host
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|*
name|th
operator|)
operator|->
name|net_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|th
operator|)
operator|->
name|not_time_yet
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|th
operator|)
operator|->
name|succeeded
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|th
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|strcat
argument_list|(
name|strcpy
argument_list|(
name|ppath
argument_list|,
operator|(
operator|*
name|th
operator|)
operator|->
name|name
argument_list|)
argument_list|,
literal|"-last-prop"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force_flag
operator|&&
operator|!
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|&&
name|stbuf
operator|.
name|st_mtime
operator|>
name|ok_mtime
condition|)
block|{
operator|(
operator|*
name|th
operator|)
operator|->
name|not_time_yet
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|th
operator|)
operator|->
name|succeeded
operator|=
literal|1
expr_stmt|;
comment|/* no change since last success */
block|}
name|th
operator|=
operator|&
operator|(
operator|*
name|th
operator|)
operator|->
name|next
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The master -> slave protocol looks like this:      1) 8 byte version string      2) 2 bytes of "transfer mode" (net byte order of course)      3) ticket/authentication send by sendauth      4) 4 bytes of "block" length (u_int32_t)      5) data       4 and 5 repeat til EOF ... */
end_comment

begin_function
specifier|static
name|int
name|prop_to_slaves
parameter_list|(
name|struct
name|slave_host
modifier|*
name|sl
parameter_list|,
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|fslv
parameter_list|)
block|{
name|u_char
name|buf
index|[
name|KPROP_BUFSIZ
index|]
decl_stmt|;
name|u_char
name|obuf
index|[
name|KPROP_BUFSIZ
operator|+
literal|64
index|]
decl_stmt|;
comment|/* leave room for private msg overhead */
name|struct
name|sockaddr_in
name|sin
decl_stmt|,
name|my_sin
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|slave_host
modifier|*
name|cs
decl_stmt|;
comment|/* current slave */
name|char
name|path
index|[
literal|256
index|]
decl_stmt|,
name|my_host_name
index|[
name|MaxHostNameLen
index|]
decl_stmt|,
modifier|*
name|p_my_host_name
decl_stmt|;
name|char
name|kprop_service_instance
index|[
name|INST_SZ
index|]
decl_stmt|;
name|char
modifier|*
name|pc
decl_stmt|;
name|u_int32_t
name|cksum
decl_stmt|;
name|u_int32_t
name|length
decl_stmt|,
name|nlength
decl_stmt|;
name|long
name|kerror
decl_stmt|;
name|KTEXT_ST
name|ticket
decl_stmt|;
name|CREDENTIALS
name|cred
decl_stmt|;
name|MSG_DAT
name|msg_dat
decl_stmt|;
specifier|static
name|char
name|tkstring
index|[]
init|=
literal|"/tmp/kproptktXXXXXX"
decl_stmt|;
name|des_key_schedule
name|session_sched
decl_stmt|;
name|close
argument_list|(
name|mkstemp
argument_list|(
name|tkstring
argument_list|)
argument_list|)
expr_stmt|;
name|krb_set_tkt_string
argument_list|(
name|tkstring
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|k_getportbyname
argument_list|(
literal|"krb_prop"
argument_list|,
literal|"tcp"
argument_list|,
name|htons
argument_list|(
name|KPROP_PORT
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
name|fslv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pc
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
name|pc
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pc
operator|=
name|path
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
comment|/* try each slave five times max */
for|for
control|(
name|cs
operator|=
name|sl
init|;
name|cs
condition|;
name|cs
operator|=
name|cs
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|cs
operator|->
name|succeeded
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
operator|&
name|cs
operator|->
name|net_addr
argument_list|,
sizeof|sizeof
name|cs
operator|->
name|net_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"connect(%s)"
argument_list|,
name|cs
operator|->
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
comment|/*** NEXT SLAVE ***/
block|}
comment|/* for krb_mk_{priv, safe} */
name|memset
argument_list|(
operator|&
name|my_sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|my_sin
argument_list|)
expr_stmt|;
name|n
operator|=
sizeof|sizeof
name|my_sin
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|my_sin
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"getsockname(%s)"
argument_list|,
name|cs
operator|->
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
comment|/*** NEXT SLAVE ***/
block|}
if|if
condition|(
name|n
operator|!=
sizeof|sizeof
argument_list|(
name|my_sin
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"can't get socketname %s length"
argument_list|,
name|cs
operator|->
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
comment|/*** NEXT SLAVE ***/
block|}
comment|/* Get ticket */
name|kerror
operator|=
name|krb_mk_req
argument_list|(
operator|&
name|ticket
argument_list|,
name|KPROP_SERVICE_NAME
argument_list|,
name|cs
operator|->
name|instance
argument_list|,
name|cs
operator|->
name|realm
argument_list|,
operator|(
name|u_int32_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* if ticket has expired try to get a new one, but 		 * first get a TGT ... 		 */
if|if
condition|(
name|kerror
operator|!=
name|MK_AP_OK
condition|)
block|{
if|if
condition|(
name|k_gethostname
argument_list|(
name|my_host_name
argument_list|,
sizeof|sizeof
argument_list|(
name|my_host_name
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"gethostname(%s): %s"
argument_list|,
name|my_host_name
argument_list|,
ifdef|#
directive|ifdef
name|HAVE_H_ERRNO
name|hstrerror
argument_list|(
name|h_errno
argument_list|)
else|#
directive|else
literal|"unknown error"
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
comment|/* next one can't work either! */
block|}
comment|/* get canonical kerberos service instance name */
name|p_my_host_name
operator|=
name|krb_get_phost
argument_list|(
name|my_host_name
argument_list|)
expr_stmt|;
comment|/* copy it to make sure gethostbyname static doesn't 		     * screw us. */
name|strcpy
argument_list|(
name|kprop_service_instance
argument_list|,
name|p_my_host_name
argument_list|)
expr_stmt|;
name|kerror
operator|=
name|krb_get_svc_in_tkt
argument_list|(
name|KPROP_SERVICE_NAME
argument_list|,
if|#
directive|if
literal|0
argument_list|kprop_service_instance,
else|#
directive|else
name|KRB_MASTER
argument_list|,
endif|#
directive|endif
name|my_realm
argument_list|,
name|KRB_TICKET_GRANTING_TICKET
argument_list|,
name|my_realm
argument_list|,
literal|96
argument_list|,
name|KPROP_SRVTAB
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerror
operator|!=
name|INTK_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s.  While getting initial ticket\n"
argument_list|,
name|cs
operator|->
name|name
argument_list|,
name|krb_get_err_text
argument_list|(
name|kerror
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|punt
goto|;
block|}
name|kerror
operator|=
name|krb_mk_req
argument_list|(
operator|&
name|ticket
argument_list|,
name|KPROP_SERVICE_NAME
argument_list|,
name|cs
operator|->
name|instance
argument_list|,
name|cs
operator|->
name|realm
argument_list|,
operator|(
name|u_int32_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kerror
operator|!=
name|MK_AP_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: krb_mk_req: %s"
argument_list|,
name|cs
operator|->
name|name
argument_list|,
name|krb_get_err_text
argument_list|(
name|kerror
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
comment|/*** NEXT SLAVE ***/
block|}
if|if
condition|(
name|write
argument_list|(
name|s
argument_list|,
name|kprop_version
argument_list|,
sizeof|sizeof
argument_list|(
name|kprop_version
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|kprop_version
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|cs
operator|->
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
comment|/*** NEXT SLAVE ***/
block|}
name|net_transfer_mode
operator|=
name|htons
argument_list|(
name|transfer_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|s
argument_list|,
operator|&
name|net_transfer_mode
argument_list|,
sizeof|sizeof
argument_list|(
name|net_transfer_mode
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|net_transfer_mode
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"write(%s)"
argument_list|,
name|cs
operator|->
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
comment|/*** NEXT SLAVE ***/
block|}
name|kerror
operator|=
name|krb_get_cred
argument_list|(
name|KPROP_SERVICE_NAME
argument_list|,
name|cs
operator|->
name|instance
argument_list|,
name|cs
operator|->
name|realm
argument_list|,
operator|&
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerror
operator|!=
name|KSUCCESS
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s.  Getting session key."
argument_list|,
name|cs
operator|->
name|name
argument_list|,
name|krb_get_err_text
argument_list|(
name|kerror
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
comment|/*** NEXT SLAVE ***/
block|}
ifdef|#
directive|ifdef
name|NOENCRYPTION
name|memset
argument_list|(
name|session_sched
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|session_sched
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|des_key_sched
argument_list|(
operator|&
name|cred
operator|.
name|session
argument_list|,
name|session_sched
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: can't make key schedule."
argument_list|,
name|cs
operator|->
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
comment|/*** NEXT SLAVE ***/
block|}
endif|#
directive|endif
comment|/* SAFE (quad_cksum) and CLEAR are just not good enough */
name|cksum
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|not_working_yet
if|if
condition|(
name|transfer_mode
operator|!=
name|KPROP_TRANSFER_PRIVATE
condition|)
block|{
name|cksum
operator|=
name|get_data_checksum
argument_list|(
name|fd
argument_list|,
name|session_sched
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|cksum
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
block|}
name|kerror
operator|=
name|krb_sendauth
argument_list|(
name|KOPT_DO_MUTUAL
argument_list|,
name|s
argument_list|,
operator|&
name|ticket
argument_list|,
name|KPROP_SERVICE_NAME
argument_list|,
name|cs
operator|->
name|instance
argument_list|,
name|cs
operator|->
name|realm
argument_list|,
name|cksum
argument_list|,
operator|&
name|msg_dat
argument_list|,
operator|&
name|cred
argument_list|,
name|session_sched
argument_list|,
operator|&
name|my_sin
argument_list|,
operator|&
name|sin
argument_list|,
name|KPROP_PROT_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerror
operator|!=
name|KSUCCESS
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: krb_sendauth: %s."
argument_list|,
name|cs
operator|->
name|name
argument_list|,
name|krb_get_err_text
argument_list|(
name|kerror
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
comment|/*** NEXT SLAVE ***/
block|}
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* Rewind file before rereading it. */
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"read"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|transfer_mode
condition|)
block|{
case|case
name|KPROP_TRANSFER_PRIVATE
case|:
case|case
name|KPROP_TRANSFER_SAFE
case|:
if|if
condition|(
name|transfer_mode
operator|==
name|KPROP_TRANSFER_PRIVATE
condition|)
name|length
operator|=
name|krb_mk_priv
argument_list|(
name|buf
argument_list|,
name|obuf
argument_list|,
name|n
argument_list|,
name|session_sched
argument_list|,
operator|&
name|cred
operator|.
name|session
argument_list|,
operator|&
name|my_sin
argument_list|,
operator|&
name|sin
argument_list|)
expr_stmt|;
else|else
name|length
operator|=
name|krb_mk_safe
argument_list|(
name|buf
argument_list|,
name|obuf
argument_list|,
name|n
argument_list|,
operator|&
name|cred
operator|.
name|session
argument_list|,
operator|&
name|my_sin
argument_list|,
operator|&
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s failed."
argument_list|,
name|cs
operator|->
name|name
argument_list|,
operator|(
name|transfer_mode
operator|==
name|KPROP_TRANSFER_PRIVATE
operator|)
condition|?
literal|"krb_rd_priv"
else|:
literal|"krb_rd_safe"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
comment|/*** NEXT SLAVE ***/
block|}
name|nlength
operator|=
name|htonl
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|s
argument_list|,
operator|&
name|nlength
argument_list|,
sizeof|sizeof
name|nlength
argument_list|)
operator|!=
sizeof|sizeof
name|nlength
condition|)
block|{
name|warn
argument_list|(
literal|"write(%s)"
argument_list|,
name|cs
operator|->
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
comment|/*** NEXT SLAVE ***/
block|}
if|if
condition|(
name|write
argument_list|(
name|s
argument_list|,
name|obuf
argument_list|,
name|length
argument_list|)
operator|!=
name|length
condition|)
block|{
name|warn
argument_list|(
literal|"write(%s)"
argument_list|,
name|cs
operator|->
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
comment|/*** NEXT SLAVE ***/
block|}
break|break;
case|case
name|KPROP_TRANSFER_CLEAR
case|:
if|if
condition|(
name|write
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|warn
argument_list|(
literal|"write(%s)"
argument_list|,
name|cs
operator|->
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
comment|/*** NEXT SLAVE ***/
block|}
break|break;
block|}
block|}
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cs
operator|->
name|succeeded
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: success.\n"
argument_list|,
name|cs
operator|->
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|strcpy
argument_list|(
name|pc
argument_list|,
name|cs
operator|->
name|name
argument_list|)
argument_list|,
literal|"-last-prop"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|creat
argument_list|(
name|path
argument_list|,
literal|0600
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|punt
label|:
name|dest_tkt
argument_list|()
expr_stmt|;
for|for
control|(
name|cs
operator|=
name|sl
init|;
name|cs
condition|;
name|cs
operator|=
name|cs
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|cs
operator|->
name|succeeded
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* didn't get this slave */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
comment|/* already got floc and fslv, what is this? */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nUsage: kprop [-force] [-realm realm] [-private"
ifdef|#
directive|ifdef
name|not_safe_yet
literal|"|-safe|-clear"
endif|#
directive|endif
literal|"] [data_file [slaves_file]]\n\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|floc
decl_stmt|,
modifier|*
name|floc_ok
decl_stmt|;
name|char
modifier|*
name|fslv
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|,
name|stbuf_ok
decl_stmt|;
name|time_t
name|l_init
decl_stmt|,
name|l_final
decl_stmt|;
name|char
modifier|*
name|pc
decl_stmt|;
name|int
name|l_diff
decl_stmt|;
specifier|static
name|struct
name|slave_host
modifier|*
name|slave_host_list
init|=
name|NULL
decl_stmt|;
name|struct
name|slave_host
modifier|*
name|sh
decl_stmt|;
name|set_progname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|transfer_mode
operator|=
name|KPROP_TRANSFER_PRIVATE
expr_stmt|;
name|time
argument_list|(
operator|&
name|l_init
argument_list|)
expr_stmt|;
name|pc
operator|=
name|ctime
argument_list|(
operator|&
name|l_init
argument_list|)
expr_stmt|;
name|pc
index|[
name|strlen
argument_list|(
name|pc
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"\nStart slave propagation: %s\n"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|floc
operator|=
name|NULL
expr_stmt|;
name|fslv
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|krb_get_lrealm
argument_list|(
name|my_realm
argument_list|,
literal|1
argument_list|)
operator|!=
name|KSUCCESS
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Getting my kerberos realm.  Check krb.conf"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'-'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-private"
argument_list|)
operator|==
literal|0
condition|)
name|transfer_mode
operator|=
name|KPROP_TRANSFER_PRIVATE
expr_stmt|;
ifdef|#
directive|ifdef
name|not_safe_yet
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-safe"
argument_list|)
operator|==
literal|0
condition|)
name|transfer_mode
operator|=
name|KPROP_TRANSFER_SAFE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-clear"
argument_list|)
operator|==
literal|0
condition|)
name|transfer_mode
operator|=
name|KPROP_TRANSFER_CLEAR
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-realm"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|argc
condition|)
name|strcpy
argument_list|(
name|my_realm
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|usage
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-force"
argument_list|)
operator|==
literal|0
condition|)
name|force_flag
operator|++
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"unknown control argument %s."
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
comment|/* positional arguments are marginal at best ... */
if|if
condition|(
name|floc
operator|==
name|NULL
condition|)
name|floc
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fslv
operator|==
name|NULL
condition|)
name|fslv
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
else|else
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|floc
operator|==
name|NULL
condition|)
name|floc
operator|=
name|DB_DIR
literal|"/slave_dump"
expr_stmt|;
if|if
condition|(
name|fslv
operator|==
name|NULL
condition|)
name|fslv
operator|=
name|DB_DIR
literal|"/slaves"
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|floc_ok
argument_list|,
literal|"%s%s"
argument_list|,
name|floc
argument_list|,
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|floc_ok
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory in copying %s"
argument_list|,
name|floc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|floc
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"open(%s)"
argument_list|,
name|floc
argument_list|)
expr_stmt|;
if|if
condition|(
name|k_flock
argument_list|(
name|fd
argument_list|,
name|K_LOCK_SH
operator||
name|K_LOCK_NB
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"flock(%s)"
argument_list|,
name|floc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|floc
argument_list|,
operator|&
name|stbuf
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"stat(%s)"
argument_list|,
name|floc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|floc_ok
argument_list|,
operator|&
name|stbuf_ok
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"stat(%s)"
argument_list|,
name|floc_ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|stbuf
operator|.
name|st_mtime
operator|>
name|stbuf_ok
operator|.
name|st_mtime
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"'%s' more recent than '%s'."
argument_list|,
name|floc
argument_list|,
name|floc_ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_slaves
argument_list|(
operator|&
name|slave_host_list
argument_list|,
name|fslv
argument_list|,
name|stbuf_ok
operator|.
name|st_mtime
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"can't read slave host file '%s'."
argument_list|,
name|fslv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KPROP_DBG
block|{
name|struct
name|slave_host
modifier|*
name|sh
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|sh
operator|=
name|slave_host_list
init|;
name|sh
condition|;
name|sh
operator|=
name|sh
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"slave %d: %s, %s"
argument_list|,
name|i
operator|++
argument_list|,
name|sh
operator|->
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|sh
operator|->
name|net_addr
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* KPROP_DBG */
if|if
condition|(
operator|!
name|prop_to_slaves
argument_list|(
name|slave_host_list
argument_list|,
name|fd
argument_list|,
name|fslv
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"propagation failed."
argument_list|)
expr_stmt|;
if|if
condition|(
name|k_flock
argument_list|(
name|fd
argument_list|,
name|K_LOCK_UN
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"flock(%s, LOCK_UN)"
argument_list|,
name|floc
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|sh
operator|=
name|slave_host_list
init|;
name|sh
condition|;
name|sh
operator|=
name|sh
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:\t\t%s\n"
argument_list|,
name|sh
operator|->
name|name
argument_list|,
operator|(
name|sh
operator|->
name|not_time_yet
condition|?
literal|"Not time yet"
else|:
operator|(
name|sh
operator|->
name|succeeded
condition|?
literal|"Succeeded"
else|:
literal|"FAILED"
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|time
argument_list|(
operator|&
name|l_final
argument_list|)
expr_stmt|;
name|l_diff
operator|=
name|l_final
operator|-
name|l_init
expr_stmt|;
name|printf
argument_list|(
literal|"propagation finished, %d:%02d:%02d elapsed\n"
argument_list|,
name|l_diff
operator|/
literal|3600
argument_list|,
operator|(
name|l_diff
operator|%
literal|3600
operator|)
operator|/
literal|60
argument_list|,
name|l_diff
operator|%
literal|60
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|doesnt_work_yet
end_ifdef

begin_function
name|u_long
name|get_data_checksum
parameter_list|(
name|fd
parameter_list|,
name|key_sched
parameter_list|)
name|int
name|fd
decl_stmt|;
name|des_key_schedule
name|key_sched
decl_stmt|;
block|{
name|u_int32_t
name|cksum
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|u_int32_t
name|obuf
index|[
literal|2
index|]
decl_stmt|;
while|while
condition|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"read"
argument_list|)
expr_stmt|;
name|cksum
operator|=
name|cbc_cksum
argument_list|(
name|buf
argument_list|,
name|obuf
argument_list|,
name|n
argument_list|,
name|key_sched
argument_list|,
name|key_sched
argument_list|)
expr_stmt|;
block|}
return|return
name|cksum
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

