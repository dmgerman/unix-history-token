begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    Copyright (C) 1989 by the Massachusetts Institute of Technology     Export of this software from the United States of America is assumed    to require a specific license from the United States Government.    It is the responsibility of any person or organization contemplating    export to obtain such a license before exporting.  WITHIN THAT CONSTRAINT, permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.    */
end_comment

begin_include
include|#
directive|include
file|"krb_locl.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: tf_util.c,v 1.39.2.2 2000/06/23 04:03:58 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|TOO_BIG
value|-1
end_define

begin_define
define|#
directive|define
name|TF_LCK_RETRY
value|((unsigned)2)
end_define

begin_comment
comment|/* seconds to sleep before 					 * retry if ticket file is 					 * locked */
end_comment

begin_define
define|#
directive|define
name|TF_LCK_RETRY_COUNT
value|(50)
end_define

begin_comment
comment|/* number of retries	*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAGIC_TICKET_NAME
value|"magic"
end_define

begin_define
define|#
directive|define
name|MAGIC_TICKET_TIME_DIFF_INST
value|"time-diff"
end_define

begin_define
define|#
directive|define
name|MAGIC_TICKET_ADDR_INST
value|"our-address"
end_define

begin_comment
comment|/*  * fd must be initialized to something that won't ever occur as a real  * file descriptor. Since open(2) returns only non-negative numbers as  * valid file descriptors, and tf_init always stuffs the return value  * from open in here even if it is an error flag, we must  * 	a. Initialize fd to a negative number, to indicate that it is  * 	   not initially valid.  *	b. When checking for a valid fd, assume that negative values  *	   are invalid (ie. when deciding whether tf_init has been  *	   called.)  *	c. In tf_close, be sure it gets reinitialized to a negative  *	   number.   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|curpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Position in tfbfr */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lastpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* End of tfbfr */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tfbfr
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for ticket data */
end_comment

begin_function_decl
specifier|static
name|int
name|tf_gets
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tf_read
parameter_list|(
name|void
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This file contains routines for manipulating the ticket cache file.  *  * The ticket file is in the following format:  *  *      principal's name        (null-terminated string)  *      principal's instance    (null-terminated string)  *      CREDENTIAL_1  *      CREDENTIAL_2  *      ...  *      CREDENTIAL_n  *      EOF  *  *      Where "CREDENTIAL_x" consists of the following fixed-length  *      fields from the CREDENTIALS structure (see "krb.h"):  *  *              char            service[ANAME_SZ]  *              char            instance[INST_SZ]  *              char            realm[REALM_SZ]  *              C_Block         session  *              int             lifetime  *              int             kvno  *              KTEXT_ST        ticket_st  *              u_int32_t            issue_date  *  * Short description of routines:  *  * tf_init() opens the ticket file and locks it.  *  * tf_get_pname() returns the principal's name.  *  * tf_put_pname() writes the principal's name to the ticket file.  *  * tf_get_pinst() returns the principal's instance (may be null).  *  * tf_put_pinst() writes the instance.  *  * tf_get_cred() returns the next CREDENTIALS record.  *  * tf_save_cred() appends a new CREDENTIAL record to the ticket file.  *  * tf_close() closes the ticket file and releases the lock.  *  * tf_gets() returns the next null-terminated string.  It's an internal  * routine used by tf_get_pname(), tf_get_pinst(), and tf_get_cred().  *  * tf_read() reads a given number of bytes.  It's an internal routine  * used by tf_get_cred().  */
end_comment

begin_comment
comment|/*  * tf_init() should be called before the other ticket file routines.  * It takes the name of the ticket file to use, "tf_name", and a  * read/write flag "rw" as arguments.   *  * It tries to open the ticket file, checks the mode, and if everything  * is okay, locks the file.  If it's opened for reading, the lock is  * shared.  If it's opened for writing, the lock is exclusive.   *  * Returns KSUCCESS if all went well, otherwise one of the following:   *  * NO_TKT_FIL   - file wasn't there  * TKT_FIL_ACC  - file was in wrong mode, etc.  * TKT_FIL_LCK  - couldn't lock the file, even after a retry  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_NO_LOCKING
end_ifdef

begin_undef
undef|#
directive|undef
name|flock
end_undef

begin_define
define|#
directive|define
name|flock
parameter_list|(
name|F
parameter_list|,
name|M
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|tf_init
parameter_list|(
name|char
modifier|*
name|tf_name
parameter_list|,
name|int
name|rw
parameter_list|)
block|{
comment|/* Unix implementation */
name|int
name|wflag
decl_stmt|;
name|struct
name|stat
name|stat_buf
decl_stmt|;
name|int
name|i_retry
decl_stmt|;
switch|switch
condition|(
name|rw
condition|)
block|{
case|case
name|R_TKT_FIL
case|:
name|wflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|W_TKT_FIL
case|:
name|wflag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_init: illegal parameter\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_ACC
return|;
block|}
if|if
condition|(
name|lstat
argument_list|(
name|tf_name
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
return|return
name|NO_TKT_FIL
return|;
default|default:
return|return
name|TKT_FIL_ACC
return|;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|TKT_FIL_ACC
return|;
comment|/* The code tries to guess when the calling program is running    * set-uid and prevent unauthorized access.    *    * All library functions now assume that the right set of userids    * are set upon entry, therefore it's not strictly necessary to    * perform these test for programs adhering to these assumptions.    *    * This doesn't work on cygwin because getuid() returns a different    * uid than the owner of files that are created.    */
ifndef|#
directive|ifndef
name|__CYGWIN__
block|{
name|uid_t
name|me
init|=
name|getuid
argument_list|()
decl_stmt|;
if|if
condition|(
name|stat_buf
operator|.
name|st_uid
operator|!=
name|me
operator|&&
name|me
operator|!=
literal|0
condition|)
return|return
name|TKT_FIL_ACC
return|;
block|}
endif|#
directive|endif
comment|/*    * If "wflag" is set, open the ticket file in append-writeonly mode    * and lock the ticket file in exclusive mode.  If unable to lock    * the file, sleep and try again.  If we fail again, return with the    * proper error message.     */
name|curpos
operator|=
sizeof|sizeof
argument_list|(
name|tfbfr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wflag
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|tf_name
argument_list|,
name|O_RDWR
operator||
name|O_BINARY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
return|return
name|TKT_FIL_ACC
return|;
block|}
for|for
control|(
name|i_retry
operator|=
literal|0
init|;
name|i_retry
operator|<
name|TF_LCK_RETRY_COUNT
condition|;
name|i_retry
operator|++
control|)
block|{
if|if
condition|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_init: retry %d of write lock of `%s'.\n"
argument_list|,
name|i_retry
argument_list|,
name|tf_name
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|TF_LCK_RETRY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|KSUCCESS
return|;
comment|/* all done */
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|TKT_FIL_LCK
return|;
block|}
comment|/*    * Otherwise "wflag" is not set and the ticket file should be opened    * for read-only operations and locked for shared access.     */
name|fd
operator|=
name|open
argument_list|(
name|tf_name
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
return|return
name|TKT_FIL_ACC
return|;
block|}
for|for
control|(
name|i_retry
operator|=
literal|0
init|;
name|i_retry
operator|<
name|TF_LCK_RETRY_COUNT
condition|;
name|i_retry
operator|++
control|)
block|{
if|if
condition|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_SH
operator||
name|LOCK_NB
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_init: retry %d of read lock of `%s'.\n"
argument_list|,
name|i_retry
argument_list|,
name|tf_name
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|TF_LCK_RETRY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|KSUCCESS
return|;
comment|/* all done */
block|}
block|}
comment|/* failure */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|TKT_FIL_LCK
return|;
block|}
end_function

begin_comment
comment|/*  * tf_create() should be called when creating a new ticket file.  * The only argument is the name of the ticket file.  * After calling this, it should be possible to use other tf_* functions.  *  * New algoritm for creating ticket file:  * 1. try to erase contents of existing file.  * 2. try to remove old file.  * 3. try to open with O_CREAT and O_EXCL  * 4. if this fails, someone has created a file in between 1 and 2 and  *    we should fail.  Otherwise, all is wonderful.  */
end_comment

begin_function
name|int
name|tf_create
parameter_list|(
name|char
modifier|*
name|tf_name
parameter_list|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|tf_name
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
return|return
name|TKT_FIL_ACC
return|;
name|fd
operator|=
name|open
argument_list|(
name|tf_name
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_EXCL
operator||
name|O_BINARY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
name|TKT_FIL_ACC
return|;
if|if
condition|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sleep
argument_list|(
name|TF_LCK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|TKT_FIL_LCK
return|;
block|}
block|}
return|return
name|KSUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * tf_get_pname() reads the principal's name from the ticket file. It  * should only be called after tf_init() has been called.  The  * principal's name is filled into the "p" parameter.  If all goes well,  * KSUCCESS is returned.  If tf_init() wasn't called, TKT_FIL_INI is  * returned.  If the name was null, or EOF was encountered, or the name  * was longer than ANAME_SZ, TKT_FIL_FMT is returned.   */
end_comment

begin_function
name|int
name|tf_get_pname
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_get_pname called before tf_init.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_INI
return|;
block|}
if|if
condition|(
name|tf_gets
argument_list|(
name|p
argument_list|,
name|ANAME_SZ
argument_list|)
operator|<
literal|2
condition|)
comment|/* can't be just a null */
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_get_pname: pname< 2.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_FMT
return|;
block|}
return|return
name|KSUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * tf_put_pname() sets the principal's name in the ticket file. Call  * after tf_create().  */
end_comment

begin_function
name|int
name|tf_put_pname
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|count
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_put_pname called before tf_create.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_INI
return|;
block|}
name|count
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
return|return
operator|(
name|KFAILURE
operator|)
return|;
return|return
name|KSUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * tf_get_pinst() reads the principal's instance from a ticket file.  * It should only be called after tf_init() and tf_get_pname() have been  * called.  The instance is filled into the "inst" parameter.  If all  * goes well, KSUCCESS is returned.  If tf_init() wasn't called,  * TKT_FIL_INI is returned.  If EOF was encountered, or the instance  * was longer than ANAME_SZ, TKT_FIL_FMT is returned.  Note that the  * instance may be null.   */
end_comment

begin_function
name|int
name|tf_get_pinst
parameter_list|(
name|char
modifier|*
name|inst
parameter_list|)
block|{
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_get_pinst called before tf_init.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_INI
return|;
block|}
if|if
condition|(
name|tf_gets
argument_list|(
name|inst
argument_list|,
name|INST_SZ
argument_list|)
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_get_pinst: inst_sz< 1.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_FMT
return|;
block|}
return|return
name|KSUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * tf_put_pinst writes the principal's instance to the ticket file.  * Call after tf_create.  */
end_comment

begin_function
name|int
name|tf_put_pinst
parameter_list|(
specifier|const
name|char
modifier|*
name|inst
parameter_list|)
block|{
name|unsigned
name|count
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_put_pinst called before tf_create.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_INI
return|;
block|}
name|count
operator|=
name|strlen
argument_list|(
name|inst
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|inst
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
return|return
operator|(
name|KFAILURE
operator|)
return|;
return|return
name|KSUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * tf_get_cred() reads a CREDENTIALS record from a ticket file and fills  * in the given structure "c".  It should only be called after tf_init(),  * tf_get_pname(), and tf_get_pinst() have been called. If all goes well,  * KSUCCESS is returned.  Possible error codes are:   *  * TKT_FIL_INI  - tf_init wasn't called first  * TKT_FIL_FMT  - bad format  * EOF          - end of file encountered  */
end_comment

begin_function
specifier|static
name|int
name|real_tf_get_cred
parameter_list|(
name|CREDENTIALS
modifier|*
name|c
parameter_list|)
block|{
name|KTEXT
name|ticket
init|=
operator|&
name|c
operator|->
name|ticket_st
decl_stmt|;
comment|/* pointer to ticket */
name|int
name|k_errno
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_get_cred called before tf_init.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_INI
return|;
block|}
if|if
condition|(
operator|(
name|k_errno
operator|=
name|tf_gets
argument_list|(
name|c
operator|->
name|service
argument_list|,
name|SNAME_SZ
argument_list|)
operator|)
operator|<
literal|2
condition|)
switch|switch
condition|(
name|k_errno
condition|)
block|{
case|case
name|TOO_BIG
case|:
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_get_cred: too big service cred.\n"
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
comment|/* can't be just a null */
name|tf_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_get_cred: null service cred.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_FMT
return|;
case|case
literal|0
case|:
return|return
name|EOF
return|;
block|}
if|if
condition|(
operator|(
name|k_errno
operator|=
name|tf_gets
argument_list|(
name|c
operator|->
name|instance
argument_list|,
name|INST_SZ
argument_list|)
operator|)
operator|<
literal|1
condition|)
switch|switch
condition|(
name|k_errno
condition|)
block|{
case|case
name|TOO_BIG
case|:
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_get_cred: too big instance cred.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_FMT
return|;
case|case
literal|0
case|:
return|return
name|EOF
return|;
block|}
if|if
condition|(
operator|(
name|k_errno
operator|=
name|tf_gets
argument_list|(
name|c
operator|->
name|realm
argument_list|,
name|REALM_SZ
argument_list|)
operator|)
operator|<
literal|2
condition|)
switch|switch
condition|(
name|k_errno
condition|)
block|{
case|case
name|TOO_BIG
case|:
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_get_cred: too big realm cred.\n"
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
comment|/* can't be just a null */
name|tf_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_get_cred: null realm cred.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_FMT
return|;
case|case
literal|0
case|:
return|return
name|EOF
return|;
block|}
if|if
condition|(
name|tf_read
argument_list|(
operator|(
name|c
operator|->
name|session
operator|)
argument_list|,
name|DES_KEY_SZ
argument_list|)
operator|<
literal|1
operator|||
name|tf_read
argument_list|(
operator|&
operator|(
name|c
operator|->
name|lifetime
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|lifetime
argument_list|)
argument_list|)
operator|<
literal|1
operator|||
name|tf_read
argument_list|(
operator|&
operator|(
name|c
operator|->
name|kvno
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|kvno
argument_list|)
argument_list|)
operator|<
literal|1
operator|||
name|tf_read
argument_list|(
operator|&
operator|(
name|ticket
operator|->
name|length
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ticket
operator|->
name|length
argument_list|)
argument_list|)
operator|<
literal|1
operator|||
comment|/* don't try to read a silly amount into ticket->dat */
name|ticket
operator|->
name|length
operator|>
name|MAX_KTXT_LEN
operator|||
name|tf_read
argument_list|(
operator|(
name|ticket
operator|->
name|dat
operator|)
argument_list|,
name|ticket
operator|->
name|length
argument_list|)
operator|<
literal|1
operator|||
name|tf_read
argument_list|(
operator|&
operator|(
name|c
operator|->
name|issue_date
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|issue_date
argument_list|)
argument_list|)
operator|<
literal|1
condition|)
block|{
name|tf_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_get_cred: failed tf_read.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_FMT
return|;
block|}
return|return
name|KSUCCESS
return|;
block|}
end_function

begin_function
name|int
name|tf_get_cred
parameter_list|(
name|CREDENTIALS
modifier|*
name|c
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|fake
decl_stmt|;
do|do
block|{
name|fake
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|real_tf_get_cred
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|c
operator|->
name|service
argument_list|,
name|MAGIC_TICKET_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|c
operator|->
name|instance
argument_list|,
name|MAGIC_TICKET_TIME_DIFF_INST
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* we found the magic `time diff' ticket; update the kdc time          differential, and then get the next ticket */
name|u_int32_t
name|d
decl_stmt|;
name|krb_get_int
argument_list|(
name|c
operator|->
name|ticket_st
operator|.
name|dat
argument_list|,
operator|&
name|d
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|krb_set_kdc_time_diff
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|fake
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|c
operator|->
name|instance
argument_list|,
name|MAGIC_TICKET_ADDR_INST
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fake
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|fake
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|tf_get_cred_addr
parameter_list|(
name|char
modifier|*
name|realm
parameter_list|,
name|size_t
name|realm_sz
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|fake
decl_stmt|;
name|CREDENTIALS
name|cred
decl_stmt|;
do|do
block|{
name|fake
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|real_tf_get_cred
argument_list|(
operator|&
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|cred
operator|.
name|service
argument_list|,
name|MAGIC_TICKET_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cred
operator|.
name|instance
argument_list|,
name|MAGIC_TICKET_TIME_DIFF_INST
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* we found the magic `time diff' ticket; update the kdc time          differential, and then get the next ticket */
name|u_int32_t
name|d
decl_stmt|;
name|krb_get_int
argument_list|(
name|cred
operator|.
name|ticket_st
operator|.
name|dat
argument_list|,
operator|&
name|d
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|krb_set_kdc_time_diff
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cred
operator|.
name|instance
argument_list|,
name|MAGIC_TICKET_ADDR_INST
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strlcpy
argument_list|(
name|realm
argument_list|,
name|cred
operator|.
name|realm
argument_list|,
name|realm_sz
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|addr
argument_list|,
name|cred
operator|.
name|ticket_st
operator|.
name|dat
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|fake
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|fake
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * tf_close() closes the ticket file and sets "fd" to -1. If "fd" is  * not a valid file descriptor, it just returns.  It also clears the  * buffer used to read tickets.  *  * The return value is not defined.  */
end_comment

begin_function
name|void
name|tf_close
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|fd
operator|<
literal|0
operator|)
condition|)
block|{
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_UN
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* see declaration of fd above */
block|}
name|memset
argument_list|(
name|tfbfr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tfbfr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * tf_gets() is an internal routine.  It takes a string "s" and a count  * "n", and reads from the file until either it has read "n" characters,  * or until it reads a null byte. When finished, what has been read exists  * in "s". If it encounters EOF or an error, it closes the ticket file.   *  * Possible return values are:  *  * n            the number of bytes read (including null terminator)  *              when all goes well  *  * 0            end of file or read error  *  * TOO_BIG      if "count" characters are read and no null is  *		encountered. This is an indication that the ticket  *		file is seriously ill.  */
end_comment

begin_function
specifier|static
name|int
name|tf_gets
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_gets called before tf_init.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_INI
return|;
block|}
for|for
control|(
name|count
operator|=
name|n
operator|-
literal|1
init|;
name|count
operator|>
literal|0
condition|;
operator|--
name|count
control|)
block|{
if|if
condition|(
name|curpos
operator|>=
sizeof|sizeof
argument_list|(
name|tfbfr
argument_list|)
condition|)
block|{
name|lastpos
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|tfbfr
argument_list|,
sizeof|sizeof
argument_list|(
name|tfbfr
argument_list|)
argument_list|)
expr_stmt|;
name|curpos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|curpos
operator|==
name|lastpos
condition|)
block|{
name|tf_close
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|s
operator|=
name|tfbfr
index|[
name|curpos
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|n
operator|-
name|count
operator|)
return|;
block|}
name|tf_close
argument_list|()
expr_stmt|;
return|return
name|TOO_BIG
return|;
block|}
end_function

begin_comment
comment|/*  * tf_read() is an internal routine.  It takes a string "s" and a count  * "n", and reads from the file until "n" bytes have been read.  When  * finished, what has been read exists in "s".  If it encounters EOF or  * an error, it closes the ticket file.  *  * Possible return values are:  *  * n		the number of bytes read when all goes well  *  * 0		on end of file or read error  */
end_comment

begin_function
specifier|static
name|int
name|tf_read
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|v
decl_stmt|;
name|int
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
name|n
init|;
name|count
operator|>
literal|0
condition|;
operator|--
name|count
control|)
block|{
if|if
condition|(
name|curpos
operator|>=
sizeof|sizeof
argument_list|(
name|tfbfr
argument_list|)
condition|)
block|{
name|lastpos
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|tfbfr
argument_list|,
sizeof|sizeof
argument_list|(
name|tfbfr
argument_list|)
argument_list|)
expr_stmt|;
name|curpos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|curpos
operator|==
name|lastpos
condition|)
block|{
name|tf_close
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|s
operator|++
operator|=
name|tfbfr
index|[
name|curpos
operator|++
index|]
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * tf_save_cred() appends an incoming ticket to the end of the ticket  * file.  You must call tf_init() before calling tf_save_cred().  *  * The "service", "instance", and "realm" arguments specify the  * server's name; "session" contains the session key to be used with  * the ticket; "kvno" is the server key version number in which the  * ticket is encrypted, "ticket" contains the actual ticket, and  * "issue_date" is the time the ticket was requested (local host's time).  *  * Returns KSUCCESS if all goes well, TKT_FIL_INI if tf_init() wasn't  * called previously, and KFAILURE for anything else that went wrong.  */
end_comment

begin_function
name|int
name|tf_save_cred
parameter_list|(
name|char
modifier|*
name|service
parameter_list|,
comment|/* Service name */
name|char
modifier|*
name|instance
parameter_list|,
comment|/* Instance */
name|char
modifier|*
name|realm
parameter_list|,
comment|/* Auth domain */
name|unsigned
name|char
modifier|*
name|session
parameter_list|,
comment|/* Session key */
name|int
name|lifetime
parameter_list|,
comment|/* Lifetime */
name|int
name|kvno
parameter_list|,
comment|/* Key version number */
name|KTEXT
name|ticket
parameter_list|,
comment|/* The ticket itself */
name|u_int32_t
name|issue_date
parameter_list|)
comment|/* The issue time */
block|{
name|int
name|count
decl_stmt|;
comment|/* count for write */
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
comment|/* fd is ticket file as set by tf_init */
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"tf_save_cred called before tf_init.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_INI
return|;
block|}
comment|/* Find the end of the ticket file */
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
comment|/* Write the ticket and associated data */
comment|/* Service */
name|count
operator|=
name|strlen
argument_list|(
name|service
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|service
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
goto|goto
name|bad
goto|;
comment|/* Instance */
name|count
operator|=
name|strlen
argument_list|(
name|instance
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|instance
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
goto|goto
name|bad
goto|;
comment|/* Realm */
name|count
operator|=
name|strlen
argument_list|(
name|realm
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|realm
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
goto|goto
name|bad
goto|;
comment|/* Session key */
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|session
argument_list|,
literal|8
argument_list|)
operator|!=
literal|8
condition|)
goto|goto
name|bad
goto|;
comment|/* Lifetime */
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|lifetime
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* Key vno */
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|kvno
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* Tkt length */
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|&
operator|(
name|ticket
operator|->
name|length
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* Ticket */
name|count
operator|=
name|ticket
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|ticket
operator|->
name|dat
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
goto|goto
name|bad
goto|;
comment|/* Issue date */
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|issue_date
argument_list|,
sizeof|sizeof
argument_list|(
name|issue_date
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|issue_date
argument_list|)
condition|)
goto|goto
name|bad
goto|;
return|return
operator|(
name|KSUCCESS
operator|)
return|;
name|bad
label|:
return|return
operator|(
name|KFAILURE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tf_setup
parameter_list|(
name|CREDENTIALS
modifier|*
name|cred
parameter_list|,
specifier|const
name|char
modifier|*
name|pname
parameter_list|,
specifier|const
name|char
modifier|*
name|pinst
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|tf_create
argument_list|(
name|tkt_string
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KSUCCESS
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|tf_put_pname
argument_list|(
name|pname
argument_list|)
operator|!=
name|KSUCCESS
operator|||
name|tf_put_pinst
argument_list|(
name|pinst
argument_list|)
operator|!=
name|KSUCCESS
condition|)
block|{
name|tf_close
argument_list|()
expr_stmt|;
return|return
name|INTK_ERR
return|;
block|}
if|if
condition|(
name|krb_get_kdc_time_diff
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|/* Add an extra magic ticket containing the time differential            to the kdc. The first ticket defines which realm we belong            to, but since this ticket gets the same realm as the tgt,            this shouldn't be a problem */
name|des_cblock
name|s
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|KTEXT_ST
name|t
decl_stmt|;
name|int
name|d
init|=
name|krb_get_kdc_time_diff
argument_list|()
decl_stmt|;
name|krb_put_int
argument_list|(
name|d
argument_list|,
name|t
operator|.
name|dat
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|.
name|dat
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|t
operator|.
name|length
operator|=
literal|4
expr_stmt|;
name|tf_save_cred
argument_list|(
name|MAGIC_TICKET_NAME
argument_list|,
name|MAGIC_TICKET_TIME_DIFF_INST
argument_list|,
name|cred
operator|->
name|realm
argument_list|,
name|s
argument_list|,
name|cred
operator|->
name|lifetime
argument_list|,
literal|0
argument_list|,
operator|&
name|t
argument_list|,
name|cred
operator|->
name|issue_date
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|tf_save_cred
argument_list|(
name|cred
operator|->
name|service
argument_list|,
name|cred
operator|->
name|instance
argument_list|,
name|cred
operator|->
name|realm
argument_list|,
name|cred
operator|->
name|session
argument_list|,
name|cred
operator|->
name|lifetime
argument_list|,
name|cred
operator|->
name|kvno
argument_list|,
operator|&
name|cred
operator|->
name|ticket_st
argument_list|,
name|cred
operator|->
name|issue_date
argument_list|)
expr_stmt|;
name|tf_close
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|in_tkt
parameter_list|(
name|char
modifier|*
name|pname
parameter_list|,
name|char
modifier|*
name|pinst
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|tf_create
argument_list|(
name|tkt_string
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KSUCCESS
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|tf_put_pname
argument_list|(
name|pname
argument_list|)
operator|!=
name|KSUCCESS
operator|||
name|tf_put_pinst
argument_list|(
name|pinst
argument_list|)
operator|!=
name|KSUCCESS
condition|)
block|{
name|tf_close
argument_list|()
expr_stmt|;
return|return
name|INTK_ERR
return|;
block|}
name|tf_close
argument_list|()
expr_stmt|;
return|return
name|KSUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * If there's a magic ticket with an address for realm `realm' in  * ticket file, return it in `addr'.  * realm == NULL means any realm.  */
end_comment

begin_function
name|int
name|tf_get_addr
parameter_list|(
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|)
block|{
name|CREDENTIALS
name|cred
decl_stmt|;
name|krb_principal
name|princ
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|tf_init
argument_list|(
name|tkt_string
argument_list|()
argument_list|,
name|R_TKT_FIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|tf_get_pname
argument_list|(
name|princ
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|tf_get_pinst
argument_list|(
name|princ
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
while|while
condition|(
operator|(
name|ret
operator|=
name|real_tf_get_cred
argument_list|(
operator|&
name|cred
argument_list|)
operator|)
operator|==
name|KSUCCESS
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cred
operator|.
name|service
argument_list|,
name|MAGIC_TICKET_NAME
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|cred
operator|.
name|instance
argument_list|,
name|MAGIC_TICKET_ADDR_INST
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|realm
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|cred
operator|.
name|realm
argument_list|,
name|realm
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|addr
argument_list|,
name|cred
operator|.
name|ticket_st
operator|.
name|dat
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret
operator|=
name|KFAILURE
expr_stmt|;
name|out
label|:
name|tf_close
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Store `realm, addr' as a magic ticket.  */
end_comment

begin_function
name|int
name|tf_store_addr
parameter_list|(
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|)
block|{
name|CREDENTIALS
name|c
decl_stmt|;
name|krb_principal
name|princ
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|des_cblock
name|s
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|KTEXT_ST
name|t
decl_stmt|;
name|ret
operator|=
name|tf_init
argument_list|(
name|tkt_string
argument_list|()
argument_list|,
name|W_TKT_FIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|t
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|t
operator|.
name|dat
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|tf_save_cred
argument_list|(
name|MAGIC_TICKET_NAME
argument_list|,
name|MAGIC_TICKET_ADDR_INST
argument_list|,
operator|(
name|char
operator|*
operator|)
name|realm
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
comment|/* lifetime */
literal|0
argument_list|,
comment|/* kvno */
operator|&
name|t
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|tf_close
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

