begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    Copyright (C) 1989 by the Massachusetts Institute of Technology     Export of this software from the United States of America is assumed    to require a specific license from the United States Government.    It is the responsibility of any person or organization contemplating    export to obtain such a license before exporting.  WITHIN THAT CONSTRAINT, permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.    */
end_comment

begin_include
include|#
directive|include
file|"krb_locl.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: dest_tkt.c,v 1.11.14.2 2000/10/18 20:26:42 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * dest_tkt() is used to destroy the ticket store upon logout.  * If the ticket file does not exist, dest_tkt() returns RET_TKFIL.  * Otherwise the function returns RET_OK on success, KFAILURE on  * failure.  *  * The ticket file (TKT_FILE) is defined in "krb.h".  */
end_comment

begin_function
name|int
name|dest_tkt
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|TKT_FILE
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|stat
name|sb1
decl_stmt|,
name|sb2
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|filename
argument_list|,
operator|&
name|sb1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDWR
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|unlink
argument_list|(
name|filename
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sb1
operator|.
name|st_dev
operator|!=
name|sb2
operator|.
name|st_dev
operator|||
name|sb1
operator|.
name|st_ino
operator|!=
name|sb2
operator|.
name|st_ino
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sb2
operator|.
name|st_nlink
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sb2
operator|.
name|st_size
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
control|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|error
operator|=
name|errno
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
name|fsync
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|fsync
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
return|return
name|RET_TKFIL
return|;
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|KFAILURE
return|;
else|else
return|return
operator|(
name|KSUCCESS
operator|)
return|;
block|}
end_function

end_unit

