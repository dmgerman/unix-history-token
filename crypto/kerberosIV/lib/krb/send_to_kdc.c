begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    Copyright (C) 1989 by the Massachusetts Institute of Technology     Export of this software from the United States of America is assumed    to require a specific license from the United States Government.    It is the responsibility of any person or organization contemplating    export to obtain such a license before exporting.  WITHIN THAT CONSTRAINT, permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.    */
end_comment

begin_include
include|#
directive|include
file|"krb_locl.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: send_to_kdc.c,v 1.39 1997/05/15 21:02:31 joda Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|host
block|{
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|int
name|proto
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|prog
init|=
literal|"send_to_kdc"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|send_recv
argument_list|(
argument|KTEXT pkt
argument_list|,
argument|KTEXT rpkt
argument_list|,
argument|int f
argument_list|,
argument|struct sockaddr_in *_to
argument_list|,
argument|struct host *addrs
argument_list|,
argument|int h_hosts
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This file contains two routines, send_to_kdc() and send_recv().  * send_recv() is a static routine used by send_to_kdc().  */
end_comment

begin_comment
comment|/*  * send_to_kdc() sends a message to the Kerberos authentication  * server(s) in the given realm and returns the reply message.  * The "pkt" argument points to the message to be sent to Kerberos;  * the "rpkt" argument will be filled in with Kerberos' reply.  * The "realm" argument indicates the realm of the Kerberos server(s)  * to transact with.  If the realm is null, the local realm is used.  *  * If more than one Kerberos server is known for a given realm,  * different servers will be queried until one of them replies.  * Several attempts (retries) are made for each server before  * giving up entirely.  *  * If an answer was received from a Kerberos host, KSUCCESS is  * returned.  The following errors can be returned:  *  * SKDC_CANT    - can't get local realm  *              - can't find "kerberos" in /etc/services database  *              - can't open socket  *              - can't bind socket  *              - all ports in use  *              - couldn't find any Kerberos host  *  * SKDC_RETRY   - couldn't get an answer from any Kerberos server,  *		  after several retries  */
end_comment

begin_function
name|int
name|send_to_kdc
parameter_list|(
name|KTEXT
name|pkt
parameter_list|,
name|KTEXT
name|rpkt
parameter_list|,
name|char
modifier|*
name|realm
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|no_host
decl_stmt|;
comment|/* was a kerberos host found? */
name|int
name|retry
decl_stmt|;
name|int
name|n_hosts
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|struct
name|hostent
modifier|*
name|host
decl_stmt|;
name|char
name|lrealm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|struct
name|krb_host
modifier|*
name|k_host
decl_stmt|;
name|struct
name|host
modifier|*
name|hosts
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hosts
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|hosts
operator|==
name|NULL
condition|)
return|return
name|SKDC_CANT
return|;
comment|/*      * If "realm" is non-null, use that, otherwise get the      * local realm.      */
if|if
condition|(
name|realm
condition|)
name|strcpy
argument_list|(
name|lrealm
argument_list|,
name|realm
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|krb_get_lrealm
argument_list|(
name|lrealm
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"%s: can't get local realm\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
return|return
operator|(
name|SKDC_CANT
operator|)
return|;
block|}
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"lrealm is %s\n"
argument_list|,
name|lrealm
argument_list|)
expr_stmt|;
name|no_host
operator|=
literal|1
expr_stmt|;
comment|/* get an initial allocation */
name|n_hosts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|k_host
operator|=
name|krb_get_host
argument_list|(
name|i
argument_list|,
name|lrealm
argument_list|,
literal|0
argument_list|)
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"Getting host entry for %s..."
argument_list|,
name|k_host
operator|->
name|host
argument_list|)
expr_stmt|;
name|host
operator|=
name|gethostbyname
argument_list|(
name|k_host
operator|->
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|krb_debug
condition|)
block|{
name|krb_warning
argument_list|(
literal|"%s.\n"
argument_list|,
name|host
condition|?
literal|"Got it"
else|:
literal|"Didn't get it"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|host
condition|)
continue|continue;
name|no_host
operator|=
literal|0
expr_stmt|;
comment|/* found at least one */
while|while
condition|(
operator|(
name|p
operator|=
operator|*
operator|(
name|host
operator|->
name|h_addr_list
operator|)
operator|++
operator|)
condition|)
block|{
name|hosts
operator|=
name|realloc
argument_list|(
name|hosts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hosts
argument_list|)
operator|*
operator|(
name|n_hosts
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hosts
operator|==
name|NULL
condition|)
return|return
name|SKDC_CANT
return|;
name|memset
argument_list|(
operator|&
name|hosts
index|[
name|n_hosts
index|]
operator|.
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hosts
index|[
name|n_hosts
index|]
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|hosts
index|[
name|n_hosts
index|]
operator|.
name|addr
operator|.
name|sin_family
operator|=
name|host
operator|->
name|h_addrtype
expr_stmt|;
name|hosts
index|[
name|n_hosts
index|]
operator|.
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|k_host
operator|->
name|port
argument_list|)
expr_stmt|;
name|hosts
index|[
name|n_hosts
index|]
operator|.
name|proto
operator|=
name|k_host
operator|->
name|proto
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|hosts
index|[
name|n_hosts
index|]
operator|.
name|addr
operator|.
name|sin_addr
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|hosts
index|[
name|n_hosts
index|]
operator|.
name|addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|n_hosts
expr_stmt|;
if|if
condition|(
name|send_recv
argument_list|(
name|pkt
argument_list|,
name|rpkt
argument_list|,
name|hosts
index|[
name|n_hosts
operator|-
literal|1
index|]
operator|.
name|proto
argument_list|,
operator|&
name|hosts
index|[
name|n_hosts
operator|-
literal|1
index|]
operator|.
name|addr
argument_list|,
name|hosts
argument_list|,
name|n_hosts
argument_list|)
condition|)
block|{
name|retval
operator|=
name|KSUCCESS
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
if|if
condition|(
name|krb_debug
condition|)
block|{
name|krb_warning
argument_list|(
literal|"Timeout, error, or wrong descriptor\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|no_host
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"%s: can't find any Kerberos host.\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|retval
operator|=
name|SKDC_CANT
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
comment|/* retry each host in sequence */
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
name|CLIENT_KRB_RETRY
condition|;
operator|++
name|retry
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_hosts
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|send_recv
argument_list|(
name|pkt
argument_list|,
name|rpkt
argument_list|,
name|hosts
index|[
name|i
index|]
operator|.
name|proto
argument_list|,
operator|&
name|hosts
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|hosts
argument_list|,
name|n_hosts
argument_list|)
condition|)
block|{
name|retval
operator|=
name|KSUCCESS
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
block|}
block|}
name|retval
operator|=
name|SKDC_RETRY
expr_stmt|;
name|rtn
label|:
name|free
argument_list|(
name|hosts
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * try to send out and receive message.  * return 1 on success, 0 on failure  */
end_comment

begin_function
specifier|static
name|int
name|send_recv_it
parameter_list|(
name|KTEXT
name|pkt
parameter_list|,
name|KTEXT
name|rpkt
parameter_list|,
name|int
name|stream
parameter_list|,
name|int
name|f
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|_to
parameter_list|,
name|struct
name|host
modifier|*
name|addrs
parameter_list|,
name|int
name|n_hosts
parameter_list|)
block|{
name|fd_set
name|readfds
decl_stmt|;
name|int
name|numsent
decl_stmt|;
comment|/* CLIENT_KRB_TIMEOUT indicates the time to wait before      * retrying a server.  It's defined in "krb.h".      */
name|struct
name|timeval
name|timeout
decl_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|CLIENT_KRB_TIMEOUT
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|krb_debug
condition|)
block|{
if|if
condition|(
name|_to
operator|->
name|sin_family
operator|==
name|AF_INET
condition|)
name|krb_warning
argument_list|(
literal|"Sending message to %s..."
argument_list|,
name|inet_ntoa
argument_list|(
name|_to
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|krb_warning
argument_list|(
literal|"Sending message..."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stream
condition|)
block|{
name|unsigned
name|char
name|tmp
index|[
literal|4
index|]
decl_stmt|;
name|krb_put_int
argument_list|(
name|pkt
operator|->
name|length
argument_list|,
name|tmp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numsent
operator|=
name|send
argument_list|(
name|f
argument_list|,
name|tmp
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|4
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"sent only %d/%d\n"
argument_list|,
name|numsent
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|(
name|numsent
operator|=
name|send
argument_list|(
name|f
argument_list|,
name|pkt
operator|->
name|dat
argument_list|,
name|pkt
operator|->
name|length
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|pkt
operator|->
name|length
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"sent only %d/%d\n"
argument_list|,
name|numsent
argument_list|,
name|pkt
operator|->
name|length
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"Sent\nWaiting for reply..."
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|f
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
comment|/* select - either recv is ready, or timeout */
comment|/* see if timeout or error or wrong descriptor */
if|if
condition|(
name|select
argument_list|(
name|f
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|1
operator|||
operator|!
name|FD_ISSET
argument_list|(
name|f
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"select failed: errno = %d"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|stream
condition|)
block|{
if|if
condition|(
name|krb_net_read
argument_list|(
name|f
argument_list|,
name|rpkt
operator|->
name|dat
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|recv
argument_list|(
name|f
argument_list|,
name|rpkt
operator|->
name|dat
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"recvfrom: errno = %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_recv
parameter_list|(
name|KTEXT
name|pkt
parameter_list|,
name|KTEXT
name|rpkt
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|_to
parameter_list|,
name|struct
name|host
modifier|*
name|addrs
parameter_list|,
name|int
name|n_hosts
parameter_list|)
block|{
name|int
name|f
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|proto
operator|==
name|IPPROTO_UDP
condition|)
name|f
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|proto
operator|==
name|IPPROTO_TCP
condition|)
name|f
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
else|else
block|{
name|krb_warning
argument_list|(
literal|"Unknown protocol `%d'.\n"
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|f
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|_to
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|_to
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|krb_warning
argument_list|(
literal|"Connecting socket: errno = %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|send_recv_it
argument_list|(
name|pkt
argument_list|,
name|rpkt
argument_list|,
name|proto
operator|==
name|IPPROTO_TCP
argument_list|,
name|f
argument_list|,
name|_to
argument_list|,
name|addrs
argument_list|,
name|n_hosts
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

