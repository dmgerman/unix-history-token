begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    Copyright (C) 1989 by the Massachusetts Institute of Technology     Export of this software from the United States of America is assumed    to require a specific license from the United States Government.    It is the responsibility of any person or organization contemplating    export to obtain such a license before exporting.  WITHIN THAT CONSTRAINT, permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.    */
end_comment

begin_include
include|#
directive|include
file|"krb_locl.h"
end_include

begin_include
include|#
directive|include
file|<base64.h>
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: send_to_kdc.c,v 1.71.2.1 2000/10/10 12:47:21 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|host
block|{
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|;
name|enum
name|krb_host_proto
name|proto
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|send_recv
parameter_list|(
name|KTEXT
name|pkt
parameter_list|,
name|KTEXT
name|rpkt
parameter_list|,
name|struct
name|host
modifier|*
name|host
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * send_to_kdc() sends a message to the Kerberos authentication  * server(s) in the given realm and returns the reply message.  * The "pkt" argument points to the message to be sent to Kerberos;  * the "rpkt" argument will be filled in with Kerberos' reply.  * The "realm" argument indicates the realm of the Kerberos server(s)  * to transact with.  If the realm is null, the local realm is used.  *  * If more than one Kerberos server is known for a given realm,  * different servers will be queried until one of them replies.  * Several attempts (retries) are made for each server before  * giving up entirely.  *  * If an answer was received from a Kerberos host, KSUCCESS is  * returned.  The following errors can be returned:  *  * SKDC_CANT    - can't get local realm  *              - can't find "kerberos" in /etc/services database  *              - can't open socket  *              - can't bind socket  *              - all ports in use  *              - couldn't find any Kerberos host  *  * SKDC_RETRY   - couldn't get an answer from any Kerberos server,  *		  after several retries  */
end_comment

begin_comment
comment|/* always use the admin server */
end_comment

begin_decl_stmt
specifier|static
name|int
name|krb_use_admin_server_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|client_timeout
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|krb_use_admin_server
parameter_list|(
name|int
name|flag
parameter_list|)
block|{
name|int
name|old
init|=
name|krb_use_admin_server_flag
decl_stmt|;
name|krb_use_admin_server_flag
operator|=
name|flag
expr_stmt|;
return|return
name|old
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PROXY_VAR
value|"krb4_proxy"
end_define

begin_function
specifier|static
name|int
name|expand
parameter_list|(
name|struct
name|host
modifier|*
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|void
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|realloc
argument_list|(
operator|*
name|ptr
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
name|SKDC_CANT
return|;
operator|*
name|ptr
operator|=
name|tmp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|send_to_kdc
parameter_list|(
name|KTEXT
name|pkt
parameter_list|,
name|KTEXT
name|rpkt
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|no_host
decl_stmt|;
comment|/* was a kerberos host found? */
name|int
name|retry
decl_stmt|;
name|int
name|n_hosts
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|struct
name|hostent
modifier|*
name|host
decl_stmt|;
name|char
name|lrealm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|struct
name|krb_host
modifier|*
name|k_host
decl_stmt|;
name|struct
name|host
modifier|*
name|hosts
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hosts
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|proxy
init|=
name|krb_get_config_string
argument_list|(
name|PROXY_VAR
argument_list|)
decl_stmt|;
if|if
condition|(
name|hosts
operator|==
name|NULL
condition|)
return|return
name|SKDC_CANT
return|;
if|if
condition|(
name|client_timeout
operator|==
operator|-
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
name|client_timeout
operator|=
name|CLIENT_KRB_TIMEOUT
expr_stmt|;
name|to
operator|=
name|krb_get_config_string
argument_list|(
literal|"kdc_timeout"
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|!=
name|NULL
condition|)
block|{
name|int
name|tmp
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|tmp
operator|=
name|strtol
argument_list|(
name|to
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|to
condition|)
name|client_timeout
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|/*      * If "realm" is non-null, use that, otherwise get the      * local realm.      */
if|if
condition|(
name|realm
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|krb_get_lrealm
argument_list|(
name|lrealm
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"send_to_kdc: can't get local realm\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SKDC_CANT
operator|)
return|;
block|}
name|realm
operator|=
name|lrealm
expr_stmt|;
block|}
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"lrealm is %s\n"
argument_list|,
name|realm
argument_list|)
expr_stmt|;
name|no_host
operator|=
literal|1
expr_stmt|;
comment|/* get an initial allocation */
name|n_hosts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|k_host
operator|=
name|krb_get_host
argument_list|(
name|i
argument_list|,
name|realm
argument_list|,
name|krb_use_admin_server_flag
argument_list|)
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|addr_list
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|n_addrs
decl_stmt|;
name|struct
name|host
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|k_host
operator|->
name|proto
operator|==
name|PROTO_HTTP
operator|&&
name|proxy
operator|!=
name|NULL
condition|)
block|{
name|n_addrs
operator|=
literal|1
expr_stmt|;
name|no_host
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|expand
argument_list|(
operator|&
name|hosts
argument_list|,
operator|(
name|n_hosts
operator|+
name|n_addrs
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|hosts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|rtn
goto|;
name|memset
argument_list|(
operator|&
name|hosts
index|[
name|n_hosts
index|]
operator|.
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|hosts
index|[
name|n_hosts
index|]
operator|.
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|k_host
operator|->
name|port
argument_list|)
expr_stmt|;
name|hosts
index|[
name|n_hosts
index|]
operator|.
name|proto
operator|=
name|k_host
operator|->
name|proto
expr_stmt|;
name|hosts
index|[
name|n_hosts
index|]
operator|.
name|hostname
operator|=
name|k_host
operator|->
name|host
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"Getting host entry for %s..."
argument_list|,
name|k_host
operator|->
name|host
argument_list|)
expr_stmt|;
name|host
operator|=
name|gethostbyname
argument_list|(
name|k_host
operator|->
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|krb_debug
condition|)
block|{
name|krb_warning
argument_list|(
literal|"%s.\n"
argument_list|,
name|host
condition|?
literal|"Got it"
else|:
literal|"Didn't get it"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
continue|continue;
name|no_host
operator|=
literal|0
expr_stmt|;
comment|/* found at least one */
name|n_addrs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|addr_list
operator|=
name|host
operator|->
name|h_addr_list
init|;
operator|*
name|addr_list
operator|!=
name|NULL
condition|;
operator|++
name|addr_list
control|)
operator|++
name|n_addrs
expr_stmt|;
name|retval
operator|=
name|expand
argument_list|(
operator|&
name|hosts
argument_list|,
operator|(
name|n_hosts
operator|+
name|n_addrs
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|hosts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|rtn
goto|;
for|for
control|(
name|addr_list
operator|=
name|host
operator|->
name|h_addr_list
operator|,
name|j
operator|=
literal|0
init|;
operator|(
name|p
operator|=
operator|*
name|addr_list
operator|)
operator|!=
name|NULL
condition|;
operator|++
name|addr_list
operator|,
operator|++
name|j
control|)
block|{
name|memset
argument_list|(
operator|&
name|hosts
index|[
name|n_hosts
operator|+
name|j
index|]
operator|.
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|hosts
index|[
name|n_hosts
operator|+
name|j
index|]
operator|.
name|addr
operator|.
name|sin_family
operator|=
name|host
operator|->
name|h_addrtype
expr_stmt|;
name|hosts
index|[
name|n_hosts
operator|+
name|j
index|]
operator|.
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|k_host
operator|->
name|port
argument_list|)
expr_stmt|;
name|hosts
index|[
name|n_hosts
operator|+
name|j
index|]
operator|.
name|proto
operator|=
name|k_host
operator|->
name|proto
expr_stmt|;
name|hosts
index|[
name|n_hosts
operator|+
name|j
index|]
operator|.
name|hostname
operator|=
name|k_host
operator|->
name|host
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|hosts
index|[
name|n_hosts
operator|+
name|j
index|]
operator|.
name|addr
operator|.
name|sin_addr
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_addrs
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|send_recv
argument_list|(
name|pkt
argument_list|,
name|rpkt
argument_list|,
operator|&
name|hosts
index|[
name|n_hosts
operator|+
name|j
index|]
argument_list|)
condition|)
block|{
name|retval
operator|=
name|KSUCCESS
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
if|if
condition|(
name|krb_debug
condition|)
block|{
name|krb_warning
argument_list|(
literal|"Timeout, error, or wrong descriptor\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|n_hosts
operator|+=
name|j
expr_stmt|;
block|}
if|if
condition|(
name|no_host
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"send_to_kdc: can't find any Kerberos host.\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|SKDC_CANT
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
comment|/* retry each host in sequence */
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
name|CLIENT_KRB_RETRY
condition|;
operator|++
name|retry
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_hosts
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|send_recv
argument_list|(
name|pkt
argument_list|,
name|rpkt
argument_list|,
operator|&
name|hosts
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|retval
operator|=
name|KSUCCESS
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
block|}
block|}
name|retval
operator|=
name|SKDC_RETRY
expr_stmt|;
name|rtn
label|:
name|free
argument_list|(
name|hosts
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udp_socket
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udp_connect
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|host
modifier|*
name|host
parameter_list|)
block|{
if|if
condition|(
name|krb_debug
condition|)
block|{
name|krb_warning
argument_list|(
literal|"connecting to %s (%s) udp, port %d\n"
argument_list|,
name|host
operator|->
name|hostname
argument_list|,
name|inet_ntoa
argument_list|(
name|host
operator|->
name|addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|host
operator|->
name|addr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|host
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|host
operator|->
name|addr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udp_send
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|host
modifier|*
name|host
parameter_list|,
name|KTEXT
name|pkt
parameter_list|)
block|{
if|if
condition|(
name|krb_debug
condition|)
block|{
name|krb_warning
argument_list|(
literal|"sending %d bytes to %s (%s), udp port %d\n"
argument_list|,
name|pkt
operator|->
name|length
argument_list|,
name|host
operator|->
name|hostname
argument_list|,
name|inet_ntoa
argument_list|(
name|host
operator|->
name|addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|host
operator|->
name|addr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|send
argument_list|(
name|s
argument_list|,
name|pkt
operator|->
name|dat
argument_list|,
name|pkt
operator|->
name|length
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tcp_socket
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tcp_connect
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|host
modifier|*
name|host
parameter_list|)
block|{
if|if
condition|(
name|krb_debug
condition|)
block|{
name|krb_warning
argument_list|(
literal|"connecting to %s (%s), tcp port %d\n"
argument_list|,
name|host
operator|->
name|hostname
argument_list|,
name|inet_ntoa
argument_list|(
name|host
operator|->
name|addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|host
operator|->
name|addr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|host
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|host
operator|->
name|addr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tcp_send
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|host
modifier|*
name|host
parameter_list|,
name|KTEXT
name|pkt
parameter_list|)
block|{
name|unsigned
name|char
name|len
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|krb_debug
condition|)
block|{
name|krb_warning
argument_list|(
literal|"sending %d bytes to %s (%s), tcp port %d\n"
argument_list|,
name|pkt
operator|->
name|length
argument_list|,
name|host
operator|->
name|hostname
argument_list|,
name|inet_ntoa
argument_list|(
name|host
operator|->
name|addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|host
operator|->
name|addr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|krb_put_int
argument_list|(
name|pkt
operator|->
name|length
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|send
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|send
argument_list|(
name|s
argument_list|,
name|pkt
operator|->
name|dat
argument_list|,
name|pkt
operator|->
name|length
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udptcp_recv
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|KTEXT
name|rpkt
parameter_list|)
block|{
name|int
name|pktlen
init|=
name|min
argument_list|(
name|len
argument_list|,
name|MAX_KTXT_LEN
argument_list|)
decl_stmt|;
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"recieved %lu bytes on udp/tcp socket\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|,
name|buf
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|rpkt
operator|->
name|length
operator|=
name|pktlen
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|url_parse
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|char
modifier|*
name|host
parameter_list|,
name|size_t
name|len
parameter_list|,
name|short
modifier|*
name|port
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|n
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|url
argument_list|,
literal|"http://"
argument_list|,
literal|7
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|url
operator|+=
literal|7
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|url
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
operator|*
name|port
operator|=
name|htons
argument_list|(
name|strtol
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|p
operator|+
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|n
operator|=
name|p
operator|-
name|url
expr_stmt|;
block|}
else|else
block|{
operator|*
name|port
operator|=
name|k_getportbyname
argument_list|(
literal|"http"
argument_list|,
literal|"tcp"
argument_list|,
name|htons
argument_list|(
literal|80
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|url
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|n
operator|=
name|p
operator|-
name|url
expr_stmt|;
else|else
name|n
operator|=
name|strlen
argument_list|(
name|url
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
name|len
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|host
argument_list|,
name|url
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|host
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|http_connect
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|host
modifier|*
name|host
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|proxy
init|=
name|krb_get_config_string
argument_list|(
name|PROXY_VAR
argument_list|)
decl_stmt|;
name|char
name|proxy_host
index|[
name|MaxHostNameLen
index|]
decl_stmt|;
name|short
name|port
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
if|if
condition|(
name|proxy
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"Not using proxy.\n"
argument_list|)
expr_stmt|;
return|return
name|tcp_connect
argument_list|(
name|s
argument_list|,
name|host
argument_list|)
return|;
block|}
if|if
condition|(
name|url_parse
argument_list|(
name|proxy
argument_list|,
name|proxy_host
argument_list|,
sizeof|sizeof
argument_list|(
name|proxy_host
argument_list|)
argument_list|,
operator|&
name|port
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|proxy_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
if|if
condition|(
name|krb_debug
condition|)
block|{
name|krb_warning
argument_list|(
literal|"connecting to proxy on %s (%s) port %d\n"
argument_list|,
name|proxy_host
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|http_send
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|host
modifier|*
name|host
parameter_list|,
name|KTEXT
name|pkt
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|proxy
init|=
name|krb_get_config_string
argument_list|(
name|PROXY_VAR
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|base64_encode
argument_list|(
name|pkt
operator|->
name|dat
argument_list|,
name|pkt
operator|->
name|length
argument_list|,
operator|&
name|str
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|proxy
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
block|{
name|krb_warning
argument_list|(
literal|"sending %d bytes to %s, tcp port %d (via proxy)\n"
argument_list|,
name|pkt
operator|->
name|length
argument_list|,
name|host
operator|->
name|hostname
argument_list|,
name|ntohs
argument_list|(
name|host
operator|->
name|addr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|asprintf
argument_list|(
operator|&
name|msg
argument_list|,
literal|"GET http://%s:%d/%s HTTP/1.0\r\n\r\n"
argument_list|,
name|host
operator|->
name|hostname
argument_list|,
name|ntohs
argument_list|(
name|host
operator|->
name|addr
operator|.
name|sin_port
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|krb_debug
condition|)
block|{
name|krb_warning
argument_list|(
literal|"sending %d bytes to %s (%s), http port %d\n"
argument_list|,
name|pkt
operator|->
name|length
argument_list|,
name|host
operator|->
name|hostname
argument_list|,
name|inet_ntoa
argument_list|(
name|host
operator|->
name|addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|host
operator|->
name|addr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|asprintf
argument_list|(
operator|&
name|msg
argument_list|,
literal|"GET %s HTTP/1.0\r\n\r\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|send
argument_list|(
name|s
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|strlen
argument_list|(
name|msg
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|http_recv
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|KTEXT
name|rpkt
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tmp
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|strstr
argument_list|(
name|tmp
argument_list|,
literal|"\r\n\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"recieved %lu bytes on http socket\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|tmp
operator|+
name|len
operator|)
operator|-
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|+
name|len
operator|)
operator|-
name|p
operator|>
name|MAX_KTXT_LEN
condition|)
block|{
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|strncasecmp
argument_list|(
name|tmp
argument_list|,
literal|"HTTP/1.0 2"
argument_list|,
literal|10
argument_list|)
operator|!=
literal|0
operator|&&
name|strncasecmp
argument_list|(
name|tmp
argument_list|,
literal|"HTTP/1.1 2"
argument_list|,
literal|10
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|,
name|p
argument_list|,
operator|(
name|tmp
operator|+
name|len
operator|)
operator|-
name|p
argument_list|)
expr_stmt|;
name|rpkt
operator|->
name|length
operator|=
operator|(
name|tmp
operator|+
name|len
operator|)
operator|-
name|p
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|proto_descr
block|{
name|int
name|proto
decl_stmt|;
name|int
name|stream_flag
decl_stmt|;
name|int
function_decl|(
modifier|*
name|socket
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|connect
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|struct
name|host
modifier|*
name|host
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|send
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|struct
name|host
modifier|*
name|host
parameter_list|,
name|KTEXT
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|recv
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|KTEXT
parameter_list|)
function_decl|;
block|}
name|protos
index|[]
init|=
block|{
block|{
name|PROTO_UDP
block|,
literal|0
block|,
name|udp_socket
block|,
name|udp_connect
block|,
name|udp_send
block|,
name|udptcp_recv
block|}
block|,
block|{
name|PROTO_TCP
block|,
literal|1
block|,
name|tcp_socket
block|,
name|tcp_connect
block|,
name|tcp_send
block|,
name|udptcp_recv
block|}
block|,
block|{
name|PROTO_HTTP
block|,
literal|1
block|,
name|tcp_socket
block|,
name|http_connect
block|,
name|http_send
block|,
name|http_recv
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|send_recv
parameter_list|(
name|KTEXT
name|pkt
parameter_list|,
name|KTEXT
name|rpkt
parameter_list|,
name|struct
name|host
modifier|*
name|host
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|MAX_KTXT_LEN
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|protos
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|protos
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|protos
index|[
name|i
index|]
operator|.
name|proto
operator|==
name|host
operator|->
name|proto
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
sizeof|sizeof
argument_list|(
name|protos
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|protos
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|s
operator|=
operator|(
operator|*
name|protos
index|[
name|i
index|]
operator|.
name|socket
operator|)
operator|(
operator|)
operator|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
operator|*
name|protos
index|[
name|i
index|]
operator|.
name|connect
operator|)
operator|(
name|s
operator|,
name|host
operator|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|protos
index|[
name|i
index|]
operator|.
name|send
operator|)
operator|(
name|s
operator|,
name|host
operator|,
name|pkt
operator|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
do|do
block|{
name|fd_set
name|readfds
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|int
name|len
decl_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|client_timeout
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|FD_SETSIZE
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"fd too large\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|FD_SET
argument_list|(
name|s
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
comment|/* select - either recv is ready, or timeout */
comment|/* see if timeout or error or wrong descriptor */
if|if
condition|(
name|select
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|1
operator|||
operator|!
name|FD_ISSET
argument_list|(
name|s
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|krb_warning
argument_list|(
literal|"select failed: errno = %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|len
operator|=
name|recv
argument_list|(
name|s
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
name|offset
operator|+=
name|len
expr_stmt|;
block|}
do|while
condition|(
name|protos
index|[
name|i
index|]
operator|.
name|stream_flag
condition|)
do|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|protos
index|[
name|i
index|]
operator|.
name|recv
operator|)
operator|(
name|buf
operator|,
name|offset
operator|,
name|rpkt
operator|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The configuration line "hosts: dns files" in /etc/nsswitch.conf is  * rumored to avoid triggering this bug. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|linux
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE__DNS_GETHOSTBYNAME
argument_list|)
operator|&&
literal|0
end_if

begin_comment
comment|/* Linux libc 5.3 is broken probably somewhere in nsw_hosts.o,  * for now keep this kludge. */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|gethostbyname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|_dns_gethostbyname
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

