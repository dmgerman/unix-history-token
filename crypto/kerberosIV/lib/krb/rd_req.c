begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *   * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *   * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by the Kungliga Tekniska  *      Högskolan and its contributors.  *   * 4. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"krb_locl.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: rd_req.c,v 1.25 1998/06/09 19:25:25 joda Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|t_local
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Keep the following information around for subsequent calls  * to this routine by the same server using the same key.  */
end_comment

begin_decl_stmt
specifier|static
name|des_key_schedule
name|serv_key
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Key sched to decrypt ticket */
end_comment

begin_decl_stmt
specifier|static
name|des_cblock
name|ky
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialization vector */
end_comment

begin_decl_stmt
specifier|static
name|int
name|st_kvno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* version number for this key */
end_comment

begin_decl_stmt
specifier|static
name|char
name|st_rlm
index|[
name|REALM_SZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* server's realm */
end_comment

begin_decl_stmt
specifier|static
name|char
name|st_nam
index|[
name|ANAME_SZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* service name */
end_comment

begin_decl_stmt
specifier|static
name|char
name|st_inst
index|[
name|INST_SZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* server's instance */
end_comment

begin_comment
comment|/*  * This file contains two functions.  krb_set_key() takes a DES  * key or password string and returns a DES key (either the original  * key, or the password converted into a DES key) and a key schedule  * for it.  *  * krb_rd_req() reads an authentication request and returns information  * about the identity of the requestor, or an indication that the  * identity information was not authentic.  */
end_comment

begin_comment
comment|/*  * krb_set_key() takes as its first argument either a DES key or a  * password string.  The "cvt" argument indicates how the first  * argument "key" is to be interpreted: if "cvt" is null, "key" is  * taken to be a DES key; if "cvt" is non-null, "key" is taken to  * be a password string, and is converted into a DES key using  * string_to_key().  In either case, the resulting key is returned  * in the external static variable "ky".  A key schedule is  * generated for "ky" and returned in the external static variable  * "serv_key".  *  * This routine returns the return value of des_key_sched.  *  * krb_set_key() needs to be in the same .o file as krb_rd_req() so that  * the key set by krb_set_key() is available in private storage for  * krb_rd_req().  */
end_comment

begin_function
name|int
name|krb_set_key
parameter_list|(
name|void
modifier|*
name|key
parameter_list|,
name|int
name|cvt
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NOENCRYPTION
name|memset
argument_list|(
name|ky
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ky
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|KSUCCESS
return|;
else|#
directive|else
comment|/* Encrypt */
if|if
condition|(
name|cvt
condition|)
name|des_string_to_key
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key
argument_list|,
operator|&
name|ky
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ky
argument_list|,
name|key
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
operator|(
name|des_key_sched
argument_list|(
operator|&
name|ky
argument_list|,
name|serv_key
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* NOENCRYPTION */
block|}
end_function

begin_comment
comment|/*  * krb_rd_req() takes an AUTH_MSG_APPL_REQUEST or  * AUTH_MSG_APPL_REQUEST_MUTUAL message created by krb_mk_req(),  * checks its integrity and returns a judgement as to the requestor's  * identity.  *  * The "authent" argument is a pointer to the received message.  * The "service" and "instance" arguments name the receiving server,  * and are used to get the service's ticket to decrypt the ticket  * in the message, and to compare against the server name inside the  * ticket.  "from_addr" is the network address of the host from which  * the message was received; this is checked against the network  * address in the ticket.  If "from_addr" is zero, the check is not  * performed.  "ad" is an AUTH_DAT structure which is  * filled in with information about the sender's identity according  * to the authenticator and ticket sent in the message.  Finally,  * "fn" contains the name of the file containing the server's key.  * (If "fn" is NULL, the server's key is assumed to have been set  * by krb_set_key().  If "fn" is the null string ("") the default  * file KEYFILE, defined in "krb.h", is used.)  *  * krb_rd_req() returns RD_AP_OK if the authentication information  * was genuine, or one of the following error codes (defined in  * "krb.h"):  *  *	RD_AP_VERSION		- wrong protocol version number  *	RD_AP_MSG_TYPE		- wrong message type  *	RD_AP_UNDEC		- couldn't decipher the message  *	RD_AP_INCON		- inconsistencies found  *	RD_AP_BADD		- wrong network address  *	RD_AP_TIME		- client time (in authenticator)  *				  too far off server time  *	RD_AP_NYV		- Kerberos time (in ticket) too  *				  far off server time  *	RD_AP_EXP		- ticket expired  *  * For the message format, see krb_mk_req().  *  * Mutual authentication is not implemented.  */
end_comment

begin_function
name|int
name|krb_rd_req
parameter_list|(
name|KTEXT
name|authent
parameter_list|,
comment|/* The received message */
name|char
modifier|*
name|service
parameter_list|,
comment|/* Service name */
name|char
modifier|*
name|instance
parameter_list|,
comment|/* Service instance */
name|int32_t
name|from_addr
parameter_list|,
comment|/* Net address of originating host */
name|AUTH_DAT
modifier|*
name|ad
parameter_list|,
comment|/* Structure to be filled in */
name|char
modifier|*
name|fn
parameter_list|)
comment|/* Filename to get keys from */
block|{
specifier|static
name|KTEXT_ST
name|ticket
decl_stmt|;
comment|/* Temp storage for ticket */
specifier|static
name|KTEXT
name|tkt
init|=
operator|&
name|ticket
decl_stmt|;
specifier|static
name|KTEXT_ST
name|req_id_st
decl_stmt|;
comment|/* Temp storage for authenticator */
name|KTEXT
name|req_id
init|=
operator|&
name|req_id_st
decl_stmt|;
name|char
name|realm
index|[
name|REALM_SZ
index|]
decl_stmt|;
comment|/* Realm of issuing kerberos */
name|unsigned
name|char
name|skey
index|[
name|KKEY_SZ
index|]
decl_stmt|;
comment|/* Session key from ticket */
name|char
name|sname
index|[
name|SNAME_SZ
index|]
decl_stmt|;
comment|/* Service name from ticket */
name|char
name|iname
index|[
name|INST_SZ
index|]
decl_stmt|;
comment|/* Instance name from ticket */
name|char
name|r_aname
index|[
name|ANAME_SZ
index|]
decl_stmt|;
comment|/* Client name from authenticator */
name|char
name|r_inst
index|[
name|INST_SZ
index|]
decl_stmt|;
comment|/* Client instance from authenticator */
name|char
name|r_realm
index|[
name|REALM_SZ
index|]
decl_stmt|;
comment|/* Client realm from authenticator */
name|u_int32_t
name|r_time_sec
decl_stmt|;
comment|/* Coarse time from authenticator */
name|unsigned
name|long
name|delta_t
decl_stmt|;
comment|/* Time in authenticator - local time */
name|long
name|tkt_age
decl_stmt|;
comment|/* Age of ticket */
specifier|static
name|unsigned
name|char
name|s_kvno
decl_stmt|;
comment|/* Version number of the server's key 				 * Kerberos used to encrypt ticket */
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|pvno
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|little_endian
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|authent
operator|->
name|length
operator|<=
literal|0
condition|)
return|return
operator|(
name|RD_AP_MODIFIED
operator|)
return|;
name|p
operator|=
name|authent
operator|->
name|dat
expr_stmt|;
comment|/* get msg version, type and byte order, and server key version */
name|pvno
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|pvno
operator|!=
name|KRB_PROT_VERSION
condition|)
return|return
name|RD_AP_VERSION
return|;
name|type
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|little_endian
operator|=
name|type
operator|&
literal|1
expr_stmt|;
name|type
operator|&=
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|AUTH_MSG_APPL_REQUEST
operator|&&
name|type
operator|!=
name|AUTH_MSG_APPL_REQUEST_MUTUAL
condition|)
return|return
name|RD_AP_MSG_TYPE
return|;
name|s_kvno
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|p
operator|+=
name|krb_get_string
argument_list|(
name|p
argument_list|,
name|realm
argument_list|,
sizeof|sizeof
argument_list|(
name|realm
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * If "fn" is NULL, key info should already be set; don't      * bother with ticket file.  Otherwise, check to see if we      * already have key info for the given server and key version      * (saved in the static st_* variables).  If not, go get it      * from the ticket file.  If "fn" is the null string, use the      * default ticket file.      */
if|if
condition|(
name|fn
operator|&&
operator|(
name|strcmp
argument_list|(
name|st_nam
argument_list|,
name|service
argument_list|)
operator|||
name|strcmp
argument_list|(
name|st_inst
argument_list|,
name|instance
argument_list|)
operator|||
name|strcmp
argument_list|(
name|st_rlm
argument_list|,
name|realm
argument_list|)
operator|||
operator|(
name|st_kvno
operator|!=
name|s_kvno
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|fn
operator|==
literal|0
condition|)
name|fn
operator|=
name|KEYFILE
expr_stmt|;
name|st_kvno
operator|=
name|s_kvno
expr_stmt|;
if|if
condition|(
name|read_service_key
argument_list|(
name|service
argument_list|,
name|instance
argument_list|,
name|realm
argument_list|,
name|s_kvno
argument_list|,
name|fn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|skey
argument_list|)
condition|)
return|return
operator|(
name|RD_AP_UNDEC
operator|)
return|;
if|if
condition|(
operator|(
name|status
operator|=
name|krb_set_key
argument_list|(
operator|(
name|char
operator|*
operator|)
name|skey
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|strcpy_truncate
argument_list|(
name|st_rlm
argument_list|,
name|realm
argument_list|,
name|REALM_SZ
argument_list|)
expr_stmt|;
name|strcpy_truncate
argument_list|(
name|st_nam
argument_list|,
name|service
argument_list|,
name|SNAME_SZ
argument_list|)
expr_stmt|;
name|strcpy_truncate
argument_list|(
name|st_inst
argument_list|,
name|instance
argument_list|,
name|INST_SZ
argument_list|)
expr_stmt|;
block|}
name|tkt
operator|->
name|length
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|req_id
operator|->
name|length
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|tkt
operator|->
name|length
operator|+
operator|(
name|p
operator|-
name|authent
operator|->
name|dat
operator|)
operator|>
name|authent
operator|->
name|length
condition|)
return|return
name|RD_AP_MODIFIED
return|;
name|memcpy
argument_list|(
name|tkt
operator|->
name|dat
argument_list|,
name|p
argument_list|,
name|tkt
operator|->
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
name|tkt
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|krb_log
argument_list|(
literal|"ticket->length: %d"
argument_list|,
name|tkt
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* Decrypt and take apart ticket */
if|if
condition|(
name|decomp_ticket
argument_list|(
name|tkt
argument_list|,
operator|&
name|ad
operator|->
name|k_flags
argument_list|,
name|ad
operator|->
name|pname
argument_list|,
name|ad
operator|->
name|pinst
argument_list|,
name|ad
operator|->
name|prealm
argument_list|,
operator|&
name|ad
operator|->
name|address
argument_list|,
name|ad
operator|->
name|session
argument_list|,
operator|&
name|ad
operator|->
name|life
argument_list|,
operator|&
name|ad
operator|->
name|time_sec
argument_list|,
name|sname
argument_list|,
name|iname
argument_list|,
operator|&
name|ky
argument_list|,
name|serv_key
argument_list|)
condition|)
return|return
name|RD_AP_UNDEC
return|;
if|if
condition|(
name|krb_ap_req_debug
condition|)
block|{
name|krb_log
argument_list|(
literal|"Ticket Contents."
argument_list|)
expr_stmt|;
name|krb_log
argument_list|(
literal|" Aname:   %s.%s"
argument_list|,
name|ad
operator|->
name|pname
argument_list|,
name|ad
operator|->
name|prealm
argument_list|)
expr_stmt|;
name|krb_log
argument_list|(
literal|" Service: %s"
argument_list|,
name|krb_unparse_name_long
argument_list|(
name|sname
argument_list|,
name|iname
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Extract the authenticator */
if|if
condition|(
name|req_id
operator|->
name|length
operator|+
operator|(
name|p
operator|-
name|authent
operator|->
name|dat
operator|)
operator|>
name|authent
operator|->
name|length
condition|)
return|return
name|RD_AP_MODIFIED
return|;
name|memcpy
argument_list|(
name|req_id
operator|->
name|dat
argument_list|,
name|p
argument_list|,
name|req_id
operator|->
name|length
argument_list|)
expr_stmt|;
name|p
operator|=
name|req_id
operator|->
name|dat
expr_stmt|;
ifndef|#
directive|ifndef
name|NOENCRYPTION
comment|/* And decrypt it with the session key from the ticket */
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|krb_log
argument_list|(
literal|"About to decrypt authenticator"
argument_list|)
expr_stmt|;
name|encrypt_ktext
argument_list|(
name|req_id
argument_list|,
operator|&
name|ad
operator|->
name|session
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|krb_log
argument_list|(
literal|"Done."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOENCRYPTION */
comment|/* cast req_id->length to int? */
define|#
directive|define
name|check_ptr
parameter_list|()
value|if ((ptr - (char *) req_id->dat)> req_id->length) return(RD_AP_MODIFIED);
name|p
operator|+=
name|krb_get_nir
argument_list|(
name|p
argument_list|,
name|r_aname
argument_list|,
name|r_inst
argument_list|,
name|r_realm
argument_list|)
expr_stmt|;
comment|/* XXX no rangecheck */
name|p
operator|+=
name|krb_get_int
argument_list|(
name|p
argument_list|,
operator|&
name|ad
operator|->
name|checksum
argument_list|,
literal|4
argument_list|,
name|little_endian
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
comment|/* time_5ms is not used */
name|p
operator|+=
name|krb_get_int
argument_list|(
name|p
argument_list|,
operator|&
name|r_time_sec
argument_list|,
literal|4
argument_list|,
name|little_endian
argument_list|)
expr_stmt|;
comment|/* Check for authenticity of the request */
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|krb_log
argument_list|(
literal|"Principal: %s.%s@%s / %s.%s@%s"
argument_list|,
name|ad
operator|->
name|pname
argument_list|,
name|ad
operator|->
name|pinst
argument_list|,
name|ad
operator|->
name|prealm
argument_list|,
name|r_aname
argument_list|,
name|r_inst
argument_list|,
name|r_realm
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ad
operator|->
name|pname
argument_list|,
name|r_aname
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|ad
operator|->
name|pinst
argument_list|,
name|r_inst
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|ad
operator|->
name|prealm
argument_list|,
name|r_realm
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|RD_AP_INCON
return|;
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|krb_log
argument_list|(
literal|"Address: %x %x"
argument_list|,
name|ad
operator|->
name|address
argument_list|,
name|from_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_addr
operator|&&
operator|(
operator|!
name|krb_equiv
argument_list|(
name|ad
operator|->
name|address
argument_list|,
name|from_addr
argument_list|)
operator|)
condition|)
return|return
name|RD_AP_BADD
return|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|delta_t
operator|=
name|abs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|tv
operator|.
name|tv_sec
operator|-
name|r_time_sec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta_t
operator|>
name|CLOCK_SKEW
condition|)
block|{
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|krb_log
argument_list|(
literal|"Time out of range: %lu - %lu = %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|t_local
operator|.
name|tv_sec
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|r_time_sec
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|delta_t
argument_list|)
expr_stmt|;
return|return
name|RD_AP_TIME
return|;
block|}
comment|/* Now check for expiration of ticket */
name|tkt_age
operator|=
name|tv
operator|.
name|tv_sec
operator|-
name|ad
operator|->
name|time_sec
expr_stmt|;
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|krb_log
argument_list|(
literal|"Time: %ld Issue Date: %lu Diff: %ld Life %x"
argument_list|,
operator|(
name|long
operator|)
name|tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ad
operator|->
name|time_sec
argument_list|,
name|tkt_age
argument_list|,
name|ad
operator|->
name|life
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tkt_age
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|-
name|tkt_age
operator|>
name|CLOCK_SKEW
operator|)
condition|)
return|return
name|RD_AP_NYV
return|;
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|>
name|krb_life_to_time
argument_list|(
name|ad
operator|->
name|time_sec
argument_list|,
name|ad
operator|->
name|life
argument_list|)
condition|)
return|return
name|RD_AP_EXP
return|;
comment|/* All seems OK */
name|ad
operator|->
name|reply
operator|.
name|length
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|RD_AP_OK
operator|)
return|;
block|}
end_function

end_unit

