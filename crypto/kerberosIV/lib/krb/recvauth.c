begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    Copyright (C) 1989 by the Massachusetts Institute of Technology     Export of this software from the United States of America is assumed    to require a specific license from the United States Government.    It is the responsibility of any person or organization contemplating    export to obtain such a license before exporting.  WITHIN THAT CONSTRAINT, permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.    */
end_comment

begin_include
include|#
directive|include
file|"krb_locl.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: recvauth.c,v 1.19 1998/06/09 19:25:25 joda Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * krb_recvauth() reads (and optionally responds to) a message sent  * using krb_sendauth().  The "options" argument is a bit-field of  * selected options (see "sendauth.c" for options description).  * The only option relevant to krb_recvauth() is KOPT_DO_MUTUAL  * (mutual authentication requested).  The "fd" argument supplies  * a file descriptor to read from (and write to, if mutual authenti-  * cation is requested).  *  * Part of the received message will be a Kerberos ticket sent by the  * client; this is read into the "ticket" argument.  The "service" and  * "instance" arguments supply the server's Kerberos name.  If the  * "instance" argument is the string "*", it is treated as a wild card  * and filled in during the krb_rd_req() call (see read_service_key()).  *  * The "faddr" and "laddr" give the sending (client) and receiving  * (local server) network addresses.  ("laddr" may be left NULL unless  * mutual authentication is requested, in which case it must be set.)  *  * The authentication information extracted from the message is returned  * in "kdata".  The "filename" argument indicates the file where the  * server's key can be found.  (It is passed on to krb_rd_req().)  If  * left null, the default "/etc/srvtab" will be used.  *  * If mutual authentication is requested, the session key schedule must  * be computed in order to reply; this schedule is returned in the  * "schedule" argument.  A string containing the application version  * number from the received message is returned in "version", which  * should be large enough to hold a KRB_SENDAUTH_VLEN-character string.  *  * See krb_sendauth() for the format of the received client message.  *  * krb_recvauth() first reads the protocol version string from the  * given file descriptor.  If it doesn't match the current protocol  * version (KRB_SENDAUTH_VERS), the old-style format is assumed.  In  * that case, the string of characters up to the first space is read  * and interpreted as the ticket length, then the ticket is read.  *  * If the first string did match KRB_SENDAUTH_VERS, krb_recvauth()  * next reads the application protocol version string.  Then the  * ticket length and ticket itself are read.  *  * The ticket is decrypted and checked by the call to krb_rd_req().  * If no mutual authentication is required, the result of the  * krb_rd_req() call is retured by this routine.  If mutual authenti-  * cation is required, a message in the following format is returned  * on "fd":  *  * Size			Variable		Field  * ----			--------		-----  *  * 4 bytes		tkt_len			length of ticket or -1  *						if error occurred  *  * priv_len		tmp_buf			"private" message created  *						by krb_mk_priv() which  *						contains the incremented  *						checksum sent by the client  *						encrypted in the session  *						key.  (This field is not  *						present in case of error.)  *  * If all goes well, KSUCCESS is returned; otherwise KFAILURE or some  * other error code is returned.  */
end_comment

begin_function
specifier|static
name|int
name|send_error_reply
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|unsigned
name|char
name|tmp
index|[
literal|4
index|]
init|=
block|{
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|}
decl_stmt|;
if|if
condition|(
name|krb_net_write
argument_list|(
name|fd
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|krb_recvauth
parameter_list|(
name|int32_t
name|options
parameter_list|,
comment|/* bit-pattern of options */
name|int
name|fd
parameter_list|,
comment|/* file descr. to read from */
name|KTEXT
name|ticket
parameter_list|,
comment|/* storage for client's ticket */
name|char
modifier|*
name|service
parameter_list|,
comment|/* service expected */
name|char
modifier|*
name|instance
parameter_list|,
comment|/* inst expected (may be filled in) */
name|struct
name|sockaddr_in
modifier|*
name|faddr
parameter_list|,
comment|/* address of foreign host on fd */
name|struct
name|sockaddr_in
modifier|*
name|laddr
parameter_list|,
comment|/* local address */
name|AUTH_DAT
modifier|*
name|kdata
parameter_list|,
comment|/* kerberos data (returned) */
name|char
modifier|*
name|filename
parameter_list|,
comment|/* name of file with service keys */
name|struct
name|des_ks_struct
modifier|*
name|schedule
parameter_list|,
comment|/* key schedule (return) */
name|char
modifier|*
name|version
parameter_list|)
comment|/* version string (filled in) */
block|{
name|int
name|cc
decl_stmt|;
name|char
name|krb_vers
index|[
name|KRB_SENDAUTH_VLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* + 1 for the null terminator */
name|int
name|rem
decl_stmt|;
name|int32_t
name|priv_len
decl_stmt|;
name|u_char
name|tmp_buf
index|[
name|MAX_KTXT_LEN
operator|+
name|max
argument_list|(
name|KRB_SENDAUTH_VLEN
operator|+
literal|1
argument_list|,
literal|21
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|KOPT_IGNORE_PROTOCOL
operator|)
condition|)
block|{
comment|/* read the protocol version number */
if|if
condition|(
name|krb_net_read
argument_list|(
name|fd
argument_list|,
name|krb_vers
argument_list|,
name|KRB_SENDAUTH_VLEN
argument_list|)
operator|!=
name|KRB_SENDAUTH_VLEN
condition|)
return|return
operator|(
name|errno
operator|)
return|;
name|krb_vers
index|[
name|KRB_SENDAUTH_VLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* read the application version string */
if|if
condition|(
name|krb_net_read
argument_list|(
name|fd
argument_list|,
name|version
argument_list|,
name|KRB_SENDAUTH_VLEN
argument_list|)
operator|!=
name|KRB_SENDAUTH_VLEN
condition|)
return|return
operator|(
name|errno
operator|)
return|;
name|version
index|[
name|KRB_SENDAUTH_VLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* get the length of the ticket */
block|{
name|char
name|tmp
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|krb_net_read
argument_list|(
name|fd
argument_list|,
name|tmp
argument_list|,
literal|4
argument_list|)
operator|!=
literal|4
condition|)
return|return
operator|-
literal|1
return|;
name|krb_get_int
argument_list|(
name|tmp
argument_list|,
operator|&
name|ticket
operator|->
name|length
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* sanity check */
if|if
condition|(
name|ticket
operator|->
name|length
operator|<=
literal|0
operator|||
name|ticket
operator|->
name|length
operator|>
name|MAX_KTXT_LEN
condition|)
block|{
if|if
condition|(
name|options
operator|&
name|KOPT_DO_MUTUAL
condition|)
block|{
if|if
condition|(
name|send_error_reply
argument_list|(
name|fd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|KFAILURE
return|;
block|}
else|else
return|return
name|KFAILURE
return|;
comment|/* XXX there may still be junk on the fd? */
block|}
comment|/* read the ticket */
if|if
condition|(
name|krb_net_read
argument_list|(
name|fd
argument_list|,
name|ticket
operator|->
name|dat
argument_list|,
name|ticket
operator|->
name|length
argument_list|)
operator|!=
name|ticket
operator|->
name|length
condition|)
return|return
operator|-
literal|1
return|;
comment|/*      * now have the ticket.  decrypt it to get the authenticated      * data.      */
name|rem
operator|=
name|krb_rd_req
argument_list|(
name|ticket
argument_list|,
name|service
argument_list|,
name|instance
argument_list|,
name|faddr
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|kdata
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* if we are doing mutual auth, compose a response */
if|if
condition|(
name|options
operator|&
name|KOPT_DO_MUTUAL
condition|)
block|{
if|if
condition|(
name|rem
operator|!=
name|KSUCCESS
condition|)
block|{
comment|/* the krb_rd_req failed */
if|if
condition|(
name|send_error_reply
argument_list|(
name|fd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|rem
return|;
block|}
comment|/* add one to the (formerly) sealed checksum, and re-seal it 	   for return to the client */
block|{
name|unsigned
name|char
name|cs
index|[
literal|4
index|]
decl_stmt|;
name|krb_put_int
argument_list|(
name|kdata
operator|->
name|checksum
operator|+
literal|1
argument_list|,
name|cs
argument_list|,
sizeof|sizeof
argument_list|(
name|cs
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOENCRYPTION
name|des_key_sched
argument_list|(
operator|&
name|kdata
operator|->
name|session
argument_list|,
name|schedule
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|priv_len
operator|=
name|krb_mk_priv
argument_list|(
name|cs
argument_list|,
name|tmp_buf
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
name|schedule
argument_list|,
operator|&
name|kdata
operator|->
name|session
argument_list|,
name|laddr
argument_list|,
name|faddr
argument_list|)
expr_stmt|;
block|}
comment|/* mk_priv will never fail */
name|priv_len
operator|+=
name|krb_put_int
argument_list|(
name|priv_len
argument_list|,
name|tmp_buf
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|=
name|krb_net_write
argument_list|(
name|fd
argument_list|,
name|tmp_buf
argument_list|,
name|priv_len
argument_list|)
operator|)
operator|!=
name|priv_len
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
name|rem
return|;
block|}
end_function

end_unit

