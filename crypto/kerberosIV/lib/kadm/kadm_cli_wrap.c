begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    Copyright (C) 1989 by the Massachusetts Institute of Technology     Export of this software from the United States of America is assumed    to require a specific license from the United States Government.    It is the responsibility of any person or organization contemplating    export to obtain such a license before exporting.  WITHIN THAT CONSTRAINT, permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.    */
end_comment

begin_comment
comment|/*  * Kerberos administration server client-side routines  */
end_comment

begin_comment
comment|/*  * kadm_cli_wrap.c the client side wrapping of the calls to the admin server   */
end_comment

begin_include
include|#
directive|include
file|"kadm_locl.h"
end_include

begin_comment
comment|/* RCSID("$Id: kadm_cli_wrap.c,v 1.27 1999/09/16 20:41:46 assar Exp $");*/
end_comment

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|Kadm_Client
name|client_parm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macros for use in returning data... used in kadm_cli_send */
end_comment

begin_define
define|#
directive|define
name|RET_N_FREE
parameter_list|(
name|r
parameter_list|)
value|{clear_secrets(); free(act_st); free(priv_pak); return r;}
end_define

begin_comment
comment|/* Keys for use in the transactions */
end_comment

begin_decl_stmt
specifier|static
name|des_cblock
name|sess_key
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to be filled in by kadm_cli_keyd */
end_comment

begin_decl_stmt
specifier|static
name|des_key_schedule
name|sess_sched
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|clear_secrets
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
name|sess_key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sess_key
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sess_sched
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sess_sched
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|RETSIGTYPE
function_decl|(
modifier|*
name|opipe
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|kadm_cli_disconn
parameter_list|(
name|void
parameter_list|)
block|{
name|close
argument_list|(
name|client_parm
operator|.
name|admin_fd
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|opipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * kadm_init_link  *	receives    : name, inst, realm  *  * initializes client parm, the Kadm_Client structure which holds the   * data about the connection between the server and client, the services   * used, the locations and other fun things   */
end_comment

begin_function
name|int
name|kadm_init_link
parameter_list|(
name|char
modifier|*
name|n
parameter_list|,
name|char
modifier|*
name|i
parameter_list|,
name|char
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hop
decl_stmt|;
comment|/* host we will talk to */
name|char
name|adm_hostname
index|[
name|MaxHostNameLen
index|]
decl_stmt|;
name|init_kadm_err_tbl
argument_list|()
expr_stmt|;
name|init_krb_err_tbl
argument_list|()
expr_stmt|;
name|strlcpy
argument_list|(
name|client_parm
operator|.
name|sname
argument_list|,
name|n
argument_list|,
name|ANAME_SZ
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|client_parm
operator|.
name|sinst
argument_list|,
name|i
argument_list|,
name|INST_SZ
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|client_parm
operator|.
name|krbrlm
argument_list|,
name|r
argument_list|,
name|REALM_SZ
argument_list|)
expr_stmt|;
name|client_parm
operator|.
name|admin_fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* set up the admin_addr - fetch name of admin host */
if|if
condition|(
name|krb_get_admhst
argument_list|(
name|adm_hostname
argument_list|,
name|client_parm
operator|.
name|krbrlm
argument_list|,
literal|1
argument_list|)
operator|!=
name|KSUCCESS
condition|)
return|return
name|KADM_NO_HOST
return|;
if|if
condition|(
operator|(
name|hop
operator|=
name|gethostbyname
argument_list|(
name|adm_hostname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|KADM_UNK_HOST
return|;
name|memset
argument_list|(
operator|&
name|client_parm
operator|.
name|admin_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|client_parm
operator|.
name|admin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|client_parm
operator|.
name|admin_addr
operator|.
name|sin_port
operator|=
name|k_getportbyname
argument_list|(
name|KADM_SNAME
argument_list|,
literal|"tcp"
argument_list|,
name|htons
argument_list|(
name|KADM_PORT
argument_list|)
argument_list|)
expr_stmt|;
name|client_parm
operator|.
name|admin_addr
operator|.
name|sin_family
operator|=
name|hop
operator|->
name|h_addrtype
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|client_parm
operator|.
name|admin_addr
operator|.
name|sin_addr
argument_list|,
name|hop
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|client_parm
operator|.
name|admin_addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|KADM_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kadm_cli_conn
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* this connects and sets my_addr */
name|client_parm
operator|.
name|admin_fd
operator|=
name|socket
argument_list|(
name|client_parm
operator|.
name|admin_addr
operator|.
name|sin_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_parm
operator|.
name|admin_fd
operator|<
literal|0
condition|)
return|return
name|KADM_NO_SOCK
return|;
comment|/* couldn't create the socket */
if|if
condition|(
name|connect
argument_list|(
name|client_parm
operator|.
name|admin_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|client_parm
operator|.
name|admin_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|client_parm
operator|.
name|admin_addr
argument_list|)
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|client_parm
operator|.
name|admin_fd
argument_list|)
expr_stmt|;
name|client_parm
operator|.
name|admin_fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|KADM_NO_CONN
return|;
comment|/* couldn't get the connect */
block|}
name|opipe
operator|=
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|client_parm
operator|.
name|my_addr_len
operator|=
sizeof|sizeof
argument_list|(
name|client_parm
operator|.
name|my_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|client_parm
operator|.
name|admin_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|client_parm
operator|.
name|my_addr
argument_list|,
operator|&
name|client_parm
operator|.
name|my_addr_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|client_parm
operator|.
name|admin_fd
argument_list|)
expr_stmt|;
name|client_parm
operator|.
name|admin_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|opipe
argument_list|)
expr_stmt|;
return|return
name|KADM_NO_HERE
return|;
comment|/* couldn't find out who we are */
block|}
if|#
directive|if
name|defined
argument_list|(
name|SO_KEEPALIVE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETSOCKOPT
argument_list|)
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|client_parm
operator|.
name|admin_fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|client_parm
operator|.
name|admin_fd
argument_list|)
expr_stmt|;
name|client_parm
operator|.
name|admin_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|opipe
argument_list|)
expr_stmt|;
return|return
name|KADM_NO_CONN
return|;
comment|/* XXX */
block|}
block|}
endif|#
directive|endif
return|return
name|KADM_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* takes in the sess_key and key_schedule and sets them appropriately */
end_comment

begin_decl_stmt
specifier|static
name|int
name|kadm_cli_keyd
argument_list|(
name|des_cblock
argument_list|(
operator|*
name|s_k
argument_list|)
argument_list|,
comment|/* session key */
expr|struct
name|des_ks_struct
operator|*
name|s_s
argument_list|)
comment|/* session key schedule */
block|{
name|CREDENTIALS
name|cred
decl_stmt|;
comment|/* to get key data */
name|int
name|stat
decl_stmt|;
comment|/* want .sname and .sinst here.... */
if|if
condition|(
operator|(
name|stat
operator|=
name|krb_get_cred
argument_list|(
name|client_parm
operator|.
name|sname
argument_list|,
name|client_parm
operator|.
name|sinst
argument_list|,
name|client_parm
operator|.
name|krbrlm
argument_list|,
operator|&
name|cred
argument_list|)
operator|)
condition|)
return|return
name|stat
operator|+
name|krb_err_base
return|;
name|memcpy
argument_list|(
name|s_k
argument_list|,
name|cred
operator|.
name|session
argument_list|,
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cred
operator|.
name|session
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOENCRYPTION
name|memset
argument_list|(
name|s_s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|des_key_schedule
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|stat
operator|=
name|des_key_sched
argument_list|(
name|s_k
argument_list|,
name|s_s
argument_list|)
operator|)
condition|)
return|return
name|stat
operator|+
name|krb_err_base
return|;
endif|#
directive|endif
return|return
name|KADM_SUCCESS
return|;
block|}
end_decl_stmt

begin_comment
comment|/* This code "works" */
end_comment

begin_function
specifier|static
name|int
name|kadm_cli_out
parameter_list|(
name|u_char
modifier|*
name|dat
parameter_list|,
name|int
name|dat_len
parameter_list|,
name|u_char
modifier|*
modifier|*
name|ret_dat
parameter_list|,
name|int
modifier|*
name|ret_siz
parameter_list|)
block|{
name|u_int16_t
name|dlen
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|char
name|tmp
index|[
literal|4
index|]
decl_stmt|;
operator|*
name|ret_dat
operator|=
name|NULL
expr_stmt|;
operator|*
name|ret_siz
operator|=
literal|0
expr_stmt|;
name|dlen
operator|=
operator|(
name|u_int16_t
operator|)
name|dat_len
expr_stmt|;
if|if
condition|(
name|dat_len
operator|!=
operator|(
name|int
operator|)
name|dlen
condition|)
return|return
operator|(
name|KADM_NO_ROOM
operator|)
return|;
name|tmp
index|[
literal|0
index|]
operator|=
operator|(
name|dlen
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
name|dlen
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|krb_net_write
argument_list|(
name|client_parm
operator|.
name|admin_fd
argument_list|,
name|tmp
argument_list|,
literal|2
argument_list|)
operator|!=
literal|2
condition|)
return|return
operator|(
name|errno
operator|)
return|;
comment|/* XXX */
if|if
condition|(
name|krb_net_write
argument_list|(
name|client_parm
operator|.
name|admin_fd
argument_list|,
name|dat
argument_list|,
name|dat_len
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|errno
operator|)
return|;
comment|/* XXX */
if|if
condition|(
operator|(
name|retval
operator|=
name|krb_net_read
argument_list|(
name|client_parm
operator|.
name|admin_fd
argument_list|,
name|tmp
argument_list|,
literal|2
argument_list|)
operator|)
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
return|return
operator|(
name|errno
operator|)
return|;
comment|/* XXX */
else|else
return|return
operator|(
name|EPIPE
operator|)
return|;
comment|/* short read ! */
block|}
name|dlen
operator|=
operator|(
name|tmp
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|tmp
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|ret_dat
operator|=
name|malloc
argument_list|(
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ret_dat
operator|==
name|NULL
condition|)
return|return
operator|(
name|KADM_NOMEM
operator|)
return|;
if|if
condition|(
operator|(
name|retval
operator|=
name|krb_net_read
argument_list|(
name|client_parm
operator|.
name|admin_fd
argument_list|,
operator|*
name|ret_dat
argument_list|,
name|dlen
argument_list|)
operator|!=
name|dlen
operator|)
condition|)
block|{
name|free
argument_list|(
operator|*
name|ret_dat
argument_list|)
expr_stmt|;
operator|*
name|ret_dat
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
return|return
operator|(
name|errno
operator|)
return|;
comment|/* XXX */
else|else
return|return
operator|(
name|EPIPE
operator|)
return|;
comment|/* short read ! */
block|}
operator|*
name|ret_siz
operator|=
operator|(
name|int
operator|)
name|dlen
expr_stmt|;
return|return
name|KADM_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * kadm_cli_send  *	recieves   : opcode, packet, packet length, serv_name, serv_inst  *	returns    : return code from the packet build, the server, or  *			 something else   *  * It assembles a packet as follows:  *	 8 bytes    : VERSION STRING  *	 4 bytes    : LENGTH OF MESSAGE DATA and OPCODE  *		    : KTEXT  *		    : OPCODE       \  *		    : DATA> Encrypted (with make priv)  *		    : ......       /   *  * If it builds the packet and it is small enough, then it attempts to open the  * connection to the admin server.  If the connection is succesfully open  * then it sends the data and waits for a reply.   */
end_comment

begin_function
specifier|static
name|int
name|kadm_cli_send
parameter_list|(
name|u_char
modifier|*
name|st_dat
parameter_list|,
comment|/* the actual data */
name|int
name|st_siz
parameter_list|,
comment|/* length of said data */
name|u_char
modifier|*
modifier|*
name|ret_dat
parameter_list|,
comment|/* to give return info */
name|int
modifier|*
name|ret_siz
parameter_list|)
comment|/* length of returned info */
block|{
name|int
name|act_len
decl_stmt|,
name|retdat
decl_stmt|;
comment|/* current offset into packet, return 				 * data */
name|KTEXT_ST
name|authent
decl_stmt|;
comment|/* the authenticator we will build */
name|u_char
modifier|*
name|act_st
decl_stmt|;
comment|/* the pointer to the complete packet */
name|u_char
modifier|*
name|priv_pak
decl_stmt|;
comment|/* private version of the packet */
name|int
name|priv_len
decl_stmt|;
comment|/* length of private packet */
name|u_int32_t
name|cksum
decl_stmt|;
comment|/* checksum of the packet */
name|MSG_DAT
name|mdat
decl_stmt|;
name|u_char
modifier|*
name|return_dat
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|void
modifier|*
name|tmp_ptr
decl_stmt|;
operator|*
name|ret_dat
operator|=
name|NULL
expr_stmt|;
operator|*
name|ret_siz
operator|=
literal|0
expr_stmt|;
name|act_st
operator|=
name|malloc
argument_list|(
name|KADM_VERSIZE
argument_list|)
expr_stmt|;
comment|/* verstr stored first */
if|if
condition|(
name|act_st
operator|==
name|NULL
condition|)
block|{
name|clear_secrets
argument_list|()
expr_stmt|;
return|return
name|KADM_NOMEM
return|;
block|}
name|memcpy
argument_list|(
name|act_st
argument_list|,
name|KADM_VERSTR
argument_list|,
name|KADM_VERSIZE
argument_list|)
expr_stmt|;
name|act_len
operator|=
name|KADM_VERSIZE
expr_stmt|;
if|if
condition|(
operator|(
name|retdat
operator|=
name|kadm_cli_keyd
argument_list|(
operator|&
name|sess_key
argument_list|,
name|sess_sched
argument_list|)
operator|)
operator|!=
name|KADM_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|act_st
argument_list|)
expr_stmt|;
name|clear_secrets
argument_list|()
expr_stmt|;
return|return
name|retdat
return|;
comment|/* couldnt get key working */
block|}
name|priv_pak
operator|=
name|malloc
argument_list|(
name|st_siz
operator|+
literal|200
argument_list|)
expr_stmt|;
comment|/* 200 bytes for extra info case */
if|if
condition|(
name|priv_pak
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|act_st
argument_list|)
expr_stmt|;
name|clear_secrets
argument_list|()
expr_stmt|;
return|return
name|KADM_NOMEM
return|;
block|}
name|priv_len
operator|=
name|krb_mk_priv
argument_list|(
name|st_dat
argument_list|,
name|priv_pak
argument_list|,
name|st_siz
argument_list|,
name|sess_sched
argument_list|,
operator|&
name|sess_key
argument_list|,
operator|&
name|client_parm
operator|.
name|my_addr
argument_list|,
operator|&
name|client_parm
operator|.
name|admin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv_len
operator|<
literal|0
condition|)
name|RET_N_FREE
argument_list|(
name|KADM_NO_ENCRYPT
argument_list|)
expr_stmt|;
comment|/* whoops... we got a lose 						 * here */
comment|/* here is the length of priv data.  receiver calcs 	 size of authenticator by subtracting vno size, priv size, and 	 sizeof(u_int32_t) (for the size indication) from total size */
name|tmp
operator|=
name|vts_long
argument_list|(
name|priv_len
argument_list|,
operator|&
name|act_st
argument_list|,
name|act_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
name|RET_N_FREE
argument_list|(
name|KADM_NOMEM
argument_list|)
expr_stmt|;
name|act_len
operator|+=
name|tmp
expr_stmt|;
ifdef|#
directive|ifdef
name|NOENCRYPTION
name|cksum
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|cksum
operator|=
name|des_quad_cksum
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|priv_pak
argument_list|,
operator|(
name|des_cblock
operator|*
operator|)
literal|0
argument_list|,
name|priv_len
argument_list|,
literal|0
argument_list|,
operator|&
name|sess_key
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|retdat
operator|=
name|krb_mk_req
argument_list|(
operator|&
name|authent
argument_list|,
name|client_parm
operator|.
name|sname
argument_list|,
name|client_parm
operator|.
name|sinst
argument_list|,
name|client_parm
operator|.
name|krbrlm
argument_list|,
name|cksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|retdat
condition|)
block|{
comment|/* authenticator? */
name|RET_N_FREE
argument_list|(
name|retdat
operator|+
name|krb_err_base
argument_list|)
expr_stmt|;
block|}
name|tmp_ptr
operator|=
name|realloc
argument_list|(
name|act_st
argument_list|,
name|act_len
operator|+
name|authent
operator|.
name|length
operator|+
name|priv_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_ptr
operator|==
name|NULL
condition|)
block|{
name|clear_secrets
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|priv_pak
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|act_st
argument_list|)
expr_stmt|;
return|return
name|KADM_NOMEM
return|;
block|}
name|act_st
operator|=
name|tmp_ptr
expr_stmt|;
name|memcpy
argument_list|(
name|act_st
operator|+
name|act_len
argument_list|,
name|authent
operator|.
name|dat
argument_list|,
name|authent
operator|.
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|act_st
operator|+
name|act_len
operator|+
name|authent
operator|.
name|length
argument_list|,
name|priv_pak
argument_list|,
name|priv_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|priv_pak
argument_list|)
expr_stmt|;
name|retdat
operator|=
name|kadm_cli_out
argument_list|(
name|act_st
argument_list|,
name|act_len
operator|+
name|authent
operator|.
name|length
operator|+
name|priv_len
argument_list|,
name|ret_dat
argument_list|,
name|ret_siz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|act_st
argument_list|)
expr_stmt|;
if|if
condition|(
name|retdat
operator|!=
name|KADM_SUCCESS
condition|)
block|{
name|clear_secrets
argument_list|()
expr_stmt|;
return|return
name|retdat
return|;
block|}
define|#
directive|define
name|RET_N_FREE2
parameter_list|(
name|r
parameter_list|)
value|{free(*ret_dat); *ret_dat = NULL; clear_secrets(); return(r);}
comment|/* first see if it's a YOULOUSE */
if|if
condition|(
operator|(
operator|*
name|ret_siz
operator|>=
name|KADM_VERSIZE
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|KADM_ULOSE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|*
name|ret_dat
argument_list|,
name|KADM_VERSIZE
argument_list|)
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* it's a youlose packet */
if|if
condition|(
operator|*
name|ret_siz
operator|<
name|KADM_VERSIZE
operator|+
literal|4
condition|)
name|RET_N_FREE2
argument_list|(
name|KADM_BAD_VER
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
operator|*
name|ret_dat
operator|)
operator|+
name|KADM_VERSIZE
expr_stmt|;
name|retdat
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|3
index|]
expr_stmt|;
name|RET_N_FREE2
argument_list|(
name|retdat
argument_list|)
expr_stmt|;
block|}
comment|/* need to decode the ret_dat */
name|retdat
operator|=
name|krb_rd_priv
argument_list|(
operator|*
name|ret_dat
argument_list|,
operator|(
name|u_int32_t
operator|)
operator|*
name|ret_siz
argument_list|,
name|sess_sched
argument_list|,
operator|&
name|sess_key
argument_list|,
operator|&
name|client_parm
operator|.
name|admin_addr
argument_list|,
operator|&
name|client_parm
operator|.
name|my_addr
argument_list|,
operator|&
name|mdat
argument_list|)
expr_stmt|;
if|if
condition|(
name|retdat
condition|)
name|RET_N_FREE2
argument_list|(
name|retdat
operator|+
name|krb_err_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdat
operator|.
name|app_length
operator|<
name|KADM_VERSIZE
operator|+
literal|4
condition|)
comment|/* too short! */
name|RET_N_FREE2
argument_list|(
name|KADM_BAD_VER
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mdat
operator|.
name|app_data
argument_list|,
name|KADM_VERSTR
argument_list|,
name|KADM_VERSIZE
argument_list|)
condition|)
comment|/* bad version */
name|RET_N_FREE2
argument_list|(
name|KADM_BAD_VER
argument_list|)
expr_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
name|mdat
operator|.
name|app_data
operator|+
name|KADM_VERSIZE
decl_stmt|;
name|retdat
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|3
index|]
expr_stmt|;
block|}
block|{
name|int
name|s
init|=
name|mdat
operator|.
name|app_length
operator|-
name|KADM_VERSIZE
operator|-
literal|4
decl_stmt|;
if|if
condition|(
name|s
operator|<=
literal|0
condition|)
name|s
operator|=
literal|1
expr_stmt|;
name|return_dat
operator|=
name|malloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_dat
operator|==
name|NULL
condition|)
name|RET_N_FREE2
argument_list|(
name|KADM_NOMEM
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|return_dat
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mdat
operator|.
name|app_data
operator|+
name|KADM_VERSIZE
operator|+
literal|4
argument_list|,
name|mdat
operator|.
name|app_length
operator|-
name|KADM_VERSIZE
operator|-
literal|4
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|ret_dat
argument_list|)
expr_stmt|;
name|clear_secrets
argument_list|()
expr_stmt|;
operator|*
name|ret_dat
operator|=
name|return_dat
expr_stmt|;
operator|*
name|ret_siz
operator|=
name|mdat
operator|.
name|app_length
operator|-
name|KADM_VERSIZE
operator|-
literal|4
expr_stmt|;
return|return
name|retdat
return|;
block|}
end_function

begin_comment
comment|/*   * kadm_change_pw_plain  *  * see kadm_change_pw  *  */
end_comment

begin_function
name|int
name|kadm_change_pw_plain
parameter_list|(
name|unsigned
name|char
modifier|*
name|newkey
parameter_list|,
name|char
modifier|*
name|password
parameter_list|,
name|char
modifier|*
modifier|*
name|pw_msg
parameter_list|)
block|{
name|int
name|stsize
decl_stmt|,
name|retc
decl_stmt|;
comment|/* stream size and return code */
name|u_char
modifier|*
name|send_st
decl_stmt|;
comment|/* send stream */
name|u_char
modifier|*
name|ret_st
decl_stmt|;
name|int
name|ret_sz
decl_stmt|;
name|int
name|status
decl_stmt|;
specifier|static
name|char
name|msg
index|[
literal|128
index|]
decl_stmt|;
comment|/* possible problem with vts_long on a non-multiple of four boundary */
name|stsize
operator|=
literal|0
expr_stmt|;
comment|/* start of our output packet */
name|send_st
operator|=
name|malloc
argument_list|(
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_st
operator|==
name|NULL
condition|)
return|return
name|KADM_NOMEM
return|;
name|send_st
index|[
name|stsize
operator|++
index|]
operator|=
operator|(
name|u_char
operator|)
name|CHANGE_PW
expr_stmt|;
name|memcpy
argument_list|(
name|send_st
operator|+
name|stsize
operator|+
literal|4
argument_list|,
name|newkey
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* yes, this is backwards */
name|memcpy
argument_list|(
name|send_st
operator|+
name|stsize
argument_list|,
name|newkey
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|stsize
operator|+=
literal|8
expr_stmt|;
comment|/* change key to stream */
if|if
condition|(
name|password
operator|&&
operator|*
name|password
condition|)
block|{
name|int
name|tmp
init|=
name|vts_string
argument_list|(
name|password
argument_list|,
operator|&
name|send_st
argument_list|,
name|stsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|send_st
argument_list|)
expr_stmt|;
return|return
name|KADM_NOMEM
return|;
block|}
name|stsize
operator|+=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|retc
operator|=
name|kadm_cli_conn
argument_list|()
operator|)
operator|!=
name|KADM_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|send_st
argument_list|)
expr_stmt|;
return|return
operator|(
name|retc
operator|)
return|;
block|}
name|retc
operator|=
name|kadm_cli_send
argument_list|(
name|send_st
argument_list|,
name|stsize
argument_list|,
operator|&
name|ret_st
argument_list|,
operator|&
name|ret_sz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|send_st
argument_list|)
expr_stmt|;
if|if
condition|(
name|retc
operator|!=
name|KADM_SUCCESS
condition|)
block|{
name|status
operator|=
name|stv_string
argument_list|(
name|ret_st
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|ret_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
name|msg
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|pw_msg
operator|=
name|msg
expr_stmt|;
block|}
name|free
argument_list|(
name|ret_st
argument_list|)
expr_stmt|;
name|kadm_cli_disconn
argument_list|()
expr_stmt|;
return|return
operator|(
name|retc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is here for compatibility with CNS  */
end_comment

begin_function
name|int
name|kadm_change_pw2
parameter_list|(
name|unsigned
name|char
modifier|*
name|newkey
parameter_list|,
name|char
modifier|*
name|password
parameter_list|,
name|char
modifier|*
modifier|*
name|pw_msg
parameter_list|)
block|{
return|return
name|kadm_change_pw_plain
argument_list|(
name|newkey
argument_list|,
name|password
argument_list|,
name|pw_msg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * kadm_change_pw  * recieves    : key   *  * Replaces the password (i.e. des key) of the caller with that specified in  * key. Returns no actual data from the master server, since this is called  * by a user   */
end_comment

begin_function
name|int
name|kadm_change_pw
parameter_list|(
name|unsigned
name|char
modifier|*
name|newkey
parameter_list|)
block|{
name|char
modifier|*
name|pw_msg
decl_stmt|;
return|return
name|kadm_change_pw_plain
argument_list|(
name|newkey
argument_list|,
literal|""
argument_list|,
operator|&
name|pw_msg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * kadm_add  * 	receives    : vals  * 	returns     : vals   *  * Adds and entry containing values to the database returns the values of the  * entry, so if you leave certain fields blank you will be able to determine  * the default values they are set to   */
end_comment

begin_function
name|int
name|kadm_add
parameter_list|(
name|Kadm_vals
modifier|*
name|vals
parameter_list|)
block|{
name|u_char
modifier|*
name|st
decl_stmt|,
modifier|*
name|st2
decl_stmt|;
comment|/* st will hold the stream of values */
name|int
name|st_len
decl_stmt|;
comment|/* st2 the final stream with opcode */
name|int
name|retc
decl_stmt|;
comment|/* return code from call */
name|u_char
modifier|*
name|ret_st
decl_stmt|;
name|int
name|ret_sz
decl_stmt|;
name|st_len
operator|=
name|vals_to_stream
argument_list|(
name|vals
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|st2
operator|=
name|malloc
argument_list|(
literal|1
operator|+
name|st_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|st2
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return
name|KADM_NOMEM
return|;
block|}
operator|*
name|st2
operator|=
operator|(
name|u_char
operator|)
name|ADD_ENT
expr_stmt|;
comment|/* here's the opcode */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|st2
operator|+
literal|1
argument_list|,
name|st
argument_list|,
name|st_len
argument_list|)
expr_stmt|;
comment|/* append st on */
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retc
operator|=
name|kadm_cli_conn
argument_list|()
operator|)
operator|!=
name|KADM_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|st2
argument_list|)
expr_stmt|;
return|return
operator|(
name|retc
operator|)
return|;
block|}
name|retc
operator|=
name|kadm_cli_send
argument_list|(
name|st2
argument_list|,
name|st_len
operator|+
literal|1
argument_list|,
operator|&
name|ret_st
argument_list|,
operator|&
name|ret_sz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|st2
argument_list|)
expr_stmt|;
if|if
condition|(
name|retc
operator|==
name|KADM_SUCCESS
condition|)
block|{
comment|/* ret_st has vals */
if|if
condition|(
name|stream_to_vals
argument_list|(
name|ret_st
argument_list|,
name|vals
argument_list|,
name|ret_sz
argument_list|)
operator|<
literal|0
condition|)
name|retc
operator|=
name|KADM_LENGTH_ERROR
expr_stmt|;
block|}
name|free
argument_list|(
name|ret_st
argument_list|)
expr_stmt|;
name|kadm_cli_disconn
argument_list|()
expr_stmt|;
return|return
operator|(
name|retc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * kadm_mod  * 	receives    : KTEXT, {values, values}  *	returns     : CKSUM,  RETCODE, {values}   *	acl         : su, sms (as register or dealloc)   *  * Modifies all entries corresponding to the first values so they match the  * second values. returns the values for the changed entries in vals2  */
end_comment

begin_function
name|int
name|kadm_mod
parameter_list|(
name|Kadm_vals
modifier|*
name|vals1
parameter_list|,
name|Kadm_vals
modifier|*
name|vals2
parameter_list|)
block|{
name|u_char
modifier|*
name|st
decl_stmt|,
modifier|*
name|st2
decl_stmt|;
comment|/* st will hold the stream of values */
name|int
name|st_len
decl_stmt|,
name|nlen
decl_stmt|;
comment|/* st2 the final stream with opcode */
name|u_char
modifier|*
name|ret_st
decl_stmt|;
name|int
name|ret_sz
decl_stmt|;
name|void
modifier|*
name|tmp_ptr
decl_stmt|;
comment|/* nlen is the length of second vals */
name|int
name|retc
decl_stmt|;
comment|/* return code from call */
name|st_len
operator|=
name|vals_to_stream
argument_list|(
name|vals1
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|st2
operator|=
name|malloc
argument_list|(
literal|1
operator|+
name|st_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|st2
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return
name|KADM_NOMEM
return|;
block|}
operator|*
name|st2
operator|=
operator|(
name|u_char
operator|)
name|MOD_ENT
expr_stmt|;
comment|/* here's the opcode */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|st2
operator|+
literal|1
argument_list|,
name|st
argument_list|,
name|st_len
operator|++
argument_list|)
expr_stmt|;
comment|/* append st on */
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|nlen
operator|=
name|vals_to_stream
argument_list|(
name|vals2
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|tmp_ptr
operator|=
name|realloc
argument_list|(
name|st2
argument_list|,
name|st_len
operator|+
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_ptr
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|st2
argument_list|)
expr_stmt|;
return|return
name|KADM_NOMEM
return|;
block|}
name|st2
operator|=
name|tmp_ptr
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|st2
operator|+
name|st_len
argument_list|,
name|st
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
comment|/* append st on */
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retc
operator|=
name|kadm_cli_conn
argument_list|()
operator|)
operator|!=
name|KADM_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|st2
argument_list|)
expr_stmt|;
return|return
operator|(
name|retc
operator|)
return|;
block|}
name|retc
operator|=
name|kadm_cli_send
argument_list|(
name|st2
argument_list|,
name|st_len
operator|+
name|nlen
argument_list|,
operator|&
name|ret_st
argument_list|,
operator|&
name|ret_sz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|st2
argument_list|)
expr_stmt|;
if|if
condition|(
name|retc
operator|==
name|KADM_SUCCESS
condition|)
block|{
comment|/* ret_st has vals */
if|if
condition|(
name|stream_to_vals
argument_list|(
name|ret_st
argument_list|,
name|vals2
argument_list|,
name|ret_sz
argument_list|)
operator|<
literal|0
condition|)
name|retc
operator|=
name|KADM_LENGTH_ERROR
expr_stmt|;
block|}
name|free
argument_list|(
name|ret_st
argument_list|)
expr_stmt|;
name|kadm_cli_disconn
argument_list|()
expr_stmt|;
return|return
operator|(
name|retc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kadm_del
parameter_list|(
name|Kadm_vals
modifier|*
name|vals
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|st
decl_stmt|,
modifier|*
name|st2
decl_stmt|;
comment|/* st will hold the stream of values */
name|int
name|st_len
decl_stmt|;
comment|/* st2 the final stream with opcode */
name|int
name|retc
decl_stmt|;
comment|/* return code from call */
name|u_char
modifier|*
name|ret_st
decl_stmt|;
name|int
name|ret_sz
decl_stmt|;
name|st_len
operator|=
name|vals_to_stream
argument_list|(
name|vals
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|st2
operator|=
name|malloc
argument_list|(
name|st_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|st2
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return
name|KADM_NOMEM
return|;
block|}
operator|*
name|st2
operator|=
name|DEL_ENT
expr_stmt|;
comment|/* here's the opcode */
name|memcpy
argument_list|(
name|st2
operator|+
literal|1
argument_list|,
name|st
argument_list|,
name|st_len
argument_list|)
expr_stmt|;
comment|/* append st on */
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retc
operator|=
name|kadm_cli_conn
argument_list|()
operator|)
operator|!=
name|KADM_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|st2
argument_list|)
expr_stmt|;
return|return
operator|(
name|retc
operator|)
return|;
block|}
name|retc
operator|=
name|kadm_cli_send
argument_list|(
name|st2
argument_list|,
name|st_len
operator|+
literal|1
argument_list|,
operator|&
name|ret_st
argument_list|,
operator|&
name|ret_sz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|st2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret_st
argument_list|)
expr_stmt|;
name|kadm_cli_disconn
argument_list|()
expr_stmt|;
return|return
operator|(
name|retc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * kadm_get  * 	receives   : KTEXT, {values, flags}   *	returns    : CKSUM, RETCODE, {count, values, values, values}  *	acl        : su   *  * gets the fields requested by flags from all entries matching values returns  * this data for each matching recipient, after a count of how many such  * matches there were   */
end_comment

begin_function
name|int
name|kadm_get
parameter_list|(
name|Kadm_vals
modifier|*
name|vals
parameter_list|,
name|u_char
modifier|*
name|fl
parameter_list|)
block|{
name|int
name|loop
decl_stmt|;
comment|/* for copying the fields data */
name|u_char
modifier|*
name|st
decl_stmt|,
modifier|*
name|st2
decl_stmt|;
comment|/* st will hold the stream of values */
name|int
name|st_len
decl_stmt|;
comment|/* st2 the final stream with opcode */
name|int
name|retc
decl_stmt|;
comment|/* return code from call */
name|u_char
modifier|*
name|ret_st
decl_stmt|;
name|int
name|ret_sz
decl_stmt|;
name|st_len
operator|=
name|vals_to_stream
argument_list|(
name|vals
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|st2
operator|=
name|malloc
argument_list|(
literal|1
operator|+
name|st_len
operator|+
name|FLDSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|st2
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return
name|KADM_NOMEM
return|;
block|}
operator|*
name|st2
operator|=
operator|(
name|u_char
operator|)
name|GET_ENT
expr_stmt|;
comment|/* here's the opcode */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|st2
operator|+
literal|1
argument_list|,
name|st
argument_list|,
name|st_len
argument_list|)
expr_stmt|;
comment|/* append st on */
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
name|FLDSZ
operator|-
literal|1
init|;
name|loop
operator|>=
literal|0
condition|;
name|loop
operator|--
control|)
operator|*
operator|(
name|st2
operator|+
name|st_len
operator|+
name|FLDSZ
operator|-
name|loop
operator|)
operator|=
name|fl
index|[
name|loop
index|]
expr_stmt|;
comment|/* append the flags */
if|if
condition|(
operator|(
name|retc
operator|=
name|kadm_cli_conn
argument_list|()
operator|)
operator|!=
name|KADM_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|st2
argument_list|)
expr_stmt|;
return|return
operator|(
name|retc
operator|)
return|;
block|}
name|retc
operator|=
name|kadm_cli_send
argument_list|(
name|st2
argument_list|,
name|st_len
operator|+
literal|1
operator|+
name|FLDSZ
argument_list|,
operator|&
name|ret_st
argument_list|,
operator|&
name|ret_sz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|st2
argument_list|)
expr_stmt|;
if|if
condition|(
name|retc
operator|==
name|KADM_SUCCESS
condition|)
block|{
comment|/* ret_st has vals */
if|if
condition|(
name|stream_to_vals
argument_list|(
name|ret_st
argument_list|,
name|vals
argument_list|,
name|ret_sz
argument_list|)
operator|<
literal|0
condition|)
name|retc
operator|=
name|KADM_LENGTH_ERROR
expr_stmt|;
block|}
name|free
argument_list|(
name|ret_st
argument_list|)
expr_stmt|;
name|kadm_cli_disconn
argument_list|()
expr_stmt|;
return|return
operator|(
name|retc
operator|)
return|;
block|}
end_function

end_unit

