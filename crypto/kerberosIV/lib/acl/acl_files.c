begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    Copyright (C) 1989 by the Massachusetts Institute of Technology     Export of this software from the United States of America is assumed    to require a specific license from the United States Government.    It is the responsibility of any person or organization contemplating    export to obtain such a license before exporting.  WITHIN THAT CONSTRAINT, permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.    */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"protos.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: acl_files.c,v 1.14 1999/09/16 20:41:43 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FCNTL_H
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_FILE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<roken.h>
end_include

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<acl.h>
end_include

begin_comment
comment|/*** Routines for manipulating access control list files ***/
end_comment

begin_comment
comment|/* "aname.inst@realm" */
end_comment

begin_define
define|#
directive|define
name|MAX_PRINCIPAL_SIZE
value|(ANAME_SZ + INST_SZ + REALM_SZ + 3)
end_define

begin_define
define|#
directive|define
name|INST_SEP
value|'.'
end_define

begin_define
define|#
directive|define
name|REALM_SEP
value|'@'
end_define

begin_define
define|#
directive|define
name|LINESIZE
value|2048
end_define

begin_comment
comment|/* Maximum line length in an acl file */
end_comment

begin_define
define|#
directive|define
name|NEW_FILE
value|"%s.~NEWACL~"
end_define

begin_comment
comment|/* Format for name of altered acl file */
end_comment

begin_define
define|#
directive|define
name|WAIT_TIME
value|300
end_define

begin_comment
comment|/* Maximum time allowed write acl file */
end_comment

begin_define
define|#
directive|define
name|CACHED_ACLS
value|8
end_define

begin_comment
comment|/* How many acls to cache */
end_comment

begin_comment
comment|/* Each acl costs 1 open file descriptor */
end_comment

begin_define
define|#
directive|define
name|ACL_LEN
value|16
end_define

begin_comment
comment|/* Twice a reasonable acl length */
end_comment

begin_define
define|#
directive|define
name|COR
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a!=NULL)?(a):(b))
end_define

begin_comment
comment|/*  * Canonicalize a principal name.  * If instance is missing, it becomes ""  * If realm is missing, it becomes the local realm  * Canonicalized form is put in canon, which must be big enough to  * hold MAX_PRINCIPAL_SIZE characters  *  */
end_comment

begin_function
name|void
name|acl_canonicalize_principal
parameter_list|(
name|char
modifier|*
name|principal
parameter_list|,
name|char
modifier|*
name|canon
parameter_list|)
block|{
name|krb_principal
name|princ
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|krb_parse_name
argument_list|(
name|principal
argument_list|,
operator|&
name|princ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* ? */
operator|*
name|canon
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|princ
operator|.
name|realm
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|krb_get_lrealm
argument_list|(
name|princ
operator|.
name|realm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|krb_unparse_name_r
argument_list|(
operator|&
name|princ
argument_list|,
name|canon
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a lock to modify acl_file */
end_comment

begin_comment
comment|/* Return new FILE pointer */
end_comment

begin_comment
comment|/* or NULL if file cannot be modified */
end_comment

begin_comment
comment|/* REQUIRES WRITE PERMISSION TO CONTAINING DIRECTORY */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|acl_lock_file
parameter_list|(
name|char
modifier|*
name|acl_file
parameter_list|)
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|char
name|new
index|[
name|LINESIZE
index|]
decl_stmt|;
name|int
name|nfd
decl_stmt|;
name|FILE
modifier|*
name|nf
decl_stmt|;
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|acl_file
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mode
operator|=
name|s
operator|.
name|st_mode
expr_stmt|;
name|snprintf
argument_list|(
name|new
argument_list|,
sizeof|sizeof
argument_list|(
name|new
argument_list|)
argument_list|,
name|NEW_FILE
argument_list|,
name|acl_file
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Open the new file */
if|if
condition|(
operator|(
name|nfd
operator|=
name|open
argument_list|(
name|new
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|mode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
block|{
comment|/* Maybe somebody got here already, maybe it's just old */
if|if
condition|(
name|stat
argument_list|(
name|new
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|time
argument_list|(
literal|0
argument_list|)
operator|-
name|s
operator|.
name|st_ctime
operator|>
name|WAIT_TIME
condition|)
block|{
comment|/* File is stale, kill it */
name|unlink
argument_list|(
name|new
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* Wait and try again */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/* Some other error, we lose */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* If we got to here, the lock file is ours and ok */
comment|/* Reopen it under stdio */
if|if
condition|(
operator|(
name|nf
operator|=
name|fdopen
argument_list|(
name|nfd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Oops, clean up */
name|unlink
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nf
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Abort changes to acl_file written onto FILE *f */
end_comment

begin_comment
comment|/* Returns 0 if successful,< 0 otherwise */
end_comment

begin_comment
comment|/* Closes f */
end_comment

begin_function
specifier|static
name|int
name|acl_abort
parameter_list|(
name|char
modifier|*
name|acl_file
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|char
name|new
index|[
name|LINESIZE
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
comment|/* make sure we aren't nuking someone else's file */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
operator|||
name|s
operator|.
name|st_nlink
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|new
argument_list|,
sizeof|sizeof
argument_list|(
name|new
argument_list|)
argument_list|,
name|NEW_FILE
argument_list|,
name|acl_file
argument_list|)
expr_stmt|;
name|ret
operator|=
name|unlink
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Commit changes to acl_file written onto FILE *f */
end_comment

begin_comment
comment|/* Returns zero if successful */
end_comment

begin_comment
comment|/* Returns> 0 if lock was broken */
end_comment

begin_comment
comment|/* Returns< 0 if some other error occurs */
end_comment

begin_comment
comment|/* Closes f */
end_comment

begin_function
specifier|static
name|int
name|acl_commit
parameter_list|(
name|char
modifier|*
name|acl_file
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|char
name|new
index|[
name|LINESIZE
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|snprintf
argument_list|(
name|new
argument_list|,
sizeof|sizeof
argument_list|(
name|new
argument_list|)
argument_list|,
name|NEW_FILE
argument_list|,
name|acl_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|f
argument_list|)
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
operator|||
name|s
operator|.
name|st_nlink
operator|==
literal|0
condition|)
block|{
name|acl_abort
argument_list|(
name|acl_file
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|rename
argument_list|(
name|new
argument_list|,
name|acl_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize an acl_file */
end_comment

begin_comment
comment|/* Creates the file with permissions perm if it does not exist */
end_comment

begin_comment
comment|/* Erases it if it does */
end_comment

begin_comment
comment|/* Returns return value of acl_commit */
end_comment

begin_function
name|int
name|acl_initialize
parameter_list|(
name|char
modifier|*
name|acl_file
parameter_list|,
name|int
name|perm
parameter_list|)
block|{
name|FILE
modifier|*
name|new
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* Check if the file exists already */
if|if
condition|(
operator|(
name|new
operator|=
name|acl_lock_file
argument_list|(
name|acl_file
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|acl_commit
argument_list|(
name|acl_file
argument_list|,
name|new
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* File must be readable and writable by owner */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|acl_file
argument_list|,
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|perm
operator||
literal|0600
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Eliminate all whitespace character in buf */
end_comment

begin_comment
comment|/* Modifies its argument */
end_comment

begin_function
specifier|static
name|void
name|nuke_whitespace
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|pin
decl_stmt|,
modifier|*
name|pout
decl_stmt|;
for|for
control|(
name|pin
operator|=
name|pout
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
init|;
operator|*
name|pin
operator|!=
literal|'\0'
condition|;
name|pin
operator|++
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|pin
argument_list|)
condition|)
operator|*
name|pout
operator|++
operator|=
operator|*
name|pin
expr_stmt|;
operator|*
name|pout
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate the string */
block|}
end_function

begin_comment
comment|/* Hash table stuff */
end_comment

begin_struct
struct|struct
name|hashtbl
block|{
name|int
name|size
decl_stmt|;
comment|/* Max number of entries */
name|int
name|entries
decl_stmt|;
comment|/* Actual number of entries */
name|char
modifier|*
modifier|*
name|tbl
decl_stmt|;
comment|/* Pointer to start of table */
block|}
struct|;
end_struct

begin_comment
comment|/* Make an empty hash table of size s */
end_comment

begin_function
specifier|static
name|struct
name|hashtbl
modifier|*
name|make_hash
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|struct
name|hashtbl
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|hashtbl
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hashtbl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|h
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|h
operator|->
name|entries
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|tbl
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|tbl
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Destroy a hash table */
end_comment

begin_function
specifier|static
name|void
name|destroy_hash
parameter_list|(
name|struct
name|hashtbl
modifier|*
name|h
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|h
operator|->
name|tbl
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|h
operator|->
name|tbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|h
operator|->
name|tbl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute hash value for a string */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hashval
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|hv
decl_stmt|;
for|for
control|(
name|hv
operator|=
literal|0
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
name|hv
operator|^=
operator|(
operator|(
name|hv
operator|<<
literal|3
operator|)
operator|^
operator|*
name|s
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|hv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add an element to a hash table */
end_comment

begin_function
specifier|static
name|void
name|add_hash
parameter_list|(
name|struct
name|hashtbl
modifier|*
name|h
parameter_list|,
name|char
modifier|*
name|el
parameter_list|)
block|{
name|unsigned
name|hv
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
modifier|*
name|old
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Make space if it isn't there already */
if|if
condition|(
name|h
operator|->
name|entries
operator|+
literal|1
operator|>
operator|(
name|h
operator|->
name|size
operator|>>
literal|1
operator|)
condition|)
block|{
name|old
operator|=
name|h
operator|->
name|tbl
expr_stmt|;
name|h
operator|->
name|tbl
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|h
operator|->
name|size
operator|<<
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|old
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|hv
operator|=
name|hashval
argument_list|(
name|old
index|[
name|i
index|]
argument_list|)
operator|%
operator|(
name|h
operator|->
name|size
operator|<<
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|tbl
index|[
name|hv
index|]
operator|!=
name|NULL
condition|)
name|hv
operator|=
operator|(
name|hv
operator|+
literal|1
operator|)
operator|%
operator|(
name|h
operator|->
name|size
operator|<<
literal|1
operator|)
expr_stmt|;
name|h
operator|->
name|tbl
index|[
name|hv
index|]
operator|=
name|old
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|h
operator|->
name|size
operator|=
name|h
operator|->
name|size
operator|<<
literal|1
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
name|hv
operator|=
name|hashval
argument_list|(
name|el
argument_list|)
operator|%
name|h
operator|->
name|size
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|tbl
index|[
name|hv
index|]
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|tbl
index|[
name|hv
index|]
argument_list|,
name|el
argument_list|)
condition|)
name|hv
operator|=
operator|(
name|hv
operator|+
literal|1
operator|)
operator|%
name|h
operator|->
name|size
expr_stmt|;
name|s
operator|=
name|strdup
argument_list|(
name|el
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|tbl
index|[
name|hv
index|]
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|entries
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns nonzero if el is in h */
end_comment

begin_function
specifier|static
name|int
name|check_hash
parameter_list|(
name|struct
name|hashtbl
modifier|*
name|h
parameter_list|,
name|char
modifier|*
name|el
parameter_list|)
block|{
name|unsigned
name|hv
decl_stmt|;
for|for
control|(
name|hv
operator|=
name|hashval
argument_list|(
name|el
argument_list|)
operator|%
name|h
operator|->
name|size
init|;
name|h
operator|->
name|tbl
index|[
name|hv
index|]
operator|!=
name|NULL
condition|;
name|hv
operator|=
operator|(
name|hv
operator|+
literal|1
operator|)
operator|%
name|h
operator|->
name|size
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|h
operator|->
name|tbl
index|[
name|hv
index|]
argument_list|,
name|el
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|acl
block|{
name|char
name|filename
index|[
name|LINESIZE
index|]
decl_stmt|;
comment|/* Name of acl file */
name|int
name|fd
decl_stmt|;
comment|/* File descriptor for acl file */
name|struct
name|stat
name|status
decl_stmt|;
comment|/* File status at last read */
name|struct
name|hashtbl
modifier|*
name|acl
decl_stmt|;
comment|/* Acl entries */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|acl
name|acl_cache
index|[
name|CACHED_ACLS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|acl_cache_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|acl_cache_next
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns< 0 if unsuccessful in loading acl */
end_comment

begin_comment
comment|/* Returns index into acl_cache otherwise */
end_comment

begin_comment
comment|/* Note that if acl is already loaded, this is just a lookup */
end_comment

begin_function
specifier|static
name|int
name|acl_load
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|char
name|buf
index|[
name|MAX_PRINCIPAL_SIZE
index|]
decl_stmt|;
name|char
name|canon
index|[
name|MAX_PRINCIPAL_SIZE
index|]
decl_stmt|;
comment|/* See if it's there already */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl_cache_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|filename
argument_list|,
name|name
argument_list|)
operator|&&
name|acl_cache
index|[
name|i
index|]
operator|.
name|fd
operator|>=
literal|0
condition|)
goto|goto
name|got_it
goto|;
block|}
comment|/* It isn't, load it in */
comment|/* maybe there's still room */
if|if
condition|(
name|acl_cache_count
operator|<
name|CACHED_ACLS
condition|)
block|{
name|i
operator|=
name|acl_cache_count
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* No room, clean one out */
name|i
operator|=
name|acl_cache_next
expr_stmt|;
name|acl_cache_next
operator|=
operator|(
name|acl_cache_next
operator|+
literal|1
operator|)
operator|%
name|CACHED_ACLS
expr_stmt|;
name|close
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
condition|)
block|{
name|destroy_hash
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
argument_list|)
expr_stmt|;
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
operator|=
operator|(
expr|struct
name|hashtbl
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
comment|/* Set up the acl */
name|strlcpy
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|filename
argument_list|,
name|name
argument_list|,
name|LINESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Force reload */
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
operator|=
operator|(
expr|struct
name|hashtbl
operator|*
operator|)
literal|0
expr_stmt|;
name|got_it
label|:
comment|/*      * See if the stat matches      *      * Use stat(), not fstat(), as the file may have been re-created by      * acl_add or acl_delete.  If this happens, the old inode will have      * no changes in the mod-time and the following test will fail.      */
if|if
condition|(
name|stat
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|filename
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
operator|==
operator|(
expr|struct
name|hashtbl
operator|*
operator|)
literal|0
operator|||
name|s
operator|.
name|st_nlink
operator|!=
name|acl_cache
index|[
name|i
index|]
operator|.
name|status
operator|.
name|st_nlink
operator|||
name|s
operator|.
name|st_mtime
operator|!=
name|acl_cache
index|[
name|i
index|]
operator|.
name|status
operator|.
name|st_mtime
operator|||
name|s
operator|.
name|st_ctime
operator|!=
name|acl_cache
index|[
name|i
index|]
operator|.
name|status
operator|.
name|st_ctime
condition|)
block|{
comment|/* Gotta reload */
if|if
condition|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|f
operator|=
name|fdopen
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
condition|)
name|destroy_hash
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
argument_list|)
expr_stmt|;
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
operator|=
name|make_hash
argument_list|(
name|ACL_LEN
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|nuke_whitespace
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|acl_canonicalize_principal
argument_list|(
name|buf
argument_list|,
name|canon
argument_list|)
expr_stmt|;
name|add_hash
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
argument_list|,
name|canon
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|acl_cache
index|[
name|i
index|]
operator|.
name|status
operator|=
name|s
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if it can be determined that acl contains principal */
end_comment

begin_comment
comment|/* Principal is not canonicalized, and no wildcarding is done */
end_comment

begin_function
name|int
name|acl_exact_match
parameter_list|(
name|char
modifier|*
name|acl
parameter_list|,
name|char
modifier|*
name|principal
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
return|return
operator|(
operator|(
name|idx
operator|=
name|acl_load
argument_list|(
name|acl
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|check_hash
argument_list|(
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
argument_list|,
name|principal
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if it can be determined that acl contains principal */
end_comment

begin_comment
comment|/* Recognizes wildcards in acl of the form    name.*@realm, *.*@realm, and *.*@* */
end_comment

begin_function
name|int
name|acl_check
parameter_list|(
name|char
modifier|*
name|acl
parameter_list|,
name|char
modifier|*
name|principal
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAX_PRINCIPAL_SIZE
index|]
decl_stmt|;
name|char
name|canon
index|[
name|MAX_PRINCIPAL_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|realm
decl_stmt|;
name|acl_canonicalize_principal
argument_list|(
name|principal
argument_list|,
name|canon
argument_list|)
expr_stmt|;
comment|/* Is it there? */
if|if
condition|(
name|acl_exact_match
argument_list|(
name|acl
argument_list|,
name|canon
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Try the wildcards */
name|realm
operator|=
name|strchr
argument_list|(
name|canon
argument_list|,
name|REALM_SEP
argument_list|)
expr_stmt|;
operator|*
name|strchr
argument_list|(
name|canon
argument_list|,
name|INST_SEP
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* Chuck the instance */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s.*%s"
argument_list|,
name|canon
argument_list|,
name|realm
argument_list|)
expr_stmt|;
if|if
condition|(
name|acl_exact_match
argument_list|(
name|acl
argument_list|,
name|buf
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"*.*%s"
argument_list|,
name|realm
argument_list|)
expr_stmt|;
if|if
condition|(
name|acl_exact_match
argument_list|(
name|acl
argument_list|,
name|buf
argument_list|)
operator|||
name|acl_exact_match
argument_list|(
name|acl
argument_list|,
literal|"*.*@*"
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Adds principal to acl */
end_comment

begin_comment
comment|/* Wildcards are interpreted literally */
end_comment

begin_function
name|int
name|acl_add
parameter_list|(
name|char
modifier|*
name|acl
parameter_list|,
name|char
modifier|*
name|principal
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|new
decl_stmt|;
name|char
name|canon
index|[
name|MAX_PRINCIPAL_SIZE
index|]
decl_stmt|;
name|acl_canonicalize_principal
argument_list|(
name|principal
argument_list|,
name|canon
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|acl_lock_file
argument_list|(
name|acl
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|acl_exact_match
argument_list|(
name|acl
argument_list|,
name|canon
argument_list|)
operator|)
operator|||
operator|(
name|idx
operator|=
name|acl_load
argument_list|(
name|acl
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|acl_abort
argument_list|(
name|acl
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* It isn't there yet, copy the file and put it in */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
operator|->
name|tbl
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fputs
argument_list|(
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
operator|->
name|tbl
index|[
name|i
index|]
argument_list|,
name|new
argument_list|)
operator|==
name|EOF
operator|||
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|new
argument_list|)
operator|!=
literal|'\n'
condition|)
block|{
name|acl_abort
argument_list|(
name|acl
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
name|fputs
argument_list|(
name|canon
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
name|acl_commit
argument_list|(
name|acl
argument_list|,
name|new
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Removes principal from acl */
end_comment

begin_comment
comment|/* Wildcards are interpreted literally */
end_comment

begin_function
name|int
name|acl_delete
parameter_list|(
name|char
modifier|*
name|acl
parameter_list|,
name|char
modifier|*
name|principal
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|new
decl_stmt|;
name|char
name|canon
index|[
name|MAX_PRINCIPAL_SIZE
index|]
decl_stmt|;
name|acl_canonicalize_principal
argument_list|(
name|principal
argument_list|,
name|canon
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|acl_lock_file
argument_list|(
name|acl
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
operator|!
name|acl_exact_match
argument_list|(
name|acl
argument_list|,
name|canon
argument_list|)
operator|)
operator|||
operator|(
name|idx
operator|=
name|acl_load
argument_list|(
name|acl
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|acl_abort
argument_list|(
name|acl
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* It isn't there yet, copy the file and put it in */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
operator|->
name|tbl
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
operator|->
name|tbl
index|[
name|i
index|]
argument_list|,
name|canon
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
operator|->
name|tbl
index|[
name|i
index|]
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|acl_commit
argument_list|(
name|acl
argument_list|,
name|new
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

