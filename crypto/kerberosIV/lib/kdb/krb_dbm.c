begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    Copyright (C) 1989 by the Massachusetts Institute of Technology     Export of this software from the United States of America is assumed    to require a specific license from the United States Government.    It is the responsibility of any person or organization contemplating    export to obtain such a license before exporting.  WITHIN THAT CONSTRAINT, permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.    */
end_comment

begin_include
include|#
directive|include
file|"kdb_locl.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: krb_dbm.c,v 1.37 1999/09/16 20:41:49 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<xdbm.h>
end_include

begin_define
define|#
directive|define
name|KERB_DB_MAX_RETRY
value|5
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|kerb_debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|init
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|default_db_name
index|[]
init|=
name|DBM_FILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|current_db_name
init|=
name|default_db_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|timestamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current time of request */
end_comment

begin_decl_stmt
specifier|static
name|int
name|non_blocking
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This module contains all of the code which directly interfaces to  * the underlying representation of the Kerberos database; this  * implementation uses a DBM or NDBM indexed "file" (actually  * implemented as two separate files) to store the relations, plus a  * third file as a semaphore to allow the database to be replaced out  * from underneath the KDC server.  */
end_comment

begin_comment
comment|/*  * Locking:  *   * There are two distinct locking protocols used.  One is designed to  * lock against processes (the admin_server, for one) which make  * incremental changes to the database; the other is designed to lock  * against utilities (kdb_util, kpropd) which replace the entire  * database in one fell swoop.  *  * The first locking protocol is implemented using flock() in the   * krb_dbl_lock() and krb_dbl_unlock routines.  *  * The second locking protocol is necessary because DBM "files" are  * actually implemented as two separate files, and it is impossible to  * atomically rename two files simultaneously.  It assumes that the  * database is replaced only very infrequently in comparison to the time  * needed to do a database read operation.  *  * A third file is used as a "version" semaphore; the modification  * time of this file is the "version number" of the database.  * At the start of a read operation, the reader checks the version  * number; at the end of the read operation, it checks again.  If the  * version number changed, or if the semaphore was nonexistant at  * either time, the reader sleeps for a second to let things  * stabilize, and then tries again; if it does not succeed after  * KERB_DB_MAX_RETRY attempts, it gives up.  *   * On update, the semaphore file is deleted (if it exists) before any  * update takes place; at the end of the update, it is replaced, with  * a version number strictly greater than the version number which  * existed at the start of the update.  *   * If the system crashes in the middle of an update, the semaphore  * file is not automatically created on reboot; this is a feature, not  * a bug, since the database may be inconsistant.  Note that the  * absence of a semaphore file does not prevent another _update_ from  * taking place later.  Database replacements take place automatically  * only on slave servers; a crash in the middle of an update will be  * fixed by the next slave propagation.  A crash in the middle of an  * update on the master would be somewhat more serious, but this would  * likely be noticed by an administrator, who could fix the problem and  * retry the operation.  */
end_comment

begin_comment
comment|/*  * Utility routine: generate name of database file.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|gen_dbsuffix
parameter_list|(
name|char
modifier|*
name|db_name
parameter_list|,
name|char
modifier|*
name|sfx
parameter_list|)
block|{
name|char
modifier|*
name|dbsuffix
decl_stmt|;
if|if
condition|(
name|sfx
operator|==
name|NULL
condition|)
name|sfx
operator|=
literal|".ok"
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|dbsuffix
argument_list|,
literal|"%s%s"
argument_list|,
name|db_name
argument_list|,
name|sfx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbsuffix
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gen_dbsuffix: out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|dbsuffix
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_princ_key
parameter_list|(
name|datum
modifier|*
name|key
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|instance
parameter_list|)
block|{
name|strlcpy
argument_list|(
name|name
argument_list|,
name|key
operator|->
name|dptr
argument_list|,
name|ANAME_SZ
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|instance
argument_list|,
operator|(
name|char
operator|*
operator|)
name|key
operator|->
name|dptr
operator|+
name|ANAME_SZ
argument_list|,
name|INST_SZ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|encode_princ_contents
parameter_list|(
name|datum
modifier|*
name|contents
parameter_list|,
name|Principal
modifier|*
name|principal
parameter_list|)
block|{
name|contents
operator|->
name|dsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|principal
argument_list|)
expr_stmt|;
name|contents
operator|->
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
name|principal
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_princ_contents
parameter_list|(
name|datum
modifier|*
name|contents
parameter_list|,
name|Principal
modifier|*
name|principal
parameter_list|)
block|{
name|memcpy
argument_list|(
name|principal
argument_list|,
name|contents
operator|->
name|dptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|principal
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|encode_princ_key
parameter_list|(
name|datum
modifier|*
name|key
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|instance
parameter_list|)
block|{
specifier|static
name|char
name|keystring
index|[
name|ANAME_SZ
operator|+
name|INST_SZ
index|]
decl_stmt|;
name|memset
argument_list|(
name|keystring
argument_list|,
literal|0
argument_list|,
name|ANAME_SZ
operator|+
name|INST_SZ
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|keystring
argument_list|,
name|name
argument_list|,
name|ANAME_SZ
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|keystring
index|[
name|ANAME_SZ
index|]
argument_list|,
name|instance
argument_list|,
name|INST_SZ
argument_list|)
expr_stmt|;
name|key
operator|->
name|dptr
operator|=
name|keystring
expr_stmt|;
name|key
operator|->
name|dsize
operator|=
name|ANAME_SZ
operator|+
name|INST_SZ
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|dblfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* db LOCK fd */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mylock
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|kerb_dbl_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inited
condition|)
block|{
name|char
modifier|*
name|filename
init|=
name|gen_dbsuffix
argument_list|(
name|current_db_name
argument_list|,
literal|".ok"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|dblfd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"kerb_dbl_init: couldn't open %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|inited
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kerb_dbl_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|close
argument_list|(
name|dblfd
argument_list|)
expr_stmt|;
name|dblfd
operator|=
operator|-
literal|1
expr_stmt|;
name|inited
operator|=
literal|0
expr_stmt|;
name|mylock
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|kerb_dbl_lock
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|int
name|flock_mode
decl_stmt|;
if|if
condition|(
operator|!
name|inited
condition|)
name|kerb_dbl_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|mylock
condition|)
block|{
comment|/* Detect lock call when lock already 				 * locked */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Kerberos locking error (mylock)\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|KERB_DBL_EXCLUSIVE
case|:
name|flock_mode
operator|=
name|LOCK_EX
expr_stmt|;
break|break;
case|case
name|KERB_DBL_SHARED
case|:
name|flock_mode
operator|=
name|LOCK_SH
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid lock mode %d\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|non_blocking
condition|)
name|flock_mode
operator||=
name|LOCK_NB
expr_stmt|;
if|if
condition|(
name|flock
argument_list|(
name|dblfd
argument_list|,
name|flock_mode
argument_list|)
operator|<
literal|0
condition|)
return|return
name|errno
return|;
name|mylock
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kerb_dbl_unlock
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mylock
condition|)
block|{
comment|/* lock already unlocked */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Kerberos database lock not locked when unlocking.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flock
argument_list|(
name|dblfd
argument_list|,
name|LOCK_UN
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Kerberos database lock error. (unlocking)\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"flock"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mylock
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|kerb_db_set_lockmode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|int
name|old
init|=
name|non_blocking
decl_stmt|;
name|non_blocking
operator|=
name|mode
expr_stmt|;
return|return
name|old
return|;
block|}
end_function

begin_comment
comment|/*  * initialization for data base routines.  */
end_comment

begin_function
name|int
name|kerb_db_init
parameter_list|(
name|void
parameter_list|)
block|{
name|init
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gracefully shut down database--must be called by ANY program that does  * a kerb_db_init   */
end_comment

begin_function
name|void
name|kerb_db_fini
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Set the "name" of the current database to some alternate value.  *  * Passing a null pointer as "name" will set back to the default.  * If the alternate database doesn't exist, nothing is changed.  */
end_comment

begin_function
name|int
name|kerb_db_set_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|DBM
modifier|*
name|db
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|default_db_name
expr_stmt|;
name|db
operator|=
name|dbm_open
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
return|return
name|errno
return|;
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|kerb_dbl_fini
argument_list|()
expr_stmt|;
name|current_db_name
operator|=
name|name
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return the last modification time of the database.  */
end_comment

begin_function
name|time_t
name|kerb_get_db_age
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|okname
decl_stmt|;
name|time_t
name|age
decl_stmt|;
name|okname
operator|=
name|gen_dbsuffix
argument_list|(
name|current_db_name
argument_list|,
literal|".ok"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|okname
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|age
operator|=
literal|0
expr_stmt|;
else|else
name|age
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|free
argument_list|(
name|okname
argument_list|)
expr_stmt|;
return|return
name|age
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the semaphore file; indicates that database is currently  * under renovation.  *  * This is only for use when moving the database out from underneath  * the server (for example, during slave updates).  */
end_comment

begin_function
specifier|static
name|time_t
name|kerb_start_update
parameter_list|(
name|char
modifier|*
name|db_name
parameter_list|)
block|{
name|char
modifier|*
name|okname
init|=
name|gen_dbsuffix
argument_list|(
name|db_name
argument_list|,
literal|".ok"
argument_list|)
decl_stmt|;
name|time_t
name|age
init|=
name|kerb_get_db_age
argument_list|()
decl_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|okname
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|age
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|okname
argument_list|)
expr_stmt|;
return|return
name|age
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kerb_end_update
parameter_list|(
name|char
modifier|*
name|db_name
parameter_list|,
name|time_t
name|age
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|new_okname
init|=
name|gen_dbsuffix
argument_list|(
name|db_name
argument_list|,
literal|".ok#"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|okname
init|=
name|gen_dbsuffix
argument_list|(
name|db_name
argument_list|,
literal|".ok"
argument_list|)
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|new_okname
argument_list|,
name|O_CREAT
operator||
name|O_RDWR
operator||
name|O_TRUNC
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|retval
operator|=
name|errno
expr_stmt|;
else|else
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|utimbuf
name|tv
decl_stmt|;
comment|/* make sure that semaphore is "after" previous value. */
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|st
operator|.
name|st_mtime
operator|<=
name|age
condition|)
block|{
name|tv
operator|.
name|actime
operator|=
name|st
operator|.
name|st_atime
expr_stmt|;
name|tv
operator|.
name|modtime
operator|=
name|age
expr_stmt|;
comment|/* set times.. */
name|utime
argument_list|(
name|new_okname
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|fsync
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|new_okname
argument_list|,
name|okname
argument_list|)
operator|<
literal|0
condition|)
name|retval
operator|=
name|errno
expr_stmt|;
block|}
name|free
argument_list|(
name|new_okname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|okname
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|kerb_start_read
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|kerb_get_db_age
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kerb_end_read
parameter_list|(
name|time_t
name|age
parameter_list|)
block|{
if|if
condition|(
name|kerb_get_db_age
argument_list|()
operator|!=
name|age
operator|||
name|age
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Create the database, assuming it's not there.  */
end_comment

begin_function
name|int
name|kerb_db_create
parameter_list|(
name|char
modifier|*
name|db_name
parameter_list|)
block|{
name|char
modifier|*
name|okname
init|=
name|gen_dbsuffix
argument_list|(
name|db_name
argument_list|,
literal|".ok"
argument_list|)
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|NDBM
name|DBM
modifier|*
name|db
decl_stmt|;
name|db
operator|=
name|dbm_open
argument_list|(
name|db_name
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
else|else
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|dirname
init|=
name|gen_dbsuffix
argument_list|(
name|db_name
argument_list|,
literal|".dir"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pagname
init|=
name|gen_dbsuffix
argument_list|(
name|db_name
argument_list|,
literal|".pag"
argument_list|)
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|dirname
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
else|else
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|pagname
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
else|else
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dbminit
argument_list|(
name|db_name
argument_list|)
operator|<
literal|0
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|okname
argument_list|,
name|O_CREAT
operator||
name|O_RDWR
operator||
name|O_TRUNC
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * "Atomically" rename the database in a way that locks out read  * access in the middle of the rename.  *  * Not perfect; if we crash in the middle of an update, we don't  * necessarily know to complete the transaction the rename, but...  */
end_comment

begin_function
name|int
name|kerb_db_rename
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_NEW_DB
name|char
modifier|*
name|fromdb
init|=
name|gen_dbsuffix
argument_list|(
name|from
argument_list|,
literal|".db"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|todb
init|=
name|gen_dbsuffix
argument_list|(
name|to
argument_list|,
literal|".db"
argument_list|)
decl_stmt|;
else|#
directive|else
name|char
modifier|*
name|fromdir
init|=
name|gen_dbsuffix
argument_list|(
name|from
argument_list|,
literal|".dir"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|todir
init|=
name|gen_dbsuffix
argument_list|(
name|to
argument_list|,
literal|".dir"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|frompag
init|=
name|gen_dbsuffix
argument_list|(
name|from
argument_list|,
literal|".pag"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|topag
init|=
name|gen_dbsuffix
argument_list|(
name|to
argument_list|,
literal|".pag"
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|fromok
init|=
name|gen_dbsuffix
argument_list|(
name|from
argument_list|,
literal|".ok"
argument_list|)
decl_stmt|;
name|long
name|trans
init|=
name|kerb_start_update
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NEW_DB
if|if
condition|(
name|rename
argument_list|(
name|fromdb
argument_list|,
name|todb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|fromok
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|fromdb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|todb
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|rename
argument_list|(
name|fromdir
argument_list|,
name|todir
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rename
argument_list|(
name|frompag
argument_list|,
name|topag
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|unlink
argument_list|(
name|fromok
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|fromdir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|todir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frompag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|topag
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|fromok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
return|return
name|kerb_end_update
argument_list|(
name|to
argument_list|,
name|trans
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|kerb_db_delete_principal
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|inst
parameter_list|)
block|{
name|DBM
modifier|*
name|db
decl_stmt|;
name|int
name|try
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|code
decl_stmt|;
name|datum
name|key
decl_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
name|kerb_db_init
argument_list|()
expr_stmt|;
for|for
control|(
name|try
operator|=
literal|0
init|;
name|try
operator|<
name|KERB_DB_MAX_RETRY
condition|;
name|try
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|code
operator|=
name|kerb_dbl_lock
argument_list|(
name|KERB_DBL_EXCLUSIVE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|db
operator|=
name|dbm_open
argument_list|(
name|current_db_name
argument_list|,
name|O_RDWR
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|encode_princ_key
argument_list|(
operator|&
name|key
argument_list|,
name|name
argument_list|,
name|inst
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbm_delete
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
name|done
operator|=
literal|1
expr_stmt|;
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|kerb_dbl_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|done
condition|)
break|break;
if|if
condition|(
operator|!
name|non_blocking
condition|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * look up a principal in the data base returns number of principals  * found , and whether there were more than requested.   */
end_comment

begin_function
name|int
name|kerb_db_get_principal
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|inst
parameter_list|,
name|Principal
modifier|*
name|principal
parameter_list|,
name|unsigned
name|int
name|max
parameter_list|,
name|int
modifier|*
name|more
parameter_list|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|,
name|code
decl_stmt|;
name|int
name|wildp
decl_stmt|,
name|wildi
decl_stmt|;
name|datum
name|key
decl_stmt|,
name|contents
decl_stmt|;
name|char
name|testname
index|[
name|ANAME_SZ
index|]
decl_stmt|,
name|testinst
index|[
name|INST_SZ
index|]
decl_stmt|;
name|u_long
name|trans
decl_stmt|;
name|int
name|try
decl_stmt|;
name|DBM
modifier|*
name|db
decl_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
name|kerb_db_init
argument_list|()
expr_stmt|;
comment|/* initialize database routines */
for|for
control|(
name|try
operator|=
literal|0
init|;
name|try
operator|<
name|KERB_DB_MAX_RETRY
condition|;
name|try
operator|++
control|)
block|{
name|trans
operator|=
name|kerb_start_read
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|kerb_dbl_lock
argument_list|(
name|KERB_DBL_SHARED
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|db
operator|=
name|dbm_open
argument_list|(
name|current_db_name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|more
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kerb_debug
operator|&
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: db_get_principal for %s %s max = %d"
argument_list|,
name|progname
argument_list|,
name|name
argument_list|,
name|inst
argument_list|,
name|max
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wildp
operator|=
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|wildi
operator|=
operator|!
name|strcmp
argument_list|(
name|inst
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wildi
operator|&&
operator|!
name|wildp
condition|)
block|{
comment|/* nothing's wild */
name|encode_princ_key
argument_list|(
operator|&
name|key
argument_list|,
name|name
argument_list|,
name|inst
argument_list|)
expr_stmt|;
name|contents
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|.
name|dptr
operator|==
name|NULL
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|decode_princ_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|principal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kerb_debug
operator|&
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t found %s %s p_n length %d t_n length %d\n"
argument_list|,
name|principal
operator|->
name|name
argument_list|,
name|principal
operator|->
name|instance
argument_list|,
name|strlen
argument_list|(
name|principal
operator|->
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|principal
operator|->
name|instance
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|found
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* process wild cards by looping through entire database */
for|for
control|(
name|key
operator|=
name|dbm_firstkey
argument_list|(
name|db
argument_list|)
init|;
name|key
operator|.
name|dptr
operator|!=
name|NULL
condition|;
name|key
operator|=
name|dbm_next
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
control|)
block|{
name|decode_princ_key
argument_list|(
operator|&
name|key
argument_list|,
name|testname
argument_list|,
name|testinst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wildp
operator|||
operator|!
name|strcmp
argument_list|(
name|testname
argument_list|,
name|name
argument_list|)
operator|)
operator|&&
operator|(
name|wildi
operator|||
operator|!
name|strcmp
argument_list|(
name|testinst
argument_list|,
name|inst
argument_list|)
operator|)
condition|)
block|{
comment|/* have a match */
if|if
condition|(
name|found
operator|>=
name|max
condition|)
block|{
operator|*
name|more
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|found
operator|++
expr_stmt|;
name|contents
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|decode_princ_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|principal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kerb_debug
operator|&
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfound %s %s p_n length %d t_n length %d\n"
argument_list|,
name|principal
operator|->
name|name
argument_list|,
name|principal
operator|->
name|instance
argument_list|,
name|strlen
argument_list|(
name|principal
operator|->
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|principal
operator|->
name|instance
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|principal
operator|++
expr_stmt|;
comment|/* point to next */
block|}
block|}
block|}
name|done
label|:
name|kerb_dbl_unlock
argument_list|()
expr_stmt|;
comment|/* unlock read lock */
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerb_end_read
argument_list|(
name|trans
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|found
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|non_blocking
condition|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Use long * rather than DBM * so that the database structure is private */
end_comment

begin_function
name|long
modifier|*
name|kerb_db_begin_update
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|timestamp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
name|kerb_db_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|kerb_dbl_lock
argument_list|(
name|KERB_DBL_EXCLUSIVE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|long
operator|*
operator|)
name|dbm_open
argument_list|(
name|current_db_name
argument_list|,
name|O_RDWR
argument_list|,
literal|0600
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|kerb_db_end_update
parameter_list|(
name|long
modifier|*
name|db
parameter_list|)
block|{
name|dbm_close
argument_list|(
operator|(
name|DBM
operator|*
operator|)
name|db
argument_list|)
expr_stmt|;
name|kerb_dbl_unlock
argument_list|()
expr_stmt|;
comment|/* unlock database */
block|}
end_function

begin_function
name|int
name|kerb_db_update
parameter_list|(
name|long
modifier|*
name|db
parameter_list|,
name|Principal
modifier|*
name|principal
parameter_list|,
name|unsigned
name|int
name|max
parameter_list|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|u_long
name|i
decl_stmt|;
name|datum
name|key
decl_stmt|,
name|contents
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kerb_debug
operator|&
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: kerb_db_put_principal  max = %d"
argument_list|,
name|progname
argument_list|,
name|max
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* for each one, stuff temps, and do replace/append */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|encode_princ_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|principal
argument_list|)
expr_stmt|;
name|encode_princ_key
argument_list|(
operator|&
name|key
argument_list|,
name|principal
operator|->
name|name
argument_list|,
name|principal
operator|->
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbm_store
argument_list|(
operator|(
name|DBM
operator|*
operator|)
name|db
argument_list|,
name|key
argument_list|,
name|contents
argument_list|,
name|DBM_REPLACE
argument_list|)
operator|<
literal|0
condition|)
return|return
name|found
return|;
comment|/* XXX some better mechanism to report 			     failure should exist */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kerb_debug
operator|&
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n put %s %s\n"
argument_list|,
name|principal
operator|->
name|name
argument_list|,
name|principal
operator|->
name|instance
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|found
operator|++
expr_stmt|;
name|principal
operator|++
expr_stmt|;
comment|/* bump to next struct			   */
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/*  * Update a name in the data base.  Returns number of names  * successfully updated.  */
end_comment

begin_function
name|int
name|kerb_db_put_principal
parameter_list|(
name|Principal
modifier|*
name|principal
parameter_list|,
name|unsigned
name|max
parameter_list|)
block|{
name|int
name|found
decl_stmt|;
name|long
modifier|*
name|db
decl_stmt|;
name|db
operator|=
name|kerb_db_begin_update
argument_list|()
expr_stmt|;
if|if
condition|(
name|db
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|found
operator|=
name|kerb_db_update
argument_list|(
name|db
argument_list|,
name|principal
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|kerb_db_end_update
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
name|void
name|kerb_db_get_stat
parameter_list|(
name|DB_stat
modifier|*
name|s
parameter_list|)
block|{
name|gettimeofday
argument_list|(
operator|&
name|timestamp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|cpu
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|elapsed
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|dio
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|pfault
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|t_stamp
operator|=
name|timestamp
operator|.
name|tv_sec
expr_stmt|;
name|s
operator|->
name|n_retrieve
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|n_replace
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|n_append
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|n_get_stat
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|n_put_stat
operator|=
literal|0
expr_stmt|;
comment|/* update local copy too */
block|}
end_function

begin_function
name|void
name|kerb_db_put_stat
parameter_list|(
name|DB_stat
modifier|*
name|s
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|delta_stat
parameter_list|(
name|DB_stat
modifier|*
name|a
parameter_list|,
name|DB_stat
modifier|*
name|b
parameter_list|,
name|DB_stat
modifier|*
name|c
parameter_list|)
block|{
comment|/* c = a - b then b = a for the next time */
name|c
operator|->
name|cpu
operator|=
name|a
operator|->
name|cpu
operator|-
name|b
operator|->
name|cpu
expr_stmt|;
name|c
operator|->
name|elapsed
operator|=
name|a
operator|->
name|elapsed
operator|-
name|b
operator|->
name|elapsed
expr_stmt|;
name|c
operator|->
name|dio
operator|=
name|a
operator|->
name|dio
operator|-
name|b
operator|->
name|dio
expr_stmt|;
name|c
operator|->
name|pfault
operator|=
name|a
operator|->
name|pfault
operator|-
name|b
operator|->
name|pfault
expr_stmt|;
name|c
operator|->
name|t_stamp
operator|=
name|a
operator|->
name|t_stamp
operator|-
name|b
operator|->
name|t_stamp
expr_stmt|;
name|c
operator|->
name|n_retrieve
operator|=
name|a
operator|->
name|n_retrieve
operator|-
name|b
operator|->
name|n_retrieve
expr_stmt|;
name|c
operator|->
name|n_replace
operator|=
name|a
operator|->
name|n_replace
operator|-
name|b
operator|->
name|n_replace
expr_stmt|;
name|c
operator|->
name|n_append
operator|=
name|a
operator|->
name|n_append
operator|-
name|b
operator|->
name|n_append
expr_stmt|;
name|c
operator|->
name|n_get_stat
operator|=
name|a
operator|->
name|n_get_stat
operator|-
name|b
operator|->
name|n_get_stat
expr_stmt|;
name|c
operator|->
name|n_put_stat
operator|=
name|a
operator|->
name|n_put_stat
operator|-
name|b
operator|->
name|n_put_stat
expr_stmt|;
name|memcpy
argument_list|(
name|b
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|DB_stat
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * look up a dba in the data base returns number of dbas found , and  * whether there were more than requested.   */
end_comment

begin_function
name|int
name|kerb_db_get_dba
parameter_list|(
name|char
modifier|*
name|dba_name
parameter_list|,
comment|/* could have wild card */
name|char
modifier|*
name|dba_inst
parameter_list|,
comment|/* could have wild card */
name|Dba
modifier|*
name|dba
parameter_list|,
name|unsigned
name|max
parameter_list|,
comment|/* max number of name structs to return */
name|int
modifier|*
name|more
parameter_list|)
comment|/* where there more than 'max' tuples? */
block|{
operator|*
name|more
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kerb_db_iterate
parameter_list|(
name|k_iter_proc_t
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|datum
name|key
decl_stmt|,
name|contents
decl_stmt|;
name|Principal
modifier|*
name|principal
decl_stmt|;
name|int
name|code
decl_stmt|;
name|DBM
modifier|*
name|db
decl_stmt|;
name|kerb_db_init
argument_list|()
expr_stmt|;
comment|/* initialize and open the database */
if|if
condition|(
operator|(
name|code
operator|=
name|kerb_dbl_lock
argument_list|(
name|KERB_DBL_SHARED
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|code
return|;
name|db
operator|=
name|dbm_open
argument_list|(
name|current_db_name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
return|return
name|errno
return|;
for|for
control|(
name|key
operator|=
name|dbm_firstkey
argument_list|(
name|db
argument_list|)
init|;
name|key
operator|.
name|dptr
operator|!=
name|NULL
condition|;
name|key
operator|=
name|dbm_next
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
control|)
block|{
name|contents
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/* XXX may not be properly aligned */
name|principal
operator|=
operator|(
name|Principal
operator|*
operator|)
name|contents
operator|.
name|dptr
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|arg
argument_list|,
name|principal
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|code
return|;
block|}
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|kerb_dbl_unlock
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

