begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    Copyright (C) 1989 by the Massachusetts Institute of Technology     Export of this software from the United States of America is assumed    to require a specific license from the United States Government.    It is the responsibility of any person or organization contemplating    export to obtain such a license before exporting.  WITHIN THAT CONSTRAINT, permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.    */
end_comment

begin_comment
comment|/*  * Utility routines for Kerberos programs which directly access  * the database.  This code was duplicated in too many places  * before I gathered it here.  *  * Jon Rochlis, MIT Telecom, March 1988  */
end_comment

begin_include
include|#
directive|include
file|"kdb_locl.h"
end_include

begin_include
include|#
directive|include
file|<kdc.h>
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: krb_kdb_utils.c,v 1.23 1997/05/02 14:29:10 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* always try /.k for backwards compatibility */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|master_key_files
index|[]
init|=
block|{
name|MKEYFILE
block|,
literal|"/.k"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRERROR
end_ifdef

begin_define
define|#
directive|define
name|k_strerror
parameter_list|(
name|e
parameter_list|)
value|strerror(e)
end_define

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|char
modifier|*
name|k_strerror
parameter_list|(
name|int
name|eno
parameter_list|)
block|{
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|static
name|char
name|emsg
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|eno
operator|<
literal|0
operator|||
name|eno
operator|>=
name|sys_nerr
condition|)
name|snprintf
argument_list|(
name|emsg
argument_list|,
sizeof|sizeof
argument_list|(
name|emsg
argument_list|)
argument_list|,
literal|"Error %d occurred."
argument_list|,
name|eno
argument_list|)
expr_stmt|;
else|else
return|return
name|sys_errlist
index|[
name|eno
index|]
return|;
return|return
name|emsg
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|kdb_new_get_master_key
parameter_list|(
name|des_cblock
modifier|*
name|key
parameter_list|,
name|des_key_schedule
name|schedule
parameter_list|)
block|{
name|int
name|kfile
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|mkey
decl_stmt|;
for|for
control|(
name|mkey
operator|=
name|master_key_files
init|;
operator|*
name|mkey
condition|;
name|mkey
operator|++
control|)
block|{
name|kfile
operator|=
name|open
argument_list|(
operator|*
name|mkey
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|kfile
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to open master key file \"%s\": %s\n"
argument_list|,
operator|*
name|mkey
argument_list|,
name|k_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kfile
operator|>=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|mkey
condition|)
block|{
name|int
name|bytes
decl_stmt|;
name|bytes
operator|=
name|read
argument_list|(
name|kfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|kfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
condition|)
block|{
name|des_key_sched
argument_list|(
name|key
argument_list|,
name|schedule
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could only read %d bytes from master key file %s\n"
argument_list|,
name|bytes
argument_list|,
operator|*
name|mkey
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No master key file found.\n"
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|des_read_pw_string
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Enter master password: "
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
comment|/* buffer now contains either an old format master key password or a        * new format base64 encoded master key        */
comment|/* try to verify as old password */
name|des_string_to_key
argument_list|(
name|buf
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|des_key_sched
argument_list|(
name|key
argument_list|,
name|schedule
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdb_verify_master_key
argument_list|(
name|key
argument_list|,
name|schedule
argument_list|,
name|NULL
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* failed test, so must be base64 encoded */
if|if
condition|(
name|base64_decode
argument_list|(
name|buf
argument_list|,
name|key
argument_list|)
operator|==
literal|8
condition|)
block|{
name|des_key_sched
argument_list|(
name|key
argument_list|,
name|schedule
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdb_verify_master_key
argument_list|(
name|key
argument_list|,
name|schedule
argument_list|,
name|NULL
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to verify master key.\n"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* life sucks */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You loose.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|kdb_new_get_new_master_key
parameter_list|(
name|des_cblock
modifier|*
name|key
parameter_list|,
name|des_key_schedule
name|schedule
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|RANDOM_MKEY
name|des_read_password
argument_list|(
name|key
argument_list|,
literal|"\nEnter Kerberos master password: "
argument_list|,
name|verify
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|des_generate_random_block
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|des_key_sched
argument_list|(
name|key
argument_list|,
name|schedule
argument_list|)
expr_stmt|;
name|des_read_pw_string
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Enter master key seed: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|des_cbc_cksum
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|buf
argument_list|,
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|schedule
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|des_key_sched
argument_list|(
name|key
argument_list|,
name|schedule
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|kdb_get_master_key
parameter_list|(
name|int
name|prompt
parameter_list|,
name|des_cblock
modifier|*
name|master_key
parameter_list|,
name|des_key_schedule
name|master_key_sched
parameter_list|)
block|{
name|int
name|ask
init|=
operator|(
name|prompt
operator|==
name|KDB_GET_TWICE
operator|)
decl_stmt|;
ifndef|#
directive|ifndef
name|RANDOM_MKEY
name|ask
operator||=
operator|(
name|prompt
operator|==
name|KDB_GET_PROMPT
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ask
condition|)
name|kdb_new_get_new_master_key
argument_list|(
name|master_key
argument_list|,
name|master_key_sched
argument_list|,
name|prompt
operator|==
name|KDB_GET_TWICE
argument_list|)
expr_stmt|;
else|else
name|kdb_new_get_master_key
argument_list|(
name|master_key
argument_list|,
name|master_key_sched
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|kdb_kstash
parameter_list|(
name|des_cblock
modifier|*
name|master_key
parameter_list|,
name|char
modifier|*
name|file
parameter_list|)
block|{
name|int
name|kfile
decl_stmt|;
name|kfile
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_TRUNC
operator||
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|kfile
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|write
argument_list|(
name|kfile
argument_list|,
name|master_key
argument_list|,
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|kfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|close
argument_list|(
name|kfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The old algorithm used the key schedule as the initial vector which    was byte order depedent ... */
end_comment

begin_decl_stmt
name|void
name|kdb_encrypt_key
argument_list|(
name|des_cblock
argument_list|(
operator|*
name|in
argument_list|)
argument_list|,
name|des_cblock
argument_list|(
operator|*
name|out
argument_list|)
argument_list|,
name|des_cblock
argument_list|(
operator|*
name|master_key
argument_list|)
argument_list|,
name|des_key_schedule
name|master_key_sched
argument_list|,
name|int
name|e_d_flag
argument_list|)
block|{
ifdef|#
directive|ifdef
name|NOENCRYPTION
name|memcpy
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|des_pcbc_encrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
argument_list|,
name|master_key_sched
argument_list|,
name|master_key
argument_list|,
name|e_d_flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_comment
comment|/* The caller is reasponsible for cleaning up the master key and sched,    even if we can't verify the master key */
end_comment

begin_comment
comment|/* Returns master key version if successful, otherwise -1 */
end_comment

begin_function
name|long
name|kdb_verify_master_key
parameter_list|(
name|des_cblock
modifier|*
name|master_key
parameter_list|,
name|des_key_schedule
name|master_key_sched
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
comment|/* NULL -> no output */
block|{
name|des_cblock
name|key_from_db
decl_stmt|;
name|Principal
name|principal_data
index|[
literal|1
index|]
decl_stmt|;
name|int
name|n
decl_stmt|,
name|more
init|=
literal|0
decl_stmt|;
name|long
name|master_key_version
decl_stmt|;
comment|/* lookup the master key version */
name|n
operator|=
name|kerb_get_principal
argument_list|(
name|KERB_M_NAME
argument_list|,
name|KERB_M_INST
argument_list|,
name|principal_data
argument_list|,
literal|1
comment|/* only one please */
argument_list|,
operator|&
name|more
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|!=
literal|1
operator|)
operator|||
name|more
condition|)
block|{
if|if
condition|(
name|out
operator|!=
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"verify_master_key: %s, %d found.\n"
argument_list|,
literal|"Kerberos error on master key version lookup"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|master_key_version
operator|=
operator|(
name|long
operator|)
name|principal_data
index|[
literal|0
index|]
operator|.
name|key_version
expr_stmt|;
comment|/* set up the master key */
if|if
condition|(
name|out
operator|!=
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
comment|/* should we punt this? */
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Current Kerberos master key version is %d.\n"
argument_list|,
name|principal_data
index|[
literal|0
index|]
operator|.
name|kdc_key_ver
argument_list|)
expr_stmt|;
comment|/*    * now use the master key to decrypt the key in the db, had better    * be the same!     */
name|copy_to_key
argument_list|(
operator|&
name|principal_data
index|[
literal|0
index|]
operator|.
name|key_low
argument_list|,
operator|&
name|principal_data
index|[
literal|0
index|]
operator|.
name|key_high
argument_list|,
name|key_from_db
argument_list|)
expr_stmt|;
name|kdb_encrypt_key
argument_list|(
operator|&
name|key_from_db
argument_list|,
operator|&
name|key_from_db
argument_list|,
name|master_key
argument_list|,
name|master_key_sched
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
comment|/* the decrypted database key had better equal the master key */
name|n
operator|=
name|memcmp
argument_list|(
name|master_key
argument_list|,
name|key_from_db
argument_list|,
sizeof|sizeof
argument_list|(
name|master_key
argument_list|)
argument_list|)
expr_stmt|;
comment|/* this used to zero the master key here! */
name|memset
argument_list|(
name|key_from_db
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key_from_db
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|principal_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|principal_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
operator|(
name|out
operator|!=
operator|(
name|FILE
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n\07\07verify_master_key: Invalid master key; "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"does not match database.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|out
operator|!=
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nMaster key entered.  BEWARE!\07\07\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|master_key_version
operator|)
return|;
block|}
end_function

end_unit

