begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    Copyright (C) 1989 by the Massachusetts Institute of Technology     Export of this software from the United States of America is assumed    to require a specific license from the United States Government.    It is the responsibility of any person or organization contemplating    export to obtain such a license before exporting.  WITHIN THAT CONSTRAINT, permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.    */
end_comment

begin_include
include|#
directive|include
file|"kdb_locl.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: krb_lib.c,v 1.11 1997/05/07 01:36:08 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|kerb_debug
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|init
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * initialization routine for data base   */
end_comment

begin_function
name|int
name|kerb_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|init
condition|)
block|{
name|char
modifier|*
name|dbg
init|=
name|getenv
argument_list|(
literal|"KERB_DBG"
argument_list|)
decl_stmt|;
if|if
condition|(
name|dbg
condition|)
name|sscanf
argument_list|(
name|dbg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|kerb_debug
argument_list|)
expr_stmt|;
name|init
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|kerb_db_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CACHE
name|kerb_cache_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* successful init, return 0, else errcode */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * finalization routine for database -- NOTE: MUST be called by any  * program using kerb_init.  ALSO will have to be modified to finalize  * caches, if they're ever really implemented.   */
end_comment

begin_function
name|void
name|kerb_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|kerb_db_fini
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|kerb_delete_principal
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|inst
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
name|kerb_init
argument_list|()
expr_stmt|;
name|ret
operator|=
name|kerb_db_delete_principal
argument_list|(
name|name
argument_list|,
name|inst
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CACHE
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|kerb_cache_delete_principal
argument_list|(
name|name
argument_list|,
name|inst
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * look up a principal in the cache or data base returns number of  * principals found   */
end_comment

begin_function
name|int
name|kerb_get_principal
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|inst
parameter_list|,
name|Principal
modifier|*
name|principal
parameter_list|,
name|unsigned
name|int
name|max
parameter_list|,
name|int
modifier|*
name|more
parameter_list|)
comment|/* could have wild card */
comment|/* could have wild card */
comment|/* max number of name structs to return */
comment|/* more tuples than room for */
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|CACHE
specifier|static
name|int
name|wild
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|init
condition|)
name|kerb_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kerb_debug
operator|&
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: kerb_get_principal for %s %s max = %d\n"
argument_list|,
name|progname
argument_list|,
name|name
argument_list|,
name|inst
argument_list|,
name|max
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * if this is a request including a wild card, have to go to db      * since the cache may not be exhaustive.       */
comment|/* clear the principal area */
name|memset
argument_list|(
name|principal
argument_list|,
literal|0
argument_list|,
name|max
operator|*
sizeof|sizeof
argument_list|(
name|Principal
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CACHE
comment|/*      * so check to see if the name contains a wildcard "*" or "?", not      * preceeded by a backslash.       */
name|wild
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|name
argument_list|,
literal|'*'
argument_list|)
operator|||
name|index
argument_list|(
name|name
argument_list|,
literal|'?'
argument_list|)
operator|||
name|index
argument_list|(
name|inst
argument_list|,
literal|'*'
argument_list|)
operator|||
name|index
argument_list|(
name|inst
argument_list|,
literal|'?'
argument_list|)
condition|)
name|wild
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wild
condition|)
block|{
comment|/* try the cache first */
name|found
operator|=
name|kerb_cache_get_principal
argument_list|(
name|name
argument_list|,
name|inst
argument_list|,
name|principal
argument_list|,
name|max
argument_list|,
name|more
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return
operator|(
name|found
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* If we didn't try cache, or it wasn't there, try db */
name|found
operator|=
name|kerb_db_get_principal
argument_list|(
name|name
argument_list|,
name|inst
argument_list|,
name|principal
argument_list|,
name|max
argument_list|,
name|more
argument_list|)
expr_stmt|;
comment|/* try to insert principal(s) into cache if it was found */
ifdef|#
directive|ifdef
name|CACHE
if|if
condition|(
name|found
condition|)
block|{
name|kerb_cache_put_principal
argument_list|(
name|principal
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_comment
comment|/* principals */
end_comment

begin_function
name|int
name|kerb_put_principal
parameter_list|(
name|Principal
modifier|*
name|principal
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
comment|/* number of principal structs to write */
block|{
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
comment|/* set mod date */
name|principal
operator|->
name|mod_date
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* and mod date string */
name|tp
operator|=
name|k_localtime
argument_list|(
operator|&
name|principal
operator|->
name|mod_date
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|principal
operator|->
name|mod_date_txt
argument_list|,
sizeof|sizeof
argument_list|(
name|principal
operator|->
name|mod_date_txt
argument_list|)
argument_list|,
literal|"%4d-%2d-%2d"
argument_list|,
name|tp
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tp
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tp
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
comment|/* January is 0, not 1 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kerb_debug
operator|&
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nkerb_put_principal..."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|krb_print_principal
argument_list|(
operator|&
name|principal
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* write database */
if|if
condition|(
name|kerb_db_put_principal
argument_list|(
name|principal
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kerb_debug
operator|&
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: kerb_db_put_principal err"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
comment|/* watch out for cache */
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|CACHE
comment|/* write cache */
if|if
condition|(
operator|!
name|kerb_cache_put_principal
argument_list|(
name|principal
argument_list|,
name|n
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kerb_debug
operator|&
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: kerb_cache_put_principal err"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|kerb_get_dba
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|inst
parameter_list|,
name|Dba
modifier|*
name|dba
parameter_list|,
name|unsigned
name|int
name|max
parameter_list|,
name|int
modifier|*
name|more
parameter_list|)
comment|/* could have wild card */
comment|/* could have wild card */
comment|/* max number of name structs to return */
comment|/* more tuples than room for */
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|CACHE
specifier|static
name|int
name|wild
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|init
condition|)
name|kerb_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kerb_debug
operator|&
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: kerb_get_dba for %s %s max = %d\n"
argument_list|,
name|progname
argument_list|,
name|name
argument_list|,
name|inst
argument_list|,
name|max
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * if this is a request including a wild card, have to go to db      * since the cache may not be exhaustive.       */
comment|/* clear the dba area */
name|memset
argument_list|(
name|dba
argument_list|,
literal|0
argument_list|,
name|max
operator|*
sizeof|sizeof
argument_list|(
name|Dba
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CACHE
comment|/*      * so check to see if the name contains a wildcard "*" or "?", not      * preceeded by a backslash.       */
name|wild
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|name
argument_list|,
literal|'*'
argument_list|)
operator|||
name|index
argument_list|(
name|name
argument_list|,
literal|'?'
argument_list|)
operator|||
name|index
argument_list|(
name|inst
argument_list|,
literal|'*'
argument_list|)
operator|||
name|index
argument_list|(
name|inst
argument_list|,
literal|'?'
argument_list|)
condition|)
name|wild
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wild
condition|)
block|{
comment|/* try the cache first */
name|found
operator|=
name|kerb_cache_get_dba
argument_list|(
name|name
argument_list|,
name|inst
argument_list|,
name|dba
argument_list|,
name|max
argument_list|,
name|more
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return
operator|(
name|found
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* If we didn't try cache, or it wasn't there, try db */
name|found
operator|=
name|kerb_db_get_dba
argument_list|(
name|name
argument_list|,
name|inst
argument_list|,
name|dba
argument_list|,
name|max
argument_list|,
name|more
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CACHE
comment|/* try to insert dba(s) into cache if it was found */
if|if
condition|(
name|found
condition|)
block|{
name|kerb_cache_put_dba
argument_list|(
name|dba
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

end_unit

