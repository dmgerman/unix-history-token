begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *   * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *   * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* KClient.c - KClient glue to krb4.dll  * Author: Jörgen Karlsson - d93-jka@nada.kth.se  * Date: June 1996  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: KClient.c,v 1.14 1999/12/02 16:58:40 joda Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_comment
comment|/* Visual C++ 4.0 (Windows95/NT) */
end_comment

begin_include
include|#
directive|include
file|<Windows.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

begin_comment
comment|//#include<string.h>
end_comment

begin_include
include|#
directive|include
file|<winsock.h>
end_include

begin_include
include|#
directive|include
file|"passwd_dlg.h"
end_include

begin_include
include|#
directive|include
file|"KClient.h"
end_include

begin_include
include|#
directive|include
file|"krb.h"
end_include

begin_decl_stmt
name|char
name|guser
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|msg
parameter_list|(
name|char
modifier|*
name|text
parameter_list|)
block|{
name|HWND
name|wnd
init|=
name|GetActiveWindow
argument_list|()
decl_stmt|;
name|MessageBox
argument_list|(
name|wnd
argument_list|,
name|text
argument_list|,
literal|"KClient message"
argument_list|,
name|MB_OK
operator||
name|MB_APPLMODAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|BOOL
name|SendTicketForService
parameter_list|(
name|LPSTR
name|service
parameter_list|,
name|LPSTR
name|version
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|KTEXT_ST
name|ticket
decl_stmt|;
name|MSG_DAT
name|mdat
decl_stmt|;
name|CREDENTIALS
name|cred
decl_stmt|;
name|des_key_schedule
name|schedule
decl_stmt|;
name|char
name|name
index|[
name|SNAME_SZ
index|]
decl_stmt|,
name|inst
index|[
name|INST_SZ
index|]
decl_stmt|,
name|realm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
specifier|static
name|KClientSessionInfo
name|foo
decl_stmt|;
name|KClientKey
name|key
decl_stmt|;
name|kname_parse
argument_list|(
name|name
argument_list|,
name|inst
argument_list|,
name|realm
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|foo
operator|.
name|realm
argument_list|,
name|realm
argument_list|,
sizeof|sizeof
argument_list|(
name|foo
operator|.
name|realm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|KClientStatus
argument_list|(
operator|&
name|foo
argument_list|)
operator|==
name|KClientNotLoggedIn
condition|)
name|KClientLogin
argument_list|(
operator|&
name|foo
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|ret
operator|=
name|krb_sendauth
argument_list|(
literal|0
argument_list|,
name|fd
argument_list|,
operator|&
name|ticket
argument_list|,
name|name
argument_list|,
name|inst
argument_list|,
name|realm
argument_list|,
literal|17
argument_list|,
operator|&
name|mdat
argument_list|,
operator|&
name|cred
argument_list|,
operator|&
name|schedule
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|BOOL
name|WINAPI
name|DllMain
parameter_list|(
name|HANDLE
name|hInst
parameter_list|,
name|ULONG
name|reason
parameter_list|,
name|LPVOID
name|lpReserved
parameter_list|)
block|{
name|WORD
name|wVersionRequested
decl_stmt|;
name|WSADATA
name|wsaData
decl_stmt|;
name|int
name|err
decl_stmt|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|DLL_PROCESS_ATTACH
case|:
name|wVersionRequested
operator|=
name|MAKEWORD
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|WSAStartup
argument_list|(
name|wVersionRequested
argument_list|,
operator|&
name|wsaData
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
comment|/* Tell the user that we couldn't find a useable */
comment|/* winsock.dll.     */
name|msg
argument_list|(
literal|"Cannot find winsock.dll"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
name|DLL_PROCESS_DETACH
case|:
name|WSACleanup
argument_list|()
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|Kerr
name|KClientMessage
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|Kerr
name|error
parameter_list|)
block|{
name|msg
argument_list|(
name|text
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* KClientInitSession  * You need to call this routine before calling most other routines.  * It initializes a KClientSessionInfo structure.  * The local and remote addresses are for use in KClientEncrypt,  * KClientDecrypt, KClientMakeSendAuth and KClientVerifySendAuth.  * If you don't use any of these routines it's perfectly OK to do the following...  * err = KClientInitSession(session,0,0,0,0);  */
end_comment

begin_function
name|Kerr
name|KClientInitSession
parameter_list|(
name|KClientSessionInfo
modifier|*
name|session
parameter_list|,
name|unsigned
name|long
name|lAddr
parameter_list|,
name|unsigned
name|short
name|lPort
parameter_list|,
name|unsigned
name|long
name|fAddr
parameter_list|,
name|unsigned
name|short
name|fPort
parameter_list|)
block|{
name|session
operator|->
name|lAddr
operator|=
name|lAddr
expr_stmt|;
name|session
operator|->
name|lPort
operator|=
name|lPort
expr_stmt|;
name|session
operator|->
name|fAddr
operator|=
name|fAddr
expr_stmt|;
name|session
operator|->
name|fPort
operator|=
name|fPort
expr_stmt|;
if|if
condition|(
name|tf_get_pname
argument_list|(
name|session
operator|->
name|user
argument_list|)
operator|!=
name|KSUCCESS
condition|)
operator|*
operator|(
name|session
operator|->
name|user
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tf_get_pinst
argument_list|(
name|session
operator|->
name|inst
argument_list|)
operator|!=
name|KSUCCESS
condition|)
operator|*
operator|(
name|session
operator|->
name|inst
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|krb_get_lrealm
argument_list|(
name|session
operator|->
name|realm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|session
operator|->
name|user
operator|)
condition|)
name|strlcpy
argument_list|(
name|guser
argument_list|,
name|session
operator|->
name|user
argument_list|,
sizeof|sizeof
argument_list|(
name|guser
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|guser
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* KClientGetTicketForService  * This routine gets an authenticator to be passed to a service.  * If the user isn't already logged in the user is prompted for a password.  */
end_comment

begin_function
name|Kerr
name|KClientGetTicketForService
parameter_list|(
name|KClientSessionInfo
modifier|*
name|session
parameter_list|,
name|char
modifier|*
name|service
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
modifier|*
name|buflen
parameter_list|)
block|{
name|CREDENTIALS
name|c
decl_stmt|;
name|KClientKey
name|k
decl_stmt|;
name|KTEXT_ST
name|ticket
decl_stmt|;
name|char
name|serv
index|[
literal|255
index|]
decl_stmt|,
name|inst
index|[
literal|255
index|]
decl_stmt|,
name|realm
index|[
literal|255
index|]
decl_stmt|;
name|Kerr
name|err
decl_stmt|;
comment|//	KClientSetUserName(session->user);
name|err
operator|=
name|kname_parse
argument_list|(
name|serv
argument_list|,
name|inst
argument_list|,
name|realm
argument_list|,
name|service
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|realm
condition|)
name|strlcpy
argument_list|(
name|session
operator|->
name|realm
argument_list|,
name|realm
argument_list|,
sizeof|sizeof
argument_list|(
name|session
operator|->
name|realm
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|realm
argument_list|,
name|session
operator|->
name|realm
argument_list|,
sizeof|sizeof
argument_list|(
name|realm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|KClientStatus
argument_list|(
name|session
argument_list|)
operator|==
name|KClientNotLoggedIn
condition|)
if|if
condition|(
operator|(
name|err
operator|=
name|KClientLogin
argument_list|(
name|session
argument_list|,
operator|&
name|k
argument_list|)
operator|)
operator|!=
name|KSUCCESS
condition|)
return|return
name|err
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|krb_mk_req
argument_list|(
operator|&
name|ticket
argument_list|,
name|serv
argument_list|,
name|inst
argument_list|,
name|realm
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|KSUCCESS
condition|)
return|return
name|KClientMessage
argument_list|(
name|KClientErrorText
argument_list|(
name|err
argument_list|,
literal|0
argument_list|)
argument_list|,
name|err
argument_list|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|krb_get_cred
argument_list|(
name|serv
argument_list|,
name|inst
argument_list|,
name|realm
argument_list|,
operator|&
name|c
argument_list|)
operator|)
operator|!=
name|KSUCCESS
condition|)
return|return
name|KClientMessage
argument_list|(
name|KClientErrorText
argument_list|(
name|err
argument_list|,
literal|0
argument_list|)
argument_list|,
name|err
argument_list|)
return|;
if|if
condition|(
operator|*
name|buflen
operator|>=
name|ticket
operator|.
name|length
condition|)
block|{
operator|*
name|buflen
operator|=
name|ticket
operator|.
name|length
operator|+
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
expr_stmt|;
name|CopyMemory
argument_list|(
name|buf
argument_list|,
operator|&
name|ticket
argument_list|,
operator|*
name|buflen
argument_list|)
expr_stmt|;
name|CopyMemory
argument_list|(
name|session
operator|->
name|key
argument_list|,
name|c
operator|.
name|session
argument_list|,
sizeof|sizeof
argument_list|(
name|session
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|err
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* KClientLogin  * This routine "logs in" by getting a ticket granting ticket from kerberos.  * It returns the user's private key which can be used to automate login at  * a later time with KClientKeyLogin.  */
end_comment

begin_function
name|Kerr
name|KClientLogin
parameter_list|(
name|KClientSessionInfo
modifier|*
name|session
parameter_list|,
name|KClientKey
modifier|*
name|privateKey
parameter_list|)
block|{
name|CREDENTIALS
name|c
decl_stmt|;
name|Kerr
name|err
decl_stmt|;
name|char
name|passwd
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|pwd_dialog
argument_list|(
name|guser
argument_list|,
name|passwd
argument_list|)
operator|)
condition|)
return|return
name|err
return|;
if|if
condition|(
name|KClientStatus
argument_list|(
name|session
argument_list|)
operator|==
name|KClientNotLoggedIn
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|krb_get_pw_in_tkt
argument_list|(
name|guser
argument_list|,
name|session
operator|->
name|inst
argument_list|,
name|session
operator|->
name|realm
argument_list|,
literal|"krbtgt"
argument_list|,
name|session
operator|->
name|realm
argument_list|,
name|DEFAULT_TKT_LIFE
argument_list|,
name|passwd
argument_list|)
operator|)
operator|!=
name|KSUCCESS
condition|)
return|return
name|KClientMessage
argument_list|(
name|KClientErrorText
argument_list|(
name|err
argument_list|,
literal|0
argument_list|)
argument_list|,
name|err
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|krb_get_cred
argument_list|(
literal|"krbtgt"
argument_list|,
name|session
operator|->
name|realm
argument_list|,
name|session
operator|->
name|realm
argument_list|,
operator|&
name|c
argument_list|)
operator|)
operator|==
name|KSUCCESS
condition|)
name|CopyMemory
argument_list|(
name|privateKey
argument_list|,
name|c
operator|.
name|session
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|privateKey
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* KClientPasswordLogin  * This routine is similiar to KClientLogin but instead of prompting the user  * for a password it uses the password supplied to establish login.  */
end_comment

begin_function
name|Kerr
name|KClientPasswordLogin
parameter_list|(
name|KClientSessionInfo
modifier|*
name|session
parameter_list|,
name|char
modifier|*
name|password
parameter_list|,
name|KClientKey
modifier|*
name|privateKey
parameter_list|)
block|{
return|return
name|krb_get_pw_in_tkt
argument_list|(
name|guser
argument_list|,
name|session
operator|->
name|inst
argument_list|,
name|session
operator|->
name|realm
argument_list|,
literal|"krbtgt"
argument_list|,
name|session
operator|->
name|realm
argument_list|,
name|DEFAULT_TKT_LIFE
argument_list|,
name|password
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|key_proc_t
name|key_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* KClientKeyLogin  * This routine is similiar to KClientLogin but instead of prompting the user  * for a password it uses the private key supplied to establish login.  */
end_comment

begin_function
name|Kerr
name|KClientKeyLogin
parameter_list|(
name|KClientSessionInfo
modifier|*
name|session
parameter_list|,
name|KClientKey
modifier|*
name|privateKey
parameter_list|)
block|{
return|return
name|krb_get_in_tkt
argument_list|(
name|guser
argument_list|,
name|session
operator|->
name|inst
argument_list|,
name|session
operator|->
name|realm
argument_list|,
literal|"krbtgt"
argument_list|,
name|session
operator|->
name|realm
argument_list|,
name|DEFAULT_TKT_LIFE
argument_list|,
name|key_proc
argument_list|,
literal|0
argument_list|,
name|privateKey
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* KClientLogout  * This routine destroys all credentials stored in the credential cache  * effectively logging the user out.  */
end_comment

begin_function
name|Kerr
name|KClientLogout
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* KClientStatus  * This routine returns the user's login status which can be  * KClientLoggedIn or KClientNotLoggedIn.  */
end_comment

begin_function
name|short
name|KClientStatus
parameter_list|(
name|KClientSessionInfo
modifier|*
name|session
parameter_list|)
block|{
name|CREDENTIALS
name|c
decl_stmt|;
if|if
condition|(
name|krb_get_cred
argument_list|(
literal|"krbtgt"
argument_list|,
name|session
operator|->
name|realm
argument_list|,
name|session
operator|->
name|realm
argument_list|,
operator|&
name|c
argument_list|)
operator|==
name|KSUCCESS
condition|)
return|return
name|KClientLoggedIn
return|;
else|else
return|return
name|KClientNotLoggedIn
return|;
block|}
end_function

begin_comment
comment|/* KClientGetUserName  * This routine returns the name the user supplied in the login dialog.  * No name is returned if the user is not logged in.  */
end_comment

begin_function
name|Kerr
name|KClientGetUserName
parameter_list|(
name|char
modifier|*
name|user
parameter_list|)
block|{
name|strcpy
argument_list|(
name|user
argument_list|,
name|guser
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* KClientSetUserName  * This routine sets the name that will come up in the login dialog  * the next time the user is prompted for a password.  */
end_comment

begin_function
name|Kerr
name|KClientSetUserName
parameter_list|(
name|char
modifier|*
name|user
parameter_list|)
block|{
name|strlcpy
argument_list|(
name|guser
argument_list|,
name|user
argument_list|,
sizeof|sizeof
argument_list|(
name|guser
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* KClientCacheInitialTicket  * This routine is used to obtain a ticket for the password changing service.  */
end_comment

begin_function
name|Kerr
name|KClientCacheInitialTicket
parameter_list|(
name|KClientSessionInfo
modifier|*
name|session
parameter_list|,
name|char
modifier|*
name|service
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* KClientGetSessionKey  * This routine can be used to obtain the session key which is stored  * in the KClientSessionInfo record. The session key has no usefullness  * with any KClient calls but it can be used to with the MIT kerberos API.  */
end_comment

begin_function
name|Kerr
name|KClientGetSessionKey
parameter_list|(
name|KClientSessionInfo
modifier|*
name|session
parameter_list|,
name|KClientKey
modifier|*
name|sessionKey
parameter_list|)
block|{
name|CopyMemory
argument_list|(
name|sessionKey
argument_list|,
name|session
operator|->
name|key
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sessionKey
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* KClientMakeSendAuth  * This routine is used to create an authenticator that is the same as those  * created by the kerberos routine SendAuth.  */
end_comment

begin_function
name|Kerr
name|KClientMakeSendAuth
parameter_list|(
name|KClientSessionInfo
modifier|*
name|session
parameter_list|,
name|char
modifier|*
name|service
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
modifier|*
name|buflen
parameter_list|,
name|long
name|checksum
parameter_list|,
name|char
modifier|*
name|applicationVersion
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* KClientVerifySendAuth  * This routine is used to verify a response made by a server doing RecvAuth.  * The two routines KClientMakeSendAuth and KClientVerifySendAuth together  * provide the functionality of SendAuth minus the transmission of authenticators  * between client->server->client.  */
end_comment

begin_function
name|Kerr
name|KClientVerifySendAuth
parameter_list|(
name|KClientSessionInfo
modifier|*
name|session
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
modifier|*
name|buflen
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* KClientEncrypt  * This routine encrypts a series a bytes for transmission to the remote host.  * For this to work properly you must be logged in and you must have specified  * the remote and local addresses in KClientInitSession. The unencrypted  * message pointed to by buf and of length buflen is returned encrypted  * in encryptBuf of length encryptLength.  * The encrypted buffer must be at least 26 bytes longer the buf.  */
end_comment

begin_function
name|Kerr
name|KClientEncrypt
parameter_list|(
name|KClientSessionInfo
modifier|*
name|session
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|buflen
parameter_list|,
name|void
modifier|*
name|encryptBuf
parameter_list|,
name|unsigned
name|long
modifier|*
name|encryptLength
parameter_list|)
block|{
name|int
name|num
init|=
literal|64
decl_stmt|;
name|des_cfb64_encrypt
argument_list|(
name|buf
argument_list|,
name|encryptBuf
argument_list|,
name|buflen
argument_list|,
operator|(
expr|struct
name|des_ks_struct
operator|*
operator|)
name|session
operator|->
name|key
argument_list|,
literal|0
argument_list|,
operator|&
name|num
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* KClientDecrypt  * This routine decrypts a series of bytes received from the remote host.   * NOTE: this routine will not reverse a KClientEncrypt call.  * It can only decrypt messages sent from the remote host.   * Instead of copying the decrypted message to an out buffer,  * the message is decrypted in place and you are returned  * an offset into the buffer where the decrypted message begins.  */
end_comment

begin_function
name|Kerr
name|KClientDecrypt
parameter_list|(
name|KClientSessionInfo
modifier|*
name|session
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|buflen
parameter_list|,
name|unsigned
name|long
modifier|*
name|decryptOffset
parameter_list|,
name|unsigned
name|long
modifier|*
name|decryptLength
parameter_list|)
block|{
name|int
name|num
decl_stmt|;
name|des_cfb64_encrypt
argument_list|(
name|buf
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
operator|(
expr|struct
name|des_ks_struct
operator|*
operator|)
name|session
operator|->
name|key
argument_list|,
literal|0
argument_list|,
operator|&
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|decryptOffset
operator|=
literal|0
expr_stmt|;
operator|*
name|decryptLength
operator|=
name|buflen
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* KClientErrorText  * This routine returns a text description of errors returned by any of  * the calls in this library.  */
end_comment

begin_function
name|char
modifier|*
name|KClientErrorText
parameter_list|(
name|Kerr
name|err
parameter_list|,
name|char
modifier|*
name|text
parameter_list|)
block|{
name|char
modifier|*
name|t
init|=
name|krb_get_err_text
argument_list|(
name|err
argument_list|)
decl_stmt|;
if|if
condition|(
name|text
condition|)
name|strcpy
argument_list|(
name|text
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

end_unit

