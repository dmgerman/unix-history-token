begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   Copyright (C) 1989 by the Massachusetts Institute of Technology     Export of this software from the United States of America is assumed    to require a specific license from the United States Government.    It is the responsibility of any person or organization contemplating    export to obtain such a license before exporting.  WITHIN THAT CONSTRAINT, permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.    */
end_comment

begin_comment
comment|/*  * Top-level loop of the kerberos Administration server  */
end_comment

begin_comment
comment|/*   admin_server.c   this holds the main loop and initialization and cleanup code for the server */
end_comment

begin_include
include|#
directive|include
file|"kadm_locl.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: admin_server.c,v 1.47 1999/07/07 12:41:07 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Almost all procs and such need this, so it is global */
end_comment

begin_decl_stmt
name|admin_params
name|prm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The command line parameters struct */
end_comment

begin_comment
comment|/* GLOBAL */
end_comment

begin_decl_stmt
name|char
modifier|*
name|acldir
init|=
name|DEFAULT_ACL_DIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|krbrlm
index|[
name|REALM_SZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|pidarraysize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|pidarray
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exit_now
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|RETSIGTYPE
name|doexit
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|exit_now
operator|=
literal|1
expr_stmt|;
name|SIGRETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|RETSIGTYPE
name|do_child
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|status
decl_stmt|;
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* Reinstall signal handlers for SysV. Must be done *after* wait */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|do_child
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pidarraysize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pidarray
index|[
name|i
index|]
operator|==
name|pid
condition|)
block|{
comment|/* found it */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|pidarraysize
operator|-
literal|1
condition|;
name|j
operator|++
control|)
comment|/* copy others down */
name|pidarray
index|[
name|j
index|]
operator|=
name|pidarray
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|pidarraysize
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|&&
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
operator|)
operator|||
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
name|krb_log
argument_list|(
literal|"child %d: termsig %d, retcode %d"
argument_list|,
name|pid
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|SIGRETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|krb_log
argument_list|(
literal|"child %d not in list: termsig %d, retcode %d"
argument_list|,
name|pid
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|SIGRETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kill_children
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pidarraysize
condition|;
name|i
operator|++
control|)
block|{
name|kill
argument_list|(
name|pidarray
index|[
name|i
index|]
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|krb_log
argument_list|(
literal|"killing child %d"
argument_list|,
name|pidarray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* close the system log file */
end_comment

begin_function
specifier|static
name|void
name|close_syslog
parameter_list|(
name|void
parameter_list|)
block|{
name|krb_log
argument_list|(
literal|"Shutting down admin server"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|byebye
parameter_list|(
name|void
parameter_list|)
comment|/* say goodnight gracie */
block|{
name|printf
argument_list|(
literal|"Admin Server (kadm server) has completed operation.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_secrets
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
name|server_parm
operator|.
name|master_key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|server_parm
operator|.
name|master_key
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|server_parm
operator|.
name|master_key_schedule
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|server_parm
operator|.
name|master_key_schedule
argument_list|)
argument_list|)
expr_stmt|;
name|server_parm
operator|.
name|master_key_version
operator|=
literal|0L
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|cleanexit
parameter_list|(
name|code
parameter_list|)
value|{kerb_fini(); return;}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_function
specifier|static
name|void
name|cleanexit
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|kerb_fini
argument_list|()
expr_stmt|;
name|clear_secrets
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|process_client
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|who
parameter_list|)
block|{
name|u_char
modifier|*
name|dat
decl_stmt|;
name|int
name|dat_len
decl_stmt|;
name|u_short
name|dlen
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|Principal
name|service
decl_stmt|;
name|des_cblock
name|skey
decl_stmt|;
name|int
name|more
decl_stmt|;
name|int
name|status
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SO_KEEPALIVE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETSOCKOPT
argument_list|)
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|krb_log
argument_list|(
literal|"setsockopt keepalive: %d"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|server_parm
operator|.
name|recv_addr
operator|=
operator|*
name|who
expr_stmt|;
if|if
condition|(
name|kerb_init
argument_list|()
condition|)
block|{
comment|/* Open as client */
name|krb_log
argument_list|(
literal|"can't open krb db"
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* need to set service key to changepw.KRB_MASTER */
name|status
operator|=
name|kerb_get_principal
argument_list|(
name|server_parm
operator|.
name|sname
argument_list|,
name|server_parm
operator|.
name|sinst
argument_list|,
operator|&
name|service
argument_list|,
literal|1
argument_list|,
operator|&
name|more
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* db locked */
name|char
modifier|*
name|pdat
decl_stmt|;
name|dat_len
operator|=
name|KADM_VERSIZE
operator|+
literal|4
expr_stmt|;
name|dat
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|dat_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dat
operator|==
name|NULL
condition|)
block|{
name|krb_log
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|pdat
operator|=
operator|(
name|char
operator|*
operator|)
name|dat
expr_stmt|;
name|memcpy
argument_list|(
name|pdat
argument_list|,
name|KADM_ULOSE
argument_list|,
name|KADM_VERSIZE
argument_list|)
expr_stmt|;
name|krb_put_int
argument_list|(
name|KADM_DB_INUSE
argument_list|,
name|pdat
operator|+
name|KADM_VERSIZE
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|status
condition|)
block|{
name|krb_log
argument_list|(
literal|"no service %s.%s"
argument_list|,
name|server_parm
operator|.
name|sname
argument_list|,
name|server_parm
operator|.
name|sinst
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|copy_to_key
argument_list|(
operator|&
name|service
operator|.
name|key_low
argument_list|,
operator|&
name|service
operator|.
name|key_high
argument_list|,
name|skey
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|service
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|service
argument_list|)
argument_list|)
expr_stmt|;
name|kdb_encrypt_key
argument_list|(
operator|&
name|skey
argument_list|,
operator|&
name|skey
argument_list|,
operator|&
name|server_parm
operator|.
name|master_key
argument_list|,
name|server_parm
operator|.
name|master_key_schedule
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
name|krb_set_key
argument_list|(
name|skey
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if error, will show up when 					    rd_req fails */
name|memset
argument_list|(
name|skey
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|skey
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|void
modifier|*
name|errpkt
decl_stmt|;
name|errpkt
operator|=
name|malloc
argument_list|(
name|KADM_VERSIZE
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|errpkt
operator|==
name|NULL
condition|)
block|{
name|krb_log
argument_list|(
literal|"malloc: no memory"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|retval
operator|=
name|krb_net_read
argument_list|(
name|fd
argument_list|,
operator|&
name|dlen
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
operator|)
operator|!=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
block|{
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|krb_log
argument_list|(
literal|"dlen read: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|retval
condition|)
name|krb_log
argument_list|(
literal|"short dlen read: %d"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
name|retval
condition|?
literal|3
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exit_now
condition|)
block|{
name|cleanexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|dat_len
operator|=
name|ntohs
argument_list|(
name|dlen
argument_list|)
expr_stmt|;
name|dat
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|dat_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dat
operator|==
name|NULL
condition|)
block|{
name|krb_log
argument_list|(
literal|"malloc: No memory"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|retval
operator|=
name|krb_net_read
argument_list|(
name|fd
argument_list|,
name|dat
argument_list|,
name|dat_len
argument_list|)
operator|)
operator|!=
name|dat_len
condition|)
block|{
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|krb_log
argument_list|(
literal|"data read: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|krb_log
argument_list|(
literal|"short read: %d vs. %d"
argument_list|,
name|dat_len
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exit_now
condition|)
block|{
name|cleanexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|retval
operator|=
name|kadm_ser_in
argument_list|(
operator|&
name|dat
argument_list|,
operator|&
name|dat_len
argument_list|,
name|errpkt
argument_list|)
operator|)
operator|!=
name|KADM_SUCCESS
condition|)
name|krb_log
argument_list|(
literal|"processing request: %s"
argument_list|,
name|error_message
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
comment|/* kadm_ser_in did the processing and returned stuff in 	   dat& dat_len , return the appropriate data */
name|out
label|:
name|dlen
operator|=
name|htons
argument_list|(
name|dat_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|krb_net_write
argument_list|(
name|fd
argument_list|,
operator|&
name|dlen
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|krb_log
argument_list|(
literal|"writing dlen to client: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|krb_net_write
argument_list|(
name|fd
argument_list|,
name|dat
argument_list|,
name|dat_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|krb_log
argument_list|(
literal|"writing to client: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dat
argument_list|)
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* kadm_listen listen on the admin servers port for a request */
end_comment

begin_function
specifier|static
name|int
name|kadm_listen
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|found
decl_stmt|;
name|int
name|admin_fd
decl_stmt|;
name|int
name|peer_fd
decl_stmt|;
name|fd_set
name|mask
decl_stmt|,
name|readfds
decl_stmt|;
name|struct
name|sockaddr_in
name|peer
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|doexit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|doexit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|doexit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|doexit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* get errors on write() */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|doexit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|do_child
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsid
argument_list|()
operator|<
literal|0
condition|)
name|krb_log
argument_list|(
literal|"setsid() failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|admin_fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|KADM_NO_SOCK
return|;
if|#
directive|if
name|defined
argument_list|(
name|SO_REUSEADDR
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETSOCKOPT
argument_list|)
block|{
name|int
name|one
init|=
literal|1
decl_stmt|;
name|setsockopt
argument_list|(
name|admin_fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|one
argument_list|,
sizeof|sizeof
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bind
argument_list|(
name|admin_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server_parm
operator|.
name|admin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
name|KADM_NO_BIND
return|;
name|listen
argument_list|(
name|admin_fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|admin_fd
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* loop nearly forever */
if|if
condition|(
name|exit_now
condition|)
block|{
name|clear_secrets
argument_list|()
expr_stmt|;
name|kill_children
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|readfds
operator|=
name|mask
expr_stmt|;
if|if
condition|(
operator|(
name|found
operator|=
name|select
argument_list|(
name|admin_fd
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* no things read */
if|if
condition|(
name|found
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|krb_log
argument_list|(
literal|"select: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|admin_fd
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
comment|/* accept the conn */
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|peer_fd
operator|=
name|accept
argument_list|(
name|admin_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|peer
argument_list|,
operator|&
name|addrlen
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|krb_log
argument_list|(
literal|"accept: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifndef|#
directive|ifndef
name|DEBUG
comment|/* if you want a sep daemon for each server */
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
name|void
modifier|*
name|tmp
decl_stmt|;
comment|/* parent */
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|krb_log
argument_list|(
literal|"fork: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|peer_fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* fork succeded: keep tabs on child */
name|close
argument_list|(
name|peer_fd
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|realloc
argument_list|(
name|pidarray
argument_list|,
operator|(
name|pidarraysize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|pidarray
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|krb_log
argument_list|(
literal|"malloc: no memory. pid %u on its own"
argument_list|,
operator|(
name|unsigned
operator|)
name|pid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pidarray
operator|=
name|tmp
expr_stmt|;
name|pidarray
index|[
name|pidarraysize
operator|++
index|]
operator|=
name|pid
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* child */
name|close
argument_list|(
name|admin_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 		 * If we are multihomed we need to figure out which 		 * local address that is used this time since it is 		 * used in "direction" comparison. 		 */
name|getsockname
argument_list|(
name|peer_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server_parm
operator|.
name|admin_addr
argument_list|,
operator|&
name|addrlen
argument_list|)
expr_stmt|;
comment|/* do stuff */
name|process_client
argument_list|(
name|peer_fd
argument_list|,
operator|&
name|peer
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|krb_log
argument_list|(
literal|"something else woke me up!"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* ** Main does the logical thing, it sets up the database and RPC interface, **  as well as handling the creation and maintenance of the syslog file... */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
comment|/* admin_server main routine */
block|{
name|int
name|errval
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|in_addr
name|i_addr
decl_stmt|;
name|set_progname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|umask
argument_list|(
literal|077
argument_list|)
expr_stmt|;
comment|/* Create protected files */
name|i_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
comment|/* initialize the admin_params structure */
name|prm
operator|.
name|sysfile
operator|=
name|KADM_SYSLOG
expr_stmt|;
comment|/* default file name */
name|prm
operator|.
name|inter
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|krbrlm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|krbrlm
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f:hmnd:a:r:i:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* Syslog file name change */
name|prm
operator|.
name|sysfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|prm
operator|.
name|inter
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|prm
operator|.
name|inter
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* new acl directory */
name|acldir
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* put code to deal with alt database place */
if|if
condition|(
operator|(
name|errval
operator|=
name|kerb_db_set_name
argument_list|(
name|optarg
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"opening database %s: %s"
argument_list|,
name|optarg
argument_list|,
name|error_message
argument_list|(
name|errval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|strcpy_truncate
argument_list|(
name|krbrlm
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|krbrlm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Only listen on this address */
if|if
condition|(
name|inet_aton
argument_list|(
name|optarg
argument_list|,
operator|&
name|i_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad address: %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'h'
case|:
comment|/* get help on using admin_server */
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Usage: kadmind [-h] [-n] [-m] [-r realm] [-d dbname] [-f filename] [-a acldir] [-i address_to_listen_on]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|krbrlm
index|[
literal|0
index|]
operator|==
literal|0
condition|)
if|if
condition|(
name|krb_get_lrealm
argument_list|(
name|krbrlm
argument_list|,
literal|1
argument_list|)
operator|!=
name|KSUCCESS
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unable to get local realm.  Fix krb.conf or use -r."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"KADM Server %s initializing\n"
argument_list|,
name|KADM_VERSTR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Please do not use 'kill -9' to kill this job, use a\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"regular kill instead\n\n"
argument_list|)
expr_stmt|;
name|kset_logfile
argument_list|(
name|prm
operator|.
name|sysfile
argument_list|)
expr_stmt|;
name|krb_log
argument_list|(
literal|"Admin server starting"
argument_list|)
expr_stmt|;
name|kerb_db_set_lockmode
argument_list|(
name|KERB_DBL_NONBLOCKING
argument_list|)
expr_stmt|;
name|errval
operator|=
name|kerb_init
argument_list|()
expr_stmt|;
comment|/* Open the Kerberos database */
if|if
condition|(
name|errval
condition|)
block|{
name|warnx
argument_list|(
literal|"error: kerb_init() failed"
argument_list|)
expr_stmt|;
name|close_syslog
argument_list|()
expr_stmt|;
name|byebye
argument_list|()
expr_stmt|;
block|}
comment|/* set up the server_parm struct */
if|if
condition|(
operator|(
name|errval
operator|=
name|kadm_ser_init
argument_list|(
name|prm
operator|.
name|inter
argument_list|,
name|krbrlm
argument_list|,
name|i_addr
argument_list|)
operator|)
operator|==
name|KADM_SUCCESS
condition|)
block|{
name|kerb_fini
argument_list|()
expr_stmt|;
comment|/* Close the Kerberos database-- 					   will re-open later */
name|errval
operator|=
name|kadm_listen
argument_list|()
expr_stmt|;
comment|/* listen for calls to server from 					   clients */
block|}
if|if
condition|(
name|errval
operator|!=
name|KADM_SUCCESS
condition|)
block|{
name|warnx
argument_list|(
literal|"error:  %s"
argument_list|,
name|error_message
argument_list|(
name|errval
argument_list|)
argument_list|)
expr_stmt|;
name|kerb_fini
argument_list|()
expr_stmt|;
comment|/* Close if error */
block|}
name|close_syslog
argument_list|()
expr_stmt|;
comment|/* Close syslog file, print 					   closing note */
name|byebye
argument_list|()
expr_stmt|;
comment|/* Say bye bye on the terminal 					   in use */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* procedure main */
end_comment

end_unit

