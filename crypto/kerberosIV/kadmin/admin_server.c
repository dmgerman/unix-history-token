begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   Copyright (C) 1989 by the Massachusetts Institute of Technology     Export of this software from the United States of America is assumed    to require a specific license from the United States Government.    It is the responsibility of any person or organization contemplating    export to obtain such a license before exporting.  WITHIN THAT CONSTRAINT, permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.    */
end_comment

begin_comment
comment|/*  * Top-level loop of the kerberos Administration server  */
end_comment

begin_comment
comment|/*   admin_server.c   this holds the main loop and initialization and cleanup code for the server */
end_comment

begin_include
include|#
directive|include
file|"kadm_locl.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: admin_server.c,v 1.49.2.2 2000/10/18 20:24:57 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Almost all procs and such need this, so it is global */
end_comment

begin_decl_stmt
name|admin_params
name|prm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The command line parameters struct */
end_comment

begin_comment
comment|/* GLOBAL */
end_comment

begin_decl_stmt
name|char
modifier|*
name|acldir
init|=
name|DEFAULT_ACL_DIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|krbrlm
index|[
name|REALM_SZ
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXCHILDREN
value|100
end_define

begin_struct
struct|struct
name|child
block|{
name|pid_t
name|pid
decl_stmt|;
name|int
name|pipe_fd
decl_stmt|;
name|int
name|authenticated
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|unsigned
name|nchildren
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|child
name|children
index|[
name|MAXCHILDREN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exit_now
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|RETSIGTYPE
name|doexit
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|exit_now
operator|=
literal|1
expr_stmt|;
name|SIGRETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|sig_atomic_t
name|do_wait
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|RETSIGTYPE
name|do_child
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|do_wait
operator|=
literal|1
expr_stmt|;
name|SIGRETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kill_children
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchildren
condition|;
name|i
operator|++
control|)
block|{
name|kill
argument_list|(
name|children
index|[
name|i
index|]
operator|.
name|pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|children
index|[
name|i
index|]
operator|.
name|pipe_fd
argument_list|)
expr_stmt|;
name|krb_log
argument_list|(
literal|"killing child %d"
argument_list|,
name|children
index|[
name|i
index|]
operator|.
name|pid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* close the system log file */
end_comment

begin_function
specifier|static
name|void
name|close_syslog
parameter_list|(
name|void
parameter_list|)
block|{
name|krb_log
argument_list|(
literal|"Shutting down admin server"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|byebye
parameter_list|(
name|void
parameter_list|)
comment|/* say goodnight gracie */
block|{
name|printf
argument_list|(
literal|"Admin Server (kadm server) has completed operation.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_secrets
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
name|server_parm
operator|.
name|master_key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|server_parm
operator|.
name|master_key
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|server_parm
operator|.
name|master_key_schedule
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|server_parm
operator|.
name|master_key_schedule
argument_list|)
argument_list|)
expr_stmt|;
name|server_parm
operator|.
name|master_key_version
operator|=
literal|0L
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cleanexit
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|kerb_fini
argument_list|()
expr_stmt|;
name|clear_secrets
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|RETSIGTYPE
name|sigalrm
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|cleanexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * handle the client on the socket `fd' from `who'  * `signal_fd' is a pipe on which to signal when the user has been  * authenticated  */
end_comment

begin_function
specifier|static
name|void
name|process_client
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|who
parameter_list|,
name|int
name|signal_fd
parameter_list|)
block|{
name|u_char
modifier|*
name|dat
decl_stmt|;
name|int
name|dat_len
decl_stmt|;
name|u_short
name|dlen
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|Principal
name|service
decl_stmt|;
name|des_cblock
name|skey
decl_stmt|;
name|int
name|more
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|authenticated
init|=
literal|0
decl_stmt|;
comment|/* make this connection time-out after 1 second if the user has        not managed one transaction succesfully in kadm_ser_in */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|sigalrm
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SO_KEEPALIVE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETSOCKOPT
argument_list|)
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|krb_log
argument_list|(
literal|"setsockopt keepalive: %d"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|server_parm
operator|.
name|recv_addr
operator|=
operator|*
name|who
expr_stmt|;
if|if
condition|(
name|kerb_init
argument_list|()
condition|)
block|{
comment|/* Open as client */
name|krb_log
argument_list|(
literal|"can't open krb db"
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* need to set service key to changepw.KRB_MASTER */
name|status
operator|=
name|kerb_get_principal
argument_list|(
name|server_parm
operator|.
name|sname
argument_list|,
name|server_parm
operator|.
name|sinst
argument_list|,
operator|&
name|service
argument_list|,
literal|1
argument_list|,
operator|&
name|more
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* db locked */
name|char
modifier|*
name|pdat
decl_stmt|;
name|dat_len
operator|=
name|KADM_VERSIZE
operator|+
literal|4
expr_stmt|;
name|dat
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|dat_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dat
operator|==
name|NULL
condition|)
block|{
name|krb_log
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|pdat
operator|=
operator|(
name|char
operator|*
operator|)
name|dat
expr_stmt|;
name|memcpy
argument_list|(
name|pdat
argument_list|,
name|KADM_ULOSE
argument_list|,
name|KADM_VERSIZE
argument_list|)
expr_stmt|;
name|krb_put_int
argument_list|(
name|KADM_DB_INUSE
argument_list|,
name|pdat
operator|+
name|KADM_VERSIZE
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|status
condition|)
block|{
name|krb_log
argument_list|(
literal|"no service %s.%s"
argument_list|,
name|server_parm
operator|.
name|sname
argument_list|,
name|server_parm
operator|.
name|sinst
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|copy_to_key
argument_list|(
operator|&
name|service
operator|.
name|key_low
argument_list|,
operator|&
name|service
operator|.
name|key_high
argument_list|,
name|skey
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|service
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|service
argument_list|)
argument_list|)
expr_stmt|;
name|kdb_encrypt_key
argument_list|(
operator|&
name|skey
argument_list|,
operator|&
name|skey
argument_list|,
operator|&
name|server_parm
operator|.
name|master_key
argument_list|,
name|server_parm
operator|.
name|master_key_schedule
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
name|krb_set_key
argument_list|(
name|skey
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if error, will show up when 					    rd_req fails */
name|memset
argument_list|(
name|skey
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|skey
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|void
modifier|*
name|errpkt
decl_stmt|;
name|errpkt
operator|=
name|malloc
argument_list|(
name|KADM_VERSIZE
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|errpkt
operator|==
name|NULL
condition|)
block|{
name|krb_log
argument_list|(
literal|"malloc: no memory"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|retval
operator|=
name|krb_net_read
argument_list|(
name|fd
argument_list|,
operator|&
name|dlen
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
operator|)
operator|!=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
block|{
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|krb_log
argument_list|(
literal|"dlen read: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|retval
condition|)
name|krb_log
argument_list|(
literal|"short dlen read: %d"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
name|retval
condition|?
literal|3
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exit_now
condition|)
block|{
name|cleanexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|dat_len
operator|=
name|ntohs
argument_list|(
name|dlen
argument_list|)
expr_stmt|;
name|dat
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|dat_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dat
operator|==
name|NULL
condition|)
block|{
name|krb_log
argument_list|(
literal|"malloc: No memory"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|retval
operator|=
name|krb_net_read
argument_list|(
name|fd
argument_list|,
name|dat
argument_list|,
name|dat_len
argument_list|)
operator|)
operator|!=
name|dat_len
condition|)
block|{
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|krb_log
argument_list|(
literal|"data read: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|krb_log
argument_list|(
literal|"short read: %d vs. %d"
argument_list|,
name|dat_len
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exit_now
condition|)
block|{
name|cleanexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|kadm_ser_in
argument_list|(
operator|&
name|dat
argument_list|,
operator|&
name|dat_len
argument_list|,
name|errpkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|KADM_SUCCESS
condition|)
block|{
if|if
condition|(
operator|!
name|authenticated
condition|)
block|{
name|unsigned
name|char
name|one
init|=
literal|1
decl_stmt|;
name|authenticated
operator|=
literal|1
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|signal_fd
argument_list|,
operator|&
name|one
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|krb_log
argument_list|(
literal|"processing request: %s"
argument_list|,
name|error_message
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* kadm_ser_in did the processing and returned stuff in 	   dat& dat_len , return the appropriate data */
name|out
label|:
name|dlen
operator|=
name|htons
argument_list|(
name|dat_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|krb_net_write
argument_list|(
name|fd
argument_list|,
operator|&
name|dlen
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|krb_log
argument_list|(
literal|"writing dlen to client: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|krb_net_write
argument_list|(
name|fd
argument_list|,
name|dat
argument_list|,
name|dat_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|krb_log
argument_list|(
literal|"writing to client: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|cleanexit
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dat
argument_list|)
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_function
specifier|static
name|void
name|accept_client
parameter_list|(
name|int
name|admin_fd
parameter_list|)
block|{
name|int
name|pipe_fd
index|[
literal|2
index|]
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|struct
name|sockaddr_in
name|peer
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|peer_fd
decl_stmt|;
comment|/* using up the maximum number of children, try to get rid        of one unauthenticated one */
if|if
condition|(
name|nchildren
operator|>=
name|MAXCHILDREN
condition|)
block|{
name|int
name|i
decl_stmt|,
name|nunauth
init|=
literal|0
decl_stmt|;
name|int
name|victim
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchildren
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|children
index|[
name|i
index|]
operator|.
name|authenticated
operator|==
literal|0
condition|)
operator|++
name|nunauth
expr_stmt|;
if|if
condition|(
name|nunauth
operator|==
literal|0
condition|)
return|return;
name|victim
operator|=
name|rand
argument_list|()
operator|%
name|nchildren
expr_stmt|;
if|if
condition|(
name|children
index|[
name|victim
index|]
operator|.
name|authenticated
operator|==
literal|0
condition|)
block|{
name|kill
argument_list|(
name|children
index|[
name|victim
index|]
operator|.
name|pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|children
index|[
name|victim
index|]
operator|.
name|pipe_fd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|victim
init|;
name|i
operator|<
name|nchildren
condition|;
operator|++
name|i
control|)
name|children
index|[
name|i
index|]
operator|=
name|children
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
operator|--
name|nchildren
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* accept the conn */
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer_fd
operator|=
name|accept
argument_list|(
name|admin_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|peer
argument_list|,
operator|&
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer_fd
operator|<
literal|0
condition|)
block|{
name|krb_log
argument_list|(
literal|"accept: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|pipe_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|krb_log
argument_list|(
literal|"pipe: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pipe_fd
index|[
literal|0
index|]
operator|>=
name|FD_SETSIZE
operator|||
name|pipe_fd
index|[
literal|1
index|]
operator|>=
name|FD_SETSIZE
condition|)
block|{
name|krb_log
argument_list|(
literal|"pipe fds too large"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipe_fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|krb_log
argument_list|(
literal|"fork: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipe_fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pid
operator|!=
literal|0
condition|)
block|{
comment|/* parent */
comment|/* fork succeded: keep tabs on child */
name|close
argument_list|(
name|peer_fd
argument_list|)
expr_stmt|;
name|children
index|[
name|nchildren
index|]
operator|.
name|pid
operator|=
name|pid
expr_stmt|;
name|children
index|[
name|nchildren
index|]
operator|.
name|pipe_fd
operator|=
name|pipe_fd
index|[
literal|0
index|]
expr_stmt|;
name|children
index|[
name|nchildren
index|]
operator|.
name|authenticated
operator|=
literal|0
expr_stmt|;
operator|++
name|nchildren
expr_stmt|;
name|close
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* child */
name|close
argument_list|(
name|admin_fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipe_fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchildren
condition|;
operator|++
name|i
control|)
name|close
argument_list|(
name|children
index|[
name|i
index|]
operator|.
name|pipe_fd
argument_list|)
expr_stmt|;
comment|/* 	 * If we are multihomed we need to figure out which 	 * local address that is used this time since it is 	 * used in "direction" comparison. 	 */
name|getsockname
argument_list|(
name|peer_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server_parm
operator|.
name|admin_addr
argument_list|,
operator|&
name|addrlen
argument_list|)
expr_stmt|;
comment|/* do stuff */
name|process_client
argument_list|(
name|peer_fd
argument_list|,
operator|&
name|peer
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * handle data signaled from child `child' kadmind  */
end_comment

begin_function
specifier|static
name|void
name|handle_child_signal
parameter_list|(
name|int
name|child
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|1
index|]
decl_stmt|;
name|ret
operator|=
name|read
argument_list|(
name|children
index|[
name|child
index|]
operator|.
name|pipe_fd
argument_list|,
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|krb_log
argument_list|(
literal|"read from child %d: %s"
argument_list|,
name|child
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|children
index|[
name|child
index|]
operator|.
name|pipe_fd
argument_list|)
expr_stmt|;
name|children
index|[
name|child
index|]
operator|.
name|pipe_fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|data
condition|)
name|children
index|[
name|child
index|]
operator|.
name|authenticated
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * handle dead children  */
end_comment

begin_function
specifier|static
name|void
name|handle_sigchld
parameter_list|(
name|void
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|pid
operator|=
name|waitpid
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
operator||
name|WUNTRACED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
operator|||
operator|(
name|pid
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ECHILD
operator|)
condition|)
break|break;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|krb_log
argument_list|(
literal|"waitpid: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchildren
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|children
index|[
name|i
index|]
operator|.
name|pid
operator|==
name|pid
condition|)
block|{
comment|/* found it */
name|close
argument_list|(
name|children
index|[
name|i
index|]
operator|.
name|pipe_fd
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|nchildren
condition|;
name|j
operator|++
control|)
comment|/* copy others down */
name|children
index|[
name|j
index|]
operator|=
name|children
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
operator|--
name|nchildren
expr_stmt|;
if|#
directive|if
literal|0
block|if ((WIFEXITED(status)&& WEXITSTATUS(status) != 0) 		    || WIFSIGNALED(status)) 		    krb_log("child %d: termsig %d, retcode %d", pid, 			    WTERMSIG(status), WEXITSTATUS(status));
endif|#
directive|endif
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (!found) 	    krb_log("child %d not in list: termsig %d, retcode %d", pid, 		    WTERMSIG(status), WEXITSTATUS(status));
endif|#
directive|endif
block|}
name|do_wait
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* kadm_listen listen on the admin servers port for a request */
end_comment

begin_function
specifier|static
name|int
name|kadm_listen
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|found
decl_stmt|;
name|int
name|admin_fd
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|doexit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|doexit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|doexit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|doexit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* get errors on write() */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|doexit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|do_child
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsid
argument_list|()
operator|<
literal|0
condition|)
name|krb_log
argument_list|(
literal|"setsid() failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|admin_fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|KADM_NO_SOCK
return|;
if|if
condition|(
name|admin_fd
operator|>=
name|FD_SETSIZE
condition|)
block|{
name|krb_log
argument_list|(
literal|"admin_fd too big"
argument_list|)
expr_stmt|;
return|return
name|KADM_NO_BIND
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SO_REUSEADDR
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETSOCKOPT
argument_list|)
block|{
name|int
name|one
init|=
literal|1
decl_stmt|;
name|setsockopt
argument_list|(
name|admin_fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|one
argument_list|,
sizeof|sizeof
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bind
argument_list|(
name|admin_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server_parm
operator|.
name|admin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
name|KADM_NO_BIND
return|;
if|if
condition|(
name|listen
argument_list|(
name|admin_fd
argument_list|,
name|SOMAXCONN
argument_list|)
operator|<
literal|0
condition|)
return|return
name|KADM_NO_BIND
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* loop nearly forever */
name|int
name|i
decl_stmt|;
name|int
name|maxfd
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|exit_now
condition|)
block|{
name|clear_secrets
argument_list|()
expr_stmt|;
name|kill_children
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|do_wait
condition|)
name|handle_sigchld
argument_list|()
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|admin_fd
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|maxfd
operator|=
name|max
argument_list|(
name|maxfd
argument_list|,
name|admin_fd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchildren
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|children
index|[
name|i
index|]
operator|.
name|pipe_fd
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|children
index|[
name|i
index|]
operator|.
name|pipe_fd
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|maxfd
operator|=
name|max
argument_list|(
name|maxfd
argument_list|,
name|children
index|[
name|i
index|]
operator|.
name|pipe_fd
argument_list|)
expr_stmt|;
block|}
name|found
operator|=
name|select
argument_list|(
name|maxfd
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|krb_log
argument_list|(
literal|"select: %s"
argument_list|,
name|error_message
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|admin_fd
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
name|accept_client
argument_list|(
name|admin_fd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchildren
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|children
index|[
name|i
index|]
operator|.
name|pipe_fd
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|children
index|[
name|i
index|]
operator|.
name|pipe_fd
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
name|handle_child_signal
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* ** Main does the logical thing, it sets up the database and RPC interface, **  as well as handling the creation and maintenance of the syslog file... */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
comment|/* admin_server main routine */
block|{
name|int
name|errval
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|in_addr
name|i_addr
decl_stmt|;
name|set_progname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|umask
argument_list|(
literal|077
argument_list|)
expr_stmt|;
comment|/* Create protected files */
name|i_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
comment|/* initialize the admin_params structure */
name|prm
operator|.
name|sysfile
operator|=
name|KADM_SYSLOG
expr_stmt|;
comment|/* default file name */
name|prm
operator|.
name|inter
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|krbrlm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|krbrlm
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f:hmnd:a:r:i:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* Syslog file name change */
name|prm
operator|.
name|sysfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|prm
operator|.
name|inter
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|prm
operator|.
name|inter
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* new acl directory */
name|acldir
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* put code to deal with alt database place */
if|if
condition|(
operator|(
name|errval
operator|=
name|kerb_db_set_name
argument_list|(
name|optarg
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"opening database %s: %s"
argument_list|,
name|optarg
argument_list|,
name|error_message
argument_list|(
name|errval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|strlcpy
argument_list|(
name|krbrlm
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|krbrlm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Only listen on this address */
if|if
condition|(
name|inet_aton
argument_list|(
name|optarg
argument_list|,
operator|&
name|i_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad address: %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'h'
case|:
comment|/* get help on using admin_server */
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Usage: kadmind [-h] [-n] [-m] [-r realm] [-d dbname] [-f filename] [-a acldir] [-i address_to_listen_on]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|krbrlm
index|[
literal|0
index|]
operator|==
literal|0
condition|)
if|if
condition|(
name|krb_get_lrealm
argument_list|(
name|krbrlm
argument_list|,
literal|1
argument_list|)
operator|!=
name|KSUCCESS
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unable to get local realm.  Fix krb.conf or use -r."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"KADM Server %s initializing\n"
argument_list|,
name|KADM_VERSTR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Please do not use 'kill -9' to kill this job, use a\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"regular kill instead\n\n"
argument_list|)
expr_stmt|;
name|kset_logfile
argument_list|(
name|prm
operator|.
name|sysfile
argument_list|)
expr_stmt|;
name|krb_log
argument_list|(
literal|"Admin server starting"
argument_list|)
expr_stmt|;
name|kerb_db_set_lockmode
argument_list|(
name|KERB_DBL_NONBLOCKING
argument_list|)
expr_stmt|;
name|errval
operator|=
name|kerb_init
argument_list|()
expr_stmt|;
comment|/* Open the Kerberos database */
if|if
condition|(
name|errval
condition|)
block|{
name|warnx
argument_list|(
literal|"error: kerb_init() failed"
argument_list|)
expr_stmt|;
name|close_syslog
argument_list|()
expr_stmt|;
name|byebye
argument_list|()
expr_stmt|;
block|}
comment|/* set up the server_parm struct */
if|if
condition|(
operator|(
name|errval
operator|=
name|kadm_ser_init
argument_list|(
name|prm
operator|.
name|inter
argument_list|,
name|krbrlm
argument_list|,
name|i_addr
argument_list|)
operator|)
operator|==
name|KADM_SUCCESS
condition|)
block|{
name|kerb_fini
argument_list|()
expr_stmt|;
comment|/* Close the Kerberos database-- 					   will re-open later */
name|errval
operator|=
name|kadm_listen
argument_list|()
expr_stmt|;
comment|/* listen for calls to server from 					   clients */
block|}
if|if
condition|(
name|errval
operator|!=
name|KADM_SUCCESS
condition|)
block|{
name|warnx
argument_list|(
literal|"error:  %s"
argument_list|,
name|error_message
argument_list|(
name|errval
argument_list|)
argument_list|)
expr_stmt|;
name|kerb_fini
argument_list|()
expr_stmt|;
comment|/* Close if error */
block|}
name|close_syslog
argument_list|()
expr_stmt|;
comment|/* Close syslog file, print 					   closing note */
name|byebye
argument_list|()
expr_stmt|;
comment|/* Say bye bye on the terminal 					   in use */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* procedure main */
end_comment

end_unit

