begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).   * All rights reserved.   *  * Redistribution and use in source and binary forms, with or without   * modification, are permitted provided that the following conditions   * are met:   *  * 1. Redistributions of source code must retain the above copyright   *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright   *    notice, this list of conditions and the following disclaimer in the   *    documentation and/or other materials provided with the distribution.   *  * 3. Neither the name of the Institute nor the names of its contributors   *    may be used to endorse or promote products derived from this software   *    without specific prior written permission.   *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF   * SUCH DAMAGE.   */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"kadm_locl.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: random_password.c,v 1.4 1999/12/02 16:58:36 joda Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This file defines some a function that generates a random password,    that can be used when creating a large amount of principals (such    as for a batch of students). Since this is a political matter, you    should think about how secure generated passwords has to be.        Both methods defined here will give you at least 55 bits of    entropy.    */
end_comment

begin_comment
comment|/* If you want OTP-style passwords, define OTP_STYLE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OTP_STYLE
end_ifdef

begin_include
include|#
directive|include
file|<otp.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|generate_password
parameter_list|(
name|char
modifier|*
modifier|*
name|pw
parameter_list|,
name|int
name|num_classes
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|random_password
parameter_list|(
name|char
modifier|*
name|pw
parameter_list|,
name|size_t
name|len
parameter_list|,
name|u_int32_t
modifier|*
name|low
parameter_list|,
name|u_int32_t
modifier|*
name|high
parameter_list|)
block|{
name|des_cblock
name|newkey
decl_stmt|;
ifdef|#
directive|ifdef
name|OTP_STYLE
name|des_random_key
argument_list|(
operator|&
name|newkey
argument_list|)
expr_stmt|;
name|otp_print_stddict
argument_list|(
name|newkey
argument_list|,
name|pw
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strlwr
argument_list|(
name|pw
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|pass
decl_stmt|;
name|generate_password
argument_list|(
operator|&
name|pass
argument_list|,
literal|3
argument_list|,
literal|"abcdefghijklmnopqrstuvwxyz"
argument_list|,
literal|7
argument_list|,
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
argument_list|,
literal|2
argument_list|,
literal|"@$%&*()-+=:,/<>1234567890"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|pw
argument_list|,
name|pass
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pass
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|pass
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pass
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|des_string_to_key
argument_list|(
name|pw
argument_list|,
operator|&
name|newkey
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|low
argument_list|,
name|newkey
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|high
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|newkey
operator|)
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|newkey
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|newkey
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|low
operator|=
name|htonl
argument_list|(
operator|*
name|low
argument_list|)
expr_stmt|;
operator|*
name|high
operator|=
name|htonl
argument_list|(
operator|*
name|high
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* some helper functions */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OTP_STYLE
end_ifndef

begin_comment
comment|/* return a random value in range 0-127 */
end_comment

begin_function
specifier|static
name|int
name|RND
parameter_list|(
name|des_cblock
modifier|*
name|key
parameter_list|,
name|int
modifier|*
name|left
parameter_list|)
block|{
if|if
condition|(
operator|*
name|left
operator|==
literal|0
condition|)
block|{
name|des_random_key
argument_list|(
operator|*
name|key
argument_list|)
expr_stmt|;
operator|*
name|left
operator|=
literal|8
expr_stmt|;
block|}
operator|(
operator|*
name|left
operator|)
operator|--
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|)
index|[
operator|*
name|left
index|]
return|;
block|}
end_function

begin_comment
comment|/* This a helper function that generates a random password with a    number of characters from a set of character classes.     If there are n classes, and the size of each class is Pi, and the    number of characters from each class is Ni, the number of possible    passwords are (given that the character classes are disjoint):       n             n    -----        /  ----  \    |   |  Ni    |  \     |    |   | Pi     |   \  Ni| !    |   | ---- * |   /    |    |   | Ni!    |  /___  |     i=1          \  i=1  /         Since it uses the RND function above, neither the size of each     class, nor the total length of the generated password should be     larger than 127 (without fixing RND).        */
end_comment

begin_function
specifier|static
name|void
name|generate_password
parameter_list|(
name|char
modifier|*
modifier|*
name|pw
parameter_list|,
name|int
name|num_classes
parameter_list|,
modifier|...
parameter_list|)
block|{
struct|struct
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|freq
decl_stmt|;
block|}
modifier|*
name|classes
struct|;
name|va_list
name|ap
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|des_cblock
name|rbuf
decl_stmt|;
comment|/* random buffer */
name|int
name|rleft
init|=
literal|0
decl_stmt|;
name|classes
operator|=
name|malloc
argument_list|(
name|num_classes
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|classes
argument_list|)
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|num_classes
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_classes
condition|;
name|i
operator|++
control|)
block|{
name|classes
index|[
name|i
index|]
operator|.
name|str
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|classes
index|[
name|i
index|]
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|classes
index|[
name|i
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|classes
index|[
name|i
index|]
operator|.
name|freq
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|len
operator|+=
name|classes
index|[
name|i
index|]
operator|.
name|freq
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|*
name|pw
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pw
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|x
init|=
name|RND
argument_list|(
operator|&
name|rbuf
argument_list|,
operator|&
name|rleft
argument_list|)
operator|%
operator|(
name|len
operator|-
name|i
operator|)
decl_stmt|;
name|int
name|t
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_classes
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|x
operator|<
name|t
operator|+
name|classes
index|[
name|j
index|]
operator|.
name|freq
condition|)
block|{
operator|(
operator|*
name|pw
operator|)
index|[
name|i
index|]
operator|=
name|classes
index|[
name|j
index|]
operator|.
name|str
index|[
name|RND
argument_list|(
operator|&
name|rbuf
argument_list|,
operator|&
name|rleft
argument_list|)
operator|%
name|classes
index|[
name|j
index|]
operator|.
name|len
index|]
expr_stmt|;
name|classes
index|[
name|j
index|]
operator|.
name|freq
operator|--
expr_stmt|;
break|break;
block|}
name|t
operator|+=
name|classes
index|[
name|j
index|]
operator|.
name|freq
expr_stmt|;
block|}
block|}
operator|(
operator|*
name|pw
operator|)
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|memset
argument_list|(
name|rbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|classes
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

