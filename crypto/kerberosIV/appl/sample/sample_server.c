begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Copyright 1987, 1988 by the Massachusetts Institute of Technology.  *  * For copying and distribution information,  * please see the file<mit-copyright.h>.  *  * sample_server:  * A sample Kerberos server, which reads a ticket from a TCP socket,  * decodes it, and writes back the results (in ASCII) to the client.  *  * Usage:  * sample_server  *  * file descriptor 0 (zero) should be a socket connected to the requesting  * client (this will be correct if this server is started by inetd).  */
end_comment

begin_include
include|#
directive|include
file|"sample.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: sample_server.c,v 1.14 1999/11/13 06:28:49 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-i] [-s service] [-t srvtab]\n"
argument_list|,
name|__progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|peername
decl_stmt|,
name|myname
decl_stmt|;
name|int
name|namelen
init|=
sizeof|sizeof
argument_list|(
name|peername
argument_list|)
decl_stmt|;
name|int
name|status
decl_stmt|,
name|count
decl_stmt|,
name|len
decl_stmt|;
name|long
name|authopts
decl_stmt|;
name|AUTH_DAT
name|auth_data
decl_stmt|;
name|KTEXT_ST
name|clt_ticket
decl_stmt|;
name|des_key_schedule
name|sched
decl_stmt|;
name|char
name|instance
index|[
name|INST_SZ
index|]
decl_stmt|;
name|char
name|service
index|[
name|ANAME_SZ
index|]
decl_stmt|;
name|char
name|version
index|[
name|KRB_SENDAUTH_VLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|retbuf
index|[
literal|512
index|]
decl_stmt|;
name|char
name|lname
index|[
name|ANAME_SZ
index|]
decl_stmt|;
name|char
name|srvtab
index|[
name|MaxPathLen
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|no_inetd
init|=
literal|0
decl_stmt|;
comment|/* open a log connection */
name|set_progname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|roken_openlog
argument_list|(
name|__progname
argument_list|,
name|LOG_ODELAY
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|service
argument_list|,
name|SAMPLE_SERVICE
argument_list|,
sizeof|sizeof
argument_list|(
name|service
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|srvtab
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"s:t:i"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'s'
case|:
name|strlcpy
argument_list|(
name|service
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|service
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|strlcpy
argument_list|(
name|srvtab
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|srvtab
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|no_inetd
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default :
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|no_inetd
condition|)
name|mini_inetd
argument_list|(
name|htons
argument_list|(
name|SAMPLE_PORT
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * To verify authenticity, we need to know the address of the      * client.      */
if|if
condition|(
name|getpeername
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|peername
argument_list|,
operator|&
name|namelen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getpeername: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* for mutual authentication, we need to know our address */
name|namelen
operator|=
sizeof|sizeof
argument_list|(
name|myname
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|myname
argument_list|,
operator|&
name|namelen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getsocknamename: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* read the authenticator and decode it.  Using `k_getsockinst' we      * always get the right instance on a multi-homed host.      */
name|k_getsockinst
argument_list|(
name|STDIN_FILENO
argument_list|,
name|instance
argument_list|,
sizeof|sizeof
argument_list|(
name|instance
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we want mutual authentication */
name|authopts
operator|=
name|KOPT_DO_MUTUAL
expr_stmt|;
name|status
operator|=
name|krb_recvauth
argument_list|(
name|authopts
argument_list|,
name|STDIN_FILENO
argument_list|,
operator|&
name|clt_ticket
argument_list|,
name|service
argument_list|,
name|instance
argument_list|,
operator|&
name|peername
argument_list|,
operator|&
name|myname
argument_list|,
operator|&
name|auth_data
argument_list|,
name|srvtab
argument_list|,
name|sched
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|KSUCCESS
condition|)
block|{
name|snprintf
argument_list|(
name|retbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|retbuf
argument_list|)
argument_list|,
literal|"Kerberos error: %s\n"
argument_list|,
name|krb_get_err_text
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|retbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check the version string (KRB_SENDAUTH_VLEN chars) */
if|if
condition|(
name|strncmp
argument_list|(
name|version
argument_list|,
name|SAMPLE_VERSION
argument_list|,
name|KRB_SENDAUTH_VLEN
argument_list|)
condition|)
block|{
comment|/* didn't match the expected version */
comment|/* could do something different, but we just log an error 	       and continue */
name|version
index|[
literal|8
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* make sure null term */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Version mismatch: '%s' isn't '%s'"
argument_list|,
name|version
argument_list|,
name|SAMPLE_VERSION
argument_list|)
expr_stmt|;
block|}
comment|/* now that we have decoded the authenticator, translate 	   the kerberos principal.instance@realm into a local name */
if|if
condition|(
name|krb_kntoln
argument_list|(
operator|&
name|auth_data
argument_list|,
name|lname
argument_list|)
operator|!=
name|KSUCCESS
condition|)
name|strlcpy
argument_list|(
name|lname
argument_list|,
literal|"*No local name returned by krb_kntoln*"
argument_list|,
sizeof|sizeof
argument_list|(
name|lname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compose the reply */
name|snprintf
argument_list|(
name|retbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|retbuf
argument_list|)
argument_list|,
literal|"You are %s.%s@%s (local name %s),\n at address %s, version %s, cksum %ld\n"
argument_list|,
name|auth_data
operator|.
name|pname
argument_list|,
name|auth_data
operator|.
name|pinst
argument_list|,
name|auth_data
operator|.
name|prealm
argument_list|,
name|lname
argument_list|,
name|inet_ntoa
argument_list|(
name|peername
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|version
argument_list|,
operator|(
name|long
operator|)
name|auth_data
operator|.
name|checksum
argument_list|)
expr_stmt|;
block|}
comment|/* write back the response */
if|if
condition|(
operator|(
name|count
operator|=
name|write
argument_list|(
literal|0
argument_list|,
name|retbuf
argument_list|,
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|retbuf
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"write: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|count
operator|!=
name|len
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"write count incorrect: %d != %d\n"
argument_list|,
name|count
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* close up and exit */
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

