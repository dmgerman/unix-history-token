begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980, 1987, 1988, 1991, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * login [ name ]  * login -h hostname	(for telnetd, etc.)  * login -f name	(for pre-authenticated login: datakit, xterm, etc.)  */
end_comment

begin_include
include|#
directive|include
file|"bsd_locl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CAPABILITY_H
end_ifdef

begin_include
include|#
directive|include
file|<capability.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_CAPABILITY_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/capability.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: login.c,v 1.125.2.2 2000/06/23 02:33:07 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OTP
end_ifdef

begin_include
include|#
directive|include
file|<otp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sysv_default.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV_SHADOW
end_ifdef

begin_include
include|#
directive|include
file|"sysv_shadow.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|badlogin
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|checknologin
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dolastlog
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|getloginname
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rootterm
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|stypeof
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|RETSIGTYPE
name|timedout
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|doremotelogin
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|login_fbtab
parameter_list|(
name|char
modifier|*
parameter_list|,
name|uid_t
parameter_list|,
name|gid_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|KERBEROS
end_ifdef

begin_function_decl
name|int
name|klogin
parameter_list|(
name|struct
name|passwd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TTYGRPNAME
value|"tty"
end_define

begin_comment
comment|/* name of group to own ttys */
end_comment

begin_comment
comment|/*  * This bounds the time given to login.  Change it in  * `/etc/default/login'.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|login_timeout
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KERBEROS
end_ifdef

begin_decl_stmt
name|int
name|notickets
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|noticketsdontcomplain
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|instance
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|krbtkfile_env
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|authok
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SHADOW_H
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|spwd
modifier|*
name|spwd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ttyprompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|failures
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|term
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|hostname
decl_stmt|,
modifier|*
name|username
decl_stmt|,
modifier|*
name|tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rusername
index|[
literal|100
index|]
decl_stmt|,
name|lusername
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|change_passwd
parameter_list|(
name|struct
name|passwd
modifier|*
name|who
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|warn
argument_list|(
literal|"fork /bin/passwd"
argument_list|)
expr_stmt|;
name|sleepexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|execlp
argument_list|(
literal|"/bin/passwd"
argument_list|,
literal|"passwd"
argument_list|,
name|who
operator|->
name|pw_name
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
default|default:
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MOTD
end_ifndef

begin_comment
comment|/* message of the day stuff */
end_comment

begin_decl_stmt
name|jmp_buf
name|motdinterrupt
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|RETSIGTYPE
name|sigint
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|longjmp
argument_list|(
name|motdinterrupt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|motd
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|nchars
decl_stmt|;
name|RETSIGTYPE
function_decl|(
modifier|*
name|oldint
function_decl|)
parameter_list|()
function_decl|;
name|char
name|tbuf
index|[
literal|8192
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|_PATH_MOTDFILE
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
name|oldint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|motdinterrupt
argument_list|)
operator|==
literal|0
condition|)
while|while
condition|(
operator|(
name|nchars
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|tbuf
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oldint
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NO_MOTD */
end_comment

begin_define
define|#
directive|define
name|AUTH_NONE
value|0
end_define

begin_define
define|#
directive|define
name|AUTH_OTP
value|1
end_define

begin_comment
comment|/*  * getpwnam and try to detect the worst form of NIS attack.  */
end_comment

begin_function
specifier|static
name|struct
name|passwd
modifier|*
name|paranoid_getpwnam
parameter_list|(
name|char
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|k_getpwnam
argument_list|(
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|p
return|;
if|if
condition|(
name|p
operator|->
name|pw_uid
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|username
argument_list|,
literal|"root"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"NIS attack, user %s has uid 0"
argument_list|,
name|username
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
name|int
name|ask
decl_stmt|,
name|ch
decl_stmt|,
name|cnt
decl_stmt|,
name|fflag
decl_stmt|,
name|hflag
decl_stmt|,
name|pflag
decl_stmt|,
name|quietlog
decl_stmt|,
name|nomailcheck
decl_stmt|;
name|int
name|rootlogin
decl_stmt|,
name|rval
decl_stmt|;
name|int
name|rflag
decl_stmt|;
name|int
name|changepass
init|=
literal|0
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|char
modifier|*
name|domain
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|passwd
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|ttyn
decl_stmt|;
name|char
name|tbuf
index|[
name|MaxPathLen
operator|+
literal|2
index|]
decl_stmt|,
name|tname
index|[
sizeof|sizeof
argument_list|(
name|_PATH_TTY
argument_list|)
operator|+
literal|10
index|]
decl_stmt|;
name|char
name|localhost
index|[
name|MaxHostNameLen
index|]
decl_stmt|;
name|char
name|full_hostname
index|[
name|MaxHostNameLen
index|]
decl_stmt|;
name|int
name|auth_level
init|=
name|AUTH_NONE
decl_stmt|;
ifdef|#
directive|ifdef
name|OTP
name|OtpContext
name|otp_ctx
decl_stmt|;
endif|#
directive|endif
name|int
name|mask
init|=
literal|022
decl_stmt|;
comment|/* Default umask (set below) */
name|int
name|maxtrys
init|=
literal|5
decl_stmt|;
comment|/* Default number of allowed failed logins */
name|set_progname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
literal|"login"
argument_list|,
name|LOG_ODELAY
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
comment|/* Read defaults file and set the login timeout period. */
name|sysv_defaults
argument_list|()
expr_stmt|;
name|login_timeout
operator|=
name|atoi
argument_list|(
name|default_timeout
argument_list|)
expr_stmt|;
name|maxtrys
operator|=
name|atoi
argument_list|(
name|default_maxtrys
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|default_umask
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|mask
argument_list|)
operator|!=
literal|1
operator|||
operator|(
name|mask
operator|&
operator|~
literal|0777
operator|)
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"bad umask default: %s"
argument_list|,
name|default_umask
argument_list|)
expr_stmt|;
else|else
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|timedout
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|login_timeout
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * -p is used by getty to tell login not to destroy the environment 	 * -f is used to skip a second login authentication 	 * -h is used by other servers to pass the name of the remote 	 *    host to login so that it may be placed in utmp and wtmp 	 * -r is used by old-style rlogind to execute the autologin protocol 	 */
operator|*
name|full_hostname
operator|=
literal|'\0'
expr_stmt|;
name|domain
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|localhost
argument_list|,
sizeof|sizeof
argument_list|(
name|localhost
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"couldn't get local hostname: %m"
argument_list|)
expr_stmt|;
else|else
name|domain
operator|=
name|strchr
argument_list|(
name|localhost
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|fflag
operator|=
name|hflag
operator|=
name|pflag
operator|=
name|rflag
operator|=
literal|0
expr_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:d:fh:pr:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
name|auth_level
operator|=
name|AUTH_NONE
expr_stmt|;
ifdef|#
directive|ifdef
name|OTP
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"otp"
argument_list|)
operator|==
literal|0
condition|)
name|auth_level
operator|=
name|AUTH_OTP
expr_stmt|;
endif|#
directive|endif
else|else
name|warnx
argument_list|(
literal|"bad value for -a: %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
break|break;
case|case
literal|'f'
case|:
name|fflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|rflag
operator|||
name|hflag
condition|)
block|{
name|printf
argument_list|(
literal|"Only one of -r and -h allowed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uid
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-h option: %s"
argument_list|,
name|strerror
argument_list|(
name|EPERM
argument_list|)
argument_list|)
expr_stmt|;
name|hflag
operator|=
literal|1
expr_stmt|;
name|strlcpy
argument_list|(
name|full_hostname
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|full_hostname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|&&
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
name|strcasecmp
argument_list|(
name|p
argument_list|,
name|domain
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|hostname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|getuid
argument_list|()
condition|)
block|{
name|warnx
argument_list|(
literal|"-p for super-user only."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|rflag
operator|||
name|hflag
condition|)
block|{
name|warnx
argument_list|(
literal|"Only one of -r and -h allowed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getuid
argument_list|()
condition|)
block|{
name|warnx
argument_list|(
literal|"-r for super-user only."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|rflag
operator|=
literal|1
expr_stmt|;
name|strlcpy
argument_list|(
name|full_hostname
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|full_hostname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|&&
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
name|strcasecmp
argument_list|(
name|p
argument_list|,
name|domain
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|hostname
operator|=
name|optarg
expr_stmt|;
name|fflag
operator|=
operator|(
name|doremotelogin
argument_list|(
name|full_hostname
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
if|if
condition|(
operator|!
name|uid
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid flag %c"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: login [-fp]"
ifdef|#
directive|ifdef
name|OTP
literal|" [-a otp]"
endif|#
directive|endif
literal|" [-h hostname | -r hostname] [username]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"only root may use login, use su"
argument_list|)
expr_stmt|;
comment|/* Or install login setuid root, which is not necessary */
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*          * Figure out if we should ask for the username or not. The name          * may be given on the command line or via the environment, and          * it may even be in the terminal input queue.          */
if|if
condition|(
name|rflag
condition|)
block|{
name|username
operator|=
name|lusername
expr_stmt|;
name|ask
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|argv
operator|&&
name|strchr
argument_list|(
operator|*
name|argv
argument_list|,
literal|'='
argument_list|)
condition|)
block|{
name|ask
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|argv
operator|&&
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|ask
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|argv
condition|)
block|{
name|username
operator|=
operator|*
name|argv
expr_stmt|;
name|ask
operator|=
literal|0
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ttyprompt
operator|=
name|getenv
argument_list|(
literal|"TTYPROMPT"
argument_list|)
operator|)
operator|&&
operator|*
name|ttyprompt
condition|)
block|{
name|getloginname
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ask
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ask
operator|=
literal|1
expr_stmt|;
comment|/* Default tty settings. */
name|stty_default
argument_list|()
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|getdtablesize
argument_list|()
init|;
name|cnt
operator|>
literal|2
condition|;
name|cnt
operator|--
control|)
name|close
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
comment|/*          * Determine the tty name. BSD takes the basename, SYSV4 takes          * whatever remains after stripping the "/dev/" prefix. The code          * below should produce sensible results in either environment.          */
name|ttyn
operator|=
name|ttyname
argument_list|(
name|STDIN_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyn
operator|==
name|NULL
operator|||
operator|*
name|ttyn
operator|==
literal|'\0'
condition|)
block|{
name|snprintf
argument_list|(
name|tname
argument_list|,
sizeof|sizeof
argument_list|(
name|tname
argument_list|)
argument_list|,
literal|"%s??"
argument_list|,
name|_PATH_TTY
argument_list|)
expr_stmt|;
name|ttyn
operator|=
name|tname
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tty
operator|=
name|strchr
argument_list|(
name|ttyn
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
operator|++
name|tty
expr_stmt|;
else|else
name|tty
operator|=
name|ttyn
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
condition|;
name|ask
operator|=
literal|1
control|)
block|{
name|char
name|prompt
index|[
literal|128
index|]
decl_stmt|,
name|ss
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|ask
condition|)
block|{
name|fflag
operator|=
literal|0
expr_stmt|;
name|getloginname
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|rootlogin
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|KERBEROS
if|if
condition|(
operator|(
name|instance
operator|=
name|strchr
argument_list|(
name|username
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|instance
argument_list|,
literal|".root"
argument_list|)
operator|==
literal|0
condition|)
name|rootlogin
operator|=
literal|1
expr_stmt|;
operator|*
name|instance
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|instance
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strlen
argument_list|(
name|username
argument_list|)
operator|>
name|UT_NAMESIZE
condition|)
name|username
index|[
name|UT_NAMESIZE
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Note if trying multiple user names; log failures for 		 * previous user name, but don't bother logging one failure 		 * for nonexistent name (mistyped username). 		 */
if|if
condition|(
name|failures
operator|&&
name|strcmp
argument_list|(
name|tbuf
argument_list|,
name|username
argument_list|)
condition|)
block|{
if|if
condition|(
name|failures
operator|>
operator|(
name|pwd
condition|?
literal|0
else|:
literal|1
operator|)
condition|)
name|badlogin
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|failures
operator|=
literal|0
expr_stmt|;
block|}
name|strlcpy
argument_list|(
name|tbuf
argument_list|,
name|username
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
name|pwd
operator|=
name|paranoid_getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
comment|/* 		 * if we have a valid account name, and it doesn't have a 		 * password, or the -f option was specified and the caller 		 * is root or the caller isn't changing their uid, don't 		 * authenticate. 		 */
if|if
condition|(
name|pwd
condition|)
block|{
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|==
literal|0
condition|)
name|rootlogin
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fflag
operator|&&
operator|(
name|uid
operator|==
literal|0
operator|||
name|uid
operator|==
name|pwd
operator|->
name|pw_uid
operator|)
condition|)
block|{
comment|/* already authenticated */
break|break;
block|}
elseif|else
if|if
condition|(
name|pwd
operator|->
name|pw_passwd
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* pretend password okay */
name|rval
operator|=
literal|0
expr_stmt|;
goto|goto
name|ttycheck
goto|;
block|}
block|}
name|fflag
operator|=
literal|0
expr_stmt|;
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
operator|-
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OTP
if|if
condition|(
name|otp_challenge
argument_list|(
operator|&
name|otp_ctx
argument_list|,
name|username
argument_list|,
name|ss
argument_list|,
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|snprintf
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
argument_list|(
name|prompt
argument_list|)
argument_list|,
literal|"%s's %s Password: "
argument_list|,
name|username
argument_list|,
name|ss
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|auth_level
operator|==
name|AUTH_NONE
condition|)
name|snprintf
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
argument_list|(
name|prompt
argument_list|)
argument_list|,
literal|"%s's Password: "
argument_list|,
name|username
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|OTP
name|s
operator|=
name|otp_error
argument_list|(
operator|&
name|otp_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|printf
argument_list|(
literal|"OTP: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
block|}
if|if
condition|(
name|des_read_pw_string
argument_list|(
name|passwd
argument_list|,
sizeof|sizeof
argument_list|(
name|passwd
argument_list|)
operator|-
literal|1
argument_list|,
name|prompt
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
name|passwd
index|[
sizeof|sizeof
argument_list|(
name|passwd
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Verify it somehow */
ifdef|#
directive|ifdef
name|OTP
if|if
condition|(
name|otp_verify_user
argument_list|(
operator|&
name|otp_ctx
argument_list|,
name|passwd
argument_list|)
operator|==
literal|0
condition|)
name|rval
operator|=
literal|0
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|auth_level
operator|==
name|AUTH_NONE
condition|)
block|{
name|uid_t
name|pwd_uid
init|=
name|pwd
operator|->
name|pw_uid
decl_stmt|;
name|rval
operator|=
name|unix_verify_user
argument_list|(
name|username
argument_list|,
name|passwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rootlogin
operator|&&
name|pwd_uid
operator|!=
literal|0
condition|)
name|rootlogin
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
name|klogin
argument_list|(
name|pwd
argument_list|,
name|instance
argument_list|,
name|localhost
argument_list|,
name|passwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
literal|0
operator|&&
name|rootlogin
operator|&&
name|pwd_uid
operator|!=
literal|0
condition|)
name|rootlogin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
name|authok
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|OTP
if|if
condition|(
operator|(
name|s
operator|=
name|otp_error
argument_list|(
operator|&
name|otp_ctx
argument_list|)
operator|)
condition|)
name|printf
argument_list|(
literal|"OTP: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|memset
argument_list|(
name|passwd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|passwd
argument_list|)
argument_list|)
expr_stmt|;
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Santa Claus, give me a portable and reentrant getpwnam. 		 */
name|pwd
operator|=
name|paranoid_getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|ttycheck
label|:
comment|/* 		 * If trying to log in as root without Kerberos, 		 * but with insecure terminal, refuse the login attempt. 		 */
ifdef|#
directive|ifdef
name|KERBEROS
if|if
condition|(
name|authok
operator|==
literal|0
condition|)
endif|#
directive|endif
if|if
condition|(
name|pwd
operator|&&
operator|!
name|rval
operator|&&
name|rootlogin
operator|&&
operator|!
name|rootterm
argument_list|(
name|tty
argument_list|)
operator|&&
operator|!
name|rootterm
argument_list|(
name|ttyn
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s login refused on this terminal."
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"LOGIN %s REFUSED FROM %s ON TTY %s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|hostname
argument_list|,
name|tty
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"LOGIN %s REFUSED ON TTY %s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|tty
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"Login incorrect\n"
argument_list|)
expr_stmt|;
name|failures
operator|++
expr_stmt|;
comment|/* max number of attemps and delays taken from defaults file */
comment|/* we allow maxtrys tries, but after 2 we start backing off */
if|if
condition|(
operator|++
name|cnt
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|cnt
operator|>=
name|maxtrys
condition|)
block|{
name|badlogin
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|sleepexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
call|(
name|u_int
call|)
argument_list|(
operator|(
name|cnt
operator|-
literal|2
operator|)
operator|*
name|atoi
argument_list|(
name|default_sleep
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* committed to login -- turn off timeout */
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETUDBNAM
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETLIM
argument_list|)
block|{
name|struct
name|udb
modifier|*
name|udb
decl_stmt|;
name|long
name|t
decl_stmt|;
specifier|const
name|long
name|maxcpu
init|=
literal|46116860184
decl_stmt|;
comment|/* some random constant */
if|if
condition|(
name|setjob
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"setjob"
argument_list|)
expr_stmt|;
name|udb
operator|=
name|getudbnam
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|udb
operator|==
name|UDB_NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Failed to get UDB entry."
argument_list|)
expr_stmt|;
comment|/* per process cpu limit */
name|t
operator|=
name|udb
operator|->
name|ue_pcpulim
index|[
name|UDBRC_INTER
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
operator|||
name|t
operator|>
name|maxcpu
condition|)
name|t
operator|=
name|CPUUNLIM
expr_stmt|;
else|else
name|t
operator|*=
name|CLK_TCK
expr_stmt|;
if|if
condition|(
name|limit
argument_list|(
name|C_PROC
argument_list|,
literal|0
argument_list|,
name|L_CPU
argument_list|,
name|t
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"limit process cpu"
argument_list|)
expr_stmt|;
comment|/* per process memory limit */
if|if
condition|(
name|limit
argument_list|(
name|C_PROC
argument_list|,
literal|0
argument_list|,
name|L_MEM
argument_list|,
name|udb
operator|->
name|ue_pmemlim
index|[
name|UDBRC_INTER
index|]
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"limit process memory"
argument_list|)
expr_stmt|;
comment|/* per job cpu limit */
name|t
operator|=
name|udb
operator|->
name|ue_jcpulim
index|[
name|UDBRC_INTER
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
operator|||
name|t
operator|>
name|maxcpu
condition|)
name|t
operator|=
name|CPUUNLIM
expr_stmt|;
else|else
name|t
operator|*=
name|CLK_TCK
expr_stmt|;
if|if
condition|(
name|limit
argument_list|(
name|C_JOB
argument_list|,
literal|0
argument_list|,
name|L_CPU
argument_list|,
name|t
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"limit job cpu"
argument_list|)
expr_stmt|;
comment|/* per job processor limit */
if|if
condition|(
name|limit
argument_list|(
name|C_JOB
argument_list|,
literal|0
argument_list|,
name|L_CPROC
argument_list|,
name|udb
operator|->
name|ue_jproclim
index|[
name|UDBRC_INTER
index|]
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"limit job processors"
argument_list|)
expr_stmt|;
comment|/* per job memory limit */
if|if
condition|(
name|limit
argument_list|(
name|C_JOB
argument_list|,
literal|0
argument_list|,
name|L_MEM
argument_list|,
name|udb
operator|->
name|ue_jmemlim
index|[
name|UDBRC_INTER
index|]
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"limit job memory"
argument_list|)
expr_stmt|;
name|nice
argument_list|(
name|udb
operator|->
name|ue_nice
index|[
name|UDBRC_INTER
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* if user not super-user, check for disabled logins */
if|if
condition|(
operator|!
name|rootlogin
condition|)
name|checknologin
argument_list|()
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"No home directory %s!\n"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|"/"
argument_list|)
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_dir
operator|=
literal|"/"
expr_stmt|;
name|printf
argument_list|(
literal|"Logging in with home = \"/\".\n"
argument_list|)
expr_stmt|;
block|}
name|quietlog
operator|=
name|access
argument_list|(
name|_PATH_HUSHLOGIN
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
expr_stmt|;
name|nomailcheck
operator|=
name|access
argument_list|(
name|_PATH_NOMAILCHECK
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PASSWD_CHANGE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_PASSWD_EXPIRE
argument_list|)
if|if
condition|(
name|pwd
operator|->
name|pw_change
operator|||
name|pwd
operator|->
name|pw_expire
condition|)
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_change
condition|)
block|{
name|time_t
name|t
decl_stmt|;
if|if
condition|(
name|tp
operator|.
name|tv_sec
operator|>=
name|pwd
operator|->
name|pw_change
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry -- your password has expired.\n"
argument_list|)
expr_stmt|;
name|changepass
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pwd
operator|->
name|pw_change
operator|-
name|tp
operator|.
name|tv_sec
operator|<
literal|2
operator|*
name|DAYSPERWEEK
operator|*
name|SECSPERDAY
operator|&&
operator|!
name|quietlog
condition|)
block|{
name|t
operator|=
name|pwd
operator|->
name|pw_change
expr_stmt|;
name|printf
argument_list|(
literal|"Warning: your password expires on %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pwd
operator|->
name|pw_expire
condition|)
if|if
condition|(
name|tp
operator|.
name|tv_sec
operator|>=
name|pwd
operator|->
name|pw_expire
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry -- your account has expired.\n"
argument_list|)
expr_stmt|;
name|sleepexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pwd
operator|->
name|pw_expire
operator|-
name|tp
operator|.
name|tv_sec
operator|<
literal|2
operator|*
name|DAYSPERWEEK
operator|*
name|SECSPERDAY
operator|&&
operator|!
name|quietlog
condition|)
block|{
name|t
operator|=
name|pwd
operator|->
name|pw_expire
expr_stmt|;
name|printf
argument_list|(
literal|"Warning: your account expires on %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(HAVE_PASSWD_CHANGE)&& defined(HAVE_PASSWD_EXPIRE) */
comment|/* Nothing else left to fail -- really log in. */
comment|/*          * Update the utmp files, both BSD and SYSV style.          */
if|if
condition|(
name|utmpx_login
argument_list|(
name|tty
argument_list|,
name|username
argument_list|,
name|hostname
condition|?
name|hostname
else|:
literal|""
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|fflag
condition|)
block|{
name|printf
argument_list|(
literal|"No utmpx entry.  You must exec \"login\" from the lowest level \"sh\".\n"
argument_list|)
expr_stmt|;
name|sleepexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|utmp_login
argument_list|(
name|ttyn
argument_list|,
name|username
argument_list|,
name|hostname
condition|?
name|hostname
else|:
literal|""
argument_list|)
expr_stmt|;
name|dolastlog
argument_list|(
name|quietlog
argument_list|)
expr_stmt|;
comment|/* 	 * Set device protections, depending on what terminal the 	 * user is logged in. This feature is used on Suns to give 	 * console users better privacy. 	 */
name|login_fbtab
argument_list|(
name|tty
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|chown
argument_list|(
name|ttyn
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
operator|(
name|gr
operator|=
name|getgrnam
argument_list|(
name|TTYGRPNAME
argument_list|)
operator|)
condition|?
name|gr
operator|->
name|gr_gid
else|:
name|pwd
operator|->
name|pw_gid
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"chown tty failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|ttyn
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IWGRP
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"chmod tty failed"
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|initgroups
argument_list|(
name|username
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pwd
operator|->
name|pw_shell
operator|==
literal|'\0'
condition|)
name|pwd
operator|->
name|pw_shell
operator|=
name|_PATH_BSHELL
expr_stmt|;
comment|/*          * Set up a new environment. With SYSV, some variables are always          * preserved; some varables are never preserved, and some variables          * are always clobbered. With BSD, nothing is always preserved, and          * some variables are always clobbered. We add code to make sure          * that LD_* and IFS are never preserved.          */
if|if
condition|(
name|term
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strlcpy
argument_list|(
name|term
argument_list|,
name|stypeof
argument_list|(
name|tty
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set up a somewhat censored environment. */
name|sysv_newenv
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|pwd
argument_list|,
name|term
argument_list|,
name|pflag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KERBEROS
if|if
condition|(
name|krbtkfile_env
condition|)
name|setenv
argument_list|(
literal|"KRBTKFILE"
argument_list|,
name|krbtkfile_env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tty
index|[
sizeof|sizeof
argument_list|(
literal|"tty"
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'d'
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"DIALUP %s, %s"
argument_list|,
name|tty
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
comment|/* If fflag is on, assume caller/authenticator has logged root login. */
if|if
condition|(
name|rootlogin
operator|&&
name|fflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hostname
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ROOT LOGIN (%s) ON %s FROM %s"
argument_list|,
name|username
argument_list|,
name|tty
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ROOT LOGIN (%s) ON %s"
argument_list|,
name|username
argument_list|,
name|tty
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KERBEROS
if|if
condition|(
operator|!
name|quietlog
operator|&&
name|notickets
operator|==
literal|1
operator|&&
operator|!
name|noticketsdontcomplain
condition|)
name|printf
argument_list|(
literal|"Warning: no Kerberos tickets issued.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOGALL
comment|/* 	 * Syslog each successful login, so we don't have to watch hundreds 	 * of wtmp or lastlogin files. 	 */
if|if
condition|(
name|hostname
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"login from %s as %s"
argument_list|,
name|hostname
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"login on %s as %s"
argument_list|,
name|tty
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_MOTD
comment|/*          * Optionally show the message of the day. System V login leaves          * motd and mail stuff up to the shell startup file.          */
if|if
condition|(
operator|!
name|quietlog
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|#
directive|if
literal|0
block|printf("%s\n\t%s  %s\n\n", 	    "Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994", 		    "The Regents of the University of California. ", 		    "All rights reserved.");
endif|#
directive|endif
name|motd
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nomailcheck
condition|)
block|{
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|_PATH_MAILDIR
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|tbuf
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|st
operator|.
name|st_size
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"You have %smail.\n"
argument_list|,
operator|(
name|st
operator|.
name|st_mtime
operator|>
name|st
operator|.
name|st_atime
operator|)
condition|?
literal|"new "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NO_MOTD */
ifdef|#
directive|ifdef
name|LOGIN_ACCESS
if|if
condition|(
name|login_access
argument_list|(
name|pwd
argument_list|,
name|hostname
condition|?
name|full_hostname
else|:
name|tty
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Permission denied\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s LOGIN REFUSED FROM %s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s LOGIN REFUSED ON %s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|tty
argument_list|)
expr_stmt|;
name|sleepexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|strrchr
argument_list|(
name|pwd
operator|->
name|pw_shell
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"-%s"
argument_list|,
name|p
condition|?
name|p
operator|+
literal|1
else|:
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SETLOGIN
if|if
condition|(
name|setlogin
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setlogin() failure: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SETPCRED
if|if
condition|(
name|setpcred
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setpcred() failure: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SETPCRED */
if|#
directive|if
name|defined
argument_list|(
name|SYSV_SHADOW
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_GETSPNAM
argument_list|)
name|spwd
operator|=
name|getspnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|endspent
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* perhaps work some magic */
if|if
condition|(
name|do_osfc2_magic
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|)
condition|)
name|sleepexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SGI_GETCAPABILITYBYNAME
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_CAP_SET_PROC
argument_list|)
comment|/* XXX SGI capability hack IRIX 6.x (x>= 0?) has something 	   called capabilities, that allow you to give away 	   permissions (such as chown) to specific processes. From 6.5 	   this is default on, and the default capability set seems to 	   not always be the empty set. The problem is that the 	   runtime linker refuses to do just about anything if the 	   process has *any* capabilities set, so we have to remove 	   them here (unless otherwise instructed by /etc/capability). 	   In IRIX< 6.5, these functions was called sgi_cap_setproc, 	   etc, but we ignore this fact (it works anyway). */
block|{
name|struct
name|user_cap
modifier|*
name|ucap
init|=
name|sgi_getcapabilitybyname
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
decl_stmt|;
name|cap_t
name|cap
decl_stmt|;
if|if
condition|(
name|ucap
operator|==
name|NULL
condition|)
name|cap
operator|=
name|cap_from_text
argument_list|(
literal|"all="
argument_list|)
expr_stmt|;
else|else
name|cap
operator|=
name|cap_from_text
argument_list|(
name|ucap
operator|->
name|ca_default
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cap_from_text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap_set_proc
argument_list|(
name|cap
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cap_set_proc"
argument_list|)
expr_stmt|;
name|cap_free
argument_list|(
name|cap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ucap
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Discard permissions last so can't get killed and drop core. */
block|{
name|int
name|uid
init|=
name|rootlogin
condition|?
literal|0
else|:
name|pwd
operator|->
name|pw_uid
decl_stmt|;
if|if
condition|(
name|setuid
argument_list|(
name|uid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"setuid(%d)"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rootlogin
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uid
operator|!=
literal|0
operator|&&
name|setuid
argument_list|(
literal|0
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ALERT
operator||
name|LOG_AUTH
argument_list|,
literal|"Failed to drop privileges for user %d"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Sorry"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*          * After dropping privileges and after cleaning up the environment,          * optionally run, as the user, /bin/passwd.          */
if|if
condition|(
name|pwd
operator|->
name|pw_passwd
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|default_passreq
argument_list|,
literal|"YES"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"You don't have a password.  Choose one.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|change_passwd
argument_list|(
name|pwd
argument_list|)
condition|)
name|sleepexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|changepass
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SYSV_SHADOW
if|if
condition|(
name|spwd
operator|&&
name|sysv_expire
argument_list|(
name|spwd
argument_list|)
condition|)
block|{
if|if
condition|(
name|change_passwd
argument_list|(
name|pwd
argument_list|)
condition|)
name|sleepexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|changepass
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYSV_SHADOW */
if|if
condition|(
name|changepass
condition|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|system
argument_list|(
name|_PATH_CHPASS
argument_list|)
operator|)
condition|)
name|sleepexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k_hasafs
argument_list|()
condition|)
block|{
name|char
name|cell
index|[
literal|64
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|_AIX
comment|/* XXX this is a fix for a bug in AFS for AIX 4.3, w/o                this hack the kernel crashes on the following                pioctl... */
name|char
modifier|*
name|pw_dir
init|=
name|strdup
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|)
decl_stmt|;
else|#
directive|else
name|char
modifier|*
name|pw_dir
init|=
name|pwd
operator|->
name|pw_dir
decl_stmt|;
endif|#
directive|endif
name|k_setpag
argument_list|()
expr_stmt|;
if|if
condition|(
name|k_afs_cell_of_file
argument_list|(
name|pw_dir
argument_list|,
name|cell
argument_list|,
sizeof|sizeof
argument_list|(
name|cell
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|krb_afslog
argument_list|(
name|cell
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|krb_afslog
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|execlp
argument_list|(
name|pwd
operator|->
name|pw_shell
argument_list|,
name|tbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|getuid
argument_list|()
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Can't exec %s, trying %s\n"
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|,
name|_PATH_BSHELL
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
name|_PATH_BSHELL
argument_list|,
name|tbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|_PATH_BSHELL
argument_list|)
expr_stmt|;
block|}
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|KERBEROS
define|#
directive|define
name|NBUFSIZ
value|(UT_NAMESIZE + 1 + 5)
comment|/* .root suffix */
else|#
directive|else
define|#
directive|define
name|NBUFSIZ
value|(UT_NAMESIZE + 1)
endif|#
directive|endif
specifier|static
name|void
name|getloginname
parameter_list|(
name|int
name|prompt
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|nbuf
index|[
name|NBUFSIZ
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|prompt
condition|)
block|{
if|if
condition|(
name|ttyprompt
operator|&&
operator|*
name|ttyprompt
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ttyprompt
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"login: "
argument_list|)
expr_stmt|;
block|}
name|prompt
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|nbuf
init|;
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|;
control|)
block|{
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|badlogin
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<
name|nbuf
operator|+
operator|(
name|NBUFSIZ
operator|-
literal|1
operator|)
condition|)
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|>
name|nbuf
condition|)
block|{
if|if
condition|(
name|nbuf
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|warnx
argument_list|(
literal|"login names may not start with '-'."
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|username
operator|=
name|nbuf
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
specifier|static
name|int
name|find_in_etc_securetty
parameter_list|(
name|char
modifier|*
name|ttyn
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|_PATH_ETC_SECURETTY
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|ttyn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
specifier|static
name|int
name|rootterm
parameter_list|(
name|char
modifier|*
name|ttyn
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TTYENT_H
block|{
name|struct
name|ttyent
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|getttynam
argument_list|(
name|ttyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|t
operator|->
name|ty_status
operator|&
name|TTY_SECURE
condition|)
return|return
literal|1
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|find_in_etc_securetty
argument_list|(
name|ttyn
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|default_console
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|default_console
argument_list|,
name|ttyn
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
specifier|static
name|RETSIGTYPE
name|timedout
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Login timed out after %d seconds\n"
argument_list|,
name|login_timeout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|checknologin
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|nchars
decl_stmt|;
name|char
name|tbuf
index|[
literal|8192
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|_PATH_NOLOGIN
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|nchars
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|tbuf
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
name|sleepexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|dolastlog
parameter_list|(
name|int
name|quiet
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LASTLOG_H
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_LOGIN_H
argument_list|)
name|struct
name|lastlog
name|ll
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|time_t
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|_PATH_LASTLOG
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|pwd
operator|->
name|pw_uid
operator|*
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV_SHADOW
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|ll
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
operator|&&
name|ll
operator|.
name|ll_time
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|&&
name|spwd
operator|&&
name|spwd
operator|->
name|sp_inact
operator|>
literal|0
operator|&&
name|ll
operator|.
name|ll_time
operator|/
operator|(
literal|24
operator|*
literal|60
operator|*
literal|60
operator|)
operator|+
name|spwd
operator|->
name|sp_inact
operator|<
name|time
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Your account has been inactive too long.\n"
argument_list|)
expr_stmt|;
name|sleepexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|t
operator|=
name|ll
operator|.
name|ll_time
expr_stmt|;
name|printf
argument_list|(
literal|"Last login: %.*s "
argument_list|,
literal|24
operator|-
literal|5
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ll
operator|.
name|ll_host
operator|!=
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"from %.*s\n"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_host
argument_list|)
argument_list|,
name|ll
operator|.
name|ll_host
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"on %.*s\n"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_line
argument_list|)
argument_list|,
name|ll
operator|.
name|ll_line
argument_list|)
expr_stmt|;
block|}
block|}
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|pwd
operator|->
name|pw_uid
operator|*
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SYSV_SHADOW */
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|ll
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
operator|&&
name|ll
operator|.
name|ll_time
operator|!=
literal|0
condition|)
block|{
name|t
operator|=
name|ll
operator|.
name|ll_time
expr_stmt|;
name|printf
argument_list|(
literal|"Last login: %.*s "
argument_list|,
literal|24
operator|-
literal|5
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ll
operator|.
name|ll_host
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"from %.*s\n"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_host
argument_list|)
argument_list|,
name|ll
operator|.
name|ll_host
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"on %.*s\n"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_line
argument_list|)
argument_list|,
name|ll
operator|.
name|ll_line
argument_list|)
expr_stmt|;
block|}
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|pwd
operator|->
name|pw_uid
operator|*
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYSV_SHADOW */
name|memset
argument_list|(
operator|&
name|ll
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|)
expr_stmt|;
name|ll
operator|.
name|ll_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ll
operator|.
name|ll_line
argument_list|,
name|tty
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
condition|)
name|strncpy
argument_list|(
name|ll
operator|.
name|ll_host
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_host
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|ll
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DOLASTLOG */
block|}
specifier|static
name|void
name|badlogin
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|failures
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|hostname
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%d LOGIN FAILURE%s FROM %s"
argument_list|,
name|failures
argument_list|,
name|failures
operator|>
literal|1
condition|?
literal|"S"
else|:
literal|""
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_AUTHPRIV
operator||
name|LOG_NOTICE
argument_list|,
literal|"%d LOGIN FAILURE%s FROM %s, %s"
argument_list|,
name|failures
argument_list|,
name|failures
operator|>
literal|1
condition|?
literal|"S"
else|:
literal|""
argument_list|,
name|hostname
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%d LOGIN FAILURE%s ON %s"
argument_list|,
name|failures
argument_list|,
name|failures
operator|>
literal|1
condition|?
literal|"S"
else|:
literal|""
argument_list|,
name|tty
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_AUTHPRIV
operator||
name|LOG_NOTICE
argument_list|,
literal|"%d LOGIN FAILURE%s ON %s, %s"
argument_list|,
name|failures
argument_list|,
name|failures
operator|>
literal|1
condition|?
literal|"S"
else|:
literal|""
argument_list|,
name|tty
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|UNKNOWN
define|#
directive|define
name|UNKNOWN
value|"su"
specifier|static
name|char
modifier|*
name|stypeof
parameter_list|(
name|char
modifier|*
name|ttyid
parameter_list|)
block|{
comment|/* TERM is probably a better guess than anything else. */
name|char
modifier|*
name|term
init|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
decl_stmt|;
if|if
condition|(
name|term
operator|!=
literal|0
operator|&&
name|term
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
return|return
name|term
return|;
block|{
ifndef|#
directive|ifndef
name|HAVE_TTYENT_H
return|return
name|UNKNOWN
return|;
else|#
directive|else
name|struct
name|ttyent
modifier|*
name|t
decl_stmt|;
return|return
operator|(
name|ttyid
operator|&&
operator|(
name|t
operator|=
name|getttynam
argument_list|(
name|ttyid
argument_list|)
operator|)
condition|?
name|t
operator|->
name|ty_type
else|:
name|UNKNOWN
operator|)
return|;
endif|#
directive|endif
block|}
block|}
specifier|static
name|void
name|xgetstr
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|cnt
parameter_list|,
name|char
modifier|*
name|err
parameter_list|)
block|{
name|char
name|ch
decl_stmt|;
do|do
block|{
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|cnt
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s too long\r\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|sleepexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|buf
operator|++
operator|=
name|ch
expr_stmt|;
block|}
do|while
condition|(
name|ch
condition|)
do|;
block|}
comment|/*  * Some old rlogind's unknowingly pass remuser, locuser and  * terminal_type/speed so we need to take care of that part of the  * protocol here. Also, we can't make a getpeername(2) on the socket  * so we have to trust that rlogind resolved the name correctly.  */
specifier|static
name|int
name|doremotelogin
parameter_list|(
name|char
modifier|*
name|host
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|xgetstr
argument_list|(
name|rusername
argument_list|,
sizeof|sizeof
argument_list|(
name|rusername
argument_list|)
argument_list|,
literal|"remuser"
argument_list|)
expr_stmt|;
name|xgetstr
argument_list|(
name|lusername
argument_list|,
sizeof|sizeof
argument_list|(
name|lusername
argument_list|)
argument_list|,
literal|"locuser"
argument_list|)
expr_stmt|;
name|xgetstr
argument_list|(
name|term
argument_list|,
sizeof|sizeof
argument_list|(
name|term
argument_list|)
argument_list|,
literal|"Terminal type"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|term
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
literal|0
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
comment|/* For now ignore speed/bg */
name|pwd
operator|=
name|k_getpwnam
argument_list|(
name|lusername
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|code
operator|=
name|ruserok
argument_list|(
name|host
argument_list|,
operator|(
name|pwd
operator|->
name|pw_uid
operator|==
literal|0
operator|)
argument_list|,
name|rusername
argument_list|,
name|lusername
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Warning: An old rlogind accepted login probably from host %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|)
return|;
block|}
name|void
name|sleepexit
parameter_list|(
name|int
name|eval
parameter_list|)
block|{
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

