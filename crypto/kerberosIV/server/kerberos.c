begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1985, 1986, 1987, 1988 by the Massachusetts Institute  * of Technology.  *  * For copying and distribution information, please see the file  *<mit-copyright.h>.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"protos.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: kerberos.c,v 1.87.2.3 2000/10/18 20:24:13 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * If support for really large numbers of network interfaces is  * desired, define FD_SETSIZE to some suitable value.  */
end_comment

begin_define
define|#
directive|define
name|FD_SETSIZE
value|(4*1024)
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIME_WITH_SYS_TIME
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SYS_TIME_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SELECT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ARPA_INET_H
end_ifdef

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FCNTL_H
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_IOCTL_H
argument_list|)
operator|&&
name|SunOS
operator|!=
literal|40
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_FILIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_FILIO_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SOCKS
end_ifdef

begin_include
include|#
directive|include
file|<socks.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<roken.h>
end_include

begin_include
include|#
directive|include
file|<base64.h>
end_include

begin_define
define|#
directive|define
name|OPENSSL_DES_LIBDES_COMPATIBILITY
end_define

begin_include
include|#
directive|include
file|<openssl/des.h>
end_include

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<krb_db.h>
end_include

begin_include
include|#
directive|include
file|<prot.h>
end_include

begin_include
include|#
directive|include
file|<klog.h>
end_include

begin_include
include|#
directive|include
file|<krb_log.h>
end_include

begin_include
include|#
directive|include
file|<kdc.h>
end_include

begin_decl_stmt
specifier|static
name|des_key_schedule
name|master_key_schedule
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|des_cblock
name|master_key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|kerb_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|master_key_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|more
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Are we invoked manually? */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|log_file
init|=
name|KRBLOG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of alt. log file */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't check max age */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* alternate realm specified */
end_comment

begin_comment
comment|/* fields within the received request packet */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|req_name_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|req_inst_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|req_realm_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|req_time_ws
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|local_realm
index|[
name|REALM_SZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* options */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_age
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pause_int
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Print usage message and exit.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-s] [-m] [-n] [-p pause_seconds]"
literal|" [-a max_age] [-l log_file] [-i address_to_listen_on]"
literal|" [-r realm] [database_pathname]\n"
argument_list|,
name|__progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * kerb_err_reply creates an error reply packet and sends it to the  * client.   */
end_comment

begin_function
specifier|static
name|void
name|kerb_err_reply
parameter_list|(
name|int
name|f
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|client
parameter_list|,
name|int
name|err
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
block|{
specifier|static
name|KTEXT_ST
name|e_pkt_st
decl_stmt|;
name|KTEXT
name|e_pkt
init|=
operator|&
name|e_pkt_st
decl_stmt|;
specifier|static
name|char
name|e_msg
index|[
literal|128
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|e_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|e_msg
argument_list|)
argument_list|,
literal|"\nKerberos error -- %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|cr_err_reply
argument_list|(
name|e_pkt
argument_list|,
name|req_name_ptr
argument_list|,
name|req_inst_ptr
argument_list|,
name|req_realm_ptr
argument_list|,
name|req_time_ws
argument_list|,
name|err
argument_list|,
name|e_msg
argument_list|)
expr_stmt|;
name|sendto
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
name|e_pkt
operator|->
name|dat
argument_list|,
name|e_pkt
operator|->
name|length
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|client
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|client
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hang
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|pause_int
operator|==
operator|-
literal|1
condition|)
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Kerberos will pause so as not to loop init"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
name|pause
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Kerberos will wait %d seconds before dying so as not to loop init"
argument_list|,
name|pause_int
argument_list|)
expr_stmt|;
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|pause_int
argument_list|)
expr_stmt|;
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Do svedania....\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|check_princ
parameter_list|(
name|char
modifier|*
name|p_name
parameter_list|,
name|char
modifier|*
name|instance
parameter_list|,
name|unsigned
name|int
name|lifetime
parameter_list|,
name|Principal
modifier|*
name|p
parameter_list|)
block|{
specifier|static
name|int
name|n
decl_stmt|;
specifier|static
name|int
name|more
decl_stmt|;
name|n
operator|=
name|kerb_get_principal
argument_list|(
name|p_name
argument_list|,
name|instance
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
operator|&
name|more
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|lt
operator|=
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Database unavailable!"
argument_list|)
expr_stmt|;
name|hang
argument_list|()
expr_stmt|;
block|}
comment|/*      * if more than one p_name, pick one, randomly create a session key,      * compute maximum lifetime, lookup authorizations if applicable,      * and stuff into cipher.       */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* service unknown, log error, skip to next request */
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_UNK
argument_list|,
literal|"UNKNOWN %s.%s"
argument_list|,
name|p_name
argument_list|,
name|instance
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_PRINCIPAL_UNKNOWN
return|;
block|}
if|if
condition|(
name|more
condition|)
block|{
comment|/* not unique, log error */
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_NUN
argument_list|,
literal|"Principal not unique %s.%s"
argument_list|,
name|p_name
argument_list|,
name|instance
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_PRINCIPAL_NOT_UNIQUE
return|;
block|}
comment|/* If the user's key is null, we want to return an error */
if|if
condition|(
operator|(
name|p
operator|->
name|key_low
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p
operator|->
name|key_high
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* User has a null key */
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_NKY
argument_list|,
literal|"Null key %s.%s"
argument_list|,
name|p_name
argument_list|,
name|instance
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_NULL_KEY
return|;
block|}
if|if
condition|(
name|master_key_version
operator|!=
name|p
operator|->
name|kdc_key_ver
condition|)
block|{
comment|/* log error reply */
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_MKV
argument_list|,
literal|"Incorrect master key version for %s.%s: %d (should be %d)"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|instance
argument_list|,
name|p
operator|->
name|kdc_key_ver
argument_list|,
name|master_key_version
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_NAME_MAST_KEY_VER
return|;
block|}
comment|/* make sure the service hasn't expired */
if|if
condition|(
operator|(
name|u_int32_t
operator|)
name|p
operator|->
name|exp_date
operator|<
operator|(
name|u_int32_t
operator|)
name|kerb_time
operator|.
name|tv_sec
condition|)
block|{
comment|/* service did expire, log it */
name|time_t
name|t
init|=
name|p
operator|->
name|exp_date
decl_stmt|;
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_SEXP
argument_list|,
literal|"Principal %s.%s expired at %s"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|instance
argument_list|,
name|krb_stime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_NAME_EXP
return|;
block|}
comment|/* ok is zero */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unseal
parameter_list|(
name|des_cblock
modifier|*
name|key
parameter_list|)
block|{
name|kdb_encrypt_key
argument_list|(
name|key
argument_list|,
name|key
argument_list|,
operator|&
name|master_key
argument_list|,
name|master_key_schedule
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the key for krb_rd_req so we can check tgt */
end_comment

begin_function
specifier|static
name|int
name|set_tgtkey
parameter_list|(
name|char
modifier|*
name|r
parameter_list|)
comment|/* Realm for desired key */
block|{
name|int
name|n
decl_stmt|;
specifier|static
name|char
name|lastrealm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|Principal
name|p_st
decl_stmt|;
name|Principal
modifier|*
name|p
init|=
operator|&
name|p_st
decl_stmt|;
name|des_cblock
name|key
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|lastrealm
argument_list|,
name|r
argument_list|)
condition|)
return|return
operator|(
name|KSUCCESS
operator|)
return|;
name|klog
argument_list|(
name|L_ALL_REQ
argument_list|,
literal|"Getting key for %s"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|n
operator|=
name|kerb_get_principal
argument_list|(
name|KRB_TICKET_GRANTING_TICKET
argument_list|,
name|r
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
operator|&
name|more
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|KFAILURE
operator|)
return|;
comment|/* unseal tgt key from master key */
name|copy_to_key
argument_list|(
operator|&
name|p
operator|->
name|key_low
argument_list|,
operator|&
name|p
operator|->
name|key_high
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|unseal
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|krb_set_key
argument_list|(
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|lastrealm
argument_list|,
name|r
argument_list|,
name|REALM_SZ
argument_list|)
expr_stmt|;
return|return
operator|(
name|KSUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kerberos
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|proto
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|client
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|server
parameter_list|,
name|KTEXT
name|rpkt
parameter_list|)
block|{
name|int
name|pvno
decl_stmt|;
name|int
name|msg_type
decl_stmt|;
name|int
name|lsb
decl_stmt|;
name|int
name|life
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|char
name|name
index|[
name|ANAME_SZ
index|]
decl_stmt|,
name|inst
index|[
name|INST_SZ
index|]
decl_stmt|,
name|realm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|char
name|service
index|[
name|SNAME_SZ
index|]
decl_stmt|,
name|sinst
index|[
name|INST_SZ
index|]
decl_stmt|;
name|u_int32_t
name|req_time
decl_stmt|;
specifier|static
name|KTEXT_ST
name|ticket
decl_stmt|,
name|cipher
decl_stmt|,
name|adat
decl_stmt|;
name|KTEXT
name|tk
init|=
operator|&
name|ticket
decl_stmt|,
name|ciph
init|=
operator|&
name|cipher
decl_stmt|,
name|auth
init|=
operator|&
name|adat
decl_stmt|;
name|AUTH_DAT
name|ad
decl_stmt|;
name|des_cblock
name|session
decl_stmt|,
name|key
decl_stmt|;
name|int
name|err
decl_stmt|;
name|Principal
name|a_name
decl_stmt|,
name|s_name
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
condition|)
block|{
name|strlcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
literal|"Packet too short"
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|KFAILURE
return|;
block|}
name|gettimeofday
argument_list|(
operator|&
name|kerb_time
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pvno
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|pvno
operator|!=
name|KRB_PROT_VERSION
condition|)
block|{
name|msg
operator|=
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"KRB protocol version mismatch (%d)"
argument_list|,
name|pvno
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_PKT_VER
return|;
block|}
name|msg_type
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|lsb
operator|=
name|msg_type
operator|&
literal|1
expr_stmt|;
name|msg_type
operator|&=
operator|~
literal|1
expr_stmt|;
switch|switch
condition|(
name|msg_type
condition|)
block|{
case|case
name|AUTH_MSG_KDC_REQUEST
case|:
comment|/* XXX range check */
name|p
operator|+=
name|krb_get_nir
argument_list|(
name|p
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
argument_list|)
argument_list|,
name|realm
argument_list|,
sizeof|sizeof
argument_list|(
name|realm
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|krb_get_int
argument_list|(
name|p
argument_list|,
operator|&
name|req_time
argument_list|,
literal|4
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|life
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|p
operator|+=
name|krb_get_nir
argument_list|(
name|p
argument_list|,
name|service
argument_list|,
sizeof|sizeof
argument_list|(
name|service
argument_list|)
argument_list|,
name|sinst
argument_list|,
sizeof|sizeof
argument_list|(
name|sinst
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|klog
argument_list|(
name|L_INI_REQ
argument_list|,
literal|"AS REQ %s.%s@%s for %s.%s from %s (%s/%u)"
argument_list|,
name|name
argument_list|,
name|inst
argument_list|,
name|realm
argument_list|,
name|service
argument_list|,
name|sinst
argument_list|,
name|inet_ntoa
argument_list|(
name|client
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|proto
argument_list|,
name|ntohs
argument_list|(
name|server
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|check_princ
argument_list|(
name|name
argument_list|,
name|inst
argument_list|,
literal|0
argument_list|,
operator|&
name|a_name
argument_list|)
operator|)
condition|)
block|{
name|strlcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|krb_get_err_text
argument_list|(
name|err
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|tk
operator|->
name|length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|check_princ
argument_list|(
name|service
argument_list|,
name|sinst
argument_list|,
literal|0
argument_list|,
operator|&
name|s_name
argument_list|)
operator|)
condition|)
block|{
name|strlcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|krb_get_err_text
argument_list|(
name|err
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|life
operator|=
name|min
argument_list|(
name|life
argument_list|,
name|s_name
operator|.
name|max_life
argument_list|)
expr_stmt|;
name|life
operator|=
name|min
argument_list|(
name|life
argument_list|,
name|a_name
operator|.
name|max_life
argument_list|)
expr_stmt|;
name|des_new_random_key
argument_list|(
operator|&
name|session
argument_list|)
expr_stmt|;
name|copy_to_key
argument_list|(
operator|&
name|s_name
operator|.
name|key_low
argument_list|,
operator|&
name|s_name
operator|.
name|key_high
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|unseal
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|krb_create_ticket
argument_list|(
name|tk
argument_list|,
name|flags
argument_list|,
name|a_name
operator|.
name|name
argument_list|,
name|a_name
operator|.
name|instance
argument_list|,
name|local_realm
argument_list|,
name|client
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|session
argument_list|,
name|life
argument_list|,
name|kerb_time
operator|.
name|tv_sec
argument_list|,
name|s_name
operator|.
name|name
argument_list|,
name|s_name
operator|.
name|instance
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|copy_to_key
argument_list|(
operator|&
name|a_name
operator|.
name|key_low
argument_list|,
operator|&
name|a_name
operator|.
name|key_high
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|unseal
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|create_ciph
argument_list|(
name|ciph
argument_list|,
name|session
argument_list|,
name|s_name
operator|.
name|name
argument_list|,
name|s_name
operator|.
name|instance
argument_list|,
name|local_realm
argument_list|,
name|life
argument_list|,
name|s_name
operator|.
name|key_version
argument_list|,
name|tk
argument_list|,
name|kerb_time
operator|.
name|tv_sec
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|session
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|session
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|KTEXT
name|r
decl_stmt|;
name|r
operator|=
name|create_auth_reply
argument_list|(
name|name
argument_list|,
name|inst
argument_list|,
name|realm
argument_list|,
name|req_time
argument_list|,
literal|0
argument_list|,
name|a_name
operator|.
name|exp_date
argument_list|,
name|a_name
operator|.
name|key_version
argument_list|,
name|ciph
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rpkt
argument_list|,
name|r
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rpkt
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|AUTH_MSG_APPL_REQUEST
case|:
name|strlcpy
argument_list|(
name|realm
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
literal|3
argument_list|,
name|REALM_SZ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|set_tgtkey
argument_list|(
name|realm
argument_list|)
operator|)
condition|)
block|{
name|msg
operator|=
name|klog
argument_list|(
name|L_ERR_UNK
argument_list|,
literal|"Unknown realm %s from %s (%s/%u)"
argument_list|,
name|realm
argument_list|,
name|inet_ntoa
argument_list|(
name|client
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|proto
argument_list|,
name|ntohs
argument_list|(
name|server
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|realm
argument_list|)
operator|+
literal|4
expr_stmt|;
name|p
operator|=
name|p
operator|+
name|p
index|[
literal|0
index|]
operator|+
name|p
index|[
literal|1
index|]
operator|+
literal|2
expr_stmt|;
name|auth
operator|->
name|length
operator|=
name|p
operator|-
name|buf
expr_stmt|;
name|memcpy
argument_list|(
name|auth
operator|->
name|dat
argument_list|,
name|buf
argument_list|,
name|auth
operator|->
name|length
argument_list|)
expr_stmt|;
name|err
operator|=
name|krb_rd_req
argument_list|(
name|auth
argument_list|,
name|KRB_TICKET_GRANTING_TICKET
argument_list|,
name|realm
argument_list|,
name|client
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
operator|&
name|ad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|msg
operator|=
name|klog
argument_list|(
name|L_ERR_UNK
argument_list|,
literal|"krb_rd_req from %s (%s/%u): %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|client
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|proto
argument_list|,
name|ntohs
argument_list|(
name|server
operator|->
name|sin_port
argument_list|)
argument_list|,
name|krb_get_err_text
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|p
operator|+=
name|krb_get_int
argument_list|(
name|p
argument_list|,
operator|&
name|req_time
argument_list|,
literal|4
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|life
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|p
operator|+=
name|krb_get_nir
argument_list|(
name|p
argument_list|,
name|service
argument_list|,
sizeof|sizeof
argument_list|(
name|service
argument_list|)
argument_list|,
name|sinst
argument_list|,
sizeof|sizeof
argument_list|(
name|sinst
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|klog
argument_list|(
name|L_APPL_REQ
argument_list|,
literal|"APPL REQ %s.%s@%s for %s.%s from %s (%s/%u)"
argument_list|,
name|ad
operator|.
name|pname
argument_list|,
name|ad
operator|.
name|pinst
argument_list|,
name|ad
operator|.
name|prealm
argument_list|,
name|service
argument_list|,
name|sinst
argument_list|,
name|inet_ntoa
argument_list|(
name|client
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|proto
argument_list|,
name|ntohs
argument_list|(
name|server
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ad
operator|.
name|prealm
argument_list|,
name|realm
argument_list|)
condition|)
block|{
name|msg
operator|=
name|klog
argument_list|(
name|L_ERR_UNK
argument_list|,
literal|"Can't hop realms: %s -> %s"
argument_list|,
name|realm
argument_list|,
name|ad
operator|.
name|prealm
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_PRINCIPAL_UNKNOWN
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|service
argument_list|,
literal|"changepw"
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
literal|"Can't authorize password changed based on TGT"
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_PRINCIPAL_UNKNOWN
return|;
block|}
name|err
operator|=
name|check_princ
argument_list|(
name|service
argument_list|,
name|sinst
argument_list|,
name|life
argument_list|,
operator|&
name|s_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|strlcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|krb_get_err_text
argument_list|(
name|err
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|life
operator|=
name|min
argument_list|(
name|life
argument_list|,
name|krb_time_to_life
argument_list|(
name|kerb_time
operator|.
name|tv_sec
argument_list|,
name|krb_life_to_time
argument_list|(
name|ad
operator|.
name|time_sec
argument_list|,
name|ad
operator|.
name|life
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|life
operator|=
name|min
argument_list|(
name|life
argument_list|,
name|s_name
operator|.
name|max_life
argument_list|)
expr_stmt|;
name|copy_to_key
argument_list|(
operator|&
name|s_name
operator|.
name|key_low
argument_list|,
operator|&
name|s_name
operator|.
name|key_high
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|unseal
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|des_new_random_key
argument_list|(
operator|&
name|session
argument_list|)
expr_stmt|;
name|krb_create_ticket
argument_list|(
name|tk
argument_list|,
name|flags
argument_list|,
name|ad
operator|.
name|pname
argument_list|,
name|ad
operator|.
name|pinst
argument_list|,
name|ad
operator|.
name|prealm
argument_list|,
name|client
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
operator|&
name|session
argument_list|,
name|life
argument_list|,
name|kerb_time
operator|.
name|tv_sec
argument_list|,
name|s_name
operator|.
name|name
argument_list|,
name|s_name
operator|.
name|instance
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|create_ciph
argument_list|(
name|ciph
argument_list|,
name|session
argument_list|,
name|service
argument_list|,
name|sinst
argument_list|,
name|local_realm
argument_list|,
name|life
argument_list|,
name|s_name
operator|.
name|key_version
argument_list|,
name|tk
argument_list|,
name|kerb_time
operator|.
name|tv_sec
argument_list|,
operator|&
name|ad
operator|.
name|session
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|session
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|session
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ad
operator|.
name|session
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ad
operator|.
name|session
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|KTEXT
name|r
decl_stmt|;
name|r
operator|=
name|create_auth_reply
argument_list|(
name|ad
operator|.
name|pname
argument_list|,
name|ad
operator|.
name|pinst
argument_list|,
name|ad
operator|.
name|prealm
argument_list|,
name|req_time
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ciph
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rpkt
argument_list|,
name|r
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rpkt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|s_name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|s_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|AUTH_MSG_ERR_REPLY
case|:
return|return
operator|-
literal|1
return|;
default|default:
name|msg
operator|=
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Unknown message type: %d from %s (%s/%u)"
argument_list|,
name|msg_type
argument_list|,
name|inet_ntoa
argument_list|(
name|client
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|proto
argument_list|,
name|ntohs
argument_list|(
name|server
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|KFAILURE
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|kerberos_wrap
parameter_list|(
name|int
name|s
parameter_list|,
name|KTEXT
name|data
parameter_list|,
name|char
modifier|*
name|proto
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|client
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|server
parameter_list|)
block|{
name|KTEXT_ST
name|pkt
decl_stmt|;
name|int
name|http_flag
init|=
name|strcmp
argument_list|(
name|proto
argument_list|,
literal|"http"
argument_list|)
operator|==
literal|0
decl_stmt|;
name|int
name|err
init|=
name|kerberos
argument_list|(
name|data
operator|->
name|dat
argument_list|,
name|data
operator|->
name|length
argument_list|,
name|proto
argument_list|,
name|client
argument_list|,
name|server
argument_list|,
operator|&
name|pkt
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|http_flag
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
literal|"HTTP/1.1 200 OK\r\n"
literal|"Server: KTH-KRB/1\r\n"
literal|"Content-type: application/octet-stream\r\n"
literal|"Content-transfer-encoding: binary\r\n\r\n"
decl_stmt|;
name|sendto
argument_list|(
name|s
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|client
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|client
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|kerb_err_reply
argument_list|(
name|s
argument_list|,
name|client
argument_list|,
name|err
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pkt
operator|.
name|dat
argument_list|)
expr_stmt|;
return|return;
block|}
name|sendto
argument_list|(
name|s
argument_list|,
name|pkt
operator|.
name|dat
argument_list|,
name|pkt
operator|.
name|length
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|client
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|client
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setup_disc   *  * disconnect all descriptors, remove ourself from the process  * group that spawned us.   */
end_comment

begin_function
specifier|static
name|void
name|setup_disc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
literal|3
condition|;
name|s
operator|++
control|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|setsid
argument_list|()
expr_stmt|;
name|chdir
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Make sure that database isn't stale.  *  * Exit if it is; we don't want to tell lies.  */
end_comment

begin_function
specifier|static
name|void
name|check_db_age
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|age
decl_stmt|;
if|if
condition|(
name|max_age
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Requires existance of kerb_get_db_age() */
name|gettimeofday
argument_list|(
operator|&
name|kerb_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|age
operator|=
name|kerb_get_db_age
argument_list|()
expr_stmt|;
if|if
condition|(
name|age
operator|==
literal|0
condition|)
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Database currently being updated!"
argument_list|)
expr_stmt|;
name|hang
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|age
operator|+
name|max_age
operator|)
operator|<
name|kerb_time
operator|.
name|tv_sec
condition|)
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Database out of date!"
argument_list|)
expr_stmt|;
name|hang
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
block|}
end_function

begin_struct
struct|struct
name|descr
block|{
name|int
name|s
decl_stmt|;
name|KTEXT_ST
name|buf
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|mksocket
parameter_list|(
name|struct
name|descr
modifier|*
name|d
parameter_list|,
name|struct
name|in_addr
name|addr
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|service
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|memset
argument_list|(
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|descr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|>=
name|FD_SETSIZE
condition|)
block|{
name|errno
operator|=
name|EMFILE
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Aborting: too many descriptors"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SO_REUSEADDR
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETSOCKOPT
argument_list|)
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"setsockopt (SO_REUSEADDR)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|d
operator|->
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|d
operator|->
name|addr
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|d
operator|->
name|addr
operator|.
name|sin_addr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|d
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"bind '%s/%s' (%d)"
argument_list|,
name|service
argument_list|,
operator|(
name|type
operator|==
name|SOCK_DGRAM
operator|)
condition|?
literal|"udp"
else|:
literal|"tcp"
argument_list|,
name|ntohs
argument_list|(
name|d
operator|->
name|addr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SOCK_STREAM
condition|)
name|listen
argument_list|(
name|sock
argument_list|,
name|SOMAXCONN
argument_list|)
expr_stmt|;
name|d
operator|->
name|s
operator|=
name|sock
expr_stmt|;
name|d
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|loop
parameter_list|(
name|struct
name|descr
modifier|*
name|fds
parameter_list|,
name|int
name|maxfd
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|port_spec
block|{
name|int
name|port
decl_stmt|;
name|int
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|add_port
parameter_list|(
name|struct
name|port_spec
modifier|*
modifier|*
name|ports
parameter_list|,
name|int
modifier|*
name|num_ports
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|port_spec
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|realloc
argument_list|(
operator|*
name|ports
argument_list|,
operator|(
operator|*
name|num_ports
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
operator|*
name|ports
operator|=
name|tmp
expr_stmt|;
name|tmp
index|[
operator|*
name|num_ports
index|]
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|tmp
index|[
operator|*
name|num_ports
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
operator|(
operator|*
name|num_ports
operator|)
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_sockets
parameter_list|(
specifier|const
name|char
modifier|*
name|port_spec
parameter_list|,
name|struct
name|in_addr
modifier|*
name|i_addr
parameter_list|,
name|struct
name|descr
modifier|*
modifier|*
name|fds
parameter_list|,
name|int
modifier|*
name|nfds
parameter_list|)
block|{
name|int
name|tp
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|pos
init|=
name|NULL
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|struct
name|port_spec
modifier|*
name|ports
init|=
name|NULL
decl_stmt|;
name|int
name|num_ports
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|port_spec_copy
init|=
name|strdup
argument_list|(
name|port_spec
argument_list|)
decl_stmt|;
if|if
condition|(
name|port_spec_copy
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|strtok_r
argument_list|(
name|port_spec_copy
argument_list|,
literal|", \t"
argument_list|,
operator|&
name|pos
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|strtok_r
argument_list|(
name|NULL
argument_list|,
literal|", \t"
argument_list|,
operator|&
name|pos
argument_list|)
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"+"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|add_port
argument_list|(
operator|&
name|ports
argument_list|,
operator|&
name|num_ports
argument_list|,
literal|88
argument_list|,
name|SOCK_DGRAM
argument_list|)
expr_stmt|;
name|add_port
argument_list|(
operator|&
name|ports
argument_list|,
operator|&
name|num_ports
argument_list|,
literal|88
argument_list|,
name|SOCK_STREAM
argument_list|)
expr_stmt|;
name|add_port
argument_list|(
operator|&
name|ports
argument_list|,
operator|&
name|num_ports
argument_list|,
literal|750
argument_list|,
name|SOCK_DGRAM
argument_list|)
expr_stmt|;
name|add_port
argument_list|(
operator|&
name|ports
argument_list|,
operator|&
name|num_ports
argument_list|,
literal|750
argument_list|,
name|SOCK_STREAM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
block|{
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
name|sp
operator|=
name|getservbyname
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
name|tp
operator|=
name|ntohs
argument_list|(
name|sp
operator|->
name|s_port
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|tp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"Unknown port: %s%s%s"
argument_list|,
name|p
argument_list|,
name|q
condition|?
literal|"/"
else|:
literal|""
argument_list|,
name|q
condition|?
name|q
else|:
literal|""
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|q
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|q
argument_list|,
literal|"tcp"
argument_list|)
operator|==
literal|0
condition|)
name|add_port
argument_list|(
operator|&
name|ports
argument_list|,
operator|&
name|num_ports
argument_list|,
name|tp
argument_list|,
name|SOCK_STREAM
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|q
argument_list|,
literal|"udp"
argument_list|)
operator|==
literal|0
condition|)
name|add_port
argument_list|(
operator|&
name|ports
argument_list|,
operator|&
name|num_ports
argument_list|,
name|tp
argument_list|,
name|SOCK_DGRAM
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"Unknown protocol type: %s"
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_port
argument_list|(
operator|&
name|ports
argument_list|,
operator|&
name|num_ports
argument_list|,
name|tp
argument_list|,
name|SOCK_DGRAM
argument_list|)
expr_stmt|;
name|add_port
argument_list|(
operator|&
name|ports
argument_list|,
operator|&
name|num_ports
argument_list|,
name|tp
argument_list|,
name|SOCK_STREAM
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|port_spec_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_ports
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"No valid ports specified!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_addr
condition|)
block|{
operator|*
name|nfds
operator|=
literal|1
expr_stmt|;
name|a
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
operator|*
operator|*
name|nfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Failed to allocate %lu bytes"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
operator|*
operator|*
name|nfds
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|a
argument_list|,
name|i_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|nfds
operator|=
name|k_get_all_addrs
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|nfds
operator|<
literal|0
condition|)
block|{
name|struct
name|in_addr
name|any
decl_stmt|;
name|any
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|warnx
argument_list|(
literal|"Could not get local addresses, binding to INADDR_ANY"
argument_list|)
expr_stmt|;
operator|*
name|nfds
operator|=
literal|1
expr_stmt|;
name|a
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
operator|*
operator|*
name|nfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Failed to allocate %lu bytes"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
operator|*
operator|*
name|nfds
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|a
argument_list|,
operator|&
name|any
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|fds
operator|=
name|malloc
argument_list|(
operator|*
name|nfds
operator|*
name|num_ports
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|fds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|fds
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Failed to allocate %lu bytes"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|*
name|nfds
operator|*
name|num_ports
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|fds
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|nfds
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_ports
condition|;
name|j
operator|++
control|)
block|{
name|mksocket
argument_list|(
operator|*
name|fds
operator|+
name|num_ports
operator|*
name|i
operator|+
name|j
argument_list|,
name|a
index|[
name|i
index|]
argument_list|,
name|ports
index|[
name|j
index|]
operator|.
name|type
argument_list|,
literal|""
argument_list|,
name|htons
argument_list|(
name|ports
index|[
name|j
index|]
operator|.
name|port
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|nfds
operator|*=
name|num_ports
expr_stmt|;
name|free
argument_list|(
name|ports
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|child
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|descr
modifier|*
name|fds
decl_stmt|;
name|int
name|nfds
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|kerror
decl_stmt|;
name|int
name|i_flag
init|=
literal|0
decl_stmt|;
name|struct
name|in_addr
name|i_addr
decl_stmt|;
name|char
modifier|*
name|port_spec
init|=
literal|"+"
decl_stmt|;
name|umask
argument_list|(
literal|077
argument_list|)
expr_stmt|;
comment|/* Create protected files */
name|set_progname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"snmp:P:a:l:r:i:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* 	     * Set parameters to slave server defaults. 	     */
if|if
condition|(
name|max_age
operator|==
operator|-
literal|1
operator|&&
operator|!
name|nflag
condition|)
name|max_age
operator|=
name|THREE_DAYS
expr_stmt|;
comment|/* Survive weekend */
if|if
condition|(
name|pause_int
operator|==
operator|-
literal|1
condition|)
name|pause_int
operator|=
name|FIVE_MINUTES
expr_stmt|;
comment|/* 5 minutes */
break|break;
case|case
literal|'n'
case|:
name|max_age
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* don't check max age. */
name|nflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mflag
operator|++
expr_stmt|;
comment|/* running manually; prompt for master key */
break|break;
case|case
literal|'p'
case|:
block|{
comment|/* Set pause interval. */
name|char
modifier|*
name|tmp
decl_stmt|;
name|pause_int
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pause_int
operator|==
literal|0
operator|&&
name|tmp
operator|==
name|optarg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pause_int `%s' not a number\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pause_int
operator|<
literal|5
operator|)
operator|||
operator|(
name|pause_int
operator|>
name|ONE_HOUR
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pause_int must be between 5 and 3600 seconds.\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'P'
case|:
name|port_spec
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
block|{
comment|/* Set max age. */
name|char
modifier|*
name|tmp
decl_stmt|;
name|max_age
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_age
operator|==
literal|0
operator|&&
name|tmp
operator|==
name|optarg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"max_age `%s' not a number\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|max_age
operator|<
name|ONE_HOUR
operator|)
operator|||
operator|(
name|max_age
operator|>
name|THREE_DAYS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"max_age must be between one hour and "
literal|"three days, in seconds\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'l'
case|:
comment|/* Set alternate log file */
name|log_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Set realm name */
name|rflag
operator|++
expr_stmt|;
name|strlcpy
argument_list|(
name|local_realm
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|local_realm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Only listen on this address */
if|if
condition|(
name|inet_aton
argument_list|(
name|optarg
argument_list|,
operator|&
name|i_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad address: %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|++
name|i_flag
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|==
operator|(
name|argc
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|kerb_db_set_name
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not set alternate database name\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|optind
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|!=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Kerberos server starting\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|nflag
operator|)
operator|&&
operator|(
name|max_age
operator|!=
operator|-
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"\tMaximum database age: %d seconds\n"
argument_list|,
name|max_age
argument_list|)
expr_stmt|;
if|if
condition|(
name|pause_int
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"\tSleep for %d seconds on error\n"
argument_list|,
name|pause_int
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\tSleep forever on error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mflag
condition|)
name|printf
argument_list|(
literal|"\tMaster key will be entered manually\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tLog file is %s\n"
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
name|kset_logfile
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
name|make_sockets
argument_list|(
name|port_spec
argument_list|,
name|i_flag
condition|?
operator|&
name|i_addr
else|:
name|NULL
argument_list|,
operator|&
name|fds
argument_list|,
operator|&
name|nfds
argument_list|)
expr_stmt|;
comment|/* do all the database and cache inits */
if|if
condition|(
operator|(
name|n
operator|=
name|kerb_init
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|mflag
condition|)
block|{
name|printf
argument_list|(
literal|"Kerberos db and cache init "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"failed = %d ...exiting\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Kerberos db and cache init failed = %d ...exiting"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|hang
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Make sure database isn't stale */
name|check_db_age
argument_list|()
expr_stmt|;
comment|/* setup master key */
if|if
condition|(
name|kdb_get_master_key
argument_list|(
name|mflag
argument_list|,
operator|&
name|master_key
argument_list|,
name|master_key_schedule
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"kerberos: couldn't get master key."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|kerror
operator|=
name|kdb_verify_master_key
argument_list|(
operator|&
name|master_key
argument_list|,
name|master_key_schedule
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerror
operator|<
literal|0
condition|)
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Can't verify master key."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|master_key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|master_key
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|master_key_schedule
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|master_key_schedule
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|master_key_version
operator|=
operator|(
name|u_char
operator|)
name|kerror
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nCurrent Kerberos master key version is %d\n"
argument_list|,
name|master_key_version
argument_list|)
expr_stmt|;
name|des_init_random_number_generator
argument_list|(
operator|&
name|master_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rflag
condition|)
block|{
comment|/* Look up our local realm */
name|krb_get_lrealm
argument_list|(
name|local_realm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Local realm: %s\n"
argument_list|,
name|local_realm
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_tgtkey
argument_list|(
name|local_realm
argument_list|)
condition|)
block|{
comment|/* Ticket granting service unknown */
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Ticket granting ticket service unknown"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Ticket granting ticket service unknown\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mflag
condition|)
block|{
if|if
condition|(
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Kerberos started, PID=%d\n"
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|setup_disc
argument_list|()
expr_stmt|;
block|}
name|klog
argument_list|(
name|L_ALL_REQ
argument_list|,
literal|"Starting Kerberos for %s (kvno %d)"
argument_list|,
name|local_realm
argument_list|,
name|master_key_version
argument_list|)
expr_stmt|;
comment|/* receive loop */
name|loop
argument_list|(
name|fds
argument_list|,
name|nfds
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_socket
parameter_list|(
name|struct
name|descr
modifier|*
name|n
parameter_list|)
block|{
name|int
name|b
decl_stmt|;
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|int
name|fromlen
init|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|b
operator|=
name|recvfrom
argument_list|(
name|n
operator|->
name|s
argument_list|,
name|n
operator|->
name|buf
operator|.
name|dat
operator|+
name|n
operator|->
name|buf
operator|.
name|length
argument_list|,
name|MAX_PKT_LEN
operator|-
name|n
operator|->
name|buf
operator|.
name|length
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|SOCK_STREAM
condition|)
block|{
name|close
argument_list|(
name|n
operator|->
name|s
argument_list|)
expr_stmt|;
name|n
operator|->
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|n
operator|->
name|buf
operator|.
name|length
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|n
operator|->
name|buf
operator|.
name|length
operator|+=
name|b
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|SOCK_STREAM
condition|)
block|{
name|char
modifier|*
name|proto
init|=
literal|"tcp"
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|buf
operator|.
name|length
operator|>
literal|4
operator|&&
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|n
operator|->
name|buf
operator|.
name|dat
argument_list|,
literal|"GET "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|n
operator|->
name|buf
operator|.
name|dat
operator|+
name|n
operator|->
name|buf
operator|.
name|length
operator|-
literal|4
argument_list|,
literal|"\r\n\r\n"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|save
init|=
name|NULL
decl_stmt|;
name|n
operator|->
name|buf
operator|.
name|dat
index|[
name|n
operator|->
name|buf
operator|.
name|length
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|strtok_r
argument_list|(
operator|(
name|char
operator|*
operator|)
name|n
operator|->
name|buf
operator|.
name|dat
argument_list|,
literal|" \t\r\n"
argument_list|,
operator|&
name|save
argument_list|)
expr_stmt|;
name|p
operator|=
name|strtok_r
argument_list|(
name|NULL
argument_list|,
literal|" \t\r\n"
argument_list|,
operator|&
name|save
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|p
operator|++
expr_stmt|;
name|n
operator|->
name|buf
operator|.
name|length
operator|=
name|base64_decode
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|buf
operator|.
name|dat
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|buf
operator|.
name|length
operator|<=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
literal|"HTTP/1.1 404 Not found\r\n"
literal|"Server: KTH-KRB/1\r\n"
literal|"Content-type: text/html\r\n"
literal|"Content-transfer-encoding: 8bit\r\n\r\n"
literal|"<TITLE>404 Not found</TITLE>\r\n"
literal|"<H1>404 Not found</H1>\r\n"
literal|"That page does not exist. Information about "
literal|"<A HREF=\"http://www.pdc.kth.se/kth-krb\">KTH-KRB</A> "
literal|"is available elsewhere.\r\n"
decl_stmt|;
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpeername
argument_list|(
name|n
operator|->
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
operator|==
literal|0
condition|)
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Unknown HTTP request from %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Unknown HTTP request from<unknown>"
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|n
operator|->
name|s
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|n
operator|->
name|s
argument_list|)
expr_stmt|;
name|n
operator|->
name|s
operator|=
operator|-
literal|1
expr_stmt|;
name|n
operator|->
name|buf
operator|.
name|length
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|proto
operator|=
literal|"http"
expr_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|buf
operator|.
name|length
operator|>=
literal|4
operator|&&
name|n
operator|->
name|buf
operator|.
name|dat
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* if this is a new type of packet (with 	       the length attached to the head of the 	       packet), and there is no more data to 	       be read, fake an old packet, so the 	       code below will work */
name|u_int32_t
name|len
decl_stmt|;
name|krb_get_int
argument_list|(
name|n
operator|->
name|buf
operator|.
name|dat
argument_list|,
operator|&
name|len
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|buf
operator|.
name|length
operator|==
name|len
operator|+
literal|4
condition|)
block|{
name|memmove
argument_list|(
name|n
operator|->
name|buf
operator|.
name|dat
argument_list|,
name|n
operator|->
name|buf
operator|.
name|dat
operator|+
literal|4
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
comment|/* handle request if there are  	       no more bytes to read */
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|getpeername
argument_list|(
name|n
operator|->
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
name|kerberos_wrap
argument_list|(
name|n
operator|->
name|s
argument_list|,
operator|&
name|n
operator|->
name|buf
argument_list|,
name|proto
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|n
operator|->
name|addr
argument_list|)
expr_stmt|;
name|n
operator|->
name|buf
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|n
operator|->
name|s
argument_list|)
expr_stmt|;
name|n
operator|->
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* udp packets are atomic */
name|kerberos_wrap
argument_list|(
name|n
operator|->
name|s
argument_list|,
operator|&
name|n
operator|->
name|buf
argument_list|,
literal|"udp"
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|n
operator|->
name|addr
argument_list|)
expr_stmt|;
name|n
operator|->
name|buf
operator|.
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|fd_set
name|readfds
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|loop
parameter_list|(
name|struct
name|descr
modifier|*
name|fds
parameter_list|,
name|int
name|base_nfds
parameter_list|)
block|{
name|int
name|nfds
init|=
name|base_nfds
decl_stmt|;
name|int
name|max_tcp
init|=
name|min
argument_list|(
name|FD_SETSIZE
argument_list|,
name|getdtablesize
argument_list|()
argument_list|)
operator|-
name|fds
index|[
name|base_nfds
operator|-
literal|1
index|]
operator|.
name|s
decl_stmt|;
if|if
condition|(
name|max_tcp
operator|<=
literal|10
condition|)
block|{
name|errno
operator|=
name|EMFILE
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Aborting: too many descriptors"
argument_list|)
expr_stmt|;
block|}
name|max_tcp
operator|-=
literal|10
expr_stmt|;
comment|/* We need a few extra for DB, logs, etc. */
if|if
condition|(
name|max_tcp
operator|>
literal|100
condition|)
name|max_tcp
operator|=
literal|100
expr_stmt|;
comment|/* Keep to some sane limit. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|next_timeout
init|=
literal|10
decl_stmt|;
comment|/* In seconds */
name|int
name|maxfd
init|=
literal|0
decl_stmt|;
name|struct
name|descr
modifier|*
name|n
decl_stmt|,
modifier|*
name|minfree
decl_stmt|;
name|int
name|accepted
decl_stmt|;
comment|/* accept at most one socket per `round' */
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|maxfd
operator|=
literal|0
expr_stmt|;
name|minfree
operator|=
name|NULL
expr_stmt|;
comment|/* Remove expired TCP sockets, and add all other  	   to the set we are selecting on */
for|for
control|(
name|n
operator|=
name|fds
init|;
name|n
operator|<
name|fds
operator|+
name|nfds
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|->
name|s
operator|>=
literal|0
operator|&&
name|n
operator|->
name|timeout
operator|&&
name|tv
operator|.
name|tv_sec
operator|>
name|n
operator|->
name|timeout
condition|)
block|{
name|kerb_err_reply
argument_list|(
name|n
operator|->
name|s
argument_list|,
name|NULL
argument_list|,
name|KERB_ERR_TIMEOUT
argument_list|,
literal|"Timeout"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|n
operator|->
name|s
argument_list|)
expr_stmt|;
name|n
operator|->
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|->
name|s
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|minfree
operator|==
name|NULL
condition|)
name|minfree
operator|=
name|n
expr_stmt|;
continue|continue;
block|}
name|FD_SET
argument_list|(
name|n
operator|->
name|s
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|maxfd
operator|=
name|max
argument_list|(
name|maxfd
argument_list|,
name|n
operator|->
name|s
argument_list|)
expr_stmt|;
name|next_timeout
operator|=
name|min
argument_list|(
name|next_timeout
argument_list|,
name|tv
operator|.
name|tv_sec
operator|-
name|n
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
comment|/* add more space for sockets */
if|if
condition|(
name|minfree
operator|==
name|NULL
operator|&&
name|nfds
operator|<
name|base_nfds
operator|+
name|max_tcp
condition|)
block|{
name|int
name|i
init|=
name|nfds
decl_stmt|;
name|struct
name|descr
modifier|*
name|new
decl_stmt|;
name|nfds
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|nfds
operator|>
name|base_nfds
operator|+
name|max_tcp
condition|)
name|nfds
operator|=
name|base_nfds
operator|+
name|max_tcp
expr_stmt|;
name|new
operator|=
name|realloc
argument_list|(
name|fds
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|descr
argument_list|)
operator|*
name|nfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|fds
operator|=
name|new
expr_stmt|;
name|minfree
operator|=
name|fds
operator|+
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nfds
condition|;
name|i
operator|++
control|)
name|fds
index|[
name|i
index|]
operator|.
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|minfree
operator|==
name|NULL
condition|)
block|{
comment|/* 	     * We are possibly the subject of a DOS attack, pick a TCP 	     * connection at random and drop it. 	     */
name|int
name|r
init|=
name|rand
argument_list|()
operator|%
operator|(
name|nfds
operator|-
name|base_nfds
operator|)
decl_stmt|;
name|r
operator|=
name|r
operator|+
name|base_nfds
expr_stmt|;
name|FD_CLR
argument_list|(
name|fds
index|[
name|r
index|]
operator|.
name|s
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fds
index|[
name|r
index|]
operator|.
name|s
argument_list|)
expr_stmt|;
name|fds
index|[
name|r
index|]
operator|.
name|s
operator|=
operator|-
literal|1
expr_stmt|;
name|minfree
operator|=
operator|&
name|fds
index|[
name|r
index|]
expr_stmt|;
block|}
if|if
condition|(
name|next_timeout
operator|<
literal|0
condition|)
name|next_timeout
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|next_timeout
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|select
argument_list|(
name|maxfd
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"select: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|accepted
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|fds
init|;
name|n
operator|<
name|fds
operator|+
name|nfds
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|->
name|s
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|n
operator|->
name|s
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|SOCK_STREAM
operator|&&
name|n
operator|->
name|timeout
operator|==
literal|0
condition|)
block|{
comment|/* add accepted socket to list of sockets we are                        selecting on */
name|int
name|s
decl_stmt|;
if|if
condition|(
name|accepted
condition|)
continue|continue;
name|accepted
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|accept
argument_list|(
name|n
operator|->
name|s
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|minfree
operator|==
name|NULL
operator|||
name|s
operator|>=
name|FD_SETSIZE
condition|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|minfree
operator|->
name|s
operator|=
name|s
expr_stmt|;
name|minfree
operator|->
name|type
operator|=
name|SOCK_STREAM
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|minfree
operator|->
name|timeout
operator|=
name|tv
operator|.
name|tv_sec
operator|+
literal|4
expr_stmt|;
comment|/* XXX */
name|minfree
operator|->
name|buf
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|minfree
operator|->
name|addr
argument_list|,
operator|&
name|n
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|minfree
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|read_socket
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

end_unit

