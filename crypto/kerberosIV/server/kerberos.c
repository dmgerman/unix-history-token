begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1985, 1986, 1987, 1988 by the Massachusetts Institute  * of Technology.  *  * For copying and distribution information, please see the file  *<mit-copyright.h>.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"protos.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: kerberos.c,v 1.64 1997/05/20 18:40:46 bg Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIME_WITH_SYS_TIME
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SYS_TIME_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SELECT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ARPA_INET_H
end_ifdef

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FCNTL_H
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_IOCTL_H
argument_list|)
operator|&&
name|SunOS
operator|!=
literal|4
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_FILIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_FILIO_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SOCKS
end_ifdef

begin_include
include|#
directive|include
file|<socks.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<roken.h>
end_include

begin_include
include|#
directive|include
file|<des.h>
end_include

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<krb_db.h>
end_include

begin_include
include|#
directive|include
file|<prot.h>
end_include

begin_include
include|#
directive|include
file|<klog.h>
end_include

begin_include
include|#
directive|include
file|<kdc.h>
end_include

begin_decl_stmt
specifier|static
name|des_key_schedule
name|master_key_schedule
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|des_cblock
name|master_key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|kerb_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|master_key_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|k_instance
index|[
name|INST_SZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|more
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Are we invoked manually? */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|log_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of alt. log file */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't check max age */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* alternate realm specified */
end_comment

begin_comment
comment|/* fields within the received request packet */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|req_name_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|req_inst_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|req_realm_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|req_time_ws
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|local_realm
index|[
name|REALM_SZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* options */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_age
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pause_int
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Print usage message and exit.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-s] [-m] [-n] [-p pause_seconds]"
literal|" [-a max_age] [-l log_file] [-r realm] [database_pathname]\n"
argument_list|,
name|__progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * kerb_err_reply creates an error reply packet and sends it to the  * client.   */
end_comment

begin_function
specifier|static
name|void
name|kerb_err_reply
parameter_list|(
name|int
name|f
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|client
parameter_list|,
name|int
name|err
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
block|{
specifier|static
name|KTEXT_ST
name|e_pkt_st
decl_stmt|;
name|KTEXT
name|e_pkt
init|=
operator|&
name|e_pkt_st
decl_stmt|;
specifier|static
name|char
name|e_msg
index|[
literal|128
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|e_msg
argument_list|,
literal|"\nKerberos error -- "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|e_msg
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|cr_err_reply
argument_list|(
name|e_pkt
argument_list|,
name|req_name_ptr
argument_list|,
name|req_inst_ptr
argument_list|,
name|req_realm_ptr
argument_list|,
name|req_time_ws
argument_list|,
name|err
argument_list|,
name|e_msg
argument_list|)
expr_stmt|;
name|sendto
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
name|e_pkt
operator|->
name|dat
argument_list|,
name|e_pkt
operator|->
name|length
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|client
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|client
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hang
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|pause_int
operator|==
operator|-
literal|1
condition|)
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Kerberos will pause so as not to loop init"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
name|pause
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Kerberos will wait %d seconds before dying so as not to loop init"
argument_list|,
name|pause_int
argument_list|)
expr_stmt|;
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|pause_int
argument_list|)
expr_stmt|;
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Do svedania....\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|check_princ
parameter_list|(
name|char
modifier|*
name|p_name
parameter_list|,
name|char
modifier|*
name|instance
parameter_list|,
name|unsigned
name|int
name|lifetime
parameter_list|,
name|Principal
modifier|*
name|p
parameter_list|)
block|{
specifier|static
name|int
name|n
decl_stmt|;
specifier|static
name|int
name|more
decl_stmt|;
name|n
operator|=
name|kerb_get_principal
argument_list|(
name|p_name
argument_list|,
name|instance
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
operator|&
name|more
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|lt
operator|=
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Database unavailable!"
argument_list|)
expr_stmt|;
name|hang
argument_list|()
expr_stmt|;
block|}
comment|/*      * if more than one p_name, pick one, randomly create a session key,      * compute maximum lifetime, lookup authorizations if applicable,      * and stuff into cipher.       */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* service unknown, log error, skip to next request */
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_UNK
argument_list|,
literal|"UNKNOWN %s.%s"
argument_list|,
name|p_name
argument_list|,
name|instance
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_PRINCIPAL_UNKNOWN
return|;
block|}
if|if
condition|(
name|more
condition|)
block|{
comment|/* not unique, log error */
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_NUN
argument_list|,
literal|"Principal not unique %s.%s"
argument_list|,
name|p_name
argument_list|,
name|instance
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_PRINCIPAL_NOT_UNIQUE
return|;
block|}
comment|/* If the user's key is null, we want to return an error */
if|if
condition|(
operator|(
name|p
operator|->
name|key_low
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p
operator|->
name|key_high
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* User has a null key */
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_NKY
argument_list|,
literal|"Null key %s.%s"
argument_list|,
name|p_name
argument_list|,
name|instance
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_NULL_KEY
return|;
block|}
if|if
condition|(
name|master_key_version
operator|!=
name|p
operator|->
name|kdc_key_ver
condition|)
block|{
comment|/* log error reply */
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_MKV
argument_list|,
literal|"Incorrect master key version for %s.%s: %d (should be %d)"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|instance
argument_list|,
name|p
operator|->
name|kdc_key_ver
argument_list|,
name|master_key_version
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_NAME_MAST_KEY_VER
return|;
block|}
comment|/* make sure the service hasn't expired */
if|if
condition|(
operator|(
name|u_int32_t
operator|)
name|p
operator|->
name|exp_date
operator|<
operator|(
name|u_int32_t
operator|)
name|kerb_time
operator|.
name|tv_sec
condition|)
block|{
comment|/* service did expire, log it */
name|time_t
name|t
init|=
name|p
operator|->
name|exp_date
decl_stmt|;
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_SEXP
argument_list|,
literal|"Principal %s.%s expired at %s"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|instance
argument_list|,
name|krb_stime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_NAME_EXP
return|;
block|}
comment|/* ok is zero */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unseal
parameter_list|(
name|des_cblock
modifier|*
name|key
parameter_list|)
block|{
name|kdb_encrypt_key
argument_list|(
name|key
argument_list|,
name|key
argument_list|,
operator|&
name|master_key
argument_list|,
name|master_key_schedule
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the key for krb_rd_req so we can check tgt */
end_comment

begin_function
specifier|static
name|int
name|set_tgtkey
parameter_list|(
name|char
modifier|*
name|r
parameter_list|)
comment|/* Realm for desired key */
block|{
name|int
name|n
decl_stmt|;
specifier|static
name|char
name|lastrealm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|Principal
name|p_st
decl_stmt|;
name|Principal
modifier|*
name|p
init|=
operator|&
name|p_st
decl_stmt|;
name|des_cblock
name|key
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|lastrealm
argument_list|,
name|r
argument_list|)
condition|)
return|return
operator|(
name|KSUCCESS
operator|)
return|;
name|klog
argument_list|(
name|L_ALL_REQ
argument_list|,
literal|"Getting key for %s"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|n
operator|=
name|kerb_get_principal
argument_list|(
name|KRB_TICKET_GRANTING_TICKET
argument_list|,
name|r
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
operator|&
name|more
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|KFAILURE
operator|)
return|;
comment|/* unseal tgt key from master key */
name|copy_to_key
argument_list|(
operator|&
name|p
operator|->
name|key_low
argument_list|,
operator|&
name|p
operator|->
name|key_high
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|unseal
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|krb_set_key
argument_list|(
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lastrealm
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|KSUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kerberos
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|in_addr
name|client
parameter_list|,
name|KTEXT
name|rpkt
parameter_list|)
block|{
name|int
name|pvno
decl_stmt|;
name|int
name|msg_type
decl_stmt|;
name|int
name|lsb
decl_stmt|;
name|int
name|life
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|char
name|name
index|[
name|ANAME_SZ
index|]
decl_stmt|,
name|inst
index|[
name|INST_SZ
index|]
decl_stmt|,
name|realm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|char
name|service
index|[
name|SNAME_SZ
index|]
decl_stmt|,
name|sinst
index|[
name|INST_SZ
index|]
decl_stmt|;
name|u_int32_t
name|req_time
decl_stmt|;
specifier|static
name|KTEXT_ST
name|ticket
decl_stmt|,
name|cipher
decl_stmt|,
name|adat
decl_stmt|;
name|KTEXT
name|tk
init|=
operator|&
name|ticket
decl_stmt|,
name|ciph
init|=
operator|&
name|cipher
decl_stmt|,
name|auth
init|=
operator|&
name|adat
decl_stmt|;
name|AUTH_DAT
name|ad
decl_stmt|;
name|des_cblock
name|session
decl_stmt|,
name|key
decl_stmt|;
name|int
name|err
decl_stmt|;
name|Principal
name|a_name
decl_stmt|,
name|s_name
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
condition|)
block|{
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
literal|"Packet too short"
argument_list|)
expr_stmt|;
return|return
name|KFAILURE
return|;
block|}
name|gettimeofday
argument_list|(
operator|&
name|kerb_time
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pvno
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|pvno
operator|!=
name|KRB_PROT_VERSION
condition|)
block|{
name|msg
operator|=
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"KRB protocol version mismatch (%d)"
argument_list|,
name|pvno
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_PKT_VER
return|;
block|}
name|msg_type
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|lsb
operator|=
name|msg_type
operator|&
literal|1
expr_stmt|;
name|msg_type
operator|&=
operator|~
literal|1
expr_stmt|;
switch|switch
condition|(
name|msg_type
condition|)
block|{
case|case
name|AUTH_MSG_KDC_REQUEST
case|:
comment|/* XXX range check */
name|p
operator|+=
name|krb_get_nir
argument_list|(
name|p
argument_list|,
name|name
argument_list|,
name|inst
argument_list|,
name|realm
argument_list|)
expr_stmt|;
name|p
operator|+=
name|krb_get_int
argument_list|(
name|p
argument_list|,
operator|&
name|req_time
argument_list|,
literal|4
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|life
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|p
operator|+=
name|krb_get_nir
argument_list|(
name|p
argument_list|,
name|service
argument_list|,
name|sinst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|klog
argument_list|(
name|L_INI_REQ
argument_list|,
literal|"AS REQ %s.%s@%s for %s.%s from %s"
argument_list|,
name|name
argument_list|,
name|inst
argument_list|,
name|realm
argument_list|,
name|service
argument_list|,
name|sinst
argument_list|,
name|inet_ntoa
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|check_princ
argument_list|(
name|name
argument_list|,
name|inst
argument_list|,
literal|0
argument_list|,
operator|&
name|a_name
argument_list|)
operator|)
condition|)
block|{
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|krb_get_err_text
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|tk
operator|->
name|length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|check_princ
argument_list|(
name|service
argument_list|,
name|sinst
argument_list|,
literal|0
argument_list|,
operator|&
name|s_name
argument_list|)
operator|)
condition|)
block|{
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|krb_get_err_text
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|life
operator|=
name|min
argument_list|(
name|life
argument_list|,
name|s_name
operator|.
name|max_life
argument_list|)
expr_stmt|;
name|life
operator|=
name|min
argument_list|(
name|life
argument_list|,
name|a_name
operator|.
name|max_life
argument_list|)
expr_stmt|;
name|des_new_random_key
argument_list|(
operator|&
name|session
argument_list|)
expr_stmt|;
name|copy_to_key
argument_list|(
operator|&
name|s_name
operator|.
name|key_low
argument_list|,
operator|&
name|s_name
operator|.
name|key_high
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|unseal
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|krb_create_ticket
argument_list|(
name|tk
argument_list|,
name|flags
argument_list|,
name|a_name
operator|.
name|name
argument_list|,
name|a_name
operator|.
name|instance
argument_list|,
name|local_realm
argument_list|,
name|client
operator|.
name|s_addr
argument_list|,
name|session
argument_list|,
name|life
argument_list|,
name|kerb_time
operator|.
name|tv_sec
argument_list|,
name|s_name
operator|.
name|name
argument_list|,
name|s_name
operator|.
name|instance
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|copy_to_key
argument_list|(
operator|&
name|a_name
operator|.
name|key_low
argument_list|,
operator|&
name|a_name
operator|.
name|key_high
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|unseal
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|create_ciph
argument_list|(
name|ciph
argument_list|,
name|session
argument_list|,
name|s_name
operator|.
name|name
argument_list|,
name|s_name
operator|.
name|instance
argument_list|,
name|local_realm
argument_list|,
name|life
argument_list|,
name|s_name
operator|.
name|key_version
argument_list|,
name|tk
argument_list|,
name|kerb_time
operator|.
name|tv_sec
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|session
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|session
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|KTEXT
name|r
decl_stmt|;
name|r
operator|=
name|create_auth_reply
argument_list|(
name|name
argument_list|,
name|inst
argument_list|,
name|realm
argument_list|,
name|req_time
argument_list|,
literal|0
argument_list|,
name|a_name
operator|.
name|exp_date
argument_list|,
name|a_name
operator|.
name|key_version
argument_list|,
name|ciph
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rpkt
argument_list|,
name|r
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rpkt
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|AUTH_MSG_APPL_REQUEST
case|:
name|strcpy
argument_list|(
name|realm
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|set_tgtkey
argument_list|(
name|realm
argument_list|)
operator|)
condition|)
block|{
name|msg
operator|=
name|klog
argument_list|(
name|L_ERR_UNK
argument_list|,
literal|"Unknown realm %s from %s"
argument_list|,
name|realm
argument_list|,
name|inet_ntoa
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|realm
argument_list|)
operator|+
literal|4
expr_stmt|;
name|p
operator|=
name|p
operator|+
name|p
index|[
literal|0
index|]
operator|+
name|p
index|[
literal|1
index|]
operator|+
literal|2
expr_stmt|;
name|auth
operator|->
name|length
operator|=
name|p
operator|-
name|buf
expr_stmt|;
name|memcpy
argument_list|(
name|auth
operator|->
name|dat
argument_list|,
name|buf
argument_list|,
name|auth
operator|->
name|length
argument_list|)
expr_stmt|;
name|err
operator|=
name|krb_rd_req
argument_list|(
name|auth
argument_list|,
name|KRB_TICKET_GRANTING_TICKET
argument_list|,
name|realm
argument_list|,
name|client
operator|.
name|s_addr
argument_list|,
operator|&
name|ad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|msg
operator|=
name|klog
argument_list|(
name|L_ERR_UNK
argument_list|,
literal|"krb_rd_req from %s: %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|client
argument_list|)
argument_list|,
name|krb_get_err_text
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|p
operator|+=
name|krb_get_int
argument_list|(
name|p
argument_list|,
operator|&
name|req_time
argument_list|,
literal|4
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|life
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|p
operator|+=
name|krb_get_nir
argument_list|(
name|p
argument_list|,
name|service
argument_list|,
name|sinst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|klog
argument_list|(
name|L_APPL_REQ
argument_list|,
literal|"APPL REQ %s.%s@%s for %s.%s from %s"
argument_list|,
name|ad
operator|.
name|pname
argument_list|,
name|ad
operator|.
name|pinst
argument_list|,
name|ad
operator|.
name|prealm
argument_list|,
name|service
argument_list|,
name|sinst
argument_list|,
name|inet_ntoa
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ad
operator|.
name|prealm
argument_list|,
name|realm
argument_list|)
condition|)
block|{
name|msg
operator|=
name|klog
argument_list|(
name|L_ERR_UNK
argument_list|,
literal|"Can't hop realms: %s -> %s"
argument_list|,
name|realm
argument_list|,
name|ad
operator|.
name|prealm
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_PRINCIPAL_UNKNOWN
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|service
argument_list|,
literal|"changepw"
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
literal|"Can't authorize password changed based on TGT"
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_PRINCIPAL_UNKNOWN
return|;
block|}
name|err
operator|=
name|check_princ
argument_list|(
name|service
argument_list|,
name|sinst
argument_list|,
name|life
argument_list|,
operator|&
name|s_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|krb_get_err_text
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|life
operator|=
name|min
argument_list|(
name|life
argument_list|,
name|krb_time_to_life
argument_list|(
name|kerb_time
operator|.
name|tv_sec
argument_list|,
name|krb_life_to_time
argument_list|(
name|ad
operator|.
name|time_sec
argument_list|,
name|ad
operator|.
name|life
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|life
operator|=
name|min
argument_list|(
name|life
argument_list|,
name|s_name
operator|.
name|max_life
argument_list|)
expr_stmt|;
name|copy_to_key
argument_list|(
operator|&
name|s_name
operator|.
name|key_low
argument_list|,
operator|&
name|s_name
operator|.
name|key_high
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|unseal
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|des_new_random_key
argument_list|(
operator|&
name|session
argument_list|)
expr_stmt|;
name|krb_create_ticket
argument_list|(
name|tk
argument_list|,
name|flags
argument_list|,
name|ad
operator|.
name|pname
argument_list|,
name|ad
operator|.
name|pinst
argument_list|,
name|ad
operator|.
name|prealm
argument_list|,
name|client
operator|.
name|s_addr
argument_list|,
operator|&
name|session
argument_list|,
name|life
argument_list|,
name|kerb_time
operator|.
name|tv_sec
argument_list|,
name|s_name
operator|.
name|name
argument_list|,
name|s_name
operator|.
name|instance
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|create_ciph
argument_list|(
name|ciph
argument_list|,
name|session
argument_list|,
name|service
argument_list|,
name|sinst
argument_list|,
name|local_realm
argument_list|,
name|life
argument_list|,
name|s_name
operator|.
name|key_version
argument_list|,
name|tk
argument_list|,
name|kerb_time
operator|.
name|tv_sec
argument_list|,
operator|&
name|ad
operator|.
name|session
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|session
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|session
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ad
operator|.
name|session
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ad
operator|.
name|session
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|KTEXT
name|r
decl_stmt|;
name|r
operator|=
name|create_auth_reply
argument_list|(
name|ad
operator|.
name|pname
argument_list|,
name|ad
operator|.
name|pinst
argument_list|,
name|ad
operator|.
name|prealm
argument_list|,
name|req_time
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ciph
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rpkt
argument_list|,
name|r
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rpkt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|s_name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|s_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|AUTH_MSG_ERR_REPLY
case|:
return|return
operator|-
literal|1
return|;
default|default:
name|msg
operator|=
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Unknown message type: %d from %s"
argument_list|,
name|msg_type
argument_list|,
name|inet_ntoa
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|->
name|dat
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|KFAILURE
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|kerberos_wrap
parameter_list|(
name|int
name|s
parameter_list|,
name|KTEXT
name|data
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|client
parameter_list|)
block|{
name|KTEXT_ST
name|pkt
decl_stmt|;
name|int
name|err
init|=
name|kerberos
argument_list|(
name|data
operator|->
name|dat
argument_list|,
name|data
operator|->
name|length
argument_list|,
name|client
operator|->
name|sin_addr
argument_list|,
operator|&
name|pkt
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|err
condition|)
block|{
name|kerb_err_reply
argument_list|(
name|s
argument_list|,
name|client
argument_list|,
name|err
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pkt
operator|.
name|dat
argument_list|)
expr_stmt|;
return|return;
block|}
name|sendto
argument_list|(
name|s
argument_list|,
name|pkt
operator|.
name|dat
argument_list|,
name|pkt
operator|.
name|length
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|client
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|client
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setup_disc   *  * disconnect all descriptors, remove ourself from the process  * group that spawned us.   */
end_comment

begin_function
specifier|static
name|void
name|setup_disc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
literal|3
condition|;
name|s
operator|++
control|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|setsid
argument_list|()
expr_stmt|;
name|chdir
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Make sure that database isn't stale.  *  * Exit if it is; we don't want to tell lies.  */
end_comment

begin_function
specifier|static
name|void
name|check_db_age
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|age
decl_stmt|;
if|if
condition|(
name|max_age
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Requires existance of kerb_get_db_age() */
name|gettimeofday
argument_list|(
operator|&
name|kerb_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|age
operator|=
name|kerb_get_db_age
argument_list|()
expr_stmt|;
if|if
condition|(
name|age
operator|==
literal|0
condition|)
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Database currently being updated!"
argument_list|)
expr_stmt|;
name|hang
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|age
operator|+
name|max_age
operator|)
operator|<
name|kerb_time
operator|.
name|tv_sec
condition|)
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Database out of date!"
argument_list|)
expr_stmt|;
name|hang
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
block|}
end_function

begin_struct
struct|struct
name|descr
block|{
name|int
name|s
decl_stmt|;
name|KTEXT_ST
name|buf
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|mksocket
parameter_list|(
name|struct
name|descr
modifier|*
name|d
parameter_list|,
name|struct
name|in_addr
name|addr
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|service
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|sina
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|memset
argument_list|(
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|descr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SO_REUSEADDR
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETSOCKOPT
argument_list|)
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"setsockopt (SO_REUSEADDR)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|sina
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sina
argument_list|)
argument_list|)
expr_stmt|;
name|sina
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sina
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|sina
operator|.
name|sin_addr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sina
argument_list|,
sizeof|sizeof
argument_list|(
name|sina
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"bind '%s/%s' (%d)"
argument_list|,
name|service
argument_list|,
operator|(
name|type
operator|==
name|SOCK_DGRAM
operator|)
condition|?
literal|"udp"
else|:
literal|"tcp"
argument_list|,
name|ntohs
argument_list|(
name|sina
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SOCK_STREAM
condition|)
name|listen
argument_list|(
name|sock
argument_list|,
name|SOMAXCONN
argument_list|)
expr_stmt|;
name|d
operator|->
name|s
operator|=
name|sock
expr_stmt|;
name|d
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|loop
parameter_list|(
name|struct
name|descr
modifier|*
name|fds
parameter_list|,
name|int
name|maxfd
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|child
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|descr
modifier|*
name|fds
decl_stmt|;
name|int
name|nfds
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|kerror
decl_stmt|;
name|umask
argument_list|(
literal|077
argument_list|)
expr_stmt|;
comment|/* Create protected files */
name|set_progname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"snmp:a:l:r:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* 	     * Set parameters to slave server defaults. 	     */
if|if
condition|(
name|max_age
operator|==
operator|-
literal|1
operator|&&
operator|!
name|nflag
condition|)
name|max_age
operator|=
name|ONE_DAY
expr_stmt|;
comment|/* 24 hours */
if|if
condition|(
name|pause_int
operator|==
operator|-
literal|1
condition|)
name|pause_int
operator|=
name|FIVE_MINUTES
expr_stmt|;
comment|/* 5 minutes */
if|#
directive|if
literal|0
block|if (log_file == NULL) {
comment|/* this is only silly */
block|log_file = KRBSLAVELOG; 	    }
endif|#
directive|endif
break|break;
case|case
literal|'n'
case|:
name|max_age
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* don't check max age. */
name|nflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mflag
operator|++
expr_stmt|;
comment|/* running manually; prompt for master key */
break|break;
case|case
literal|'p'
case|:
comment|/* Set pause interval. */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|optarg
index|[
literal|0
index|]
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
name|pause_int
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pause_int
operator|<
literal|5
operator|)
operator|||
operator|(
name|pause_int
operator|>
name|ONE_HOUR
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pause_int must be between 5 and 3600 seconds.\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
comment|/* Set max age. */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|optarg
index|[
literal|0
index|]
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
name|max_age
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|max_age
operator|<
name|ONE_HOUR
operator|)
operator|||
operator|(
name|max_age
operator|>
name|THREE_DAYS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"max_age must be between one hour and three days, in seconds\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
comment|/* Set alternate log file */
name|log_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Set realm name */
name|rflag
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|local_realm
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|log_file
operator|==
name|NULL
condition|)
name|log_file
operator|=
name|KRBLOG
expr_stmt|;
if|if
condition|(
name|optind
operator|==
operator|(
name|argc
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|kerb_db_set_name
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not set alternate database name\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|optind
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|!=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Kerberos server starting\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|nflag
operator|)
operator|&&
operator|(
name|max_age
operator|!=
operator|-
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"\tMaximum database age: %d seconds\n"
argument_list|,
name|max_age
argument_list|)
expr_stmt|;
if|if
condition|(
name|pause_int
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"\tSleep for %d seconds on error\n"
argument_list|,
name|pause_int
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\tSleep forever on error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mflag
condition|)
name|printf
argument_list|(
literal|"\tMaster key will be entered manually\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tLog file is %s\n"
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
name|kset_logfile
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
comment|/* find our hostname, and use it as the instance */
if|if
condition|(
name|k_gethostname
argument_list|(
name|k_instance
argument_list|,
name|INST_SZ
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"gethostname"
argument_list|)
expr_stmt|;
comment|/*      * Yes this looks backwards but it has to be this way to enable a      * smooth migration to the new port 88.      */
block|{
name|int
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|a
decl_stmt|;
name|p1
operator|=
name|k_getportbyname
argument_list|(
literal|"kerberos-iv"
argument_list|,
literal|"udp"
argument_list|,
name|htons
argument_list|(
literal|750
argument_list|)
argument_list|)
expr_stmt|;
name|p2
operator|=
name|k_getportbyname
argument_list|(
literal|"kerberos-sec"
argument_list|,
literal|"udp"
argument_list|,
name|htons
argument_list|(
literal|88
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Either define kerberos-iv/udp as 750\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      and kerberos-sec/udp as 88\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"or the other way around!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|nfds
operator|=
name|k_get_all_addrs
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfds
operator|<
literal|0
condition|)
block|{
name|struct
name|in_addr
name|any
decl_stmt|;
name|any
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not get local addresses, "
literal|"binding to INADDR_ANY\n"
argument_list|)
expr_stmt|;
name|nfds
operator|=
literal|1
expr_stmt|;
name|a
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
operator|*
name|nfds
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|a
argument_list|,
operator|&
name|any
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nfds
operator|*=
literal|4
expr_stmt|;
name|fds
operator|=
operator|(
expr|struct
name|descr
operator|*
operator|)
name|malloc
argument_list|(
name|nfds
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|descr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfds
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|mksocket
argument_list|(
name|fds
operator|+
literal|4
operator|*
name|i
operator|+
literal|0
argument_list|,
name|a
index|[
name|i
index|]
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|"kerberos-iv"
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|mksocket
argument_list|(
name|fds
operator|+
literal|4
operator|*
name|i
operator|+
literal|1
argument_list|,
name|a
index|[
name|i
index|]
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|"kerberos-sec"
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|mksocket
argument_list|(
name|fds
operator|+
literal|4
operator|*
name|i
operator|+
literal|2
argument_list|,
name|a
index|[
name|i
index|]
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|"kerberos-iv"
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|mksocket
argument_list|(
name|fds
operator|+
literal|4
operator|*
name|i
operator|+
literal|3
argument_list|,
name|a
index|[
name|i
index|]
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|"kerberos-sec"
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
comment|/* do all the database and cache inits */
if|if
condition|(
operator|(
name|n
operator|=
name|kerb_init
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|mflag
condition|)
block|{
name|printf
argument_list|(
literal|"Kerberos db and cache init "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"failed = %d ...exiting\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Kerberos db and cache init failed = %d ...exiting"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|hang
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Make sure database isn't stale */
name|check_db_age
argument_list|()
expr_stmt|;
comment|/* setup master key */
if|if
condition|(
name|kdb_get_master_key
argument_list|(
name|mflag
argument_list|,
operator|&
name|master_key
argument_list|,
name|master_key_schedule
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"kerberos: couldn't get master key.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|kerror
operator|=
name|kdb_verify_master_key
argument_list|(
operator|&
name|master_key
argument_list|,
name|master_key_schedule
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerror
operator|<
literal|0
condition|)
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Can't verify master key."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|master_key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|master_key
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|master_key_schedule
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|master_key_schedule
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|master_key_version
operator|=
operator|(
name|u_char
operator|)
name|kerror
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nCurrent Kerberos master key version is %d\n"
argument_list|,
name|master_key_version
argument_list|)
expr_stmt|;
name|des_init_random_number_generator
argument_list|(
operator|&
name|master_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rflag
condition|)
block|{
comment|/* Look up our local realm */
name|krb_get_lrealm
argument_list|(
name|local_realm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Local realm: %s\n"
argument_list|,
name|local_realm
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_tgtkey
argument_list|(
name|local_realm
argument_list|)
condition|)
block|{
comment|/* Ticket granting service unknown */
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Ticket granting ticket service unknown"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Ticket granting ticket service unknown\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mflag
condition|)
block|{
if|if
condition|(
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Kerberos started, PID=%d\n"
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|setup_disc
argument_list|()
expr_stmt|;
block|}
name|klog
argument_list|(
name|L_ALL_REQ
argument_list|,
literal|"Starting Kerberos for %s (kvno %d)"
argument_list|,
name|local_realm
argument_list|,
name|master_key_version
argument_list|)
expr_stmt|;
comment|/* receive loop */
name|loop
argument_list|(
name|fds
argument_list|,
name|nfds
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|loop
parameter_list|(
name|struct
name|descr
modifier|*
name|fds
parameter_list|,
name|int
name|nfds
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ret
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|maxfd
init|=
literal|0
decl_stmt|;
name|struct
name|descr
modifier|*
name|n
decl_stmt|,
modifier|*
name|minfree
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|maxfd
operator|=
literal|0
expr_stmt|;
name|minfree
operator|=
name|NULL
expr_stmt|;
comment|/* Remove expired TCP sockets, and add all other  	   to the set we are selecting on */
for|for
control|(
name|n
operator|=
name|fds
init|;
name|n
operator|<
name|fds
operator|+
name|nfds
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|->
name|s
operator|>=
literal|0
operator|&&
name|n
operator|->
name|timeout
operator|&&
name|tv
operator|.
name|tv_sec
operator|>
name|n
operator|->
name|timeout
condition|)
block|{
name|kerb_err_reply
argument_list|(
name|n
operator|->
name|s
argument_list|,
name|NULL
argument_list|,
name|KERB_ERR_TIMEOUT
argument_list|,
literal|"Timeout"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|n
operator|->
name|s
argument_list|)
expr_stmt|;
name|n
operator|->
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|->
name|s
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|minfree
operator|==
name|NULL
condition|)
name|minfree
operator|=
name|n
expr_stmt|;
continue|continue;
block|}
name|FD_SET
argument_list|(
name|n
operator|->
name|s
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|maxfd
operator|=
name|max
argument_list|(
name|maxfd
argument_list|,
name|n
operator|->
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* add more space for sockets */
if|if
condition|(
name|minfree
operator|==
name|NULL
condition|)
block|{
name|int
name|i
init|=
name|nfds
decl_stmt|;
name|struct
name|descr
modifier|*
name|new
decl_stmt|;
name|nfds
operator|*=
literal|2
expr_stmt|;
name|new
operator|=
name|realloc
argument_list|(
name|fds
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|descr
argument_list|)
operator|*
name|nfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|fds
operator|=
name|new
expr_stmt|;
name|minfree
operator|=
name|fds
operator|+
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nfds
condition|;
name|i
operator|++
control|)
name|fds
index|[
name|i
index|]
operator|.
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|select
argument_list|(
name|maxfd
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|fds
init|;
name|n
operator|<
name|fds
operator|+
name|nfds
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|->
name|s
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|n
operator|->
name|s
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|SOCK_STREAM
operator|&&
name|n
operator|->
name|timeout
operator|==
literal|0
condition|)
block|{
comment|/* add accepted socket to list of sockets we are                        selecting on */
name|int
name|s
init|=
name|accept
argument_list|(
name|n
operator|->
name|s
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|minfree
operator|==
name|NULL
condition|)
block|{
name|kerb_err_reply
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|KFAILURE
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|minfree
operator|->
name|s
operator|=
name|s
expr_stmt|;
name|minfree
operator|->
name|type
operator|=
name|SOCK_STREAM
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|minfree
operator|->
name|timeout
operator|=
name|tv
operator|.
name|tv_sec
operator|+
literal|4
expr_stmt|;
comment|/* XXX */
block|}
block|}
else|else
block|{
name|int
name|b
decl_stmt|;
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|int
name|fromlen
init|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|b
operator|=
name|recvfrom
argument_list|(
name|n
operator|->
name|s
argument_list|,
name|n
operator|->
name|buf
operator|.
name|dat
operator|+
name|n
operator|->
name|buf
operator|.
name|length
argument_list|,
name|MAX_PKT_LEN
operator|-
name|n
operator|->
name|buf
operator|.
name|length
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|SOCK_STREAM
condition|)
block|{
name|close
argument_list|(
name|n
operator|->
name|s
argument_list|)
expr_stmt|;
name|n
operator|->
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|n
operator|->
name|buf
operator|.
name|length
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|n
operator|->
name|buf
operator|.
name|length
operator|+=
name|b
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|SOCK_STREAM
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|buf
operator|.
name|length
operator|>=
literal|4
operator|&&
name|n
operator|->
name|buf
operator|.
name|dat
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* if this is a new type of packet (with                                the length attached to the head of the                                packet), and there is no more data to                                be read, fake an old packet, so the                                code below will work */
name|u_int32_t
name|len
decl_stmt|;
name|krb_get_int
argument_list|(
name|n
operator|->
name|buf
operator|.
name|dat
argument_list|,
operator|&
name|len
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|buf
operator|.
name|length
operator|==
name|len
operator|+
literal|4
condition|)
block|{
name|memmove
argument_list|(
name|n
operator|->
name|buf
operator|.
name|dat
argument_list|,
name|n
operator|->
name|buf
operator|.
name|dat
operator|+
literal|4
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
comment|/* handle request if there are  			       no more bytes to read */
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|getpeername
argument_list|(
name|n
operator|->
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
name|kerberos_wrap
argument_list|(
name|n
operator|->
name|s
argument_list|,
operator|&
name|n
operator|->
name|buf
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
name|n
operator|->
name|buf
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|n
operator|->
name|s
argument_list|)
expr_stmt|;
name|n
operator|->
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* udp packets are atomic */
name|kerberos_wrap
argument_list|(
name|n
operator|->
name|s
argument_list|,
operator|&
name|n
operator|->
name|buf
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
name|n
operator|->
name|buf
operator|.
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

end_unit

