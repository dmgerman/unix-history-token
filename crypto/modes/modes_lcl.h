begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ====================================================================  * Copyright (c) 2010 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use is governed by OpenSSL license.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<openssl/modes.h>
end_include

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN64
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
end_if

begin_typedef
typedef|typedef
name|__int64
name|i64
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|__int64
name|u64
typedef|;
end_typedef

begin_define
define|#
directive|define
name|U64
parameter_list|(
name|C
parameter_list|)
value|C##UI64
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__arch64__
argument_list|)
end_elif

begin_typedef
typedef|typedef
name|long
name|i64
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|u64
typedef|;
end_typedef

begin_define
define|#
directive|define
name|U64
parameter_list|(
name|C
parameter_list|)
value|C##UL
end_define

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|long
name|long
name|i64
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|long
name|u64
typedef|;
end_typedef

begin_define
define|#
directive|define
name|U64
parameter_list|(
name|C
parameter_list|)
value|C##ULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|unsigned
name|int
name|u32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|u8
typedef|;
end_typedef

begin_define
define|#
directive|define
name|STRICT_ALIGNMENT
value|1
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PEDANTIC
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__x86_64
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|_M_IX86
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_AMD64
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_X64
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__aarch64__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__s390__
argument_list|)
operator|||
name|defined
argument_list|(
name|__s390x__
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|STRICT_ALIGNMENT
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PEDANTIC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_ASM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_INLINE_ASM
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|2
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__x86_64
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
end_if

begin_define
define|#
directive|define
name|BSWAP8
parameter_list|(
name|x
parameter_list|)
value|({ u64 ret_=(x);                   \                         asm ("bswapq %0"                \                         : "+r"(ret_));   ret_;          })
end_define

begin_define
define|#
directive|define
name|BSWAP4
parameter_list|(
name|x
parameter_list|)
value|({ u32 ret_=(x);                   \                         asm ("bswapl %0"                \                         : "+r"(ret_));   ret_;          })
end_define

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|I386_ONLY
argument_list|)
end_elif

begin_define
define|#
directive|define
name|BSWAP8
parameter_list|(
name|x
parameter_list|)
value|({ u32 lo_=(u64)(x)>>32,hi_=(x);   \                         asm ("bswapl %0; bswapl %1"     \                         : "+r"(hi_),"+r"(lo_));         \                         (u64)hi_<<32|lo_;               })
end_define

begin_define
define|#
directive|define
name|BSWAP4
parameter_list|(
name|x
parameter_list|)
value|({ u32 ret_=(x);                   \                         asm ("bswapl %0"                \                         : "+r"(ret_));   ret_;          })
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__aarch64__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|BSWAP8
parameter_list|(
name|x
parameter_list|)
value|({ u64 ret_;                       \                         asm ("rev %0,%1"                \                         : "=r"(ret_) : "r"(x)); ret_;   })
end_define

begin_define
define|#
directive|define
name|BSWAP4
parameter_list|(
name|x
parameter_list|)
value|({ u32 ret_;                       \                         asm ("rev %w0,%w1"              \                         : "=r"(ret_) : "r"(x)); ret_;   })
end_define

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|__arm__
argument_list|)
operator|||
name|defined
argument_list|(
name|__arm
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|STRICT_ALIGNMENT
argument_list|)
end_elif

begin_define
define|#
directive|define
name|BSWAP8
parameter_list|(
name|x
parameter_list|)
value|({ u32 lo_=(u64)(x)>>32,hi_=(x);   \                         asm ("rev %0,%0; rev %1,%1"     \                         : "+r"(hi_),"+r"(lo_));         \                         (u64)hi_<<32|lo_;               })
end_define

begin_define
define|#
directive|define
name|BSWAP4
parameter_list|(
name|x
parameter_list|)
value|({ u32 ret_;                       \                         asm ("rev %0,%1"                \                         : "=r"(ret_) : "r"((u32)(x)));  \                         ret_;                           })
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_elif

begin_if
if|#
directive|if
name|_MSC_VER
operator|>=
literal|1300
end_if

begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|_byteswap_uint64
name|,
name|_byteswap_ulong
name|)
end_pragma

begin_define
define|#
directive|define
name|BSWAP8
parameter_list|(
name|x
parameter_list|)
value|_byteswap_uint64((u64)(x))
end_define

begin_define
define|#
directive|define
name|BSWAP4
parameter_list|(
name|x
parameter_list|)
value|_byteswap_ulong((u32)(x))
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_M_IX86
argument_list|)
end_elif

begin_function
name|__inline
name|u32
name|_bswap4
parameter_list|(
name|u32
name|val
parameter_list|)
block|{
name|_asm
name|mov
name|eax
decl_stmt|,
name|val
name|_asm
name|bswap
name|eax
block|}
end_function

begin_define
define|#
directive|define
name|BSWAP4
parameter_list|(
name|x
parameter_list|)
value|_bswap4(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSWAP4
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|STRICT_ALIGNMENT
argument_list|)
end_if

begin_define
define|#
directive|define
name|GETU32
parameter_list|(
name|p
parameter_list|)
value|BSWAP4(*(const u32 *)(p))
end_define

begin_define
define|#
directive|define
name|PUTU32
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|*(u32 *)(p) = BSWAP4(v)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GETU32
parameter_list|(
name|p
parameter_list|)
value|((u32)(p)[0]<<24|(u32)(p)[1]<<16|(u32)(p)[2]<<8|(u32)(p)[3])
end_define

begin_define
define|#
directive|define
name|PUTU32
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|((p)[0]=(u8)((v)>>24),(p)[1]=(u8)((v)>>16),(p)[2]=(u8)((v)>>8),(p)[3]=(u8)(v))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*- GCM definitions */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|u64
name|hi
decl_stmt|,
name|lo
decl_stmt|;
block|}
name|u128
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|TABLE_BITS
end_ifdef

begin_undef
undef|#
directive|undef
name|TABLE_BITS
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Even though permitted values for TABLE_BITS are 8, 4 and 1, it should  * never be set to 8 [or 1]. For further information see gcm128.c.  */
end_comment

begin_define
define|#
directive|define
name|TABLE_BITS
value|4
end_define

begin_struct
struct|struct
name|gcm128_context
block|{
comment|/* Following 6 names follow names in GCM specification */
union|union
block|{
name|u64
name|u
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|d
index|[
literal|4
index|]
decl_stmt|;
name|u8
name|c
index|[
literal|16
index|]
decl_stmt|;
name|size_t
name|t
index|[
literal|16
operator|/
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
index|]
decl_stmt|;
block|}
name|Yi
union|,
name|EKi
union|,
name|EK0
union|,
name|len
union|,
name|Xi
union|,
name|H
union|;
comment|/*      * Relative position of Xi, H and pre-computed Htable is used in some      * assembler modules, i.e. don't change the order!      */
if|#
directive|if
name|TABLE_BITS
operator|==
literal|8
name|u128
name|Htable
index|[
literal|256
index|]
decl_stmt|;
else|#
directive|else
name|u128
name|Htable
index|[
literal|16
index|]
decl_stmt|;
name|void
function_decl|(
modifier|*
name|gmult
function_decl|)
parameter_list|(
name|u64
name|Xi
index|[
literal|2
index|]
parameter_list|,
specifier|const
name|u128
name|Htable
index|[
literal|16
index|]
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|ghash
function_decl|)
parameter_list|(
name|u64
name|Xi
index|[
literal|2
index|]
parameter_list|,
specifier|const
name|u128
name|Htable
index|[
literal|16
index|]
parameter_list|,
specifier|const
name|u8
modifier|*
name|inp
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
endif|#
directive|endif
name|unsigned
name|int
name|mres
decl_stmt|,
name|ares
decl_stmt|;
name|block128_f
name|block
decl_stmt|;
name|void
modifier|*
name|key
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|xts128_context
block|{
name|void
modifier|*
name|key1
decl_stmt|,
modifier|*
name|key2
decl_stmt|;
name|block128_f
name|block1
decl_stmt|,
name|block2
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ccm128_context
block|{
union|union
block|{
name|u64
name|u
index|[
literal|2
index|]
decl_stmt|;
name|u8
name|c
index|[
literal|16
index|]
decl_stmt|;
block|}
name|nonce
union|,
name|cmac
union|;
name|u64
name|blocks
decl_stmt|;
name|block128_f
name|block
decl_stmt|;
name|void
modifier|*
name|key
decl_stmt|;
block|}
struct|;
end_struct

end_unit

