begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/engine/hw_ncipher.c -*- mode: C; c-file-style: "eay" -*- */
end_comment

begin_comment
comment|/* Written by Richard Levitte (richard@levitte.org), Geoff Thorpe  * (geoff@geoffthorpe.net) and Dr Stephen N Henson (shenson@bigfoot.com)  * for the OpenSSL project 2000.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1999-2001 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_include
include|#
directive|include
file|<openssl/dso.h>
end_include

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ui.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HW
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HW_NCIPHER
end_ifndef

begin_comment
comment|/* Attribution notice: nCipher have said several times that it's OK for  * us to implement a general interface to their boxes, and recently declared  * their HWCryptoHook to be public, and therefore available for us to use.  * Thanks, nCipher.  *  * The hwcryptohook.h included here is from May 2000.  * [Richard Levitte]  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FLAT_INC
end_ifdef

begin_include
include|#
directive|include
file|"hwcryptohook.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"vendor_defns/hwcryptohook.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HWCRHK_LIB_NAME
value|"hwcrhk engine"
end_define

begin_include
include|#
directive|include
file|"hw_ncipher_err.c"
end_include

begin_function_decl
specifier|static
name|int
name|hwcrhk_destroy
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwcrhk_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwcrhk_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwcrhk_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions to handle mutexes if have dynamic locks */
end_comment

begin_function_decl
specifier|static
name|int
name|hwcrhk_mutex_init
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwcrhk_mutex_lock
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hwcrhk_mutex_unlock
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hwcrhk_mutex_destroy
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* This is a HACK which will disappear in 0.9.8 */
end_comment

begin_comment
comment|/* Functions to handle mutexes if only have static locks */
end_comment

begin_function_decl
specifier|static
name|int
name|hwcrhk_static_mutex_init
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|m
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwcrhk_static_mutex_lock
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hwcrhk_static_mutex_unlock
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hwcrhk_static_mutex_destroy
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BIGNUM stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|hwcrhk_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_comment
comment|/* RSA stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|hwcrhk_rsa_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|I
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function is aliased to mod_exp (with the mont stuff dropped). */
end_comment

begin_function_decl
specifier|static
name|int
name|hwcrhk_mod_exp_mont
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_comment
comment|/* DH stuff */
end_comment

begin_comment
comment|/* This function is alised to mod_exp (with the DH and mont dropped). */
end_comment

begin_function_decl
specifier|static
name|int
name|hwcrhk_mod_exp_dh
parameter_list|(
specifier|const
name|DH
modifier|*
name|dh
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAND stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|hwcrhk_rand_bytes
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwcrhk_rand_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* KM stuff */
end_comment

begin_function_decl
specifier|static
name|EVP_PKEY
modifier|*
name|hwcrhk_load_privkey
parameter_list|(
name|ENGINE
modifier|*
name|eng
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|EVP_PKEY
modifier|*
name|hwcrhk_load_pubkey
parameter_list|(
name|ENGINE
modifier|*
name|eng
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hwcrhk_ex_free
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|,
name|int
name|ind
parameter_list|,
name|long
name|argl
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Interaction stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|hwcrhk_insert_card
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt_info
parameter_list|,
specifier|const
name|char
modifier|*
name|wrong_info
parameter_list|,
name|HWCryptoHook_PassphraseContext
modifier|*
name|ppctx
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
name|cactx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwcrhk_get_pass
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt_info
parameter_list|,
name|int
modifier|*
name|len_io
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|HWCryptoHook_PassphraseContext
modifier|*
name|ppctx
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
name|cactx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hwcrhk_log_message
parameter_list|(
name|void
modifier|*
name|logstr
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The definitions for control commands specific to this engine */
end_comment

begin_define
define|#
directive|define
name|HWCRHK_CMD_SO_PATH
value|ENGINE_CMD_BASE
end_define

begin_define
define|#
directive|define
name|HWCRHK_CMD_FORK_CHECK
value|(ENGINE_CMD_BASE + 1)
end_define

begin_define
define|#
directive|define
name|HWCRHK_CMD_THREAD_LOCKING
value|(ENGINE_CMD_BASE + 2)
end_define

begin_define
define|#
directive|define
name|HWCRHK_CMD_SET_USER_INTERFACE
value|(ENGINE_CMD_BASE + 3)
end_define

begin_define
define|#
directive|define
name|HWCRHK_CMD_SET_CALLBACK_DATA
value|(ENGINE_CMD_BASE + 4)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|ENGINE_CMD_DEFN
name|hwcrhk_cmd_defns
index|[]
init|=
block|{
block|{
name|HWCRHK_CMD_SO_PATH
block|,
literal|"SO_PATH"
block|,
literal|"Specifies the path to the 'hwcrhk' shared library"
block|,
name|ENGINE_CMD_FLAG_STRING
block|}
block|,
block|{
name|HWCRHK_CMD_FORK_CHECK
block|,
literal|"FORK_CHECK"
block|,
literal|"Turns fork() checking on or off (boolean)"
block|,
name|ENGINE_CMD_FLAG_NUMERIC
block|}
block|,
block|{
name|HWCRHK_CMD_THREAD_LOCKING
block|,
literal|"THREAD_LOCKING"
block|,
literal|"Turns thread-safe locking on or off (boolean)"
block|,
name|ENGINE_CMD_FLAG_NUMERIC
block|}
block|,
block|{
name|HWCRHK_CMD_SET_USER_INTERFACE
block|,
literal|"SET_USER_INTERFACE"
block|,
literal|"Set the global user interface (internal)"
block|,
name|ENGINE_CMD_FLAG_INTERNAL
block|}
block|,
block|{
name|HWCRHK_CMD_SET_CALLBACK_DATA
block|,
literal|"SET_CALLBACK_DATA"
block|,
literal|"Set the global user interface extra data (internal)"
block|,
name|ENGINE_CMD_FLAG_INTERNAL
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_comment
comment|/* Our internal RSA_METHOD that we provide pointers to */
end_comment

begin_decl_stmt
specifier|static
name|RSA_METHOD
name|hwcrhk_rsa
init|=
block|{
literal|"nCipher RSA method"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|hwcrhk_rsa_mod_exp
block|,
name|hwcrhk_mod_exp_mont
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_comment
comment|/* Our internal DH_METHOD that we provide pointers to */
end_comment

begin_decl_stmt
specifier|static
name|DH_METHOD
name|hwcrhk_dh
init|=
block|{
literal|"nCipher DH method"
block|,
name|NULL
block|,
name|NULL
block|,
name|hwcrhk_mod_exp_dh
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|RAND_METHOD
name|hwcrhk_rand
init|=
block|{
comment|/* "nCipher RAND method", */
name|NULL
block|,
name|hwcrhk_rand_bytes
block|,
name|NULL
block|,
name|NULL
block|,
name|hwcrhk_rand_bytes
block|,
name|hwcrhk_rand_status
block|, 	}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Constants used when creating the ENGINE */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_hwcrhk_id
init|=
literal|"chil"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_hwcrhk_name
init|=
literal|"nCipher hardware engine support"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal stuff for HWCryptoHook */
end_comment

begin_comment
comment|/* Some structures needed for proper use of thread locks */
end_comment

begin_comment
comment|/* hwcryptohook.h has some typedefs that turn struct HWCryptoHook_MutexValue    into HWCryptoHook_Mutex */
end_comment

begin_struct
struct|struct
name|HWCryptoHook_MutexValue
block|{
name|int
name|lockid
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* hwcryptohook.h has some typedefs that turn    struct HWCryptoHook_PassphraseContextValue    into HWCryptoHook_PassphraseContext */
end_comment

begin_struct
struct|struct
name|HWCryptoHook_PassphraseContextValue
block|{
name|UI_METHOD
modifier|*
name|ui_method
decl_stmt|;
name|void
modifier|*
name|callback_data
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* hwcryptohook.h has some typedefs that turn    struct HWCryptoHook_CallerContextValue    into HWCryptoHook_CallerContext */
end_comment

begin_struct
struct|struct
name|HWCryptoHook_CallerContextValue
block|{
name|pem_password_cb
modifier|*
name|password_callback
decl_stmt|;
comment|/* Deprecated!  Only present for                                                backward compatibility! */
name|UI_METHOD
modifier|*
name|ui_method
decl_stmt|;
name|void
modifier|*
name|callback_data
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The MPI structure in HWCryptoHook is pretty compatible with OpenSSL    BIGNUM's, so lets define a couple of conversion macros */
end_comment

begin_define
define|#
directive|define
name|BN2MPI
parameter_list|(
name|mp
parameter_list|,
name|bn
parameter_list|)
define|\
value|{mp.size = bn->top * sizeof(BN_ULONG); mp.buf = (unsigned char *)bn->d;}
end_define

begin_define
define|#
directive|define
name|MPI2BN
parameter_list|(
name|bn
parameter_list|,
name|mp
parameter_list|)
define|\
value|{mp.size = bn->dmax * sizeof(BN_ULONG); mp.buf = (unsigned char *)bn->d;}
end_define

begin_decl_stmt
specifier|static
name|BIO
modifier|*
name|logstream
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|disable_mutex_callbacks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* One might wonder why these are needed, since one can pass down at least    a UI_METHOD and a pointer to callback data to the key-loading functions.    The thing is that the ModExp and RSAImmed functions can load keys as well,    if the data they get is in a special, nCipher-defined format (hint: if you    look at the private exponent of the RSA data as a string, you'll see this    string: "nCipher KM tool key id", followed by some bytes, followed a key    identity string, followed by more bytes.  This happens when you use "embed"    keys instead of "hwcrhk" keys).  Unfortunately, those functions do not take    any passphrase or caller context, and our functions can't really take any    callback data either.  Still, the "insert_card" and "get_passphrase"    callbacks may be called down the line, and will need to know what user    interface callbacks to call, and having callback data from the application    may be a nice thing as well, so we need to keep track of that globally. */
end_comment

begin_decl_stmt
specifier|static
name|HWCryptoHook_CallerContext
name|password_context
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stuff to pass to the HWCryptoHook library */
end_comment

begin_decl_stmt
specifier|static
name|HWCryptoHook_InitInfo
name|hwcrhk_globals
init|=
block|{
name|HWCryptoHook_InitFlags_SimpleForkCheck
block|,
comment|/* Flags */
operator|&
name|logstream
block|,
comment|/* logstream */
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
block|,
comment|/* limbsize */
literal|0
block|,
comment|/* mslimb first: false for BNs */
operator|-
literal|1
block|,
comment|/* msbyte first: use native */
literal|0
block|,
comment|/* Max mutexes, 0 = no small limit */
literal|0
block|,
comment|/* Max simultaneous, 0 = default */
comment|/* The next few are mutex stuff: we write wrapper functions 	   around the OS mutex functions.  We initialise them to 0 	   here, and change that to actual function pointers in hwcrhk_init() 	   if dynamic locks are supported (that is, if the application 	   programmer has made sure of setting up callbacks bafore starting 	   this engine) *and* if disable_mutex_callbacks hasn't been set by 	   a call to ENGINE_ctrl(ENGINE_CTRL_CHIL_NO_LOCKING). */
sizeof|sizeof
argument_list|(
name|HWCryptoHook_Mutex
argument_list|)
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* The next few are condvar stuff: we write wrapper functions 	   round the OS functions.  Currently not implemented and not 	   and absolute necessity even in threaded programs, therefore 	   0'ed.  Will hopefully be implemented some day, since it 	   enhances the efficiency of HWCryptoHook.  */
literal|0
block|,
comment|/* sizeof(HWCryptoHook_CondVar), */
literal|0
block|,
comment|/* hwcrhk_cv_init, */
literal|0
block|,
comment|/* hwcrhk_cv_wait, */
literal|0
block|,
comment|/* hwcrhk_cv_signal, */
literal|0
block|,
comment|/* hwcrhk_cv_broadcast, */
literal|0
block|,
comment|/* hwcrhk_cv_destroy, */
name|hwcrhk_get_pass
block|,
comment|/* pass phrase */
name|hwcrhk_insert_card
block|,
comment|/* insert a card */
name|hwcrhk_log_message
comment|/* Log message */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Now, to our own code */
end_comment

begin_comment
comment|/* This internal function is used by ENGINE_ncipher() and possibly by the  * "dynamic" ENGINE support too */
end_comment

begin_function
specifier|static
name|int
name|bind_helper
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
specifier|const
name|RSA_METHOD
modifier|*
name|meth1
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
specifier|const
name|DH_METHOD
modifier|*
name|meth2
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ENGINE_set_id
argument_list|(
name|e
argument_list|,
name|engine_hwcrhk_id
argument_list|)
operator|||
operator|!
name|ENGINE_set_name
argument_list|(
name|e
argument_list|,
name|engine_hwcrhk_name
argument_list|)
operator|||
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
operator|!
name|ENGINE_set_RSA
argument_list|(
name|e
argument_list|,
operator|&
name|hwcrhk_rsa
argument_list|)
operator|||
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
operator|!
name|ENGINE_set_DH
argument_list|(
name|e
argument_list|,
operator|&
name|hwcrhk_dh
argument_list|)
operator|||
endif|#
directive|endif
operator|!
name|ENGINE_set_RAND
argument_list|(
name|e
argument_list|,
operator|&
name|hwcrhk_rand
argument_list|)
operator|||
operator|!
name|ENGINE_set_destroy_function
argument_list|(
name|e
argument_list|,
name|hwcrhk_destroy
argument_list|)
operator|||
operator|!
name|ENGINE_set_init_function
argument_list|(
name|e
argument_list|,
name|hwcrhk_init
argument_list|)
operator|||
operator|!
name|ENGINE_set_finish_function
argument_list|(
name|e
argument_list|,
name|hwcrhk_finish
argument_list|)
operator|||
operator|!
name|ENGINE_set_ctrl_function
argument_list|(
name|e
argument_list|,
name|hwcrhk_ctrl
argument_list|)
operator|||
operator|!
name|ENGINE_set_load_privkey_function
argument_list|(
name|e
argument_list|,
name|hwcrhk_load_privkey
argument_list|)
operator|||
operator|!
name|ENGINE_set_load_pubkey_function
argument_list|(
name|e
argument_list|,
name|hwcrhk_load_pubkey
argument_list|)
operator|||
operator|!
name|ENGINE_set_cmd_defns
argument_list|(
name|e
argument_list|,
name|hwcrhk_cmd_defns
argument_list|)
condition|)
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
comment|/* We know that the "PKCS1_SSLeay()" functions hook properly 	 * to the cswift-specific mod_exp and mod_exp_crt so we use 	 * those functions. NB: We don't use ENGINE_openssl() or 	 * anything "more generic" because something like the RSAref 	 * code may not hook properly, and if you own one of these 	 * cards then you have the right to do RSA operations on it 	 * anyway! */
name|meth1
operator|=
name|RSA_PKCS1_SSLeay
argument_list|()
expr_stmt|;
name|hwcrhk_rsa
operator|.
name|rsa_pub_enc
operator|=
name|meth1
operator|->
name|rsa_pub_enc
expr_stmt|;
name|hwcrhk_rsa
operator|.
name|rsa_pub_dec
operator|=
name|meth1
operator|->
name|rsa_pub_dec
expr_stmt|;
name|hwcrhk_rsa
operator|.
name|rsa_priv_enc
operator|=
name|meth1
operator|->
name|rsa_priv_enc
expr_stmt|;
name|hwcrhk_rsa
operator|.
name|rsa_priv_dec
operator|=
name|meth1
operator|->
name|rsa_priv_dec
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
comment|/* Much the same for Diffie-Hellman */
name|meth2
operator|=
name|DH_OpenSSL
argument_list|()
expr_stmt|;
name|hwcrhk_dh
operator|.
name|generate_key
operator|=
name|meth2
operator|->
name|generate_key
expr_stmt|;
name|hwcrhk_dh
operator|.
name|compute_key
operator|=
name|meth2
operator|->
name|compute_key
expr_stmt|;
endif|#
directive|endif
comment|/* Ensure the hwcrhk error handling is set up */
name|ERR_load_HWCRHK_strings
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ENGINE_DYNAMIC_SUPPORT
end_ifndef

begin_function
specifier|static
name|ENGINE
modifier|*
name|engine_ncipher
parameter_list|(
name|void
parameter_list|)
block|{
name|ENGINE
modifier|*
name|ret
init|=
name|ENGINE_new
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|bind_helper
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ENGINE_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|ENGINE_load_chil
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Copied from eng_[openssl|dyn].c */
name|ENGINE
modifier|*
name|toadd
init|=
name|engine_ncipher
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|toadd
condition|)
return|return;
name|ENGINE_add
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ENGINE_free
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is a process-global DSO handle used for loading and unloading  * the HWCryptoHook library. NB: This is only set (or unset) during an  * init() or finish() call (reference counts permitting) and they're  * operating with global locks, so this should be thread-safe  * implicitly. */
end_comment

begin_decl_stmt
specifier|static
name|DSO
modifier|*
name|hwcrhk_dso
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HWCryptoHook_ContextHandle
name|hwcrhk_context
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|hndidx_rsa
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index for KM handle.  Not really used yet. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These are the function pointers that are (un)set when the library has  * successfully (un)loaded. */
end_comment

begin_decl_stmt
specifier|static
name|HWCryptoHook_Init_t
modifier|*
name|p_hwcrhk_Init
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HWCryptoHook_Finish_t
modifier|*
name|p_hwcrhk_Finish
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HWCryptoHook_ModExp_t
modifier|*
name|p_hwcrhk_ModExp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_decl_stmt
specifier|static
name|HWCryptoHook_RSA_t
modifier|*
name|p_hwcrhk_RSA
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|HWCryptoHook_RandomBytes_t
modifier|*
name|p_hwcrhk_RandomBytes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_decl_stmt
specifier|static
name|HWCryptoHook_RSALoadKey_t
modifier|*
name|p_hwcrhk_RSALoadKey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HWCryptoHook_RSAGetPublicKey_t
modifier|*
name|p_hwcrhk_RSAGetPublicKey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HWCryptoHook_RSAUnloadKey_t
modifier|*
name|p_hwcrhk_RSAUnloadKey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|HWCryptoHook_ModExpCRT_t
modifier|*
name|p_hwcrhk_ModExpCRT
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used in the DSO operations. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|HWCRHK_LIBNAME
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|free_HWCRHK_LIBNAME
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|HWCRHK_LIBNAME
condition|)
name|OPENSSL_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|HWCRHK_LIBNAME
argument_list|)
expr_stmt|;
name|HWCRHK_LIBNAME
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_HWCRHK_LIBNAME
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|HWCRHK_LIBNAME
condition|)
return|return
name|HWCRHK_LIBNAME
return|;
return|return
literal|"nfhwcrhk"
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|set_HWCRHK_LIBNAME
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|free_HWCRHK_LIBNAME
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|HWCRHK_LIBNAME
operator|=
name|BUF_strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_Init
init|=
literal|"HWCryptoHook_Init"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_Finish
init|=
literal|"HWCryptoHook_Finish"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_ModExp
init|=
literal|"HWCryptoHook_ModExp"
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_RSA
init|=
literal|"HWCryptoHook_RSA"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_RandomBytes
init|=
literal|"HWCryptoHook_RandomBytes"
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_RSALoadKey
init|=
literal|"HWCryptoHook_RSALoadKey"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_RSAGetPublicKey
init|=
literal|"HWCryptoHook_RSAGetPublicKey"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_RSAUnloadKey
init|=
literal|"HWCryptoHook_RSAUnloadKey"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_ModExpCRT
init|=
literal|"HWCryptoHook_ModExpCRT"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* HWCryptoHook library functions and mechanics - these are used by the  * higher-level functions further down. NB: As and where there's no  * error checking, take a look lower down where these functions are  * called, the checking and error handling is probably down there. */
end_comment

begin_comment
comment|/* utility function to obtain a context */
end_comment

begin_function
specifier|static
name|int
name|get_context
parameter_list|(
name|HWCryptoHook_ContextHandle
modifier|*
name|hac
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
name|cac
parameter_list|)
block|{
name|char
name|tempbuf
index|[
literal|1024
index|]
decl_stmt|;
name|HWCryptoHook_ErrMsgBuf
name|rmsg
decl_stmt|;
name|rmsg
operator|.
name|buf
operator|=
name|tempbuf
expr_stmt|;
name|rmsg
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
operator|*
name|hac
operator|=
name|p_hwcrhk_Init
argument_list|(
operator|&
name|hwcrhk_globals
argument_list|,
sizeof|sizeof
argument_list|(
name|hwcrhk_globals
argument_list|)
argument_list|,
operator|&
name|rmsg
argument_list|,
name|cac
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|hac
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* similarly to release one. */
end_comment

begin_function
specifier|static
name|void
name|release_context
parameter_list|(
name|HWCryptoHook_ContextHandle
name|hac
parameter_list|)
block|{
name|p_hwcrhk_Finish
argument_list|(
name|hac
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Destructor (complements the "ENGINE_ncipher()" constructor) */
end_comment

begin_function
specifier|static
name|int
name|hwcrhk_destroy
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|free_HWCRHK_LIBNAME
argument_list|()
expr_stmt|;
name|ERR_unload_HWCRHK_strings
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* (de)initialisation functions. */
end_comment

begin_function
specifier|static
name|int
name|hwcrhk_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|HWCryptoHook_Init_t
modifier|*
name|p1
decl_stmt|;
name|HWCryptoHook_Finish_t
modifier|*
name|p2
decl_stmt|;
name|HWCryptoHook_ModExp_t
modifier|*
name|p3
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|HWCryptoHook_RSA_t
modifier|*
name|p4
decl_stmt|;
name|HWCryptoHook_RSALoadKey_t
modifier|*
name|p5
decl_stmt|;
name|HWCryptoHook_RSAGetPublicKey_t
modifier|*
name|p6
decl_stmt|;
name|HWCryptoHook_RSAUnloadKey_t
modifier|*
name|p7
decl_stmt|;
endif|#
directive|endif
name|HWCryptoHook_RandomBytes_t
modifier|*
name|p8
decl_stmt|;
name|HWCryptoHook_ModExpCRT_t
modifier|*
name|p9
decl_stmt|;
if|if
condition|(
name|hwcrhk_dso
operator|!=
name|NULL
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_INIT
argument_list|,
name|HWCRHK_R_ALREADY_LOADED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Attempt to load libnfhwcrhk.so/nfhwcrhk.dll/whatever. */
name|hwcrhk_dso
operator|=
name|DSO_load
argument_list|(
name|NULL
argument_list|,
name|get_HWCRHK_LIBNAME
argument_list|()
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwcrhk_dso
operator|==
name|NULL
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_INIT
argument_list|,
name|HWCRHK_R_DSO_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|p1
operator|=
operator|(
name|HWCryptoHook_Init_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_Init
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p2
operator|=
operator|(
name|HWCryptoHook_Finish_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_Finish
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p3
operator|=
operator|(
name|HWCryptoHook_ModExp_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_ModExp
argument_list|)
operator|)
operator|||
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
operator|!
operator|(
name|p4
operator|=
operator|(
name|HWCryptoHook_RSA_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_RSA
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p5
operator|=
operator|(
name|HWCryptoHook_RSALoadKey_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_RSALoadKey
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p6
operator|=
operator|(
name|HWCryptoHook_RSAGetPublicKey_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_RSAGetPublicKey
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p7
operator|=
operator|(
name|HWCryptoHook_RSAUnloadKey_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_RSAUnloadKey
argument_list|)
operator|)
operator|||
endif|#
directive|endif
operator|!
operator|(
name|p8
operator|=
operator|(
name|HWCryptoHook_RandomBytes_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_RandomBytes
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p9
operator|=
operator|(
name|HWCryptoHook_ModExpCRT_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_ModExpCRT
argument_list|)
operator|)
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_INIT
argument_list|,
name|HWCRHK_R_DSO_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Copy the pointers */
name|p_hwcrhk_Init
operator|=
name|p1
expr_stmt|;
name|p_hwcrhk_Finish
operator|=
name|p2
expr_stmt|;
name|p_hwcrhk_ModExp
operator|=
name|p3
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|p_hwcrhk_RSA
operator|=
name|p4
expr_stmt|;
name|p_hwcrhk_RSALoadKey
operator|=
name|p5
expr_stmt|;
name|p_hwcrhk_RSAGetPublicKey
operator|=
name|p6
expr_stmt|;
name|p_hwcrhk_RSAUnloadKey
operator|=
name|p7
expr_stmt|;
endif|#
directive|endif
name|p_hwcrhk_RandomBytes
operator|=
name|p8
expr_stmt|;
name|p_hwcrhk_ModExpCRT
operator|=
name|p9
expr_stmt|;
comment|/* Check if the application decided to support dynamic locks, 	   and if it does, use them. */
if|if
condition|(
name|disable_mutex_callbacks
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|CRYPTO_get_dynlock_create_callback
argument_list|()
operator|!=
name|NULL
operator|&&
name|CRYPTO_get_dynlock_lock_callback
argument_list|()
operator|!=
name|NULL
operator|&&
name|CRYPTO_get_dynlock_destroy_callback
argument_list|()
operator|!=
name|NULL
condition|)
block|{
name|hwcrhk_globals
operator|.
name|mutex_init
operator|=
name|hwcrhk_mutex_init
expr_stmt|;
name|hwcrhk_globals
operator|.
name|mutex_acquire
operator|=
name|hwcrhk_mutex_lock
expr_stmt|;
name|hwcrhk_globals
operator|.
name|mutex_release
operator|=
name|hwcrhk_mutex_unlock
expr_stmt|;
name|hwcrhk_globals
operator|.
name|mutex_destroy
operator|=
name|hwcrhk_mutex_destroy
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CRYPTO_get_locking_callback
argument_list|()
operator|!=
name|NULL
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_INIT
argument_list|,
name|HWCRHK_R_DYNAMIC_LOCKING_MISSING
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
literal|"You HAVE to add dynamic locking callbacks via CRYPTO_set_dynlock_{create,lock,destroy}_callback()"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* This is a HACK which will disappear in 0.9.8 */
name|hwcrhk_globals
operator|.
name|maxmutexes
operator|=
literal|1
expr_stmt|;
comment|/* Only have one lock */
name|hwcrhk_globals
operator|.
name|mutex_init
operator|=
name|hwcrhk_static_mutex_init
expr_stmt|;
name|hwcrhk_globals
operator|.
name|mutex_acquire
operator|=
name|hwcrhk_static_mutex_lock
expr_stmt|;
name|hwcrhk_globals
operator|.
name|mutex_release
operator|=
name|hwcrhk_static_mutex_unlock
expr_stmt|;
name|hwcrhk_globals
operator|.
name|mutex_destroy
operator|=
name|hwcrhk_static_mutex_destroy
expr_stmt|;
else|#
directive|else
goto|goto
name|err
goto|;
endif|#
directive|endif
block|}
block|}
comment|/* Try and get a context - if not, we may have a DSO but no 	 * accelerator! */
if|if
condition|(
operator|!
name|get_context
argument_list|(
operator|&
name|hwcrhk_context
argument_list|,
operator|&
name|password_context
argument_list|)
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_INIT
argument_list|,
name|HWCRHK_R_UNIT_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Everything's fine. */
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|hndidx_rsa
operator|==
operator|-
literal|1
condition|)
name|hndidx_rsa
operator|=
name|RSA_get_ex_new_index
argument_list|(
literal|0
argument_list|,
literal|"nFast HWCryptoHook RSA key handle"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|hwcrhk_ex_free
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
name|err
label|:
if|if
condition|(
name|hwcrhk_dso
condition|)
name|DSO_free
argument_list|(
name|hwcrhk_dso
argument_list|)
expr_stmt|;
name|hwcrhk_dso
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_Init
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_Finish
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_ModExp
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|p_hwcrhk_RSA
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RSALoadKey
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RSAGetPublicKey
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RSAUnloadKey
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|p_hwcrhk_ModExpCRT
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RandomBytes
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwcrhk_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|int
name|to_return
init|=
literal|1
decl_stmt|;
name|free_HWCRHK_LIBNAME
argument_list|()
expr_stmt|;
if|if
condition|(
name|hwcrhk_dso
operator|==
name|NULL
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_FINISH
argument_list|,
name|HWCRHK_R_NOT_LOADED
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|0
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|release_context
argument_list|(
name|hwcrhk_context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DSO_free
argument_list|(
name|hwcrhk_dso
argument_list|)
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_FINISH
argument_list|,
name|HWCRHK_R_DSO_FAILURE
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|0
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|err
label|:
if|if
condition|(
name|logstream
condition|)
name|BIO_free
argument_list|(
name|logstream
argument_list|)
expr_stmt|;
name|hwcrhk_dso
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_Init
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_Finish
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_ModExp
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|p_hwcrhk_RSA
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RSALoadKey
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RSAGetPublicKey
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RSAUnloadKey
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|p_hwcrhk_ModExpCRT
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RandomBytes
operator|=
name|NULL
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwcrhk_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
parameter_list|)
block|{
name|int
name|to_return
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|HWCRHK_CMD_SO_PATH
case|:
if|if
condition|(
name|hwcrhk_dso
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_CTRL
argument_list|,
name|HWCRHK_R_ALREADY_LOADED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_CTRL
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|set_HWCRHK_LIBNAME
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|)
return|;
case|case
name|ENGINE_CTRL_SET_LOGSTREAM
case|:
block|{
name|BIO
modifier|*
name|bio
init|=
operator|(
name|BIO
operator|*
operator|)
name|p
decl_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|logstream
condition|)
block|{
name|BIO_free
argument_list|(
name|logstream
argument_list|)
expr_stmt|;
name|logstream
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|CRYPTO_add
argument_list|(
operator|&
name|bio
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_BIO
argument_list|)
operator|>
literal|1
condition|)
name|logstream
operator|=
name|bio
expr_stmt|;
else|else
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_CTRL
argument_list|,
name|HWCRHK_R_BIO_WAS_FREED
argument_list|)
expr_stmt|;
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENGINE_CTRL_SET_PASSWORD_CALLBACK
case|:
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|password_context
operator|.
name|password_callback
operator|=
operator|(
name|pem_password_cb
operator|*
operator|)
name|f
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENGINE_CTRL_SET_USER_INTERFACE
case|:
case|case
name|HWCRHK_CMD_SET_USER_INTERFACE
case|:
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|password_context
operator|.
name|ui_method
operator|=
operator|(
name|UI_METHOD
operator|*
operator|)
name|p
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENGINE_CTRL_SET_CALLBACK_DATA
case|:
case|case
name|HWCRHK_CMD_SET_CALLBACK_DATA
case|:
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|password_context
operator|.
name|callback_data
operator|=
name|p
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
comment|/* this enables or disables the "SimpleForkCheck" flag used in the 	 * initialisation structure. */
case|case
name|ENGINE_CTRL_CHIL_SET_FORKCHECK
case|:
case|case
name|HWCRHK_CMD_FORK_CHECK
case|:
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|hwcrhk_globals
operator|.
name|flags
operator||=
name|HWCryptoHook_InitFlags_SimpleForkCheck
expr_stmt|;
else|else
name|hwcrhk_globals
operator|.
name|flags
operator|&=
operator|~
name|HWCryptoHook_InitFlags_SimpleForkCheck
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
comment|/* This will prevent the initialisation function from "installing" 	 * the mutex-handling callbacks, even if they are available from 	 * within the library (or were provided to the library from the 	 * calling application). This is to remove any baggage for 	 * applications not using multithreading. */
case|case
name|ENGINE_CTRL_CHIL_NO_LOCKING
case|:
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|disable_mutex_callbacks
operator|=
literal|1
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
case|case
name|HWCRHK_CMD_THREAD_LOCKING
case|:
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|disable_mutex_callbacks
operator|=
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
comment|/* The command isn't understood by this engine */
default|default:
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_CTRL
argument_list|,
name|HWCRHK_R_CTRL_COMMAND_NOT_IMPLEMENTED
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|EVP_PKEY
modifier|*
name|hwcrhk_load_privkey
parameter_list|(
name|ENGINE
modifier|*
name|eng
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|RSA
modifier|*
name|rtmp
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|EVP_PKEY
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|HWCryptoHook_MPI
name|e
decl_stmt|,
name|n
decl_stmt|;
name|HWCryptoHook_RSAKeyHandle
modifier|*
name|hptr
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_RSA
argument_list|)
name|char
name|tempbuf
index|[
literal|1024
index|]
decl_stmt|;
name|HWCryptoHook_ErrMsgBuf
name|rmsg
decl_stmt|;
endif|#
directive|endif
name|HWCryptoHook_PassphraseContext
name|ppctx
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_RSA
argument_list|)
name|rmsg
operator|.
name|buf
operator|=
name|tempbuf
expr_stmt|;
name|rmsg
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|hwcrhk_context
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PRIVKEY
argument_list|,
name|HWCRHK_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|hptr
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HWCryptoHook_RSAKeyHandle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hptr
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PRIVKEY
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ppctx
operator|.
name|ui_method
operator|=
name|ui_method
expr_stmt|;
name|ppctx
operator|.
name|callback_data
operator|=
name|callback_data
expr_stmt|;
if|if
condition|(
name|p_hwcrhk_RSALoadKey
argument_list|(
name|hwcrhk_context
argument_list|,
name|key_id
argument_list|,
name|hptr
argument_list|,
operator|&
name|rmsg
argument_list|,
operator|&
name|ppctx
argument_list|)
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PRIVKEY
argument_list|,
name|HWCRHK_R_CHIL_ERROR
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|rmsg
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
operator|*
name|hptr
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PRIVKEY
argument_list|,
name|HWCRHK_R_NO_KEY
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|rtmp
operator|=
name|RSA_new_method
argument_list|(
name|eng
argument_list|)
expr_stmt|;
name|RSA_set_ex_data
argument_list|(
name|rtmp
argument_list|,
name|hndidx_rsa
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hptr
argument_list|)
expr_stmt|;
name|rtmp
operator|->
name|e
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|rtmp
operator|->
name|n
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|rtmp
operator|->
name|flags
operator||=
name|RSA_FLAG_EXT_PKEY
expr_stmt|;
name|MPI2BN
argument_list|(
name|rtmp
operator|->
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|MPI2BN
argument_list|(
name|rtmp
operator|->
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_hwcrhk_RSAGetPublicKey
argument_list|(
operator|*
name|hptr
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|e
argument_list|,
operator|&
name|rmsg
argument_list|)
operator|!=
name|HWCRYPTOHOOK_ERROR_MPISIZE
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PUBKEY
argument_list|,
name|HWCRHK_R_CHIL_ERROR
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|rmsg
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|bn_expand2
argument_list|(
name|rtmp
operator|->
name|e
argument_list|,
name|e
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
expr_stmt|;
name|bn_expand2
argument_list|(
name|rtmp
operator|->
name|n
argument_list|,
name|n
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
expr_stmt|;
name|MPI2BN
argument_list|(
name|rtmp
operator|->
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|MPI2BN
argument_list|(
name|rtmp
operator|->
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_hwcrhk_RSAGetPublicKey
argument_list|(
operator|*
name|hptr
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|e
argument_list|,
operator|&
name|rmsg
argument_list|)
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PUBKEY
argument_list|,
name|HWCRHK_R_CHIL_ERROR
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|rmsg
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|rtmp
operator|->
name|e
operator|->
name|top
operator|=
name|e
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|rtmp
operator|->
name|e
argument_list|)
expr_stmt|;
name|rtmp
operator|->
name|n
operator|->
name|top
operator|=
name|n
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|rtmp
operator|->
name|n
argument_list|)
expr_stmt|;
name|res
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_RSA
argument_list|(
name|res
argument_list|,
name|rtmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|res
condition|)
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PUBKEY
argument_list|,
name|HWCRHK_R_PRIVATE_KEY_ALGORITHMS_DISABLED
argument_list|)
expr_stmt|;
return|return
name|res
return|;
name|err
label|:
if|if
condition|(
name|res
condition|)
name|EVP_PKEY_free
argument_list|(
name|res
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|rtmp
condition|)
name|RSA_free
argument_list|(
name|rtmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|EVP_PKEY
modifier|*
name|hwcrhk_load_pubkey
parameter_list|(
name|ENGINE
modifier|*
name|eng
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|res
operator|=
name|hwcrhk_load_privkey
argument_list|(
name|eng
argument_list|,
name|key_id
argument_list|,
name|ui_method
argument_list|,
name|callback_data
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|res
condition|)
switch|switch
condition|(
name|res
operator|->
name|type
condition|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
case|case
name|EVP_PKEY_RSA
case|:
block|{
name|RSA
modifier|*
name|rsa
init|=
name|NULL
decl_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_EVP_PKEY
argument_list|)
expr_stmt|;
name|rsa
operator|=
name|res
operator|->
name|pkey
operator|.
name|rsa
expr_stmt|;
name|res
operator|->
name|pkey
operator|.
name|rsa
operator|=
name|RSA_new
argument_list|()
expr_stmt|;
name|res
operator|->
name|pkey
operator|.
name|rsa
operator|->
name|n
operator|=
name|rsa
operator|->
name|n
expr_stmt|;
name|res
operator|->
name|pkey
operator|.
name|rsa
operator|->
name|e
operator|=
name|rsa
operator|->
name|e
expr_stmt|;
name|rsa
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
name|rsa
operator|->
name|e
operator|=
name|NULL
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_EVP_PKEY
argument_list|)
expr_stmt|;
name|RSA_free
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PUBKEY
argument_list|,
name|HWCRHK_R_CTRL_COMMAND_NOT_IMPLEMENTED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
name|res
return|;
name|err
label|:
if|if
condition|(
name|res
condition|)
name|EVP_PKEY_free
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* A little mod_exp */
end_comment

begin_function
specifier|static
name|int
name|hwcrhk_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|char
name|tempbuf
index|[
literal|1024
index|]
decl_stmt|;
name|HWCryptoHook_ErrMsgBuf
name|rmsg
decl_stmt|;
comment|/* Since HWCryptoHook_MPI is pretty compatible with BIGNUM's, 	   we use them directly, plus a little macro magic.  We only 	   thing we need to make sure of is that enough space is allocated. */
name|HWCryptoHook_MPI
name|m_a
decl_stmt|,
name|m_p
decl_stmt|,
name|m_n
decl_stmt|,
name|m_r
decl_stmt|;
name|int
name|to_return
decl_stmt|,
name|ret
decl_stmt|;
name|to_return
operator|=
literal|0
expr_stmt|;
comment|/* expect failure */
name|rmsg
operator|.
name|buf
operator|=
name|tempbuf
expr_stmt|;
name|rmsg
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hwcrhk_context
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_MOD_EXP
argument_list|,
name|HWCRHK_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Prepare the params */
name|bn_expand2
argument_list|(
name|r
argument_list|,
name|m
operator|->
name|top
argument_list|)
expr_stmt|;
comment|/* Check for error !! */
name|BN2MPI
argument_list|(
name|m_a
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|BN2MPI
argument_list|(
name|m_p
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|BN2MPI
argument_list|(
name|m_n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|MPI2BN
argument_list|(
name|r
argument_list|,
name|m_r
argument_list|)
expr_stmt|;
comment|/* Perform the operation */
name|ret
operator|=
name|p_hwcrhk_ModExp
argument_list|(
name|hwcrhk_context
argument_list|,
name|m_a
argument_list|,
name|m_p
argument_list|,
name|m_n
argument_list|,
operator|&
name|m_r
argument_list|,
operator|&
name|rmsg
argument_list|)
expr_stmt|;
comment|/* Convert the response */
name|r
operator|->
name|top
operator|=
name|m_r
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* FIXME: When this error is returned, HWCryptoHook is 		   telling us that falling back to software computation 		   might be a good thing. */
if|if
condition|(
name|ret
operator|==
name|HWCRYPTOHOOK_ERROR_FALLBACK
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_MOD_EXP
argument_list|,
name|HWCRHK_R_REQUEST_FALLBACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_MOD_EXP
argument_list|,
name|HWCRHK_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
block|}
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|rmsg
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|to_return
operator|=
literal|1
expr_stmt|;
name|err
label|:
return|return
name|to_return
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_function
specifier|static
name|int
name|hwcrhk_rsa_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|I
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|)
block|{
name|char
name|tempbuf
index|[
literal|1024
index|]
decl_stmt|;
name|HWCryptoHook_ErrMsgBuf
name|rmsg
decl_stmt|;
name|HWCryptoHook_RSAKeyHandle
modifier|*
name|hptr
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|,
name|ret
decl_stmt|;
name|rmsg
operator|.
name|buf
operator|=
name|tempbuf
expr_stmt|;
name|rmsg
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hwcrhk_context
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_MOD_EXP
argument_list|,
name|HWCRHK_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* This provides support for nForce keys.  Since that's opaque data 	   all we do is provide a handle to the proper key and let HWCryptoHook 	   take care of the rest. */
if|if
condition|(
operator|(
name|hptr
operator|=
operator|(
name|HWCryptoHook_RSAKeyHandle
operator|*
operator|)
name|RSA_get_ex_data
argument_list|(
name|rsa
argument_list|,
name|hndidx_rsa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|HWCryptoHook_MPI
name|m_a
decl_stmt|,
name|m_r
decl_stmt|;
if|if
condition|(
operator|!
name|rsa
operator|->
name|n
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RSA_MOD_EXP
argument_list|,
name|HWCRHK_R_MISSING_KEY_COMPONENTS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Prepare the params */
name|bn_expand2
argument_list|(
name|r
argument_list|,
name|rsa
operator|->
name|n
operator|->
name|top
argument_list|)
expr_stmt|;
comment|/* Check for error !! */
name|BN2MPI
argument_list|(
name|m_a
argument_list|,
name|I
argument_list|)
expr_stmt|;
name|MPI2BN
argument_list|(
name|r
argument_list|,
name|m_r
argument_list|)
expr_stmt|;
comment|/* Perform the operation */
name|ret
operator|=
name|p_hwcrhk_RSA
argument_list|(
name|m_a
argument_list|,
operator|*
name|hptr
argument_list|,
operator|&
name|m_r
argument_list|,
operator|&
name|rmsg
argument_list|)
expr_stmt|;
comment|/* Convert the response */
name|r
operator|->
name|top
operator|=
name|m_r
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* FIXME: When this error is returned, HWCryptoHook is 			   telling us that falling back to software computation 			   might be a good thing. */
if|if
condition|(
name|ret
operator|==
name|HWCRYPTOHOOK_ERROR_FALLBACK
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RSA_MOD_EXP
argument_list|,
name|HWCRHK_R_REQUEST_FALLBACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RSA_MOD_EXP
argument_list|,
name|HWCRHK_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
block|}
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|rmsg
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
else|else
block|{
name|HWCryptoHook_MPI
name|m_a
decl_stmt|,
name|m_p
decl_stmt|,
name|m_q
decl_stmt|,
name|m_dmp1
decl_stmt|,
name|m_dmq1
decl_stmt|,
name|m_iqmp
decl_stmt|,
name|m_r
decl_stmt|;
if|if
condition|(
operator|!
name|rsa
operator|->
name|p
operator|||
operator|!
name|rsa
operator|->
name|q
operator|||
operator|!
name|rsa
operator|->
name|dmp1
operator|||
operator|!
name|rsa
operator|->
name|dmq1
operator|||
operator|!
name|rsa
operator|->
name|iqmp
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RSA_MOD_EXP
argument_list|,
name|HWCRHK_R_MISSING_KEY_COMPONENTS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Prepare the params */
name|bn_expand2
argument_list|(
name|r
argument_list|,
name|rsa
operator|->
name|n
operator|->
name|top
argument_list|)
expr_stmt|;
comment|/* Check for error !! */
name|BN2MPI
argument_list|(
name|m_a
argument_list|,
name|I
argument_list|)
expr_stmt|;
name|BN2MPI
argument_list|(
name|m_p
argument_list|,
name|rsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|BN2MPI
argument_list|(
name|m_q
argument_list|,
name|rsa
operator|->
name|q
argument_list|)
expr_stmt|;
name|BN2MPI
argument_list|(
name|m_dmp1
argument_list|,
name|rsa
operator|->
name|dmp1
argument_list|)
expr_stmt|;
name|BN2MPI
argument_list|(
name|m_dmq1
argument_list|,
name|rsa
operator|->
name|dmq1
argument_list|)
expr_stmt|;
name|BN2MPI
argument_list|(
name|m_iqmp
argument_list|,
name|rsa
operator|->
name|iqmp
argument_list|)
expr_stmt|;
name|MPI2BN
argument_list|(
name|r
argument_list|,
name|m_r
argument_list|)
expr_stmt|;
comment|/* Perform the operation */
name|ret
operator|=
name|p_hwcrhk_ModExpCRT
argument_list|(
name|hwcrhk_context
argument_list|,
name|m_a
argument_list|,
name|m_p
argument_list|,
name|m_q
argument_list|,
name|m_dmp1
argument_list|,
name|m_dmq1
argument_list|,
name|m_iqmp
argument_list|,
operator|&
name|m_r
argument_list|,
operator|&
name|rmsg
argument_list|)
expr_stmt|;
comment|/* Convert the response */
name|r
operator|->
name|top
operator|=
name|m_r
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* FIXME: When this error is returned, HWCryptoHook is 			   telling us that falling back to software computation 			   might be a good thing. */
if|if
condition|(
name|ret
operator|==
name|HWCRYPTOHOOK_ERROR_FALLBACK
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RSA_MOD_EXP
argument_list|,
name|HWCRHK_R_REQUEST_FALLBACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RSA_MOD_EXP
argument_list|,
name|HWCRHK_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
block|}
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|rmsg
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
comment|/* If we're here, we must be here with some semblance of success :-) */
name|to_return
operator|=
literal|1
expr_stmt|;
name|err
label|:
return|return
name|to_return
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function is aliased to mod_exp (with the mont stuff dropped). */
end_comment

begin_function
specifier|static
name|int
name|hwcrhk_mod_exp_mont
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
block|{
return|return
name|hwcrhk_mod_exp
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_comment
comment|/* This function is aliased to mod_exp (with the dh and mont dropped). */
end_comment

begin_function
specifier|static
name|int
name|hwcrhk_mod_exp_dh
parameter_list|(
specifier|const
name|DH
modifier|*
name|dh
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
block|{
return|return
name|hwcrhk_mod_exp
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Random bytes are good */
end_comment

begin_function
specifier|static
name|int
name|hwcrhk_rand_bytes
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|char
name|tempbuf
index|[
literal|1024
index|]
decl_stmt|;
name|HWCryptoHook_ErrMsgBuf
name|rmsg
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
comment|/* assume failure */
name|int
name|ret
decl_stmt|;
name|rmsg
operator|.
name|buf
operator|=
name|tempbuf
expr_stmt|;
name|rmsg
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hwcrhk_context
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RAND_BYTES
argument_list|,
name|HWCRHK_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
name|p_hwcrhk_RandomBytes
argument_list|(
name|hwcrhk_context
argument_list|,
name|buf
argument_list|,
name|num
argument_list|,
operator|&
name|rmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* FIXME: When this error is returned, HWCryptoHook is 		   telling us that falling back to software computation 		   might be a good thing. */
if|if
condition|(
name|ret
operator|==
name|HWCRYPTOHOOK_ERROR_FALLBACK
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RAND_BYTES
argument_list|,
name|HWCRHK_R_REQUEST_FALLBACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RAND_BYTES
argument_list|,
name|HWCRHK_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
block|}
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|rmsg
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|to_return
operator|=
literal|1
expr_stmt|;
name|err
label|:
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwcrhk_rand_status
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This cleans up an RSA KM key, called when ex_data is freed */
end_comment

begin_function
specifier|static
name|void
name|hwcrhk_ex_free
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|,
name|int
name|ind
parameter_list|,
name|long
name|argl
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|)
block|{
name|char
name|tempbuf
index|[
literal|1024
index|]
decl_stmt|;
name|HWCryptoHook_ErrMsgBuf
name|rmsg
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|HWCryptoHook_RSAKeyHandle
modifier|*
name|hptr
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_RSA
argument_list|)
name|int
name|ret
decl_stmt|;
endif|#
directive|endif
name|rmsg
operator|.
name|buf
operator|=
name|tempbuf
expr_stmt|;
name|rmsg
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|hptr
operator|=
operator|(
name|HWCryptoHook_RSAKeyHandle
operator|*
operator|)
name|item
expr_stmt|;
if|if
condition|(
name|hptr
condition|)
block|{
name|ret
operator|=
name|p_hwcrhk_RSAUnloadKey
argument_list|(
operator|*
name|hptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|hptr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Mutex calls: since the HWCryptoHook model closely follows the POSIX model  * these just wrap the POSIX functions and add some logging.  */
end_comment

begin_function
specifier|static
name|int
name|hwcrhk_mutex_init
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|mt
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
name|cactx
parameter_list|)
block|{
name|mt
operator|->
name|lockid
operator|=
name|CRYPTO_get_new_dynlockid
argument_list|()
expr_stmt|;
if|if
condition|(
name|mt
operator|->
name|lockid
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* failure */
return|return
literal|0
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|int
name|hwcrhk_mutex_lock
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|mt
parameter_list|)
block|{
name|CRYPTO_w_lock
argument_list|(
name|mt
operator|->
name|lockid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hwcrhk_mutex_unlock
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|mt
parameter_list|)
block|{
name|CRYPTO_w_unlock
argument_list|(
name|mt
operator|->
name|lockid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hwcrhk_mutex_destroy
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|mt
parameter_list|)
block|{
name|CRYPTO_destroy_dynlockid
argument_list|(
name|mt
operator|->
name|lockid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mutex upcalls to use if the application does not support dynamic locks */
end_comment

begin_function
specifier|static
name|int
name|hwcrhk_static_mutex_init
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|m
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
name|c
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwcrhk_static_mutex_lock
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|m
parameter_list|)
block|{
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_HWCRHK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hwcrhk_static_mutex_unlock
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|m
parameter_list|)
block|{
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_HWCRHK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hwcrhk_static_mutex_destroy
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|m
parameter_list|)
block|{ 	}
end_function

begin_function
specifier|static
name|int
name|hwcrhk_get_pass
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt_info
parameter_list|,
name|int
modifier|*
name|len_io
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|HWCryptoHook_PassphraseContext
modifier|*
name|ppctx
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
name|cactx
parameter_list|)
block|{
name|pem_password_cb
modifier|*
name|callback
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|callback_data
init|=
name|NULL
decl_stmt|;
name|UI_METHOD
modifier|*
name|ui_method
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|cactx
condition|)
block|{
if|if
condition|(
name|cactx
operator|->
name|ui_method
condition|)
name|ui_method
operator|=
name|cactx
operator|->
name|ui_method
expr_stmt|;
if|if
condition|(
name|cactx
operator|->
name|password_callback
condition|)
name|callback
operator|=
name|cactx
operator|->
name|password_callback
expr_stmt|;
if|if
condition|(
name|cactx
operator|->
name|callback_data
condition|)
name|callback_data
operator|=
name|cactx
operator|->
name|callback_data
expr_stmt|;
block|}
if|if
condition|(
name|ppctx
condition|)
block|{
if|if
condition|(
name|ppctx
operator|->
name|ui_method
condition|)
block|{
name|ui_method
operator|=
name|ppctx
operator|->
name|ui_method
expr_stmt|;
name|callback
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ppctx
operator|->
name|callback_data
condition|)
name|callback_data
operator|=
name|ppctx
operator|->
name|callback_data
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|==
name|NULL
operator|&&
name|ui_method
operator|==
name|NULL
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_GET_PASS
argument_list|,
name|HWCRHK_R_NO_CALLBACK
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ui_method
condition|)
block|{
name|UI
modifier|*
name|ui
init|=
name|UI_new_method
argument_list|(
name|ui_method
argument_list|)
decl_stmt|;
if|if
condition|(
name|ui
condition|)
block|{
name|int
name|ok
decl_stmt|;
name|char
modifier|*
name|prompt
init|=
name|UI_construct_prompt
argument_list|(
name|ui
argument_list|,
literal|"pass phrase"
argument_list|,
name|prompt_info
argument_list|)
decl_stmt|;
name|ok
operator|=
name|UI_add_input_string
argument_list|(
name|ui
argument_list|,
name|prompt
argument_list|,
name|UI_INPUT_FLAG_DEFAULT_PWD
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
operator|*
name|len_io
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|UI_add_user_data
argument_list|(
name|ui
argument_list|,
name|callback_data
argument_list|)
expr_stmt|;
name|UI_ctrl
argument_list|(
name|ui
argument_list|,
name|UI_CTRL_PRINT_ERRORS
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|>=
literal|0
condition|)
do|do
block|{
name|ok
operator|=
name|UI_process
argument_list|(
name|ui
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ok
operator|<
literal|0
operator|&&
name|UI_ctrl
argument_list|(
name|ui
argument_list|,
name|UI_CTRL_IS_REDOABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
do|;
if|if
condition|(
name|ok
operator|>=
literal|0
condition|)
operator|*
name|len_io
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|UI_free
argument_list|(
name|ui
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|len_io
operator|=
name|callback
argument_list|(
name|buf
argument_list|,
operator|*
name|len_io
argument_list|,
literal|0
argument_list|,
name|callback_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|len_io
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwcrhk_insert_card
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt_info
parameter_list|,
specifier|const
name|char
modifier|*
name|wrong_info
parameter_list|,
name|HWCryptoHook_PassphraseContext
modifier|*
name|ppctx
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
name|cactx
parameter_list|)
block|{
name|int
name|ok
init|=
operator|-
literal|1
decl_stmt|;
name|UI
modifier|*
name|ui
decl_stmt|;
name|void
modifier|*
name|callback_data
init|=
name|NULL
decl_stmt|;
name|UI_METHOD
modifier|*
name|ui_method
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|cactx
condition|)
block|{
if|if
condition|(
name|cactx
operator|->
name|ui_method
condition|)
name|ui_method
operator|=
name|cactx
operator|->
name|ui_method
expr_stmt|;
if|if
condition|(
name|cactx
operator|->
name|callback_data
condition|)
name|callback_data
operator|=
name|cactx
operator|->
name|callback_data
expr_stmt|;
block|}
if|if
condition|(
name|ppctx
condition|)
block|{
if|if
condition|(
name|ppctx
operator|->
name|ui_method
condition|)
name|ui_method
operator|=
name|ppctx
operator|->
name|ui_method
expr_stmt|;
if|if
condition|(
name|ppctx
operator|->
name|callback_data
condition|)
name|callback_data
operator|=
name|ppctx
operator|->
name|callback_data
expr_stmt|;
block|}
if|if
condition|(
name|ui_method
operator|==
name|NULL
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_INSERT_CARD
argument_list|,
name|HWCRHK_R_NO_CALLBACK
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ui
operator|=
name|UI_new_method
argument_list|(
name|ui_method
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui
condition|)
block|{
name|char
name|answer
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|wrong_info
condition|)
name|BIO_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|,
literal|"Current card: \"%s\"\n"
argument_list|,
name|wrong_info
argument_list|)
expr_stmt|;
name|ok
operator|=
name|UI_dup_info_string
argument_list|(
name|ui
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|>=
literal|0
operator|&&
name|prompt_info
condition|)
block|{
name|BIO_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|,
literal|"Insert card \"%s\""
argument_list|,
name|prompt_info
argument_list|)
expr_stmt|;
name|ok
operator|=
name|UI_dup_input_boolean
argument_list|(
name|ui
argument_list|,
name|buf
argument_list|,
literal|"\n then hit<enter> or C<enter> to cancel\n"
argument_list|,
literal|"\r\n"
argument_list|,
literal|"Cc"
argument_list|,
name|UI_INPUT_FLAG_ECHO
argument_list|,
operator|&
name|answer
argument_list|)
expr_stmt|;
block|}
name|UI_add_user_data
argument_list|(
name|ui
argument_list|,
name|callback_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|>=
literal|0
condition|)
name|ok
operator|=
name|UI_process
argument_list|(
name|ui
argument_list|)
expr_stmt|;
name|UI_free
argument_list|(
name|ui
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
operator|-
literal|2
operator|||
operator|(
name|ok
operator|>=
literal|0
operator|&&
name|answer
operator|==
literal|'C'
operator|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ok
operator|<
literal|0
condition|)
name|ok
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|ok
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hwcrhk_log_message
parameter_list|(
name|void
modifier|*
name|logstr
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|BIO
modifier|*
name|lstream
init|=
name|NULL
decl_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_BIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|logstr
condition|)
name|lstream
operator|=
operator|*
operator|(
name|BIO
operator|*
operator|*
operator|)
name|logstr
expr_stmt|;
if|if
condition|(
name|lstream
condition|)
block|{
name|BIO_printf
argument_list|(
name|lstream
argument_list|,
literal|"%s\n"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_BIO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This stuff is needed if this ENGINE is being compiled into a self-contained  * shared-library. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENGINE_DYNAMIC_SUPPORT
end_ifdef

begin_function
specifier|static
name|int
name|bind_fn
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|&&
operator|(
name|strcmp
argument_list|(
name|id
argument_list|,
name|engine_hwcrhk_id
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|bind_helper
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_macro
name|IMPLEMENT_DYNAMIC_CHECK_FN
argument_list|()
end_macro

begin_macro
name|IMPLEMENT_DYNAMIC_BIND_FN
argument_list|(
argument|bind_fn
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENGINE_DYNAMIC_SUPPORT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_HW_NCIPHER */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_HW */
end_comment

end_unit

