begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-2007 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"kdc_locl.h"
end_include

begin_define
define|#
directive|define
name|MAX_TIME
value|((time_t)((1U<< 31) - 1))
end_define

begin_function
name|void
name|_kdc_fix_time
parameter_list|(
name|time_t
modifier|*
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
name|NULL
condition|)
block|{
name|ALLOC
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
operator|*
operator|*
name|t
operator|=
name|MAX_TIME
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|t
operator|==
literal|0
condition|)
operator|*
operator|*
name|t
operator|=
name|MAX_TIME
expr_stmt|;
comment|/* fix for old clients */
block|}
end_function

begin_function
specifier|static
name|int
name|realloc_method_data
parameter_list|(
name|METHOD_DATA
modifier|*
name|md
parameter_list|)
block|{
name|PA_DATA
modifier|*
name|pa
decl_stmt|;
name|pa
operator|=
name|realloc
argument_list|(
name|md
operator|->
name|val
argument_list|,
operator|(
name|md
operator|->
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|md
operator|->
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|md
operator|->
name|val
operator|=
name|pa
expr_stmt|;
name|md
operator|->
name|len
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_salt_padata
parameter_list|(
name|METHOD_DATA
modifier|*
name|md
parameter_list|,
name|Salt
modifier|*
name|salt
parameter_list|)
block|{
if|if
condition|(
name|salt
condition|)
block|{
name|realloc_method_data
argument_list|(
name|md
argument_list|)
expr_stmt|;
name|md
operator|->
name|val
index|[
name|md
operator|->
name|len
operator|-
literal|1
index|]
operator|.
name|padata_type
operator|=
name|salt
operator|->
name|type
expr_stmt|;
name|der_copy_octet_string
argument_list|(
operator|&
name|salt
operator|->
name|salt
argument_list|,
operator|&
name|md
operator|->
name|val
index|[
name|md
operator|->
name|len
operator|-
literal|1
index|]
operator|.
name|padata_value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|const
name|PA_DATA
modifier|*
name|_kdc_find_padata
parameter_list|(
specifier|const
name|KDC_REQ
modifier|*
name|req
parameter_list|,
name|int
modifier|*
name|start
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|req
operator|->
name|padata
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
while|while
condition|(
operator|(
name|size_t
operator|)
operator|*
name|start
operator|<
name|req
operator|->
name|padata
operator|->
name|len
condition|)
block|{
operator|(
operator|*
name|start
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|padata
operator|->
name|val
index|[
operator|*
name|start
operator|-
literal|1
index|]
operator|.
name|padata_type
operator|==
operator|(
name|unsigned
operator|)
name|type
condition|)
return|return
operator|&
name|req
operator|->
name|padata
operator|->
name|val
index|[
operator|*
name|start
operator|-
literal|1
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * This is a hack to allow predefined weak services, like afs to  * still use weak types  */
end_comment

begin_function
name|krb5_boolean
name|_kdc_is_weak_exception
parameter_list|(
name|krb5_principal
name|principal
parameter_list|,
name|krb5_enctype
name|etype
parameter_list|)
block|{
if|if
condition|(
name|principal
operator|->
name|name
operator|.
name|name_string
operator|.
name|len
operator|>
literal|0
operator|&&
name|strcmp
argument_list|(
name|principal
operator|->
name|name
operator|.
name|name_string
operator|.
name|val
index|[
literal|0
index|]
argument_list|,
literal|"afs"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|etype
operator|==
name|ETYPE_DES_CBC_CRC
operator|||
name|etype
operator|==
name|ETYPE_DES_CBC_MD4
operator|||
name|etype
operator|==
name|ETYPE_DES_CBC_MD5
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Detect if `key' is the using the the precomputed `default_salt'.  */
end_comment

begin_function
specifier|static
name|krb5_boolean
name|is_default_salt_p
parameter_list|(
specifier|const
name|krb5_salt
modifier|*
name|default_salt
parameter_list|,
specifier|const
name|Key
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|->
name|salt
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|default_salt
operator|->
name|salttype
operator|!=
name|key
operator|->
name|salt
operator|->
name|type
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|krb5_data_cmp
argument_list|(
operator|&
name|default_salt
operator|->
name|saltvalue
argument_list|,
operator|&
name|key
operator|->
name|salt
operator|->
name|salt
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * return the first appropriate key of `princ' in `ret_key'.  Look for  * all the etypes in (`etypes', `len'), stopping as soon as we find  * one, but preferring one that has default salt  */
end_comment

begin_function
name|krb5_error_code
name|_kdc_find_etype
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_boolean
name|use_strongest_session_key
parameter_list|,
name|krb5_boolean
name|is_preauth
parameter_list|,
name|hdb_entry_ex
modifier|*
name|princ
parameter_list|,
name|krb5_enctype
modifier|*
name|etypes
parameter_list|,
name|unsigned
name|len
parameter_list|,
name|krb5_enctype
modifier|*
name|ret_enctype
parameter_list|,
name|Key
modifier|*
modifier|*
name|ret_key
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_salt
name|def_salt
decl_stmt|;
name|krb5_enctype
name|enctype
init|=
name|ETYPE_NULL
decl_stmt|;
name|Key
modifier|*
name|key
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We'll want to avoid keys with v4 salted keys in the pre-auth case... */
name|ret
operator|=
name|krb5_get_pw_salt
argument_list|(
name|context
argument_list|,
name|princ
operator|->
name|entry
operator|.
name|principal
argument_list|,
operator|&
name|def_salt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|KRB5KDC_ERR_ETYPE_NOSUPP
expr_stmt|;
if|if
condition|(
name|use_strongest_session_key
condition|)
block|{
specifier|const
name|krb5_enctype
modifier|*
name|p
decl_stmt|;
name|krb5_enctype
name|clientbest
init|=
name|ETYPE_NULL
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* 	 * Pick the strongest key that the KDC, target service, and 	 * client all support, using the local cryptosystem enctype 	 * list in strongest-to-weakest order to drive the search. 	 * 	 * This is not what RFC4120 says to do, but it encourages 	 * adoption of stronger enctypes.  This doesn't play well with 	 * clients that have multiple Kerberos client implementations 	 * available with different supported enctype lists. 	 */
comment|/* drive the search with local supported enctypes list */
name|p
operator|=
name|krb5_kerberos_enctypes
argument_list|(
name|context
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
index|[
name|i
index|]
operator|!=
name|ETYPE_NULL
operator|&&
name|enctype
operator|==
name|ETYPE_NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|krb5_enctype_valid
argument_list|(
name|context
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* check that the client supports it too */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
operator|&&
name|enctype
operator|==
name|ETYPE_NULL
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
index|]
operator|!=
name|etypes
index|[
name|j
index|]
condition|)
continue|continue;
comment|/* save best of union of { client, crypto system } */
if|if
condition|(
name|clientbest
operator|==
name|ETYPE_NULL
condition|)
name|clientbest
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
comment|/* check target princ support */
name|ret
operator|=
name|hdb_enctype2key
argument_list|(
name|context
argument_list|,
operator|&
name|princ
operator|->
name|entry
argument_list|,
name|p
index|[
name|i
index|]
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
continue|continue;
if|if
condition|(
name|is_preauth
operator|&&
operator|!
name|is_default_salt_p
argument_list|(
operator|&
name|def_salt
argument_list|,
name|key
argument_list|)
condition|)
continue|continue;
name|enctype
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|clientbest
operator|!=
name|ETYPE_NULL
operator|&&
name|enctype
operator|==
name|ETYPE_NULL
condition|)
name|enctype
operator|=
name|clientbest
expr_stmt|;
elseif|else
if|if
condition|(
name|enctype
operator|==
name|ETYPE_NULL
condition|)
name|ret
operator|=
name|KRB5KDC_ERR_ETYPE_NOSUPP
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|ret_enctype
operator|!=
name|NULL
condition|)
operator|*
name|ret_enctype
operator|=
name|enctype
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|ret_key
operator|!=
name|NULL
condition|)
operator|*
name|ret_key
operator|=
name|key
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Pick the first key from the client's enctype list that is 	 * supported by the cryptosystem and by the given principal. 	 * 	 * RFC4120 says we SHOULD pick the first _strong_ key from the 	 * client's list... not the first key...  If the admin disallows 	 * weak enctypes in krb5.conf and selects this key selection 	 * algorithm, then we get exactly what RFC4120 says. 	 */
for|for
control|(
name|key
operator|=
name|NULL
operator|,
name|i
operator|=
literal|0
init|;
name|ret
operator|!=
literal|0
operator|&&
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|key
operator|=
name|NULL
control|)
block|{
if|if
condition|(
name|krb5_enctype_valid
argument_list|(
name|context
argument_list|,
name|etypes
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|_kdc_is_weak_exception
argument_list|(
name|princ
operator|->
name|entry
operator|.
name|principal
argument_list|,
name|etypes
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
while|while
condition|(
name|hdb_next_enctype2key
argument_list|(
name|context
argument_list|,
operator|&
name|princ
operator|->
name|entry
argument_list|,
name|etypes
index|[
name|i
index|]
argument_list|,
operator|&
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|key
operator|->
name|key
operator|.
name|keyvalue
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|KRB5KDC_ERR_NULL_KEY
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ret_key
operator|!=
name|NULL
condition|)
operator|*
name|ret_key
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|ret_enctype
operator|!=
name|NULL
condition|)
operator|*
name|ret_enctype
operator|=
name|etypes
index|[
name|i
index|]
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_preauth
operator|&&
name|is_default_salt_p
argument_list|(
operator|&
name|def_salt
argument_list|,
name|key
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
block|}
block|}
name|out
label|:
name|krb5_free_salt
argument_list|(
name|context
argument_list|,
name|def_salt
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|krb5_error_code
name|_kdc_make_anonymous_principalname
parameter_list|(
name|PrincipalName
modifier|*
name|pn
parameter_list|)
block|{
name|pn
operator|->
name|name_type
operator|=
name|KRB5_NT_PRINCIPAL
expr_stmt|;
name|pn
operator|->
name|name_string
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|pn
operator|->
name|name_string
operator|.
name|val
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pn
operator|->
name|name_string
operator|.
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|->
name|name_string
operator|.
name|val
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|pn
operator|->
name|name_string
operator|.
name|val
index|[
literal|0
index|]
operator|=
name|strdup
argument_list|(
literal|"anonymous"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|->
name|name_string
operator|.
name|val
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pn
operator|->
name|name_string
operator|.
name|val
argument_list|)
expr_stmt|;
name|pn
operator|->
name|name_string
operator|.
name|val
operator|=
name|NULL
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|_kdc_log_timestamp
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_kdc_configuration
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|KerberosTime
name|authtime
parameter_list|,
name|KerberosTime
modifier|*
name|starttime
parameter_list|,
name|KerberosTime
name|endtime
parameter_list|,
name|KerberosTime
modifier|*
name|renew_till
parameter_list|)
block|{
name|char
name|authtime_str
index|[
literal|100
index|]
decl_stmt|,
name|starttime_str
index|[
literal|100
index|]
decl_stmt|,
name|endtime_str
index|[
literal|100
index|]
decl_stmt|,
name|renewtime_str
index|[
literal|100
index|]
decl_stmt|;
name|krb5_format_time
argument_list|(
name|context
argument_list|,
name|authtime
argument_list|,
name|authtime_str
argument_list|,
sizeof|sizeof
argument_list|(
name|authtime_str
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|starttime
condition|)
name|krb5_format_time
argument_list|(
name|context
argument_list|,
operator|*
name|starttime
argument_list|,
name|starttime_str
argument_list|,
sizeof|sizeof
argument_list|(
name|starttime_str
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|starttime_str
argument_list|,
literal|"unset"
argument_list|,
sizeof|sizeof
argument_list|(
name|starttime_str
argument_list|)
argument_list|)
expr_stmt|;
name|krb5_format_time
argument_list|(
name|context
argument_list|,
name|endtime
argument_list|,
name|endtime_str
argument_list|,
sizeof|sizeof
argument_list|(
name|endtime_str
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|renew_till
condition|)
name|krb5_format_time
argument_list|(
name|context
argument_list|,
operator|*
name|renew_till
argument_list|,
name|renewtime_str
argument_list|,
sizeof|sizeof
argument_list|(
name|renewtime_str
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|renewtime_str
argument_list|,
literal|"unset"
argument_list|,
sizeof|sizeof
argument_list|(
name|renewtime_str
argument_list|)
argument_list|)
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|5
argument_list|,
literal|"%s authtime: %s starttime: %s endtime: %s renew till: %s"
argument_list|,
name|type
argument_list|,
name|authtime_str
argument_list|,
name|starttime_str
argument_list|,
name|endtime_str
argument_list|,
name|renewtime_str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|log_patypes
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_kdc_configuration
modifier|*
name|config
parameter_list|,
name|METHOD_DATA
modifier|*
name|padata
parameter_list|)
block|{
name|struct
name|rk_strpool
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|padata
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|padata
operator|->
name|val
index|[
name|i
index|]
operator|.
name|padata_type
condition|)
block|{
case|case
name|KRB5_PADATA_PK_AS_REQ
case|:
name|p
operator|=
name|rk_strpoolprintf
argument_list|(
name|p
argument_list|,
literal|"PK-INIT(ietf)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KRB5_PADATA_PK_AS_REQ_WIN
case|:
name|p
operator|=
name|rk_strpoolprintf
argument_list|(
name|p
argument_list|,
literal|"PK-INIT(win2k)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KRB5_PADATA_PA_PK_OCSP_RESPONSE
case|:
name|p
operator|=
name|rk_strpoolprintf
argument_list|(
name|p
argument_list|,
literal|"OCSP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KRB5_PADATA_ENC_TIMESTAMP
case|:
name|p
operator|=
name|rk_strpoolprintf
argument_list|(
name|p
argument_list|,
literal|"encrypted-timestamp"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|p
operator|=
name|rk_strpoolprintf
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
name|padata
operator|->
name|val
index|[
name|i
index|]
operator|.
name|padata_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|&&
name|i
operator|+
literal|1
operator|<
name|padata
operator|->
name|len
condition|)
name|p
operator|=
name|rk_strpoolprintf
argument_list|(
name|p
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|rk_strpoolprintf
argument_list|(
name|p
argument_list|,
literal|"none"
argument_list|)
expr_stmt|;
name|str
operator|=
name|rk_strpoolcollect
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Client sent patypes: %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|krb5_error_code
name|_kdc_encode_reply
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_kdc_configuration
modifier|*
name|config
parameter_list|,
name|KDC_REP
modifier|*
name|rep
parameter_list|,
specifier|const
name|EncTicketPart
modifier|*
name|et
parameter_list|,
name|EncKDCRepPart
modifier|*
name|ek
parameter_list|,
name|krb5_enctype
name|etype
parameter_list|,
name|int
name|skvno
parameter_list|,
specifier|const
name|EncryptionKey
modifier|*
name|skey
parameter_list|,
name|int
name|ckvno
parameter_list|,
specifier|const
name|EncryptionKey
modifier|*
name|reply_key
parameter_list|,
name|int
name|rk_is_subkey
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|e_text
parameter_list|,
name|krb5_data
modifier|*
name|reply
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buf_size
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_crypto
name|crypto
decl_stmt|;
name|ASN1_MALLOC_ENCODE
argument_list|(
name|EncTicketPart
argument_list|,
name|buf
argument_list|,
name|buf_size
argument_list|,
name|et
argument_list|,
operator|&
name|len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|krb5_get_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|)
decl_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Failed to encode ticket: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|krb5_free_error_message
argument_list|(
name|context
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|buf_size
operator|!=
name|len
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Internal error in ASN.1 encoder"
argument_list|)
expr_stmt|;
operator|*
name|e_text
operator|=
literal|"KDC internal error"
expr_stmt|;
return|return
name|KRB5KRB_ERR_GENERIC
return|;
block|}
name|ret
operator|=
name|krb5_crypto_init
argument_list|(
name|context
argument_list|,
name|skey
argument_list|,
name|etype
argument_list|,
operator|&
name|crypto
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|msg
operator|=
name|krb5_get_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"krb5_crypto_init failed: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|krb5_free_error_message
argument_list|(
name|context
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|krb5_encrypt_EncryptedData
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|KRB5_KU_TICKET
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|skvno
argument_list|,
operator|&
name|rep
operator|->
name|ticket
operator|.
name|enc_part
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|krb5_crypto_destroy
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|krb5_get_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|)
decl_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Failed to encrypt data: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|krb5_free_error_message
argument_list|(
name|context
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|rep
operator|->
name|msg_type
operator|==
name|krb_as_rep
operator|&&
operator|!
name|config
operator|->
name|encode_as_rep_as_tgs_rep
condition|)
name|ASN1_MALLOC_ENCODE
argument_list|(
name|EncASRepPart
argument_list|,
name|buf
argument_list|,
name|buf_size
argument_list|,
name|ek
argument_list|,
operator|&
name|len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
else|else
name|ASN1_MALLOC_ENCODE
argument_list|(
name|EncTGSRepPart
argument_list|,
name|buf
argument_list|,
name|buf_size
argument_list|,
name|ek
argument_list|,
operator|&
name|len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|krb5_get_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|)
decl_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Failed to encode KDC-REP: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|krb5_free_error_message
argument_list|(
name|context
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|buf_size
operator|!=
name|len
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Internal error in ASN.1 encoder"
argument_list|)
expr_stmt|;
operator|*
name|e_text
operator|=
literal|"KDC internal error"
expr_stmt|;
return|return
name|KRB5KRB_ERR_GENERIC
return|;
block|}
name|ret
operator|=
name|krb5_crypto_init
argument_list|(
name|context
argument_list|,
name|reply_key
argument_list|,
literal|0
argument_list|,
operator|&
name|crypto
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|krb5_get_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"krb5_crypto_init failed: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|krb5_free_error_message
argument_list|(
name|context
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|rep
operator|->
name|msg_type
operator|==
name|krb_as_rep
condition|)
block|{
name|krb5_encrypt_EncryptedData
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|KRB5_KU_AS_REP_ENC_PART
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|ckvno
argument_list|,
operator|&
name|rep
operator|->
name|enc_part
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ASN1_MALLOC_ENCODE
argument_list|(
name|AS_REP
argument_list|,
name|buf
argument_list|,
name|buf_size
argument_list|,
name|rep
argument_list|,
operator|&
name|len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|krb5_encrypt_EncryptedData
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|rk_is_subkey
condition|?
name|KRB5_KU_TGS_REP_ENC_PART_SUB_KEY
else|:
name|KRB5_KU_TGS_REP_ENC_PART_SESSION
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|ckvno
argument_list|,
operator|&
name|rep
operator|->
name|enc_part
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ASN1_MALLOC_ENCODE
argument_list|(
name|TGS_REP
argument_list|,
name|buf
argument_list|,
name|buf_size
argument_list|,
name|rep
argument_list|,
operator|&
name|len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
name|krb5_crypto_destroy
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|krb5_get_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|)
decl_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Failed to encode KDC-REP: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|krb5_free_error_message
argument_list|(
name|context
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|buf_size
operator|!=
name|len
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Internal error in ASN.1 encoder"
argument_list|)
expr_stmt|;
operator|*
name|e_text
operator|=
literal|"KDC internal error"
expr_stmt|;
return|return
name|KRB5KRB_ERR_GENERIC
return|;
block|}
name|reply
operator|->
name|data
operator|=
name|buf
expr_stmt|;
name|reply
operator|->
name|length
operator|=
name|buf_size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return 1 if the client have only older enctypes, this is for  * determining if the server should send ETYPE_INFO2 or not.  */
end_comment

begin_function
specifier|static
name|int
name|older_enctype
parameter_list|(
name|krb5_enctype
name|enctype
parameter_list|)
block|{
switch|switch
condition|(
name|enctype
condition|)
block|{
case|case
name|ETYPE_DES_CBC_CRC
case|:
case|case
name|ETYPE_DES_CBC_MD4
case|:
case|case
name|ETYPE_DES_CBC_MD5
case|:
case|case
name|ETYPE_DES3_CBC_SHA1
case|:
case|case
name|ETYPE_ARCFOUR_HMAC_MD5
case|:
case|case
name|ETYPE_ARCFOUR_HMAC_MD5_56
case|:
comment|/*      * The following three is "old" windows enctypes and is needed for      * windows 2000 hosts.      */
case|case
name|ETYPE_ARCFOUR_MD4
case|:
case|case
name|ETYPE_ARCFOUR_HMAC_OLD
case|:
case|case
name|ETYPE_ARCFOUR_HMAC_OLD_EXP
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|krb5_error_code
name|make_etype_info_entry
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|ETYPE_INFO_ENTRY
modifier|*
name|ent
parameter_list|,
name|Key
modifier|*
name|key
parameter_list|)
block|{
name|ent
operator|->
name|etype
operator|=
name|key
operator|->
name|key
operator|.
name|keytype
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|salt
condition|)
block|{
if|#
directive|if
literal|0
block|ALLOC(ent->salttype);  	if(key->salt->type == hdb_pw_salt) 	    *ent->salttype = 0;
comment|/* or 1? or NULL? */
block|else if(key->salt->type == hdb_afs3_salt) 	    *ent->salttype = 2; 	else { 	    kdc_log(context, config, 0, "unknown salt-type: %d", 		    key->salt->type); 	    return KRB5KRB_ERR_GENERIC; 	}
comment|/* according to `the specs', we can't send a salt if 	   we have AFS3 salted key, but that requires that you 	   *know* what cell you are using (e.g by assuming 	   that the cell is the same as the realm in lower 	   case) */
elif|#
directive|elif
literal|0
name|ALLOC
argument_list|(
name|ent
operator|->
name|salttype
argument_list|)
expr_stmt|;
operator|*
name|ent
operator|->
name|salttype
operator|=
name|key
operator|->
name|salt
operator|->
name|type
expr_stmt|;
else|#
directive|else
comment|/* 	 * We shouldn't sent salttype since it is incompatible with the 	 * specification and it breaks windows clients.  The afs 	 * salting problem is solved by using KRB5-PADATA-AFS3-SALT 	 * implemented in Heimdal 0.7 and later. 	 */
name|ent
operator|->
name|salttype
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|krb5_copy_data
argument_list|(
name|context
argument_list|,
operator|&
name|key
operator|->
name|salt
operator|->
name|salt
argument_list|,
operator|&
name|ent
operator|->
name|salt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we return no salt type at all, as that should indicate 	 * the default salt type and make everybody happy.  some 	 * systems (like w2k) dislike being told the salt type 	 * here. */
name|ent
operator|->
name|salttype
operator|=
name|NULL
expr_stmt|;
name|ent
operator|->
name|salt
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|get_pa_etype_info
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_kdc_configuration
modifier|*
name|config
parameter_list|,
name|METHOD_DATA
modifier|*
name|md
parameter_list|,
name|Key
modifier|*
name|ckey
parameter_list|)
block|{
name|krb5_error_code
name|ret
init|=
literal|0
decl_stmt|;
name|ETYPE_INFO
name|pa
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|pa
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|pa
operator|.
name|val
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|pa
operator|.
name|val
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|.
name|val
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|ret
operator|=
name|make_etype_info_entry
argument_list|(
name|context
argument_list|,
operator|&
name|pa
operator|.
name|val
index|[
literal|0
index|]
argument_list|,
name|ckey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free_ETYPE_INFO
argument_list|(
operator|&
name|pa
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ASN1_MALLOC_ENCODE
argument_list|(
name|ETYPE_INFO
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|pa
argument_list|,
operator|&
name|len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|free_ETYPE_INFO
argument_list|(
operator|&
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|realloc_method_data
argument_list|(
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|md
operator|->
name|val
index|[
name|md
operator|->
name|len
operator|-
literal|1
index|]
operator|.
name|padata_type
operator|=
name|KRB5_PADATA_ETYPE_INFO
expr_stmt|;
name|md
operator|->
name|val
index|[
name|md
operator|->
name|len
operator|-
literal|1
index|]
operator|.
name|padata_value
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|md
operator|->
name|val
index|[
name|md
operator|->
name|len
operator|-
literal|1
index|]
operator|.
name|padata_value
operator|.
name|data
operator|=
name|buf
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|_krb5_AES_string_to_default_iterator
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|krb5_error_code
name|make_etype_info2_entry
parameter_list|(
name|ETYPE_INFO2_ENTRY
modifier|*
name|ent
parameter_list|,
name|Key
modifier|*
name|key
parameter_list|)
block|{
name|ent
operator|->
name|etype
operator|=
name|key
operator|->
name|key
operator|.
name|keytype
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|salt
condition|)
block|{
name|ALLOC
argument_list|(
name|ent
operator|->
name|salt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|salt
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
operator|*
name|ent
operator|->
name|salt
operator|=
name|malloc
argument_list|(
name|key
operator|->
name|salt
operator|->
name|salt
operator|.
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ent
operator|->
name|salt
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ent
operator|->
name|salt
argument_list|)
expr_stmt|;
name|ent
operator|->
name|salt
operator|=
name|NULL
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|memcpy
argument_list|(
operator|*
name|ent
operator|->
name|salt
argument_list|,
name|key
operator|->
name|salt
operator|->
name|salt
operator|.
name|data
argument_list|,
name|key
operator|->
name|salt
operator|->
name|salt
operator|.
name|length
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ent
operator|->
name|salt
operator|)
index|[
name|key
operator|->
name|salt
operator|->
name|salt
operator|.
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|ent
operator|->
name|salt
operator|=
name|NULL
expr_stmt|;
name|ent
operator|->
name|s2kparams
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|key
operator|->
name|key
operator|.
name|keytype
condition|)
block|{
case|case
name|ETYPE_AES128_CTS_HMAC_SHA1_96
case|:
case|case
name|ETYPE_AES256_CTS_HMAC_SHA1_96
case|:
name|ALLOC
argument_list|(
name|ent
operator|->
name|s2kparams
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|s2kparams
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|ent
operator|->
name|s2kparams
operator|->
name|length
operator|=
literal|4
expr_stmt|;
name|ent
operator|->
name|s2kparams
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|ent
operator|->
name|s2kparams
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|s2kparams
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ent
operator|->
name|s2kparams
argument_list|)
expr_stmt|;
name|ent
operator|->
name|s2kparams
operator|=
name|NULL
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|_krb5_put_int
argument_list|(
name|ent
operator|->
name|s2kparams
operator|->
name|data
argument_list|,
name|_krb5_AES_string_to_default_iterator
argument_list|,
name|ent
operator|->
name|s2kparams
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETYPE_DES_CBC_CRC
case|:
case|case
name|ETYPE_DES_CBC_MD4
case|:
case|case
name|ETYPE_DES_CBC_MD5
case|:
comment|/* Check if this was a AFS3 salted key */
if|if
condition|(
name|key
operator|->
name|salt
operator|&&
name|key
operator|->
name|salt
operator|->
name|type
operator|==
name|hdb_afs3_salt
condition|)
block|{
name|ALLOC
argument_list|(
name|ent
operator|->
name|s2kparams
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|s2kparams
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|ent
operator|->
name|s2kparams
operator|->
name|length
operator|=
literal|1
expr_stmt|;
name|ent
operator|->
name|s2kparams
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|ent
operator|->
name|s2kparams
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|s2kparams
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ent
operator|->
name|s2kparams
argument_list|)
expr_stmt|;
name|ent
operator|->
name|s2kparams
operator|=
name|NULL
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|_krb5_put_int
argument_list|(
name|ent
operator|->
name|s2kparams
operator|->
name|data
argument_list|,
literal|1
argument_list|,
name|ent
operator|->
name|s2kparams
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return an ETYPE-INFO2. Enctypes are storted the same way as in the  * database (client supported enctypes first, then the unsupported  * enctypes).  */
end_comment

begin_function
specifier|static
name|krb5_error_code
name|get_pa_etype_info2
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_kdc_configuration
modifier|*
name|config
parameter_list|,
name|METHOD_DATA
modifier|*
name|md
parameter_list|,
name|Key
modifier|*
name|ckey
parameter_list|)
block|{
name|krb5_error_code
name|ret
init|=
literal|0
decl_stmt|;
name|ETYPE_INFO2
name|pa
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|pa
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|pa
operator|.
name|val
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|pa
operator|.
name|val
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|.
name|val
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|ret
operator|=
name|make_etype_info2_entry
argument_list|(
operator|&
name|pa
operator|.
name|val
index|[
literal|0
index|]
argument_list|,
name|ckey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free_ETYPE_INFO2
argument_list|(
operator|&
name|pa
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ASN1_MALLOC_ENCODE
argument_list|(
name|ETYPE_INFO2
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|pa
argument_list|,
operator|&
name|len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|free_ETYPE_INFO2
argument_list|(
operator|&
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|realloc_method_data
argument_list|(
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|md
operator|->
name|val
index|[
name|md
operator|->
name|len
operator|-
literal|1
index|]
operator|.
name|padata_type
operator|=
name|KRB5_PADATA_ETYPE_INFO2
expr_stmt|;
name|md
operator|->
name|val
index|[
name|md
operator|->
name|len
operator|-
literal|1
index|]
operator|.
name|padata_value
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|md
operator|->
name|val
index|[
name|md
operator|->
name|len
operator|-
literal|1
index|]
operator|.
name|padata_value
operator|.
name|data
operator|=
name|buf
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|log_as_req
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_kdc_configuration
modifier|*
name|config
parameter_list|,
name|krb5_enctype
name|cetype
parameter_list|,
name|krb5_enctype
name|setype
parameter_list|,
specifier|const
name|KDC_REQ_BODY
modifier|*
name|b
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|struct
name|rk_strpool
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|p
operator|=
name|rk_strpoolprintf
argument_list|(
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"Client supported enctypes: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b
operator|->
name|etype
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|krb5_enctype_to_string
argument_list|(
name|context
argument_list|,
name|b
operator|->
name|etype
operator|.
name|val
index|[
name|i
index|]
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|rk_strpoolprintf
argument_list|(
name|p
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|rk_strpoolprintf
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
name|b
operator|->
name|etype
operator|.
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|i
operator|+
literal|1
operator|<
name|b
operator|->
name|etype
operator|.
name|len
condition|)
name|p
operator|=
name|rk_strpoolprintf
argument_list|(
name|p
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|rk_strpoolprintf
argument_list|(
name|p
argument_list|,
literal|"no encryption types"
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|cet
decl_stmt|;
name|char
modifier|*
name|set
decl_stmt|;
name|ret
operator|=
name|krb5_enctype_to_string
argument_list|(
name|context
argument_list|,
name|cetype
argument_list|,
operator|&
name|cet
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|krb5_enctype_to_string
argument_list|(
name|context
argument_list|,
name|setype
argument_list|,
operator|&
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|rk_strpoolprintf
argument_list|(
name|p
argument_list|,
literal|", using %s/%s"
argument_list|,
name|cet
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|cet
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|p
operator|=
name|rk_strpoolprintf
argument_list|(
name|p
argument_list|,
literal|", using enctypes %d/%d"
argument_list|,
name|cetype
argument_list|,
name|setype
argument_list|)
expr_stmt|;
block|}
name|str
operator|=
name|rk_strpoolcollect
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|{
name|char
name|fixedstr
index|[
literal|128
index|]
decl_stmt|;
name|unparse_flags
argument_list|(
name|KDCOptions2int
argument_list|(
name|b
operator|->
name|kdc_options
argument_list|)
argument_list|,
name|asn1_KDCOptions_units
argument_list|()
argument_list|,
name|fixedstr
argument_list|,
sizeof|sizeof
argument_list|(
name|fixedstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|fixedstr
condition|)
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Requested flags: %s"
argument_list|,
name|fixedstr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * verify the flags on `client' and `server', returning 0  * if they are OK and generating an error messages and returning  * and error code otherwise.  */
end_comment

begin_function
name|krb5_error_code
name|kdc_check_flags
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_kdc_configuration
modifier|*
name|config
parameter_list|,
name|hdb_entry_ex
modifier|*
name|client_ex
parameter_list|,
specifier|const
name|char
modifier|*
name|client_name
parameter_list|,
name|hdb_entry_ex
modifier|*
name|server_ex
parameter_list|,
specifier|const
name|char
modifier|*
name|server_name
parameter_list|,
name|krb5_boolean
name|is_as_req
parameter_list|)
block|{
if|if
condition|(
name|client_ex
operator|!=
name|NULL
condition|)
block|{
name|hdb_entry
modifier|*
name|client
init|=
operator|&
name|client_ex
operator|->
name|entry
decl_stmt|;
comment|/* check client */
if|if
condition|(
name|client
operator|->
name|flags
operator|.
name|locked_out
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Client (%s) is locked out"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
return|return
name|KRB5KDC_ERR_POLICY
return|;
block|}
if|if
condition|(
name|client
operator|->
name|flags
operator|.
name|invalid
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Client (%s) has invalid bit set"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
return|return
name|KRB5KDC_ERR_POLICY
return|;
block|}
if|if
condition|(
operator|!
name|client
operator|->
name|flags
operator|.
name|client
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Principal may not act as client -- %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
return|return
name|KRB5KDC_ERR_POLICY
return|;
block|}
if|if
condition|(
name|client
operator|->
name|valid_start
operator|&&
operator|*
name|client
operator|->
name|valid_start
operator|>
name|kdc_time
condition|)
block|{
name|char
name|starttime_str
index|[
literal|100
index|]
decl_stmt|;
name|krb5_format_time
argument_list|(
name|context
argument_list|,
operator|*
name|client
operator|->
name|valid_start
argument_list|,
name|starttime_str
argument_list|,
sizeof|sizeof
argument_list|(
name|starttime_str
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Client not yet valid until %s -- %s"
argument_list|,
name|starttime_str
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
return|return
name|KRB5KDC_ERR_CLIENT_NOTYET
return|;
block|}
if|if
condition|(
name|client
operator|->
name|valid_end
operator|&&
operator|*
name|client
operator|->
name|valid_end
operator|<
name|kdc_time
condition|)
block|{
name|char
name|endtime_str
index|[
literal|100
index|]
decl_stmt|;
name|krb5_format_time
argument_list|(
name|context
argument_list|,
operator|*
name|client
operator|->
name|valid_end
argument_list|,
name|endtime_str
argument_list|,
sizeof|sizeof
argument_list|(
name|endtime_str
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Client expired at %s -- %s"
argument_list|,
name|endtime_str
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
return|return
name|KRB5KDC_ERR_NAME_EXP
return|;
block|}
if|if
condition|(
name|client
operator|->
name|pw_end
operator|&&
operator|*
name|client
operator|->
name|pw_end
operator|<
name|kdc_time
operator|&&
operator|(
name|server_ex
operator|==
name|NULL
operator|||
operator|!
name|server_ex
operator|->
name|entry
operator|.
name|flags
operator|.
name|change_pw
operator|)
condition|)
block|{
name|char
name|pwend_str
index|[
literal|100
index|]
decl_stmt|;
name|krb5_format_time
argument_list|(
name|context
argument_list|,
operator|*
name|client
operator|->
name|pw_end
argument_list|,
name|pwend_str
argument_list|,
sizeof|sizeof
argument_list|(
name|pwend_str
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Client's key has expired at %s -- %s"
argument_list|,
name|pwend_str
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
return|return
name|KRB5KDC_ERR_KEY_EXPIRED
return|;
block|}
block|}
comment|/* check server */
if|if
condition|(
name|server_ex
operator|!=
name|NULL
condition|)
block|{
name|hdb_entry
modifier|*
name|server
init|=
operator|&
name|server_ex
operator|->
name|entry
decl_stmt|;
if|if
condition|(
name|server
operator|->
name|flags
operator|.
name|locked_out
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Client server locked out -- %s"
argument_list|,
name|server_name
argument_list|)
expr_stmt|;
return|return
name|KRB5KDC_ERR_POLICY
return|;
block|}
if|if
condition|(
name|server
operator|->
name|flags
operator|.
name|invalid
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Server has invalid flag set -- %s"
argument_list|,
name|server_name
argument_list|)
expr_stmt|;
return|return
name|KRB5KDC_ERR_POLICY
return|;
block|}
if|if
condition|(
operator|!
name|server
operator|->
name|flags
operator|.
name|server
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Principal may not act as server -- %s"
argument_list|,
name|server_name
argument_list|)
expr_stmt|;
return|return
name|KRB5KDC_ERR_POLICY
return|;
block|}
if|if
condition|(
operator|!
name|is_as_req
operator|&&
name|server
operator|->
name|flags
operator|.
name|initial
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"AS-REQ is required for server -- %s"
argument_list|,
name|server_name
argument_list|)
expr_stmt|;
return|return
name|KRB5KDC_ERR_POLICY
return|;
block|}
if|if
condition|(
name|server
operator|->
name|valid_start
operator|&&
operator|*
name|server
operator|->
name|valid_start
operator|>
name|kdc_time
condition|)
block|{
name|char
name|starttime_str
index|[
literal|100
index|]
decl_stmt|;
name|krb5_format_time
argument_list|(
name|context
argument_list|,
operator|*
name|server
operator|->
name|valid_start
argument_list|,
name|starttime_str
argument_list|,
sizeof|sizeof
argument_list|(
name|starttime_str
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Server not yet valid until %s -- %s"
argument_list|,
name|starttime_str
argument_list|,
name|server_name
argument_list|)
expr_stmt|;
return|return
name|KRB5KDC_ERR_SERVICE_NOTYET
return|;
block|}
if|if
condition|(
name|server
operator|->
name|valid_end
operator|&&
operator|*
name|server
operator|->
name|valid_end
operator|<
name|kdc_time
condition|)
block|{
name|char
name|endtime_str
index|[
literal|100
index|]
decl_stmt|;
name|krb5_format_time
argument_list|(
name|context
argument_list|,
operator|*
name|server
operator|->
name|valid_end
argument_list|,
name|endtime_str
argument_list|,
sizeof|sizeof
argument_list|(
name|endtime_str
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Server expired at %s -- %s"
argument_list|,
name|endtime_str
argument_list|,
name|server_name
argument_list|)
expr_stmt|;
return|return
name|KRB5KDC_ERR_SERVICE_EXP
return|;
block|}
if|if
condition|(
name|server
operator|->
name|pw_end
operator|&&
operator|*
name|server
operator|->
name|pw_end
operator|<
name|kdc_time
condition|)
block|{
name|char
name|pwend_str
index|[
literal|100
index|]
decl_stmt|;
name|krb5_format_time
argument_list|(
name|context
argument_list|,
operator|*
name|server
operator|->
name|pw_end
argument_list|,
name|pwend_str
argument_list|,
sizeof|sizeof
argument_list|(
name|pwend_str
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Server's key has expired at -- %s"
argument_list|,
name|pwend_str
argument_list|,
name|server_name
argument_list|)
expr_stmt|;
return|return
name|KRB5KDC_ERR_KEY_EXPIRED
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return TRUE if `from' is part of `addresses' taking into consideration  * the configuration variables that tells us how strict we should be about  * these checks  */
end_comment

begin_function
name|krb5_boolean
name|_kdc_check_addresses
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_kdc_configuration
modifier|*
name|config
parameter_list|,
name|HostAddresses
modifier|*
name|addresses
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|from
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_address
name|addr
decl_stmt|;
name|krb5_boolean
name|result
decl_stmt|;
name|krb5_boolean
name|only_netbios
init|=
name|TRUE
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|config
operator|->
name|check_ticket_addresses
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|addresses
operator|==
name|NULL
condition|)
return|return
name|config
operator|->
name|allow_null_ticket_addresses
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addresses
operator|->
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|addresses
operator|->
name|val
index|[
name|i
index|]
operator|.
name|addr_type
operator|!=
name|KRB5_ADDRESS_NETBIOS
condition|)
block|{
name|only_netbios
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/* Windows sends it's netbios name, which I can only assume is      * used for the 'allowed workstations' check.  This is painful,      * but we still want to check IP addresses if they happen to be      * present.      */
if|if
condition|(
name|only_netbios
condition|)
return|return
name|config
operator|->
name|allow_null_ticket_addresses
return|;
name|ret
operator|=
name|krb5_sockaddr2address
argument_list|(
name|context
argument_list|,
name|from
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|FALSE
return|;
name|result
operator|=
name|krb5_address_search
argument_list|(
name|context
argument_list|,
operator|&
name|addr
argument_list|,
name|addresses
argument_list|)
expr_stmt|;
name|krb5_free_address
argument_list|(
name|context
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|krb5_boolean
name|send_pac_p
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|KDC_REQ
modifier|*
name|req
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|PA_PAC_REQUEST
name|pacreq
decl_stmt|;
specifier|const
name|PA_DATA
modifier|*
name|pa
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|pa
operator|=
name|_kdc_find_padata
argument_list|(
name|req
argument_list|,
operator|&
name|i
argument_list|,
name|KRB5_PADATA_PA_PAC_REQUEST
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|ret
operator|=
name|decode_PA_PAC_REQUEST
argument_list|(
name|pa
operator|->
name|padata_value
operator|.
name|data
argument_list|,
name|pa
operator|->
name|padata_value
operator|.
name|length
argument_list|,
operator|&
name|pacreq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|TRUE
return|;
name|i
operator|=
name|pacreq
operator|.
name|include_pac
expr_stmt|;
name|free_PA_PAC_REQUEST
argument_list|(
operator|&
name|pacreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|krb5_boolean
name|_kdc_is_anonymous
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_principal
name|principal
parameter_list|)
block|{
if|if
condition|(
name|principal
operator|->
name|name
operator|.
name|name_type
operator|!=
name|KRB5_NT_WELLKNOWN
operator|||
name|principal
operator|->
name|name
operator|.
name|name_string
operator|.
name|len
operator|!=
literal|2
operator|||
name|strcmp
argument_list|(
name|principal
operator|->
name|name
operator|.
name|name_string
operator|.
name|val
index|[
literal|0
index|]
argument_list|,
name|KRB5_WELLKNOWN_NAME
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|principal
operator|->
name|name
operator|.
name|name_string
operator|.
name|val
index|[
literal|1
index|]
argument_list|,
name|KRB5_ANON_NAME
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|krb5_error_code
name|_kdc_as_rep
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_kdc_configuration
modifier|*
name|config
parameter_list|,
name|KDC_REQ
modifier|*
name|req
parameter_list|,
specifier|const
name|krb5_data
modifier|*
name|req_buffer
parameter_list|,
name|krb5_data
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|from_addr
parameter_list|,
name|int
name|datagram_reply
parameter_list|)
block|{
name|KDC_REQ_BODY
modifier|*
name|b
init|=
operator|&
name|req
operator|->
name|req_body
decl_stmt|;
name|AS_REP
name|rep
decl_stmt|;
name|KDCOptions
name|f
init|=
name|b
operator|->
name|kdc_options
decl_stmt|;
name|hdb_entry_ex
modifier|*
name|client
init|=
name|NULL
decl_stmt|,
modifier|*
name|server
init|=
name|NULL
decl_stmt|;
name|HDB
modifier|*
name|clientdb
decl_stmt|;
name|krb5_enctype
name|setype
decl_stmt|,
name|sessionetype
decl_stmt|;
name|krb5_data
name|e_data
decl_stmt|;
name|EncTicketPart
name|et
decl_stmt|;
name|EncKDCRepPart
name|ek
decl_stmt|;
name|krb5_principal
name|client_princ
init|=
name|NULL
decl_stmt|,
name|server_princ
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|client_name
init|=
name|NULL
decl_stmt|,
modifier|*
name|server_name
init|=
name|NULL
decl_stmt|;
name|krb5_error_code
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|e_text
init|=
name|NULL
decl_stmt|;
name|krb5_crypto
name|crypto
decl_stmt|;
name|Key
modifier|*
name|ckey
decl_stmt|,
modifier|*
name|skey
decl_stmt|;
name|EncryptionKey
modifier|*
name|reply_key
init|=
name|NULL
decl_stmt|,
name|session_key
decl_stmt|;
name|int
name|flags
init|=
name|HDB_F_FOR_AS_REQ
decl_stmt|;
ifdef|#
directive|ifdef
name|PKINIT
name|pk_client_params
modifier|*
name|pkp
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|rep
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rep
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|session_key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|session_key
argument_list|)
argument_list|)
expr_stmt|;
name|krb5_data_zero
argument_list|(
operator|&
name|e_data
argument_list|)
expr_stmt|;
name|ALLOC
argument_list|(
name|rep
operator|.
name|padata
argument_list|)
expr_stmt|;
name|rep
operator|.
name|padata
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|rep
operator|.
name|padata
operator|->
name|val
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|canonicalize
condition|)
name|flags
operator||=
name|HDB_F_CANON
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|sname
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|KRB5KRB_ERR_GENERIC
expr_stmt|;
name|e_text
operator|=
literal|"No server in request"
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|_krb5_principalname2krb5_principal
argument_list|(
name|context
argument_list|,
operator|&
name|server_princ
argument_list|,
operator|*
operator|(
name|b
operator|->
name|sname
operator|)
argument_list|,
name|b
operator|->
name|realm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|ret
operator|=
name|krb5_unparse_name
argument_list|(
name|context
argument_list|,
name|server_princ
argument_list|,
operator|&
name|server_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"AS-REQ malformed server name from %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|b
operator|->
name|cname
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|KRB5KRB_ERR_GENERIC
expr_stmt|;
name|e_text
operator|=
literal|"No client in request"
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|_krb5_principalname2krb5_principal
argument_list|(
name|context
argument_list|,
operator|&
name|client_princ
argument_list|,
operator|*
operator|(
name|b
operator|->
name|cname
operator|)
argument_list|,
name|b
operator|->
name|realm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|krb5_unparse_name
argument_list|(
name|context
argument_list|,
name|client_princ
argument_list|,
operator|&
name|client_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"AS-REQ malformed client name from %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"AS-REQ %s from %s for %s"
argument_list|,
name|client_name
argument_list|,
name|from
argument_list|,
name|server_name
argument_list|)
expr_stmt|;
comment|/*      *      */
if|if
condition|(
name|_kdc_is_anonymous
argument_list|(
name|context
argument_list|,
name|client_princ
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|b
operator|->
name|kdc_options
operator|.
name|request_anonymous
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Anonymous ticket w/o anonymous flag"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|kdc_options
operator|.
name|request_anonymous
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Request for a anonymous ticket with non "
literal|"anonymous client name: %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      *      */
name|ret
operator|=
name|_kdc_db_fetch
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
name|client_princ
argument_list|,
name|HDB_F_GET_CLIENT
operator||
name|flags
argument_list|,
name|NULL
argument_list|,
operator|&
name|clientdb
argument_list|,
operator|&
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|HDB_ERR_NOT_FOUND_HERE
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|5
argument_list|,
literal|"client %s does not have secrets at this KDC, need to proxy"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|ret
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|krb5_get_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|)
decl_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"UNKNOWN -- %s: %s"
argument_list|,
name|client_name
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|krb5_free_error_message
argument_list|(
name|context
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|ret
operator|=
name|KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|_kdc_db_fetch
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
name|server_princ
argument_list|,
name|HDB_F_GET_SERVER
operator||
name|HDB_F_GET_KRBTGT
operator||
name|flags
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|HDB_ERR_NOT_FOUND_HERE
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|5
argument_list|,
literal|"target %s does not have secrets at this KDC, need to proxy"
argument_list|,
name|server_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|ret
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|krb5_get_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|)
decl_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"UNKNOWN -- %s: %s"
argument_list|,
name|server_name
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|krb5_free_error_message
argument_list|(
name|context
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|ret
operator|=
name|KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memset
argument_list|(
operator|&
name|et
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|et
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ek
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ek
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Select a session enctype from the list of the crypto system      * supported enctypes that is supported by the client and is one of      * the enctype of the enctype of the service (likely krbtgt).      *      * The latter is used as a hint of what enctypes all KDC support,      * to make sure a newer version of KDC won't generate a session      * enctype that an older version of a KDC in the same realm can't      * decrypt.      */
name|ret
operator|=
name|_kdc_find_etype
argument_list|(
name|context
argument_list|,
name|krb5_principal_is_krbtgt
argument_list|(
name|context
argument_list|,
name|server_princ
argument_list|)
condition|?
name|config
operator|->
name|tgt_use_strongest_session_key
else|:
name|config
operator|->
name|svc_use_strongest_session_key
argument_list|,
name|FALSE
argument_list|,
name|client
argument_list|,
name|b
operator|->
name|etype
operator|.
name|val
argument_list|,
name|b
operator|->
name|etype
operator|.
name|len
argument_list|,
operator|&
name|sessionetype
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Client (%s) from %s has no common enctypes with KDC "
literal|"to use for the session key"
argument_list|,
name|client_name
argument_list|,
name|from
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * But if the KDC admin is paranoid and doesn't want to have "not      * the best" enctypes on the krbtgt, lets save the best pick from      * the client list and hope that that will work for any other      * KDCs.      */
comment|/*      * Pre-auth processing      */
if|if
condition|(
name|req
operator|->
name|padata
condition|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|PA_DATA
modifier|*
name|pa
decl_stmt|;
name|int
name|found_pa
init|=
literal|0
decl_stmt|;
name|log_patypes
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
name|req
operator|->
name|padata
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PKINIT
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|5
argument_list|,
literal|"Looking for PKINIT pa-data -- %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
name|e_text
operator|=
literal|"No PKINIT PA found"
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|pa
operator|=
name|_kdc_find_padata
argument_list|(
name|req
argument_list|,
operator|&
name|i
argument_list|,
name|KRB5_PADATA_PK_AS_REQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|pa
operator|=
name|_kdc_find_padata
argument_list|(
name|req
argument_list|,
operator|&
name|i
argument_list|,
name|KRB5_PADATA_PK_AS_REQ_WIN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pa
condition|)
block|{
name|char
modifier|*
name|client_cert
init|=
name|NULL
decl_stmt|;
name|ret
operator|=
name|_kdc_pk_rd_padata
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
name|req
argument_list|,
name|pa
argument_list|,
name|client
argument_list|,
operator|&
name|pkp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ret
operator|=
name|KRB5KRB_AP_ERR_BAD_INTEGRITY
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|5
argument_list|,
literal|"Failed to decode PKINIT PA-DATA -- %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
goto|goto
name|ts_enc
goto|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|pkp
operator|==
name|NULL
condition|)
goto|goto
name|ts_enc
goto|;
name|ret
operator|=
name|_kdc_pk_check_client
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
name|clientdb
argument_list|,
name|client
argument_list|,
name|pkp
argument_list|,
operator|&
name|client_cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|e_text
operator|=
literal|"PKINIT certificate not allowed to "
literal|"impersonate principal"
expr_stmt|;
name|_kdc_pk_free_client_param
argument_list|(
name|context
argument_list|,
name|pkp
argument_list|)
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|e_text
argument_list|)
expr_stmt|;
name|pkp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|found_pa
operator|=
literal|1
expr_stmt|;
name|et
operator|.
name|flags
operator|.
name|pre_authent
operator|=
literal|1
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"PKINIT pre-authentication succeeded -- %s using %s"
argument_list|,
name|client_name
argument_list|,
name|client_cert
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|client_cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkp
condition|)
goto|goto
name|preauth_done
goto|;
block|}
name|ts_enc
label|:
endif|#
directive|endif
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|5
argument_list|,
literal|"Looking for ENC-TS pa-data -- %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|e_text
operator|=
literal|"No ENC-TS found"
expr_stmt|;
while|while
condition|(
operator|(
name|pa
operator|=
name|_kdc_find_padata
argument_list|(
name|req
argument_list|,
operator|&
name|i
argument_list|,
name|KRB5_PADATA_ENC_TIMESTAMP
argument_list|)
operator|)
condition|)
block|{
name|krb5_data
name|ts_data
decl_stmt|;
name|PA_ENC_TS_ENC
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|EncryptedData
name|enc_data
decl_stmt|;
name|Key
modifier|*
name|pa_key
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|found_pa
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|kdc_options
operator|.
name|request_anonymous
condition|)
block|{
name|ret
operator|=
name|KRB5KRB_AP_ERR_BAD_INTEGRITY
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"ENC-TS doesn't support anon"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|decode_EncryptedData
argument_list|(
name|pa
operator|->
name|padata_value
operator|.
name|data
argument_list|,
name|pa
operator|->
name|padata_value
operator|.
name|length
argument_list|,
operator|&
name|enc_data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ret
operator|=
name|KRB5KRB_AP_ERR_BAD_INTEGRITY
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|5
argument_list|,
literal|"Failed to decode PA-DATA -- %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|hdb_enctype2key
argument_list|(
name|context
argument_list|,
operator|&
name|client
operator|->
name|entry
argument_list|,
name|enc_data
operator|.
name|etype
argument_list|,
operator|&
name|pa_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|char
modifier|*
name|estr
decl_stmt|;
name|e_text
operator|=
literal|"No key matches pa-data"
expr_stmt|;
name|ret
operator|=
name|KRB5KDC_ERR_ETYPE_NOSUPP
expr_stmt|;
if|if
condition|(
name|krb5_enctype_to_string
argument_list|(
name|context
argument_list|,
name|enc_data
operator|.
name|etype
argument_list|,
operator|&
name|estr
argument_list|)
condition|)
name|estr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|estr
operator|==
name|NULL
condition|)
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|5
argument_list|,
literal|"No client key matching pa-data (%d) -- %s"
argument_list|,
name|enc_data
operator|.
name|etype
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
else|else
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|5
argument_list|,
literal|"No client key matching pa-data (%s) -- %s"
argument_list|,
name|estr
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|estr
argument_list|)
expr_stmt|;
name|free_EncryptedData
argument_list|(
operator|&
name|enc_data
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|try_next_key
label|:
name|ret
operator|=
name|krb5_crypto_init
argument_list|(
name|context
argument_list|,
operator|&
name|pa_key
operator|->
name|key
argument_list|,
literal|0
argument_list|,
operator|&
name|crypto
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|krb5_get_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|)
decl_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"krb5_crypto_init failed: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|krb5_free_error_message
argument_list|(
name|context
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|free_EncryptedData
argument_list|(
operator|&
name|enc_data
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ret
operator|=
name|krb5_decrypt_EncryptedData
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|KRB5_KU_PA_ENC_TIMESTAMP
argument_list|,
operator|&
name|enc_data
argument_list|,
operator|&
name|ts_data
argument_list|)
expr_stmt|;
name|krb5_crypto_destroy
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
expr_stmt|;
comment|/* 	     * Since the user might have several keys with the same 	     * enctype but with diffrent salting, we need to try all 	     * the keys with the same enctype. 	     */
if|if
condition|(
name|ret
condition|)
block|{
name|krb5_error_code
name|ret2
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
name|krb5_get_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|)
decl_stmt|;
name|ret2
operator|=
name|krb5_enctype_to_string
argument_list|(
name|context
argument_list|,
name|pa_key
operator|->
name|key
operator|.
name|keytype
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret2
condition|)
name|str
operator|=
name|NULL
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|5
argument_list|,
literal|"Failed to decrypt PA-DATA -- %s "
literal|"(enctype %s) error %s"
argument_list|,
name|client_name
argument_list|,
name|str
condition|?
name|str
else|:
literal|"unknown enctype"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|krb5_free_error_message
argument_list|(
name|context
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdb_next_enctype2key
argument_list|(
name|context
argument_list|,
operator|&
name|client
operator|->
name|entry
argument_list|,
name|enc_data
operator|.
name|etype
argument_list|,
operator|&
name|pa_key
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|try_next_key
goto|;
name|e_text
operator|=
literal|"Failed to decrypt PA-DATA"
expr_stmt|;
name|free_EncryptedData
argument_list|(
operator|&
name|enc_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|clientdb
operator|->
name|hdb_auth_status
condition|)
call|(
name|clientdb
operator|->
name|hdb_auth_status
call|)
argument_list|(
name|context
argument_list|,
name|clientdb
argument_list|,
name|client
argument_list|,
name|HDB_AUTH_WRONG_PASSWORD
argument_list|)
expr_stmt|;
name|ret
operator|=
name|KRB5KDC_ERR_PREAUTH_FAILED
expr_stmt|;
continue|continue;
block|}
name|free_EncryptedData
argument_list|(
operator|&
name|enc_data
argument_list|)
expr_stmt|;
name|ret
operator|=
name|decode_PA_ENC_TS_ENC
argument_list|(
name|ts_data
operator|.
name|data
argument_list|,
name|ts_data
operator|.
name|length
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|krb5_data_free
argument_list|(
operator|&
name|ts_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|e_text
operator|=
literal|"Failed to decode PA-ENC-TS-ENC"
expr_stmt|;
name|ret
operator|=
name|KRB5KDC_ERR_PREAUTH_FAILED
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|5
argument_list|,
literal|"Failed to decode PA-ENC-TS_ENC -- %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|free_PA_ENC_TS_ENC
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|kdc_time
operator|-
name|p
operator|.
name|patimestamp
argument_list|)
operator|>
name|context
operator|->
name|max_skew
condition|)
block|{
name|char
name|client_time
index|[
literal|100
index|]
decl_stmt|;
name|krb5_format_time
argument_list|(
name|context
argument_list|,
name|p
operator|.
name|patimestamp
argument_list|,
name|client_time
argument_list|,
sizeof|sizeof
argument_list|(
name|client_time
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|KRB5KRB_AP_ERR_SKEW
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Too large time skew, "
literal|"client time %s is out by %u> %u seconds -- %s"
argument_list|,
name|client_time
argument_list|,
operator|(
name|unsigned
operator|)
name|abs
argument_list|(
name|kdc_time
operator|-
name|p
operator|.
name|patimestamp
argument_list|)
argument_list|,
name|context
operator|->
name|max_skew
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
comment|/* 		 * The following is needed to make windows clients to 		 * retry using the timestamp in the error message, if 		 * there is a e_text, they become unhappy. 		 */
name|e_text
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|et
operator|.
name|flags
operator|.
name|pre_authent
operator|=
literal|1
expr_stmt|;
name|set_salt_padata
argument_list|(
name|rep
operator|.
name|padata
argument_list|,
name|pa_key
operator|->
name|salt
argument_list|)
expr_stmt|;
name|reply_key
operator|=
operator|&
name|pa_key
operator|->
name|key
expr_stmt|;
name|ret
operator|=
name|krb5_enctype_to_string
argument_list|(
name|context
argument_list|,
name|pa_key
operator|->
name|key
operator|.
name|keytype
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|str
operator|=
name|NULL
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|2
argument_list|,
literal|"ENC-TS Pre-authentication succeeded -- %s using %s"
argument_list|,
name|client_name
argument_list|,
name|str
condition|?
name|str
else|:
literal|"unknown enctype"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|PKINIT
name|preauth_done
label|:
endif|#
directive|endif
if|if
condition|(
name|found_pa
operator|==
literal|0
operator|&&
name|config
operator|->
name|require_preauth
condition|)
goto|goto
name|use_pa
goto|;
comment|/* We come here if we found a pa-enc-timestamp, but if there            was some problem with it, other than too large skew */
if|if
condition|(
name|found_pa
operator|&&
name|et
operator|.
name|flags
operator|.
name|pre_authent
operator|==
literal|0
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"%s -- %s"
argument_list|,
name|e_text
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
name|e_text
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|config
operator|->
name|require_preauth
operator|||
name|b
operator|->
name|kdc_options
operator|.
name|request_anonymous
comment|/* hack to force anon */
operator|||
name|client
operator|->
name|entry
operator|.
name|flags
operator|.
name|require_preauth
operator|||
name|server
operator|->
name|entry
operator|.
name|flags
operator|.
name|require_preauth
condition|)
block|{
name|METHOD_DATA
name|method_data
decl_stmt|;
name|PA_DATA
modifier|*
name|pa
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|use_pa
label|:
name|method_data
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|method_data
operator|.
name|val
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|realloc_method_data
argument_list|(
operator|&
name|method_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free_METHOD_DATA
argument_list|(
operator|&
name|method_data
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pa
operator|=
operator|&
name|method_data
operator|.
name|val
index|[
name|method_data
operator|.
name|len
operator|-
literal|1
index|]
expr_stmt|;
name|pa
operator|->
name|padata_type
operator|=
name|KRB5_PADATA_ENC_TIMESTAMP
expr_stmt|;
name|pa
operator|->
name|padata_value
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|pa
operator|->
name|padata_value
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|PKINIT
name|ret
operator|=
name|realloc_method_data
argument_list|(
operator|&
name|method_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free_METHOD_DATA
argument_list|(
operator|&
name|method_data
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pa
operator|=
operator|&
name|method_data
operator|.
name|val
index|[
name|method_data
operator|.
name|len
operator|-
literal|1
index|]
expr_stmt|;
name|pa
operator|->
name|padata_type
operator|=
name|KRB5_PADATA_PK_AS_REQ
expr_stmt|;
name|pa
operator|->
name|padata_value
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|pa
operator|->
name|padata_value
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|realloc_method_data
argument_list|(
operator|&
name|method_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free_METHOD_DATA
argument_list|(
operator|&
name|method_data
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pa
operator|=
operator|&
name|method_data
operator|.
name|val
index|[
name|method_data
operator|.
name|len
operator|-
literal|1
index|]
expr_stmt|;
name|pa
operator|->
name|padata_type
operator|=
name|KRB5_PADATA_PK_AS_REQ_WIN
expr_stmt|;
name|pa
operator|->
name|padata_value
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|pa
operator|->
name|padata_value
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If there is a client key, send ETYPE_INFO{,2} 	 */
name|ret
operator|=
name|_kdc_find_etype
argument_list|(
name|context
argument_list|,
name|config
operator|->
name|preauth_use_strongest_session_key
argument_list|,
name|TRUE
argument_list|,
name|client
argument_list|,
name|b
operator|->
name|etype
operator|.
name|val
argument_list|,
name|b
operator|->
name|etype
operator|.
name|len
argument_list|,
name|NULL
argument_list|,
operator|&
name|ckey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* 	     * RFC4120 requires: 	     * - If the client only knows about old enctypes, then send 	     *   both info replies (we send 'info' first in the list). 	     * - If the client is 'modern', because it knows about 'new' 	     *   enctype types, then only send the 'info2' reply. 	     * 	     * Before we send the full list of etype-info data, we pick 	     * the client key we would have used anyway below, just pick 	     * that instead. 	     */
if|if
condition|(
name|older_enctype
argument_list|(
name|ckey
operator|->
name|key
operator|.
name|keytype
argument_list|)
condition|)
block|{
name|ret
operator|=
name|get_pa_etype_info
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
operator|&
name|method_data
argument_list|,
name|ckey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free_METHOD_DATA
argument_list|(
operator|&
name|method_data
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret
operator|=
name|get_pa_etype_info2
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
operator|&
name|method_data
argument_list|,
name|ckey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free_METHOD_DATA
argument_list|(
operator|&
name|method_data
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ASN1_MALLOC_ENCODE
argument_list|(
name|METHOD_DATA
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|method_data
argument_list|,
operator|&
name|len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|free_METHOD_DATA
argument_list|(
operator|&
name|method_data
argument_list|)
expr_stmt|;
name|e_data
operator|.
name|data
operator|=
name|buf
expr_stmt|;
name|e_data
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|e_text
operator|=
literal|"Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ"
operator|,
name|ret
operator|=
name|KRB5KDC_ERR_PREAUTH_REQUIRED
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"No preauth found, returning PREAUTH-REQUIRED -- %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|clientdb
operator|->
name|hdb_auth_status
condition|)
call|(
name|clientdb
operator|->
name|hdb_auth_status
call|)
argument_list|(
name|context
argument_list|,
name|clientdb
argument_list|,
name|client
argument_list|,
name|HDB_AUTH_SUCCESS
argument_list|)
expr_stmt|;
comment|/*      * Verify flags after the user been required to prove its identity      * with in a preauth mech.      */
name|ret
operator|=
name|_kdc_check_access
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
name|client
argument_list|,
name|client_name
argument_list|,
name|server
argument_list|,
name|server_name
argument_list|,
name|req
argument_list|,
operator|&
name|e_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
comment|/*      * Selelct the best encryption type for the KDC with out regard to      * the client since the client never needs to read that data.      */
name|ret
operator|=
name|_kdc_get_preferred_key
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
name|server
argument_list|,
name|server_name
argument_list|,
operator|&
name|setype
argument_list|,
operator|&
name|skey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|f
operator|.
name|renew
operator|||
name|f
operator|.
name|validate
operator|||
name|f
operator|.
name|proxy
operator|||
name|f
operator|.
name|forwarded
operator|||
name|f
operator|.
name|enc_tkt_in_skey
operator|||
operator|(
name|f
operator|.
name|request_anonymous
operator|&&
operator|!
name|config
operator|->
name|allow_anonymous
operator|)
condition|)
block|{
name|ret
operator|=
name|KRB5KDC_ERR_BADOPTION
expr_stmt|;
name|e_text
operator|=
literal|"Bad KDC options"
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Bad KDC options -- %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rep
operator|.
name|pvno
operator|=
literal|5
expr_stmt|;
name|rep
operator|.
name|msg_type
operator|=
name|krb_as_rep
expr_stmt|;
name|ret
operator|=
name|copy_Realm
argument_list|(
operator|&
name|client
operator|->
name|entry
operator|.
name|principal
operator|->
name|realm
argument_list|,
operator|&
name|rep
operator|.
name|crealm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|_krb5_principal2principalname
argument_list|(
operator|&
name|rep
operator|.
name|cname
argument_list|,
name|client
operator|->
name|entry
operator|.
name|principal
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|rep
operator|.
name|ticket
operator|.
name|tkt_vno
operator|=
literal|5
expr_stmt|;
name|copy_Realm
argument_list|(
operator|&
name|server
operator|->
name|entry
operator|.
name|principal
operator|->
name|realm
argument_list|,
operator|&
name|rep
operator|.
name|ticket
operator|.
name|realm
argument_list|)
expr_stmt|;
name|_krb5_principal2principalname
argument_list|(
operator|&
name|rep
operator|.
name|ticket
operator|.
name|sname
argument_list|,
name|server
operator|->
name|entry
operator|.
name|principal
argument_list|)
expr_stmt|;
comment|/* java 1.6 expects the name to be the same type, lets allow that      * uncomplicated name-types. */
define|#
directive|define
name|CNT
parameter_list|(
name|sp
parameter_list|,
name|t
parameter_list|)
value|(((sp)->sname->name_type) == KRB5_NT_##t)
if|if
condition|(
name|CNT
argument_list|(
name|b
argument_list|,
name|UNKNOWN
argument_list|)
operator|||
name|CNT
argument_list|(
name|b
argument_list|,
name|PRINCIPAL
argument_list|)
operator|||
name|CNT
argument_list|(
name|b
argument_list|,
name|SRV_INST
argument_list|)
operator|||
name|CNT
argument_list|(
name|b
argument_list|,
name|SRV_HST
argument_list|)
operator|||
name|CNT
argument_list|(
name|b
argument_list|,
name|SRV_XHST
argument_list|)
condition|)
name|rep
operator|.
name|ticket
operator|.
name|sname
operator|.
name|name_type
operator|=
name|b
operator|->
name|sname
operator|->
name|name_type
expr_stmt|;
undef|#
directive|undef
name|CNT
name|et
operator|.
name|flags
operator|.
name|initial
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|entry
operator|.
name|flags
operator|.
name|forwardable
operator|&&
name|server
operator|->
name|entry
operator|.
name|flags
operator|.
name|forwardable
condition|)
name|et
operator|.
name|flags
operator|.
name|forwardable
operator|=
name|f
operator|.
name|forwardable
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|.
name|forwardable
condition|)
block|{
name|e_text
operator|=
literal|"Ticket may not be forwardable"
expr_stmt|;
name|ret
operator|=
name|KRB5KDC_ERR_POLICY
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Ticket may not be forwardable -- %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|client
operator|->
name|entry
operator|.
name|flags
operator|.
name|proxiable
operator|&&
name|server
operator|->
name|entry
operator|.
name|flags
operator|.
name|proxiable
condition|)
name|et
operator|.
name|flags
operator|.
name|proxiable
operator|=
name|f
operator|.
name|proxiable
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|.
name|proxiable
condition|)
block|{
name|e_text
operator|=
literal|"Ticket may not be proxiable"
expr_stmt|;
name|ret
operator|=
name|KRB5KDC_ERR_POLICY
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Ticket may not be proxiable -- %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|client
operator|->
name|entry
operator|.
name|flags
operator|.
name|postdate
operator|&&
name|server
operator|->
name|entry
operator|.
name|flags
operator|.
name|postdate
condition|)
name|et
operator|.
name|flags
operator|.
name|may_postdate
operator|=
name|f
operator|.
name|allow_postdate
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|.
name|allow_postdate
condition|)
block|{
name|e_text
operator|=
literal|"Ticket may not be postdate"
expr_stmt|;
name|ret
operator|=
name|KRB5KDC_ERR_POLICY
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Ticket may not be postdatable -- %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* check for valid set of addresses */
if|if
condition|(
operator|!
name|_kdc_check_addresses
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
name|b
operator|->
name|addresses
argument_list|,
name|from_addr
argument_list|)
condition|)
block|{
name|e_text
operator|=
literal|"Bad address list in requested"
expr_stmt|;
name|ret
operator|=
name|KRB5KRB_AP_ERR_BADADDR
expr_stmt|;
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"Bad address list requested -- %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|copy_PrincipalName
argument_list|(
operator|&
name|rep
operator|.
name|cname
argument_list|,
operator|&
name|et
operator|.
name|cname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|copy_Realm
argument_list|(
operator|&
name|rep
operator|.
name|crealm
argument_list|,
operator|&
name|et
operator|.
name|crealm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|{
name|time_t
name|start
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|start
operator|=
name|et
operator|.
name|authtime
operator|=
name|kdc_time
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|postdated
operator|&&
name|req
operator|->
name|req_body
operator|.
name|from
condition|)
block|{
name|ALLOC
argument_list|(
name|et
operator|.
name|starttime
argument_list|)
expr_stmt|;
name|start
operator|=
operator|*
name|et
operator|.
name|starttime
operator|=
operator|*
name|req
operator|->
name|req_body
operator|.
name|from
expr_stmt|;
name|et
operator|.
name|flags
operator|.
name|invalid
operator|=
literal|1
expr_stmt|;
name|et
operator|.
name|flags
operator|.
name|postdated
operator|=
literal|1
expr_stmt|;
comment|/* XXX ??? */
block|}
name|_kdc_fix_time
argument_list|(
operator|&
name|b
operator|->
name|till
argument_list|)
expr_stmt|;
name|t
operator|=
operator|*
name|b
operator|->
name|till
expr_stmt|;
comment|/* be careful not overflowing */
if|if
condition|(
name|client
operator|->
name|entry
operator|.
name|max_life
condition|)
name|t
operator|=
name|start
operator|+
name|min
argument_list|(
name|t
operator|-
name|start
argument_list|,
operator|*
name|client
operator|->
name|entry
operator|.
name|max_life
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|->
name|entry
operator|.
name|max_life
condition|)
name|t
operator|=
name|start
operator|+
name|min
argument_list|(
name|t
operator|-
name|start
argument_list|,
operator|*
name|server
operator|->
name|entry
operator|.
name|max_life
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|t = min(t, start + realm->max_life);
endif|#
directive|endif
name|et
operator|.
name|endtime
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|renewable_ok
operator|&&
name|et
operator|.
name|endtime
operator|<
operator|*
name|b
operator|->
name|till
condition|)
block|{
name|f
operator|.
name|renewable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|rtime
operator|==
name|NULL
condition|)
block|{
name|ALLOC
argument_list|(
name|b
operator|->
name|rtime
argument_list|)
expr_stmt|;
operator|*
name|b
operator|->
name|rtime
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|b
operator|->
name|rtime
operator|<
operator|*
name|b
operator|->
name|till
condition|)
operator|*
name|b
operator|->
name|rtime
operator|=
operator|*
name|b
operator|->
name|till
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|.
name|renewable
operator|&&
name|b
operator|->
name|rtime
condition|)
block|{
name|t
operator|=
operator|*
name|b
operator|->
name|rtime
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|t
operator|=
name|MAX_TIME
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|entry
operator|.
name|max_renew
condition|)
name|t
operator|=
name|start
operator|+
name|min
argument_list|(
name|t
operator|-
name|start
argument_list|,
operator|*
name|client
operator|->
name|entry
operator|.
name|max_renew
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|->
name|entry
operator|.
name|max_renew
condition|)
name|t
operator|=
name|start
operator|+
name|min
argument_list|(
name|t
operator|-
name|start
argument_list|,
operator|*
name|server
operator|->
name|entry
operator|.
name|max_renew
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|t = min(t, start + realm->max_renew);
endif|#
directive|endif
name|ALLOC
argument_list|(
name|et
operator|.
name|renew_till
argument_list|)
expr_stmt|;
operator|*
name|et
operator|.
name|renew_till
operator|=
name|t
expr_stmt|;
name|et
operator|.
name|flags
operator|.
name|renewable
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|f
operator|.
name|request_anonymous
condition|)
name|et
operator|.
name|flags
operator|.
name|anonymous
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|addresses
condition|)
block|{
name|ALLOC
argument_list|(
name|et
operator|.
name|caddr
argument_list|)
expr_stmt|;
name|copy_HostAddresses
argument_list|(
name|b
operator|->
name|addresses
argument_list|,
name|et
operator|.
name|caddr
argument_list|)
expr_stmt|;
block|}
name|et
operator|.
name|transited
operator|.
name|tr_type
operator|=
name|DOMAIN_X500_COMPRESS
expr_stmt|;
name|krb5_data_zero
argument_list|(
operator|&
name|et
operator|.
name|transited
operator|.
name|contents
argument_list|)
expr_stmt|;
comment|/* The MIT ASN.1 library (obviously) doesn't tell lengths encoded      * as 0 and as 0x80 (meaning indefinite length) apart, and is thus      * incapable of correctly decoding SEQUENCE OF's of zero length.      *      * To fix this, always send at least one no-op last_req      *      * If there's a pw_end or valid_end we will use that,      * otherwise just a dummy lr.      */
name|ek
operator|.
name|last_req
operator|.
name|val
operator|=
name|malloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ek
operator|.
name|last_req
operator|.
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ek
operator|.
name|last_req
operator|.
name|val
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ek
operator|.
name|last_req
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|entry
operator|.
name|pw_end
operator|&&
operator|(
name|config
operator|->
name|kdc_warn_pwexpire
operator|==
literal|0
operator|||
name|kdc_time
operator|+
name|config
operator|->
name|kdc_warn_pwexpire
operator|>=
operator|*
name|client
operator|->
name|entry
operator|.
name|pw_end
operator|)
condition|)
block|{
name|ek
operator|.
name|last_req
operator|.
name|val
index|[
name|ek
operator|.
name|last_req
operator|.
name|len
index|]
operator|.
name|lr_type
operator|=
name|LR_PW_EXPTIME
expr_stmt|;
name|ek
operator|.
name|last_req
operator|.
name|val
index|[
name|ek
operator|.
name|last_req
operator|.
name|len
index|]
operator|.
name|lr_value
operator|=
operator|*
name|client
operator|->
name|entry
operator|.
name|pw_end
expr_stmt|;
operator|++
name|ek
operator|.
name|last_req
operator|.
name|len
expr_stmt|;
block|}
if|if
condition|(
name|client
operator|->
name|entry
operator|.
name|valid_end
condition|)
block|{
name|ek
operator|.
name|last_req
operator|.
name|val
index|[
name|ek
operator|.
name|last_req
operator|.
name|len
index|]
operator|.
name|lr_type
operator|=
name|LR_ACCT_EXPTIME
expr_stmt|;
name|ek
operator|.
name|last_req
operator|.
name|val
index|[
name|ek
operator|.
name|last_req
operator|.
name|len
index|]
operator|.
name|lr_value
operator|=
operator|*
name|client
operator|->
name|entry
operator|.
name|valid_end
expr_stmt|;
operator|++
name|ek
operator|.
name|last_req
operator|.
name|len
expr_stmt|;
block|}
if|if
condition|(
name|ek
operator|.
name|last_req
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|ek
operator|.
name|last_req
operator|.
name|val
index|[
name|ek
operator|.
name|last_req
operator|.
name|len
index|]
operator|.
name|lr_type
operator|=
name|LR_NONE
expr_stmt|;
name|ek
operator|.
name|last_req
operator|.
name|val
index|[
name|ek
operator|.
name|last_req
operator|.
name|len
index|]
operator|.
name|lr_value
operator|=
literal|0
expr_stmt|;
operator|++
name|ek
operator|.
name|last_req
operator|.
name|len
expr_stmt|;
block|}
name|ek
operator|.
name|nonce
operator|=
name|b
operator|->
name|nonce
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|entry
operator|.
name|valid_end
operator|||
name|client
operator|->
name|entry
operator|.
name|pw_end
condition|)
block|{
name|ALLOC
argument_list|(
name|ek
operator|.
name|key_expiration
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|entry
operator|.
name|valid_end
condition|)
block|{
if|if
condition|(
name|client
operator|->
name|entry
operator|.
name|pw_end
condition|)
operator|*
name|ek
operator|.
name|key_expiration
operator|=
name|min
argument_list|(
operator|*
name|client
operator|->
name|entry
operator|.
name|valid_end
argument_list|,
operator|*
name|client
operator|->
name|entry
operator|.
name|pw_end
argument_list|)
expr_stmt|;
else|else
operator|*
name|ek
operator|.
name|key_expiration
operator|=
operator|*
name|client
operator|->
name|entry
operator|.
name|valid_end
expr_stmt|;
block|}
else|else
operator|*
name|ek
operator|.
name|key_expiration
operator|=
operator|*
name|client
operator|->
name|entry
operator|.
name|pw_end
expr_stmt|;
block|}
else|else
name|ek
operator|.
name|key_expiration
operator|=
name|NULL
expr_stmt|;
name|ek
operator|.
name|flags
operator|=
name|et
operator|.
name|flags
expr_stmt|;
name|ek
operator|.
name|authtime
operator|=
name|et
operator|.
name|authtime
expr_stmt|;
if|if
condition|(
name|et
operator|.
name|starttime
condition|)
block|{
name|ALLOC
argument_list|(
name|ek
operator|.
name|starttime
argument_list|)
expr_stmt|;
operator|*
name|ek
operator|.
name|starttime
operator|=
operator|*
name|et
operator|.
name|starttime
expr_stmt|;
block|}
name|ek
operator|.
name|endtime
operator|=
name|et
operator|.
name|endtime
expr_stmt|;
if|if
condition|(
name|et
operator|.
name|renew_till
condition|)
block|{
name|ALLOC
argument_list|(
name|ek
operator|.
name|renew_till
argument_list|)
expr_stmt|;
operator|*
name|ek
operator|.
name|renew_till
operator|=
operator|*
name|et
operator|.
name|renew_till
expr_stmt|;
block|}
name|copy_Realm
argument_list|(
operator|&
name|rep
operator|.
name|ticket
operator|.
name|realm
argument_list|,
operator|&
name|ek
operator|.
name|srealm
argument_list|)
expr_stmt|;
name|copy_PrincipalName
argument_list|(
operator|&
name|rep
operator|.
name|ticket
operator|.
name|sname
argument_list|,
operator|&
name|ek
operator|.
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
name|et
operator|.
name|caddr
condition|)
block|{
name|ALLOC
argument_list|(
name|ek
operator|.
name|caddr
argument_list|)
expr_stmt|;
name|copy_HostAddresses
argument_list|(
name|et
operator|.
name|caddr
argument_list|,
name|ek
operator|.
name|caddr
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|PKINIT
if|if
condition|(
name|pkp
condition|)
block|{
name|e_text
operator|=
literal|"Failed to build PK-INIT reply"
expr_stmt|;
name|ret
operator|=
name|_kdc_pk_mk_pa_reply
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
name|pkp
argument_list|,
name|client
argument_list|,
name|sessionetype
argument_list|,
name|req
argument_list|,
name|req_buffer
argument_list|,
operator|&
name|reply_key
argument_list|,
operator|&
name|et
operator|.
name|key
argument_list|,
name|rep
operator|.
name|padata
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|_kdc_add_inital_verified_cas
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
name|pkp
argument_list|,
operator|&
name|et
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
else|else
endif|#
directive|endif
block|{
name|ret
operator|=
name|krb5_generate_random_keyblock
argument_list|(
name|context
argument_list|,
name|sessionetype
argument_list|,
operator|&
name|et
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|reply_key
operator|==
name|NULL
condition|)
block|{
name|e_text
operator|=
literal|"Client have no reply key"
expr_stmt|;
name|ret
operator|=
name|KRB5KDC_ERR_CLIENT_NOTYET
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|copy_EncryptionKey
argument_list|(
operator|&
name|et
operator|.
name|key
argument_list|,
operator|&
name|ek
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
comment|/* Add signing of alias referral */
if|if
condition|(
name|f
operator|.
name|canonicalize
condition|)
block|{
name|PA_ClientCanonicalized
name|canon
decl_stmt|;
name|krb5_data
name|data
decl_stmt|;
name|PA_DATA
name|pa
decl_stmt|;
name|krb5_crypto
name|cryptox
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|canon
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|canon
argument_list|)
argument_list|)
expr_stmt|;
name|canon
operator|.
name|names
operator|.
name|requested_name
operator|=
operator|*
name|b
operator|->
name|cname
expr_stmt|;
name|canon
operator|.
name|names
operator|.
name|mapped_name
operator|=
name|client
operator|->
name|entry
operator|.
name|principal
operator|->
name|name
expr_stmt|;
name|ASN1_MALLOC_ENCODE
argument_list|(
name|PA_ClientCanonicalizedNames
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|length
argument_list|,
operator|&
name|canon
operator|.
name|names
argument_list|,
operator|&
name|len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|data
operator|.
name|length
operator|!=
name|len
condition|)
name|krb5_abortx
argument_list|(
name|context
argument_list|,
literal|"internal asn.1 error"
argument_list|)
expr_stmt|;
comment|/* sign using "returned session key" */
name|ret
operator|=
name|krb5_crypto_init
argument_list|(
name|context
argument_list|,
operator|&
name|et
operator|.
name|key
argument_list|,
literal|0
argument_list|,
operator|&
name|cryptox
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|data
operator|.
name|data
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|krb5_create_checksum
argument_list|(
name|context
argument_list|,
name|cryptox
argument_list|,
name|KRB5_KU_CANONICALIZED_NAMES
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|length
argument_list|,
operator|&
name|canon
operator|.
name|canon_checksum
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
operator|.
name|data
argument_list|)
expr_stmt|;
name|krb5_crypto_destroy
argument_list|(
name|context
argument_list|,
name|cryptox
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ASN1_MALLOC_ENCODE
argument_list|(
name|PA_ClientCanonicalized
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|length
argument_list|,
operator|&
name|canon
argument_list|,
operator|&
name|len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|free_Checksum
argument_list|(
operator|&
name|canon
operator|.
name|canon_checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|data
operator|.
name|length
operator|!=
name|len
condition|)
name|krb5_abortx
argument_list|(
name|context
argument_list|,
literal|"internal asn.1 error"
argument_list|)
expr_stmt|;
name|pa
operator|.
name|padata_type
operator|=
name|KRB5_PADATA_CLIENT_CANONICALIZED
expr_stmt|;
name|pa
operator|.
name|padata_value
operator|=
name|data
expr_stmt|;
name|ret
operator|=
name|add_METHOD_DATA
argument_list|(
name|rep
operator|.
name|padata
argument_list|,
operator|&
name|pa
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|rep
operator|.
name|padata
operator|->
name|len
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|rep
operator|.
name|padata
argument_list|)
expr_stmt|;
name|rep
operator|.
name|padata
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Add the PAC */
if|if
condition|(
name|send_pac_p
argument_list|(
name|context
argument_list|,
name|req
argument_list|)
condition|)
block|{
name|krb5_pac
name|p
init|=
name|NULL
decl_stmt|;
name|krb5_data
name|data
decl_stmt|;
name|ret
operator|=
name|_kdc_pac_generate
argument_list|(
name|context
argument_list|,
name|client
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"PAC generation failed for -- %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|_krb5_pac_sign
argument_list|(
name|context
argument_list|,
name|p
argument_list|,
name|et
operator|.
name|authtime
argument_list|,
name|client
operator|->
name|entry
operator|.
name|principal
argument_list|,
operator|&
name|skey
operator|->
name|key
argument_list|,
comment|/* Server key */
operator|&
name|skey
operator|->
name|key
argument_list|,
comment|/* FIXME: should be krbtgt key */
operator|&
name|data
argument_list|)
expr_stmt|;
name|krb5_pac_free
argument_list|(
name|context
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|kdc_log
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|0
argument_list|,
literal|"PAC signing failed for -- %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|_kdc_tkt_add_if_relevant_ad
argument_list|(
name|context
argument_list|,
operator|&
name|et
argument_list|,
name|KRB5_AUTHDATA_WIN2K_PAC
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|krb5_data_free
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|_kdc_log_timestamp
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
literal|"AS-REQ"
argument_list|,
name|et
operator|.
name|authtime
argument_list|,
name|et
operator|.
name|starttime
argument_list|,
name|et
operator|.
name|endtime
argument_list|,
name|et
operator|.
name|renew_till
argument_list|)
expr_stmt|;
comment|/* do this as the last thing since this signs the EncTicketPart */
name|ret
operator|=
name|_kdc_add_KRB5SignedPath
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
name|server
argument_list|,
name|setype
argument_list|,
name|client
operator|->
name|entry
operator|.
name|principal
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|et
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|log_as_req
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
name|reply_key
operator|->
name|keytype
argument_list|,
name|setype
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_kdc_encode_reply
argument_list|(
name|context
argument_list|,
name|config
argument_list|,
operator|&
name|rep
argument_list|,
operator|&
name|et
argument_list|,
operator|&
name|ek
argument_list|,
name|setype
argument_list|,
name|server
operator|->
name|entry
operator|.
name|kvno
argument_list|,
operator|&
name|skey
operator|->
name|key
argument_list|,
name|client
operator|->
name|entry
operator|.
name|kvno
argument_list|,
name|reply_key
argument_list|,
literal|0
argument_list|,
operator|&
name|e_text
argument_list|,
name|reply
argument_list|)
expr_stmt|;
name|free_EncTicketPart
argument_list|(
operator|&
name|et
argument_list|)
expr_stmt|;
name|free_EncKDCRepPart
argument_list|(
operator|&
name|ek
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
comment|/* */
if|if
condition|(
name|datagram_reply
operator|&&
name|reply
operator|->
name|length
operator|>
name|config
operator|->
name|max_datagram_reply_length
condition|)
block|{
name|krb5_data_free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|ret
operator|=
name|KRB5KRB_ERR_RESPONSE_TOO_BIG
expr_stmt|;
name|e_text
operator|=
literal|"Reply packet too large"
expr_stmt|;
block|}
name|out
label|:
name|free_AS_REP
argument_list|(
operator|&
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
operator|&&
name|ret
operator|!=
name|HDB_ERR_NOT_FOUND_HERE
condition|)
block|{
name|krb5_mk_error
argument_list|(
name|context
argument_list|,
name|ret
argument_list|,
name|e_text
argument_list|,
operator|(
name|e_data
operator|.
name|data
condition|?
operator|&
name|e_data
else|:
name|NULL
operator|)
argument_list|,
name|client_princ
argument_list|,
name|server_princ
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|reply
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PKINIT
if|if
condition|(
name|pkp
condition|)
name|_kdc_pk_free_client_param
argument_list|(
name|context
argument_list|,
name|pkp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|e_data
operator|.
name|data
condition|)
name|free
argument_list|(
name|e_data
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_princ
condition|)
name|krb5_free_principal
argument_list|(
name|context
argument_list|,
name|client_princ
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|client_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_princ
condition|)
name|krb5_free_principal
argument_list|(
name|context
argument_list|,
name|server_princ
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|server_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
condition|)
name|_kdc_free_ent
argument_list|(
name|context
argument_list|,
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
condition|)
name|_kdc_free_ent
argument_list|(
name|context
argument_list|,
name|server
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Add the AuthorizationData `dataÂ´ of `typeÂ´ to the last element in  * the sequence of authorization_data in `tktÂ´ wrapped in an IF_RELEVANT  */
end_comment

begin_function
name|krb5_error_code
name|_kdc_tkt_add_if_relevant_ad
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|EncTicketPart
modifier|*
name|tkt
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|krb5_data
modifier|*
name|data
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|size_t
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tkt
operator|->
name|authorization_data
operator|==
name|NULL
condition|)
block|{
name|tkt
operator|->
name|authorization_data
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tkt
operator|->
name|authorization_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tkt
operator|->
name|authorization_data
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
comment|/* add the entry to the last element */
block|{
name|AuthorizationData
name|ad
init|=
block|{
literal|0
block|,
name|NULL
block|}
decl_stmt|;
name|AuthorizationDataElement
name|ade
decl_stmt|;
name|ade
operator|.
name|ad_type
operator|=
name|type
expr_stmt|;
name|ade
operator|.
name|ad_data
operator|=
operator|*
name|data
expr_stmt|;
name|ret
operator|=
name|add_AuthorizationData
argument_list|(
operator|&
name|ad
argument_list|,
operator|&
name|ade
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|,
literal|"add AuthorizationData failed"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ade
operator|.
name|ad_type
operator|=
name|KRB5_AUTHDATA_IF_RELEVANT
expr_stmt|;
name|ASN1_MALLOC_ENCODE
argument_list|(
name|AuthorizationData
argument_list|,
name|ade
operator|.
name|ad_data
operator|.
name|data
argument_list|,
name|ade
operator|.
name|ad_data
operator|.
name|length
argument_list|,
operator|&
name|ad
argument_list|,
operator|&
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|free_AuthorizationData
argument_list|(
operator|&
name|ad
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|,
literal|"ASN.1 encode of "
literal|"AuthorizationData failed"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|ade
operator|.
name|ad_data
operator|.
name|length
operator|!=
name|size
condition|)
name|krb5_abortx
argument_list|(
name|context
argument_list|,
literal|"internal asn.1 encoder error"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|add_AuthorizationData
argument_list|(
name|tkt
operator|->
name|authorization_data
argument_list|,
operator|&
name|ade
argument_list|)
expr_stmt|;
name|der_free_octet_string
argument_list|(
operator|&
name|ade
operator|.
name|ad_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|,
literal|"add AuthorizationData failed"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

