begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2008 Apple Inc.  All Rights Reserved.  *  * Export of this software from the United States of America may require  * a specific license from the United States Government.  It is the  * responsibility of any person or organization contemplating export to  * obtain such a license before exporting.  *  * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and  * distribute this software and its documentation for any purpose and  * without fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright notice and  * this permission notice appear in supporting documentation, and that  * the name of Apple Inc. not be used in advertising or publicity pertaining  * to distribution of the software without specific, written prior  * permission.  Apple Inc. makes no representations about the suitability of  * this software for any purpose.  It is provided "as is" without express  * or implied warranty.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  */
end_comment

begin_include
include|#
directive|include
file|"kdc_locl.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_GCD
argument_list|)
end_if

begin_include
include|#
directive|include
file|<CoreFoundation/CoreFoundation.h>
end_include

begin_include
include|#
directive|include
file|<SystemConfiguration/SCDynamicStore.h>
end_include

begin_include
include|#
directive|include
file|<SystemConfiguration/SCDynamicStoreCopySpecific.h>
end_include

begin_include
include|#
directive|include
file|<SystemConfiguration/SCDynamicStoreKey.h>
end_include

begin_include
include|#
directive|include
file|<dispatch/dispatch.h>
end_include

begin_include
include|#
directive|include
file|<asl.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<dns_sd.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_decl_stmt
specifier|static
name|krb5_kdc_configuration
modifier|*
name|announce_config
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|krb5_context
name|announce_context
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|entry
block|{
name|DNSRecordRef
name|recordRef
decl_stmt|;
name|char
modifier|*
name|domain
decl_stmt|;
name|char
modifier|*
name|realm
decl_stmt|;
define|#
directive|define
name|F_EXISTS
value|1
define|#
directive|define
name|F_PUSH
value|2
name|int
name|flags
decl_stmt|;
name|struct
name|entry
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* #define REGISTER_SRV_RR */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|entry
modifier|*
name|g_entries
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CFStringRef
name|g_hostname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DNSServiceRef
name|g_dnsRef
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SCDynamicStoreRef
name|g_store
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dispatch_queue_t
name|g_queue
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LOG
parameter_list|(
modifier|...
parameter_list|)
value|asl_log(NULL, NULL, ASL_LEVEL_INFO, __VA_ARGS__)
end_define

begin_function_decl
specifier|static
name|void
name|create_dns_sd
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_dns_sd
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_all
parameter_list|(
name|SCDynamicStoreRef
parameter_list|,
name|CFArrayRef
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* parameters */
end_comment

begin_decl_stmt
specifier|static
name|CFStringRef
name|NetworkChangedKey_BackToMyMac
init|=
name|CFSTR
argument_list|(
literal|"Setup:/Network/BackToMyMac"
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|CFString2utf8
parameter_list|(
name|CFStringRef
name|string
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|size
operator|=
literal|1
operator|+
name|CFStringGetMaximumSizeForEncoding
argument_list|(
name|CFStringGetLength
argument_list|(
name|string
argument_list|)
argument_list|,
name|kCFStringEncodingUTF8
argument_list|)
expr_stmt|;
name|str
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|CFStringGetCString
argument_list|(
name|string
argument_list|,
name|str
argument_list|,
name|size
argument_list|,
name|kCFStringEncodingUTF8
argument_list|)
operator|==
name|false
condition|)
block|{
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|retry_timer
parameter_list|(
name|void
parameter_list|)
block|{
name|dispatch_source_t
name|s
decl_stmt|;
name|dispatch_time_t
name|t
decl_stmt|;
name|s
operator|=
name|dispatch_source_create
argument_list|(
name|DISPATCH_SOURCE_TYPE_TIMER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|g_queue
argument_list|)
expr_stmt|;
name|t
operator|=
name|dispatch_time
argument_list|(
name|DISPATCH_TIME_NOW
argument_list|,
literal|5ull
operator|*
name|NSEC_PER_SEC
argument_list|)
expr_stmt|;
name|dispatch_source_set_timer
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|NSEC_PER_SEC
argument_list|)
expr_stmt|;
name|dispatch_source_set_event_handler
argument_list|(
name|s
argument_list|,
lambda|^
block|{
name|create_dns_sd
argument_list|()
expr_stmt|;
name|dispatch_release
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|dispatch_resume
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|create_dns_sd
parameter_list|(
name|void
parameter_list|)
block|{
name|DNSServiceErrorType
name|error
decl_stmt|;
name|dispatch_source_t
name|s
decl_stmt|;
name|error
operator|=
name|DNSServiceCreateConnection
argument_list|(
operator|&
name|g_dnsRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|retry_timer
argument_list|()
expr_stmt|;
return|return;
block|}
name|dispatch_suspend
argument_list|(
name|g_queue
argument_list|)
expr_stmt|;
name|s
operator|=
name|dispatch_source_create
argument_list|(
name|DISPATCH_SOURCE_TYPE_READ
argument_list|,
name|DNSServiceRefSockFD
argument_list|(
name|g_dnsRef
argument_list|)
argument_list|,
literal|0
argument_list|,
name|g_queue
argument_list|)
expr_stmt|;
name|dispatch_source_set_event_handler
argument_list|(
name|s
argument_list|,
lambda|^
block|{
name|DNSServiceErrorType
name|ret
init|=
name|DNSServiceProcessResult
argument_list|(
name|g_dnsRef
argument_list|)
decl_stmt|;
comment|/* on error tear down and set timer to recreate */
if|if
condition|(
name|ret
operator|!=
name|kDNSServiceErr_NoError
operator|&&
name|ret
operator|!=
name|kDNSServiceErr_Transient
condition|)
block|{
name|dispatch_source_cancel
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|dispatch_source_set_cancel_handler
argument_list|(
name|s
argument_list|,
lambda|^
block|{
name|destroy_dns_sd
argument_list|()
expr_stmt|;
name|retry_timer
argument_list|()
expr_stmt|;
name|dispatch_release
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|dispatch_resume
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Do the first update ourself */
name|update_all
argument_list|(
name|g_store
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dispatch_resume
argument_list|(
name|g_queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|domain_add
parameter_list|(
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|g_entries
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|domain
argument_list|,
name|e
operator|->
name|domain
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|realm
argument_list|,
name|e
operator|->
name|realm
argument_list|)
operator|==
literal|0
condition|)
block|{
name|e
operator|->
name|flags
operator||=
name|flag
expr_stmt|;
return|return;
block|}
block|}
name|LOG
argument_list|(
literal|"Adding realm %s to domain %s"
argument_list|,
name|realm
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|e
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return;
name|e
operator|->
name|domain
operator|=
name|strdup
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|e
operator|->
name|realm
operator|=
name|strdup
argument_list|(
name|realm
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|domain
operator|==
name|NULL
operator|||
name|e
operator|->
name|realm
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|e
operator|->
name|domain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
operator|->
name|realm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|e
operator|->
name|flags
operator|=
name|flag
operator||
name|F_PUSH
expr_stmt|;
comment|/* if we allocate, we push */
name|e
operator|->
name|next
operator|=
name|g_entries
expr_stmt|;
name|g_entries
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|addctx
block|{
name|int
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|realm
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|domains_add
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
name|CFString2utf8
argument_list|(
operator|(
name|CFStringRef
operator|)
name|value
argument_list|)
decl_stmt|;
name|struct
name|addctx
modifier|*
name|ctx
init|=
name|context
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|domain_add
argument_list|(
name|str
argument_list|,
name|ctx
operator|->
name|realm
argument_list|,
name|F_EXISTS
operator||
name|ctx
operator|->
name|flags
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|dnsCallback
argument_list|(
name|DNSServiceRef
name|sdRef
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
name|DNSRecordRef
name|RecordRef
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
name|DNSServiceFlags
name|flags
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
name|DNSServiceErrorType
name|errorCode
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
name|void
operator|*
name|context
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{ }
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|REGISTER_SRV_RR
end_ifdef

begin_comment
comment|/*  * Register DNS SRV rr for the realm.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|register_names
index|[
literal|2
index|]
init|=
block|{
literal|"_kerberos._tcp"
block|,
literal|"_kerberos._udp"
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|DNSRecordRef
modifier|*
name|val
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|}
name|srvRefs
init|=
block|{
name|NULL
block|,
literal|0
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|register_srv
parameter_list|(
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|unsigned
name|char
name|target
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* skip registering LKDC realms */
if|if
condition|(
name|strncmp
argument_list|(
name|realm
argument_list|,
literal|"LKDC:"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* encode SRV-RR */
name|target
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* priority */
name|target
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* priority */
name|target
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* weight */
name|target
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* weigth */
name|target
index|[
literal|4
index|]
operator|=
operator|(
name|port
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* port */
name|target
index|[
literal|5
index|]
operator|=
operator|(
name|port
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* port */
name|size
operator|=
name|dn_comp
argument_list|(
name|hostname
argument_list|,
name|target
operator|+
literal|6
argument_list|,
sizeof|sizeof
argument_list|(
name|target
argument_list|)
operator|-
literal|6
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
return|return;
name|size
operator|+=
literal|6
expr_stmt|;
name|LOG
argument_list|(
literal|"register SRV rr for realm %s hostname %s:%d"
argument_list|,
name|realm
argument_list|,
name|hostname
argument_list|,
name|port
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|register_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|register_names
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|char
name|name
index|[
name|kDNSServiceMaxDomainName
index|]
decl_stmt|;
name|DNSServiceErrorType
name|error
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|realloc
argument_list|(
name|srvRefs
operator|.
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|srvRefs
operator|.
name|val
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|srvRefs
operator|.
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc: out of memory"
argument_list|)
expr_stmt|;
name|srvRefs
operator|.
name|val
operator|=
name|ptr
expr_stmt|;
name|DNSServiceConstructFullName
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|register_names
index|[
name|i
index|]
argument_list|,
name|realm
argument_list|)
expr_stmt|;
name|error
operator|=
name|DNSServiceRegisterRecord
argument_list|(
name|g_dnsRef
argument_list|,
operator|&
name|srvRefs
operator|.
name|val
index|[
name|srvRefs
operator|.
name|len
index|]
argument_list|,
name|kDNSServiceFlagsUnique
operator||
name|kDNSServiceFlagsShareConnection
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|kDNSServiceType_SRV
argument_list|,
name|kDNSServiceClass_IN
argument_list|,
name|size
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|dnsCallback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|LOG
argument_list|(
literal|"Failed to register SRV rr for realm %s: %d"
argument_list|,
name|realm
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
name|srvRefs
operator|.
name|len
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|unregister_srv_realms
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|g_dnsRef
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|srvRefs
operator|.
name|len
condition|;
name|i
operator|++
control|)
name|DNSServiceRemoveRecord
argument_list|(
name|g_dnsRef
argument_list|,
name|srvRefs
operator|.
name|val
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|srvRefs
operator|.
name|val
argument_list|)
expr_stmt|;
name|srvRefs
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|srvRefs
operator|.
name|val
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|register_srv_realms
parameter_list|(
name|CFStringRef
name|host
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|char
modifier|*
name|hostname
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* first unregister old names */
name|hostname
operator|=
name|CFString2utf8
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|announce_config
operator|->
name|num_db
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
modifier|*
name|realms
decl_stmt|,
modifier|*
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|announce_config
operator|->
name|db
index|[
name|i
index|]
operator|->
name|hdb_get_realms
operator|==
name|NULL
condition|)
continue|continue;
name|ret
operator|=
operator|(
name|announce_config
operator|->
name|db
index|[
name|i
index|]
operator|->
name|hdb_get_realms
operator|)
operator|(
name|announce_context
operator|,
operator|&
name|realms
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|r
operator|=
name|realms
init|;
name|r
operator|&&
operator|*
name|r
condition|;
name|r
operator|++
control|)
name|register_srv
argument_list|(
operator|*
name|r
argument_list|,
name|hostname
argument_list|,
literal|88
argument_list|)
expr_stmt|;
name|krb5_free_host_realm
argument_list|(
name|announce_context
argument_list|,
name|realms
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REGISTER_SRV_RR */
end_comment

begin_function
specifier|static
name|void
name|update_dns
parameter_list|(
name|void
parameter_list|)
block|{
name|DNSServiceErrorType
name|error
decl_stmt|;
name|struct
name|entry
modifier|*
modifier|*
name|e
init|=
operator|&
name|g_entries
decl_stmt|;
name|char
modifier|*
name|hostname
decl_stmt|;
name|hostname
operator|=
name|CFString2utf8
argument_list|(
name|g_hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
operator|*
name|e
operator|!=
name|NULL
condition|)
block|{
comment|/* remove if this wasn't updated */
if|if
condition|(
operator|(
operator|(
operator|*
name|e
operator|)
operator|->
name|flags
operator|&
name|F_EXISTS
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|entry
modifier|*
name|drop
init|=
operator|*
name|e
decl_stmt|;
operator|*
name|e
operator|=
operator|(
operator|*
name|e
operator|)
operator|->
name|next
expr_stmt|;
name|LOG
argument_list|(
literal|"Deleting realm %s from domain %s"
argument_list|,
name|drop
operator|->
name|realm
argument_list|,
name|drop
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop
operator|->
name|recordRef
operator|&&
name|g_dnsRef
condition|)
name|DNSServiceRemoveRecord
argument_list|(
name|g_dnsRef
argument_list|,
name|drop
operator|->
name|recordRef
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|drop
operator|->
name|domain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|drop
operator|->
name|realm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|drop
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
operator|*
name|e
operator|)
operator|->
name|flags
operator|&
name|F_PUSH
condition|)
block|{
name|struct
name|entry
modifier|*
name|update
init|=
operator|*
name|e
decl_stmt|;
name|char
modifier|*
name|dnsdata
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|update
operator|->
name|realm
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|dnsdata
argument_list|,
literal|"%c%s"
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|update
operator|->
name|realm
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnsdata
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|name
argument_list|,
literal|"_kerberos.%s.%s"
argument_list|,
name|hostname
argument_list|,
name|update
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
operator|->
name|recordRef
condition|)
name|DNSServiceRemoveRecord
argument_list|(
name|g_dnsRef
argument_list|,
name|update
operator|->
name|recordRef
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|DNSServiceRegisterRecord
argument_list|(
name|g_dnsRef
argument_list|,
operator|&
name|update
operator|->
name|recordRef
argument_list|,
name|kDNSServiceFlagsShared
operator||
name|kDNSServiceFlagsAllowRemoteQuery
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|kDNSServiceType_TXT
argument_list|,
name|kDNSServiceClass_IN
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|dnsdata
argument_list|,
literal|0
argument_list|,
name|dnsCallback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dnsdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"failure to update entry for %s/%s"
argument_list|,
name|update
operator|->
name|domain
argument_list|,
name|update
operator|->
name|realm
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
operator|&
operator|(
operator|*
name|e
operator|)
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_entries
parameter_list|(
name|SCDynamicStoreRef
name|store
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|CFDictionaryRef
name|btmm
decl_stmt|;
comment|/* we always announce in the local domain */
name|domain_add
argument_list|(
literal|"local"
argument_list|,
name|realm
argument_list|,
name|F_EXISTS
operator||
name|flags
argument_list|)
expr_stmt|;
comment|/* announce btmm */
name|btmm
operator|=
name|SCDynamicStoreCopyValue
argument_list|(
name|store
argument_list|,
name|NetworkChangedKey_BackToMyMac
argument_list|)
expr_stmt|;
if|if
condition|(
name|btmm
condition|)
block|{
name|struct
name|addctx
name|addctx
decl_stmt|;
name|addctx
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|addctx
operator|.
name|realm
operator|=
name|realm
expr_stmt|;
name|CFDictionaryApplyFunction
argument_list|(
name|btmm
argument_list|,
name|domains_add
argument_list|,
operator|&
name|addctx
argument_list|)
expr_stmt|;
name|CFRelease
argument_list|(
name|btmm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|update_all
parameter_list|(
name|SCDynamicStoreRef
name|store
parameter_list|,
name|CFArrayRef
name|changedKeys
parameter_list|,
name|void
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|e
decl_stmt|;
name|CFStringRef
name|host
decl_stmt|;
name|int
name|i
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
name|LOG
argument_list|(
literal|"something changed, running update"
argument_list|)
expr_stmt|;
name|host
operator|=
name|SCDynamicStoreCopyLocalHostName
argument_list|(
name|store
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|g_hostname
operator|==
name|NULL
operator|||
name|CFStringCompare
argument_list|(
name|host
argument_list|,
name|g_hostname
argument_list|,
literal|0
argument_list|)
operator|!=
name|kCFCompareEqualTo
condition|)
block|{
if|if
condition|(
name|g_hostname
condition|)
name|CFRelease
argument_list|(
name|g_hostname
argument_list|)
expr_stmt|;
name|g_hostname
operator|=
name|CFRetain
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|flags
operator|=
name|F_PUSH
expr_stmt|;
comment|/* if hostname has changed, force push */
ifdef|#
directive|ifdef
name|REGISTER_SRV_RR
name|register_srv_realms
argument_list|(
name|g_hostname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
for|for
control|(
name|e
operator|=
name|g_entries
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
name|e
operator|->
name|flags
operator|&=
operator|~
operator|(
name|F_EXISTS
operator||
name|F_PUSH
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|announce_config
operator|->
name|num_db
condition|;
name|i
operator|++
control|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|char
modifier|*
modifier|*
name|realms
decl_stmt|,
modifier|*
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|announce_config
operator|->
name|db
index|[
name|i
index|]
operator|->
name|hdb_get_realms
operator|==
name|NULL
condition|)
continue|continue;
name|ret
operator|=
operator|(
name|announce_config
operator|->
name|db
index|[
name|i
index|]
operator|->
name|hdb_get_realms
operator|)
operator|(
name|announce_context
operator|,
name|announce_config
operator|->
name|db
index|[
name|i
index|]
operator|,
operator|&
name|realms
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|r
operator|=
name|realms
init|;
name|r
operator|&&
operator|*
name|r
condition|;
name|r
operator|++
control|)
name|update_entries
argument_list|(
name|store
argument_list|,
operator|*
name|r
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|krb5_free_host_realm
argument_list|(
name|announce_context
argument_list|,
name|realms
argument_list|)
expr_stmt|;
block|}
block|}
name|update_dns
argument_list|()
expr_stmt|;
name|CFRelease
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_all
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|g_entries
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
name|e
operator|->
name|flags
operator|&=
operator|~
operator|(
name|F_EXISTS
operator||
name|F_PUSH
operator|)
expr_stmt|;
name|update_dns
argument_list|()
expr_stmt|;
if|if
condition|(
name|g_entries
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Failed to remove all bonjour entries"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_dns_sd
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|g_dnsRef
operator|==
name|NULL
condition|)
return|return;
name|delete_all
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_SRV_RR
name|unregister_srv_realms
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|DNSServiceRefDeallocate
argument_list|(
name|g_dnsRef
argument_list|)
expr_stmt|;
name|g_dnsRef
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|SCDynamicStoreRef
name|register_notification
parameter_list|(
name|void
parameter_list|)
block|{
name|SCDynamicStoreRef
name|store
decl_stmt|;
name|CFStringRef
name|computerNameKey
decl_stmt|;
name|CFMutableArrayRef
name|keys
decl_stmt|;
name|computerNameKey
operator|=
name|SCDynamicStoreKeyCreateHostNames
argument_list|(
name|kCFAllocatorDefault
argument_list|)
expr_stmt|;
name|store
operator|=
name|SCDynamicStoreCreate
argument_list|(
name|kCFAllocatorDefault
argument_list|,
name|CFSTR
argument_list|(
literal|"Network watcher"
argument_list|)
argument_list|,
name|update_all
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"SCDynamicStoreCreate"
argument_list|)
expr_stmt|;
name|keys
operator|=
name|CFArrayCreateMutable
argument_list|(
name|kCFAllocatorDefault
argument_list|,
literal|2
argument_list|,
operator|&
name|kCFTypeArrayCallBacks
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"CFArrayCreateMutable"
argument_list|)
expr_stmt|;
name|CFArrayAppendValue
argument_list|(
name|keys
argument_list|,
name|computerNameKey
argument_list|)
expr_stmt|;
name|CFArrayAppendValue
argument_list|(
name|keys
argument_list|,
name|NetworkChangedKey_BackToMyMac
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCDynamicStoreSetNotificationKeys
argument_list|(
name|store
argument_list|,
name|keys
argument_list|,
name|NULL
argument_list|)
operator|==
name|false
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"SCDynamicStoreSetNotificationKeys"
argument_list|)
expr_stmt|;
name|CFRelease
argument_list|(
name|computerNameKey
argument_list|)
expr_stmt|;
name|CFRelease
argument_list|(
name|keys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SCDynamicStoreSetDispatchQueue
argument_list|(
name|store
argument_list|,
name|g_queue
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"SCDynamicStoreSetDispatchQueue"
argument_list|)
expr_stmt|;
return|return
name|store
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|bonjour_announce
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_kdc_configuration
modifier|*
name|config
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_GCD
argument_list|)
name|g_queue
operator|=
name|dispatch_queue_create
argument_list|(
literal|"com.apple.kdc_announce"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_queue
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"dispatch_queue_create"
argument_list|)
expr_stmt|;
name|g_store
operator|=
name|register_notification
argument_list|()
expr_stmt|;
name|announce_config
operator|=
name|config
expr_stmt|;
name|announce_context
operator|=
name|context
expr_stmt|;
name|create_dns_sd
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

