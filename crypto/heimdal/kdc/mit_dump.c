begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"hprop.h"
end_include

begin_comment
comment|/* can have any number of princ stanzas. format is as follows (only \n indicates newlines) princ\t%d\t (%d is KRB5_KDB_V1_BASE_LENGTH, always 38) %d\t (strlen of principal e.g. shadow/foo@ANDREW.CMU.EDU) %d\t (number of tl_data) %d\t (number of key data, e.g. how many keys for this user) %d\t (extra data length) %s\t (principal name) %d\t (attributes) %d\t (max lifetime, seconds) %d\t (max renewable life, seconds) %d\t (expiration, seconds since epoch or 2145830400 for never) %d\t (password expiration, seconds, 0 for never) %d\t (last successful auth, seconds since epoch) %d\t (last failed auth, per above) %d\t (failed auth count) foreach tl_data 0 to number of tl_data - 1 as above   %d\t%d\t (data type, data length)   foreach tl_data 0 to length-1     %02x (tl data contents[element n])   except if tl_data length is 0     %d (always -1)   \t foreach key 0 to number of keys - 1 as above   %d\t%d\t (key data version, kvno)   foreach version 0 to key data version - 1 (a key or a salt)     %d\t%d\t(data type for this key, data length for this key)     foreach key data length 0 to length-1       %02x (key data contents[element n])     except if key_data length is 0       %d (always -1)     \t foreach extra data length 0 to length - 1   %02x (extra data part) unless no extra data   %d (always -1) ;\n  */
end_comment

begin_function
specifier|static
name|int
name|hex_to_octet_string
parameter_list|(
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
name|krb5_data
modifier|*
name|data
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|unsigned
name|int
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|ptr
operator|+
literal|2
operator|*
name|i
argument_list|,
literal|"%02x"
argument_list|,
operator|&
name|v
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|->
name|data
operator|)
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
block|}
return|return
literal|2
operator|*
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|nexttoken
parameter_list|(
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
do|do
block|{
name|q
operator|=
name|strsep
argument_list|(
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|q
operator|&&
operator|*
name|q
operator|==
literal|'\0'
condition|)
do|;
return|return
name|q
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|getdata
parameter_list|(
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|v
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|nexttoken
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|&&
name|i
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|q
argument_list|,
literal|"%02x"
argument_list|,
operator|&
name|v
argument_list|)
operator|!=
literal|1
condition|)
break|break;
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|v
expr_stmt|;
name|q
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getint
parameter_list|(
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|nexttoken
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|sscanf
argument_list|(
name|q
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<kadm5/admin.h>
end_include

begin_function
specifier|static
name|void
name|attr_to_flags
parameter_list|(
name|unsigned
name|attr
parameter_list|,
name|HDBFlags
modifier|*
name|flags
parameter_list|)
block|{
name|flags
operator|->
name|postdate
operator|=
operator|!
operator|(
name|attr
operator|&
name|KRB5_KDB_DISALLOW_POSTDATED
operator|)
expr_stmt|;
name|flags
operator|->
name|forwardable
operator|=
operator|!
operator|(
name|attr
operator|&
name|KRB5_KDB_DISALLOW_FORWARDABLE
operator|)
expr_stmt|;
name|flags
operator|->
name|initial
operator|=
operator|!
operator|!
operator|(
name|attr
operator|&
name|KRB5_KDB_DISALLOW_TGT_BASED
operator|)
expr_stmt|;
name|flags
operator|->
name|renewable
operator|=
operator|!
operator|(
name|attr
operator|&
name|KRB5_KDB_DISALLOW_RENEWABLE
operator|)
expr_stmt|;
name|flags
operator|->
name|proxiable
operator|=
operator|!
operator|(
name|attr
operator|&
name|KRB5_KDB_DISALLOW_PROXIABLE
operator|)
expr_stmt|;
comment|/* DUP_SKEY */
name|flags
operator|->
name|invalid
operator|=
operator|!
operator|!
operator|(
name|attr
operator|&
name|KRB5_KDB_DISALLOW_ALL_TIX
operator|)
expr_stmt|;
name|flags
operator|->
name|require_preauth
operator|=
operator|!
operator|!
operator|(
name|attr
operator|&
name|KRB5_KDB_REQUIRES_PRE_AUTH
operator|)
expr_stmt|;
name|flags
operator|->
name|require_hwauth
operator|=
operator|!
operator|!
operator|(
name|attr
operator|&
name|KRB5_KDB_REQUIRES_HW_AUTH
operator|)
expr_stmt|;
name|flags
operator|->
name|server
operator|=
operator|!
operator|(
name|attr
operator|&
name|KRB5_KDB_DISALLOW_SVR
operator|)
expr_stmt|;
name|flags
operator|->
name|change_pw
operator|=
operator|!
operator|!
operator|(
name|attr
operator|&
name|KRB5_KDB_PWCHANGE_SERVICE
operator|)
expr_stmt|;
name|flags
operator|->
name|client
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
block|}
end_function

begin_define
define|#
directive|define
name|KRB5_KDB_SALTTYPE_NORMAL
value|0
end_define

begin_define
define|#
directive|define
name|KRB5_KDB_SALTTYPE_V4
value|1
end_define

begin_define
define|#
directive|define
name|KRB5_KDB_SALTTYPE_NOREALM
value|2
end_define

begin_define
define|#
directive|define
name|KRB5_KDB_SALTTYPE_ONLYREALM
value|3
end_define

begin_define
define|#
directive|define
name|KRB5_KDB_SALTTYPE_SPECIAL
value|4
end_define

begin_define
define|#
directive|define
name|KRB5_KDB_SALTTYPE_AFS3
value|5
end_define

begin_function
specifier|static
name|krb5_error_code
name|fix_salt
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|hdb_entry
modifier|*
name|ent
parameter_list|,
name|int
name|key_num
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|Salt
modifier|*
name|salt
init|=
name|ent
operator|->
name|keys
operator|.
name|val
index|[
name|key_num
index|]
operator|.
name|salt
decl_stmt|;
comment|/* fix salt type */
switch|switch
condition|(
operator|(
name|int
operator|)
name|salt
operator|->
name|type
condition|)
block|{
case|case
name|KRB5_KDB_SALTTYPE_NORMAL
case|:
name|salt
operator|->
name|type
operator|=
name|KRB5_PADATA_PW_SALT
expr_stmt|;
break|break;
case|case
name|KRB5_KDB_SALTTYPE_V4
case|:
name|krb5_data_free
argument_list|(
operator|&
name|salt
operator|->
name|salt
argument_list|)
expr_stmt|;
name|salt
operator|->
name|type
operator|=
name|KRB5_PADATA_PW_SALT
expr_stmt|;
break|break;
case|case
name|KRB5_KDB_SALTTYPE_NOREALM
case|:
block|{
name|size_t
name|len
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ent
operator|->
name|principal
operator|->
name|name
operator|.
name|name_string
operator|.
name|len
condition|;
operator|++
name|i
control|)
name|len
operator|+=
name|strlen
argument_list|(
name|ent
operator|->
name|principal
operator|->
name|name
operator|.
name|name_string
operator|.
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ret
operator|=
name|krb5_data_alloc
argument_list|(
operator|&
name|salt
operator|->
name|salt
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|p
operator|=
name|salt
operator|->
name|salt
operator|.
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ent
operator|->
name|principal
operator|->
name|name
operator|.
name|name_string
operator|.
name|len
condition|;
operator|++
name|i
control|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|ent
operator|->
name|principal
operator|->
name|name
operator|.
name|name_string
operator|.
name|val
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|ent
operator|->
name|principal
operator|->
name|name
operator|.
name|name_string
operator|.
name|val
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|ent
operator|->
name|principal
operator|->
name|name
operator|.
name|name_string
operator|.
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|salt
operator|->
name|type
operator|=
name|KRB5_PADATA_PW_SALT
expr_stmt|;
break|break;
block|}
case|case
name|KRB5_KDB_SALTTYPE_ONLYREALM
case|:
name|krb5_data_free
argument_list|(
operator|&
name|salt
operator|->
name|salt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|krb5_data_copy
argument_list|(
operator|&
name|salt
operator|->
name|salt
argument_list|,
name|ent
operator|->
name|principal
operator|->
name|realm
argument_list|,
name|strlen
argument_list|(
name|ent
operator|->
name|principal
operator|->
name|realm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|salt
operator|->
name|type
operator|=
name|KRB5_PADATA_PW_SALT
expr_stmt|;
break|break;
case|case
name|KRB5_KDB_SALTTYPE_SPECIAL
case|:
name|salt
operator|->
name|type
operator|=
name|KRB5_PADATA_PW_SALT
expr_stmt|;
break|break;
case|case
name|KRB5_KDB_SALTTYPE_AFS3
case|:
name|krb5_data_free
argument_list|(
operator|&
name|salt
operator|->
name|salt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|krb5_data_copy
argument_list|(
operator|&
name|salt
operator|->
name|salt
argument_list|,
name|ent
operator|->
name|principal
operator|->
name|realm
argument_list|,
name|strlen
argument_list|(
name|ent
operator|->
name|principal
operator|->
name|realm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|salt
operator|->
name|type
operator|=
name|KRB5_PADATA_AFS3_SALT
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mit_prop_dump
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|char
name|line
index|[
literal|2048
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|lineno
init|=
literal|0
decl_stmt|;
name|struct
name|hdb_entry_ex
name|ent
decl_stmt|;
name|struct
name|prop_data
modifier|*
name|pd
init|=
name|arg
decl_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
name|errno
return|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|line
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_tl_data
decl_stmt|;
name|int
name|num_key_data
decl_stmt|;
name|int
name|high_kvno
decl_stmt|;
name|int
name|attributes
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|lineno
operator|++
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ent
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"kdb5_util"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|major
decl_stmt|;
name|q
operator|=
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* load_dump */
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"load_dump"
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"line %d: unknown version"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|q
operator|=
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* load_dump */
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"version"
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"line %d: unknown version"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|q
operator|=
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* x.0 */
if|if
condition|(
name|sscanf
argument_list|(
name|q
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|major
argument_list|)
operator|!=
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"line %d: unknown version"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|major
operator|!=
literal|4
operator|&&
name|major
operator|!=
literal|5
operator|&&
name|major
operator|!=
literal|6
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown dump file format, got %d, expected 4-6"
argument_list|,
name|major
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"policy"
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"princ"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"line %d: not a principal"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|tmp
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|38
condition|)
block|{
name|warnx
argument_list|(
literal|"line %d: bad base length %d != 38"
argument_list|,
name|lineno
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* length of principal */
name|num_tl_data
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* number of tl-data */
name|num_key_data
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* number of key-data */
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* length of extra data */
name|q
operator|=
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* principal name */
name|krb5_parse_name
argument_list|(
name|pd
operator|->
name|context
argument_list|,
name|q
argument_list|,
operator|&
name|ent
operator|.
name|entry
operator|.
name|principal
argument_list|)
expr_stmt|;
name|attributes
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* attributes */
name|attr_to_flags
argument_list|(
name|attributes
argument_list|,
operator|&
name|ent
operator|.
name|entry
operator|.
name|flags
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* max life */
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
block|{
name|ALLOC
argument_list|(
name|ent
operator|.
name|entry
operator|.
name|max_life
argument_list|)
expr_stmt|;
operator|*
name|ent
operator|.
name|entry
operator|.
name|max_life
operator|=
name|tmp
expr_stmt|;
block|}
name|tmp
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* max renewable life */
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
block|{
name|ALLOC
argument_list|(
name|ent
operator|.
name|entry
operator|.
name|max_renew
argument_list|)
expr_stmt|;
operator|*
name|ent
operator|.
name|entry
operator|.
name|max_renew
operator|=
name|tmp
expr_stmt|;
block|}
name|tmp
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* expiration */
if|if
condition|(
name|tmp
operator|!=
literal|0
operator|&&
name|tmp
operator|!=
literal|2145830400
condition|)
block|{
name|ALLOC
argument_list|(
name|ent
operator|.
name|entry
operator|.
name|valid_end
argument_list|)
expr_stmt|;
operator|*
name|ent
operator|.
name|entry
operator|.
name|valid_end
operator|=
name|tmp
expr_stmt|;
block|}
name|tmp
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* pw expiration */
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
block|{
name|ALLOC
argument_list|(
name|ent
operator|.
name|entry
operator|.
name|pw_end
argument_list|)
expr_stmt|;
operator|*
name|ent
operator|.
name|entry
operator|.
name|pw_end
operator|=
name|tmp
expr_stmt|;
block|}
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* last auth */
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* last failed auth */
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* fail auth count */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_tl_data
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|val
decl_stmt|;
name|int
name|tl_type
decl_stmt|,
name|tl_length
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|krb5_principal
name|princ
decl_stmt|;
name|tl_type
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* data type */
name|tl_length
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* data length */
define|#
directive|define
name|mit_KRB5_TL_LAST_PWD_CHANGE
value|1
define|#
directive|define
name|mit_KRB5_TL_MOD_PRINC
value|2
switch|switch
condition|(
name|tl_type
condition|)
block|{
case|case
name|mit_KRB5_TL_LAST_PWD_CHANGE
case|:
name|buf
operator|=
name|malloc
argument_list|(
name|tl_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|ENOMEM
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|getdata
argument_list|(
operator|&
name|p
argument_list|,
name|buf
argument_list|,
name|tl_length
argument_list|)
expr_stmt|;
comment|/* data itself */
name|val
operator|=
name|buf
index|[
literal|0
index|]
operator||
operator|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|buf
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|buf
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ALLOC
argument_list|(
name|ent
operator|.
name|entry
operator|.
name|extensions
argument_list|)
expr_stmt|;
name|ALLOC_SEQ
argument_list|(
name|ent
operator|.
name|entry
operator|.
name|extensions
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ent
operator|.
name|entry
operator|.
name|extensions
operator|->
name|val
index|[
literal|0
index|]
operator|.
name|mandatory
operator|=
literal|0
expr_stmt|;
name|ent
operator|.
name|entry
operator|.
name|extensions
operator|->
name|val
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|element
operator|=
name|choice_HDB_extension_data_last_pw_change
expr_stmt|;
name|ent
operator|.
name|entry
operator|.
name|extensions
operator|->
name|val
index|[
literal|0
index|]
operator|.
name|data
operator|.
name|u
operator|.
name|last_pw_change
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|mit_KRB5_TL_MOD_PRINC
case|:
name|buf
operator|=
name|malloc
argument_list|(
name|tl_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|ENOMEM
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|getdata
argument_list|(
operator|&
name|p
argument_list|,
name|buf
argument_list|,
name|tl_length
argument_list|)
expr_stmt|;
comment|/* data itself */
name|val
operator|=
name|buf
index|[
literal|0
index|]
operator||
operator|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|buf
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|buf
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|ret
operator|=
name|krb5_parse_name
argument_list|(
name|pd
operator|->
name|context
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
literal|4
argument_list|,
operator|&
name|princ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|krb5_err
argument_list|(
name|pd
operator|->
name|context
argument_list|,
literal|1
argument_list|,
name|ret
argument_list|,
literal|"parse_name: %s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ALLOC
argument_list|(
name|ent
operator|.
name|entry
operator|.
name|modified_by
argument_list|)
expr_stmt|;
name|ent
operator|.
name|entry
operator|.
name|modified_by
operator|->
name|time
operator|=
name|val
expr_stmt|;
name|ent
operator|.
name|entry
operator|.
name|modified_by
operator|->
name|principal
operator|=
name|princ
expr_stmt|;
break|break;
default|default:
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ALLOC_SEQ
argument_list|(
operator|&
name|ent
operator|.
name|entry
operator|.
name|keys
argument_list|,
name|num_key_data
argument_list|)
expr_stmt|;
name|high_kvno
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_key_data
condition|;
name|i
operator|++
control|)
block|{
name|int
name|key_versions
decl_stmt|;
name|int
name|kvno
decl_stmt|;
name|key_versions
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* key data version */
name|kvno
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* 	     * An MIT dump file may contain multiple sets of keys with 	     * different kvnos.  Since the Heimdal database can only represent 	     * one kvno per principal, we only want the highest set.  Assume 	     * that set will be given first, and discard all keys with lower 	     * kvnos. 	     */
if|if
condition|(
name|kvno
operator|>
name|high_kvno
operator|&&
name|high_kvno
operator|!=
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"line %d: high kvno keys given after low kvno keys"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|kvno
operator|<
name|high_kvno
condition|)
block|{
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* key type */
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* key length */
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* key */
if|if
condition|(
name|key_versions
operator|>
literal|1
condition|)
block|{
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* salt type */
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* salt length */
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* salt */
block|}
name|ent
operator|.
name|entry
operator|.
name|keys
operator|.
name|len
operator|--
expr_stmt|;
continue|continue;
block|}
name|ent
operator|.
name|entry
operator|.
name|kvno
operator|=
name|kvno
expr_stmt|;
name|high_kvno
operator|=
name|kvno
expr_stmt|;
name|ALLOC
argument_list|(
name|ent
operator|.
name|entry
operator|.
name|keys
operator|.
name|val
index|[
name|i
index|]
operator|.
name|mkvno
argument_list|)
expr_stmt|;
operator|*
name|ent
operator|.
name|entry
operator|.
name|keys
operator|.
name|val
index|[
name|i
index|]
operator|.
name|mkvno
operator|=
literal|1
expr_stmt|;
comment|/* key version 0 -- actual key */
name|ent
operator|.
name|entry
operator|.
name|keys
operator|.
name|val
index|[
name|i
index|]
operator|.
name|key
operator|.
name|keytype
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* key type */
name|tmp
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* key length */
comment|/* the first two bytes of the key is the key length -- 	       skip it */
name|krb5_data_alloc
argument_list|(
operator|&
name|ent
operator|.
name|entry
operator|.
name|keys
operator|.
name|val
index|[
name|i
index|]
operator|.
name|key
operator|.
name|keyvalue
argument_list|,
name|tmp
operator|-
literal|2
argument_list|)
expr_stmt|;
name|q
operator|=
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* key itself */
name|hex_to_octet_string
argument_list|(
name|q
operator|+
literal|4
argument_list|,
operator|&
name|ent
operator|.
name|entry
operator|.
name|keys
operator|.
name|val
index|[
name|i
index|]
operator|.
name|key
operator|.
name|keyvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_versions
operator|>
literal|1
condition|)
block|{
comment|/* key version 1 -- optional salt */
name|ALLOC
argument_list|(
name|ent
operator|.
name|entry
operator|.
name|keys
operator|.
name|val
index|[
name|i
index|]
operator|.
name|salt
argument_list|)
expr_stmt|;
name|ent
operator|.
name|entry
operator|.
name|keys
operator|.
name|val
index|[
name|i
index|]
operator|.
name|salt
operator|->
name|type
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* salt type */
name|tmp
operator|=
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* salt length */
if|if
condition|(
name|tmp
operator|>
literal|0
condition|)
block|{
name|krb5_data_alloc
argument_list|(
operator|&
name|ent
operator|.
name|entry
operator|.
name|keys
operator|.
name|val
index|[
name|i
index|]
operator|.
name|salt
operator|->
name|salt
argument_list|,
name|tmp
operator|-
literal|2
argument_list|)
expr_stmt|;
name|q
operator|=
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* salt itself */
name|hex_to_octet_string
argument_list|(
name|q
operator|+
literal|4
argument_list|,
operator|&
name|ent
operator|.
name|entry
operator|.
name|keys
operator|.
name|val
index|[
name|i
index|]
operator|.
name|salt
operator|->
name|salt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ent
operator|.
name|entry
operator|.
name|keys
operator|.
name|val
index|[
name|i
index|]
operator|.
name|salt
operator|->
name|salt
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|ent
operator|.
name|entry
operator|.
name|keys
operator|.
name|val
index|[
name|i
index|]
operator|.
name|salt
operator|->
name|salt
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|getint
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* -1, if no data. */
block|}
name|fix_salt
argument_list|(
name|pd
operator|->
name|context
argument_list|,
operator|&
name|ent
operator|.
name|entry
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* extra data */
name|v5_prop
argument_list|(
name|pd
operator|->
name|context
argument_list|,
name|NULL
argument_list|,
operator|&
name|ent
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

