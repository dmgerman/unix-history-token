begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004 - 2009 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"hx_locl.h"
end_include

begin_include
include|#
directive|include
file|<wind.h>
end_include

begin_include
include|#
directive|include
file|"char_map.h"
end_include

begin_comment
comment|/**  * @page page_name PKIX/X.509 Names  *  * There are several names in PKIX/X.509, GeneralName and Name.  *  * A Name consists of an ordered list of Relative Distinguished Names  * (RDN). Each RDN consists of an unordered list of typed strings. The  * types are defined by OID and have long and short description. For  * example id-at-commonName (2.5.4.3) have the long name CommonName  * and short name CN. The string itself can be of several encoding,  * UTF8, UTF16, Teltex string, etc. The type limit what encoding  * should be used.  *  * GeneralName is a broader nametype that can contains al kind of  * stuff like Name, IP addresses, partial Name, etc.  *  * Name is mapped into a hx509_name object.  *  * Parse and string name into a hx509_name object with hx509_parse_name(),  * make it back into string representation with hx509_name_to_string().  *  * Name string are defined rfc2253, rfc1779 and X.501.  *  * See the library functions here: @ref hx509_name  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|n
decl_stmt|;
specifier|const
name|heim_oid
modifier|*
name|o
decl_stmt|;
name|wind_profile_flags
name|flags
decl_stmt|;
block|}
name|no
index|[]
init|=
block|{
block|{
literal|"C"
block|,
operator|&
name|asn1_oid_id_at_countryName
block|,
literal|0
block|}
block|,
block|{
literal|"CN"
block|,
operator|&
name|asn1_oid_id_at_commonName
block|,
literal|0
block|}
block|,
block|{
literal|"DC"
block|,
operator|&
name|asn1_oid_id_domainComponent
block|,
literal|0
block|}
block|,
block|{
literal|"L"
block|,
operator|&
name|asn1_oid_id_at_localityName
block|,
literal|0
block|}
block|,
block|{
literal|"O"
block|,
operator|&
name|asn1_oid_id_at_organizationName
block|,
literal|0
block|}
block|,
block|{
literal|"OU"
block|,
operator|&
name|asn1_oid_id_at_organizationalUnitName
block|,
literal|0
block|}
block|,
block|{
literal|"S"
block|,
operator|&
name|asn1_oid_id_at_stateOrProvinceName
block|,
literal|0
block|}
block|,
block|{
literal|"STREET"
block|,
operator|&
name|asn1_oid_id_at_streetAddress
block|,
literal|0
block|}
block|,
block|{
literal|"UID"
block|,
operator|&
name|asn1_oid_id_Userid
block|,
literal|0
block|}
block|,
block|{
literal|"emailAddress"
block|,
operator|&
name|asn1_oid_id_pkcs9_emailAddress
block|,
literal|0
block|}
block|,
block|{
literal|"serialNumber"
block|,
operator|&
name|asn1_oid_id_at_serialNumber
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|char
modifier|*
name|quote_string
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|flags
parameter_list|,
name|size_t
modifier|*
name|rlen
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|tolen
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|from
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|f
decl_stmt|;
name|unsigned
name|char
modifier|*
name|to
decl_stmt|;
name|tolen
operator|=
name|len
operator|*
literal|3
operator|+
literal|1
expr_stmt|;
name|to
operator|=
name|malloc
argument_list|(
name|tolen
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|map
init|=
name|char_map
index|[
name|from
index|[
name|i
index|]
index|]
operator|&
name|flags
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|map
operator|&
name|Q_RFC2253_QUOTE_FIRST
operator|)
condition|)
block|{
name|to
index|[
name|j
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|to
index|[
name|j
operator|++
index|]
operator|=
name|from
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|==
name|len
operator|&&
operator|(
name|map
operator|&
name|Q_RFC2253_QUOTE_LAST
operator|)
condition|)
block|{
name|to
index|[
name|j
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|to
index|[
name|j
operator|++
index|]
operator|=
name|from
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|map
operator|&
name|Q_RFC2253_QUOTE
condition|)
block|{
name|to
index|[
name|j
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|to
index|[
name|j
operator|++
index|]
operator|=
name|from
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|map
operator|&
name|Q_RFC2253_HEX
condition|)
block|{
name|int
name|l
init|=
name|snprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|to
index|[
name|j
index|]
argument_list|,
name|tolen
operator|-
name|j
operator|-
literal|1
argument_list|,
literal|"#%02x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|from
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|j
operator|+=
name|l
expr_stmt|;
block|}
else|else
block|{
name|to
index|[
name|j
operator|++
index|]
operator|=
name|from
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|to
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|assert
argument_list|(
name|j
operator|<
name|tolen
argument_list|)
expr_stmt|;
operator|*
name|rlen
operator|=
name|j
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|to
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|append_string
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|size_t
modifier|*
name|total_len
parameter_list|,
specifier|const
name|char
modifier|*
name|ss
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|quote
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|qs
decl_stmt|;
if|if
condition|(
name|quote
condition|)
name|qs
operator|=
name|quote_string
argument_list|(
name|ss
argument_list|,
name|len
argument_list|,
name|Q_RFC2253
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
else|else
name|qs
operator|=
name|rk_UNCONST
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|s
operator|=
name|realloc
argument_list|(
operator|*
name|str
argument_list|,
name|len
operator|+
operator|*
name|total_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|_hx509_abort
argument_list|(
literal|"allocation failure"
argument_list|)
expr_stmt|;
comment|/* XXX */
name|memcpy
argument_list|(
name|s
operator|+
operator|*
name|total_len
argument_list|,
name|qs
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|qs
operator|!=
name|ss
condition|)
name|free
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|s
index|[
operator|*
name|total_len
operator|+
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|str
operator|=
name|s
expr_stmt|;
operator|*
name|total_len
operator|+=
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|oidtostring
parameter_list|(
specifier|const
name|heim_oid
modifier|*
name|type
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|no
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|no
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|der_heim_oid_cmp
argument_list|(
name|no
index|[
name|i
index|]
operator|.
name|o
argument_list|,
name|type
argument_list|)
operator|==
literal|0
condition|)
return|return
name|strdup
argument_list|(
name|no
index|[
name|i
index|]
operator|.
name|n
argument_list|)
return|;
block|}
if|if
condition|(
name|der_print_heim_oid
argument_list|(
name|type
argument_list|,
literal|'.'
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|stringtooid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|,
name|heim_oid
modifier|*
name|oid
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|memset
argument_list|(
name|oid
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|oid
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|no
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|no
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|no
index|[
name|i
index|]
operator|.
name|n
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|der_copy_oid
argument_list|(
name|no
index|[
name|i
index|]
operator|.
name|o
argument_list|,
name|oid
argument_list|)
return|;
block|}
name|s
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|=
name|der_parse_heim_oid
argument_list|(
name|s
argument_list|,
literal|"."
argument_list|,
name|oid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Convert the hx509 name object into a printable string.  * The resulting string should be freed with free().  *  * @param name name to print  * @param str the string to return  *  * @return An hx509 error code, see hx509_get_error_string().  *  * @ingroup hx509_name  */
end_comment

begin_function
name|int
name|hx509_name_to_string
parameter_list|(
specifier|const
name|hx509_name
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
return|return
name|_hx509_Name_to_string
argument_list|(
operator|&
name|name
operator|->
name|der_name
argument_list|,
name|str
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|_hx509_Name_to_string
parameter_list|(
specifier|const
name|Name
modifier|*
name|n
parameter_list|,
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|size_t
name|total_len
init|=
literal|0
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|m
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|*
name|str
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
for|for
control|(
name|m
operator|=
name|n
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|len
init|;
name|m
operator|>
literal|0
condition|;
name|m
operator|--
control|)
block|{
name|size_t
name|len
decl_stmt|;
name|i
operator|=
name|m
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
name|i
index|]
operator|.
name|len
condition|;
name|j
operator|++
control|)
block|{
name|DirectoryString
modifier|*
name|ds
init|=
operator|&
name|n
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
name|i
index|]
operator|.
name|val
index|[
name|j
index|]
operator|.
name|value
decl_stmt|;
name|char
modifier|*
name|oidname
decl_stmt|;
name|char
modifier|*
name|ss
decl_stmt|;
name|oidname
operator|=
name|oidtostring
argument_list|(
operator|&
name|n
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
name|i
index|]
operator|.
name|val
index|[
name|j
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ds
operator|->
name|element
condition|)
block|{
case|case
name|choice_DirectoryString_ia5String
case|:
name|ss
operator|=
name|ds
operator|->
name|u
operator|.
name|ia5String
operator|.
name|data
expr_stmt|;
name|len
operator|=
name|ds
operator|->
name|u
operator|.
name|ia5String
operator|.
name|length
expr_stmt|;
break|break;
case|case
name|choice_DirectoryString_printableString
case|:
name|ss
operator|=
name|ds
operator|->
name|u
operator|.
name|printableString
operator|.
name|data
expr_stmt|;
name|len
operator|=
name|ds
operator|->
name|u
operator|.
name|printableString
operator|.
name|length
expr_stmt|;
break|break;
case|case
name|choice_DirectoryString_utf8String
case|:
name|ss
operator|=
name|ds
operator|->
name|u
operator|.
name|utf8String
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ss
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_DirectoryString_bmpString
case|:
block|{
specifier|const
name|uint16_t
modifier|*
name|bmp
init|=
name|ds
operator|->
name|u
operator|.
name|bmpString
operator|.
name|data
decl_stmt|;
name|size_t
name|bmplen
init|=
name|ds
operator|->
name|u
operator|.
name|bmpString
operator|.
name|length
decl_stmt|;
name|size_t
name|k
decl_stmt|;
name|ret
operator|=
name|wind_ucs2utf8_length
argument_list|(
name|bmp
argument_list|,
name|bmplen
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ss
operator|=
name|malloc
argument_list|(
name|k
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
condition|)
name|_hx509_abort
argument_list|(
literal|"allocation failure"
argument_list|)
expr_stmt|;
comment|/* XXX */
name|ret
operator|=
name|wind_ucs2utf8
argument_list|(
name|bmp
argument_list|,
name|bmplen
argument_list|,
name|ss
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ss
index|[
name|k
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|k
expr_stmt|;
break|break;
block|}
case|case
name|choice_DirectoryString_teletexString
case|:
name|ss
operator|=
name|ds
operator|->
name|u
operator|.
name|teletexString
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ss
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_DirectoryString_universalString
case|:
block|{
specifier|const
name|uint32_t
modifier|*
name|uni
init|=
name|ds
operator|->
name|u
operator|.
name|universalString
operator|.
name|data
decl_stmt|;
name|size_t
name|unilen
init|=
name|ds
operator|->
name|u
operator|.
name|universalString
operator|.
name|length
decl_stmt|;
name|size_t
name|k
decl_stmt|;
name|ret
operator|=
name|wind_ucs4utf8_length
argument_list|(
name|uni
argument_list|,
name|unilen
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ss
operator|=
name|malloc
argument_list|(
name|k
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
condition|)
name|_hx509_abort
argument_list|(
literal|"allocation failure"
argument_list|)
expr_stmt|;
comment|/* XXX */
name|ret
operator|=
name|wind_ucs4utf8
argument_list|(
name|uni
argument_list|,
name|unilen
argument_list|,
name|ss
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ss
index|[
name|k
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|k
expr_stmt|;
break|break;
block|}
default|default:
name|_hx509_abort
argument_list|(
literal|"unknown directory type: %d"
argument_list|,
name|ds
operator|->
name|element
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|append_string
argument_list|(
name|str
argument_list|,
operator|&
name|total_len
argument_list|,
name|oidname
argument_list|,
name|strlen
argument_list|(
name|oidname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oidname
argument_list|)
expr_stmt|;
name|append_string
argument_list|(
name|str
argument_list|,
operator|&
name|total_len
argument_list|,
literal|"="
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|append_string
argument_list|(
name|str
argument_list|,
operator|&
name|total_len
argument_list|,
name|ss
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|element
operator|==
name|choice_DirectoryString_bmpString
operator|||
name|ds
operator|->
name|element
operator|==
name|choice_DirectoryString_universalString
condition|)
block|{
name|free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|+
literal|1
operator|<
name|n
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
name|i
index|]
operator|.
name|len
condition|)
name|append_string
argument_list|(
name|str
argument_list|,
operator|&
name|total_len
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|append_string
argument_list|(
name|str
argument_list|,
operator|&
name|total_len
argument_list|,
literal|","
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|COPYCHARARRAY
parameter_list|(
name|_ds
parameter_list|,
name|_el
parameter_list|,
name|_l
parameter_list|,
name|_n
parameter_list|)
define|\
value|(_l) = strlen(_ds->u._el);		\ 	(_n) = malloc((_l) * sizeof((_n)[0]));	\ 	if ((_n) == NULL)			\ 	    return ENOMEM;			\ 	for (i = 0; i< (_l); i++)		\ 	    (_n)[i] = _ds->u._el[i]
end_define

begin_define
define|#
directive|define
name|COPYVALARRAY
parameter_list|(
name|_ds
parameter_list|,
name|_el
parameter_list|,
name|_l
parameter_list|,
name|_n
parameter_list|)
define|\
value|(_l) = _ds->u._el.length;		\ 	(_n) = malloc((_l) * sizeof((_n)[0]));	\ 	if ((_n) == NULL)			\ 	    return ENOMEM;			\ 	for (i = 0; i< (_l); i++)		\ 	    (_n)[i] = _ds->u._el.data[i]
end_define

begin_define
define|#
directive|define
name|COPYVOIDARRAY
parameter_list|(
name|_ds
parameter_list|,
name|_el
parameter_list|,
name|_l
parameter_list|,
name|_n
parameter_list|)
define|\
value|(_l) = _ds->u._el.length;		\ 	(_n) = malloc((_l) * sizeof((_n)[0]));	\ 	if ((_n) == NULL)			\ 	    return ENOMEM;			\ 	for (i = 0; i< (_l); i++)		\ 	    (_n)[i] = ((unsigned char *)_ds->u._el.data)[i]
end_define

begin_function
specifier|static
name|int
name|dsstringprep
parameter_list|(
specifier|const
name|DirectoryString
modifier|*
name|ds
parameter_list|,
name|uint32_t
modifier|*
modifier|*
name|rname
parameter_list|,
name|size_t
modifier|*
name|rlen
parameter_list|)
block|{
name|wind_profile_flags
name|flags
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|uint32_t
modifier|*
name|name
decl_stmt|;
operator|*
name|rname
operator|=
name|NULL
expr_stmt|;
operator|*
name|rlen
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ds
operator|->
name|element
condition|)
block|{
case|case
name|choice_DirectoryString_ia5String
case|:
name|flags
operator|=
name|WIND_PROFILE_LDAP
expr_stmt|;
name|COPYVOIDARRAY
argument_list|(
name|ds
argument_list|,
name|ia5String
argument_list|,
name|len
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_DirectoryString_printableString
case|:
name|flags
operator|=
name|WIND_PROFILE_LDAP
expr_stmt|;
name|flags
operator||=
name|WIND_PROFILE_LDAP_CASE_EXACT_ATTRIBUTE
expr_stmt|;
name|COPYVOIDARRAY
argument_list|(
name|ds
argument_list|,
name|printableString
argument_list|,
name|len
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_DirectoryString_teletexString
case|:
name|flags
operator|=
name|WIND_PROFILE_LDAP_CASE
expr_stmt|;
name|COPYCHARARRAY
argument_list|(
name|ds
argument_list|,
name|teletexString
argument_list|,
name|len
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_DirectoryString_bmpString
case|:
name|flags
operator|=
name|WIND_PROFILE_LDAP
expr_stmt|;
name|COPYVALARRAY
argument_list|(
name|ds
argument_list|,
name|bmpString
argument_list|,
name|len
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_DirectoryString_universalString
case|:
name|flags
operator|=
name|WIND_PROFILE_LDAP
expr_stmt|;
name|COPYVALARRAY
argument_list|(
name|ds
argument_list|,
name|universalString
argument_list|,
name|len
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_DirectoryString_utf8String
case|:
name|flags
operator|=
name|WIND_PROFILE_LDAP
expr_stmt|;
name|ret
operator|=
name|wind_utf8ucs4_length
argument_list|(
name|ds
operator|->
name|u
operator|.
name|utf8String
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|name
operator|=
name|malloc
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|ret
operator|=
name|wind_utf8ucs4
argument_list|(
name|ds
operator|->
name|u
operator|.
name|utf8String
argument_list|,
name|name
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
break|break;
default|default:
name|_hx509_abort
argument_list|(
literal|"unknown directory type: %d"
argument_list|,
name|ds
operator|->
name|element
argument_list|)
expr_stmt|;
block|}
operator|*
name|rlen
operator|=
name|len
expr_stmt|;
comment|/* try a couple of times to get the length right, XXX gross */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|rlen
operator|=
operator|*
name|rlen
operator|*
literal|2
expr_stmt|;
operator|*
name|rname
operator|=
name|malloc
argument_list|(
operator|*
name|rlen
operator|*
sizeof|sizeof
argument_list|(
operator|(
operator|*
name|rname
operator|)
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|wind_stringprep
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
operator|*
name|rname
argument_list|,
name|rlen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|WIND_ERR_OVERRUN
condition|)
block|{
name|free
argument_list|(
operator|*
name|rname
argument_list|)
expr_stmt|;
operator|*
name|rname
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
operator|*
name|rname
condition|)
name|free
argument_list|(
operator|*
name|rname
argument_list|)
expr_stmt|;
operator|*
name|rname
operator|=
name|NULL
expr_stmt|;
operator|*
name|rlen
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|_hx509_name_ds_cmp
parameter_list|(
specifier|const
name|DirectoryString
modifier|*
name|ds1
parameter_list|,
specifier|const
name|DirectoryString
modifier|*
name|ds2
parameter_list|,
name|int
modifier|*
name|diff
parameter_list|)
block|{
name|uint32_t
modifier|*
name|ds1lp
decl_stmt|,
modifier|*
name|ds2lp
decl_stmt|;
name|size_t
name|ds1len
decl_stmt|,
name|ds2len
decl_stmt|,
name|i
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|dsstringprep
argument_list|(
name|ds1
argument_list|,
operator|&
name|ds1lp
argument_list|,
operator|&
name|ds1len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|dsstringprep
argument_list|(
name|ds2
argument_list|,
operator|&
name|ds2lp
argument_list|,
operator|&
name|ds2len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|ds1lp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|ds1len
operator|!=
name|ds2len
condition|)
operator|*
name|diff
operator|=
name|ds1len
operator|-
name|ds2len
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ds1len
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|diff
operator|=
name|ds1lp
index|[
name|i
index|]
operator|-
name|ds2lp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|diff
condition|)
break|break;
block|}
block|}
name|free
argument_list|(
name|ds1lp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ds2lp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|_hx509_name_cmp
parameter_list|(
specifier|const
name|Name
modifier|*
name|n1
parameter_list|,
specifier|const
name|Name
modifier|*
name|n2
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
operator|*
name|c
operator|=
name|n1
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|len
operator|-
name|n2
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|*
name|c
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n1
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|c
operator|=
name|n1
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
name|i
index|]
operator|.
name|len
operator|-
name|n2
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|*
name|c
condition|)
return|return
literal|0
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n1
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
name|i
index|]
operator|.
name|len
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|c
operator|=
name|der_heim_oid_cmp
argument_list|(
operator|&
name|n1
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
name|i
index|]
operator|.
name|val
index|[
name|j
index|]
operator|.
name|type
argument_list|,
operator|&
name|n1
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
name|i
index|]
operator|.
name|val
index|[
name|j
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|c
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|_hx509_name_ds_cmp
argument_list|(
operator|&
name|n1
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
name|i
index|]
operator|.
name|val
index|[
name|j
index|]
operator|.
name|value
argument_list|,
operator|&
name|n2
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
name|i
index|]
operator|.
name|val
index|[
name|j
index|]
operator|.
name|value
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|*
name|c
condition|)
return|return
literal|0
return|;
block|}
block|}
operator|*
name|c
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Compare to hx509 name object, useful for sorting.  *  * @param n1 a hx509 name object.  * @param n2 a hx509 name object.  *  * @return 0 the objects are the same, returns> 0 is n2 is "larger"  * then n2,< 0 if n1 is "smaller" then n2.  *  * @ingroup hx509_name  */
end_comment

begin_function
name|int
name|hx509_name_cmp
parameter_list|(
name|hx509_name
name|n1
parameter_list|,
name|hx509_name
name|n2
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|diff
decl_stmt|;
name|ret
operator|=
name|_hx509_name_cmp
argument_list|(
operator|&
name|n1
operator|->
name|der_name
argument_list|,
operator|&
name|n2
operator|->
name|der_name
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
return|return
name|diff
return|;
block|}
end_function

begin_function
name|int
name|_hx509_name_from_Name
parameter_list|(
specifier|const
name|Name
modifier|*
name|n
parameter_list|,
name|hx509_name
modifier|*
name|name
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
operator|*
name|name
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|ret
operator|=
name|copy_Name
argument_list|(
name|n
argument_list|,
operator|&
operator|(
operator|*
name|name
operator|)
operator|->
name|der_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
operator|*
name|name
argument_list|)
expr_stmt|;
operator|*
name|name
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|_hx509_name_modify
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|Name
modifier|*
name|name
parameter_list|,
name|int
name|append
parameter_list|,
specifier|const
name|heim_oid
modifier|*
name|oid
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|RelativeDistinguishedName
modifier|*
name|rdn
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|realloc
argument_list|(
name|name
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|name
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|name
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|name
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|append
condition|)
block|{
name|rdn
operator|=
operator|&
name|name
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
name|name
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|len
index|]
expr_stmt|;
block|}
else|else
block|{
name|memmove
argument_list|(
operator|&
name|name
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
literal|1
index|]
argument_list|,
operator|&
name|name
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
literal|0
index|]
argument_list|,
name|name
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|len
operator|*
sizeof|sizeof
argument_list|(
name|name
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|rdn
operator|=
operator|&
name|name
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
block|}
name|rdn
operator|->
name|val
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rdn
operator|->
name|val
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdn
operator|->
name|val
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|rdn
operator|->
name|len
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|der_copy_oid
argument_list|(
name|oid
argument_list|,
operator|&
name|rdn
operator|->
name|val
index|[
literal|0
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|rdn
operator|->
name|val
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|element
operator|=
name|choice_DirectoryString_utf8String
expr_stmt|;
name|rdn
operator|->
name|val
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|u
operator|.
name|utf8String
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdn
operator|->
name|val
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|u
operator|.
name|utf8String
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|name
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|len
operator|+=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Parse a string into a hx509 name object.  *  * @param context A hx509 context.  * @param str a string to parse.  * @param name the resulting object, NULL in case of error.  *  * @return An hx509 error code, see hx509_get_error_string().  *  * @ingroup hx509_name  */
end_comment

begin_function
name|int
name|hx509_parse_name
parameter_list|(
name|hx509_context
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|hx509_name
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|hx509_name
name|n
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|*
name|name
operator|=
name|NULL
expr_stmt|;
name|n
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ENOMEM
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|n
operator|->
name|der_name
operator|.
name|element
operator|=
name|choice_Name_rdnSequence
expr_stmt|;
name|p
operator|=
name|str
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|heim_oid
name|oid
decl_stmt|;
name|int
name|last
decl_stmt|;
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
block|{
name|len
operator|=
operator|(
name|q
operator|-
name|p
operator|)
expr_stmt|;
name|last
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|HX509_PARSING_NAME_FAILED
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"missing = in %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|q
operator|==
name|p
condition|)
block|{
name|ret
operator|=
name|HX509_PARSING_NAME_FAILED
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"missing name before = in %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|q
operator|-
name|p
argument_list|)
operator|>
name|len
condition|)
block|{
name|ret
operator|=
name|HX509_PARSING_NAME_FAILED
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|" = after , in %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|stringtooid
argument_list|(
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|,
operator|&
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ret
operator|=
name|HX509_PARSING_NAME_FAILED
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"unknown type: %.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|q
operator|-
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|{
name|size_t
name|pstr_len
init|=
name|len
operator|-
operator|(
name|q
operator|-
name|p
operator|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|pstr
init|=
name|p
operator|+
operator|(
name|q
operator|-
name|p
operator|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|malloc
argument_list|(
name|pstr_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|der_free_oid
argument_list|(
operator|&
name|oid
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memcpy
argument_list|(
name|r
argument_list|,
name|pstr
argument_list|,
name|pstr_len
argument_list|)
expr_stmt|;
name|r
index|[
name|pstr_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|=
name|_hx509_name_modify
argument_list|(
name|context
argument_list|,
operator|&
name|n
operator|->
name|der_name
argument_list|,
literal|0
argument_list|,
operator|&
name|oid
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|der_free_oid
argument_list|(
operator|&
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
name|p
operator|+=
name|len
operator|+
name|last
expr_stmt|;
block|}
operator|*
name|name
operator|=
name|n
expr_stmt|;
return|return
literal|0
return|;
name|out
label|:
name|hx509_name_free
argument_list|(
operator|&
name|n
argument_list|)
expr_stmt|;
return|return
name|HX509_NAME_MALFORMED
return|;
block|}
end_function

begin_comment
comment|/**  * Copy a hx509 name object.  *  * @param context A hx509 cotext.  * @param from the name to copy from  * @param to the name to copy to  *  * @return An hx509 error code, see hx509_get_error_string().  *  * @ingroup hx509_name  */
end_comment

begin_function
name|int
name|hx509_name_copy
parameter_list|(
name|hx509_context
name|context
parameter_list|,
specifier|const
name|hx509_name
name|from
parameter_list|,
name|hx509_name
modifier|*
name|to
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
operator|*
name|to
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|to
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|to
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|ret
operator|=
name|copy_Name
argument_list|(
operator|&
name|from
operator|->
name|der_name
argument_list|,
operator|&
operator|(
operator|*
name|to
operator|)
operator|->
name|der_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
operator|*
name|to
argument_list|)
expr_stmt|;
operator|*
name|to
operator|=
name|NULL
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Convert a hx509_name into a Name.  *  * @param from the name to copy from  * @param to the name to copy to  *  * @return An hx509 error code, see hx509_get_error_string().  *  * @ingroup hx509_name  */
end_comment

begin_function
name|int
name|hx509_name_to_Name
parameter_list|(
specifier|const
name|hx509_name
name|from
parameter_list|,
name|Name
modifier|*
name|to
parameter_list|)
block|{
return|return
name|copy_Name
argument_list|(
operator|&
name|from
operator|->
name|der_name
argument_list|,
name|to
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|hx509_name_normalize
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_name
name|name
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Expands variables in the name using env. Variables are on the form  * ${name}. Useful when dealing with certificate templates.  *  * @param context A hx509 cotext.  * @param name the name to expand.  * @param env environment variable to expand.  *  * @return An hx509 error code, see hx509_get_error_string().  *  * @ingroup hx509_name  */
end_comment

begin_function
name|int
name|hx509_name_expand
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_name
name|name
parameter_list|,
name|hx509_env
name|env
parameter_list|)
block|{
name|Name
modifier|*
name|n
init|=
operator|&
name|name
operator|->
name|der_name
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|n
operator|->
name|element
operator|!=
name|choice_Name_rdnSequence
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|EINVAL
argument_list|,
literal|"RDN not of supported type"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
name|i
index|]
operator|.
name|len
condition|;
name|j
operator|++
control|)
block|{
comment|/** Only UTF8String rdnSequence names are allowed */
comment|/* 	      THIS SHOULD REALLY BE: 	      COMP = n->u.rdnSequence.val[i].val[j]; 	      normalize COMP to utf8 	      check if there are variables 	        expand variables 	        convert back to orignal format, store in COMP 	      free normalized utf8 string 	    */
name|DirectoryString
modifier|*
name|ds
init|=
operator|&
name|n
operator|->
name|u
operator|.
name|rdnSequence
operator|.
name|val
index|[
name|i
index|]
operator|.
name|val
index|[
name|j
index|]
operator|.
name|value
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|struct
name|rk_strpool
modifier|*
name|strpool
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|element
operator|!=
name|choice_DirectoryString_utf8String
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|EINVAL
argument_list|,
literal|"unsupported type"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|p
operator|=
name|strstr
argument_list|(
name|ds
operator|->
name|u
operator|.
name|utf8String
argument_list|,
literal|"${"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|strpool
operator|=
name|rk_strpoolprintf
argument_list|(
name|strpool
argument_list|,
literal|"%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|ds
operator|->
name|u
operator|.
name|utf8String
argument_list|)
argument_list|,
name|ds
operator|->
name|u
operator|.
name|utf8String
argument_list|)
expr_stmt|;
if|if
condition|(
name|strpool
operator|==
name|NULL
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ENOMEM
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* expand variables */
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|p2
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NULL
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|EINVAL
argument_list|,
literal|"missing }"
argument_list|)
expr_stmt|;
name|rk_strpoolfree
argument_list|(
name|strpool
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|p
operator|+=
literal|2
expr_stmt|;
name|value
operator|=
name|hx509_env_lfind
argument_list|(
name|context
argument_list|,
name|env
argument_list|,
name|p
argument_list|,
name|p2
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|EINVAL
argument_list|,
literal|"variable %.*s missing"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p2
operator|-
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|rk_strpoolfree
argument_list|(
name|strpool
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|strpool
operator|=
name|rk_strpoolprintf
argument_list|(
name|strpool
argument_list|,
literal|"%s"
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|strpool
operator|==
name|NULL
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ENOMEM
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|p2
operator|++
expr_stmt|;
name|p
operator|=
name|strstr
argument_list|(
name|p2
argument_list|,
literal|"${"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|strpool
operator|=
name|rk_strpoolprintf
argument_list|(
name|strpool
argument_list|,
literal|"%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|p2
argument_list|)
argument_list|,
name|p2
argument_list|)
expr_stmt|;
else|else
name|strpool
operator|=
name|rk_strpoolprintf
argument_list|(
name|strpool
argument_list|,
literal|"%s"
argument_list|,
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|strpool
operator|==
name|NULL
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ENOMEM
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
if|if
condition|(
name|strpool
condition|)
block|{
name|free
argument_list|(
name|ds
operator|->
name|u
operator|.
name|utf8String
argument_list|)
expr_stmt|;
name|ds
operator|->
name|u
operator|.
name|utf8String
operator|=
name|rk_strpoolcollect
argument_list|(
name|strpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|u
operator|.
name|utf8String
operator|==
name|NULL
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ENOMEM
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Free a hx509 name object, upond return *name will be NULL.  *  * @param name a hx509 name object to be freed.  *  * @ingroup hx509_name  */
end_comment

begin_function
name|void
name|hx509_name_free
parameter_list|(
name|hx509_name
modifier|*
name|name
parameter_list|)
block|{
name|free_Name
argument_list|(
operator|&
operator|(
operator|*
name|name
operator|)
operator|->
name|der_name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|name
argument_list|)
expr_stmt|;
operator|*
name|name
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Convert a DER encoded name info a string.  *  * @param data data to a DER/BER encoded name  * @param length length of data  * @param str the resulting string, is NULL on failure.  *  * @return An hx509 error code, see hx509_get_error_string().  *  * @ingroup hx509_name  */
end_comment

begin_function
name|int
name|hx509_unparse_der_name
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|length
parameter_list|,
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|Name
name|name
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|*
name|str
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|decode_Name
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|_hx509_Name_to_string
argument_list|(
operator|&
name|name
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|free_Name
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Convert a hx509_name object to DER encoded name.  *  * @param name name to concert  * @param os data to a DER encoded name, free the resulting octet  * string with hx509_xfree(os->data).  *  * @return An hx509 error code, see hx509_get_error_string().  *  * @ingroup hx509_name  */
end_comment

begin_function
name|int
name|hx509_name_binary
parameter_list|(
specifier|const
name|hx509_name
name|name
parameter_list|,
name|heim_octet_string
modifier|*
name|os
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ASN1_MALLOC_ENCODE
argument_list|(
name|Name
argument_list|,
name|os
operator|->
name|data
argument_list|,
name|os
operator|->
name|length
argument_list|,
operator|&
name|name
operator|->
name|der_name
argument_list|,
operator|&
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|os
operator|->
name|length
operator|!=
name|size
condition|)
name|_hx509_abort
argument_list|(
literal|"internal ASN.1 encoder error"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|_hx509_unparse_Name
parameter_list|(
specifier|const
name|Name
modifier|*
name|aname
parameter_list|,
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|hx509_name
name|name
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|_hx509_name_from_Name
argument_list|(
name|aname
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|hx509_name_to_string
argument_list|(
name|name
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|hx509_name_free
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Unparse the hx509 name in name into a string.  *  * @param name the name to check if its empty/null.  *  * @return non zero if the name is empty/null.  *  * @ingroup hx509_name  */
end_comment

begin_function
name|int
name|hx509_name_is_null_p
parameter_list|(
specifier|const
name|hx509_name
name|name
parameter_list|)
block|{
return|return
name|name
operator|->
name|der_name
operator|.
name|u
operator|.
name|rdnSequence
operator|.
name|len
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Unparse the hx509 name in name into a string.  *  * @param name the name to print  * @param str an allocated string returns the name in string form  *  * @return An hx509 error code, see hx509_get_error_string().  *  * @ingroup hx509_name  */
end_comment

begin_function
name|int
name|hx509_general_name_unparse
parameter_list|(
name|GeneralName
modifier|*
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|rk_strpool
modifier|*
name|strpool
init|=
name|NULL
decl_stmt|;
operator|*
name|str
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|name
operator|->
name|element
condition|)
block|{
case|case
name|choice_GeneralName_otherName
case|:
block|{
name|char
modifier|*
name|oid
decl_stmt|;
name|hx509_oid_sprint
argument_list|(
operator|&
name|name
operator|->
name|u
operator|.
name|otherName
operator|.
name|type_id
argument_list|,
operator|&
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|oid
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|strpool
operator|=
name|rk_strpoolprintf
argument_list|(
name|strpool
argument_list|,
literal|"otherName: %s"
argument_list|,
name|oid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oid
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|choice_GeneralName_rfc822Name
case|:
name|strpool
operator|=
name|rk_strpoolprintf
argument_list|(
name|strpool
argument_list|,
literal|"rfc822Name: %.*s\n"
argument_list|,
operator|(
name|int
operator|)
name|name
operator|->
name|u
operator|.
name|rfc822Name
operator|.
name|length
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
operator|->
name|u
operator|.
name|rfc822Name
operator|.
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_GeneralName_dNSName
case|:
name|strpool
operator|=
name|rk_strpoolprintf
argument_list|(
name|strpool
argument_list|,
literal|"dNSName: %.*s\n"
argument_list|,
operator|(
name|int
operator|)
name|name
operator|->
name|u
operator|.
name|dNSName
operator|.
name|length
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
operator|->
name|u
operator|.
name|dNSName
operator|.
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_GeneralName_directoryName
case|:
block|{
name|Name
name|dir
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|dir
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|.
name|element
operator|=
name|name
operator|->
name|u
operator|.
name|directoryName
operator|.
name|element
expr_stmt|;
name|dir
operator|.
name|u
operator|.
name|rdnSequence
operator|=
name|name
operator|->
name|u
operator|.
name|directoryName
operator|.
name|u
operator|.
name|rdnSequence
expr_stmt|;
name|ret
operator|=
name|_hx509_unparse_Name
argument_list|(
operator|&
name|dir
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|strpool
operator|=
name|rk_strpoolprintf
argument_list|(
name|strpool
argument_list|,
literal|"directoryName: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|choice_GeneralName_uniformResourceIdentifier
case|:
name|strpool
operator|=
name|rk_strpoolprintf
argument_list|(
name|strpool
argument_list|,
literal|"URI: %.*s"
argument_list|,
operator|(
name|int
operator|)
name|name
operator|->
name|u
operator|.
name|uniformResourceIdentifier
operator|.
name|length
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
operator|->
name|u
operator|.
name|uniformResourceIdentifier
operator|.
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_GeneralName_iPAddress
case|:
block|{
name|unsigned
name|char
modifier|*
name|a
init|=
name|name
operator|->
name|u
operator|.
name|iPAddress
operator|.
name|data
decl_stmt|;
name|strpool
operator|=
name|rk_strpoolprintf
argument_list|(
name|strpool
argument_list|,
literal|"IPAddress: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|strpool
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|name
operator|->
name|u
operator|.
name|iPAddress
operator|.
name|length
operator|==
literal|4
condition|)
name|strpool
operator|=
name|rk_strpoolprintf
argument_list|(
name|strpool
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|->
name|u
operator|.
name|iPAddress
operator|.
name|length
operator|==
literal|16
condition|)
name|strpool
operator|=
name|rk_strpoolprintf
argument_list|(
name|strpool
argument_list|,
literal|"%02X:%02X:%02X:%02X:"
literal|"%02X:%02X:%02X:%02X:"
literal|"%02X:%02X:%02X:%02X:"
literal|"%02X:%02X:%02X:%02X"
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|,
name|a
index|[
literal|8
index|]
argument_list|,
name|a
index|[
literal|9
index|]
argument_list|,
name|a
index|[
literal|10
index|]
argument_list|,
name|a
index|[
literal|11
index|]
argument_list|,
name|a
index|[
literal|12
index|]
argument_list|,
name|a
index|[
literal|13
index|]
argument_list|,
name|a
index|[
literal|14
index|]
argument_list|,
name|a
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
else|else
name|strpool
operator|=
name|rk_strpoolprintf
argument_list|(
name|strpool
argument_list|,
literal|"unknown IP address of length %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|name
operator|->
name|u
operator|.
name|iPAddress
operator|.
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|choice_GeneralName_registeredID
case|:
block|{
name|char
modifier|*
name|oid
decl_stmt|;
name|hx509_oid_sprint
argument_list|(
operator|&
name|name
operator|->
name|u
operator|.
name|registeredID
argument_list|,
operator|&
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|oid
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|strpool
operator|=
name|rk_strpoolprintf
argument_list|(
name|strpool
argument_list|,
literal|"registeredID: %s"
argument_list|,
name|oid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oid
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|strpool
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
operator|*
name|str
operator|=
name|rk_strpoolcollect
argument_list|(
name|strpool
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

