begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2003 - 2007 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"hx_locl.h"
end_include

begin_comment
comment|/**  * @page page_cms CMS/PKCS7 message functions.  *  * CMS is defined in RFC 3369 and is an continuation of the RSA Labs  * standard PKCS7. The basic messages in CMS is  *  * - SignedData  *   Data signed with private key (RSA, DSA, ECDSA) or secret  *   (symmetric) key  * - EnvelopedData  *   Data encrypted with private key (RSA)  * - EncryptedData  *   Data encrypted with secret (symmetric) key.  * - ContentInfo  *   Wrapper structure including type and data.  *  *  * See the library functions here: @ref hx509_cms  */
end_comment

begin_define
define|#
directive|define
name|ALLOC
parameter_list|(
name|X
parameter_list|,
name|N
parameter_list|)
value|(X) = calloc((N), sizeof(*(X)))
end_define

begin_define
define|#
directive|define
name|ALLOC_SEQ
parameter_list|(
name|X
parameter_list|,
name|N
parameter_list|)
value|do { (X)->len = (N); ALLOC((X)->val, (N)); } while(0)
end_define

begin_comment
comment|/**  * Wrap data and oid in a ContentInfo and encode it.  *  * @param oid type of the content.  * @param buf data to be wrapped. If a NULL pointer is passed in, the  * optional content field in the ContentInfo is not going be filled  * in.  * @param res the encoded buffer, the result should be freed with  * der_free_octet_string().  *  * @return Returns an hx509 error code.  *  * @ingroup hx509_cms  */
end_comment

begin_function
name|int
name|hx509_cms_wrap_ContentInfo
parameter_list|(
specifier|const
name|heim_oid
modifier|*
name|oid
parameter_list|,
specifier|const
name|heim_octet_string
modifier|*
name|buf
parameter_list|,
name|heim_octet_string
modifier|*
name|res
parameter_list|)
block|{
name|ContentInfo
name|ci
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
name|res
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ci
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ci
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|der_copy_oid
argument_list|(
name|oid
argument_list|,
operator|&
name|ci
operator|.
name|contentType
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|buf
condition|)
block|{
name|ALLOC
argument_list|(
name|ci
operator|.
name|content
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|.
name|content
operator|==
name|NULL
condition|)
block|{
name|free_ContentInfo
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|ci
operator|.
name|content
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|buf
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|.
name|content
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|free_ContentInfo
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|memcpy
argument_list|(
name|ci
operator|.
name|content
operator|->
name|data
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|length
argument_list|)
expr_stmt|;
name|ci
operator|.
name|content
operator|->
name|length
operator|=
name|buf
operator|->
name|length
expr_stmt|;
block|}
name|ASN1_MALLOC_ENCODE
argument_list|(
name|ContentInfo
argument_list|,
name|res
operator|->
name|data
argument_list|,
name|res
operator|->
name|length
argument_list|,
operator|&
name|ci
argument_list|,
operator|&
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|free_ContentInfo
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|res
operator|->
name|length
operator|!=
name|size
condition|)
name|_hx509_abort
argument_list|(
literal|"internal ASN.1 encoder error"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Decode an ContentInfo and unwrap data and oid it.  *  * @param in the encoded buffer.  * @param oid type of the content.  * @param out data to be wrapped.  * @param have_data since the data is optional, this flags show dthe  * diffrence between no data and the zero length data.  *  * @return Returns an hx509 error code.  *  * @ingroup hx509_cms  */
end_comment

begin_function
name|int
name|hx509_cms_unwrap_ContentInfo
parameter_list|(
specifier|const
name|heim_octet_string
modifier|*
name|in
parameter_list|,
name|heim_oid
modifier|*
name|oid
parameter_list|,
name|heim_octet_string
modifier|*
name|out
parameter_list|,
name|int
modifier|*
name|have_data
parameter_list|)
block|{
name|ContentInfo
name|ci
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
name|oid
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|oid
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|decode_ContentInfo
argument_list|(
name|in
operator|->
name|data
argument_list|,
name|in
operator|->
name|length
argument_list|,
operator|&
name|ci
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|der_copy_oid
argument_list|(
operator|&
name|ci
operator|.
name|contentType
argument_list|,
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free_ContentInfo
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|ci
operator|.
name|content
condition|)
block|{
name|ret
operator|=
name|der_copy_octet_string
argument_list|(
name|ci
operator|.
name|content
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|der_free_oid
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|free_ContentInfo
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
else|else
name|memset
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|out
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_data
condition|)
operator|*
name|have_data
operator|=
operator|(
name|ci
operator|.
name|content
operator|!=
name|NULL
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|free_ContentInfo
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CMS_ID_SKI
value|0
end_define

begin_define
define|#
directive|define
name|CMS_ID_NAME
value|1
end_define

begin_function
specifier|static
name|int
name|fill_CMSIdentifier
parameter_list|(
specifier|const
name|hx509_cert
name|cert
parameter_list|,
name|int
name|type
parameter_list|,
name|CMSIdentifier
modifier|*
name|id
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|CMS_ID_SKI
case|:
name|id
operator|->
name|element
operator|=
name|choice_CMSIdentifier_subjectKeyIdentifier
expr_stmt|;
name|ret
operator|=
name|_hx509_find_extension_subject_key_id
argument_list|(
name|_hx509_get_cert
argument_list|(
name|cert
argument_list|)
argument_list|,
operator|&
name|id
operator|->
name|u
operator|.
name|subjectKeyIdentifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
break|break;
comment|/* FALL THOUGH */
case|case
name|CMS_ID_NAME
case|:
block|{
name|hx509_name
name|name
decl_stmt|;
name|id
operator|->
name|element
operator|=
name|choice_CMSIdentifier_issuerAndSerialNumber
expr_stmt|;
name|ret
operator|=
name|hx509_cert_get_issuer
argument_list|(
name|cert
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|hx509_name_to_Name
argument_list|(
name|name
argument_list|,
operator|&
name|id
operator|->
name|u
operator|.
name|issuerAndSerialNumber
operator|.
name|issuer
argument_list|)
expr_stmt|;
name|hx509_name_free
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|hx509_cert_get_serialnumber
argument_list|(
name|cert
argument_list|,
operator|&
name|id
operator|->
name|u
operator|.
name|issuerAndSerialNumber
operator|.
name|serialNumber
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|_hx509_abort
argument_list|(
literal|"CMS fill identifier with unknown type"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unparse_CMSIdentifier
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|CMSIdentifier
modifier|*
name|id
parameter_list|,
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
operator|*
name|str
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|id
operator|->
name|element
condition|)
block|{
case|case
name|choice_CMSIdentifier_issuerAndSerialNumber
case|:
block|{
name|IssuerAndSerialNumber
modifier|*
name|iasn
decl_stmt|;
name|char
modifier|*
name|serial
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|iasn
operator|=
operator|&
name|id
operator|->
name|u
operator|.
name|issuerAndSerialNumber
expr_stmt|;
name|ret
operator|=
name|_hx509_Name_to_string
argument_list|(
operator|&
name|iasn
operator|->
name|issuer
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|der_print_hex_heim_integer
argument_list|(
operator|&
name|iasn
operator|->
name|serialNumber
argument_list|,
operator|&
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|asprintf
argument_list|(
name|str
argument_list|,
literal|"certificate issued by %s with serial number %s"
argument_list|,
name|name
argument_list|,
name|serial
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|serial
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|choice_CMSIdentifier_subjectKeyIdentifier
case|:
block|{
name|KeyIdentifier
modifier|*
name|ki
init|=
operator|&
name|id
operator|->
name|u
operator|.
name|subjectKeyIdentifier
decl_stmt|;
name|char
modifier|*
name|keyid
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|len
operator|=
name|hex_encode
argument_list|(
name|ki
operator|->
name|data
argument_list|,
name|ki
operator|->
name|length
argument_list|,
operator|&
name|keyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|asprintf
argument_list|(
name|str
argument_list|,
literal|"certificate with id %s"
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|keyid
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|asprintf
argument_list|(
name|str
argument_list|,
literal|"certificate have unknown CMSidentifier type"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|str
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_CMSIdentifier
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|CMSIdentifier
modifier|*
name|client
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
name|time_t
name|time_now
parameter_list|,
name|hx509_cert
modifier|*
name|signer_cert
parameter_list|,
name|int
name|match
parameter_list|)
block|{
name|hx509_query
name|q
decl_stmt|;
name|hx509_cert
name|cert
decl_stmt|;
name|Certificate
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|_hx509_query_clear
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
operator|*
name|signer_cert
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|client
operator|->
name|element
condition|)
block|{
case|case
name|choice_CMSIdentifier_issuerAndSerialNumber
case|:
name|q
operator|.
name|serial
operator|=
operator|&
name|client
operator|->
name|u
operator|.
name|issuerAndSerialNumber
operator|.
name|serialNumber
expr_stmt|;
name|q
operator|.
name|issuer_name
operator|=
operator|&
name|client
operator|->
name|u
operator|.
name|issuerAndSerialNumber
operator|.
name|issuer
expr_stmt|;
name|q
operator|.
name|match
operator|=
name|HX509_QUERY_MATCH_SERIALNUMBER
operator||
name|HX509_QUERY_MATCH_ISSUER_NAME
expr_stmt|;
break|break;
case|case
name|choice_CMSIdentifier_subjectKeyIdentifier
case|:
name|q
operator|.
name|subject_id
operator|=
operator|&
name|client
operator|->
name|u
operator|.
name|subjectKeyIdentifier
expr_stmt|;
name|q
operator|.
name|match
operator|=
name|HX509_QUERY_MATCH_SUBJECT_KEY_ID
expr_stmt|;
break|break;
default|default:
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|HX509_CMS_NO_RECIPIENT_CERTIFICATE
argument_list|,
literal|"unknown CMS identifier element"
argument_list|)
expr_stmt|;
return|return
name|HX509_CMS_NO_RECIPIENT_CERTIFICATE
return|;
block|}
name|q
operator|.
name|match
operator||=
name|match
expr_stmt|;
name|q
operator|.
name|match
operator||=
name|HX509_QUERY_MATCH_TIME
expr_stmt|;
if|if
condition|(
name|time_now
condition|)
name|q
operator|.
name|timenow
operator|=
name|time_now
expr_stmt|;
else|else
name|q
operator|.
name|timenow
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|hx509_certs_find
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
operator|&
name|q
argument_list|,
operator|&
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|HX509_CERT_NOT_FOUND
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|ret
operator|=
name|unparse_CMSIdentifier
argument_list|(
name|context
argument_list|,
name|client
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|HX509_CMS_NO_RECIPIENT_CERTIFICATE
argument_list|,
literal|"Failed to find %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|HX509_CMS_NO_RECIPIENT_CERTIFICATE
return|;
block|}
elseif|else
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
name|HX509_ERROR_APPEND
argument_list|,
name|HX509_CMS_NO_RECIPIENT_CERTIFICATE
argument_list|,
literal|"Failed to find CMS id in cert store"
argument_list|)
expr_stmt|;
return|return
name|HX509_CMS_NO_RECIPIENT_CERTIFICATE
return|;
block|}
operator|*
name|signer_cert
operator|=
name|cert
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Decode and unencrypt EnvelopedData.  *  * Extract data and parameteres from from the EnvelopedData. Also  * supports using detached EnvelopedData.  *  * @param context A hx509 context.  * @param certs Certificate that can decrypt the EnvelopedData  * encryption key.  * @param flags HX509_CMS_UE flags to control the behavior.  * @param data pointer the structure the contains the DER/BER encoded  * EnvelopedData stucture.  * @param length length of the data that data point to.  * @param encryptedContent in case of detached signature, this  * contains the actual encrypted data, othersize its should be NULL.  * @param time_now set the current time, if zero the library uses now as the date.  * @param contentType output type oid, should be freed with der_free_oid().  * @param content the data, free with der_free_octet_string().  *  * @ingroup hx509_cms  */
end_comment

begin_function
name|int
name|hx509_cms_unenvelope
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|heim_octet_string
modifier|*
name|encryptedContent
parameter_list|,
name|time_t
name|time_now
parameter_list|,
name|heim_oid
modifier|*
name|contentType
parameter_list|,
name|heim_octet_string
modifier|*
name|content
parameter_list|)
block|{
name|heim_octet_string
name|key
decl_stmt|;
name|EnvelopedData
name|ed
decl_stmt|;
name|hx509_cert
name|cert
decl_stmt|;
name|AlgorithmIdentifier
modifier|*
name|ai
decl_stmt|;
specifier|const
name|heim_octet_string
modifier|*
name|enccontent
decl_stmt|;
name|heim_octet_string
modifier|*
name|params
decl_stmt|,
name|params_data
decl_stmt|;
name|heim_octet_string
name|ivec
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|matched
init|=
literal|0
decl_stmt|,
name|findflags
init|=
literal|0
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ed
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ed
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ivec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ivec
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|content
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|content
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|contentType
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|contentType
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HX509_CMS_UE_DONT_REQUIRE_KU_ENCIPHERMENT
operator|)
operator|==
literal|0
condition|)
name|findflags
operator||=
name|HX509_QUERY_KU_ENCIPHERMENT
expr_stmt|;
name|ret
operator|=
name|decode_EnvelopedData
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
operator|&
name|ed
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to decode EnvelopedData"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|ed
operator|.
name|recipientInfos
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|HX509_CMS_NO_RECIPIENT_CERTIFICATE
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"No recipient info in enveloped data"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|enccontent
operator|=
name|ed
operator|.
name|encryptedContentInfo
operator|.
name|encryptedContent
expr_stmt|;
if|if
condition|(
name|enccontent
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|encryptedContent
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|HX509_CMS_NO_DATA_AVAILABLE
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Content missing from encrypted data"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|enccontent
operator|=
name|encryptedContent
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encryptedContent
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|HX509_CMS_NO_DATA_AVAILABLE
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Both internal and external encrypted data"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cert
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ed
operator|.
name|recipientInfos
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
name|KeyTransRecipientInfo
modifier|*
name|ri
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|ret2
decl_stmt|;
name|ri
operator|=
operator|&
name|ed
operator|.
name|recipientInfos
operator|.
name|val
index|[
name|i
index|]
expr_stmt|;
name|ret
operator|=
name|find_CMSIdentifier
argument_list|(
name|context
argument_list|,
operator|&
name|ri
operator|->
name|rid
argument_list|,
name|certs
argument_list|,
name|time_now
argument_list|,
operator|&
name|cert
argument_list|,
name|HX509_QUERY_PRIVATE_KEY
operator||
name|findflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
continue|continue;
name|matched
operator|=
literal|1
expr_stmt|;
comment|/* found a matching certificate, let decrypt */
name|ret
operator|=
name|_hx509_cert_private_decrypt
argument_list|(
name|context
argument_list|,
operator|&
name|ri
operator|->
name|encryptedKey
argument_list|,
operator|&
name|ri
operator|->
name|keyEncryptionAlgorithm
operator|.
name|algorithm
argument_list|,
name|cert
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|hx509_cert_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
break|break;
comment|/* succuessfully decrypted cert */
name|cert
operator|=
name|NULL
expr_stmt|;
name|ret2
operator|=
name|unparse_CMSIdentifier
argument_list|(
name|context
argument_list|,
operator|&
name|ri
operator|->
name|rid
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret2
operator|==
literal|0
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
name|HX509_ERROR_APPEND
argument_list|,
name|ret
argument_list|,
literal|"Failed to decrypt with %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
name|ret
operator|=
name|HX509_CMS_NO_RECIPIENT_CERTIFICATE
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"No private key matched any certificate"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|cert
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|HX509_CMS_NO_RECIPIENT_CERTIFICATE
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
name|HX509_ERROR_APPEND
argument_list|,
name|ret
argument_list|,
literal|"No private key decrypted the transfer key"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|der_copy_oid
argument_list|(
operator|&
name|ed
operator|.
name|encryptedContentInfo
operator|.
name|contentType
argument_list|,
name|contentType
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to copy EnvelopedData content oid"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ai
operator|=
operator|&
name|ed
operator|.
name|encryptedContentInfo
operator|.
name|contentEncryptionAlgorithm
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|parameters
condition|)
block|{
name|params_data
operator|.
name|data
operator|=
name|ai
operator|->
name|parameters
operator|->
name|data
expr_stmt|;
name|params_data
operator|.
name|length
operator|=
name|ai
operator|->
name|parameters
operator|->
name|length
expr_stmt|;
name|params
operator|=
operator|&
name|params_data
expr_stmt|;
block|}
else|else
name|params
operator|=
name|NULL
expr_stmt|;
block|{
name|hx509_crypto
name|crypto
decl_stmt|;
name|ret
operator|=
name|hx509_crypto_init
argument_list|(
name|context
argument_list|,
name|NULL
argument_list|,
operator|&
name|ai
operator|->
name|algorithm
argument_list|,
operator|&
name|crypto
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|flags
operator|&
name|HX509_CMS_UE_ALLOW_WEAK
condition|)
name|hx509_crypto_allow_weak
argument_list|(
name|crypto
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
condition|)
block|{
name|ret
operator|=
name|hx509_crypto_set_params
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|params
argument_list|,
operator|&
name|ivec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_crypto_destroy
argument_list|(
name|crypto
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret
operator|=
name|hx509_crypto_set_key_data
argument_list|(
name|crypto
argument_list|,
name|key
operator|.
name|data
argument_list|,
name|key
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_crypto_destroy
argument_list|(
name|crypto
argument_list|)
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to set key for decryption "
literal|"of EnvelopedData"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|hx509_crypto_decrypt
argument_list|(
name|crypto
argument_list|,
name|enccontent
operator|->
name|data
argument_list|,
name|enccontent
operator|->
name|length
argument_list|,
name|ivec
operator|.
name|length
condition|?
operator|&
name|ivec
else|:
name|NULL
argument_list|,
name|content
argument_list|)
expr_stmt|;
name|hx509_crypto_destroy
argument_list|(
name|crypto
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to decrypt EnvelopedData"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
name|free_EnvelopedData
argument_list|(
operator|&
name|ed
argument_list|)
expr_stmt|;
name|der_free_octet_string
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivec
operator|.
name|length
condition|)
name|der_free_octet_string
argument_list|(
operator|&
name|ivec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|der_free_oid
argument_list|(
name|contentType
argument_list|)
expr_stmt|;
name|der_free_octet_string
argument_list|(
name|content
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Encrypt end encode EnvelopedData.  *  * Encrypt and encode EnvelopedData. The data is encrypted with a  * random key and the the random key is encrypted with the  * certificates private key. This limits what private key type can be  * used to RSA.  *  * @param context A hx509 context.  * @param flags flags to control the behavior.  *    - HX509_CMS_EV_NO_KU_CHECK - Dont check KU on certificate  *    - HX509_CMS_EV_ALLOW_WEAK - Allow weak crytpo  *    - HX509_CMS_EV_ID_NAME - prefer issuer name and serial number  * @param cert Certificate to encrypt the EnvelopedData encryption key  * with.  * @param data pointer the data to encrypt.  * @param length length of the data that data point to.  * @param encryption_type Encryption cipher to use for the bulk data,  * use NULL to get default.  * @param contentType type of the data that is encrypted  * @param content the output of the function,  * free with der_free_octet_string().  *  * @ingroup hx509_cms  */
end_comment

begin_function
name|int
name|hx509_cms_envelope_1
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|int
name|flags
parameter_list|,
name|hx509_cert
name|cert
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|heim_oid
modifier|*
name|encryption_type
parameter_list|,
specifier|const
name|heim_oid
modifier|*
name|contentType
parameter_list|,
name|heim_octet_string
modifier|*
name|content
parameter_list|)
block|{
name|KeyTransRecipientInfo
modifier|*
name|ri
decl_stmt|;
name|heim_octet_string
name|ivec
decl_stmt|;
name|heim_octet_string
name|key
decl_stmt|;
name|hx509_crypto
name|crypto
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|cmsidflag
decl_stmt|;
name|EnvelopedData
name|ed
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ivec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ivec
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ed
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ed
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|content
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|content
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|encryption_type
operator|==
name|NULL
condition|)
name|encryption_type
operator|=
operator|&
name|asn1_oid_id_aes_256_cbc
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HX509_CMS_EV_NO_KU_CHECK
operator|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|_hx509_check_key_usage
argument_list|(
name|context
argument_list|,
name|cert
argument_list|,
literal|1
operator|<<
literal|2
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|hx509_crypto_init
argument_list|(
name|context
argument_list|,
name|NULL
argument_list|,
name|encryption_type
argument_list|,
operator|&
name|crypto
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|flags
operator|&
name|HX509_CMS_EV_ALLOW_WEAK
condition|)
name|hx509_crypto_allow_weak
argument_list|(
name|crypto
argument_list|)
expr_stmt|;
name|ret
operator|=
name|hx509_crypto_set_random_key
argument_list|(
name|crypto
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Create random key for EnvelopedData content"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|hx509_crypto_random_iv
argument_list|(
name|crypto
argument_list|,
operator|&
name|ivec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to create a random iv"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|hx509_crypto_encrypt
argument_list|(
name|crypto
argument_list|,
name|data
argument_list|,
name|length
argument_list|,
operator|&
name|ivec
argument_list|,
operator|&
name|ed
operator|.
name|encryptedContentInfo
operator|.
name|encryptedContent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to encrypt EnvelopedData content"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|{
name|AlgorithmIdentifier
modifier|*
name|enc_alg
decl_stmt|;
name|enc_alg
operator|=
operator|&
name|ed
operator|.
name|encryptedContentInfo
operator|.
name|contentEncryptionAlgorithm
expr_stmt|;
name|ret
operator|=
name|der_copy_oid
argument_list|(
name|encryption_type
argument_list|,
operator|&
name|enc_alg
operator|->
name|algorithm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to set crypto oid "
literal|"for EnvelopedData"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ALLOC
argument_list|(
name|enc_alg
operator|->
name|parameters
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc_alg
operator|->
name|parameters
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to allocate crypto paramaters "
literal|"for EnvelopedData"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|hx509_crypto_get_params
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
operator|&
name|ivec
argument_list|,
name|enc_alg
operator|->
name|parameters
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
name|ALLOC_SEQ
argument_list|(
operator|&
name|ed
operator|.
name|recipientInfos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|.
name|recipientInfos
operator|.
name|val
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to allocate recipients info "
literal|"for EnvelopedData"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ri
operator|=
operator|&
name|ed
operator|.
name|recipientInfos
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|HX509_CMS_EV_ID_NAME
condition|)
block|{
name|ri
operator|->
name|version
operator|=
literal|0
expr_stmt|;
name|cmsidflag
operator|=
name|CMS_ID_NAME
expr_stmt|;
block|}
else|else
block|{
name|ri
operator|->
name|version
operator|=
literal|2
expr_stmt|;
name|cmsidflag
operator|=
name|CMS_ID_SKI
expr_stmt|;
block|}
name|ret
operator|=
name|fill_CMSIdentifier
argument_list|(
name|cert
argument_list|,
name|cmsidflag
argument_list|,
operator|&
name|ri
operator|->
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to set CMS identifier info "
literal|"for EnvelopedData"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|hx509_cert_public_encrypt
argument_list|(
name|context
argument_list|,
operator|&
name|key
argument_list|,
name|cert
argument_list|,
operator|&
name|ri
operator|->
name|keyEncryptionAlgorithm
operator|.
name|algorithm
argument_list|,
operator|&
name|ri
operator|->
name|encryptedKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
name|HX509_ERROR_APPEND
argument_list|,
name|ret
argument_list|,
literal|"Failed to encrypt transport key for "
literal|"EnvelopedData"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      *      */
name|ed
operator|.
name|version
operator|=
literal|0
expr_stmt|;
name|ed
operator|.
name|originatorInfo
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|der_copy_oid
argument_list|(
name|contentType
argument_list|,
operator|&
name|ed
operator|.
name|encryptedContentInfo
operator|.
name|contentType
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to copy content oid for "
literal|"EnvelopedData"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ed
operator|.
name|unprotectedAttrs
operator|=
name|NULL
expr_stmt|;
name|ASN1_MALLOC_ENCODE
argument_list|(
name|EnvelopedData
argument_list|,
name|content
operator|->
name|data
argument_list|,
name|content
operator|->
name|length
argument_list|,
operator|&
name|ed
argument_list|,
operator|&
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to encode EnvelopedData"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|size
operator|!=
name|content
operator|->
name|length
condition|)
name|_hx509_abort
argument_list|(
literal|"internal ASN.1 encoder error"
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|crypto
condition|)
name|hx509_crypto_destroy
argument_list|(
name|crypto
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|der_free_octet_string
argument_list|(
name|content
argument_list|)
expr_stmt|;
name|der_free_octet_string
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|der_free_octet_string
argument_list|(
operator|&
name|ivec
argument_list|)
expr_stmt|;
name|free_EnvelopedData
argument_list|(
operator|&
name|ed
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|any_to_certs
parameter_list|(
name|hx509_context
name|context
parameter_list|,
specifier|const
name|SignedData
modifier|*
name|sd
parameter_list|,
name|hx509_certs
name|certs
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|sd
operator|->
name|certificates
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sd
operator|->
name|certificates
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|hx509_cert
name|c
decl_stmt|;
name|ret
operator|=
name|hx509_cert_init_data
argument_list|(
name|context
argument_list|,
name|sd
operator|->
name|certificates
operator|->
name|val
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|sd
operator|->
name|certificates
operator|->
name|val
index|[
name|i
index|]
operator|.
name|length
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|hx509_certs_add
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|hx509_cert_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|Attribute
modifier|*
name|find_attribute
parameter_list|(
specifier|const
name|CMSAttributes
modifier|*
name|attr
parameter_list|,
specifier|const
name|heim_oid
modifier|*
name|oid
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attr
operator|->
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|der_heim_oid_cmp
argument_list|(
operator|&
name|attr
operator|->
name|val
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|oid
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|attr
operator|->
name|val
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Decode SignedData and verify that the signature is correct.  *  * @param context A hx509 context.  * @param ctx a hx509 verify context.  * @param flags to control the behaivor of the function.  *    - HX509_CMS_VS_NO_KU_CHECK - Don't check KeyUsage  *    - HX509_CMS_VS_ALLOW_DATA_OID_MISMATCH - allow oid mismatch  *    - HX509_CMS_VS_ALLOW_ZERO_SIGNER - no signer, see below.  * @param data pointer to CMS SignedData encoded data.  * @param length length of the data that data point to.  * @param signedContent external data used for signature.  * @param pool certificate pool to build certificates paths.  * @param contentType free with der_free_oid().  * @param content the output of the function, free with  * der_free_octet_string().  * @param signer_certs list of the cerficates used to sign this  * request, free with hx509_certs_free().  *  * @ingroup hx509_cms  */
end_comment

begin_function
name|int
name|hx509_cms_verify_signed
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_verify_ctx
name|ctx
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|heim_octet_string
modifier|*
name|signedContent
parameter_list|,
name|hx509_certs
name|pool
parameter_list|,
name|heim_oid
modifier|*
name|contentType
parameter_list|,
name|heim_octet_string
modifier|*
name|content
parameter_list|,
name|hx509_certs
modifier|*
name|signer_certs
parameter_list|)
block|{
name|SignerInfo
modifier|*
name|signer_info
decl_stmt|;
name|hx509_cert
name|cert
init|=
name|NULL
decl_stmt|;
name|hx509_certs
name|certs
init|=
name|NULL
decl_stmt|;
name|SignedData
name|sd
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|found_valid_sig
decl_stmt|;
name|size_t
name|i
decl_stmt|;
operator|*
name|signer_certs
operator|=
name|NULL
expr_stmt|;
name|content
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|content
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|contentType
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|contentType
operator|->
name|components
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sd
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|decode_SignedData
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
operator|&
name|sd
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to decode SignedData"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sd
operator|.
name|encapContentInfo
operator|.
name|eContent
operator|==
name|NULL
operator|&&
name|signedContent
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|HX509_CMS_NO_DATA_AVAILABLE
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"No content data in SignedData"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sd
operator|.
name|encapContentInfo
operator|.
name|eContent
operator|&&
name|signedContent
condition|)
block|{
name|ret
operator|=
name|HX509_CMS_NO_DATA_AVAILABLE
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Both external and internal SignedData"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sd
operator|.
name|encapContentInfo
operator|.
name|eContent
condition|)
name|ret
operator|=
name|der_copy_octet_string
argument_list|(
name|sd
operator|.
name|encapContentInfo
operator|.
name|eContent
argument_list|,
name|content
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|der_copy_octet_string
argument_list|(
name|signedContent
argument_list|,
name|content
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"malloc: out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|hx509_certs_init
argument_list|(
name|context
argument_list|,
literal|"MEMORY:cms-cert-buffer"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|certs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|hx509_certs_init
argument_list|(
name|context
argument_list|,
literal|"MEMORY:cms-signer-certs"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|signer_certs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
comment|/* XXX Check CMS version */
name|ret
operator|=
name|any_to_certs
argument_list|(
name|context
argument_list|,
operator|&
name|sd
argument_list|,
name|certs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|pool
condition|)
block|{
name|ret
operator|=
name|hx509_certs_merge
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|found_valid_sig
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sd
operator|.
name|signerInfos
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
name|heim_octet_string
name|signed_data
decl_stmt|;
specifier|const
name|heim_oid
modifier|*
name|match_oid
decl_stmt|;
name|heim_oid
name|decode_oid
decl_stmt|;
name|signer_info
operator|=
operator|&
name|sd
operator|.
name|signerInfos
operator|.
name|val
index|[
name|i
index|]
expr_stmt|;
name|match_oid
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|signer_info
operator|->
name|signature
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|HX509_CMS_MISSING_SIGNER_DATA
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"SignerInfo %d in SignedData "
literal|"missing sigature"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ret
operator|=
name|find_CMSIdentifier
argument_list|(
name|context
argument_list|,
operator|&
name|signer_info
operator|->
name|sid
argument_list|,
name|certs
argument_list|,
name|_hx509_verify_get_time
argument_list|(
name|ctx
argument_list|)
argument_list|,
operator|&
name|cert
argument_list|,
name|HX509_QUERY_KU_DIGITALSIGNATURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/** 	     * If HX509_CMS_VS_NO_KU_CHECK is set, allow more liberal 	     * search for matching certificates by not considering 	     * KeyUsage bits on the certificates. 	     */
if|if
condition|(
operator|(
name|flags
operator|&
name|HX509_CMS_VS_NO_KU_CHECK
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|ret
operator|=
name|find_CMSIdentifier
argument_list|(
name|context
argument_list|,
operator|&
name|signer_info
operator|->
name|sid
argument_list|,
name|certs
argument_list|,
name|_hx509_verify_get_time
argument_list|(
name|ctx
argument_list|)
argument_list|,
operator|&
name|cert
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
continue|continue;
block|}
if|if
condition|(
name|signer_info
operator|->
name|signedAttrs
condition|)
block|{
specifier|const
name|Attribute
modifier|*
name|attr
decl_stmt|;
name|CMSAttributes
name|sa
decl_stmt|;
name|heim_octet_string
name|os
decl_stmt|;
name|sa
operator|.
name|val
operator|=
name|signer_info
operator|->
name|signedAttrs
operator|->
name|val
expr_stmt|;
name|sa
operator|.
name|len
operator|=
name|signer_info
operator|->
name|signedAttrs
operator|->
name|len
expr_stmt|;
comment|/* verify that sigature exists */
name|attr
operator|=
name|find_attribute
argument_list|(
operator|&
name|sa
argument_list|,
operator|&
name|asn1_oid_id_pkcs9_messageDigest
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|HX509_CRYPTO_SIGNATURE_MISSING
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"SignerInfo have signed attributes "
literal|"but messageDigest (signature) "
literal|"is missing"
argument_list|)
expr_stmt|;
goto|goto
name|next_sigature
goto|;
block|}
if|if
condition|(
name|attr
operator|->
name|value
operator|.
name|len
operator|!=
literal|1
condition|)
block|{
name|ret
operator|=
name|HX509_CRYPTO_SIGNATURE_MISSING
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"SignerInfo have more then one "
literal|"messageDigest (signature)"
argument_list|)
expr_stmt|;
goto|goto
name|next_sigature
goto|;
block|}
name|ret
operator|=
name|decode_MessageDigest
argument_list|(
name|attr
operator|->
name|value
operator|.
name|val
index|[
literal|0
index|]
operator|.
name|data
argument_list|,
name|attr
operator|->
name|value
operator|.
name|val
index|[
literal|0
index|]
operator|.
name|length
argument_list|,
operator|&
name|os
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to decode "
literal|"messageDigest (signature)"
argument_list|)
expr_stmt|;
goto|goto
name|next_sigature
goto|;
block|}
name|ret
operator|=
name|_hx509_verify_signature
argument_list|(
name|context
argument_list|,
name|NULL
argument_list|,
operator|&
name|signer_info
operator|->
name|digestAlgorithm
argument_list|,
name|content
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
name|der_free_octet_string
argument_list|(
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
name|HX509_ERROR_APPEND
argument_list|,
name|ret
argument_list|,
literal|"Failed to verify messageDigest"
argument_list|)
expr_stmt|;
goto|goto
name|next_sigature
goto|;
block|}
comment|/* 	     * Fetch content oid inside signedAttrs or set it to 	     * id-pkcs7-data. 	     */
name|attr
operator|=
name|find_attribute
argument_list|(
operator|&
name|sa
argument_list|,
operator|&
name|asn1_oid_id_pkcs9_contentType
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
name|NULL
condition|)
block|{
name|match_oid
operator|=
operator|&
name|asn1_oid_id_pkcs7_data
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|attr
operator|->
name|value
operator|.
name|len
operator|!=
literal|1
condition|)
block|{
name|ret
operator|=
name|HX509_CMS_DATA_OID_MISMATCH
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"More then one oid in signedAttrs"
argument_list|)
expr_stmt|;
goto|goto
name|next_sigature
goto|;
block|}
name|ret
operator|=
name|decode_ContentType
argument_list|(
name|attr
operator|->
name|value
operator|.
name|val
index|[
literal|0
index|]
operator|.
name|data
argument_list|,
name|attr
operator|->
name|value
operator|.
name|val
index|[
literal|0
index|]
operator|.
name|length
argument_list|,
operator|&
name|decode_oid
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to decode "
literal|"oid in signedAttrs"
argument_list|)
expr_stmt|;
goto|goto
name|next_sigature
goto|;
block|}
name|match_oid
operator|=
operator|&
name|decode_oid
expr_stmt|;
block|}
name|ASN1_MALLOC_ENCODE
argument_list|(
name|CMSAttributes
argument_list|,
name|signed_data
operator|.
name|data
argument_list|,
name|signed_data
operator|.
name|length
argument_list|,
operator|&
name|sa
argument_list|,
operator|&
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|match_oid
operator|==
operator|&
name|decode_oid
condition|)
name|der_free_oid
argument_list|(
operator|&
name|decode_oid
argument_list|)
expr_stmt|;
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
goto|goto
name|next_sigature
goto|;
block|}
if|if
condition|(
name|size
operator|!=
name|signed_data
operator|.
name|length
condition|)
name|_hx509_abort
argument_list|(
literal|"internal ASN.1 encoder error"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|signed_data
operator|.
name|data
operator|=
name|content
operator|->
name|data
expr_stmt|;
name|signed_data
operator|.
name|length
operator|=
name|content
operator|->
name|length
expr_stmt|;
name|match_oid
operator|=
operator|&
name|asn1_oid_id_pkcs7_data
expr_stmt|;
block|}
comment|/** 	 * If HX509_CMS_VS_ALLOW_DATA_OID_MISMATCH, allow 	 * encapContentInfo mismatch with the oid in signedAttributes 	 * (or if no signedAttributes where use, pkcs7-data oid). 	 * This is only needed to work with broken CMS implementations 	 * that doesn't follow CMS signedAttributes rules. 	 */
if|if
condition|(
name|der_heim_oid_cmp
argument_list|(
name|match_oid
argument_list|,
operator|&
name|sd
operator|.
name|encapContentInfo
operator|.
name|eContentType
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|HX509_CMS_VS_ALLOW_DATA_OID_MISMATCH
operator|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|HX509_CMS_DATA_OID_MISMATCH
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Oid in message mismatch from the expected"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|match_oid
operator|==
operator|&
name|decode_oid
condition|)
name|der_free_oid
argument_list|(
operator|&
name|decode_oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|hx509_verify_signature
argument_list|(
name|context
argument_list|,
name|cert
argument_list|,
operator|&
name|signer_info
operator|->
name|signatureAlgorithm
argument_list|,
operator|&
name|signed_data
argument_list|,
operator|&
name|signer_info
operator|->
name|signature
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
name|HX509_ERROR_APPEND
argument_list|,
name|ret
argument_list|,
literal|"Failed to verify signature in "
literal|"CMS SignedData"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signer_info
operator|->
name|signedAttrs
condition|)
name|free
argument_list|(
name|signed_data
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|next_sigature
goto|;
comment|/** 	 * If HX509_CMS_VS_NO_VALIDATE flags is set, do not verify the 	 * signing certificates and leave that up to the caller. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|HX509_CMS_VS_NO_VALIDATE
operator|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|hx509_verify_path
argument_list|(
name|context
argument_list|,
name|ctx
argument_list|,
name|cert
argument_list|,
name|certs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|next_sigature
goto|;
block|}
name|ret
operator|=
name|hx509_certs_add
argument_list|(
name|context
argument_list|,
operator|*
name|signer_certs
argument_list|,
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|next_sigature
goto|;
name|found_valid_sig
operator|++
expr_stmt|;
name|next_sigature
label|:
if|if
condition|(
name|cert
condition|)
name|hx509_cert_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|cert
operator|=
name|NULL
expr_stmt|;
block|}
comment|/**      * If HX509_CMS_VS_ALLOW_ZERO_SIGNER is set, allow empty      * SignerInfo (no signatures). If SignedData have no signatures,      * the function will return 0 with signer_certs set to NULL. Zero      * signers is allowed by the standard, but since its only useful      * in corner cases, it make into a flag that the caller have to      * turn on.      */
if|if
condition|(
name|sd
operator|.
name|signerInfos
operator|.
name|len
operator|==
literal|0
operator|&&
operator|(
name|flags
operator|&
name|HX509_CMS_VS_ALLOW_ZERO_SIGNER
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|signer_certs
condition|)
name|hx509_certs_free
argument_list|(
name|signer_certs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found_valid_sig
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|HX509_CMS_SIGNER_NOT_FOUND
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"No signers where found"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|der_copy_oid
argument_list|(
operator|&
name|sd
operator|.
name|encapContentInfo
operator|.
name|eContentType
argument_list|,
name|contentType
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|free_SignedData
argument_list|(
operator|&
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|certs
condition|)
name|hx509_certs_free
argument_list|(
operator|&
name|certs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|content
operator|->
name|data
condition|)
name|der_free_octet_string
argument_list|(
name|content
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|signer_certs
condition|)
name|hx509_certs_free
argument_list|(
name|signer_certs
argument_list|)
expr_stmt|;
name|der_free_oid
argument_list|(
name|contentType
argument_list|)
expr_stmt|;
name|der_free_octet_string
argument_list|(
name|content
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_one_attribute
parameter_list|(
name|Attribute
modifier|*
modifier|*
name|attr
parameter_list|,
name|unsigned
name|int
modifier|*
name|len
parameter_list|,
specifier|const
name|heim_oid
modifier|*
name|oid
parameter_list|,
name|heim_octet_string
modifier|*
name|data
parameter_list|)
block|{
name|void
modifier|*
name|d
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|d
operator|=
name|realloc
argument_list|(
operator|*
name|attr
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|*
name|attr
operator|)
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
operator|*
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
operator|(
operator|*
name|attr
operator|)
operator|=
name|d
expr_stmt|;
name|ret
operator|=
name|der_copy_oid
argument_list|(
name|oid
argument_list|,
operator|&
operator|(
operator|*
name|attr
operator|)
index|[
operator|*
name|len
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ALLOC_SEQ
argument_list|(
operator|&
operator|(
operator|*
name|attr
operator|)
index|[
operator|*
name|len
index|]
operator|.
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|attr
operator|)
index|[
operator|*
name|len
index|]
operator|.
name|value
operator|.
name|val
operator|==
name|NULL
condition|)
block|{
name|der_free_oid
argument_list|(
operator|&
operator|(
operator|*
name|attr
operator|)
index|[
operator|*
name|len
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
operator|(
operator|*
name|attr
operator|)
index|[
operator|*
name|len
index|]
operator|.
name|value
operator|.
name|val
index|[
literal|0
index|]
operator|.
name|data
operator|=
name|data
operator|->
name|data
expr_stmt|;
operator|(
operator|*
name|attr
operator|)
index|[
operator|*
name|len
index|]
operator|.
name|value
operator|.
name|val
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|data
operator|->
name|length
expr_stmt|;
operator|*
name|len
operator|+=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Decode SignedData and verify that the signature is correct.  *  * @param context A hx509 context.  * @param flags  * @param eContentType the type of the data.  * @param data data to sign  * @param length length of the data that data point to.  * @param digest_alg digest algorithm to use, use NULL to get the  * default or the peer determined algorithm.  * @param cert certificate to use for sign the data.  * @param peer info about the peer the message to send the message to,  * like what digest algorithm to use.  * @param anchors trust anchors that the client will use, used to  * polulate the certificates included in the message  * @param pool certificates to use in try to build the path to the  * trust anchors.  * @param signed_data the output of the function, free with  * der_free_octet_string().  *  * @ingroup hx509_cms  */
end_comment

begin_function
name|int
name|hx509_cms_create_signed_1
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|heim_oid
modifier|*
name|eContentType
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|AlgorithmIdentifier
modifier|*
name|digest_alg
parameter_list|,
name|hx509_cert
name|cert
parameter_list|,
name|hx509_peer_info
name|peer
parameter_list|,
name|hx509_certs
name|anchors
parameter_list|,
name|hx509_certs
name|pool
parameter_list|,
name|heim_octet_string
modifier|*
name|signed_data
parameter_list|)
block|{
name|hx509_certs
name|certs
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|signed_data
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|signed_data
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|hx509_certs_init
argument_list|(
name|context
argument_list|,
literal|"MEMORY:certs"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|certs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|hx509_certs_add
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|hx509_cms_create_signed
argument_list|(
name|context
argument_list|,
name|flags
argument_list|,
name|eContentType
argument_list|,
name|data
argument_list|,
name|length
argument_list|,
name|digest_alg
argument_list|,
name|certs
argument_list|,
name|peer
argument_list|,
name|anchors
argument_list|,
name|pool
argument_list|,
name|signed_data
argument_list|)
expr_stmt|;
name|out
label|:
name|hx509_certs_free
argument_list|(
operator|&
name|certs
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_struct
struct|struct
name|sigctx
block|{
name|SignedData
name|sd
decl_stmt|;
specifier|const
name|AlgorithmIdentifier
modifier|*
name|digest_alg
decl_stmt|;
specifier|const
name|heim_oid
modifier|*
name|eContentType
decl_stmt|;
name|heim_octet_string
name|content
decl_stmt|;
name|hx509_peer_info
name|peer
decl_stmt|;
name|int
name|cmsidflag
decl_stmt|;
name|int
name|leafonly
decl_stmt|;
name|hx509_certs
name|certs
decl_stmt|;
name|hx509_certs
name|anchors
decl_stmt|;
name|hx509_certs
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|sig_process
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|hx509_cert
name|cert
parameter_list|)
block|{
name|struct
name|sigctx
modifier|*
name|sigctx
init|=
name|ctx
decl_stmt|;
name|heim_octet_string
name|buf
decl_stmt|,
name|sigdata
init|=
block|{
literal|0
block|,
name|NULL
block|}
decl_stmt|;
name|SignerInfo
modifier|*
name|signer_info
init|=
name|NULL
decl_stmt|;
name|AlgorithmIdentifier
name|digest
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|SignedData
modifier|*
name|sd
init|=
operator|&
name|sigctx
operator|->
name|sd
decl_stmt|;
name|hx509_path
name|path
decl_stmt|;
name|memset
argument_list|(
operator|&
name|digest
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|digest
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|path
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_hx509_cert_private_key
argument_list|(
name|cert
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|HX509_PRIVATE_KEY_MISSING
argument_list|,
literal|"Private key missing for signing"
argument_list|)
expr_stmt|;
return|return
name|HX509_PRIVATE_KEY_MISSING
return|;
block|}
if|if
condition|(
name|sigctx
operator|->
name|digest_alg
condition|)
block|{
name|ret
operator|=
name|copy_AlgorithmIdentifier
argument_list|(
name|sigctx
operator|->
name|digest_alg
argument_list|,
operator|&
name|digest
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|hx509_crypto_select
argument_list|(
name|context
argument_list|,
name|HX509_SELECT_DIGEST
argument_list|,
name|_hx509_cert_private_key
argument_list|(
name|cert
argument_list|)
argument_list|,
name|sigctx
operator|->
name|peer
argument_list|,
operator|&
name|digest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
comment|/*      * Allocate on more signerInfo and do the signature processing      */
name|ptr
operator|=
name|realloc
argument_list|(
name|sd
operator|->
name|signerInfos
operator|.
name|val
argument_list|,
operator|(
name|sd
operator|->
name|signerInfos
operator|.
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sd
operator|->
name|signerInfos
operator|.
name|val
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sd
operator|->
name|signerInfos
operator|.
name|val
operator|=
name|ptr
expr_stmt|;
name|signer_info
operator|=
operator|&
name|sd
operator|->
name|signerInfos
operator|.
name|val
index|[
name|sd
operator|->
name|signerInfos
operator|.
name|len
index|]
expr_stmt|;
name|memset
argument_list|(
name|signer_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|signer_info
argument_list|)
argument_list|)
expr_stmt|;
name|signer_info
operator|->
name|version
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|fill_CMSIdentifier
argument_list|(
name|cert
argument_list|,
name|sigctx
operator|->
name|cmsidflag
argument_list|,
operator|&
name|signer_info
operator|->
name|sid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|signer_info
operator|->
name|signedAttrs
operator|=
name|NULL
expr_stmt|;
name|signer_info
operator|->
name|unsignedAttrs
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|copy_AlgorithmIdentifier
argument_list|(
operator|&
name|digest
argument_list|,
operator|&
name|signer_info
operator|->
name|digestAlgorithm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * If it isn't pkcs7-data send signedAttributes      */
if|if
condition|(
name|der_heim_oid_cmp
argument_list|(
name|sigctx
operator|->
name|eContentType
argument_list|,
operator|&
name|asn1_oid_id_pkcs7_data
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|CMSAttributes
name|sa
decl_stmt|;
name|heim_octet_string
name|sig
decl_stmt|;
name|ALLOC
argument_list|(
name|signer_info
operator|->
name|signedAttrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|signer_info
operator|->
name|signedAttrs
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|_hx509_create_signature
argument_list|(
name|context
argument_list|,
name|NULL
argument_list|,
operator|&
name|digest
argument_list|,
operator|&
name|sigctx
operator|->
name|content
argument_list|,
name|NULL
argument_list|,
operator|&
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ASN1_MALLOC_ENCODE
argument_list|(
name|MessageDigest
argument_list|,
name|buf
operator|.
name|data
argument_list|,
name|buf
operator|.
name|length
argument_list|,
operator|&
name|sig
argument_list|,
operator|&
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|der_free_octet_string
argument_list|(
operator|&
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|size
operator|!=
name|buf
operator|.
name|length
condition|)
name|_hx509_abort
argument_list|(
literal|"internal ASN.1 encoder error"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|add_one_attribute
argument_list|(
operator|&
name|signer_info
operator|->
name|signedAttrs
operator|->
name|val
argument_list|,
operator|&
name|signer_info
operator|->
name|signedAttrs
operator|->
name|len
argument_list|,
operator|&
name|asn1_oid_id_pkcs9_messageDigest
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|buf
operator|.
name|data
argument_list|)
expr_stmt|;
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ASN1_MALLOC_ENCODE
argument_list|(
name|ContentType
argument_list|,
name|buf
operator|.
name|data
argument_list|,
name|buf
operator|.
name|length
argument_list|,
name|sigctx
operator|->
name|eContentType
argument_list|,
operator|&
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|size
operator|!=
name|buf
operator|.
name|length
condition|)
name|_hx509_abort
argument_list|(
literal|"internal ASN.1 encoder error"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|add_one_attribute
argument_list|(
operator|&
name|signer_info
operator|->
name|signedAttrs
operator|->
name|val
argument_list|,
operator|&
name|signer_info
operator|->
name|signedAttrs
operator|->
name|len
argument_list|,
operator|&
name|asn1_oid_id_pkcs9_contentType
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|buf
operator|.
name|data
argument_list|)
expr_stmt|;
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sa
operator|.
name|val
operator|=
name|signer_info
operator|->
name|signedAttrs
operator|->
name|val
expr_stmt|;
name|sa
operator|.
name|len
operator|=
name|signer_info
operator|->
name|signedAttrs
operator|->
name|len
expr_stmt|;
name|ASN1_MALLOC_ENCODE
argument_list|(
name|CMSAttributes
argument_list|,
name|sigdata
operator|.
name|data
argument_list|,
name|sigdata
operator|.
name|length
argument_list|,
operator|&
name|sa
argument_list|,
operator|&
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|size
operator|!=
name|sigdata
operator|.
name|length
condition|)
name|_hx509_abort
argument_list|(
literal|"internal ASN.1 encoder error"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sigdata
operator|.
name|data
operator|=
name|sigctx
operator|->
name|content
operator|.
name|data
expr_stmt|;
name|sigdata
operator|.
name|length
operator|=
name|sigctx
operator|->
name|content
operator|.
name|length
expr_stmt|;
block|}
block|{
name|AlgorithmIdentifier
name|sigalg
decl_stmt|;
name|ret
operator|=
name|hx509_crypto_select
argument_list|(
name|context
argument_list|,
name|HX509_SELECT_PUBLIC_SIG
argument_list|,
name|_hx509_cert_private_key
argument_list|(
name|cert
argument_list|)
argument_list|,
name|sigctx
operator|->
name|peer
argument_list|,
operator|&
name|sigalg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|_hx509_create_signature
argument_list|(
name|context
argument_list|,
name|_hx509_cert_private_key
argument_list|(
name|cert
argument_list|)
argument_list|,
operator|&
name|sigalg
argument_list|,
operator|&
name|sigdata
argument_list|,
operator|&
name|signer_info
operator|->
name|signatureAlgorithm
argument_list|,
operator|&
name|signer_info
operator|->
name|signature
argument_list|)
expr_stmt|;
name|free_AlgorithmIdentifier
argument_list|(
operator|&
name|sigalg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
name|sigctx
operator|->
name|sd
operator|.
name|signerInfos
operator|.
name|len
operator|++
expr_stmt|;
name|signer_info
operator|=
name|NULL
expr_stmt|;
comment|/*      * Provide best effort path      */
if|if
condition|(
name|sigctx
operator|->
name|certs
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sigctx
operator|->
name|pool
operator|&&
name|sigctx
operator|->
name|leafonly
operator|==
literal|0
condition|)
block|{
name|_hx509_calculate_path
argument_list|(
name|context
argument_list|,
name|HX509_CALCULATE_PATH_NO_ANCHOR
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|,
name|sigctx
operator|->
name|anchors
argument_list|,
literal|0
argument_list|,
name|cert
argument_list|,
name|sigctx
operator|->
name|pool
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
block|}
else|else
name|_hx509_path_append
argument_list|(
name|context
argument_list|,
operator|&
name|path
argument_list|,
name|cert
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* XXX remove dups */
name|ret
operator|=
name|hx509_certs_add
argument_list|(
name|context
argument_list|,
name|sigctx
operator|->
name|certs
argument_list|,
name|path
operator|.
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
name|out
label|:
if|if
condition|(
name|signer_info
condition|)
name|free_SignerInfo
argument_list|(
name|signer_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigdata
operator|.
name|data
operator|!=
name|sigctx
operator|->
name|content
operator|.
name|data
condition|)
name|der_free_octet_string
argument_list|(
operator|&
name|sigdata
argument_list|)
expr_stmt|;
name|_hx509_path_free
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
name|free_AlgorithmIdentifier
argument_list|(
operator|&
name|digest
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cert_process
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|hx509_cert
name|cert
parameter_list|)
block|{
name|struct
name|sigctx
modifier|*
name|sigctx
init|=
name|ctx
decl_stmt|;
specifier|const
name|unsigned
name|int
name|i
init|=
name|sigctx
operator|->
name|sd
operator|.
name|certificates
operator|->
name|len
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ptr
operator|=
name|realloc
argument_list|(
name|sigctx
operator|->
name|sd
operator|.
name|certificates
operator|->
name|val
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sigctx
operator|->
name|sd
operator|.
name|certificates
operator|->
name|val
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|sigctx
operator|->
name|sd
operator|.
name|certificates
operator|->
name|val
operator|=
name|ptr
expr_stmt|;
name|ret
operator|=
name|hx509_cert_binary
argument_list|(
name|context
argument_list|,
name|cert
argument_list|,
operator|&
name|sigctx
operator|->
name|sd
operator|.
name|certificates
operator|->
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|sigctx
operator|->
name|sd
operator|.
name|certificates
operator|->
name|len
operator|++
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmp_AlgorithmIdentifier
parameter_list|(
specifier|const
name|AlgorithmIdentifier
modifier|*
name|p
parameter_list|,
specifier|const
name|AlgorithmIdentifier
modifier|*
name|q
parameter_list|)
block|{
return|return
name|der_heim_oid_cmp
argument_list|(
operator|&
name|p
operator|->
name|algorithm
argument_list|,
operator|&
name|q
operator|->
name|algorithm
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|hx509_cms_create_signed
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|heim_oid
modifier|*
name|eContentType
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|AlgorithmIdentifier
modifier|*
name|digest_alg
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
name|hx509_peer_info
name|peer
parameter_list|,
name|hx509_certs
name|anchors
parameter_list|,
name|hx509_certs
name|pool
parameter_list|,
name|heim_octet_string
modifier|*
name|signed_data
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|hx509_name
name|name
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|struct
name|sigctx
name|sigctx
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sigctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sigctx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eContentType
operator|==
name|NULL
condition|)
name|eContentType
operator|=
operator|&
name|asn1_oid_id_pkcs7_data
expr_stmt|;
name|sigctx
operator|.
name|digest_alg
operator|=
name|digest_alg
expr_stmt|;
name|sigctx
operator|.
name|content
operator|.
name|data
operator|=
name|rk_UNCONST
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|sigctx
operator|.
name|content
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|sigctx
operator|.
name|eContentType
operator|=
name|eContentType
expr_stmt|;
name|sigctx
operator|.
name|peer
operator|=
name|peer
expr_stmt|;
comment|/**      * Use HX509_CMS_SIGNATURE_ID_NAME to preferred use of issuer name      * and serial number if possible. Otherwise subject key identifier      * will preferred.      */
if|if
condition|(
name|flags
operator|&
name|HX509_CMS_SIGNATURE_ID_NAME
condition|)
name|sigctx
operator|.
name|cmsidflag
operator|=
name|CMS_ID_NAME
expr_stmt|;
else|else
name|sigctx
operator|.
name|cmsidflag
operator|=
name|CMS_ID_SKI
expr_stmt|;
comment|/**      * Use HX509_CMS_SIGNATURE_LEAF_ONLY to only request leaf      * certificates to be added to the SignedData.      */
name|sigctx
operator|.
name|leafonly
operator|=
operator|(
name|flags
operator|&
name|HX509_CMS_SIGNATURE_LEAF_ONLY
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/**      * Use HX509_CMS_NO_CERTS to make the SignedData contain no      * certificates, overrides HX509_CMS_SIGNATURE_LEAF_ONLY.      */
if|if
condition|(
operator|(
name|flags
operator|&
name|HX509_CMS_SIGNATURE_NO_CERTS
operator|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|hx509_certs_init
argument_list|(
name|context
argument_list|,
literal|"MEMORY:certs"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|sigctx
operator|.
name|certs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|sigctx
operator|.
name|anchors
operator|=
name|anchors
expr_stmt|;
name|sigctx
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|sigctx
operator|.
name|sd
operator|.
name|version
operator|=
name|CMSVersion_v3
expr_stmt|;
name|der_copy_oid
argument_list|(
name|eContentType
argument_list|,
operator|&
name|sigctx
operator|.
name|sd
operator|.
name|encapContentInfo
operator|.
name|eContentType
argument_list|)
expr_stmt|;
comment|/**      * Use HX509_CMS_SIGNATURE_DETACHED to create detached signatures.      */
if|if
condition|(
operator|(
name|flags
operator|&
name|HX509_CMS_SIGNATURE_DETACHED
operator|)
operator|==
literal|0
condition|)
block|{
name|ALLOC
argument_list|(
name|sigctx
operator|.
name|sd
operator|.
name|encapContentInfo
operator|.
name|eContent
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigctx
operator|.
name|sd
operator|.
name|encapContentInfo
operator|.
name|eContent
operator|==
name|NULL
condition|)
block|{
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sigctx
operator|.
name|sd
operator|.
name|encapContentInfo
operator|.
name|eContent
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigctx
operator|.
name|sd
operator|.
name|encapContentInfo
operator|.
name|eContent
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memcpy
argument_list|(
name|sigctx
operator|.
name|sd
operator|.
name|encapContentInfo
operator|.
name|eContent
operator|->
name|data
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|sigctx
operator|.
name|sd
operator|.
name|encapContentInfo
operator|.
name|eContent
operator|->
name|length
operator|=
name|length
expr_stmt|;
block|}
comment|/**      * Use HX509_CMS_SIGNATURE_NO_SIGNER to create no sigInfo (no      * signatures).      */
if|if
condition|(
operator|(
name|flags
operator|&
name|HX509_CMS_SIGNATURE_NO_SIGNER
operator|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|hx509_certs_iter_f
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|sig_process
argument_list|,
operator|&
name|sigctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sigctx
operator|.
name|sd
operator|.
name|signerInfos
operator|.
name|len
condition|)
block|{
comment|/* 	 * For each signerInfo, collect all different digest types. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sigctx
operator|.
name|sd
operator|.
name|signerInfos
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
name|AlgorithmIdentifier
modifier|*
name|di
init|=
operator|&
name|sigctx
operator|.
name|sd
operator|.
name|signerInfos
operator|.
name|val
index|[
name|i
index|]
operator|.
name|digestAlgorithm
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sigctx
operator|.
name|sd
operator|.
name|digestAlgorithms
operator|.
name|len
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|cmp_AlgorithmIdentifier
argument_list|(
name|di
argument_list|,
operator|&
name|sigctx
operator|.
name|sd
operator|.
name|digestAlgorithms
operator|.
name|val
index|[
name|j
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|sigctx
operator|.
name|sd
operator|.
name|digestAlgorithms
operator|.
name|len
condition|)
block|{
name|ret
operator|=
name|add_DigestAlgorithmIdentifiers
argument_list|(
operator|&
name|sigctx
operator|.
name|sd
operator|.
name|digestAlgorithms
argument_list|,
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
block|}
comment|/*      * Add certs we think are needed, build as part of sig_process      */
if|if
condition|(
name|sigctx
operator|.
name|certs
condition|)
block|{
name|ALLOC
argument_list|(
name|sigctx
operator|.
name|sd
operator|.
name|certificates
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigctx
operator|.
name|sd
operator|.
name|certificates
operator|==
name|NULL
condition|)
block|{
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|hx509_certs_iter_f
argument_list|(
name|context
argument_list|,
name|sigctx
operator|.
name|certs
argument_list|,
name|cert_process
argument_list|,
operator|&
name|sigctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
name|ASN1_MALLOC_ENCODE
argument_list|(
name|SignedData
argument_list|,
name|signed_data
operator|->
name|data
argument_list|,
name|signed_data
operator|->
name|length
argument_list|,
operator|&
name|sigctx
operator|.
name|sd
argument_list|,
operator|&
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|signed_data
operator|->
name|length
operator|!=
name|size
condition|)
name|_hx509_abort
argument_list|(
literal|"internal ASN.1 encoder error"
argument_list|)
expr_stmt|;
name|out
label|:
name|hx509_certs_free
argument_list|(
operator|&
name|sigctx
operator|.
name|certs
argument_list|)
expr_stmt|;
name|free_SignedData
argument_list|(
operator|&
name|sigctx
operator|.
name|sd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|hx509_cms_decrypt_encrypted
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_lock
name|lock
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|length
parameter_list|,
name|heim_oid
modifier|*
name|contentType
parameter_list|,
name|heim_octet_string
modifier|*
name|content
parameter_list|)
block|{
name|heim_octet_string
name|cont
decl_stmt|;
name|CMSEncryptedData
name|ed
decl_stmt|;
name|AlgorithmIdentifier
modifier|*
name|ai
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
name|content
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|content
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cont
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cont
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|decode_CMSEncryptedData
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
operator|&
name|ed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"Failed to decode CMSEncryptedData"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|ed
operator|.
name|encryptedContentInfo
operator|.
name|encryptedContent
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|HX509_CMS_NO_DATA_AVAILABLE
expr_stmt|;
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|"No content in EncryptedData"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|der_copy_oid
argument_list|(
operator|&
name|ed
operator|.
name|encryptedContentInfo
operator|.
name|contentType
argument_list|,
name|contentType
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ai
operator|=
operator|&
name|ed
operator|.
name|encryptedContentInfo
operator|.
name|contentEncryptionAlgorithm
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|parameters
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|HX509_ALG_NOT_SUPP
expr_stmt|;
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|_hx509_pbe_decrypt
argument_list|(
name|context
argument_list|,
name|lock
argument_list|,
name|ai
argument_list|,
name|ed
operator|.
name|encryptedContentInfo
operator|.
name|encryptedContent
argument_list|,
operator|&
name|cont
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
operator|*
name|content
operator|=
name|cont
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|cont
operator|.
name|data
condition|)
name|free
argument_list|(
name|cont
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
name|free_CMSEncryptedData
argument_list|(
operator|&
name|ed
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

