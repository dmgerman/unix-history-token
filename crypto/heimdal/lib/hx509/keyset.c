begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004 - 2007 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *  * Portions Copyright (c) 2009 Apple Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"hx_locl.h"
end_include

begin_comment
comment|/**  * @page page_keyset Certificate store operations  *  * Type of certificates store:  * - MEMORY  *   In memory based format. Doesnt support storing.  * - FILE  *   FILE supports raw DER certicates and PEM certicates. When PEM is  *   used the file can contain may certificates and match private  *   keys. Support storing the certificates. DER format only supports  *   on certificate and no private key.  * - PEM-FILE  *   Same as FILE, defaulting to PEM encoded certificates.  * - PEM-FILE  *   Same as FILE, defaulting to DER encoded certificates.  * - PKCS11  * - PKCS12  * - DIR  * - KEYCHAIN  *   Apple Mac OS X KeyChain backed keychain object.  *  * See the library functions here: @ref hx509_keyset  */
end_comment

begin_struct
struct|struct
name|hx509_certs_data
block|{
name|unsigned
name|int
name|ref
decl_stmt|;
name|struct
name|hx509_keyset_ops
modifier|*
name|ops
decl_stmt|;
name|void
modifier|*
name|ops_data
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|hx509_keyset_ops
modifier|*
name|_hx509_ks_type
parameter_list|(
name|hx509_context
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|context
operator|->
name|ks_num_ops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|type
argument_list|,
name|context
operator|->
name|ks_ops
index|[
name|i
index|]
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|context
operator|->
name|ks_ops
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|_hx509_ks_register
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|struct
name|hx509_keyset_ops
modifier|*
name|ops
parameter_list|)
block|{
name|struct
name|hx509_keyset_ops
modifier|*
modifier|*
name|val
decl_stmt|;
if|if
condition|(
name|_hx509_ks_type
argument_list|(
name|context
argument_list|,
name|ops
operator|->
name|name
argument_list|)
condition|)
return|return;
name|val
operator|=
name|realloc
argument_list|(
name|context
operator|->
name|ks_ops
argument_list|,
operator|(
name|context
operator|->
name|ks_num_ops
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|context
operator|->
name|ks_ops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
return|return;
name|val
index|[
name|context
operator|->
name|ks_num_ops
index|]
operator|=
name|ops
expr_stmt|;
name|context
operator|->
name|ks_ops
operator|=
name|val
expr_stmt|;
name|context
operator|->
name|ks_num_ops
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Open or creates a new hx509 certificate store.  *  * @param context A hx509 context  * @param name name of the store, format is TYPE:type-specific-string,  * if NULL is used the MEMORY store is used.  * @param flags list of flags:  * - HX509_CERTS_CREATE create a new keystore of the specific TYPE.  * - HX509_CERTS_UNPROTECT_ALL fails if any private key failed to be extracted.  * @param lock a lock that unlocks the certificates store, use NULL to  * select no password/certifictes/prompt lock (see @ref page_lock).  * @param certs return pointer, free with hx509_certs_free().  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|int
name|hx509_certs_init
parameter_list|(
name|hx509_context
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|flags
parameter_list|,
name|hx509_lock
name|lock
parameter_list|,
name|hx509_certs
modifier|*
name|certs
parameter_list|)
block|{
name|struct
name|hx509_keyset_ops
modifier|*
name|ops
decl_stmt|;
specifier|const
name|char
modifier|*
name|residue
decl_stmt|;
name|hx509_certs
name|c
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|*
name|certs
operator|=
name|NULL
expr_stmt|;
name|residue
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|residue
condition|)
block|{
name|type
operator|=
name|malloc
argument_list|(
name|residue
operator|-
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|strlcpy
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
name|residue
operator|-
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|residue
operator|++
expr_stmt|;
if|if
condition|(
name|residue
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|residue
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|strdup
argument_list|(
literal|"MEMORY"
argument_list|)
expr_stmt|;
name|residue
operator|=
name|name
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
block|{
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|ops
operator|=
name|_hx509_ks_type
argument_list|(
name|context
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ops
operator|==
name|NULL
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ENOENT
argument_list|,
literal|"Keyset type %s is not supported"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|free
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|c
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|c
operator|->
name|ops
operator|=
name|ops
expr_stmt|;
name|c
operator|->
name|ref
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|ops
operator|->
name|init
call|)
argument_list|(
name|context
argument_list|,
name|c
argument_list|,
operator|&
name|c
operator|->
name|ops_data
argument_list|,
name|flags
argument_list|,
name|residue
argument_list|,
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
operator|*
name|certs
operator|=
name|c
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Write the certificate store to stable storage.  *  * @param context A hx509 context.  * @param certs a certificate store to store.  * @param flags currently unused, use 0.  * @param lock a lock that unlocks the certificates store, use NULL to  * select no password/certifictes/prompt lock (see @ref page_lock).  *  * @return Returns an hx509 error code. HX509_UNSUPPORTED_OPERATION if  * the certificate store doesn't support the store operation.  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|int
name|hx509_certs_store
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
name|int
name|flags
parameter_list|,
name|hx509_lock
name|lock
parameter_list|)
block|{
if|if
condition|(
name|certs
operator|->
name|ops
operator|->
name|store
operator|==
name|NULL
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|HX509_UNSUPPORTED_OPERATION
argument_list|,
literal|"keystore if type %s doesn't support "
literal|"store operation"
argument_list|,
name|certs
operator|->
name|ops
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|HX509_UNSUPPORTED_OPERATION
return|;
block|}
return|return
call|(
modifier|*
name|certs
operator|->
name|ops
operator|->
name|store
call|)
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|certs
operator|->
name|ops_data
argument_list|,
name|flags
argument_list|,
name|lock
argument_list|)
return|;
block|}
end_function

begin_function
name|hx509_certs
name|hx509_certs_ref
parameter_list|(
name|hx509_certs
name|certs
parameter_list|)
block|{
if|if
condition|(
name|certs
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|certs
operator|->
name|ref
operator|==
literal|0
condition|)
name|_hx509_abort
argument_list|(
literal|"certs refcount == 0 on ref"
argument_list|)
expr_stmt|;
if|if
condition|(
name|certs
operator|->
name|ref
operator|==
name|UINT_MAX
condition|)
name|_hx509_abort
argument_list|(
literal|"certs refcount == UINT_MAX on ref"
argument_list|)
expr_stmt|;
name|certs
operator|->
name|ref
operator|++
expr_stmt|;
return|return
name|certs
return|;
block|}
end_function

begin_comment
comment|/**  * Free a certificate store.  *  * @param certs certificate store to free.  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|void
name|hx509_certs_free
parameter_list|(
name|hx509_certs
modifier|*
name|certs
parameter_list|)
block|{
if|if
condition|(
operator|*
name|certs
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|certs
operator|)
operator|->
name|ref
operator|==
literal|0
condition|)
name|_hx509_abort
argument_list|(
literal|"cert refcount == 0 on free"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
operator|(
operator|*
name|certs
operator|)
operator|->
name|ref
operator|>
literal|0
condition|)
return|return;
operator|(
operator|*
operator|(
operator|*
name|certs
operator|)
operator|->
name|ops
operator|->
name|free
operator|)
operator|(
operator|*
name|certs
operator|,
operator|(
operator|*
name|certs
operator|)
operator|->
name|ops_data
operator|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|certs
argument_list|)
expr_stmt|;
operator|*
name|certs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Start the integration  *  * @param context a hx509 context.  * @param certs certificate store to iterate over  * @param cursor cursor that will keep track of progress, free with  * hx509_certs_end_seq().  *  * @return Returns an hx509 error code. HX509_UNSUPPORTED_OPERATION is  * returned if the certificate store doesn't support the iteration  * operation.  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|int
name|hx509_certs_start_seq
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
name|hx509_cursor
modifier|*
name|cursor
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|certs
operator|->
name|ops
operator|->
name|iter_start
operator|==
name|NULL
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|HX509_UNSUPPORTED_OPERATION
argument_list|,
literal|"Keyset type %s doesn't support iteration"
argument_list|,
name|certs
operator|->
name|ops
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|HX509_UNSUPPORTED_OPERATION
return|;
block|}
name|ret
operator|=
call|(
modifier|*
name|certs
operator|->
name|ops
operator|->
name|iter_start
call|)
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|certs
operator|->
name|ops_data
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Get next ceritificate from the certificate keystore pointed out by  * cursor.  *  * @param context a hx509 context.  * @param certs certificate store to iterate over.  * @param cursor cursor that keeps track of progress.  * @param cert return certificate next in store, NULL if the store  * contains no more certificates. Free with hx509_cert_free().  *  * @return Returns an hx509 error code.  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|int
name|hx509_certs_next_cert
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
name|hx509_cursor
name|cursor
parameter_list|,
name|hx509_cert
modifier|*
name|cert
parameter_list|)
block|{
operator|*
name|cert
operator|=
name|NULL
expr_stmt|;
return|return
call|(
modifier|*
name|certs
operator|->
name|ops
operator|->
name|iter
call|)
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|certs
operator|->
name|ops_data
argument_list|,
name|cursor
argument_list|,
name|cert
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * End the iteration over certificates.  *  * @param context a hx509 context.  * @param certs certificate store to iterate over.  * @param cursor cursor that will keep track of progress, freed.  *  * @return Returns an hx509 error code.  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|int
name|hx509_certs_end_seq
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
name|hx509_cursor
name|cursor
parameter_list|)
block|{
call|(
modifier|*
name|certs
operator|->
name|ops
operator|->
name|iter_end
call|)
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|certs
operator|->
name|ops_data
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Iterate over all certificates in a keystore and call an function  * for each fo them.  *  * @param context a hx509 context.  * @param certs certificate store to iterate over.  * @param func function to call for each certificate. The function  * should return non-zero to abort the iteration, that value is passed  * back to the caller of hx509_certs_iter_f().  * @param ctx context variable that will passed to the function.  *  * @return Returns an hx509 error code.  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|int
name|hx509_certs_iter_f
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|hx509_context
parameter_list|,
name|void
modifier|*
parameter_list|,
name|hx509_cert
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|hx509_cursor
name|cursor
decl_stmt|;
name|hx509_cert
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|hx509_certs_start_seq
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
operator|&
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|ret
operator|=
name|hx509_certs_next_cert
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|cursor
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ret
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|context
argument_list|,
name|ctx
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|hx509_cert_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
block|}
name|hx509_certs_end_seq
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Iterate over all certificates in a keystore and call an function  * for each fo them.  *  * @param context a hx509 context.  * @param certs certificate store to iterate over.  * @param func function to call for each certificate. The function  * should return non-zero to abort the iteration, that value is passed  * back to the caller of hx509_certs_iter().  *  * @return Returns an hx509 error code.  *  * @ingroup hx509_keyset  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__BLOCKS__
end_ifdef

begin_function
specifier|static
name|int
name|certs_iter
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|hx509_cert
name|cert
parameter_list|)
block|{
name|int
function_decl|(
modifier|^
name|func
function_decl|)
parameter_list|(
name|hx509_cert
parameter_list|)
init|=
name|ctx
function_decl|;
return|return
name|func
argument_list|(
name|cert
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Iterate over all certificates in a keystore and call an block  * for each fo them.  *  * @param context a hx509 context.  * @param certs certificate store to iterate over.  * @param func block to call for each certificate. The function  * should return non-zero to abort the iteration, that value is passed  * back to the caller of hx509_certs_iter().  *  * @return Returns an hx509 error code.  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|int
name|hx509_certs_iter
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
name|int
function_decl|(
modifier|^
name|func
function_decl|)
parameter_list|(
name|hx509_cert
parameter_list|)
parameter_list|)
block|{
return|return
name|hx509_certs_iter_f
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|certs_iter
argument_list|,
name|func
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Function to use to hx509_certs_iter_f() as a function argument, the  * ctx variable to hx509_certs_iter_f() should be a FILE file descriptor.  *  * @param context a hx509 context.  * @param ctx used by hx509_certs_iter_f().  * @param c a certificate  *  * @return Returns an hx509 error code.  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|int
name|hx509_ci_print_names
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|hx509_cert
name|c
parameter_list|)
block|{
name|Certificate
modifier|*
name|cert
decl_stmt|;
name|hx509_name
name|n
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|i
decl_stmt|;
name|cert
operator|=
name|_hx509_get_cert
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|_hx509_name_from_Name
argument_list|(
operator|&
name|cert
operator|->
name|tbsCertificate
operator|.
name|subject
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|hx509_name_to_string
argument_list|(
name|n
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|hx509_name_free
argument_list|(
operator|&
name|n
argument_list|)
expr_stmt|;
name|_hx509_name_from_Name
argument_list|(
operator|&
name|cert
operator|->
name|tbsCertificate
operator|.
name|issuer
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|hx509_name_to_string
argument_list|(
name|n
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|hx509_name_free
argument_list|(
operator|&
name|n
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ctx
argument_list|,
literal|"subject: %s\nissuer: %s\n"
argument_list|,
name|s
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Add a certificate to the certificiate store.  *  * The receiving keyset certs will either increase reference counter  * of the cert or make a deep copy, either way, the caller needs to  * free the cert itself.  *  * @param context a hx509 context.  * @param certs certificate store to add the certificate to.  * @param cert certificate to add.  *  * @return Returns an hx509 error code.  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|int
name|hx509_certs_add
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
name|hx509_cert
name|cert
parameter_list|)
block|{
if|if
condition|(
name|certs
operator|->
name|ops
operator|->
name|add
operator|==
name|NULL
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|ENOENT
argument_list|,
literal|"Keyset type %s doesn't support add operation"
argument_list|,
name|certs
operator|->
name|ops
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
return|return
call|(
modifier|*
name|certs
operator|->
name|ops
operator|->
name|add
call|)
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|certs
operator|->
name|ops_data
argument_list|,
name|cert
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find a certificate matching the query.  *  * @param context a hx509 context.  * @param certs certificate store to search.  * @param q query allocated with @ref hx509_query functions.  * @param r return certificate (or NULL on error), should be freed  * with hx509_cert_free().  *  * @return Returns an hx509 error code.  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|int
name|hx509_certs_find
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
specifier|const
name|hx509_query
modifier|*
name|q
parameter_list|,
name|hx509_cert
modifier|*
name|r
parameter_list|)
block|{
name|hx509_cursor
name|cursor
decl_stmt|;
name|hx509_cert
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|*
name|r
operator|=
name|NULL
expr_stmt|;
name|_hx509_query_statistic
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|certs
operator|->
name|ops
operator|->
name|query
condition|)
return|return
call|(
modifier|*
name|certs
operator|->
name|ops
operator|->
name|query
call|)
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|certs
operator|->
name|ops_data
argument_list|,
name|q
argument_list|,
name|r
argument_list|)
return|;
name|ret
operator|=
name|hx509_certs_start_seq
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
operator|&
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|c
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ret
operator|=
name|hx509_certs_next_cert
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|cursor
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|_hx509_query_match_cert
argument_list|(
name|context
argument_list|,
name|q
argument_list|,
name|c
argument_list|)
condition|)
block|{
operator|*
name|r
operator|=
name|c
expr_stmt|;
break|break;
block|}
name|hx509_cert_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|hx509_certs_end_seq
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/**      * Return HX509_CERT_NOT_FOUND if no certificate in certs matched      * the query.      */
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|HX509_CERT_NOT_FOUND
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Filter certificate matching the query.  *  * @param context a hx509 context.  * @param certs certificate store to search.  * @param q query allocated with @ref hx509_query functions.  * @param result the filtered certificate store, caller must free with  *        hx509_certs_free().  *  * @return Returns an hx509 error code.  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|int
name|hx509_certs_filter
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
specifier|const
name|hx509_query
modifier|*
name|q
parameter_list|,
name|hx509_certs
modifier|*
name|result
parameter_list|)
block|{
name|hx509_cursor
name|cursor
decl_stmt|;
name|hx509_cert
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
name|_hx509_query_statistic
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|ret
operator|=
name|hx509_certs_init
argument_list|(
name|context
argument_list|,
literal|"MEMORY:filter-certs"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|hx509_certs_start_seq
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
operator|&
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_certs_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|c
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ret
operator|=
name|hx509_certs_next_cert
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|cursor
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|_hx509_query_match_cert
argument_list|(
name|context
argument_list|,
name|q
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|hx509_certs_add
argument_list|(
name|context
argument_list|,
operator|*
name|result
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
name|hx509_cert_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|hx509_certs_end_seq
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|hx509_certs_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**      * Return HX509_CERT_NOT_FOUND if no certificate in certs matched      * the query.      */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|hx509_certs_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|hx509_clear_error_string
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|HX509_CERT_NOT_FOUND
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|certs_merge_func
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|hx509_cert
name|c
parameter_list|)
block|{
return|return
name|hx509_certs_add
argument_list|(
name|context
argument_list|,
operator|(
name|hx509_certs
operator|)
name|ctx
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Merge a certificate store into another. The from store is keep  * intact.  *  * @param context a hx509 context.  * @param to the store to merge into.  * @param from the store to copy the object from.  *  * @return Returns an hx509 error code.  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|int
name|hx509_certs_merge
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|to
parameter_list|,
name|hx509_certs
name|from
parameter_list|)
block|{
if|if
condition|(
name|from
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|hx509_certs_iter_f
argument_list|(
name|context
argument_list|,
name|from
argument_list|,
name|certs_merge_func
argument_list|,
name|to
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Same a hx509_certs_merge() but use a lock and name to describe the  * from source.  *  * @param context a hx509 context.  * @param to the store to merge into.  * @param lock a lock that unlocks the certificates store, use NULL to  * select no password/certifictes/prompt lock (see @ref page_lock).  * @param name name of the source store  *  * @return Returns an hx509 error code.  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|int
name|hx509_certs_append
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|to
parameter_list|,
name|hx509_lock
name|lock
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|hx509_certs
name|s
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|hx509_certs_init
argument_list|(
name|context
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|lock
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|hx509_certs_merge
argument_list|(
name|context
argument_list|,
name|to
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|hx509_certs_free
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Get one random certificate from the certificate store.  *  * @param context a hx509 context.  * @param certs a certificate store to get the certificate from.  * @param c return certificate, should be freed with hx509_cert_free().  *  * @return Returns an hx509 error code.  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|int
name|hx509_get_one_cert
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
name|hx509_cert
modifier|*
name|c
parameter_list|)
block|{
name|hx509_cursor
name|cursor
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|*
name|c
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|hx509_certs_start_seq
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
operator|&
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|hx509_certs_next_cert
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|cursor
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|hx509_certs_end_seq
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|certs_info_stdio
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|ctx
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Print some info about the certificate store.  *  * @param context a hx509 context.  * @param certs certificate store to print information about.  * @param func function that will get each line of the information, if  * NULL is used the data is printed on a FILE descriptor that should  * be passed in ctx, if ctx also is NULL, stdout is used.  * @param ctx parameter to func.  *  * @return Returns an hx509 error code.  *  * @ingroup hx509_keyset  */
end_comment

begin_function
name|int
name|hx509_certs_info
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
name|func
operator|=
name|certs_info_stdio
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
name|ctx
operator|=
name|stdout
expr_stmt|;
block|}
if|if
condition|(
name|certs
operator|->
name|ops
operator|->
name|printinfo
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|func
call|)
argument_list|(
name|ctx
argument_list|,
literal|"No info function for certs"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
call|(
modifier|*
name|certs
operator|->
name|ops
operator|->
name|printinfo
call|)
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|certs
operator|->
name|ops_data
argument_list|,
name|func
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|_hx509_pi_printf
parameter_list|(
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vasprintf
argument_list|(
operator|&
name|str
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return;
call|(
modifier|*
name|func
call|)
argument_list|(
name|ctx
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_hx509_certs_keys_get
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
name|hx509_private_key
modifier|*
modifier|*
name|keys
parameter_list|)
block|{
if|if
condition|(
name|certs
operator|->
name|ops
operator|->
name|getkeys
operator|==
name|NULL
condition|)
block|{
operator|*
name|keys
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
call|(
modifier|*
name|certs
operator|->
name|ops
operator|->
name|getkeys
call|)
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|certs
operator|->
name|ops_data
argument_list|,
name|keys
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|_hx509_certs_keys_add
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_certs
name|certs
parameter_list|,
name|hx509_private_key
name|key
parameter_list|)
block|{
if|if
condition|(
name|certs
operator|->
name|ops
operator|->
name|addkey
operator|==
name|NULL
condition|)
block|{
name|hx509_set_error_string
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
name|EINVAL
argument_list|,
literal|"keystore if type %s doesn't support "
literal|"key add operation"
argument_list|,
name|certs
operator|->
name|ops
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
return|return
call|(
modifier|*
name|certs
operator|->
name|ops
operator|->
name|addkey
call|)
argument_list|(
name|context
argument_list|,
name|certs
argument_list|,
name|certs
operator|->
name|ops_data
argument_list|,
name|key
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|_hx509_certs_keys_free
parameter_list|(
name|hx509_context
name|context
parameter_list|,
name|hx509_private_key
modifier|*
name|keys
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|keys
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|hx509_private_key_free
argument_list|(
operator|&
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|keys
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

