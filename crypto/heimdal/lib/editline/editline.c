begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright 1992 Simmule Turner and Rich Salz.  All rights reserved.   *  *  This software is not subject to any license of the American Telephone   *  and Telegraph Company or of the Regents of the University of California.   *  *  Permission is granted to anyone to use this software for any purpose on  *  any computer system, and to alter it and redistribute it freely, subject  *  to the following restrictions:  *  1. The authors are not responsible for the consequences of use of this  *     software, no matter how awful, even if they arise from flaws in it.  *  2. The origin of this software must not be misrepresented, either by  *     explicit claim or by omission.  Since few users ever read sources,  *     credits must appear in the documentation.  *  3. Altered versions must be plainly marked as such, and must not be  *     misrepresented as being the original software.  Since few users  *     ever read sources, credits must appear in the documentation.  *  4. This notice may not be removed or altered.  */
end_comment

begin_comment
comment|/* **  Main editing routines for editline library. */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|"editline.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: editline.c,v 1.9 1999/12/23 21:27:00 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* **  Manifest constants. */
end_comment

begin_define
define|#
directive|define
name|SCREEN_WIDTH
value|80
end_define

begin_define
define|#
directive|define
name|SCREEN_ROWS
value|24
end_define

begin_define
define|#
directive|define
name|NO_ARG
value|(-1)
end_define

begin_define
define|#
directive|define
name|DEL
value|127
end_define

begin_define
define|#
directive|define
name|CTL
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x1F)
end_define

begin_define
define|#
directive|define
name|ISCTL
parameter_list|(
name|x
parameter_list|)
value|((x)&& (x)< ' ')
end_define

begin_define
define|#
directive|define
name|UNCTL
parameter_list|(
name|x
parameter_list|)
value|((x) + 64)
end_define

begin_define
define|#
directive|define
name|META
parameter_list|(
name|x
parameter_list|)
value|((x) | 0x80)
end_define

begin_define
define|#
directive|define
name|ISMETA
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x80)
end_define

begin_define
define|#
directive|define
name|UNMETA
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x7F)
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HIST_SIZE
argument_list|)
end_if

begin_define
define|#
directive|define
name|HIST_SIZE
value|20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HIST_SIZE) */
end_comment

begin_comment
comment|/* **  Command status codes. */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|_STATUS
block|{
name|CSdone
block|,
name|CSeof
block|,
name|CSmove
block|,
name|CSdispatch
block|,
name|CSstay
block|}
name|STATUS
typedef|;
end_typedef

begin_comment
comment|/* **  The type of case-changing to perform. */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|_CASE
block|{
name|TOupper
block|,
name|TOlower
block|}
name|CASE
typedef|;
end_typedef

begin_comment
comment|/* **  Key to command mapping. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_KEYMAP
block|{
name|unsigned
name|char
name|Key
decl_stmt|;
name|STATUS
function_decl|(
modifier|*
name|Function
function_decl|)
parameter_list|()
function_decl|;
block|}
name|KEYMAP
typedef|;
end_typedef

begin_comment
comment|/* **  Command history structure. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_HISTORY
block|{
name|int
name|Size
decl_stmt|;
name|int
name|Pos
decl_stmt|;
name|unsigned
name|char
modifier|*
name|Lines
index|[
name|HIST_SIZE
index|]
decl_stmt|;
block|}
name|HISTORY
typedef|;
end_typedef

begin_comment
comment|/* **  Globals. */
end_comment

begin_decl_stmt
name|int
name|rl_eof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_erase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_kill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|NIL
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|Input
init|=
name|NIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|Line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|Prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|Yanked
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Screen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|NEWLINE
index|[]
init|=
name|CRLF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HISTORY
name|H
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_quit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Repeat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|End
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Mark
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|OldPoint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Point
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PushBack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Pushed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KEYMAP
name|Map
index|[
literal|33
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KEYMAP
name|MetaMap
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|Length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|ScreenCount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|ScreenSize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|backspace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TTYwidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TTYrows
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Display print 8-bit chars as `M-x' or as the actual 8-bit char? */
end_comment

begin_decl_stmt
name|int
name|rl_meta_chars
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Declarations. */
end_comment

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|editinput
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|tgetstr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tgetent
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tgetnum
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* **  TTY input/output functions. */
end_comment

begin_function
specifier|static
name|void
name|TTYflush
parameter_list|()
block|{
if|if
condition|(
name|ScreenCount
condition|)
block|{
name|write
argument_list|(
literal|1
argument_list|,
name|Screen
argument_list|,
name|ScreenCount
argument_list|)
expr_stmt|;
name|ScreenCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|TTYput
parameter_list|(
name|unsigned
name|char
name|c
parameter_list|)
block|{
name|Screen
index|[
name|ScreenCount
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|++
name|ScreenCount
operator|>=
name|ScreenSize
operator|-
literal|1
condition|)
block|{
name|ScreenSize
operator|+=
name|SCREEN_INC
expr_stmt|;
name|Screen
operator|=
name|realloc
argument_list|(
name|Screen
argument_list|,
name|ScreenSize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|TTYputs
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
operator|*
name|p
condition|)
name|TTYput
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|TTYshow
parameter_list|(
name|unsigned
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
name|DEL
condition|)
block|{
name|TTYput
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|TTYput
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISCTL
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|TTYput
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|TTYput
argument_list|(
name|UNCTL
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rl_meta_chars
operator|&&
name|ISMETA
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|TTYput
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
name|TTYput
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|TTYput
argument_list|(
name|UNMETA
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TTYput
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|TTYstring
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
operator|*
name|p
condition|)
name|TTYshow
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|TTYget
parameter_list|()
block|{
name|char
name|c
decl_stmt|;
name|int
name|e
decl_stmt|;
name|TTYflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|Pushed
condition|)
block|{
name|Pushed
operator|=
literal|0
expr_stmt|;
return|return
name|PushBack
return|;
block|}
if|if
condition|(
operator|*
name|Input
condition|)
return|return
operator|*
name|Input
operator|++
return|;
do|do
block|{
name|e
operator|=
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|e
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|e
operator|==
literal|1
condition|)
return|return
name|c
return|;
return|return
name|EOF
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|TTYback
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|backspace
condition|)
name|TTYputs
argument_list|(
name|backspace
argument_list|)
expr_stmt|;
else|else
name|TTYput
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|TTYbackn
parameter_list|(
name|int
name|n
parameter_list|)
block|{
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|TTYback
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|TTYinfo
parameter_list|()
block|{
specifier|static
name|int
name|init
decl_stmt|;
name|char
modifier|*
name|term
decl_stmt|;
name|char
name|buff
index|[
literal|2048
index|]
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
name|struct
name|winsize
name|W
decl_stmt|;
endif|#
directive|endif
comment|/* defined(TIOCGWINSZ) */
if|if
condition|(
name|init
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
comment|/* Perhaps we got resized. */
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|W
argument_list|)
operator|>=
literal|0
operator|&&
name|W
operator|.
name|ws_col
operator|>
literal|0
operator|&&
name|W
operator|.
name|ws_row
operator|>
literal|0
condition|)
block|{
name|TTYwidth
operator|=
operator|(
name|int
operator|)
name|W
operator|.
name|ws_col
expr_stmt|;
name|TTYrows
operator|=
operator|(
name|int
operator|)
name|W
operator|.
name|ws_row
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(TIOCGWINSZ) */
return|return;
block|}
name|init
operator|++
expr_stmt|;
name|TTYwidth
operator|=
name|TTYrows
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
operator|&
name|buff
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|term
operator|=
literal|"dumb"
expr_stmt|;
if|if
condition|(
name|tgetent
argument_list|(
name|buff
argument_list|,
name|term
argument_list|)
operator|<
literal|0
condition|)
block|{
name|TTYwidth
operator|=
name|SCREEN_WIDTH
expr_stmt|;
name|TTYrows
operator|=
name|SCREEN_ROWS
expr_stmt|;
return|return;
block|}
name|tmp
operator|=
name|tgetstr
argument_list|(
literal|"le"
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
name|backspace
operator|=
name|strdup
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
name|backspace
operator|=
literal|"\b"
expr_stmt|;
name|TTYwidth
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
name|TTYrows
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|W
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|TTYwidth
operator|=
operator|(
name|int
operator|)
name|W
operator|.
name|ws_col
expr_stmt|;
name|TTYrows
operator|=
operator|(
name|int
operator|)
name|W
operator|.
name|ws_row
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(TIOCGWINSZ) */
if|if
condition|(
name|TTYwidth
operator|<=
literal|0
operator|||
name|TTYrows
operator|<=
literal|0
condition|)
block|{
name|TTYwidth
operator|=
name|SCREEN_WIDTH
expr_stmt|;
name|TTYrows
operator|=
name|SCREEN_ROWS
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Print an array of words in columns. */
end_comment

begin_function
specifier|static
name|void
name|columns
parameter_list|(
name|int
name|ac
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|int
name|longest
decl_stmt|;
name|int
name|cols
decl_stmt|;
comment|/* Find longest name, determine column count from that. */
for|for
control|(
name|longest
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|j
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|av
index|[
name|i
index|]
argument_list|)
operator|)
operator|>
name|longest
condition|)
name|longest
operator|=
name|j
expr_stmt|;
name|cols
operator|=
name|TTYwidth
operator|/
operator|(
name|longest
operator|+
literal|3
operator|)
expr_stmt|;
name|TTYputs
argument_list|(
name|NEWLINE
argument_list|)
expr_stmt|;
for|for
control|(
name|skip
operator|=
name|ac
operator|/
name|cols
operator|+
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|skip
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|ac
condition|;
name|j
operator|+=
name|skip
control|)
block|{
for|for
control|(
name|p
operator|=
name|av
index|[
name|j
index|]
operator|,
name|len
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|,
name|k
operator|=
name|len
init|;
operator|--
name|k
operator|>=
literal|0
condition|;
name|p
operator|++
control|)
name|TTYput
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|+
name|skip
operator|<
name|ac
condition|)
while|while
condition|(
operator|++
name|len
operator|<
name|longest
operator|+
literal|3
condition|)
name|TTYput
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|TTYputs
argument_list|(
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|reposition
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|TTYput
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|TTYputs
argument_list|(
name|Prompt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|Point
operator|,
name|p
operator|=
name|Line
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|p
operator|++
control|)
name|TTYshow
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|left
parameter_list|(
name|STATUS
name|Change
parameter_list|)
block|{
name|TTYback
argument_list|()
expr_stmt|;
if|if
condition|(
name|Point
condition|)
block|{
if|if
condition|(
name|ISCTL
argument_list|(
name|Line
index|[
name|Point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|TTYback
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|rl_meta_chars
operator|&&
name|ISMETA
argument_list|(
name|Line
index|[
name|Point
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|TTYback
argument_list|()
expr_stmt|;
name|TTYback
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Change
operator|==
name|CSmove
condition|)
name|Point
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|right
parameter_list|(
name|STATUS
name|Change
parameter_list|)
block|{
name|TTYshow
argument_list|(
name|Line
index|[
name|Point
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Change
operator|==
name|CSmove
condition|)
name|Point
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|ring_bell
parameter_list|()
block|{
name|TTYput
argument_list|(
literal|'\07'
argument_list|)
expr_stmt|;
name|TTYflush
argument_list|()
expr_stmt|;
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|do_macro
parameter_list|(
name|unsigned
name|char
name|c
parameter_list|)
block|{
name|unsigned
name|char
name|name
index|[
literal|4
index|]
decl_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|name
index|[
literal|2
index|]
operator|=
literal|'_'
expr_stmt|;
name|name
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|Input
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|getenv
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Input
operator|=
name|NIL
expr_stmt|;
return|return
name|ring_bell
argument_list|()
return|;
block|}
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|do_forward
parameter_list|(
name|STATUS
name|move
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|p
operator|=
operator|&
name|Line
index|[
name|Point
index|]
expr_stmt|;
for|for
control|(
init|;
name|Point
operator|<
name|End
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|!
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|;
name|Point
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|move
operator|==
name|CSmove
condition|)
name|right
argument_list|(
name|CSstay
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|Point
operator|<
name|End
operator|&&
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|Point
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|move
operator|==
name|CSmove
condition|)
name|right
argument_list|(
name|CSstay
argument_list|)
expr_stmt|;
if|if
condition|(
name|Point
operator|==
name|End
condition|)
break|break;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|Repeat
condition|)
do|;
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|do_case
parameter_list|(
name|CASE
name|type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|do_forward
argument_list|(
name|CSstay
argument_list|)
expr_stmt|;
if|if
condition|(
name|OldPoint
operator|!=
name|Point
condition|)
block|{
if|if
condition|(
operator|(
name|count
operator|=
name|Point
operator|-
name|OldPoint
operator|)
operator|<
literal|0
condition|)
name|count
operator|=
operator|-
name|count
expr_stmt|;
name|Point
operator|=
name|OldPoint
expr_stmt|;
if|if
condition|(
operator|(
name|end
operator|=
name|Point
operator|+
name|count
operator|)
operator|>
name|End
condition|)
name|end
operator|=
name|End
expr_stmt|;
for|for
control|(
name|i
operator|=
name|Point
operator|,
name|p
operator|=
operator|&
name|Line
index|[
name|i
index|]
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
name|type
operator|==
name|TOupper
condition|)
block|{
if|if
condition|(
name|islower
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|toupper
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|right
argument_list|(
name|CSmove
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|case_down_word
parameter_list|()
block|{
return|return
name|do_case
argument_list|(
name|TOlower
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|case_up_word
parameter_list|()
block|{
return|return
name|do_case
argument_list|(
name|TOupper
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ceol
parameter_list|()
block|{
name|int
name|extras
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|extras
operator|=
literal|0
operator|,
name|i
operator|=
name|Point
operator|,
name|p
operator|=
operator|&
name|Line
index|[
name|i
index|]
init|;
name|i
operator|<=
name|End
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|TTYput
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCTL
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|TTYput
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|extras
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rl_meta_chars
operator|&&
name|ISMETA
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|TTYput
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|TTYput
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|extras
operator|+=
literal|2
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|+=
name|extras
init|;
name|i
operator|>
name|Point
condition|;
name|i
operator|--
control|)
name|TTYback
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_line
parameter_list|()
block|{
name|Point
operator|=
operator|-
name|strlen
argument_list|(
name|Prompt
argument_list|)
expr_stmt|;
name|TTYput
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|ceol
argument_list|()
expr_stmt|;
name|Point
operator|=
literal|0
expr_stmt|;
name|End
operator|=
literal|0
expr_stmt|;
name|Line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|insert_string
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|new
decl_stmt|;
name|unsigned
name|char
modifier|*
name|q
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|End
operator|+
name|len
operator|>=
name|Length
condition|)
block|{
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|(
name|Length
operator|+
name|len
operator|+
name|MEM_INC
operator|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|CSstay
return|;
if|if
condition|(
name|Length
condition|)
block|{
name|memcpy
argument_list|(
name|new
argument_list|,
name|Line
argument_list|,
name|Length
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Line
argument_list|)
expr_stmt|;
block|}
name|Line
operator|=
name|new
expr_stmt|;
name|Length
operator|+=
name|len
operator|+
name|MEM_INC
expr_stmt|;
block|}
for|for
control|(
name|q
operator|=
operator|&
name|Line
index|[
name|Point
index|]
operator|,
name|i
operator|=
name|End
operator|-
name|Point
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|q
index|[
name|len
operator|+
name|i
index|]
operator|=
name|q
index|[
name|i
index|]
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|Line
index|[
name|Point
index|]
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|End
operator|+=
name|len
expr_stmt|;
name|Line
index|[
name|End
index|]
operator|=
literal|'\0'
expr_stmt|;
name|TTYstring
argument_list|(
operator|&
name|Line
index|[
name|Point
index|]
argument_list|)
expr_stmt|;
name|Point
operator|+=
name|len
expr_stmt|;
return|return
name|Point
operator|==
name|End
condition|?
name|CSstay
else|:
name|CSmove
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|next_hist
parameter_list|()
block|{
return|return
name|H
operator|.
name|Pos
operator|>=
name|H
operator|.
name|Size
operator|-
literal|1
condition|?
name|NULL
else|:
name|H
operator|.
name|Lines
index|[
operator|++
name|H
operator|.
name|Pos
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|prev_hist
parameter_list|()
block|{
return|return
name|H
operator|.
name|Pos
operator|==
literal|0
condition|?
name|NULL
else|:
name|H
operator|.
name|Lines
index|[
operator|--
name|H
operator|.
name|Pos
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|do_insert_hist
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|ring_bell
argument_list|()
return|;
name|Point
operator|=
literal|0
expr_stmt|;
name|reposition
argument_list|()
expr_stmt|;
name|ceol
argument_list|()
expr_stmt|;
name|End
operator|=
literal|0
expr_stmt|;
return|return
name|insert_string
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|STATUS
name|do_hist
argument_list|(
name|unsigned
name|char
operator|*
call|(
modifier|*
name|move
call|)
argument_list|()
argument_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|p
operator|=
call|(
modifier|*
name|move
call|)
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|ring_bell
argument_list|()
return|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|Repeat
condition|)
do|;
return|return
name|do_insert_hist
argument_list|(
name|p
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|STATUS
name|h_next
parameter_list|()
block|{
return|return
name|do_hist
argument_list|(
name|next_hist
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|h_prev
parameter_list|()
block|{
return|return
name|do_hist
argument_list|(
name|prev_hist
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|h_first
parameter_list|()
block|{
return|return
name|do_insert_hist
argument_list|(
name|H
operator|.
name|Lines
index|[
name|H
operator|.
name|Pos
operator|=
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|h_last
parameter_list|()
block|{
return|return
name|do_insert_hist
argument_list|(
name|H
operator|.
name|Lines
index|[
name|H
operator|.
name|Pos
operator|=
name|H
operator|.
name|Size
operator|-
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Return zero if pat appears as a substring in text. */
end_comment

begin_function
specifier|static
name|int
name|substrcmp
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|pat
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|pat
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|*
name|text
operator|==
literal|'\0'
return|;
for|for
control|(
init|;
operator|*
name|text
condition|;
name|text
operator|++
control|)
if|if
condition|(
operator|*
name|text
operator|==
name|c
operator|&&
name|strncmp
argument_list|(
name|text
argument_list|,
name|pat
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|search_hist
argument_list|(
name|unsigned
name|char
operator|*
name|search
argument_list|,
name|unsigned
name|char
operator|*
call|(
modifier|*
name|move
call|)
argument_list|()
argument_list|)
block|{
specifier|static
name|unsigned
name|char
modifier|*
name|old_search
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|int
function_decl|(
modifier|*
name|match
function_decl|)
parameter_list|()
function_decl|;
name|char
modifier|*
name|pat
decl_stmt|;
comment|/* Save or get remembered search pattern. */
if|if
condition|(
name|search
operator|&&
operator|*
name|search
condition|)
block|{
if|if
condition|(
name|old_search
condition|)
name|free
argument_list|(
name|old_search
argument_list|)
expr_stmt|;
name|old_search
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|search
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|old_search
operator|==
name|NULL
operator|||
operator|*
name|old_search
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|search
operator|=
name|old_search
expr_stmt|;
block|}
comment|/* Set up pattern-finder. */
if|if
condition|(
operator|*
name|search
operator|==
literal|'^'
condition|)
block|{
name|match
operator|=
name|strncmp
expr_stmt|;
name|pat
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|search
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|match
operator|=
name|substrcmp
expr_stmt|;
name|pat
operator|=
operator|(
name|char
operator|*
operator|)
name|search
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|pat
argument_list|)
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|H
operator|.
name|Pos
init|;
call|(
modifier|*
name|move
call|)
argument_list|()
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
call|(
modifier|*
name|match
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|H
operator|.
name|Lines
index|[
name|H
operator|.
name|Pos
index|]
argument_list|,
name|pat
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|H
operator|.
name|Lines
index|[
name|H
operator|.
name|Pos
index|]
return|;
name|H
operator|.
name|Pos
operator|=
name|pos
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|STATUS
name|h_search
parameter_list|()
block|{
specifier|static
name|int
name|Searching
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_prompt
decl_stmt|;
name|unsigned
name|char
modifier|*
argument_list|(
operator|*
name|move
argument_list|)
argument_list|()
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|Searching
condition|)
return|return
name|ring_bell
argument_list|()
return|;
name|Searching
operator|=
literal|1
expr_stmt|;
name|clear_line
argument_list|()
expr_stmt|;
name|old_prompt
operator|=
name|Prompt
expr_stmt|;
name|Prompt
operator|=
literal|"Search: "
expr_stmt|;
name|TTYputs
argument_list|(
name|Prompt
argument_list|)
expr_stmt|;
name|move
operator|=
name|Repeat
operator|==
name|NO_ARG
condition|?
name|prev_hist
else|:
name|next_hist
expr_stmt|;
name|p
operator|=
name|search_hist
argument_list|(
name|editinput
argument_list|()
argument_list|,
name|move
argument_list|)
expr_stmt|;
name|clear_line
argument_list|()
expr_stmt|;
name|Prompt
operator|=
name|old_prompt
expr_stmt|;
name|TTYputs
argument_list|(
name|Prompt
argument_list|)
expr_stmt|;
name|Searching
operator|=
literal|0
expr_stmt|;
return|return
name|do_insert_hist
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|fd_char
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|Point
operator|>=
name|End
condition|)
break|break;
name|right
argument_list|(
name|CSmove
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|Repeat
condition|)
do|;
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_yank
parameter_list|(
name|int
name|begin
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|Yanked
condition|)
block|{
name|free
argument_list|(
name|Yanked
argument_list|)
expr_stmt|;
name|Yanked
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|1
condition|)
return|return;
if|if
condition|(
operator|(
name|Yanked
operator|=
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|Yanked
argument_list|,
operator|&
name|Line
index|[
name|begin
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Yanked
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|STATUS
name|delete_string
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
operator|||
name|End
operator|==
name|Point
condition|)
return|return
name|ring_bell
argument_list|()
return|;
if|if
condition|(
name|count
operator|==
literal|1
operator|&&
name|Point
operator|==
name|End
operator|-
literal|1
condition|)
block|{
comment|/* Optimize common case of delete at end of line. */
name|End
operator|--
expr_stmt|;
name|p
operator|=
operator|&
name|Line
index|[
name|Point
index|]
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|TTYput
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCTL
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|i
operator|=
literal|2
expr_stmt|;
name|TTYput
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rl_meta_chars
operator|&&
name|ISMETA
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|i
operator|=
literal|3
expr_stmt|;
name|TTYput
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|TTYput
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|TTYbackn
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|CSmove
return|;
block|}
if|if
condition|(
name|Point
operator|+
name|count
operator|>
name|End
operator|&&
operator|(
name|count
operator|=
name|End
operator|-
name|Point
operator|)
operator|<=
literal|0
condition|)
return|return
name|CSstay
return|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|save_yank
argument_list|(
name|Point
argument_list|,
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|Line
index|[
name|Point
index|]
operator|,
name|i
operator|=
name|End
operator|-
operator|(
name|Point
operator|+
name|count
operator|)
operator|+
literal|1
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|p
operator|++
control|)
name|p
index|[
literal|0
index|]
operator|=
name|p
index|[
name|count
index|]
expr_stmt|;
name|ceol
argument_list|()
expr_stmt|;
name|End
operator|-=
name|count
expr_stmt|;
name|TTYstring
argument_list|(
operator|&
name|Line
index|[
name|Point
index|]
argument_list|)
expr_stmt|;
return|return
name|CSmove
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|bk_char
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|Point
operator|==
literal|0
condition|)
break|break;
name|left
argument_list|(
name|CSmove
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|Repeat
condition|)
do|;
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|bk_del_char
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|Point
operator|==
literal|0
condition|)
break|break;
name|left
argument_list|(
name|CSmove
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|Repeat
condition|)
do|;
return|return
name|delete_string
argument_list|(
name|i
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|redisplay
parameter_list|()
block|{
name|TTYputs
argument_list|(
name|NEWLINE
argument_list|)
expr_stmt|;
name|TTYputs
argument_list|(
name|Prompt
argument_list|)
expr_stmt|;
name|TTYstring
argument_list|(
name|Line
argument_list|)
expr_stmt|;
return|return
name|CSmove
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|kill_line
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|Repeat
operator|!=
name|NO_ARG
condition|)
block|{
if|if
condition|(
name|Repeat
operator|<
name|Point
condition|)
block|{
name|i
operator|=
name|Point
expr_stmt|;
name|Point
operator|=
name|Repeat
expr_stmt|;
name|reposition
argument_list|()
expr_stmt|;
name|delete_string
argument_list|(
name|i
operator|-
name|Point
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Repeat
operator|>
name|Point
condition|)
block|{
name|right
argument_list|(
name|CSmove
argument_list|)
expr_stmt|;
name|delete_string
argument_list|(
name|Repeat
operator|-
name|Point
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|CSmove
return|;
block|}
name|save_yank
argument_list|(
name|Point
argument_list|,
name|End
operator|-
name|Point
argument_list|)
expr_stmt|;
name|Line
index|[
name|Point
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ceol
argument_list|()
expr_stmt|;
name|End
operator|=
name|Point
expr_stmt|;
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|insert_char
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|STATUS
name|s
decl_stmt|;
name|unsigned
name|char
name|buff
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|Repeat
operator|==
name|NO_ARG
operator|||
name|Repeat
operator|<
literal|2
condition|)
block|{
name|buff
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buff
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|insert_string
argument_list|(
name|buff
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
name|Repeat
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|CSstay
return|;
for|for
control|(
name|i
operator|=
name|Repeat
operator|,
name|q
operator|=
name|p
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|Repeat
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|insert_string
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|meta
parameter_list|()
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|KEYMAP
modifier|*
name|kp
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|TTYget
argument_list|()
operator|)
operator|==
name|EOF
condition|)
return|return
name|CSeof
return|;
comment|/* Also include VT-100 arrows. */
if|if
condition|(
name|c
operator|==
literal|'['
operator|||
name|c
operator|==
literal|'O'
condition|)
switch|switch
condition|(
name|c
operator|=
name|TTYget
argument_list|()
condition|)
block|{
default|default:
return|return
name|ring_bell
argument_list|()
return|;
case|case
name|EOF
case|:
return|return
name|CSeof
return|;
case|case
literal|'A'
case|:
return|return
name|h_prev
argument_list|()
return|;
case|case
literal|'B'
case|:
return|return
name|h_next
argument_list|()
return|;
case|case
literal|'C'
case|:
return|return
name|fd_char
argument_list|()
return|;
case|case
literal|'D'
case|:
return|return
name|bk_char
argument_list|()
return|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
for|for
control|(
name|Repeat
operator|=
name|c
operator|-
literal|'0'
init|;
operator|(
name|c
operator|=
name|TTYget
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|isdigit
argument_list|(
name|c
argument_list|)
condition|;
control|)
name|Repeat
operator|=
name|Repeat
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|Pushed
operator|=
literal|1
expr_stmt|;
name|PushBack
operator|=
name|c
expr_stmt|;
return|return
name|CSstay
return|;
block|}
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|do_macro
argument_list|(
name|c
argument_list|)
return|;
for|for
control|(
name|OldPoint
operator|=
name|Point
operator|,
name|kp
operator|=
name|MetaMap
init|;
name|kp
operator|->
name|Function
condition|;
name|kp
operator|++
control|)
if|if
condition|(
name|kp
operator|->
name|Key
operator|==
name|c
condition|)
return|return
call|(
modifier|*
name|kp
operator|->
name|Function
call|)
argument_list|()
return|;
return|return
name|ring_bell
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|emacs
parameter_list|(
name|unsigned
name|int
name|c
parameter_list|)
block|{
name|STATUS
name|s
decl_stmt|;
name|KEYMAP
modifier|*
name|kp
decl_stmt|;
if|if
condition|(
name|ISMETA
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|Pushed
operator|=
literal|1
expr_stmt|;
name|PushBack
operator|=
name|UNMETA
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|meta
argument_list|()
return|;
block|}
for|for
control|(
name|kp
operator|=
name|Map
init|;
name|kp
operator|->
name|Function
condition|;
name|kp
operator|++
control|)
if|if
condition|(
name|kp
operator|->
name|Key
operator|==
name|c
condition|)
break|break;
name|s
operator|=
name|kp
operator|->
name|Function
condition|?
call|(
modifier|*
name|kp
operator|->
name|Function
call|)
argument_list|()
else|:
name|insert_char
argument_list|(
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Pushed
condition|)
comment|/* No pushback means no repeat count; hacky, but true. */
name|Repeat
operator|=
name|NO_ARG
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|TTYspecial
parameter_list|(
name|unsigned
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|ISMETA
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|CSdispatch
return|;
if|if
condition|(
name|c
operator|==
name|rl_erase
operator|||
name|c
operator|==
name|DEL
condition|)
return|return
name|bk_del_char
argument_list|()
return|;
if|if
condition|(
name|c
operator|==
name|rl_kill
condition|)
block|{
if|if
condition|(
name|Point
operator|!=
literal|0
condition|)
block|{
name|Point
operator|=
literal|0
expr_stmt|;
name|reposition
argument_list|()
expr_stmt|;
block|}
name|Repeat
operator|=
name|NO_ARG
expr_stmt|;
return|return
name|kill_line
argument_list|()
return|;
block|}
if|if
condition|(
name|c
operator|==
name|rl_intr
operator|||
name|c
operator|==
name|rl_quit
condition|)
block|{
name|Point
operator|=
name|End
operator|=
literal|0
expr_stmt|;
name|Line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|redisplay
argument_list|()
return|;
block|}
if|if
condition|(
name|c
operator|==
name|rl_eof
operator|&&
name|Point
operator|==
literal|0
operator|&&
name|End
operator|==
literal|0
condition|)
return|return
name|CSeof
return|;
return|return
name|CSdispatch
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|editinput
parameter_list|()
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|Repeat
operator|=
name|NO_ARG
expr_stmt|;
name|OldPoint
operator|=
name|Point
operator|=
name|Mark
operator|=
name|End
operator|=
literal|0
expr_stmt|;
name|Line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|TTYget
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|TTYspecial
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|CSdone
case|:
return|return
name|Line
return|;
case|case
name|CSeof
case|:
return|return
name|NULL
return|;
case|case
name|CSmove
case|:
name|reposition
argument_list|()
expr_stmt|;
break|break;
case|case
name|CSdispatch
case|:
switch|switch
condition|(
name|emacs
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|CSdone
case|:
return|return
name|Line
return|;
case|case
name|CSeof
case|:
return|return
name|NULL
return|;
case|case
name|CSmove
case|:
name|reposition
argument_list|()
expr_stmt|;
break|break;
case|case
name|CSdispatch
case|:
case|case
name|CSstay
case|:
break|break;
block|}
break|break;
case|case
name|CSstay
case|:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hist_add
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|H
operator|.
name|Size
operator|<
name|HIST_SIZE
condition|)
name|H
operator|.
name|Lines
index|[
name|H
operator|.
name|Size
operator|++
index|]
operator|=
name|p
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|H
operator|.
name|Lines
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HIST_SIZE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|H
operator|.
name|Lines
index|[
name|i
index|]
operator|=
name|H
operator|.
name|Lines
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|H
operator|.
name|Lines
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
block|}
name|H
operator|.
name|Pos
operator|=
name|H
operator|.
name|Size
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  For compatibility with FSF readline. */
end_comment

begin_comment
comment|/* ARGSUSED0 */
end_comment

begin_function
name|void
name|rl_reset_terminal
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|rl_initialize
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|char
modifier|*
name|readline
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|line
decl_stmt|;
if|if
condition|(
name|Line
operator|==
name|NULL
condition|)
block|{
name|Length
operator|=
name|MEM_INC
expr_stmt|;
if|if
condition|(
operator|(
name|Line
operator|=
name|malloc
argument_list|(
name|Length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|TTYinfo
argument_list|()
expr_stmt|;
name|rl_ttyset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hist_add
argument_list|(
name|NIL
argument_list|)
expr_stmt|;
name|ScreenSize
operator|=
name|SCREEN_INC
expr_stmt|;
name|Screen
operator|=
name|malloc
argument_list|(
name|ScreenSize
argument_list|)
expr_stmt|;
name|Prompt
operator|=
name|prompt
condition|?
name|prompt
else|:
operator|(
name|char
operator|*
operator|)
name|NIL
expr_stmt|;
name|TTYputs
argument_list|(
name|Prompt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|line
operator|=
name|editinput
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|line
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line
argument_list|)
expr_stmt|;
name|TTYputs
argument_list|(
name|NEWLINE
argument_list|)
expr_stmt|;
name|TTYflush
argument_list|()
expr_stmt|;
block|}
name|rl_ttyset
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Screen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|H
operator|.
name|Lines
index|[
operator|--
name|H
operator|.
name|Size
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|line
return|;
block|}
end_function

begin_function
name|void
name|add_history
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|UNIQUE_HISTORY
argument_list|)
if|if
condition|(
name|H
operator|.
name|Pos
operator|&&
name|strcmp
argument_list|(
name|p
argument_list|,
name|H
operator|.
name|Lines
index|[
name|H
operator|.
name|Pos
operator|-
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return;
endif|#
directive|endif
comment|/* defined(UNIQUE_HISTORY) */
name|hist_add
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|STATUS
name|beg_line
parameter_list|()
block|{
if|if
condition|(
name|Point
condition|)
block|{
name|Point
operator|=
literal|0
expr_stmt|;
return|return
name|CSmove
return|;
block|}
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|del_char
parameter_list|()
block|{
return|return
name|delete_string
argument_list|(
name|Repeat
operator|==
name|NO_ARG
condition|?
literal|1
else|:
name|Repeat
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|end_line
parameter_list|()
block|{
if|if
condition|(
name|Point
operator|!=
name|End
condition|)
block|{
name|Point
operator|=
name|End
expr_stmt|;
return|return
name|CSmove
return|;
block|}
return|return
name|CSstay
return|;
block|}
end_function

begin_comment
comment|/* **  Move back to the beginning of the current word and return an **  allocated copy of it. */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|find_word
parameter_list|()
block|{
specifier|static
name|char
name|SEPS
index|[]
init|=
literal|"#;&|^$=`'{}()<>\n\t "
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|new
decl_stmt|;
name|size_t
name|len
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|Line
index|[
name|Point
index|]
init|;
name|p
operator|>
name|Line
operator|&&
name|strchr
argument_list|(
name|SEPS
argument_list|,
operator|(
name|char
operator|)
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|==
name|NULL
condition|;
name|p
operator|--
control|)
continue|continue;
name|len
operator|=
name|Point
operator|-
operator|(
name|p
operator|-
name|Line
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|new
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|new
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|c_complete
parameter_list|()
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|word
decl_stmt|;
name|int
name|unique
decl_stmt|;
name|STATUS
name|s
decl_stmt|;
name|word
operator|=
name|find_word
argument_list|()
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rl_complete
argument_list|(
operator|(
name|char
operator|*
operator|)
name|word
argument_list|,
operator|&
name|unique
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
condition|)
name|free
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|*
name|p
condition|)
block|{
name|s
operator|=
name|insert_string
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unique
condition|)
name|ring_bell
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
return|return
name|ring_bell
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|c_possible
parameter_list|()
block|{
name|unsigned
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|unsigned
name|char
modifier|*
name|word
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|word
operator|=
name|find_word
argument_list|()
expr_stmt|;
name|ac
operator|=
name|rl_list_possib
argument_list|(
operator|(
name|char
operator|*
operator|)
name|word
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
operator|&
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
condition|)
name|free
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
condition|)
block|{
name|columns
argument_list|(
name|ac
argument_list|,
name|av
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|ac
operator|>=
literal|0
condition|)
name|free
argument_list|(
name|av
index|[
name|ac
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|av
argument_list|)
expr_stmt|;
return|return
name|CSmove
return|;
block|}
return|return
name|ring_bell
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|accept_line
parameter_list|()
block|{
name|Line
index|[
name|End
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|CSdone
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|transpose
parameter_list|()
block|{
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|Point
condition|)
block|{
if|if
condition|(
name|Point
operator|==
name|End
condition|)
name|left
argument_list|(
name|CSmove
argument_list|)
expr_stmt|;
name|c
operator|=
name|Line
index|[
name|Point
operator|-
literal|1
index|]
expr_stmt|;
name|left
argument_list|(
name|CSstay
argument_list|)
expr_stmt|;
name|Line
index|[
name|Point
operator|-
literal|1
index|]
operator|=
name|Line
index|[
name|Point
index|]
expr_stmt|;
name|TTYshow
argument_list|(
name|Line
index|[
name|Point
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|Line
index|[
name|Point
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|TTYshow
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|quote
parameter_list|()
block|{
name|unsigned
name|int
name|c
decl_stmt|;
return|return
operator|(
name|c
operator|=
name|TTYget
argument_list|()
operator|)
operator|==
name|EOF
condition|?
name|CSeof
else|:
name|insert_char
argument_list|(
operator|(
name|int
operator|)
name|c
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|wipe
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|Mark
operator|>
name|End
condition|)
return|return
name|ring_bell
argument_list|()
return|;
if|if
condition|(
name|Point
operator|>
name|Mark
condition|)
block|{
name|i
operator|=
name|Point
expr_stmt|;
name|Point
operator|=
name|Mark
expr_stmt|;
name|Mark
operator|=
name|i
expr_stmt|;
name|reposition
argument_list|()
expr_stmt|;
block|}
return|return
name|delete_string
argument_list|(
name|Mark
operator|-
name|Point
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|mk_set
parameter_list|()
block|{
name|Mark
operator|=
name|Point
expr_stmt|;
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|exchange
parameter_list|()
block|{
name|unsigned
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|TTYget
argument_list|()
operator|)
operator|!=
name|CTL
argument_list|(
literal|'X'
argument_list|)
condition|)
return|return
name|c
operator|==
name|EOF
condition|?
name|CSeof
else|:
name|ring_bell
argument_list|()
return|;
if|if
condition|(
operator|(
name|c
operator|=
name|Mark
operator|)
operator|<=
name|End
condition|)
block|{
name|Mark
operator|=
name|Point
expr_stmt|;
name|Point
operator|=
name|c
expr_stmt|;
return|return
name|CSmove
return|;
block|}
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|yank
parameter_list|()
block|{
if|if
condition|(
name|Yanked
operator|&&
operator|*
name|Yanked
condition|)
return|return
name|insert_string
argument_list|(
name|Yanked
argument_list|)
return|;
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|copy_region
parameter_list|()
block|{
if|if
condition|(
name|Mark
operator|>
name|End
condition|)
return|return
name|ring_bell
argument_list|()
return|;
if|if
condition|(
name|Point
operator|>
name|Mark
condition|)
name|save_yank
argument_list|(
name|Mark
argument_list|,
name|Point
operator|-
name|Mark
argument_list|)
expr_stmt|;
else|else
name|save_yank
argument_list|(
name|Point
argument_list|,
name|Mark
operator|-
name|Point
argument_list|)
expr_stmt|;
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|move_to_char
parameter_list|()
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|TTYget
argument_list|()
operator|)
operator|==
name|EOF
condition|)
return|return
name|CSeof
return|;
for|for
control|(
name|i
operator|=
name|Point
operator|+
literal|1
operator|,
name|p
operator|=
operator|&
name|Line
index|[
name|i
index|]
init|;
name|i
operator|<
name|End
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|c
condition|)
block|{
name|Point
operator|=
name|i
expr_stmt|;
return|return
name|CSmove
return|;
block|}
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|fd_word
parameter_list|()
block|{
return|return
name|do_forward
argument_list|(
name|CSmove
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|fd_kill_word
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|do_forward
argument_list|(
name|CSstay
argument_list|)
expr_stmt|;
if|if
condition|(
name|OldPoint
operator|!=
name|Point
condition|)
block|{
name|i
operator|=
name|Point
operator|-
name|OldPoint
expr_stmt|;
name|Point
operator|=
name|OldPoint
expr_stmt|;
return|return
name|delete_string
argument_list|(
name|i
argument_list|)
return|;
block|}
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|bk_word
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
for|for
control|(
name|p
operator|=
operator|&
name|Line
index|[
name|Point
index|]
init|;
name|p
operator|>
name|Line
operator|&&
operator|!
name|isalnum
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|;
name|p
operator|--
control|)
name|left
argument_list|(
name|CSmove
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|>
name|Line
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
operator|&&
name|isalnum
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|;
name|p
operator|--
control|)
name|left
argument_list|(
name|CSmove
argument_list|)
expr_stmt|;
if|if
condition|(
name|Point
operator|==
literal|0
condition|)
break|break;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|Repeat
condition|)
do|;
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|bk_kill_word
parameter_list|()
block|{
name|bk_word
argument_list|()
expr_stmt|;
if|if
condition|(
name|OldPoint
operator|!=
name|Point
condition|)
return|return
name|delete_string
argument_list|(
name|OldPoint
operator|-
name|Point
argument_list|)
return|;
return|return
name|CSstay
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|argify
parameter_list|(
name|unsigned
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
modifier|*
name|avp
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|c
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|new
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|MEM_INC
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|avp
operator|=
name|p
operator|=
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|*
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
for|for
control|(
name|c
operator|=
name|line
init|;
name|isspace
argument_list|(
operator|*
name|c
argument_list|)
condition|;
name|c
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|c
operator|==
literal|'\n'
operator|||
operator|*
name|c
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
for|for
control|(
name|ac
operator|=
literal|0
operator|,
name|p
index|[
name|ac
operator|++
index|]
operator|=
name|c
init|;
operator|*
name|c
operator|&&
operator|*
name|c
operator|!=
literal|'\n'
condition|;
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|c
argument_list|)
condition|)
block|{
operator|*
name|c
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|&&
operator|*
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|ac
operator|+
literal|1
operator|==
name|i
condition|)
block|{
name|new
operator|=
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|*
operator|(
name|i
operator|+
name|MEM_INC
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|p
index|[
name|ac
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|ac
return|;
block|}
name|memcpy
argument_list|(
name|new
argument_list|,
name|p
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|+=
name|MEM_INC
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|avp
operator|=
name|p
operator|=
name|new
expr_stmt|;
block|}
name|p
index|[
name|ac
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
name|c
operator|++
expr_stmt|;
block|}
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
name|p
index|[
name|ac
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|ac
return|;
block|}
end_function

begin_function
specifier|static
name|STATUS
name|last_argument
parameter_list|()
block|{
name|unsigned
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|STATUS
name|s
decl_stmt|;
name|int
name|ac
decl_stmt|;
if|if
condition|(
name|H
operator|.
name|Size
operator|==
literal|1
operator|||
operator|(
name|p
operator|=
name|H
operator|.
name|Lines
index|[
name|H
operator|.
name|Size
operator|-
literal|2
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
name|ring_bell
argument_list|()
return|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|CSstay
return|;
name|ac
operator|=
name|argify
argument_list|(
name|p
argument_list|,
operator|&
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|Repeat
operator|!=
name|NO_ARG
condition|)
name|s
operator|=
name|Repeat
operator|<
name|ac
condition|?
name|insert_string
argument_list|(
name|av
index|[
name|Repeat
index|]
argument_list|)
else|:
name|ring_bell
argument_list|()
expr_stmt|;
else|else
name|s
operator|=
name|ac
condition|?
name|insert_string
argument_list|(
name|av
index|[
name|ac
operator|-
literal|1
index|]
argument_list|)
else|:
name|CSstay
expr_stmt|;
if|if
condition|(
name|ac
condition|)
name|free
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|KEYMAP
name|Map
index|[
literal|33
index|]
init|=
block|{
block|{
name|CTL
argument_list|(
literal|'@'
argument_list|)
block|,
name|ring_bell
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'A'
argument_list|)
block|,
name|beg_line
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'B'
argument_list|)
block|,
name|bk_char
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'D'
argument_list|)
block|,
name|del_char
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'E'
argument_list|)
block|,
name|end_line
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'F'
argument_list|)
block|,
name|fd_char
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'G'
argument_list|)
block|,
name|ring_bell
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'H'
argument_list|)
block|,
name|bk_del_char
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'I'
argument_list|)
block|,
name|c_complete
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'J'
argument_list|)
block|,
name|accept_line
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'K'
argument_list|)
block|,
name|kill_line
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'L'
argument_list|)
block|,
name|redisplay
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'M'
argument_list|)
block|,
name|accept_line
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'N'
argument_list|)
block|,
name|h_next
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'O'
argument_list|)
block|,
name|ring_bell
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'P'
argument_list|)
block|,
name|h_prev
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'Q'
argument_list|)
block|,
name|ring_bell
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'R'
argument_list|)
block|,
name|h_search
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'S'
argument_list|)
block|,
name|ring_bell
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'T'
argument_list|)
block|,
name|transpose
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'U'
argument_list|)
block|,
name|ring_bell
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'V'
argument_list|)
block|,
name|quote
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'W'
argument_list|)
block|,
name|wipe
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'X'
argument_list|)
block|,
name|exchange
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'Y'
argument_list|)
block|,
name|yank
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'Z'
argument_list|)
block|,
name|ring_bell
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'['
argument_list|)
block|,
name|meta
block|}
block|,
block|{
name|CTL
argument_list|(
literal|']'
argument_list|)
block|,
name|move_to_char
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'^'
argument_list|)
block|,
name|ring_bell
block|}
block|,
block|{
name|CTL
argument_list|(
literal|'_'
argument_list|)
block|,
name|ring_bell
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KEYMAP
name|MetaMap
index|[
literal|16
index|]
init|=
block|{
block|{
name|CTL
argument_list|(
literal|'H'
argument_list|)
block|,
name|bk_kill_word
block|}
block|,
block|{
name|DEL
block|,
name|bk_kill_word
block|}
block|,
block|{
literal|' '
block|,
name|mk_set
block|}
block|,
block|{
literal|'.'
block|,
name|last_argument
block|}
block|,
block|{
literal|'<'
block|,
name|h_first
block|}
block|,
block|{
literal|'>'
block|,
name|h_last
block|}
block|,
block|{
literal|'?'
block|,
name|c_possible
block|}
block|,
block|{
literal|'b'
block|,
name|bk_word
block|}
block|,
block|{
literal|'d'
block|,
name|fd_kill_word
block|}
block|,
block|{
literal|'f'
block|,
name|fd_word
block|}
block|,
block|{
literal|'l'
block|,
name|case_down_word
block|}
block|,
block|{
literal|'u'
block|,
name|case_up_word
block|}
block|,
block|{
literal|'y'
block|,
name|yank
block|}
block|,
block|{
literal|'w'
block|,
name|copy_region
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

