begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * lib/krb5/os/k5dfspag.c  *  * New Kerberos module to issue the DFS PAG syscalls.   * It also contains the routine to fork and exec the  * k5dcecon routine to do most of the work.   *   * This file is designed to be as independent of DCE   * and DFS as possible. The only dependencies are on   * the syscall numbers.  If DFS not running or not installed,  * the sig handlers will catch and the signal and   * will  continue.   *  * krb5_dfs_newpag and krb5_dfs_getpag should not be real  * Kerberos routines, since they should be setpag and getpag  * in the DCE library, but without the DCE baggage.   * Thus they don't have context, and don't return a krb5 error.   *  *   *   * krb5_dfs_pag()  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: k5dfspag.c,v 1.4 2001/02/07 06:14:46 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<krb5.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DCE
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* Only run this DFS PAG code on systems with POSIX  * All that we are interested in dor:, AIX 4.x,  * Solaris 2.5.x, HPUX 10.x  Even SunOS 4.1.4, AIX 3.2.5  * and SGI 5.3 are OK.  This simplifies  * the build/configure which I don't want to change now.  * All of them also have waitpid as well.   */
end_comment

begin_define
define|#
directive|define
name|POSIX_SETJMP
end_define

begin_define
define|#
directive|define
name|POSIX_SIGNALS
end_define

begin_define
define|#
directive|define
name|HAVE_WAITPID
end_define

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|POSIX_SETJMP
end_ifndef

begin_undef
undef|#
directive|undef
name|sigjmp_buf
end_undef

begin_undef
undef|#
directive|undef
name|sigsetjmp
end_undef

begin_undef
undef|#
directive|undef
name|siglongjmp
end_undef

begin_define
define|#
directive|define
name|sigjmp_buf
value|jmp_buf
end_define

begin_define
define|#
directive|define
name|sigsetjmp
parameter_list|(
name|j
parameter_list|,
name|s
parameter_list|)
value|setjmp(j)
end_define

begin_define
define|#
directive|define
name|siglongjmp
value|longjmp
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
end_ifdef

begin_typedef
typedef|typedef
name|struct
name|sigaction
name|handler
typedef|;
end_typedef

begin_define
define|#
directive|define
name|handler_init
parameter_list|(
name|H
parameter_list|,
name|F
parameter_list|)
value|(sigemptyset(&(H).sa_mask), \                      (H).sa_flags=0, \                      (H).sa_handler=(F))
end_define

begin_define
define|#
directive|define
name|handler_swap
parameter_list|(
name|S
parameter_list|,
name|NEW
parameter_list|,
name|OLD
parameter_list|)
value|sigaction(S,&NEW,&OLD)
end_define

begin_define
define|#
directive|define
name|handler_set
parameter_list|(
name|S
parameter_list|,
name|OLD
parameter_list|)
value|sigaction(S,&OLD, NULL)
end_define

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|sigtype
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_define
define|#
directive|define
name|handler_init
parameter_list|(
name|H
parameter_list|,
name|F
parameter_list|)
value|((H) = (F))
end_define

begin_define
define|#
directive|define
name|handler_swap
parameter_list|(
name|S
parameter_list|,
name|NEW
parameter_list|,
name|OLD
parameter_list|)
value|((OLD) = signal ((S), (NEW)))
end_define

begin_define
define|#
directive|define
name|handler_set
parameter_list|(
name|S
parameter_list|,
name|OLD
parameter_list|)
value|(signal ((S), (OLD)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|krb5_sigtype
value|void
end_define

begin_define
define|#
directive|define
name|WAIT_USES_INT
end_define

begin_typedef
typedef|typedef
name|krb5_sigtype
name|sigtype
typedef|;
end_typedef

begin_comment
comment|/*   * Need some syscall numbers based on different systems.   * These are based on:   * HPUX 10.10 /opt/dce/include/dcedfs/syscall.h   * Solaris 2.5 /opt/dcelocal/share/include/dcedfs/syscall.h  * AIX 4.2  - needs some funny games with load and kafs_syscall  * to get the kernel extentions. There should be a better way!   *   * DEE 5/27/97  *  */
end_comment

begin_define
define|#
directive|define
name|AFSCALL_SETPAG
value|2
end_define

begin_define
define|#
directive|define
name|AFSCALL_GETPAG
value|11
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_define
define|#
directive|define
name|AFS_SYSCALL
value|72
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|hpux
argument_list|)
end_elif

begin_comment
comment|/* assume HPUX 10 +  or is it 50 */
end_comment

begin_define
define|#
directive|define
name|AFS_SYSCALL
value|326
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_AIX
argument_list|)
end_elif

begin_ifndef
ifndef|#
directive|ifndef
name|DPAGAIX
end_ifndef

begin_define
define|#
directive|define
name|DPAGAIX
value|LIBEXECDIR ## "/dpagaix"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
modifier|*
name|load
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|dpagaix
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
init|=
literal|0
function_decl|;
end_function_decl

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|_sgi
argument_list|)
end_elif

begin_define
define|#
directive|define
name|AFS_SYSCALL
value|206+1000
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|AFS_SYSCALL
value|(Unknown_DFS_AFS_SYSCALL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WAIT_USES_INT
end_ifdef

begin_decl_stmt
name|int
name|wait_status
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* WAIT_USES_INT */
end_comment

begin_decl_stmt
name|union
name|wait
name|wait_status
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WAIT_USES_INT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|K5DCECON
end_ifndef

begin_define
define|#
directive|define
name|K5DCECON
value|LIBEXECDIR ## "/k5dcecon"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * mysig()  *  * signal handler if DFS not running  *  */
end_comment

begin_decl_stmt
specifier|static
name|sigjmp_buf
name|setpag_buf
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|sigtype
name|mysig
parameter_list|()
block|{
name|siglongjmp
argument_list|(
name|setpag_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * krb5_dfs_pag_syscall()  *  * wrapper for the syscall with signal handlers  *  */
end_comment

begin_function
specifier|static
name|int
name|krb5_dfs_pag_syscall
parameter_list|(
name|opt1
parameter_list|,
name|opt2
parameter_list|)
name|int
name|opt1
decl_stmt|;
name|int
name|opt2
decl_stmt|;
block|{
name|handler
name|sa1
decl_stmt|,
name|osa1
decl_stmt|;
name|handler
name|sa2
decl_stmt|,
name|osa2
decl_stmt|;
name|int
name|pag
init|=
operator|-
literal|2
decl_stmt|;
name|handler_init
argument_list|(
name|sa1
argument_list|,
name|mysig
argument_list|)
expr_stmt|;
name|handler_init
argument_list|(
name|sa2
argument_list|,
name|mysig
argument_list|)
expr_stmt|;
name|handler_swap
argument_list|(
name|SIGSYS
argument_list|,
name|sa1
argument_list|,
name|osa1
argument_list|)
expr_stmt|;
name|handler_swap
argument_list|(
name|SIGSEGV
argument_list|,
name|sa2
argument_list|,
name|osa2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigsetjmp
argument_list|(
name|setpag_buf
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_AIX
argument_list|)
if|if
condition|(
operator|!
name|dpagaix
condition|)
name|dpagaix
operator|=
name|load
argument_list|(
name|DPAGAIX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpagaix
condition|)
name|pag
operator|=
call|(
modifier|*
name|dpagaix
call|)
argument_list|(
name|opt1
argument_list|,
name|opt2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|pag
operator|=
name|syscall
argument_list|(
name|AFS_SYSCALL
argument_list|,
name|opt1
argument_list|,
name|opt2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|handler_set
argument_list|(
name|SIGSYS
argument_list|,
name|osa1
argument_list|)
expr_stmt|;
name|handler_set
argument_list|(
name|SIGSEGV
argument_list|,
name|osa2
argument_list|)
expr_stmt|;
return|return
operator|(
name|pag
operator|)
return|;
block|}
comment|/* syscall failed! return 0 */
name|handler_set
argument_list|(
name|SIGSYS
argument_list|,
name|osa1
argument_list|)
expr_stmt|;
name|handler_set
argument_list|(
name|SIGSEGV
argument_list|,
name|osa2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * krb5_dfs_newpag()  *  * issue a DCE/DFS setpag system call to set the newpag  * for this process. This takes advantage of a currently  * undocumented feature of the Transarc port of DFS.   * Even in DCE 1.2.2 for which the source is available,  * (but no vendors have released), this feature is not  * there, but it should be, or could be added.   * If new_pag is zero, then the syscall will get a new pag  * and return its value.   */
end_comment

begin_function
name|int
name|krb5_dfs_newpag
parameter_list|(
name|new_pag
parameter_list|)
name|int
name|new_pag
decl_stmt|;
block|{
return|return
operator|(
name|krb5_dfs_pag_syscall
argument_list|(
name|AFSCALL_SETPAG
argument_list|,
name|new_pag
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * krb5_dfs_getpag()  *  * get the current PAG. Used mostly as a test.   */
end_comment

begin_function
name|int
name|krb5_dfs_getpag
parameter_list|()
block|{
return|return
operator|(
name|krb5_dfs_pag_syscall
argument_list|(
name|AFSCALL_GETPAG
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * krb5_dfs_pag()  *  * Given a principal and local username,  * fork and exec the k5dcecon module to create   * refresh or join a new DCE/DFS  * Process Authentication Group (PAG)  *   * This routine should be called after krb5_kuserok has   * determined that this combination of local user and   * principal are acceptable for the local host.   *   * It should also be called after a forwarded ticket has   * been received, and the KRB5CCNAME environment variable  * has been set to point at it. k5dcecon will convert this  * to a new DCE context and a new pag and replace KRB5CCNAME  * in the environment.   *  * If there is no forwarded ticket, k5dcecon will attempt  * to join an existing PAG for the same principal and local  * user.   *  * And it should be called before access to the home directory  * as this may be in DFS, not accessable by root, and require  * the PAG to have been setup.   *   * The krb5_afs_pag can be called after this routine to   * use the the cache obtained by k5dcecon to get an AFS token.   * DEE - 7/97  */
end_comment

begin_function
name|int
name|krb5_dfs_pag
parameter_list|(
name|context
parameter_list|,
name|flag
parameter_list|,
name|principal
parameter_list|,
name|luser
parameter_list|)
name|krb5_context
name|context
decl_stmt|;
name|int
name|flag
decl_stmt|;
comment|/* 1 if a forwarded TGT is to be used */
name|krb5_principal
name|principal
decl_stmt|;
specifier|const
name|char
modifier|*
name|luser
decl_stmt|;
block|{
name|struct
name|stat
name|stx
decl_stmt|;
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|new_pag
decl_stmt|;
name|int
name|pag
decl_stmt|;
name|char
name|newccname
index|[
name|MAXPATHLEN
index|]
init|=
literal|""
decl_stmt|;
name|char
modifier|*
name|princ
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|sigaction
name|newsig
decl_stmt|,
name|oldsig
decl_stmt|;
ifdef|#
directive|ifdef
name|WAIT_USES_INT
name|int
name|wait_status
decl_stmt|;
else|#
directive|else
comment|/* WAIT_USES_INT */
name|union
name|wait
name|wait_status
decl_stmt|;
endif|#
directive|endif
comment|/* WAIT_USES_INT */
if|if
condition|(
name|krb5_unparse_name
argument_list|(
name|context
argument_list|,
name|principal
argument_list|,
operator|&
name|princ
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* test if DFS is running or installed */
if|if
condition|(
name|krb5_dfs_getpag
argument_list|()
operator|==
operator|-
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* DFS not running, dont try */
if|if
condition|(
name|pipe
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Make sure that telnetd.c's SIGCHLD action don't happen right now... */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|newsig
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|newsig
argument_list|)
argument_list|)
expr_stmt|;
name|newsig
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|newsig
argument_list|,
operator|&
name|oldsig
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* child process */
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* close stdout */
name|dup
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* point stdout at pipe here */
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* don't use end of pipe here */
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* pipe now as stdout */
name|execl
argument_list|(
name|K5DCECON
argument_list|,
literal|"k5dcecon"
argument_list|,
operator|(
name|flag
operator|)
condition|?
literal|"-f"
else|:
literal|"-s"
argument_list|,
literal|"-l"
argument_list|,
name|luser
argument_list|,
literal|"-p"
argument_list|,
name|princ
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
comment|/* incase execl fails */
block|}
comment|/* parent, wait for child to finish */
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* dont need this end of pipe */
comment|/* #if defined(sgi) || defined(_sgi) */
comment|/* wait_status.w_status = 0; */
comment|/* waitpid((pid_t) pid,&wait_status.w_status, 0); */
comment|/* #else */
name|wait_status
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_WAITPID
name|err
operator|=
name|waitpid
argument_list|(
operator|(
name|pid_t
operator|)
name|pid
argument_list|,
operator|&
name|wait_status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HAVE_WAITPID */
name|err
operator|=
name|wait4
argument_list|(
name|pid
argument_list|,
operator|&
name|wait_status
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_WAITPID */
comment|/* #endif */
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|oldsig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|wait_status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|read
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
operator|&
name|newccname
index|[
name|j
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|newccname
argument_list|)
operator|-
literal|1
operator|-
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|j
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|j
operator|>=
sizeof|sizeof
argument_list|(
name|newccname
argument_list|)
operator|-
literal|1
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|newccname
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|esetenv
argument_list|(
literal|"KRB5CCNAME"
argument_list|,
name|newccname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
operator|&
name|newccname
index|[
name|j
operator|-
literal|8
index|]
argument_list|,
literal|"%8x"
argument_list|,
operator|&
name|new_pag
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pag
operator|&&
name|strncmp
argument_list|(
literal|"FILE:/opt/dcelocal/var/security/creds/dcecred_"
argument_list|,
name|newccname
argument_list|,
literal|46
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pag
operator|=
name|krb5_dfs_newpag
argument_list|(
name|new_pag
argument_list|)
operator|)
operator|!=
operator|-
literal|2
condition|)
block|{
return|return
operator|(
name|pag
operator|)
return|;
block|}
block|}
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* something not right */
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DCE */
end_comment

begin_comment
comment|/*   * krb5_dfs_pag - dummy version for the lib for systems   * which don't have DFS, or the needed setpag kernel code.    */
end_comment

begin_function
name|krb5_boolean
name|krb5_dfs_pag
parameter_list|(
name|context
parameter_list|,
name|principal
parameter_list|,
name|luser
parameter_list|)
name|krb5_context
name|context
decl_stmt|;
name|krb5_principal
name|principal
decl_stmt|;
specifier|const
name|char
modifier|*
name|luser
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCE */
end_comment

end_unit

