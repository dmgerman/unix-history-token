begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997 - 2005 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *  * Portions Copyright (c) 2009 Apple Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"gen_locl.h"
end_include

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|symbol_name
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|Type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_template_type
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|Type
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ttype_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
return|return
name|t
operator|->
name|symbol
operator|->
name|gen_name
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|integer_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|->
name|members
condition|)
return|return
literal|"int"
return|;
comment|/* XXX enum foo */
elseif|else
if|if
condition|(
name|t
operator|->
name|range
operator|==
name|NULL
condition|)
return|return
literal|"heim_integer"
return|;
elseif|else
if|if
condition|(
name|t
operator|->
name|range
operator|->
name|min
operator|==
name|INT_MIN
operator|&&
name|t
operator|->
name|range
operator|->
name|max
operator|==
name|INT_MAX
condition|)
return|return
literal|"int"
return|;
elseif|else
if|if
condition|(
name|t
operator|->
name|range
operator|->
name|min
operator|==
literal|0
operator|&&
name|t
operator|->
name|range
operator|->
name|max
operator|==
name|UINT_MAX
condition|)
return|return
literal|"unsigned"
return|;
elseif|else
if|if
condition|(
name|t
operator|->
name|range
operator|->
name|min
operator|==
literal|0
operator|&&
name|t
operator|->
name|range
operator|->
name|max
operator|==
name|INT_MAX
condition|)
return|return
literal|"unsigned"
return|;
else|else
block|{
name|abort
argument_list|()
expr_stmt|;
name|UNREACHABLE
argument_list|(
argument|return NULL
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|boolean_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
return|return
literal|"int"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|octetstring_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
return|return
literal|"heim_octet_string"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|sequence_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
return|return
name|basename
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|time_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
return|return
literal|"time_t"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|tag_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
return|return
name|symbol_name
argument_list|(
name|basename
argument_list|,
name|t
operator|->
name|subtype
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|generalstring_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
return|return
literal|"heim_general_string"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|printablestring_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
return|return
literal|"heim_printable_string"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ia5string_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
return|return
literal|"heim_ia5_string"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|visiblestring_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
return|return
literal|"heim_visible_string"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|utf8string_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
return|return
literal|"heim_utf8_string"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|bmpstring_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
return|return
literal|"heim_bmp_string"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|universalstring_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
return|return
literal|"heim_universal_string"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|oid_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
return|return
literal|"heim_oid"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|bitstring_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|->
name|members
condition|)
return|return
name|basename
return|;
return|return
literal|"heim_bit_string"
return|;
block|}
end_function

begin_struct
struct|struct
block|{
name|enum
name|typetype
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|symbol_name
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|Type
modifier|*
parameter_list|)
function_decl|;
name|int
name|is_struct
decl_stmt|;
block|}
name|types
index|[]
init|=
block|{
block|{
name|TBMPString
block|,
name|bmpstring_symbol
block|,
literal|0
block|}
block|,
block|{
name|TBitString
block|,
name|bitstring_symbol
block|,
literal|0
block|}
block|,
block|{
name|TBoolean
block|,
name|boolean_symbol
block|,
literal|0
block|}
block|,
block|{
name|TGeneralString
block|,
name|generalstring_symbol
block|,
literal|0
block|}
block|,
block|{
name|TGeneralizedTime
block|,
name|time_symbol
block|,
literal|0
block|}
block|,
block|{
name|TIA5String
block|,
name|ia5string_symbol
block|,
literal|0
block|}
block|,
block|{
name|TInteger
block|,
name|integer_symbol
block|,
literal|0
block|}
block|,
block|{
name|TOID
block|,
name|oid_symbol
block|,
literal|0
block|}
block|,
block|{
name|TOctetString
block|,
name|octetstring_symbol
block|,
literal|0
block|}
block|,
block|{
name|TPrintableString
block|,
name|printablestring_symbol
block|,
literal|0
block|}
block|,
block|{
name|TSequence
block|,
name|sequence_symbol
block|,
literal|1
block|}
block|,
block|{
name|TSequenceOf
block|,
name|tag_symbol
block|,
literal|1
block|}
block|,
block|{
name|TSetOf
block|,
name|tag_symbol
block|,
literal|1
block|}
block|,
block|{
name|TTag
block|,
name|tag_symbol
block|,
literal|1
block|}
block|,
block|{
name|TType
block|,
name|ttype_symbol
block|,
literal|1
block|}
block|,
block|{
name|TUTCTime
block|,
name|time_symbol
block|,
literal|0
block|}
block|,
block|{
name|TUniversalString
block|,
name|universalstring_symbol
block|,
literal|0
block|}
block|,
block|{
name|TVisibleString
block|,
name|visiblestring_symbol
block|,
literal|0
block|}
block|,
block|{
name|TUTF8String
block|,
name|utf8string_symbol
block|,
literal|0
block|}
block|,
block|{
name|TChoice
block|,
name|sequence_symbol
block|,
literal|1
block|}
block|,
block|{
name|TNull
block|,
name|integer_symbol
block|,
literal|1
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|FILE
modifier|*
name|get_code_file
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|one_code_file
condition|)
return|return
name|templatefile
return|;
return|return
name|codefile
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_supported_type_p
parameter_list|(
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|types
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|types
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|types
index|[
name|i
index|]
operator|.
name|type
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|is_template_compat
parameter_list|(
specifier|const
name|Symbol
modifier|*
name|s
parameter_list|)
block|{
return|return
name|is_supported_type_p
argument_list|(
name|s
operator|->
name|type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|symbol_name
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|types
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|types
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|types
index|[
name|i
index|]
operator|.
name|type
condition|)
return|return
operator|(
name|types
index|[
name|i
index|]
operator|.
name|symbol_name
operator|)
operator|(
name|basename
operator|,
name|t
operator|)
return|;
name|printf
argument_list|(
literal|"unknown der type: %d\n"
argument_list|,
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|partial_offset
parameter_list|(
specifier|const
name|char
modifier|*
name|basetype
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|need_offset
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|need_offset
operator|==
literal|0
condition|)
return|return
name|strdup
argument_list|(
literal|"0"
argument_list|)
return|;
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|str
argument_list|,
literal|"offsetof(struct %s, %s)"
argument_list|,
name|basetype
argument_list|,
name|name
argument_list|)
operator|<
literal|0
operator|||
name|str
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_struct
struct|struct
name|template
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|tt
decl_stmt|;
name|char
modifier|*
name|offset
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|ASN1_TAILQ_ENTRY
argument_list|(
argument|template
argument_list|)
name|members
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|ASN1_TAILQ_HEAD
argument_list|(
name|templatehead
argument_list|,
name|template
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|tlist
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|header
decl_stmt|;
name|struct
name|templatehead
name|template
decl_stmt|;
name|ASN1_TAILQ_ENTRY
argument_list|(
argument|tlist
argument_list|)
name|tmembers
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|ASN1_TAILQ_HEAD
argument_list|(
name|tlisthead
argument_list|,
name|tlist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|tlist_header
parameter_list|(
name|struct
name|tlist
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__format__
parameter_list|(
name|__printf__
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|struct
name|template
modifier|*
name|add_line
parameter_list|(
name|struct
name|templatehead
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__format__
parameter_list|(
name|__printf__
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|int
name|tlist_cmp
parameter_list|(
specifier|const
name|struct
name|tlist
modifier|*
parameter_list|,
specifier|const
name|struct
name|tlist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_line_pointer
parameter_list|(
name|struct
name|templatehead
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__format__
parameter_list|(
name|__printf__
parameter_list|,
function_decl|4
operator|,
function_decl|5
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|static
name|struct
name|tlisthead
name|tlistmaster
init|=
name|ASN1_TAILQ_HEAD_INITIALIZER
argument_list|(
name|tlistmaster
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|numdups
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|tlist
modifier|*
name|tlist_new
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|tlist
modifier|*
name|tl
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tl
argument_list|)
argument_list|)
decl_stmt|;
name|tl
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ASN1_TAILQ_INIT
argument_list|(
operator|&
name|tl
operator|->
name|template
argument_list|)
expr_stmt|;
return|return
name|tl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tlist_header
parameter_list|(
name|struct
name|tlist
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|vasprintf
argument_list|(
operator|&
name|t
operator|->
name|header
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
operator|<
literal|0
operator|||
name|t
operator|->
name|header
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|tlist_count
parameter_list|(
name|struct
name|tlist
modifier|*
name|tl
parameter_list|)
block|{
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|template
modifier|*
name|q
decl_stmt|;
name|ASN1_TAILQ_FOREACH
argument_list|(
argument|q
argument_list|,
argument|&tl->template
argument_list|,
argument|members
argument_list|)
block|{
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tlist_add
parameter_list|(
name|struct
name|tlist
modifier|*
name|tl
parameter_list|)
block|{
name|ASN1_TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|tlistmaster
argument_list|,
name|tl
argument_list|,
name|tmembers
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tlist_print
parameter_list|(
name|struct
name|tlist
modifier|*
name|tl
parameter_list|)
block|{
name|struct
name|template
modifier|*
name|q
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|1
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|get_code_file
argument_list|()
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"static const struct asn1_template asn1_%s[] = {\n"
argument_list|,
name|tl
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"/* 0 */ %s,\n"
argument_list|,
name|tl
operator|->
name|header
argument_list|)
expr_stmt|;
name|ASN1_TAILQ_FOREACH
argument_list|(
argument|q
argument_list|,
argument|&tl->template
argument_list|,
argument|members
argument_list|)
block|{
name|int
name|last
init|=
operator|(
name|ASN1_TAILQ_LAST
argument_list|(
operator|&
name|tl
operator|->
name|template
argument_list|,
name|templatehead
argument_list|)
operator|==
name|q
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"/* %lu */ %s%s\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|i
operator|++
argument_list|,
name|q
operator|->
name|line
argument_list|,
name|last
condition|?
literal|""
else|:
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|tlist
modifier|*
name|tlist_find_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|tlist
modifier|*
name|ql
decl_stmt|;
name|ASN1_TAILQ_FOREACH
argument_list|(
argument|ql
argument_list|,
argument|&tlistmaster
argument_list|,
argument|tmembers
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ql
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ql
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tlist_cmp_name
parameter_list|(
specifier|const
name|char
modifier|*
name|tname
parameter_list|,
specifier|const
name|char
modifier|*
name|qname
parameter_list|)
block|{
name|struct
name|tlist
modifier|*
name|tl
init|=
name|tlist_find_by_name
argument_list|(
name|tname
argument_list|)
decl_stmt|;
name|struct
name|tlist
modifier|*
name|ql
init|=
name|tlist_find_by_name
argument_list|(
name|qname
argument_list|)
decl_stmt|;
return|return
name|tlist_cmp
argument_list|(
name|tl
argument_list|,
name|ql
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tlist_cmp
parameter_list|(
specifier|const
name|struct
name|tlist
modifier|*
name|tl
parameter_list|,
specifier|const
name|struct
name|tlist
modifier|*
name|ql
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|template
modifier|*
name|t
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|ret
operator|=
name|strcmp
argument_list|(
name|tl
operator|->
name|header
argument_list|,
name|ql
operator|->
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|q
operator|=
name|ASN1_TAILQ_FIRST
argument_list|(
operator|&
name|ql
operator|->
name|template
argument_list|)
expr_stmt|;
name|ASN1_TAILQ_FOREACH
argument_list|(
argument|t
argument_list|,
argument|&tl->template
argument_list|,
argument|members
argument_list|)
block|{
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t
operator|->
name|ptr
operator|==
name|NULL
operator|||
name|q
operator|->
name|ptr
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|strcmp
argument_list|(
name|t
operator|->
name|line
argument_list|,
name|q
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
else|else
block|{
name|ret
operator|=
name|strcmp
argument_list|(
name|t
operator|->
name|tt
argument_list|,
name|q
operator|->
name|tt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|strcmp
argument_list|(
name|t
operator|->
name|offset
argument_list|,
name|q
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|strcmp
argument_list|(
name|t
operator|->
name|ptr
argument_list|,
name|q
operator|->
name|ptr
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|tlist_cmp_name
argument_list|(
name|t
operator|->
name|ptr
argument_list|,
name|q
operator|->
name|ptr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
block|}
name|q
operator|=
name|ASN1_TAILQ_NEXT
argument_list|(
name|q
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|tlist_find_dup
parameter_list|(
specifier|const
name|struct
name|tlist
modifier|*
name|tl
parameter_list|)
block|{
name|struct
name|tlist
modifier|*
name|ql
decl_stmt|;
name|ASN1_TAILQ_FOREACH
argument_list|(
argument|ql
argument_list|,
argument|&tlistmaster
argument_list|,
argument|tmembers
argument_list|)
block|{
if|if
condition|(
name|tlist_cmp
argument_list|(
name|ql
argument_list|,
name|tl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|numdups
operator|++
expr_stmt|;
return|return
name|ql
operator|->
name|name
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|struct
name|template
modifier|*
name|add_line
parameter_list|(
name|struct
name|templatehead
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|template
modifier|*
name|q
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|vasprintf
argument_list|(
operator|&
name|q
operator|->
name|line
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
operator|<
literal|0
operator|||
name|q
operator|->
name|line
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ASN1_TAILQ_INSERT_TAIL
argument_list|(
name|t
argument_list|,
name|q
argument_list|,
name|members
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_line_pointer
parameter_list|(
name|struct
name|templatehead
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
name|ttfmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|template
modifier|*
name|q
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|tt
init|=
name|NULL
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|ttfmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|vasprintf
argument_list|(
operator|&
name|tt
argument_list|,
name|ttfmt
argument_list|,
name|ap
argument_list|)
operator|<
literal|0
operator|||
name|tt
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|q
operator|=
name|add_line
argument_list|(
name|t
argument_list|,
literal|"{ %s, %s, asn1_%s }"
argument_list|,
name|tt
argument_list|,
name|offset
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|q
operator|->
name|tt
operator|=
name|tt
expr_stmt|;
name|q
operator|->
name|offset
operator|=
name|strdup
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|q
operator|->
name|ptr
operator|=
name|strdup
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|use_extern
parameter_list|(
specifier|const
name|Symbol
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_struct
parameter_list|(
name|Type
modifier|*
name|t
parameter_list|,
name|int
name|isstruct
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|TType
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|TSequence
operator|||
name|t
operator|->
name|type
operator|==
name|TSet
operator|||
name|t
operator|->
name|type
operator|==
name|TChoice
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|TTag
condition|)
return|return
name|is_struct
argument_list|(
name|t
operator|->
name|subtype
argument_list|,
name|isstruct
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|types
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|types
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|types
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
if|if
condition|(
name|types
index|[
name|i
index|]
operator|.
name|is_struct
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
break|break;
block|}
block|}
return|return
name|isstruct
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|Type
modifier|*
name|compact_tag
parameter_list|(
specifier|const
name|Type
modifier|*
name|t
parameter_list|)
block|{
while|while
condition|(
name|t
operator|->
name|type
operator|==
name|TTag
condition|)
name|t
operator|=
name|t
operator|->
name|subtype
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|template_members
parameter_list|(
name|struct
name|templatehead
modifier|*
name|temp
parameter_list|,
specifier|const
name|char
modifier|*
name|basetype
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|Type
modifier|*
name|t
parameter_list|,
name|int
name|optional
parameter_list|,
name|int
name|isstruct
parameter_list|,
name|int
name|need_offset
parameter_list|)
block|{
name|char
modifier|*
name|poffset
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|optional
operator|&&
name|t
operator|->
name|type
operator|!=
name|TTag
operator|&&
name|t
operator|->
name|type
operator|!=
name|TType
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s...%s is optional and not a (TTag or TType)"
argument_list|,
name|basetype
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|poffset
operator|=
name|partial_offset
argument_list|(
name|basetype
argument_list|,
name|name
argument_list|,
name|need_offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|type
condition|)
block|{
case|case
name|TType
case|:
if|if
condition|(
name|use_extern
argument_list|(
name|t
operator|->
name|symbol
argument_list|)
condition|)
block|{
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_OP_TYPE_EXTERN %s, %s,&asn1_extern_%s}"
argument_list|,
name|optional
condition|?
literal|"|A1_FLAG_OPTIONAL"
else|:
literal|""
argument_list|,
name|poffset
argument_list|,
name|t
operator|->
name|symbol
operator|->
name|gen_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_line_pointer
argument_list|(
name|temp
argument_list|,
name|t
operator|->
name|symbol
operator|->
name|gen_name
argument_list|,
name|poffset
argument_list|,
literal|"A1_OP_TYPE %s"
argument_list|,
name|optional
condition|?
literal|"|A1_FLAG_OPTIONAL"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TInteger
case|:
block|{
name|char
modifier|*
name|itype
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|members
condition|)
name|itype
operator|=
literal|"IMEMBER"
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|range
operator|==
name|NULL
condition|)
name|itype
operator|=
literal|"HEIM_INTEGER"
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|range
operator|->
name|min
operator|==
name|INT_MIN
operator|&&
name|t
operator|->
name|range
operator|->
name|max
operator|==
name|INT_MAX
condition|)
name|itype
operator|=
literal|"INTEGER"
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|range
operator|->
name|min
operator|==
literal|0
operator|&&
name|t
operator|->
name|range
operator|->
name|max
operator|==
name|UINT_MAX
condition|)
name|itype
operator|=
literal|"UNSIGNED"
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|range
operator|->
name|min
operator|==
literal|0
operator|&&
name|t
operator|->
name|range
operator|->
name|max
operator|==
name|INT_MAX
condition|)
name|itype
operator|=
literal|"UNSIGNED"
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: unsupported range %d -> %d"
argument_list|,
name|name
argument_list|,
name|t
operator|->
name|range
operator|->
name|min
argument_list|,
name|t
operator|->
name|range
operator|->
name|max
argument_list|)
expr_stmt|;
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_PARSE_T(A1T_%s), %s, NULL }"
argument_list|,
name|itype
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TGeneralString
case|:
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_PARSE_T(A1T_GENERAL_STRING), %s, NULL }"
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TTeletexString
case|:
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_PARSE_T(A1T_TELETEX_STRING), %s, NULL }"
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TPrintableString
case|:
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_PARSE_T(A1T_PRINTABLE_STRING), %s, NULL }"
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOctetString
case|:
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_PARSE_T(A1T_OCTET_STRING), %s, NULL }"
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIA5String
case|:
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_PARSE_T(A1T_IA5_STRING), %s, NULL }"
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBMPString
case|:
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_PARSE_T(A1T_BMP_STRING), %s, NULL }"
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TUniversalString
case|:
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_PARSE_T(A1T_UNIVERSAL_STRING), %s, NULL }"
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TVisibleString
case|:
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_PARSE_T(A1T_VISIBLE_STRING), %s, NULL }"
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TUTF8String
case|:
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_PARSE_T(A1T_UTF8_STRING), %s, NULL }"
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TGeneralizedTime
case|:
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_PARSE_T(A1T_GENERALIZED_TIME), %s, NULL }"
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TUTCTime
case|:
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_PARSE_T(A1T_UTC_TIME), %s, NULL }"
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBoolean
case|:
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_PARSE_T(A1T_BOOLEAN), %s, NULL }"
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOID
case|:
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_PARSE_T(A1T_OID), %s, NULL }"
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TNull
case|:
break|break;
case|case
name|TBitString
case|:
block|{
name|struct
name|templatehead
name|template
init|=
name|ASN1_TAILQ_HEAD_INITIALIZER
argument_list|(
name|template
argument_list|)
decl_stmt|;
name|struct
name|template
modifier|*
name|q
decl_stmt|;
name|Member
modifier|*
name|m
decl_stmt|;
name|size_t
name|count
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|bname
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|get_code_file
argument_list|()
decl_stmt|;
if|if
condition|(
name|ASN1_TAILQ_EMPTY
argument_list|(
name|t
operator|->
name|members
argument_list|)
condition|)
block|{
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_PARSE_T(A1T_HEIM_BIT_STRING), %s, NULL }"
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|bname
argument_list|,
literal|"bmember_%s_%p"
argument_list|,
name|name
condition|?
name|name
else|:
literal|""
argument_list|,
name|t
argument_list|)
operator|<
literal|0
operator|||
name|bname
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|output_name
argument_list|(
name|bname
argument_list|)
expr_stmt|;
name|ASN1_TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|t->members
argument_list|,
argument|members
argument_list|)
block|{
name|add_line
argument_list|(
operator|&
name|template
argument_list|,
literal|"{ 0, %d, 0 } /* %s */"
argument_list|,
name|m
operator|->
name|val
argument_list|,
name|m
operator|->
name|gen_name
argument_list|)
expr_stmt|;
block|}
name|ASN1_TAILQ_FOREACH
argument_list|(
argument|q
argument_list|,
argument|&template
argument_list|,
argument|members
argument_list|)
block|{
name|count
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"static const struct asn1_template asn1_%s_%s[] = {\n"
argument_list|,
name|basetype
argument_list|,
name|bname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"/* 0 */ { 0%s, sizeof(%s), ((void *)%lu) },\n"
argument_list|,
name|rfc1510_bitstring
condition|?
literal|"|A1_HBF_RFC1510"
else|:
literal|""
argument_list|,
name|basetype
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|count
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|ASN1_TAILQ_FOREACH
argument_list|(
argument|q
argument_list|,
argument|&template
argument_list|,
argument|members
argument_list|)
block|{
name|int
name|last
init|=
operator|(
name|ASN1_TAILQ_LAST
argument_list|(
operator|&
name|template
argument_list|,
name|templatehead
argument_list|)
operator|==
name|q
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"/* %lu */ %s%s\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|i
operator|++
argument_list|,
name|q
operator|->
name|line
argument_list|,
name|last
condition|?
literal|""
else|:
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_OP_BMEMBER, %s, asn1_%s_%s }"
argument_list|,
name|poffset
argument_list|,
name|basetype
argument_list|,
name|bname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bname
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TSequence
case|:
block|{
name|Member
modifier|*
name|m
decl_stmt|;
name|ASN1_TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|t->members
argument_list|,
argument|members
argument_list|)
block|{
name|char
modifier|*
name|newbasename
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|ellipsis
condition|)
continue|continue;
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|newbasename
argument_list|,
literal|"%s_%s"
argument_list|,
name|basetype
argument_list|,
name|name
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
block|}
else|else
name|newbasename
operator|=
name|strdup
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbasename
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|template_members
argument_list|(
name|temp
argument_list|,
name|newbasename
argument_list|,
name|m
operator|->
name|gen_name
argument_list|,
name|m
operator|->
name|type
argument_list|,
name|m
operator|->
name|optional
argument_list|,
name|isstruct
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newbasename
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TTag
case|:
block|{
name|char
modifier|*
name|tname
init|=
name|NULL
decl_stmt|,
modifier|*
name|elname
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|sename
decl_stmt|,
modifier|*
name|dupname
decl_stmt|;
name|int
name|subtype_is_struct
init|=
name|is_struct
argument_list|(
name|t
operator|->
name|subtype
argument_list|,
name|isstruct
argument_list|)
decl_stmt|;
if|if
condition|(
name|subtype_is_struct
condition|)
name|sename
operator|=
name|basetype
expr_stmt|;
else|else
name|sename
operator|=
name|symbol_name
argument_list|(
name|basetype
argument_list|,
name|t
operator|->
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|tname
argument_list|,
literal|"tag_%s_%p"
argument_list|,
name|name
condition|?
name|name
else|:
literal|""
argument_list|,
name|t
argument_list|)
operator|<
literal|0
operator|||
name|tname
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|output_name
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|elname
argument_list|,
literal|"%s_%s"
argument_list|,
name|basetype
argument_list|,
name|tname
argument_list|)
operator|<
literal|0
operator|||
name|elname
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|generate_template_type
argument_list|(
name|elname
argument_list|,
operator|&
name|dupname
argument_list|,
name|NULL
argument_list|,
name|sename
argument_list|,
name|name
argument_list|,
name|t
operator|->
name|subtype
argument_list|,
literal|0
argument_list|,
name|subtype_is_struct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_line_pointer
argument_list|(
name|temp
argument_list|,
name|dupname
argument_list|,
name|poffset
argument_list|,
literal|"A1_TAG_T(%s,%s,%s)%s"
argument_list|,
name|classname
argument_list|(
name|t
operator|->
name|tag
operator|.
name|tagclass
argument_list|)
argument_list|,
name|is_primitive_type
argument_list|(
name|t
operator|->
name|subtype
operator|->
name|type
argument_list|)
condition|?
literal|"PRIM"
else|:
literal|"CONS"
argument_list|,
name|valuename
argument_list|(
name|t
operator|->
name|tag
operator|.
name|tagclass
argument_list|,
name|t
operator|->
name|tag
operator|.
name|tagvalue
argument_list|)
argument_list|,
name|optional
condition|?
literal|"|A1_FLAG_OPTIONAL"
else|:
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elname
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TSetOf
case|:
case|case
name|TSequenceOf
case|:
block|{
specifier|const
name|char
modifier|*
name|type
init|=
name|NULL
decl_stmt|,
modifier|*
name|tname
decl_stmt|,
modifier|*
name|dupname
decl_stmt|;
name|char
modifier|*
name|sename
init|=
name|NULL
decl_stmt|,
modifier|*
name|elname
init|=
name|NULL
decl_stmt|;
name|int
name|subtype_is_struct
init|=
name|is_struct
argument_list|(
name|t
operator|->
name|subtype
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|&&
name|subtype_is_struct
condition|)
block|{
name|tname
operator|=
literal|"seofTstruct"
expr_stmt|;
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|sename
argument_list|,
literal|"%s_%s_val"
argument_list|,
name|basetype
argument_list|,
name|name
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtype_is_struct
condition|)
block|{
name|tname
operator|=
literal|"seofTstruct"
expr_stmt|;
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|sename
argument_list|,
literal|"%s_val"
argument_list|,
name|symbol_name
argument_list|(
name|basetype
argument_list|,
name|t
operator|->
name|subtype
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|name
condition|)
name|tname
operator|=
name|name
expr_stmt|;
else|else
name|tname
operator|=
literal|"seofTstruct"
expr_stmt|;
name|sename
operator|=
name|strdup
argument_list|(
name|symbol_name
argument_list|(
name|basetype
argument_list|,
name|t
operator|->
name|subtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sename
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|TSetOf
condition|)
name|type
operator|=
literal|"A1_OP_SETOF"
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|TSequenceOf
condition|)
name|type
operator|=
literal|"A1_OP_SEQOF"
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|elname
argument_list|,
literal|"%s_%s_%p"
argument_list|,
name|basetype
argument_list|,
name|tname
argument_list|,
name|t
argument_list|)
operator|<
literal|0
operator|||
name|elname
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|generate_template_type
argument_list|(
name|elname
argument_list|,
operator|&
name|dupname
argument_list|,
name|NULL
argument_list|,
name|sename
argument_list|,
name|NULL
argument_list|,
name|t
operator|->
name|subtype
argument_list|,
literal|0
argument_list|,
name|subtype_is_struct
argument_list|,
name|need_offset
argument_list|)
expr_stmt|;
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ %s, %s, asn1_%s }"
argument_list|,
name|type
argument_list|,
name|poffset
argument_list|,
name|dupname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sename
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TChoice
case|:
block|{
name|struct
name|templatehead
name|template
init|=
name|ASN1_TAILQ_HEAD_INITIALIZER
argument_list|(
name|template
argument_list|)
decl_stmt|;
name|struct
name|template
modifier|*
name|q
decl_stmt|;
name|size_t
name|count
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|tname
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|get_code_file
argument_list|()
decl_stmt|;
name|Member
modifier|*
name|m
decl_stmt|;
name|int
name|ellipsis
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|tname
argument_list|,
literal|"asn1_choice_%s_%s%x"
argument_list|,
name|basetype
argument_list|,
name|name
condition|?
name|name
else|:
literal|""
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|(
name|uintptr_t
operator|)
name|t
argument_list|)
operator|<
literal|0
operator|||
name|tname
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|ASN1_TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|t->members
argument_list|,
argument|members
argument_list|)
block|{
specifier|const
name|char
modifier|*
name|dupname
decl_stmt|;
name|char
modifier|*
name|elname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|newbasename
init|=
name|NULL
decl_stmt|;
name|int
name|subtype_is_struct
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|ellipsis
condition|)
block|{
name|ellipsis
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|subtype_is_struct
operator|=
name|is_struct
argument_list|(
name|m
operator|->
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|elname
argument_list|,
literal|"%s_choice_%s"
argument_list|,
name|basetype
argument_list|,
name|m
operator|->
name|gen_name
argument_list|)
operator|<
literal|0
operator|||
name|elname
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtype_is_struct
condition|)
block|{
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|newbasename
argument_list|,
literal|"%s_%s"
argument_list|,
name|basetype
argument_list|,
name|m
operator|->
name|gen_name
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
block|}
else|else
name|newbasename
operator|=
name|strdup
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbasename
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|generate_template_type
argument_list|(
name|elname
argument_list|,
operator|&
name|dupname
argument_list|,
name|NULL
argument_list|,
name|symbol_name
argument_list|(
name|newbasename
argument_list|,
name|m
operator|->
name|type
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|m
operator|->
name|type
argument_list|,
literal|0
argument_list|,
name|subtype_is_struct
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_line
argument_list|(
operator|&
name|template
argument_list|,
literal|"{ %s, offsetof(%s%s, u.%s), asn1_%s }"
argument_list|,
name|m
operator|->
name|label
argument_list|,
name|isstruct
condition|?
literal|"struct "
else|:
literal|""
argument_list|,
name|basetype
argument_list|,
name|m
operator|->
name|gen_name
argument_list|,
name|dupname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newbasename
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ellipsis
condition|)
block|{
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|e
argument_list|,
literal|"offsetof(%s%s, u.asn1_ellipsis)"
argument_list|,
name|isstruct
condition|?
literal|"struct "
else|:
literal|""
argument_list|,
name|basetype
argument_list|)
operator|<
literal|0
operator|||
name|e
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
block|}
name|ASN1_TAILQ_FOREACH
argument_list|(
argument|q
argument_list|,
argument|&template
argument_list|,
argument|members
argument_list|)
block|{
name|count
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"static const struct asn1_template %s[] = {\n"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"/* 0 */ { %s, offsetof(%s%s, element), ((void *)%lu) },\n"
argument_list|,
name|e
condition|?
name|e
else|:
literal|"0"
argument_list|,
name|isstruct
condition|?
literal|"struct "
else|:
literal|""
argument_list|,
name|basetype
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|count
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|ASN1_TAILQ_FOREACH
argument_list|(
argument|q
argument_list|,
argument|&template
argument_list|,
argument|members
argument_list|)
block|{
name|int
name|last
init|=
operator|(
name|ASN1_TAILQ_LAST
argument_list|(
operator|&
name|template
argument_list|,
name|templatehead
argument_list|)
operator|==
name|q
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"/* %lu */ %s%s\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|i
operator|++
argument_list|,
name|q
operator|->
name|line
argument_list|,
name|last
condition|?
literal|""
else|:
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
name|add_line
argument_list|(
name|temp
argument_list|,
literal|"{ A1_OP_CHOICE, %s, %s }"
argument_list|,
name|poffset
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tname
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|poffset
condition|)
name|free
argument_list|(
name|poffset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_extern_stubs
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"static const struct asn1_type_func asn1_extern_%s = {\n"
literal|"\t(asn1_type_encode)encode_%s,\n"
literal|"\t(asn1_type_decode)decode_%s,\n"
literal|"\t(asn1_type_length)length_%s,\n"
literal|"\t(asn1_type_copy)copy_%s,\n"
literal|"\t(asn1_type_release)free_%s,\n"
literal|"\tsizeof(%s)\n"
literal|"};\n"
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gen_template_import
parameter_list|(
specifier|const
name|Symbol
modifier|*
name|s
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|get_code_file
argument_list|()
decl_stmt|;
if|if
condition|(
name|template_flag
operator|==
literal|0
condition|)
return|return;
name|gen_extern_stubs
argument_list|(
name|f
argument_list|,
name|s
operator|->
name|gen_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_template_type
parameter_list|(
specifier|const
name|char
modifier|*
name|varname
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|dupname
parameter_list|,
specifier|const
name|char
modifier|*
name|symname
parameter_list|,
specifier|const
name|char
modifier|*
name|basetype
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|Type
modifier|*
name|type
parameter_list|,
name|int
name|optional
parameter_list|,
name|int
name|isstruct
parameter_list|,
name|int
name|need_offset
parameter_list|)
block|{
name|struct
name|tlist
modifier|*
name|tl
decl_stmt|;
specifier|const
name|char
modifier|*
name|dup
decl_stmt|;
name|int
name|have_ellipsis
init|=
literal|0
decl_stmt|;
name|tl
operator|=
name|tlist_new
argument_list|(
name|varname
argument_list|)
expr_stmt|;
name|template_members
argument_list|(
operator|&
name|tl
operator|->
name|template
argument_list|,
name|basetype
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|optional
argument_list|,
name|isstruct
argument_list|,
name|need_offset
argument_list|)
expr_stmt|;
comment|/* if its a sequence or set type, check if there is a ellipsis */
if|if
condition|(
name|type
operator|->
name|type
operator|==
name|TSequence
operator|||
name|type
operator|->
name|type
operator|==
name|TSet
condition|)
block|{
name|Member
modifier|*
name|m
decl_stmt|;
name|ASN1_TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|type->members
argument_list|,
argument|members
argument_list|)
block|{
if|if
condition|(
name|m
operator|->
name|ellipsis
condition|)
name|have_ellipsis
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ASN1_TAILQ_EMPTY
argument_list|(
operator|&
name|tl
operator|->
name|template
argument_list|)
operator|&&
name|compact_tag
argument_list|(
name|type
argument_list|)
operator|->
name|type
operator|!=
name|TNull
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Tag %s...%s with no content ?"
argument_list|,
name|basetype
argument_list|,
name|name
condition|?
name|name
else|:
literal|""
argument_list|)
expr_stmt|;
name|tlist_header
argument_list|(
name|tl
argument_list|,
literal|"{ 0%s%s, sizeof(%s%s), ((void *)%lu) }"
argument_list|,
operator|(
name|symname
operator|&&
name|preserve_type
argument_list|(
name|symname
argument_list|)
operator|)
condition|?
literal|"|A1_HF_PRESERVE"
else|:
literal|""
argument_list|,
name|have_ellipsis
condition|?
literal|"|A1_HF_ELLIPSIS"
else|:
literal|""
argument_list|,
name|isstruct
condition|?
literal|"struct "
else|:
literal|""
argument_list|,
name|basetype
argument_list|,
name|tlist_count
argument_list|(
name|tl
argument_list|)
argument_list|)
expr_stmt|;
name|dup
operator|=
name|tlist_find_dup
argument_list|(
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dup
argument_list|,
name|tl
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"found dup of ourself"
argument_list|)
expr_stmt|;
operator|*
name|dupname
operator|=
name|dup
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dupname
operator|=
name|tl
operator|->
name|name
expr_stmt|;
name|tlist_print
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tlist_add
argument_list|(
name|tl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|generate_template
parameter_list|(
specifier|const
name|Symbol
modifier|*
name|s
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|get_code_file
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|dupname
decl_stmt|;
if|if
condition|(
name|use_extern
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|gen_extern_stubs
argument_list|(
name|f
argument_list|,
name|s
operator|->
name|gen_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|generate_template_type
argument_list|(
name|s
operator|->
name|gen_name
argument_list|,
operator|&
name|dupname
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s
operator|->
name|gen_name
argument_list|,
name|NULL
argument_list|,
name|s
operator|->
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
literal|"int\n"
literal|"decode_%s(const unsigned char *p, size_t len, %s *data, size_t *size)\n"
literal|"{\n"
literal|"    return _asn1_decode_top(asn1_%s, 0|%s, p, len, data, size);\n"
literal|"}\n"
literal|"\n"
argument_list|,
name|s
operator|->
name|gen_name
argument_list|,
name|s
operator|->
name|gen_name
argument_list|,
name|dupname
argument_list|,
name|support_ber
condition|?
literal|"A1_PF_ALLOW_BER"
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
literal|"int\n"
literal|"encode_%s(unsigned char *p, size_t len, const %s *data, size_t *size)\n"
literal|"{\n"
literal|"    return _asn1_encode(asn1_%s, p, len, data, size);\n"
literal|"}\n"
literal|"\n"
argument_list|,
name|s
operator|->
name|gen_name
argument_list|,
name|s
operator|->
name|gen_name
argument_list|,
name|dupname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
literal|"size_t\n"
literal|"length_%s(const %s *data)\n"
literal|"{\n"
literal|"    return _asn1_length(asn1_%s, data);\n"
literal|"}\n"
literal|"\n"
argument_list|,
name|s
operator|->
name|gen_name
argument_list|,
name|s
operator|->
name|gen_name
argument_list|,
name|dupname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
literal|"void\n"
literal|"free_%s(%s *data)\n"
literal|"{\n"
literal|"    _asn1_free(asn1_%s, data);\n"
literal|"}\n"
literal|"\n"
argument_list|,
name|s
operator|->
name|gen_name
argument_list|,
name|s
operator|->
name|gen_name
argument_list|,
name|dupname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
literal|"int\n"
literal|"copy_%s(const %s *from, %s *to)\n"
literal|"{\n"
literal|"    return _asn1_copy_top(asn1_%s, from, to);\n"
literal|"}\n"
literal|"\n"
argument_list|,
name|s
operator|->
name|gen_name
argument_list|,
name|s
operator|->
name|gen_name
argument_list|,
name|s
operator|->
name|gen_name
argument_list|,
name|dupname
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

