begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2009 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *  * Portions Copyright (c) 2009 Apple Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"hi_locl.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_define
define|#
directive|define
name|MAX_PACKET_SIZE
value|(128 * 1024)
end_define

begin_struct
struct|struct
name|heim_sipc
block|{
name|int
function_decl|(
modifier|*
name|release
function_decl|)
parameter_list|(
name|heim_sipc
name|ctx
parameter_list|)
function_decl|;
name|heim_ipc_callback
name|callback
decl_stmt|;
name|void
modifier|*
name|userctx
decl_stmt|;
name|void
modifier|*
name|mech
decl_stmt|;
block|}
struct|;
end_struct

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_GCD
argument_list|)
end_if

begin_include
include|#
directive|include
file|"heim_ipcServer.h"
end_include

begin_include
include|#
directive|include
file|"heim_ipc_reply.h"
end_include

begin_include
include|#
directive|include
file|"heim_ipc_async.h"
end_include

begin_decl_stmt
specifier|static
name|dispatch_source_t
name|timer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dispatch_queue_t
name|timerq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|timeoutvalue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dispatch_queue_t
name|eventq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dispatch_queue_t
name|workq
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|default_timer_ev
parameter_list|(
name|void
parameter_list|)
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|timer_ev
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|default_timer_ev
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|set_timer
parameter_list|(
name|void
parameter_list|)
block|{
name|dispatch_source_set_timer
argument_list|(
name|timer
argument_list|,
name|dispatch_time
argument_list|(
name|DISPATCH_TIME_NOW
argument_list|,
name|timeoutvalue
operator|*
name|NSEC_PER_SEC
argument_list|)
argument_list|,
name|timeoutvalue
operator|*
name|NSEC_PER_SEC
argument_list|,
literal|1000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_globals
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|dispatch_once_t
name|once
decl_stmt|;
name|dispatch_once
argument_list|(
operator|&
name|once
argument_list|,
lambda|^
block|{
name|timerq
operator|=
name|dispatch_queue_create
argument_list|(
literal|"hiem-sipc-timer-q"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|timer
operator|=
name|dispatch_source_create
argument_list|(
name|DISPATCH_SOURCE_TYPE_TIMER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|timerq
argument_list|)
expr_stmt|;
name|dispatch_source_set_event_handler
argument_list|(
name|timer
argument_list|,
lambda|^
block|{
name|timer_ev
argument_list|()
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|workq
operator|=
name|dispatch_get_global_queue
argument_list|(
name|DISPATCH_QUEUE_PRIORITY_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|eventq
operator|=
name|dispatch_queue_create
argument_list|(
literal|"heim-ipc.event-queue"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|suspend_timer
parameter_list|(
name|void
parameter_list|)
block|{
name|dispatch_suspend
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|restart_timer
parameter_list|(
name|void
parameter_list|)
block|{
name|dispatch_sync
argument_list|(
name|timerq
argument_list|,
lambda|^
block|{
name|set_timer
argument_list|()
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|dispatch_resume
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|mach_service
block|{
name|mach_port_t
name|sport
decl_stmt|;
name|dispatch_source_t
name|source
decl_stmt|;
name|dispatch_queue_t
name|queue
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mach_call_ctx
block|{
name|mach_port_t
name|reply_port
decl_stmt|;
name|heim_icred
name|cred
decl_stmt|;
name|heim_idata
name|req
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|mach_complete_sync
parameter_list|(
name|heim_sipc_call
name|ctx
parameter_list|,
name|int
name|returnvalue
parameter_list|,
name|heim_idata
modifier|*
name|reply
parameter_list|)
block|{
name|struct
name|mach_call_ctx
modifier|*
name|s
init|=
operator|(
expr|struct
name|mach_call_ctx
operator|*
operator|)
name|ctx
decl_stmt|;
name|heim_ipc_message_inband_t
name|replyin
decl_stmt|;
name|mach_msg_type_number_t
name|replyinCnt
decl_stmt|;
name|heim_ipc_message_outband_t
name|replyout
decl_stmt|;
name|mach_msg_type_number_t
name|replyoutCnt
decl_stmt|;
name|kern_return_t
name|kr
decl_stmt|;
if|if
condition|(
name|returnvalue
condition|)
block|{
comment|/* on error, no reply */
name|replyinCnt
operator|=
literal|0
expr_stmt|;
name|replyout
operator|=
literal|0
expr_stmt|;
name|replyoutCnt
operator|=
literal|0
expr_stmt|;
name|kr
operator|=
name|KERN_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reply
operator|->
name|length
operator|<
literal|2048
condition|)
block|{
name|replyinCnt
operator|=
name|reply
operator|->
name|length
expr_stmt|;
name|memcpy
argument_list|(
name|replyin
argument_list|,
name|reply
operator|->
name|data
argument_list|,
name|replyinCnt
argument_list|)
expr_stmt|;
name|replyout
operator|=
literal|0
expr_stmt|;
name|replyoutCnt
operator|=
literal|0
expr_stmt|;
name|kr
operator|=
name|KERN_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|replyinCnt
operator|=
literal|0
expr_stmt|;
name|kr
operator|=
name|vm_read
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|reply
operator|->
name|data
argument_list|,
name|reply
operator|->
name|length
argument_list|,
operator|(
name|vm_address_t
operator|*
operator|)
operator|&
name|replyout
argument_list|,
operator|&
name|replyoutCnt
argument_list|)
expr_stmt|;
block|}
name|mheim_ripc_call_reply
argument_list|(
name|s
operator|->
name|reply_port
argument_list|,
name|returnvalue
argument_list|,
name|replyin
argument_list|,
name|replyinCnt
argument_list|,
name|replyout
argument_list|,
name|replyoutCnt
argument_list|)
expr_stmt|;
name|heim_ipc_free_cred
argument_list|(
name|s
operator|->
name|cred
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
operator|->
name|req
operator|.
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|restart_timer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mach_complete_async
parameter_list|(
name|heim_sipc_call
name|ctx
parameter_list|,
name|int
name|returnvalue
parameter_list|,
name|heim_idata
modifier|*
name|reply
parameter_list|)
block|{
name|struct
name|mach_call_ctx
modifier|*
name|s
init|=
operator|(
expr|struct
name|mach_call_ctx
operator|*
operator|)
name|ctx
decl_stmt|;
name|heim_ipc_message_inband_t
name|replyin
decl_stmt|;
name|mach_msg_type_number_t
name|replyinCnt
decl_stmt|;
name|heim_ipc_message_outband_t
name|replyout
decl_stmt|;
name|mach_msg_type_number_t
name|replyoutCnt
decl_stmt|;
name|kern_return_t
name|kr
decl_stmt|;
if|if
condition|(
name|returnvalue
condition|)
block|{
comment|/* on error, no reply */
name|replyinCnt
operator|=
literal|0
expr_stmt|;
name|replyout
operator|=
literal|0
expr_stmt|;
name|replyoutCnt
operator|=
literal|0
expr_stmt|;
name|kr
operator|=
name|KERN_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reply
operator|->
name|length
operator|<
literal|2048
condition|)
block|{
name|replyinCnt
operator|=
name|reply
operator|->
name|length
expr_stmt|;
name|memcpy
argument_list|(
name|replyin
argument_list|,
name|reply
operator|->
name|data
argument_list|,
name|replyinCnt
argument_list|)
expr_stmt|;
name|replyout
operator|=
literal|0
expr_stmt|;
name|replyoutCnt
operator|=
literal|0
expr_stmt|;
name|kr
operator|=
name|KERN_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|replyinCnt
operator|=
literal|0
expr_stmt|;
name|kr
operator|=
name|vm_read
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|reply
operator|->
name|data
argument_list|,
name|reply
operator|->
name|length
argument_list|,
operator|(
name|vm_address_t
operator|*
operator|)
operator|&
name|replyout
argument_list|,
operator|&
name|replyoutCnt
argument_list|)
expr_stmt|;
block|}
name|kr
operator|=
name|mheim_aipc_acall_reply
argument_list|(
name|s
operator|->
name|reply_port
argument_list|,
name|returnvalue
argument_list|,
name|replyin
argument_list|,
name|replyinCnt
argument_list|,
name|replyout
argument_list|,
name|replyoutCnt
argument_list|)
expr_stmt|;
name|heim_ipc_free_cred
argument_list|(
name|s
operator|->
name|cred
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
operator|->
name|req
operator|.
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|restart_timer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|kern_return_t
name|mheim_do_call
parameter_list|(
name|mach_port_t
name|server_port
parameter_list|,
name|audit_token_t
name|client_creds
parameter_list|,
name|mach_port_t
name|reply_port
parameter_list|,
name|heim_ipc_message_inband_t
name|requestin
parameter_list|,
name|mach_msg_type_number_t
name|requestinCnt
parameter_list|,
name|heim_ipc_message_outband_t
name|requestout
parameter_list|,
name|mach_msg_type_number_t
name|requestoutCnt
parameter_list|,
name|int
modifier|*
name|returnvalue
parameter_list|,
name|heim_ipc_message_inband_t
name|replyin
parameter_list|,
name|mach_msg_type_number_t
modifier|*
name|replyinCnt
parameter_list|,
name|heim_ipc_message_outband_t
modifier|*
name|replyout
parameter_list|,
name|mach_msg_type_number_t
modifier|*
name|replyoutCnt
parameter_list|)
block|{
name|heim_sipc
name|ctx
init|=
name|dispatch_get_context
argument_list|(
name|dispatch_get_current_queue
argument_list|()
argument_list|)
decl_stmt|;
name|struct
name|mach_call_ctx
modifier|*
name|s
decl_stmt|;
name|kern_return_t
name|kr
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|au_asid_t
name|session
decl_stmt|;
operator|*
name|replyout
operator|=
name|NULL
expr_stmt|;
operator|*
name|replyoutCnt
operator|=
literal|0
expr_stmt|;
operator|*
name|replyinCnt
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|KERN_MEMORY_FAILURE
return|;
comment|/* XXX */
name|s
operator|->
name|reply_port
operator|=
name|reply_port
expr_stmt|;
name|audit_token_to_au32
argument_list|(
name|client_creds
argument_list|,
name|NULL
argument_list|,
operator|&
name|uid
argument_list|,
operator|&
name|gid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|pid
argument_list|,
operator|&
name|session
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|kr
operator|=
name|_heim_ipc_create_cred
argument_list|(
name|uid
argument_list|,
name|gid
argument_list|,
name|pid
argument_list|,
name|session
argument_list|,
operator|&
name|s
operator|->
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|kr
return|;
block|}
name|suspend_timer
argument_list|()
expr_stmt|;
if|if
condition|(
name|requestinCnt
condition|)
block|{
name|s
operator|->
name|req
operator|.
name|data
operator|=
name|malloc
argument_list|(
name|requestinCnt
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|req
operator|.
name|data
argument_list|,
name|requestin
argument_list|,
name|requestinCnt
argument_list|)
expr_stmt|;
name|s
operator|->
name|req
operator|.
name|length
operator|=
name|requestinCnt
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|req
operator|.
name|data
operator|=
name|malloc
argument_list|(
name|requestoutCnt
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|req
operator|.
name|data
argument_list|,
name|requestout
argument_list|,
name|requestoutCnt
argument_list|)
expr_stmt|;
name|s
operator|->
name|req
operator|.
name|length
operator|=
name|requestoutCnt
expr_stmt|;
block|}
name|dispatch_async
argument_list|(
name|workq
argument_list|,
lambda|^
block|{
call|(
name|ctx
operator|->
name|callback
call|)
argument_list|(
name|ctx
operator|->
name|userctx
argument_list|,
operator|&
name|s
operator|->
name|req
argument_list|,
name|s
operator|->
name|cred
argument_list|,
name|mach_complete_sync
argument_list|,
operator|(
name|heim_sipc_call
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
return|return
name|MIG_NO_REPLY
return|;
block|}
end_function

begin_function
name|kern_return_t
name|mheim_do_call_request
parameter_list|(
name|mach_port_t
name|server_port
parameter_list|,
name|audit_token_t
name|client_creds
parameter_list|,
name|mach_port_t
name|reply_port
parameter_list|,
name|heim_ipc_message_inband_t
name|requestin
parameter_list|,
name|mach_msg_type_number_t
name|requestinCnt
parameter_list|,
name|heim_ipc_message_outband_t
name|requestout
parameter_list|,
name|mach_msg_type_number_t
name|requestoutCnt
parameter_list|)
block|{
name|heim_sipc
name|ctx
init|=
name|dispatch_get_context
argument_list|(
name|dispatch_get_current_queue
argument_list|()
argument_list|)
decl_stmt|;
name|struct
name|mach_call_ctx
modifier|*
name|s
decl_stmt|;
name|kern_return_t
name|kr
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|au_asid_t
name|session
decl_stmt|;
name|s
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|KERN_MEMORY_FAILURE
return|;
comment|/* XXX */
name|s
operator|->
name|reply_port
operator|=
name|reply_port
expr_stmt|;
name|audit_token_to_au32
argument_list|(
name|client_creds
argument_list|,
name|NULL
argument_list|,
operator|&
name|uid
argument_list|,
operator|&
name|gid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|pid
argument_list|,
operator|&
name|session
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|kr
operator|=
name|_heim_ipc_create_cred
argument_list|(
name|uid
argument_list|,
name|gid
argument_list|,
name|pid
argument_list|,
name|session
argument_list|,
operator|&
name|s
operator|->
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|kr
return|;
block|}
name|suspend_timer
argument_list|()
expr_stmt|;
if|if
condition|(
name|requestinCnt
condition|)
block|{
name|s
operator|->
name|req
operator|.
name|data
operator|=
name|malloc
argument_list|(
name|requestinCnt
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|req
operator|.
name|data
argument_list|,
name|requestin
argument_list|,
name|requestinCnt
argument_list|)
expr_stmt|;
name|s
operator|->
name|req
operator|.
name|length
operator|=
name|requestinCnt
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|req
operator|.
name|data
operator|=
name|malloc
argument_list|(
name|requestoutCnt
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|req
operator|.
name|data
argument_list|,
name|requestout
argument_list|,
name|requestoutCnt
argument_list|)
expr_stmt|;
name|s
operator|->
name|req
operator|.
name|length
operator|=
name|requestoutCnt
expr_stmt|;
block|}
name|dispatch_async
argument_list|(
name|workq
argument_list|,
lambda|^
block|{
call|(
name|ctx
operator|->
name|callback
call|)
argument_list|(
name|ctx
operator|->
name|userctx
argument_list|,
operator|&
name|s
operator|->
name|req
argument_list|,
name|s
operator|->
name|cred
argument_list|,
name|mach_complete_async
argument_list|,
operator|(
name|heim_sipc_call
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
return|return
name|KERN_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mach_init
parameter_list|(
specifier|const
name|char
modifier|*
name|service
parameter_list|,
name|mach_port_t
name|sport
parameter_list|,
name|heim_sipc
name|ctx
parameter_list|)
block|{
name|struct
name|mach_service
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|init_globals
argument_list|()
expr_stmt|;
name|s
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|asprintf
argument_list|(
operator|&
name|name
argument_list|,
literal|"heim-ipc-mach-%s"
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|s
operator|->
name|queue
operator|=
name|dispatch_queue_create
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|s
operator|->
name|sport
operator|=
name|sport
expr_stmt|;
name|s
operator|->
name|source
operator|=
name|dispatch_source_create
argument_list|(
name|DISPATCH_SOURCE_TYPE_MACH_RECV
argument_list|,
name|s
operator|->
name|sport
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|source
operator|==
name|NULL
condition|)
block|{
name|dispatch_release
argument_list|(
name|s
operator|->
name|queue
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|ctx
operator|->
name|mech
operator|=
name|s
expr_stmt|;
name|dispatch_set_context
argument_list|(
name|s
operator|->
name|queue
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|dispatch_set_context
argument_list|(
name|s
operator|->
name|source
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|dispatch_source_set_event_handler
argument_list|(
name|s
operator|->
name|source
argument_list|,
lambda|^
block|{
name|dispatch_mig_server
argument_list|(
name|s
operator|->
name|source
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|__RequestUnion__mheim_do_mheim_ipc_subsystem
argument_list|)
argument_list|,
name|mheim_ipc_server
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|dispatch_source_set_cancel_handler
argument_list|(
name|s
operator|->
name|source
argument_list|,
lambda|^
block|{
name|heim_sipc
name|ctx
init|=
name|dispatch_get_context
argument_list|(
name|dispatch_get_current_queue
argument_list|()
argument_list|)
decl_stmt|;
name|struct
name|mach_service
modifier|*
name|st
init|=
name|ctx
operator|->
name|mech
decl_stmt|;
name|mach_port_mod_refs
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|st
operator|->
name|sport
argument_list|,
name|MACH_PORT_RIGHT_RECEIVE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dispatch_release
argument_list|(
name|st
operator|->
name|queue
argument_list|)
expr_stmt|;
name|dispatch_release
argument_list|(
name|st
operator|->
name|source
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|dispatch_resume
argument_list|(
name|s
operator|->
name|source
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mach_release
parameter_list|(
name|heim_sipc
name|ctx
parameter_list|)
block|{
name|struct
name|mach_service
modifier|*
name|s
init|=
name|ctx
operator|->
name|mech
decl_stmt|;
name|dispatch_source_cancel
argument_list|(
name|s
operator|->
name|source
argument_list|)
expr_stmt|;
name|dispatch_release
argument_list|(
name|s
operator|->
name|source
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|mach_port_t
name|mach_checkin_or_register
parameter_list|(
specifier|const
name|char
modifier|*
name|service
parameter_list|)
block|{
name|mach_port_t
name|mp
decl_stmt|;
name|kern_return_t
name|kr
decl_stmt|;
name|kr
operator|=
name|bootstrap_check_in
argument_list|(
name|bootstrap_port
argument_list|,
name|service
argument_list|,
operator|&
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
operator|==
name|KERN_SUCCESS
condition|)
return|return
name|mp
return|;
if|#
directive|if
name|__MAC_OS_X_VERSION_MIN_REQUIRED
operator|<=
literal|1050
comment|/* Pre SnowLeopard version */
name|kr
operator|=
name|mach_port_allocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|MACH_PORT_RIGHT_RECEIVE
argument_list|,
operator|&
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
operator|!=
name|KERN_SUCCESS
condition|)
return|return
name|MACH_PORT_NULL
return|;
name|kr
operator|=
name|mach_port_insert_right
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|mp
argument_list|,
name|mp
argument_list|,
name|MACH_MSG_TYPE_MAKE_SEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|mach_port_destroy
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|MACH_PORT_NULL
return|;
block|}
name|kr
operator|=
name|bootstrap_register
argument_list|(
name|bootstrap_port
argument_list|,
name|rk_UNCONST
argument_list|(
name|service
argument_list|)
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|mach_port_destroy
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|MACH_PORT_NULL
return|;
block|}
return|return
name|mp
return|;
else|#
directive|else
return|return
name|MACH_PORT_NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __APPLE__&& HAVE_GCD */
end_comment

begin_function
name|int
name|heim_sipc_launchd_mach_init
parameter_list|(
specifier|const
name|char
modifier|*
name|service
parameter_list|,
name|heim_ipc_callback
name|callback
parameter_list|,
name|void
modifier|*
name|user
parameter_list|,
name|heim_sipc
modifier|*
name|ctx
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_GCD
argument_list|)
name|mach_port_t
name|sport
init|=
name|MACH_PORT_NULL
decl_stmt|;
name|heim_sipc
name|c
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|*
name|ctx
operator|=
name|NULL
expr_stmt|;
name|sport
operator|=
name|mach_checkin_or_register
argument_list|(
name|service
argument_list|)
expr_stmt|;
if|if
condition|(
name|sport
operator|==
name|MACH_PORT_NULL
condition|)
block|{
name|ret
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|c
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|c
operator|->
name|release
operator|=
name|mach_release
expr_stmt|;
name|c
operator|->
name|userctx
operator|=
name|user
expr_stmt|;
name|c
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|ret
operator|=
name|mach_init
argument_list|(
name|service
argument_list|,
name|sport
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|error
goto|;
operator|*
name|ctx
operator|=
name|c
expr_stmt|;
return|return
literal|0
return|;
name|error
label|:
if|if
condition|(
name|c
condition|)
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|sport
operator|!=
name|MACH_PORT_NULL
condition|)
name|mach_port_mod_refs
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|sport
argument_list|,
name|MACH_PORT_RIGHT_RECEIVE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
else|#
directive|else
comment|/* !(__APPLE__&& HAVE_GCD) */
operator|*
name|ctx
operator|=
name|NULL
expr_stmt|;
return|return
name|EINVAL
return|;
endif|#
directive|endif
comment|/* __APPLE__&& HAVE_GCD */
block|}
end_function

begin_struct
struct|struct
name|client
block|{
name|int
name|fd
decl_stmt|;
name|heim_ipc_callback
name|callback
decl_stmt|;
name|void
modifier|*
name|userctx
decl_stmt|;
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|LISTEN_SOCKET
value|1
define|#
directive|define
name|WAITING_READ
value|2
define|#
directive|define
name|WAITING_WRITE
value|4
define|#
directive|define
name|WAITING_CLOSE
value|8
define|#
directive|define
name|HTTP_REPLY
value|16
define|#
directive|define
name|INHERIT_MASK
value|0xffff0000
define|#
directive|define
name|INCLUDE_ERROR_CODE
value|(1<< 16)
define|#
directive|define
name|ALLOW_HTTP
value|(1<<17)
define|#
directive|define
name|UNIX_SOCKET
value|(1<<18)
name|unsigned
name|calls
decl_stmt|;
name|size_t
name|ptr
decl_stmt|,
name|len
decl_stmt|;
name|uint8_t
modifier|*
name|inmsg
decl_stmt|;
name|size_t
name|olen
decl_stmt|;
name|uint8_t
modifier|*
name|outmsg
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GCD
name|dispatch_source_t
name|in
decl_stmt|;
name|dispatch_source_t
name|out
decl_stmt|;
endif|#
directive|endif
struct|struct
block|{
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
block|}
name|unixrights
struct|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GCD
end_ifndef

begin_decl_stmt
specifier|static
name|unsigned
name|num_clients
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|client
modifier|*
modifier|*
name|clients
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|handle_read
parameter_list|(
name|struct
name|client
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_write
parameter_list|(
name|struct
name|client
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|maybe_close
parameter_list|(
name|struct
name|client
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Update peer credentials from socket.  *  * SCM_CREDS can only be updated the first time there is read data to  * read from the filedescriptor, so if we read do it before this  * point, the cred data might not be is not there yet.  */
end_comment

begin_function
specifier|static
name|int
name|update_client_creds
parameter_list|(
name|struct
name|client
modifier|*
name|c
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GETPEERUCRED
comment|/* Solaris 10 */
block|{
name|ucred_t
modifier|*
name|peercred
decl_stmt|;
if|if
condition|(
name|getpeerucred
argument_list|(
name|c
operator|->
name|fd
argument_list|,
operator|&
name|peercred
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|c
operator|->
name|unixrights
operator|.
name|uid
operator|=
name|ucred_geteuid
argument_list|(
name|peercred
argument_list|)
expr_stmt|;
name|c
operator|->
name|unixrights
operator|.
name|gid
operator|=
name|ucred_getegid
argument_list|(
name|peercred
argument_list|)
expr_stmt|;
name|c
operator|->
name|unixrights
operator|.
name|pid
operator|=
literal|0
expr_stmt|;
name|ucred_free
argument_list|(
name|peercred
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_GETPEEREID
comment|/* FreeBSD, OpenBSD */
block|{
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
if|if
condition|(
name|getpeereid
argument_list|(
name|c
operator|->
name|fd
argument_list|,
operator|&
name|uid
argument_list|,
operator|&
name|gid
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|->
name|unixrights
operator|.
name|uid
operator|=
name|uid
expr_stmt|;
name|c
operator|->
name|unixrights
operator|.
name|gid
operator|=
name|gid
expr_stmt|;
name|c
operator|->
name|unixrights
operator|.
name|pid
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SO_PEERCRED
comment|/* Linux */
block|{
name|struct
name|ucred
name|pc
decl_stmt|;
name|socklen_t
name|pclen
init|=
sizeof|sizeof
argument_list|(
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|c
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_PEERCRED
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|pc
argument_list|,
operator|&
name|pclen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|->
name|unixrights
operator|.
name|uid
operator|=
name|pc
operator|.
name|uid
expr_stmt|;
name|c
operator|->
name|unixrights
operator|.
name|gid
operator|=
name|pc
operator|.
name|gid
expr_stmt|;
name|c
operator|->
name|unixrights
operator|.
name|pid
operator|=
name|pc
operator|.
name|pid
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|LOCAL_PEERCRED
argument_list|)
operator|&&
name|defined
argument_list|(
name|XUCRED_VERSION
argument_list|)
block|{
name|struct
name|xucred
name|peercred
decl_stmt|;
name|socklen_t
name|peercredlen
init|=
sizeof|sizeof
argument_list|(
name|peercred
argument_list|)
decl_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|c
operator|->
name|fd
argument_list|,
name|LOCAL_PEERCRED
argument_list|,
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|peercred
argument_list|,
operator|&
name|peercredlen
argument_list|)
operator|==
literal|0
operator|&&
name|peercred
operator|.
name|cr_version
operator|==
name|XUCRED_VERSION
condition|)
block|{
name|c
operator|->
name|unixrights
operator|.
name|uid
operator|=
name|peercred
operator|.
name|cr_uid
expr_stmt|;
name|c
operator|->
name|unixrights
operator|.
name|gid
operator|=
name|peercred
operator|.
name|cr_gid
expr_stmt|;
name|c
operator|->
name|unixrights
operator|.
name|pid
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SOCKCREDSIZE
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCM_CREDS
argument_list|)
comment|/* NetBSD */
if|if
condition|(
name|c
operator|->
name|unixrights
operator|.
name|uid
operator|==
operator|(
name|uid_t
operator|)
operator|-
literal|1
condition|)
block|{
name|struct
name|msghdr
name|msg
decl_stmt|;
name|socklen_t
name|crmsgsize
decl_stmt|;
name|void
modifier|*
name|crmsg
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cmp
decl_stmt|;
name|struct
name|sockcred
modifier|*
name|sc
decl_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|crmsgsize
operator|=
name|CMSG_SPACE
argument_list|(
name|SOCKCREDSIZE
argument_list|(
name|CMGROUP_MAX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|crmsgsize
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|crmsg
operator|=
name|malloc
argument_list|(
name|crmsgsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|crmsg
operator|==
name|NULL
condition|)
goto|goto
name|failed_scm_creds
goto|;
name|memset
argument_list|(
name|crmsg
argument_list|,
literal|0
argument_list|,
name|crmsgsize
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
name|crmsg
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
name|crmsgsize
expr_stmt|;
if|if
condition|(
name|recvmsg
argument_list|(
name|c
operator|->
name|fd
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|crmsg
argument_list|)
expr_stmt|;
goto|goto
name|failed_scm_creds
goto|;
block|}
if|if
condition|(
name|msg
operator|.
name|msg_controllen
operator|==
literal|0
operator|||
operator|(
name|msg
operator|.
name|msg_flags
operator|&
name|MSG_CTRUNC
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|crmsg
argument_list|)
expr_stmt|;
goto|goto
name|failed_scm_creds
goto|;
block|}
name|cmp
operator|=
name|CMSG_FIRSTHDR
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|->
name|cmsg_level
operator|!=
name|SOL_SOCKET
operator|||
name|cmp
operator|->
name|cmsg_type
operator|!=
name|SCM_CREDS
condition|)
block|{
name|free
argument_list|(
name|crmsg
argument_list|)
expr_stmt|;
goto|goto
name|failed_scm_creds
goto|;
block|}
name|sc
operator|=
operator|(
expr|struct
name|sockcred
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmp
argument_list|)
expr_stmt|;
name|c
operator|->
name|unixrights
operator|.
name|uid
operator|=
name|sc
operator|->
name|sc_euid
expr_stmt|;
name|c
operator|->
name|unixrights
operator|.
name|gid
operator|=
name|sc
operator|->
name|sc_egid
expr_stmt|;
name|c
operator|->
name|unixrights
operator|.
name|pid
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|crmsg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* we already got the cred, just return it */
return|return
literal|1
return|;
block|}
name|failed_scm_creds
label|:
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|client
modifier|*
name|add_new_socket
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|flags
parameter_list|,
name|heim_ipc_callback
name|callback
parameter_list|,
name|void
modifier|*
name|userctx
parameter_list|)
block|{
name|struct
name|client
modifier|*
name|c
decl_stmt|;
name|int
name|fileflags
decl_stmt|;
name|c
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|flags
operator|&
name|LISTEN_SOCKET
condition|)
block|{
name|c
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
block|}
else|else
block|{
name|c
operator|->
name|fd
operator|=
name|accept
argument_list|(
name|fd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|c
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|c
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|c
operator|->
name|userctx
operator|=
name|userctx
expr_stmt|;
name|fileflags
operator|=
name|fcntl
argument_list|(
name|c
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|c
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|fileflags
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GCD
name|init_globals
argument_list|()
expr_stmt|;
name|c
operator|->
name|in
operator|=
name|dispatch_source_create
argument_list|(
name|DISPATCH_SOURCE_TYPE_READ
argument_list|,
name|c
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|eventq
argument_list|)
expr_stmt|;
name|c
operator|->
name|out
operator|=
name|dispatch_source_create
argument_list|(
name|DISPATCH_SOURCE_TYPE_WRITE
argument_list|,
name|c
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|eventq
argument_list|)
expr_stmt|;
name|dispatch_source_set_event_handler
argument_list|(
name|c
operator|->
name|in
argument_list|,
lambda|^
block|{
name|int
name|rw
init|=
operator|(
name|c
operator|->
name|flags
operator|&
name|WAITING_WRITE
operator|)
decl_stmt|;
name|handle_read
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
literal|0
operator|&&
operator|(
name|c
operator|->
name|flags
operator|&
name|WAITING_WRITE
operator|)
condition|)
name|dispatch_resume
argument_list|(
name|c
operator|->
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|WAITING_READ
operator|)
operator|==
literal|0
condition|)
name|dispatch_suspend
argument_list|(
name|c
operator|->
name|in
argument_list|)
expr_stmt|;
name|maybe_close
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|dispatch_source_set_event_handler
argument_list|(
name|c
operator|->
name|out
argument_list|,
lambda|^
block|{
name|handle_write
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|WAITING_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|dispatch_suspend
argument_list|(
name|c
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
name|maybe_close
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|dispatch_resume
argument_list|(
name|c
operator|->
name|in
argument_list|)
expr_stmt|;
else|#
directive|else
name|clients
operator|=
name|erealloc
argument_list|(
name|clients
argument_list|,
sizeof|sizeof
argument_list|(
name|clients
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|num_clients
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|clients
index|[
name|num_clients
index|]
operator|=
name|c
expr_stmt|;
name|num_clients
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|maybe_close
parameter_list|(
name|struct
name|client
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|calls
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
operator|(
name|WAITING_READ
operator||
name|WAITING_WRITE
operator|)
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE_GCD
name|dispatch_source_cancel
argument_list|(
name|c
operator|->
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|WAITING_READ
operator|)
operator|==
literal|0
condition|)
name|dispatch_resume
argument_list|(
name|c
operator|->
name|in
argument_list|)
expr_stmt|;
name|dispatch_release
argument_list|(
name|c
operator|->
name|in
argument_list|)
expr_stmt|;
name|dispatch_source_cancel
argument_list|(
name|c
operator|->
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|WAITING_WRITE
operator|)
operator|==
literal|0
condition|)
name|dispatch_resume
argument_list|(
name|c
operator|->
name|out
argument_list|)
expr_stmt|;
name|dispatch_release
argument_list|(
name|c
operator|->
name|out
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|(
name|c
operator|->
name|fd
argument_list|)
expr_stmt|;
comment|/* ref count fd close */
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_struct
struct|struct
name|socket_call
block|{
name|heim_idata
name|in
decl_stmt|;
name|struct
name|client
modifier|*
name|c
decl_stmt|;
name|heim_icred
name|cred
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|output_data
parameter_list|(
name|struct
name|client
modifier|*
name|c
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|olen
operator|+
name|len
operator|<
name|c
operator|->
name|olen
condition|)
name|abort
argument_list|()
expr_stmt|;
name|c
operator|->
name|outmsg
operator|=
name|erealloc
argument_list|(
name|c
operator|->
name|outmsg
argument_list|,
name|c
operator|->
name|olen
operator|+
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|c
operator|->
name|outmsg
index|[
name|c
operator|->
name|olen
index|]
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|c
operator|->
name|olen
operator|+=
name|len
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|WAITING_WRITE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|socket_complete
parameter_list|(
name|heim_sipc_call
name|ctx
parameter_list|,
name|int
name|returnvalue
parameter_list|,
name|heim_idata
modifier|*
name|reply
parameter_list|)
block|{
name|struct
name|socket_call
modifier|*
name|sc
init|=
operator|(
expr|struct
name|socket_call
operator|*
operator|)
name|ctx
decl_stmt|;
name|struct
name|client
modifier|*
name|c
init|=
name|sc
operator|->
name|c
decl_stmt|;
comment|/* double complete ? */
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|WAITING_CLOSE
operator|)
operator|==
literal|0
condition|)
block|{
name|uint32_t
name|u32
decl_stmt|;
comment|/* length */
name|u32
operator|=
name|htonl
argument_list|(
name|reply
operator|->
name|length
argument_list|)
expr_stmt|;
name|output_data
argument_list|(
name|c
argument_list|,
operator|&
name|u32
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* return value */
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|INCLUDE_ERROR_CODE
condition|)
block|{
name|u32
operator|=
name|htonl
argument_list|(
name|returnvalue
argument_list|)
expr_stmt|;
name|output_data
argument_list|(
name|c
argument_list|,
operator|&
name|u32
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* data */
name|output_data
argument_list|(
name|c
argument_list|,
name|reply
operator|->
name|data
argument_list|,
name|reply
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* if HTTP, close connection */
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|HTTP_REPLY
condition|)
block|{
name|c
operator|->
name|flags
operator||=
name|WAITING_CLOSE
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|WAITING_READ
expr_stmt|;
block|}
block|}
name|c
operator|->
name|calls
operator|--
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cred
condition|)
name|heim_ipc_free_cred
argument_list|(
name|sc
operator|->
name|cred
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|in
operator|.
name|data
argument_list|)
expr_stmt|;
name|sc
operator|->
name|c
operator|=
name|NULL
expr_stmt|;
comment|/* so we can catch double complete */
name|free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|maybe_close
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* remove HTTP %-quoting from buf */
end_comment

begin_function
specifier|static
name|int
name|de_http
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|q
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
init|;
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
operator|&&
name|isxdigit
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isxdigit
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|x
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
literal|1
argument_list|,
literal|"%2x"
argument_list|,
operator|&
name|x
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|q
operator|=
name|x
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|socket_call
modifier|*
name|handle_http_tcp
parameter_list|(
name|struct
name|client
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|socket_call
modifier|*
name|cs
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|char
modifier|*
name|proto
decl_stmt|;
name|int
name|len
decl_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|c
operator|->
name|inmsg
expr_stmt|;
name|p
operator|=
name|strstr
argument_list|(
name|s
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
name|t
operator|=
name|strtok_r
argument_list|(
name|s
argument_list|,
literal|" \t"
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|t
operator|=
name|strtok_r
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|data
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'/'
condition|)
name|t
operator|++
expr_stmt|;
if|if
condition|(
name|de_http
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|proto
operator|=
name|strtok_r
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|len
operator|=
name|base64_decode
argument_list|(
name|t
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
literal|" 404 Not found\r\n"
literal|"Server: Heimdal/"
name|VERSION
literal|"\r\n"
literal|"Cache-Control: no-cache\r\n"
literal|"Pragma: no-cache\r\n"
literal|"Content-type: text/html\r\n"
literal|"Content-transfer-encoding: 8bit\r\n\r\n"
literal|"<TITLE>404 Not found</TITLE>\r\n"
literal|"<H1>404 Not found</H1>\r\n"
literal|"That page doesn't exist, maybe you are looking for "
literal|"<A HREF=\"http://www.h5l.org/\">Heimdal</A>?\r\n"
decl_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|output_data
argument_list|(
name|c
argument_list|,
name|proto
argument_list|,
name|strlen
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|output_data
argument_list|(
name|c
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cs
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cs
argument_list|)
argument_list|)
expr_stmt|;
name|cs
operator|->
name|c
operator|=
name|c
expr_stmt|;
name|cs
operator|->
name|in
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|cs
operator|->
name|in
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|c
operator|->
name|ptr
operator|=
literal|0
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
literal|" 200 OK\r\n"
literal|"Server: Heimdal/"
name|VERSION
literal|"\r\n"
literal|"Cache-Control: no-cache\r\n"
literal|"Pragma: no-cache\r\n"
literal|"Content-type: application/octet-stream\r\n"
literal|"Content-transfer-encoding: binary\r\n\r\n"
decl_stmt|;
name|output_data
argument_list|(
name|c
argument_list|,
name|proto
argument_list|,
name|strlen
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|output_data
argument_list|(
name|c
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cs
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_read
parameter_list|(
name|struct
name|client
modifier|*
name|c
parameter_list|)
block|{
name|ssize_t
name|len
decl_stmt|;
name|uint32_t
name|dlen
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|LISTEN_SOCKET
condition|)
block|{
name|add_new_socket
argument_list|(
name|c
operator|->
name|fd
argument_list|,
name|WAITING_READ
operator||
operator|(
name|c
operator|->
name|flags
operator|&
name|INHERIT_MASK
operator|)
argument_list|,
name|c
operator|->
name|callback
argument_list|,
name|c
operator|->
name|userctx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|->
name|ptr
operator|-
name|c
operator|->
name|len
operator|<
literal|1024
condition|)
block|{
name|c
operator|->
name|inmsg
operator|=
name|erealloc
argument_list|(
name|c
operator|->
name|inmsg
argument_list|,
name|c
operator|->
name|len
operator|+
literal|1024
argument_list|)
expr_stmt|;
name|c
operator|->
name|len
operator|+=
literal|1024
expr_stmt|;
block|}
name|len
operator|=
name|read
argument_list|(
name|c
operator|->
name|fd
argument_list|,
name|c
operator|->
name|inmsg
operator|+
name|c
operator|->
name|ptr
argument_list|,
name|c
operator|->
name|len
operator|-
name|c
operator|->
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|c
operator|->
name|flags
operator||=
name|WAITING_CLOSE
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|WAITING_READ
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|ptr
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ptr
operator|>
name|c
operator|->
name|len
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|->
name|ptr
operator|>=
sizeof|sizeof
argument_list|(
name|dlen
argument_list|)
condition|)
block|{
name|struct
name|socket_call
modifier|*
name|cs
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|ALLOW_HTTP
operator|)
operator|&&
name|c
operator|->
name|ptr
operator|>=
literal|4
operator|&&
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|c
operator|->
name|inmsg
argument_list|,
literal|"GET "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|c
operator|->
name|inmsg
operator|+
name|c
operator|->
name|ptr
operator|-
literal|4
argument_list|,
literal|"\r\n\r\n"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* remove the trailing \r\n\r\n so the string is NUL terminated */
name|c
operator|->
name|inmsg
index|[
name|c
operator|->
name|ptr
operator|-
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|HTTP_REPLY
expr_stmt|;
name|cs
operator|=
name|handle_http_tcp
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|==
name|NULL
condition|)
block|{
name|c
operator|->
name|flags
operator||=
name|WAITING_CLOSE
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|WAITING_READ
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|dlen
argument_list|,
name|c
operator|->
name|inmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|dlen
argument_list|)
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|ntohl
argument_list|(
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlen
operator|>
name|MAX_PACKET_SIZE
condition|)
block|{
name|c
operator|->
name|flags
operator||=
name|WAITING_CLOSE
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|WAITING_READ
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dlen
operator|>
name|c
operator|->
name|ptr
operator|-
sizeof|sizeof
argument_list|(
name|dlen
argument_list|)
condition|)
block|{
break|break;
block|}
name|cs
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cs
argument_list|)
argument_list|)
expr_stmt|;
name|cs
operator|->
name|c
operator|=
name|c
expr_stmt|;
name|cs
operator|->
name|in
operator|.
name|data
operator|=
name|emalloc
argument_list|(
name|dlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cs
operator|->
name|in
operator|.
name|data
argument_list|,
name|c
operator|->
name|inmsg
operator|+
sizeof|sizeof
argument_list|(
name|dlen
argument_list|)
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|cs
operator|->
name|in
operator|.
name|length
operator|=
name|dlen
expr_stmt|;
name|c
operator|->
name|ptr
operator|-=
sizeof|sizeof
argument_list|(
name|dlen
argument_list|)
operator|+
name|dlen
expr_stmt|;
name|memmove
argument_list|(
name|c
operator|->
name|inmsg
argument_list|,
name|c
operator|->
name|inmsg
operator|+
sizeof|sizeof
argument_list|(
name|dlen
argument_list|)
operator|+
name|dlen
argument_list|,
name|c
operator|->
name|ptr
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|calls
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|UNIX_SOCKET
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|update_client_creds
argument_list|(
name|c
argument_list|)
condition|)
name|_heim_ipc_create_cred
argument_list|(
name|c
operator|->
name|unixrights
operator|.
name|uid
argument_list|,
name|c
operator|->
name|unixrights
operator|.
name|gid
argument_list|,
name|c
operator|->
name|unixrights
operator|.
name|pid
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|cs
operator|->
name|cred
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|callback
argument_list|(
name|c
operator|->
name|userctx
argument_list|,
operator|&
name|cs
operator|->
name|in
argument_list|,
name|cs
operator|->
name|cred
argument_list|,
name|socket_complete
argument_list|,
operator|(
name|heim_sipc_call
operator|)
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|handle_write
parameter_list|(
name|struct
name|client
modifier|*
name|c
parameter_list|)
block|{
name|ssize_t
name|len
decl_stmt|;
name|len
operator|=
name|write
argument_list|(
name|c
operator|->
name|fd
argument_list|,
name|c
operator|->
name|outmsg
argument_list|,
name|c
operator|->
name|olen
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|c
operator|->
name|flags
operator||=
name|WAITING_CLOSE
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
operator|(
name|WAITING_WRITE
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|olen
operator|!=
operator|(
name|size_t
operator|)
name|len
condition|)
block|{
name|memmove
argument_list|(
operator|&
name|c
operator|->
name|outmsg
index|[
literal|0
index|]
argument_list|,
operator|&
name|c
operator|->
name|outmsg
index|[
name|len
index|]
argument_list|,
name|c
operator|->
name|olen
operator|-
name|len
argument_list|)
expr_stmt|;
name|c
operator|->
name|olen
operator|-=
name|len
expr_stmt|;
block|}
else|else
block|{
name|c
operator|->
name|olen
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|outmsg
argument_list|)
expr_stmt|;
name|c
operator|->
name|outmsg
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
operator|(
name|WAITING_WRITE
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GCD
end_ifndef

begin_function
specifier|static
name|void
name|process_loop
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pollfd
modifier|*
name|fds
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|unsigned
name|num_fds
decl_stmt|;
while|while
condition|(
name|num_clients
operator|>
literal|0
condition|)
block|{
name|fds
operator|=
name|malloc
argument_list|(
name|num_clients
operator|*
sizeof|sizeof
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|num_fds
operator|=
name|num_clients
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_fds
condition|;
name|n
operator|++
control|)
block|{
name|fds
index|[
name|n
index|]
operator|.
name|fd
operator|=
name|clients
index|[
name|n
index|]
operator|->
name|fd
expr_stmt|;
name|fds
index|[
name|n
index|]
operator|.
name|events
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clients
index|[
name|n
index|]
operator|->
name|flags
operator|&
name|WAITING_READ
condition|)
name|fds
index|[
name|n
index|]
operator|.
name|events
operator||=
name|POLLIN
expr_stmt|;
if|if
condition|(
name|clients
index|[
name|n
index|]
operator|->
name|flags
operator|&
name|WAITING_WRITE
condition|)
name|fds
index|[
name|n
index|]
operator|.
name|events
operator||=
name|POLLOUT
expr_stmt|;
name|fds
index|[
name|n
index|]
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
block|}
name|poll
argument_list|(
name|fds
argument_list|,
name|num_fds
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_fds
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|clients
index|[
name|n
index|]
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|fds
index|[
name|n
index|]
operator|.
name|revents
operator|&
name|POLLERR
condition|)
block|{
name|clients
index|[
name|n
index|]
operator|->
name|flags
operator||=
name|WAITING_CLOSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fds
index|[
name|n
index|]
operator|.
name|revents
operator|&
name|POLLIN
condition|)
name|handle_read
argument_list|(
name|clients
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds
index|[
name|n
index|]
operator|.
name|revents
operator|&
name|POLLOUT
condition|)
name|handle_write
argument_list|(
name|clients
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|num_clients
condition|)
block|{
name|struct
name|client
modifier|*
name|c
init|=
name|clients
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|maybe_close
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
name|num_clients
operator|-
literal|1
condition|)
name|clients
index|[
name|n
index|]
operator|=
name|clients
index|[
name|num_clients
operator|-
literal|1
index|]
expr_stmt|;
name|num_clients
operator|--
expr_stmt|;
block|}
else|else
name|n
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|fds
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|socket_release
parameter_list|(
name|heim_sipc
name|ctx
parameter_list|)
block|{
name|struct
name|client
modifier|*
name|c
init|=
name|ctx
operator|->
name|mech
decl_stmt|;
name|c
operator|->
name|flags
operator||=
name|WAITING_CLOSE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|heim_sipc_stream_listener
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|type
parameter_list|,
name|heim_ipc_callback
name|callback
parameter_list|,
name|void
modifier|*
name|user
parameter_list|,
name|heim_sipc
modifier|*
name|ctx
parameter_list|)
block|{
name|heim_sipc
name|ct
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ct
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|client
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|HEIM_SIPC_TYPE_IPC
operator|)
operator|&&
operator|(
name|type
operator|&
operator|(
name|HEIM_SIPC_TYPE_UINT32
operator||
name|HEIM_SIPC_TYPE_HTTP
operator|)
operator|)
condition|)
return|return
name|EINVAL
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HEIM_SIPC_TYPE_IPC
case|:
name|c
operator|=
name|add_new_socket
argument_list|(
name|fd
argument_list|,
name|LISTEN_SOCKET
operator||
name|WAITING_READ
operator||
name|INCLUDE_ERROR_CODE
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
expr_stmt|;
break|break;
case|case
name|HEIM_SIPC_TYPE_UINT32
case|:
name|c
operator|=
name|add_new_socket
argument_list|(
name|fd
argument_list|,
name|LISTEN_SOCKET
operator||
name|WAITING_READ
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
expr_stmt|;
break|break;
case|case
name|HEIM_SIPC_TYPE_HTTP
case|:
case|case
name|HEIM_SIPC_TYPE_UINT32
operator||
name|HEIM_SIPC_TYPE_HTTP
case|:
name|c
operator|=
name|add_new_socket
argument_list|(
name|fd
argument_list|,
name|LISTEN_SOCKET
operator||
name|WAITING_READ
operator||
name|ALLOW_HTTP
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
expr_stmt|;
break|break;
default|default:
name|free
argument_list|(
name|ct
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|ct
operator|->
name|mech
operator|=
name|c
expr_stmt|;
name|ct
operator|->
name|release
operator|=
name|socket_release
expr_stmt|;
name|c
operator|->
name|unixrights
operator|.
name|uid
operator|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|unixrights
operator|.
name|gid
operator|=
operator|(
name|gid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|unixrights
operator|.
name|pid
operator|=
operator|(
name|pid_t
operator|)
literal|0
expr_stmt|;
operator|*
name|ctx
operator|=
name|ct
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|heim_sipc_service_unix
parameter_list|(
specifier|const
name|char
modifier|*
name|service
parameter_list|,
name|heim_ipc_callback
name|callback
parameter_list|,
name|void
modifier|*
name|user
parameter_list|,
name|heim_sipc
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|sockaddr_un
name|un
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|ret
decl_stmt|;
name|un
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|snprintf
argument_list|(
name|un
operator|.
name|sun_path
argument_list|,
sizeof|sizeof
argument_list|(
name|un
operator|.
name|sun_path
argument_list|)
argument_list|,
literal|"/var/run/.heim_%s-socket"
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|fd
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
name|errno
return|;
name|socket_set_reuseaddr
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCAL_CREDS
block|{
name|int
name|one
init|=
literal|1
decl_stmt|;
name|setsockopt
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|LOCAL_CREDS
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|one
argument_list|,
sizeof|sizeof
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|unlink
argument_list|(
name|un
operator|.
name|sun_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|un
argument_list|,
sizeof|sizeof
argument_list|(
name|un
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|fd
argument_list|,
name|SOMAXCONN
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
name|chmod
argument_list|(
name|un
operator|.
name|sun_path
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|ret
operator|=
name|heim_sipc_stream_listener
argument_list|(
name|fd
argument_list|,
name|HEIM_SIPC_TYPE_IPC
argument_list|,
name|callback
argument_list|,
name|user
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|struct
name|client
modifier|*
name|c
init|=
operator|(
operator|*
name|ctx
operator|)
operator|->
name|mech
decl_stmt|;
name|c
operator|->
name|flags
operator||=
name|UNIX_SOCKET
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Set the idle timeout value   * The timeout event handler is triggered recurrently every idle  * period `t'. The default action is rather draconian and just calls  * exit(0), so you might want to change this to something more  * graceful using heim_sipc_set_timeout_handler().  */
end_comment

begin_function
name|void
name|heim_sipc_timeout
parameter_list|(
name|time_t
name|t
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GCD
specifier|static
name|dispatch_once_t
name|timeoutonce
decl_stmt|;
name|init_globals
argument_list|()
expr_stmt|;
name|dispatch_sync
argument_list|(
name|timerq
argument_list|,
lambda|^
block|{
name|timeoutvalue
operator|=
name|t
expr_stmt|;
name|set_timer
argument_list|()
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|dispatch_once
argument_list|(
operator|&
name|timeoutonce
argument_list|,
lambda|^
block|{
name|dispatch_resume
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * Set the timeout event handler  *  * Replaces the default idle timeout action.  */
end_comment

begin_function
name|void
name|heim_sipc_set_timeout_handler
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GCD
name|init_globals
argument_list|()
expr_stmt|;
name|dispatch_sync
argument_list|(
name|timerq
argument_list|,
lambda|^
block|{
name|timer_ev
operator|=
name|func
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|heim_sipc_free_context
parameter_list|(
name|heim_sipc
name|ctx
parameter_list|)
block|{
call|(
name|ctx
operator|->
name|release
call|)
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|heim_ipc_main
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GCD
name|dispatch_main
argument_list|()
expr_stmt|;
else|#
directive|else
name|process_loop
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

