begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997 - 2006 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"gsskrb5_locl.h"
end_include

begin_decl_stmt
name|HEIMDAL_MUTEX
name|gssapi_keytab_mutex
init|=
name|HEIMDAL_MUTEX_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|krb5_keytab
name|_gsskrb5_keytab
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|krb5_error_code
name|validate_keytab
parameter_list|(
name|krb5_context
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|krb5_keytab
modifier|*
name|id
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|ret
operator|=
name|krb5_kt_resolve
argument_list|(
name|context
argument_list|,
name|name
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|krb5_kt_have_content
argument_list|(
name|context
argument_list|,
operator|*
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|krb5_kt_close
argument_list|(
name|context
argument_list|,
operator|*
name|id
argument_list|)
expr_stmt|;
operator|*
name|id
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|OM_uint32
name|_gsskrb5_register_acceptor_identity
parameter_list|(
name|OM_uint32
modifier|*
name|min_stat
parameter_list|,
specifier|const
name|char
modifier|*
name|identity
parameter_list|)
block|{
name|krb5_context
name|context
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
operator|*
name|min_stat
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|_gsskrb5_init
argument_list|(
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|GSS_S_FAILURE
return|;
name|HEIMDAL_MUTEX_lock
argument_list|(
operator|&
name|gssapi_keytab_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|_gsskrb5_keytab
operator|!=
name|NULL
condition|)
block|{
name|krb5_kt_close
argument_list|(
name|context
argument_list|,
name|_gsskrb5_keytab
argument_list|)
expr_stmt|;
name|_gsskrb5_keytab
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|identity
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|krb5_kt_default
argument_list|(
name|context
argument_list|,
operator|&
name|_gsskrb5_keytab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * First check if we can the keytab as is and if it has content... 	 */
name|ret
operator|=
name|validate_keytab
argument_list|(
name|context
argument_list|,
name|identity
argument_list|,
operator|&
name|_gsskrb5_keytab
argument_list|)
expr_stmt|;
comment|/* 	 * if it doesn't, lets prepend FILE: and try again 	 */
if|if
condition|(
name|ret
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|ret
operator|=
name|asprintf
argument_list|(
operator|&
name|p
argument_list|,
literal|"FILE:%s"
argument_list|,
name|identity
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|p
operator|==
name|NULL
condition|)
block|{
name|HEIMDAL_MUTEX_unlock
argument_list|(
operator|&
name|gssapi_keytab_mutex
argument_list|)
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
name|ret
operator|=
name|validate_keytab
argument_list|(
name|context
argument_list|,
name|p
argument_list|,
operator|&
name|_gsskrb5_keytab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|HEIMDAL_MUTEX_unlock
argument_list|(
operator|&
name|gssapi_keytab_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
operator|*
name|min_stat
operator|=
name|ret
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
return|return
name|GSS_S_COMPLETE
return|;
block|}
end_function

begin_function
name|void
name|_gsskrb5i_is_cfx
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|gsskrb5_ctx
name|ctx
parameter_list|,
name|int
name|acceptor
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_keyblock
modifier|*
name|key
decl_stmt|;
if|if
condition|(
name|acceptor
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|auth_context
operator|->
name|local_subkey
condition|)
name|key
operator|=
name|ctx
operator|->
name|auth_context
operator|->
name|local_subkey
expr_stmt|;
else|else
name|key
operator|=
name|ctx
operator|->
name|auth_context
operator|->
name|remote_subkey
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ctx
operator|->
name|auth_context
operator|->
name|remote_subkey
condition|)
name|key
operator|=
name|ctx
operator|->
name|auth_context
operator|->
name|remote_subkey
expr_stmt|;
else|else
name|key
operator|=
name|ctx
operator|->
name|auth_context
operator|->
name|local_subkey
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
name|key
operator|=
name|ctx
operator|->
name|auth_context
operator|->
name|keyblock
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|key
operator|->
name|keytype
condition|)
block|{
case|case
name|ETYPE_DES_CBC_CRC
case|:
case|case
name|ETYPE_DES_CBC_MD4
case|:
case|case
name|ETYPE_DES_CBC_MD5
case|:
case|case
name|ETYPE_DES3_CBC_MD5
case|:
case|case
name|ETYPE_OLD_DES3_CBC_SHA1
case|:
case|case
name|ETYPE_DES3_CBC_SHA1
case|:
case|case
name|ETYPE_ARCFOUR_HMAC_MD5
case|:
case|case
name|ETYPE_ARCFOUR_HMAC_MD5_56
case|:
break|break;
default|default :
name|ctx
operator|->
name|more_flags
operator||=
name|IS_CFX
expr_stmt|;
if|if
condition|(
operator|(
name|acceptor
operator|&&
name|ctx
operator|->
name|auth_context
operator|->
name|local_subkey
operator|)
operator|||
operator|(
operator|!
name|acceptor
operator|&&
name|ctx
operator|->
name|auth_context
operator|->
name|remote_subkey
operator|)
condition|)
name|ctx
operator|->
name|more_flags
operator||=
name|ACCEPTOR_SUBKEY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ctx
operator|->
name|crypto
condition|)
name|krb5_crypto_destroy
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|crypto
argument_list|)
expr_stmt|;
name|ret
operator|=
name|krb5_crypto_init
argument_list|(
name|context
argument_list|,
name|key
argument_list|,
literal|0
argument_list|,
operator|&
name|ctx
operator|->
name|crypto
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|gsskrb5_accept_delegated_token
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|gsskrb5_ctx
name|ctx
parameter_list|,
name|krb5_context
name|context
parameter_list|,
name|gss_cred_id_t
modifier|*
name|delegated_cred_handle
parameter_list|)
block|{
name|krb5_ccache
name|ccache
init|=
name|NULL
decl_stmt|;
name|krb5_error_code
name|kret
decl_stmt|;
name|int32_t
name|ac_flags
decl_stmt|,
name|ret
init|=
name|GSS_S_COMPLETE
decl_stmt|;
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
comment|/* XXX Create a new delegated_cred_handle? */
if|if
condition|(
name|delegated_cred_handle
operator|==
name|NULL
condition|)
block|{
name|kret
operator|=
name|krb5_cc_default
argument_list|(
name|context
argument_list|,
operator|&
name|ccache
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|delegated_cred_handle
operator|=
name|NULL
expr_stmt|;
name|kret
operator|=
name|krb5_cc_new_unique
argument_list|(
name|context
argument_list|,
name|krb5_cc_type_memory
argument_list|,
name|NULL
argument_list|,
operator|&
name|ccache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kret
condition|)
block|{
name|ctx
operator|->
name|flags
operator|&=
operator|~
name|GSS_C_DELEG_FLAG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|kret
operator|=
name|krb5_cc_initialize
argument_list|(
name|context
argument_list|,
name|ccache
argument_list|,
name|ctx
operator|->
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
name|ctx
operator|->
name|flags
operator|&=
operator|~
name|GSS_C_DELEG_FLAG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|krb5_auth_con_removeflags
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
name|KRB5_AUTH_CONTEXT_DO_TIME
argument_list|,
operator|&
name|ac_flags
argument_list|)
expr_stmt|;
name|kret
operator|=
name|krb5_rd_cred2
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
name|ccache
argument_list|,
operator|&
name|ctx
operator|->
name|fwd_data
argument_list|)
expr_stmt|;
name|krb5_auth_con_setflags
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
name|ac_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
name|ctx
operator|->
name|flags
operator|&=
operator|~
name|GSS_C_DELEG_FLAG
expr_stmt|;
name|ret
operator|=
name|GSS_S_FAILURE
expr_stmt|;
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|delegated_cred_handle
condition|)
block|{
name|gsskrb5_cred
name|handle
decl_stmt|;
name|ret
operator|=
name|_gsskrb5_krb5_import_cred
argument_list|(
name|minor_status
argument_list|,
name|ccache
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|delegated_cred_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GSS_S_COMPLETE
condition|)
goto|goto
name|out
goto|;
name|handle
operator|=
operator|(
name|gsskrb5_cred
operator|)
operator|*
name|delegated_cred_handle
expr_stmt|;
name|handle
operator|->
name|cred_flags
operator||=
name|GSS_CF_DESTROY_CRED_ON_RELEASE
expr_stmt|;
name|krb5_cc_close
argument_list|(
name|context
argument_list|,
name|ccache
argument_list|)
expr_stmt|;
name|ccache
operator|=
name|NULL
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|ccache
condition|)
block|{
comment|/* Don't destroy the default cred cache */
if|if
condition|(
name|delegated_cred_handle
operator|==
name|NULL
condition|)
name|krb5_cc_close
argument_list|(
name|context
argument_list|,
name|ccache
argument_list|)
expr_stmt|;
else|else
name|krb5_cc_destroy
argument_list|(
name|context
argument_list|,
name|ccache
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|gsskrb5_acceptor_ready
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|gsskrb5_ctx
name|ctx
parameter_list|,
name|krb5_context
name|context
parameter_list|,
name|gss_cred_id_t
modifier|*
name|delegated_cred_handle
parameter_list|)
block|{
name|OM_uint32
name|ret
decl_stmt|;
name|int32_t
name|seq_number
decl_stmt|;
name|int
name|is_cfx
init|=
literal|0
decl_stmt|;
name|krb5_auth_con_getremoteseqnumber
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
operator|&
name|seq_number
argument_list|)
expr_stmt|;
name|_gsskrb5i_is_cfx
argument_list|(
name|context
argument_list|,
name|ctx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|is_cfx
operator|=
operator|(
name|ctx
operator|->
name|more_flags
operator|&
name|IS_CFX
operator|)
expr_stmt|;
name|ret
operator|=
name|_gssapi_msg_order_create
argument_list|(
name|minor_status
argument_list|,
operator|&
name|ctx
operator|->
name|order
argument_list|,
name|_gssapi_msg_order_f
argument_list|(
name|ctx
operator|->
name|flags
argument_list|)
argument_list|,
name|seq_number
argument_list|,
literal|0
argument_list|,
name|is_cfx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/*      * If requested, set local sequence num to remote sequence if this      * isn't a mutual authentication context      */
if|if
condition|(
operator|!
operator|(
name|ctx
operator|->
name|flags
operator|&
name|GSS_C_MUTUAL_FLAG
operator|)
operator|&&
name|_gssapi_msg_order_f
argument_list|(
name|ctx
operator|->
name|flags
argument_list|)
condition|)
block|{
name|krb5_auth_con_setlocalseqnumber
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
name|seq_number
argument_list|)
expr_stmt|;
block|}
comment|/*      * We should handle the delegation ticket, in case it's there      */
if|if
condition|(
name|ctx
operator|->
name|fwd_data
operator|.
name|length
operator|>
literal|0
operator|&&
operator|(
name|ctx
operator|->
name|flags
operator|&
name|GSS_C_DELEG_FLAG
operator|)
condition|)
block|{
name|ret
operator|=
name|gsskrb5_accept_delegated_token
argument_list|(
name|minor_status
argument_list|,
name|ctx
argument_list|,
name|context
argument_list|,
name|delegated_cred_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
else|else
block|{
comment|/* Well, looks like it wasn't there after all */
name|ctx
operator|->
name|flags
operator|&=
operator|~
name|GSS_C_DELEG_FLAG
expr_stmt|;
block|}
name|ctx
operator|->
name|state
operator|=
name|ACCEPTOR_READY
expr_stmt|;
name|ctx
operator|->
name|more_flags
operator||=
name|OPEN
expr_stmt|;
return|return
name|GSS_S_COMPLETE
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|send_error_token
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|krb5_context
name|context
parameter_list|,
name|krb5_error_code
name|kret
parameter_list|,
name|krb5_principal
name|server
parameter_list|,
name|krb5_data
modifier|*
name|indata
parameter_list|,
name|gss_buffer_t
name|output_token
parameter_list|)
block|{
name|krb5_principal
name|ap_req_server
init|=
name|NULL
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_data
name|outbuf
decl_stmt|;
comment|/* this e_data value encodes KERB_AP_ERR_TYPE_SKEW_RECOVERY which        tells windows to try again with the corrected timestamp. See        [MS-KILE] 2.2.1 KERB-ERROR-DATA */
name|krb5_data
name|e_data
init|=
block|{
literal|7
block|,
name|rk_UNCONST
argument_list|(
literal|"\x30\x05\xa1\x03\x02\x01\x02"
argument_list|)
block|}
decl_stmt|;
comment|/* build server from request if the acceptor had not selected one */
if|if
condition|(
name|server
operator|==
name|NULL
condition|)
block|{
name|AP_REQ
name|ap_req
decl_stmt|;
name|ret
operator|=
name|krb5_decode_ap_req
argument_list|(
name|context
argument_list|,
name|indata
argument_list|,
operator|&
name|ap_req
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|ret
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
name|ret
operator|=
name|_krb5_principalname2krb5_principal
argument_list|(
name|context
argument_list|,
operator|&
name|ap_req_server
argument_list|,
name|ap_req
operator|.
name|ticket
operator|.
name|sname
argument_list|,
name|ap_req
operator|.
name|ticket
operator|.
name|realm
argument_list|)
expr_stmt|;
name|free_AP_REQ
argument_list|(
operator|&
name|ap_req
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|ret
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
name|server
operator|=
name|ap_req_server
expr_stmt|;
block|}
name|ret
operator|=
name|krb5_mk_error
argument_list|(
name|context
argument_list|,
name|kret
argument_list|,
name|NULL
argument_list|,
operator|&
name|e_data
argument_list|,
name|NULL
argument_list|,
name|server
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap_req_server
condition|)
name|krb5_free_principal
argument_list|(
name|context
argument_list|,
name|ap_req_server
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|ret
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
name|ret
operator|=
name|_gsskrb5_encapsulate
argument_list|(
name|minor_status
argument_list|,
operator|&
name|outbuf
argument_list|,
name|output_token
argument_list|,
literal|"\x03\x00"
argument_list|,
name|GSS_KRB5_MECHANISM
argument_list|)
expr_stmt|;
name|krb5_data_free
argument_list|(
operator|&
name|outbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
return|return
name|GSS_S_CONTINUE_NEEDED
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|gsskrb5_acceptor_start
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|gsskrb5_ctx
name|ctx
parameter_list|,
name|krb5_context
name|context
parameter_list|,
specifier|const
name|gss_cred_id_t
name|acceptor_cred_handle
parameter_list|,
specifier|const
name|gss_buffer_t
name|input_token_buffer
parameter_list|,
specifier|const
name|gss_channel_bindings_t
name|input_chan_bindings
parameter_list|,
name|gss_name_t
modifier|*
name|src_name
parameter_list|,
name|gss_OID
modifier|*
name|mech_type
parameter_list|,
name|gss_buffer_t
name|output_token
parameter_list|,
name|OM_uint32
modifier|*
name|ret_flags
parameter_list|,
name|OM_uint32
modifier|*
name|time_rec
parameter_list|,
name|gss_cred_id_t
modifier|*
name|delegated_cred_handle
parameter_list|)
block|{
name|krb5_error_code
name|kret
decl_stmt|;
name|OM_uint32
name|ret
init|=
name|GSS_S_COMPLETE
decl_stmt|;
name|krb5_data
name|indata
decl_stmt|;
name|krb5_flags
name|ap_options
decl_stmt|;
name|krb5_keytab
name|keytab
init|=
name|NULL
decl_stmt|;
name|int
name|is_cfx
init|=
literal|0
decl_stmt|;
specifier|const
name|gsskrb5_cred
name|acceptor_cred
init|=
operator|(
name|gsskrb5_cred
operator|)
name|acceptor_cred_handle
decl_stmt|;
comment|/*      * We may, or may not, have an escapsulation.      */
name|ret
operator|=
name|_gsskrb5_decapsulate
argument_list|(
name|minor_status
argument_list|,
name|input_token_buffer
argument_list|,
operator|&
name|indata
argument_list|,
literal|"\x01\x00"
argument_list|,
name|GSS_KRB5_MECHANISM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Assume that there is no OID wrapping. */
name|indata
operator|.
name|length
operator|=
name|input_token_buffer
operator|->
name|length
expr_stmt|;
name|indata
operator|.
name|data
operator|=
name|input_token_buffer
operator|->
name|value
expr_stmt|;
block|}
comment|/*      * We need to get our keytab      */
if|if
condition|(
name|acceptor_cred
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|_gsskrb5_keytab
operator|!=
name|NULL
condition|)
name|keytab
operator|=
name|_gsskrb5_keytab
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|acceptor_cred
operator|->
name|keytab
operator|!=
name|NULL
condition|)
block|{
name|keytab
operator|=
name|acceptor_cred
operator|->
name|keytab
expr_stmt|;
block|}
comment|/*      * We need to check the ticket and create the AP-REP packet      */
block|{
name|krb5_rd_req_in_ctx
name|in
init|=
name|NULL
decl_stmt|;
name|krb5_rd_req_out_ctx
name|out
init|=
name|NULL
decl_stmt|;
name|krb5_principal
name|server
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|acceptor_cred
condition|)
name|server
operator|=
name|acceptor_cred
operator|->
name|principal
expr_stmt|;
name|kret
operator|=
name|krb5_rd_req_in_ctx_alloc
argument_list|(
name|context
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
operator|==
literal|0
condition|)
name|kret
operator|=
name|krb5_rd_req_in_set_keytab
argument_list|(
name|context
argument_list|,
name|in
argument_list|,
name|keytab
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
if|if
condition|(
name|in
condition|)
name|krb5_rd_req_in_ctx_free
argument_list|(
name|context
argument_list|,
name|in
argument_list|)
expr_stmt|;
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
name|kret
operator|=
name|krb5_rd_req_ctx
argument_list|(
name|context
argument_list|,
operator|&
name|ctx
operator|->
name|auth_context
argument_list|,
operator|&
name|indata
argument_list|,
name|server
argument_list|,
name|in
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
name|krb5_rd_req_in_ctx_free
argument_list|(
name|context
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
operator|==
name|KRB5KRB_AP_ERR_SKEW
operator|||
name|kret
operator|==
name|KRB5KRB_AP_ERR_TKT_NYV
condition|)
block|{
comment|/* 	     * No reply in non-MUTUAL mode, but we don't know that its 	     * non-MUTUAL mode yet, thats inside the 8003 checksum, so 	     * lets only send the error token on clock skew, that 	     * limit when send error token for non-MUTUAL. 	     */
return|return
name|send_error_token
argument_list|(
name|minor_status
argument_list|,
name|context
argument_list|,
name|kret
argument_list|,
name|server
argument_list|,
operator|&
name|indata
argument_list|,
name|output_token
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|kret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
comment|/* 	 * we need to remember some data on the context_handle. 	 */
name|kret
operator|=
name|krb5_rd_req_out_get_ap_req_options
argument_list|(
name|context
argument_list|,
name|out
argument_list|,
operator|&
name|ap_options
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
operator|==
literal|0
condition|)
name|kret
operator|=
name|krb5_rd_req_out_get_ticket
argument_list|(
name|context
argument_list|,
name|out
argument_list|,
operator|&
name|ctx
operator|->
name|ticket
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
operator|==
literal|0
condition|)
name|kret
operator|=
name|krb5_rd_req_out_get_keyblock
argument_list|(
name|context
argument_list|,
name|out
argument_list|,
operator|&
name|ctx
operator|->
name|service_keyblock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|lifetime
operator|=
name|ctx
operator|->
name|ticket
operator|->
name|ticket
operator|.
name|endtime
expr_stmt|;
name|krb5_rd_req_out_ctx_free
argument_list|(
name|context
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
name|ret
operator|=
name|GSS_S_FAILURE
expr_stmt|;
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
comment|/*      * We need to copy the principal names to the context and the      * calling layer.      */
name|kret
operator|=
name|krb5_copy_principal
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|ticket
operator|->
name|client
argument_list|,
operator|&
name|ctx
operator|->
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
name|ret
operator|=
name|GSS_S_FAILURE
expr_stmt|;
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
block|}
name|kret
operator|=
name|krb5_copy_principal
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|ticket
operator|->
name|server
argument_list|,
operator|&
name|ctx
operator|->
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
name|ret
operator|=
name|GSS_S_FAILURE
expr_stmt|;
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/*      * We need to setup some compat stuff, this assumes that      * context_handle->target is already set.      */
name|ret
operator|=
name|_gss_DES3_get_mic_compat
argument_list|(
name|minor_status
argument_list|,
name|ctx
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|src_name
operator|!=
name|NULL
condition|)
block|{
name|kret
operator|=
name|krb5_copy_principal
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|ticket
operator|->
name|client
argument_list|,
operator|(
name|gsskrb5_name
operator|*
operator|)
name|src_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
name|ret
operator|=
name|GSS_S_FAILURE
expr_stmt|;
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
comment|/*      * We need to get the flags out of the 8003 checksum.      */
block|{
name|krb5_authenticator
name|authenticator
decl_stmt|;
name|kret
operator|=
name|krb5_auth_con_getauthenticator
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
operator|&
name|authenticator
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
name|ret
operator|=
name|GSS_S_FAILURE
expr_stmt|;
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|authenticator
operator|->
name|cksum
operator|==
name|NULL
condition|)
block|{
name|krb5_free_authenticator
argument_list|(
name|context
argument_list|,
operator|&
name|authenticator
argument_list|)
expr_stmt|;
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
return|return
name|GSS_S_BAD_BINDINGS
return|;
block|}
if|if
condition|(
name|authenticator
operator|->
name|cksum
operator|->
name|cksumtype
operator|==
name|CKSUMTYPE_GSSAPI
condition|)
block|{
name|ret
operator|=
name|_gsskrb5_verify_8003_checksum
argument_list|(
name|minor_status
argument_list|,
name|input_chan_bindings
argument_list|,
name|authenticator
operator|->
name|cksum
argument_list|,
operator|&
name|ctx
operator|->
name|flags
argument_list|,
operator|&
name|ctx
operator|->
name|fwd_data
argument_list|)
expr_stmt|;
name|krb5_free_authenticator
argument_list|(
name|context
argument_list|,
operator|&
name|authenticator
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
return|return
name|ret
return|;
block|}
block|}
else|else
block|{
name|krb5_crypto
name|crypto
decl_stmt|;
name|kret
operator|=
name|krb5_crypto_init
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
operator|->
name|keyblock
argument_list|,
literal|0
argument_list|,
operator|&
name|crypto
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
name|krb5_free_authenticator
argument_list|(
name|context
argument_list|,
operator|&
name|authenticator
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GSS_S_FAILURE
expr_stmt|;
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* 	     * Windows accepts Samba3's use of a kerberos, rather than 	     * GSSAPI checksum here 	     */
name|kret
operator|=
name|krb5_verify_checksum
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|KRB5_KU_AP_REQ_AUTH_CKSUM
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|authenticator
operator|->
name|cksum
argument_list|)
expr_stmt|;
name|krb5_free_authenticator
argument_list|(
name|context
argument_list|,
operator|&
name|authenticator
argument_list|)
expr_stmt|;
name|krb5_crypto_destroy
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
name|ret
operator|=
name|GSS_S_BAD_SIG
expr_stmt|;
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* 	     * Samba style get some flags (but not DCE-STYLE), use 	     * ap_options to guess the mutual flag. 	     */
name|ctx
operator|->
name|flags
operator|=
name|GSS_C_REPLAY_FLAG
operator||
name|GSS_C_SEQUENCE_FLAG
expr_stmt|;
if|if
condition|(
name|ap_options
operator|&
name|AP_OPTS_MUTUAL_REQUIRED
condition|)
name|ctx
operator|->
name|flags
operator||=
name|GSS_C_MUTUAL_FLAG
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ctx
operator|->
name|flags
operator|&
name|GSS_C_MUTUAL_FLAG
condition|)
block|{
name|krb5_data
name|outbuf
decl_stmt|;
name|int
name|use_subkey
init|=
literal|0
decl_stmt|;
name|_gsskrb5i_is_cfx
argument_list|(
name|context
argument_list|,
name|ctx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|is_cfx
operator|=
operator|(
name|ctx
operator|->
name|more_flags
operator|&
name|IS_CFX
operator|)
expr_stmt|;
if|if
condition|(
name|is_cfx
operator|||
operator|(
name|ap_options
operator|&
name|AP_OPTS_USE_SUBKEY
operator|)
condition|)
block|{
name|use_subkey
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|krb5_keyblock
modifier|*
name|rkey
decl_stmt|;
comment|/* 	     * If there is a initiator subkey, copy that to acceptor 	     * subkey to match Windows behavior 	     */
name|kret
operator|=
name|krb5_auth_con_getremotesubkey
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
operator|&
name|rkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
operator|==
literal|0
condition|)
block|{
name|kret
operator|=
name|krb5_auth_con_setlocalsubkey
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
name|rkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
operator|==
literal|0
condition|)
name|use_subkey
operator|=
literal|1
expr_stmt|;
name|krb5_free_keyblock
argument_list|(
name|context
argument_list|,
name|rkey
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|use_subkey
condition|)
block|{
name|ctx
operator|->
name|more_flags
operator||=
name|ACCEPTOR_SUBKEY
expr_stmt|;
name|krb5_auth_con_addflags
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
name|KRB5_AUTH_CONTEXT_USE_SUBKEY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|kret
operator|=
name|krb5_mk_rep
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
if|if
condition|(
name|IS_DCE_STYLE
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|output_token
operator|->
name|length
operator|=
name|outbuf
operator|.
name|length
expr_stmt|;
name|output_token
operator|->
name|value
operator|=
name|outbuf
operator|.
name|data
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|_gsskrb5_encapsulate
argument_list|(
name|minor_status
argument_list|,
operator|&
name|outbuf
argument_list|,
name|output_token
argument_list|,
literal|"\x02\x00"
argument_list|,
name|GSS_KRB5_MECHANISM
argument_list|)
expr_stmt|;
name|krb5_data_free
argument_list|(
operator|&
name|outbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
block|}
name|ctx
operator|->
name|flags
operator||=
name|GSS_C_TRANS_FLAG
expr_stmt|;
comment|/* Remember the flags */
name|ctx
operator|->
name|lifetime
operator|=
name|ctx
operator|->
name|ticket
operator|->
name|ticket
operator|.
name|endtime
expr_stmt|;
name|ctx
operator|->
name|more_flags
operator||=
name|OPEN
expr_stmt|;
if|if
condition|(
name|mech_type
condition|)
operator|*
name|mech_type
operator|=
name|GSS_KRB5_MECHANISM
expr_stmt|;
if|if
condition|(
name|time_rec
condition|)
block|{
name|ret
operator|=
name|_gsskrb5_lifetime_left
argument_list|(
name|minor_status
argument_list|,
name|context
argument_list|,
name|ctx
operator|->
name|lifetime
argument_list|,
name|time_rec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
return|return
name|ret
return|;
block|}
block|}
comment|/*      * When GSS_C_DCE_STYLE is in use, we need ask for a AP-REP from      * the client.      */
if|if
condition|(
name|IS_DCE_STYLE
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
comment|/* 	 * Return flags to caller, but we haven't processed 	 * delgations yet 	 */
if|if
condition|(
name|ret_flags
condition|)
operator|*
name|ret_flags
operator|=
operator|(
name|ctx
operator|->
name|flags
operator|&
operator|~
name|GSS_C_DELEG_FLAG
operator|)
expr_stmt|;
name|ctx
operator|->
name|state
operator|=
name|ACCEPTOR_WAIT_FOR_DCESTYLE
expr_stmt|;
return|return
name|GSS_S_CONTINUE_NEEDED
return|;
block|}
name|ret
operator|=
name|gsskrb5_acceptor_ready
argument_list|(
name|minor_status
argument_list|,
name|ctx
argument_list|,
name|context
argument_list|,
name|delegated_cred_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_flags
condition|)
operator|*
name|ret_flags
operator|=
name|ctx
operator|->
name|flags
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|acceptor_wait_for_dcestyle
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|gsskrb5_ctx
name|ctx
parameter_list|,
name|krb5_context
name|context
parameter_list|,
specifier|const
name|gss_cred_id_t
name|acceptor_cred_handle
parameter_list|,
specifier|const
name|gss_buffer_t
name|input_token_buffer
parameter_list|,
specifier|const
name|gss_channel_bindings_t
name|input_chan_bindings
parameter_list|,
name|gss_name_t
modifier|*
name|src_name
parameter_list|,
name|gss_OID
modifier|*
name|mech_type
parameter_list|,
name|gss_buffer_t
name|output_token
parameter_list|,
name|OM_uint32
modifier|*
name|ret_flags
parameter_list|,
name|OM_uint32
modifier|*
name|time_rec
parameter_list|,
name|gss_cred_id_t
modifier|*
name|delegated_cred_handle
parameter_list|)
block|{
name|OM_uint32
name|ret
decl_stmt|;
name|krb5_error_code
name|kret
decl_stmt|;
name|krb5_data
name|inbuf
decl_stmt|;
name|int32_t
name|r_seq_number
decl_stmt|,
name|l_seq_number
decl_stmt|;
comment|/*      * We know it's GSS_C_DCE_STYLE so we don't need to decapsulate the AP_REP      */
name|inbuf
operator|.
name|length
operator|=
name|input_token_buffer
operator|->
name|length
expr_stmt|;
name|inbuf
operator|.
name|data
operator|=
name|input_token_buffer
operator|->
name|value
expr_stmt|;
comment|/*      * We need to remeber the old remote seq_number, then check if the      * client has replied with our local seq_number, and then reset      * the remote seq_number to the old value      */
block|{
name|kret
operator|=
name|krb5_auth_con_getlocalseqnumber
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
operator|&
name|l_seq_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
name|kret
operator|=
name|krb5_auth_con_getremoteseqnumber
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
operator|&
name|r_seq_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
name|kret
operator|=
name|krb5_auth_con_setremoteseqnumber
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
name|l_seq_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
block|}
comment|/*      * We need to verify the AP_REP, but we need to flag that this is      * DCE_STYLE, so don't check the timestamps this time, but put the      * flag DO_TIME back afterward.     */
block|{
name|krb5_ap_rep_enc_part
modifier|*
name|repl
decl_stmt|;
name|int32_t
name|auth_flags
decl_stmt|;
name|krb5_auth_con_removeflags
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
name|KRB5_AUTH_CONTEXT_DO_TIME
argument_list|,
operator|&
name|auth_flags
argument_list|)
expr_stmt|;
name|kret
operator|=
name|krb5_rd_rep
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
operator|&
name|inbuf
argument_list|,
operator|&
name|repl
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
name|krb5_free_ap_rep_enc_part
argument_list|(
name|context
argument_list|,
name|repl
argument_list|)
expr_stmt|;
name|krb5_auth_con_setflags
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
name|auth_flags
argument_list|)
expr_stmt|;
block|}
comment|/* We need to check the liftime */
block|{
name|OM_uint32
name|lifetime_rec
decl_stmt|;
name|ret
operator|=
name|_gsskrb5_lifetime_left
argument_list|(
name|minor_status
argument_list|,
name|context
argument_list|,
name|ctx
operator|->
name|lifetime
argument_list|,
operator|&
name|lifetime_rec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
return|return
name|ret
return|;
block|}
if|if
condition|(
name|lifetime_rec
operator|==
literal|0
condition|)
block|{
return|return
name|GSS_S_CONTEXT_EXPIRED
return|;
block|}
if|if
condition|(
name|time_rec
condition|)
operator|*
name|time_rec
operator|=
name|lifetime_rec
expr_stmt|;
block|}
comment|/* We need to give the caller the flags which are in use */
if|if
condition|(
name|ret_flags
condition|)
operator|*
name|ret_flags
operator|=
name|ctx
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|src_name
condition|)
block|{
name|kret
operator|=
name|krb5_copy_principal
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|source
argument_list|,
operator|(
name|gsskrb5_name
operator|*
operator|)
name|src_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
block|}
comment|/*      * After the krb5_rd_rep() the remote and local seq_number should      * be the same, because the client just replies the seq_number      * from our AP-REP in its AP-REP, but then the client uses the      * seq_number from its AP-REQ for GSS_wrap()      */
block|{
name|int32_t
name|tmp_r_seq_number
decl_stmt|,
name|tmp_l_seq_number
decl_stmt|;
name|kret
operator|=
name|krb5_auth_con_getremoteseqnumber
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
operator|&
name|tmp_r_seq_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
name|kret
operator|=
name|krb5_auth_con_getlocalseqnumber
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
operator|&
name|tmp_l_seq_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
comment|/* 	 * Here we check if the client has responsed with our local seq_number, 	 */
if|if
condition|(
name|tmp_r_seq_number
operator|!=
name|tmp_l_seq_number
condition|)
block|{
return|return
name|GSS_S_UNSEQ_TOKEN
return|;
block|}
block|}
comment|/*      * We need to reset the remote seq_number, because the client will use,      * the old one for the GSS_wrap() calls      */
block|{
name|kret
operator|=
name|krb5_auth_con_setremoteseqnumber
argument_list|(
name|context
argument_list|,
name|ctx
operator|->
name|auth_context
argument_list|,
name|r_seq_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|kret
condition|)
block|{
operator|*
name|minor_status
operator|=
name|kret
expr_stmt|;
return|return
name|GSS_S_FAILURE
return|;
block|}
block|}
return|return
name|gsskrb5_acceptor_ready
argument_list|(
name|minor_status
argument_list|,
name|ctx
argument_list|,
name|context
argument_list|,
name|delegated_cred_handle
argument_list|)
return|;
block|}
end_function

begin_function
name|OM_uint32
name|GSSAPI_CALLCONV
name|_gsskrb5_accept_sec_context
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|gss_ctx_id_t
modifier|*
name|context_handle
parameter_list|,
specifier|const
name|gss_cred_id_t
name|acceptor_cred_handle
parameter_list|,
specifier|const
name|gss_buffer_t
name|input_token_buffer
parameter_list|,
specifier|const
name|gss_channel_bindings_t
name|input_chan_bindings
parameter_list|,
name|gss_name_t
modifier|*
name|src_name
parameter_list|,
name|gss_OID
modifier|*
name|mech_type
parameter_list|,
name|gss_buffer_t
name|output_token
parameter_list|,
name|OM_uint32
modifier|*
name|ret_flags
parameter_list|,
name|OM_uint32
modifier|*
name|time_rec
parameter_list|,
name|gss_cred_id_t
modifier|*
name|delegated_cred_handle
parameter_list|)
block|{
name|krb5_context
name|context
decl_stmt|;
name|OM_uint32
name|ret
decl_stmt|;
name|gsskrb5_ctx
name|ctx
decl_stmt|;
name|GSSAPI_KRB5_INIT
argument_list|(
operator|&
name|context
argument_list|)
expr_stmt|;
name|output_token
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|output_token
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|src_name
operator|!=
name|NULL
condition|)
operator|*
name|src_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mech_type
condition|)
operator|*
name|mech_type
operator|=
name|GSS_KRB5_MECHANISM
expr_stmt|;
if|if
condition|(
operator|*
name|context_handle
operator|==
name|GSS_C_NO_CONTEXT
condition|)
block|{
name|ret
operator|=
name|_gsskrb5_create_ctx
argument_list|(
name|minor_status
argument_list|,
name|context_handle
argument_list|,
name|context
argument_list|,
name|input_chan_bindings
argument_list|,
name|ACCEPTOR_START
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|ctx
operator|=
operator|(
name|gsskrb5_ctx
operator|)
operator|*
name|context_handle
expr_stmt|;
comment|/*      * TODO: check the channel_bindings      * (above just sets them to krb5 layer)      */
name|HEIMDAL_MUTEX_lock
argument_list|(
operator|&
name|ctx
operator|->
name|ctx_id_mutex
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ctx
operator|->
name|state
condition|)
block|{
case|case
name|ACCEPTOR_START
case|:
name|ret
operator|=
name|gsskrb5_acceptor_start
argument_list|(
name|minor_status
argument_list|,
name|ctx
argument_list|,
name|context
argument_list|,
name|acceptor_cred_handle
argument_list|,
name|input_token_buffer
argument_list|,
name|input_chan_bindings
argument_list|,
name|src_name
argument_list|,
name|mech_type
argument_list|,
name|output_token
argument_list|,
name|ret_flags
argument_list|,
name|time_rec
argument_list|,
name|delegated_cred_handle
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACCEPTOR_WAIT_FOR_DCESTYLE
case|:
name|ret
operator|=
name|acceptor_wait_for_dcestyle
argument_list|(
name|minor_status
argument_list|,
name|ctx
argument_list|,
name|context
argument_list|,
name|acceptor_cred_handle
argument_list|,
name|input_token_buffer
argument_list|,
name|input_chan_bindings
argument_list|,
name|src_name
argument_list|,
name|mech_type
argument_list|,
name|output_token
argument_list|,
name|ret_flags
argument_list|,
name|time_rec
argument_list|,
name|delegated_cred_handle
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACCEPTOR_READY
case|:
comment|/* 	 * If we get there, the caller have called 	 * gss_accept_sec_context() one time too many. 	 */
name|ret
operator|=
name|GSS_S_BAD_STATUS
expr_stmt|;
break|break;
default|default:
comment|/* TODO: is this correct here? --metze */
name|ret
operator|=
name|GSS_S_BAD_STATUS
expr_stmt|;
break|break;
block|}
name|HEIMDAL_MUTEX_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|ctx_id_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|GSS_ERROR
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|OM_uint32
name|min2
decl_stmt|;
name|_gsskrb5_delete_sec_context
argument_list|(
operator|&
name|min2
argument_list|,
name|context_handle
argument_list|,
name|GSS_C_NO_BUFFER
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

end_unit

