begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * AEAD support  */
end_comment

begin_include
include|#
directive|include
file|"mech_locl.h"
end_include

begin_comment
comment|/**  * Encrypts or sign the data.  *  * This is a more complicated version of gss_wrap(), it allows the  * caller to use AEAD data (signed header/trailer) and allow greater  * controll over where the encrypted data is placed.  *  * The maximum packet size is gss_context_stream_sizes.max_msg_size.  *  * The caller needs provide the folloing buffers when using in conf_req_flag=1 mode:  *  * - HEADER (of size gss_context_stream_sizes.header)  *   { DATA or SIGN_ONLY } (optional, zero or more)  *   PADDING (of size gss_context_stream_sizes.blocksize, if zero padding is zero, can be omitted)  *   TRAILER (of size gss_context_stream_sizes.trailer)  *  * - on DCE-RPC mode, the caller can skip PADDING and TRAILER if the  *   DATA elements is padded to a block bountry and header is of at  *   least size gss_context_stream_sizes.header + gss_context_stream_sizes.trailer.  *  * HEADER, PADDING, TRAILER will be shrunken to the size required to transmit any of them too large.  *  * To generate gss_wrap() compatible packets, use: HEADER | DATA | PADDING | TRAILER  *  * When used in conf_req_flag=0,  *  * - HEADER (of size gss_context_stream_sizes.header)  *   { DATA or SIGN_ONLY } (optional, zero or more)  *   PADDING (of size gss_context_stream_sizes.blocksize, if zero padding is zero, can be omitted)  *   TRAILER (of size gss_context_stream_sizes.trailer)  *  *  * The input sizes of HEADER, PADDING and TRAILER can be fetched using gss_wrap_iov_length() or  * gss_context_query_attributes().  *  * @ingroup gssapi  */
end_comment

begin_function
name|GSSAPI_LIB_FUNCTION
name|OM_uint32
name|GSSAPI_LIB_CALL
name|gss_wrap_iov
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|gss_ctx_id_t
name|context_handle
parameter_list|,
name|int
name|conf_req_flag
parameter_list|,
name|gss_qop_t
name|qop_req
parameter_list|,
name|int
modifier|*
name|conf_state
parameter_list|,
name|gss_iov_buffer_desc
modifier|*
name|iov
parameter_list|,
name|int
name|iov_count
parameter_list|)
block|{
name|struct
name|_gss_context
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|_gss_context
operator|*
operator|)
name|context_handle
decl_stmt|;
name|gssapi_mech_interface
name|m
decl_stmt|;
if|if
condition|(
name|minor_status
condition|)
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|conf_state
condition|)
operator|*
name|conf_state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
name|GSS_S_NO_CONTEXT
return|;
if|if
condition|(
name|iov
operator|==
name|NULL
operator|&&
name|iov_count
operator|!=
literal|0
condition|)
return|return
name|GSS_S_CALL_INACCESSIBLE_READ
return|;
name|m
operator|=
name|ctx
operator|->
name|gc_mech
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|gm_wrap_iov
operator|==
name|NULL
condition|)
return|return
name|GSS_S_UNAVAILABLE
return|;
return|return
call|(
name|m
operator|->
name|gm_wrap_iov
call|)
argument_list|(
name|minor_status
argument_list|,
name|ctx
operator|->
name|gc_ctx
argument_list|,
name|conf_req_flag
argument_list|,
name|qop_req
argument_list|,
name|conf_state
argument_list|,
name|iov
argument_list|,
name|iov_count
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Decrypt or verifies the signature on the data.  *  *  * @ingroup gssapi  */
end_comment

begin_function
name|GSSAPI_LIB_FUNCTION
name|OM_uint32
name|GSSAPI_LIB_CALL
name|gss_unwrap_iov
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|gss_ctx_id_t
name|context_handle
parameter_list|,
name|int
modifier|*
name|conf_state
parameter_list|,
name|gss_qop_t
modifier|*
name|qop_state
parameter_list|,
name|gss_iov_buffer_desc
modifier|*
name|iov
parameter_list|,
name|int
name|iov_count
parameter_list|)
block|{
name|struct
name|_gss_context
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|_gss_context
operator|*
operator|)
name|context_handle
decl_stmt|;
name|gssapi_mech_interface
name|m
decl_stmt|;
if|if
condition|(
name|minor_status
condition|)
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|conf_state
condition|)
operator|*
name|conf_state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qop_state
condition|)
operator|*
name|qop_state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
name|GSS_S_NO_CONTEXT
return|;
if|if
condition|(
name|iov
operator|==
name|NULL
operator|&&
name|iov_count
operator|!=
literal|0
condition|)
return|return
name|GSS_S_CALL_INACCESSIBLE_READ
return|;
name|m
operator|=
name|ctx
operator|->
name|gc_mech
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|gm_unwrap_iov
operator|==
name|NULL
condition|)
return|return
name|GSS_S_UNAVAILABLE
return|;
return|return
call|(
name|m
operator|->
name|gm_unwrap_iov
call|)
argument_list|(
name|minor_status
argument_list|,
name|ctx
operator|->
name|gc_ctx
argument_list|,
name|conf_state
argument_list|,
name|qop_state
argument_list|,
name|iov
argument_list|,
name|iov_count
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Update the length fields in iov buffer for the types:  * - GSS_IOV_BUFFER_TYPE_HEADER  * - GSS_IOV_BUFFER_TYPE_PADDING  * - GSS_IOV_BUFFER_TYPE_TRAILER  *  * Consider using gss_context_query_attributes() to fetch the data instead.  *  * @ingroup gssapi  */
end_comment

begin_function
name|GSSAPI_LIB_FUNCTION
name|OM_uint32
name|GSSAPI_LIB_CALL
name|gss_wrap_iov_length
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|gss_ctx_id_t
name|context_handle
parameter_list|,
name|int
name|conf_req_flag
parameter_list|,
name|gss_qop_t
name|qop_req
parameter_list|,
name|int
modifier|*
name|conf_state
parameter_list|,
name|gss_iov_buffer_desc
modifier|*
name|iov
parameter_list|,
name|int
name|iov_count
parameter_list|)
block|{
name|struct
name|_gss_context
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|_gss_context
operator|*
operator|)
name|context_handle
decl_stmt|;
name|gssapi_mech_interface
name|m
decl_stmt|;
if|if
condition|(
name|minor_status
condition|)
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|conf_state
condition|)
operator|*
name|conf_state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
name|GSS_S_NO_CONTEXT
return|;
if|if
condition|(
name|iov
operator|==
name|NULL
operator|&&
name|iov_count
operator|!=
literal|0
condition|)
return|return
name|GSS_S_CALL_INACCESSIBLE_READ
return|;
name|m
operator|=
name|ctx
operator|->
name|gc_mech
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|gm_wrap_iov_length
operator|==
name|NULL
condition|)
return|return
name|GSS_S_UNAVAILABLE
return|;
return|return
call|(
name|m
operator|->
name|gm_wrap_iov_length
call|)
argument_list|(
name|minor_status
argument_list|,
name|ctx
operator|->
name|gc_ctx
argument_list|,
name|conf_req_flag
argument_list|,
name|qop_req
argument_list|,
name|conf_state
argument_list|,
name|iov
argument_list|,
name|iov_count
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Free all buffer allocated by gss_wrap_iov() or gss_unwrap_iov() by  * looking at the GSS_IOV_BUFFER_FLAG_ALLOCATED flag.  *  * @ingroup gssapi  */
end_comment

begin_function
name|GSSAPI_LIB_FUNCTION
name|OM_uint32
name|GSSAPI_LIB_CALL
name|gss_release_iov_buffer
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|gss_iov_buffer_desc
modifier|*
name|iov
parameter_list|,
name|int
name|iov_count
parameter_list|)
block|{
name|OM_uint32
name|junk
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|minor_status
condition|)
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iov
operator|==
name|NULL
operator|&&
name|iov_count
operator|!=
literal|0
condition|)
return|return
name|GSS_S_CALL_INACCESSIBLE_READ
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iov_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|iov
index|[
name|i
index|]
operator|.
name|type
operator|&
name|GSS_IOV_BUFFER_FLAG_ALLOCATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|gss_release_buffer
argument_list|(
operator|&
name|junk
argument_list|,
operator|&
name|iov
index|[
name|i
index|]
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|iov
index|[
name|i
index|]
operator|.
name|type
operator|&=
operator|~
name|GSS_IOV_BUFFER_FLAG_ALLOCATED
expr_stmt|;
block|}
return|return
name|GSS_S_COMPLETE
return|;
block|}
end_function

begin_comment
comment|/**  * Query the context for parameters.  *  * SSPI equivalent if this function is QueryContextAttributes.  *  * - GSS_C_ATTR_STREAM_SIZES data is a gss_context_stream_sizes.  *  * @ingroup gssapi  */
end_comment

begin_decl_stmt
name|gss_OID_desc
name|GSSAPI_LIB_FUNCTION
name|__gss_c_attr_stream_sizes_oid_desc
init|=
block|{
literal|10
block|,
name|rk_UNCONST
argument_list|(
literal|"\x2a\x86\x48\x86\xf7\x12\x01\x02\x01\x03"
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|GSSAPI_LIB_FUNCTION
name|OM_uint32
name|GSSAPI_LIB_CALL
name|gss_context_query_attributes
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
specifier|const
name|gss_ctx_id_t
name|context_handle
parameter_list|,
specifier|const
name|gss_OID
name|attribute
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|minor_status
condition|)
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gss_oid_equal
argument_list|(
name|GSS_C_ATTR_STREAM_SIZES
argument_list|,
name|attribute
argument_list|)
condition|)
block|{
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|GSS_S_COMPLETE
return|;
block|}
return|return
name|GSS_S_FAILURE
return|;
block|}
end_function

end_unit

