begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006 - 2008 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *  * Portions Copyright (c) 2010 Apple Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<roken.h>
end_include

begin_include
include|#
directive|include
file|<parse_units.h>
end_include

begin_include
include|#
directive|include
file|<krb5.h>
end_include

begin_define
define|#
directive|define
name|HC_DEPRECATED_CRYPTO
end_define

begin_include
include|#
directive|include
file|"krb5-types.h"
end_include

begin_include
include|#
directive|include
file|"crypto-headers.h"
end_include

begin_include
include|#
directive|include
file|<heimntlm.h>
end_include

begin_comment
comment|/*! \mainpage Heimdal NTLM library  *  * \section intro Introduction  *  * Heimdal libheimntlm library is a implementation of the NTLM  * protocol, both version 1 and 2. The GSS-API mech that uses this  * library adds support for transport encryption and integrity  * checking.  *  * NTLM is a protocol for mutual authentication, its still used in  * many protocol where Kerberos is not support, one example is  * EAP/X802.1x mechanism LEAP from Microsoft and Cisco.  *  * This is a support library for the core protocol, its used in  * Heimdal to implement and GSS-API mechanism. There is also support  * in the KDC to do remote digest authenticiation, this to allow  * services to authenticate users w/o direct access to the users ntlm  * hashes (same as Kerberos arcfour enctype keys).  *  * More information about the NTLM protocol can found here  * http://davenport.sourceforge.net/ntlm.html .  *  * The Heimdal projects web page: http://www.h5l.org/  *  * @section ntlm_example NTLM Example  *  * Example to to use @ref test_ntlm.c .  *  * @example test_ntlm.c  *  * Example how to use the NTLM primitives.  *  */
end_comment

begin_comment
comment|/** @defgroup ntlm_core Heimdal NTLM library  *  * The NTLM core functions implement the string2key generation  * function, message encode and decode function, and the hash function  * functions.  */
end_comment

begin_struct
struct|struct
name|sec_buffer
block|{
name|uint16_t
name|length
decl_stmt|;
name|uint16_t
name|allocated
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|ntlmsigature
index|[
literal|8
index|]
init|=
literal|"NTLMSSP\x00"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  */
end_comment

begin_define
define|#
directive|define
name|CHECK
parameter_list|(
name|f
parameter_list|,
name|e
parameter_list|)
define|\
value|do {								\ 	ret = f;							\ 	if (ret != (ssize_t)(e)) {					\ 	    ret = HNTLM_ERR_DECODE;					\ 	    goto out;							\ 	}								\     } while(
comment|/*CONSTCOND*/
value|0)
end_define

begin_decl_stmt
specifier|static
name|struct
name|units
name|ntlm_flag_units
index|[]
init|=
block|{
define|#
directive|define
name|ntlm_flag
parameter_list|(
name|x
parameter_list|)
value|{ #x, NTLM_##x }
name|ntlm_flag
argument_list|(
name|ENC_56
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_KEYEX
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|ENC_128
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|MBZ1
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|MBZ2
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|MBZ3
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_VERSION
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|MBZ4
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_TARGET_INFO
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NON_NT_SESSION_KEY
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|MBZ5
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_IDENTIFY
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_NTLM2
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|TARGET_SHARE
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|TARGET_SERVER
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|TARGET_DOMAIN
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_ALWAYS_SIGN
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|MBZ6
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|OEM_SUPPLIED_WORKSTATION
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|OEM_SUPPLIED_DOMAIN
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_ANONYMOUS
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_NT_ONLY
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_NTLM
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|MBZ8
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_LM_KEY
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_DATAGRAM
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_SEAL
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_SIGN
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|MBZ9
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_TARGET
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_OEM
argument_list|)
block|,
name|ntlm_flag
argument_list|(
name|NEG_UNICODE
argument_list|)
block|,
undef|#
directive|undef
name|ntlm_flag
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|size_t
name|heim_ntlm_unparse_flags
parameter_list|(
name|uint32_t
name|flags
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|unparse_flags
argument_list|(
name|flags
argument_list|,
name|ntlm_flag_units
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * heim_ntlm_free_buf frees the ntlm buffer  *  * @param p buffer to be freed  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|void
name|heim_ntlm_free_buf
parameter_list|(
name|struct
name|ntlm_buf
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|data
condition|)
name|free
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ascii2ucs2le
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|up
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|i
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|/
literal|2
operator|>
name|UINT_MAX
condition|)
return|return
name|ERANGE
return|;
name|buf
operator|->
name|length
operator|=
name|len
operator|*
literal|2
expr_stmt|;
name|buf
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|buf
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|data
operator|==
name|NULL
operator|&&
name|len
operator|!=
literal|0
condition|)
block|{
name|heim_ntlm_free_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|p
operator|=
name|buf
operator|->
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|t
init|=
operator|(
name|unsigned
name|char
operator|)
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|&
literal|0x80
condition|)
block|{
name|heim_ntlm_free_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|up
condition|)
name|t
operator|=
name|toupper
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|p
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
literal|0
index|]
operator|=
name|t
expr_stmt|;
name|p
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|krb5_error_code
name|ret_sec_buffer
parameter_list|(
name|krb5_storage
modifier|*
name|sp
parameter_list|,
name|struct
name|sec_buffer
modifier|*
name|buf
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint16
argument_list|(
name|sp
argument_list|,
operator|&
name|buf
operator|->
name|length
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint16
argument_list|(
name|sp
argument_list|,
operator|&
name|buf
operator|->
name|allocated
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|sp
argument_list|,
operator|&
name|buf
operator|->
name|offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|store_sec_buffer
parameter_list|(
name|krb5_storage
modifier|*
name|sp
parameter_list|,
specifier|const
name|struct
name|sec_buffer
modifier|*
name|buf
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint16
argument_list|(
name|sp
argument_list|,
name|buf
operator|->
name|length
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint16
argument_list|(
name|sp
argument_list|,
name|buf
operator|->
name|allocated
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|sp
argument_list|,
name|buf
operator|->
name|offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Strings are either OEM or UNICODE. The later is encoded as ucs2 on  * wire, but using utf8 in memory.  */
end_comment

begin_function
specifier|static
name|krb5_error_code
name|len_string
parameter_list|(
name|int
name|ucs2
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|ucs2
condition|)
name|len
operator|*=
literal|2
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|krb5_error_code
name|ret_string
parameter_list|(
name|krb5_storage
modifier|*
name|sp
parameter_list|,
name|int
name|ucs2
parameter_list|,
name|size_t
name|len
parameter_list|,
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
operator|*
name|s
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|sp
argument_list|,
operator|*
name|s
argument_list|,
name|len
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|*
name|s
operator|)
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ucs2
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|*
name|s
operator|)
index|[
name|i
index|]
operator|=
operator|(
operator|*
name|s
operator|)
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|)
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
condition|)
block|{
name|free
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|NULL
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
operator|(
operator|*
name|s
operator|)
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|ret_sec_string
parameter_list|(
name|krb5_storage
modifier|*
name|sp
parameter_list|,
name|int
name|ucs2
parameter_list|,
name|struct
name|sec_buffer
modifier|*
name|desc
parameter_list|,
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|krb5_error_code
name|ret
init|=
literal|0
decl_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_seek
argument_list|(
name|sp
argument_list|,
name|desc
operator|->
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
argument_list|,
name|desc
operator|->
name|offset
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_string
argument_list|(
name|sp
argument_list|,
name|ucs2
argument_list|,
name|desc
operator|->
name|length
argument_list|,
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|put_string
parameter_list|(
name|krb5_storage
modifier|*
name|sp
parameter_list|,
name|int
name|ucs2
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|struct
name|ntlm_buf
name|buf
decl_stmt|;
if|if
condition|(
name|ucs2
condition|)
block|{
name|ret
operator|=
name|ascii2ucs2le
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
else|else
block|{
name|buf
operator|.
name|data
operator|=
name|rk_UNCONST
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|buf
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|sp
argument_list|,
name|buf
operator|.
name|data
argument_list|,
name|buf
operator|.
name|length
argument_list|)
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucs2
condition|)
name|heim_ntlm_free_buf
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|krb5_error_code
name|ret_buf
parameter_list|(
name|krb5_storage
modifier|*
name|sp
parameter_list|,
name|struct
name|sec_buffer
modifier|*
name|desc
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|buf
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|buf
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|desc
operator|->
name|length
argument_list|)
expr_stmt|;
name|buf
operator|->
name|length
operator|=
name|desc
operator|->
name|length
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_seek
argument_list|(
name|sp
argument_list|,
name|desc
operator|->
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
argument_list|,
name|desc
operator|->
name|offset
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|sp
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|length
argument_list|)
argument_list|,
name|buf
operator|->
name|length
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|put_buf
parameter_list|(
name|krb5_storage
modifier|*
name|sp
parameter_list|,
specifier|const
name|struct
name|ntlm_buf
modifier|*
name|buf
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|sp
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|length
argument_list|)
argument_list|,
name|buf
operator|->
name|length
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Frees the ntlm_targetinfo message  *  * @param ti targetinfo to be freed  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|void
name|heim_ntlm_free_targetinfo
parameter_list|(
name|struct
name|ntlm_targetinfo
modifier|*
name|ti
parameter_list|)
block|{
name|free
argument_list|(
name|ti
operator|->
name|servername
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ti
operator|->
name|domainname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ti
operator|->
name|dnsdomainname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ti
operator|->
name|dnsservername
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ti
operator|->
name|dnstreename
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ti
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ti
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|encode_ti_string
parameter_list|(
name|krb5_storage
modifier|*
name|out
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|int
name|ucs2
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint16
argument_list|(
name|out
argument_list|,
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint16
argument_list|(
name|out
argument_list|,
name|len_string
argument_list|(
name|ucs2
argument_list|,
name|s
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|put_string
argument_list|(
name|out
argument_list|,
name|ucs2
argument_list|,
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Encodes a ntlm_targetinfo message.  *  * @param ti the ntlm_targetinfo message to encode.  * @param ucs2 ignored  * @param data is the return buffer with the encoded message, should be  * freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_encode_targetinfo
parameter_list|(
specifier|const
name|struct
name|ntlm_targetinfo
modifier|*
name|ti
parameter_list|,
name|int
name|ucs2
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|data
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_storage
modifier|*
name|out
decl_stmt|;
name|data
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|out
operator|=
name|krb5_storage_emem
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|krb5_storage_set_byteorder
argument_list|(
name|out
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|servername
condition|)
name|CHECK
argument_list|(
name|encode_ti_string
argument_list|(
name|out
argument_list|,
literal|1
argument_list|,
name|ucs2
argument_list|,
name|ti
operator|->
name|servername
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|domainname
condition|)
name|CHECK
argument_list|(
name|encode_ti_string
argument_list|(
name|out
argument_list|,
literal|2
argument_list|,
name|ucs2
argument_list|,
name|ti
operator|->
name|domainname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|dnsservername
condition|)
name|CHECK
argument_list|(
name|encode_ti_string
argument_list|(
name|out
argument_list|,
literal|3
argument_list|,
name|ucs2
argument_list|,
name|ti
operator|->
name|dnsservername
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|dnsdomainname
condition|)
name|CHECK
argument_list|(
name|encode_ti_string
argument_list|(
name|out
argument_list|,
literal|4
argument_list|,
name|ucs2
argument_list|,
name|ti
operator|->
name|dnsdomainname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|dnstreename
condition|)
name|CHECK
argument_list|(
name|encode_ti_string
argument_list|(
name|out
argument_list|,
literal|5
argument_list|,
name|ucs2
argument_list|,
name|ti
operator|->
name|dnstreename
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|avflags
condition|)
block|{
name|CHECK
argument_list|(
name|krb5_store_uint16
argument_list|(
name|out
argument_list|,
literal|6
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint16
argument_list|(
name|out
argument_list|,
literal|4
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
name|ti
operator|->
name|avflags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* end tag */
name|CHECK
argument_list|(
name|krb5_store_int16
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_int16
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|krb5_data
name|d
decl_stmt|;
name|ret
operator|=
name|krb5_storage_to_data
argument_list|(
name|out
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|data
operator|->
name|data
operator|=
name|d
operator|.
name|data
expr_stmt|;
name|data
operator|->
name|length
operator|=
name|d
operator|.
name|length
expr_stmt|;
block|}
name|out
label|:
name|krb5_storage_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Decodes an NTLM targetinfo message  *  * @param data input data buffer with the encode NTLM targetinfo message  * @param ucs2 if the strings should be encoded with ucs2 (selected by flag in message).  * @param ti the decoded target info, should be freed with heim_ntlm_free_targetinfo().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_decode_targetinfo
parameter_list|(
specifier|const
name|struct
name|ntlm_buf
modifier|*
name|data
parameter_list|,
name|int
name|ucs2
parameter_list|,
name|struct
name|ntlm_targetinfo
modifier|*
name|ti
parameter_list|)
block|{
name|uint16_t
name|type
decl_stmt|,
name|len
decl_stmt|;
name|krb5_storage
modifier|*
name|in
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|ti
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ti
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|length
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|in
operator|=
name|krb5_storage_from_readonly_mem
argument_list|(
name|data
operator|->
name|data
argument_list|,
name|data
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|krb5_storage_set_byteorder
argument_list|(
name|in
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|CHECK
argument_list|(
name|krb5_ret_uint16
argument_list|(
name|in
argument_list|,
operator|&
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint16
argument_list|(
name|in
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0
case|:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|CHECK
argument_list|(
name|ret_string
argument_list|(
name|in
argument_list|,
name|ucs2
argument_list|,
name|len
argument_list|,
operator|&
name|ti
operator|->
name|servername
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|CHECK
argument_list|(
name|ret_string
argument_list|(
name|in
argument_list|,
name|ucs2
argument_list|,
name|len
argument_list|,
operator|&
name|ti
operator|->
name|domainname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|CHECK
argument_list|(
name|ret_string
argument_list|(
name|in
argument_list|,
name|ucs2
argument_list|,
name|len
argument_list|,
operator|&
name|ti
operator|->
name|dnsservername
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|CHECK
argument_list|(
name|ret_string
argument_list|(
name|in
argument_list|,
name|ucs2
argument_list|,
name|len
argument_list|,
operator|&
name|ti
operator|->
name|dnsdomainname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|CHECK
argument_list|(
name|ret_string
argument_list|(
name|in
argument_list|,
name|ucs2
argument_list|,
name|len
argument_list|,
operator|&
name|ti
operator|->
name|dnstreename
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|ti
operator|->
name|avflags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|krb5_storage_seek
argument_list|(
name|in
argument_list|,
name|len
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
if|if
condition|(
name|in
condition|)
name|krb5_storage_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Frees the ntlm_type1 message  *  * @param data message to be freed  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|void
name|heim_ntlm_free_type1
parameter_list|(
name|struct
name|ntlm_type1
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|->
name|domain
condition|)
name|free
argument_list|(
name|data
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|hostname
condition|)
name|free
argument_list|(
name|data
operator|->
name|hostname
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|heim_ntlm_decode_type1
parameter_list|(
specifier|const
name|struct
name|ntlm_buf
modifier|*
name|buf
parameter_list|,
name|struct
name|ntlm_type1
modifier|*
name|data
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|unsigned
name|char
name|sig
index|[
literal|8
index|]
decl_stmt|;
name|uint32_t
name|type
decl_stmt|;
name|struct
name|sec_buffer
name|domain
decl_stmt|,
name|hostname
decl_stmt|;
name|krb5_storage
modifier|*
name|in
decl_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
name|krb5_storage_from_readonly_mem
argument_list|(
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|krb5_storage_set_byteorder
argument_list|(
name|in
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|in
argument_list|,
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|memcmp
argument_list|(
name|ntlmsigature
argument_list|,
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|data
operator|->
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|NTLM_OEM_SUPPLIED_DOMAIN
condition|)
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|NTLM_OEM_SUPPLIED_WORKSTATION
condition|)
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|hostname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (domain.offset> 32) { 	CHECK(krb5_ret_uint32(in,&data->os[0]), 0); 	CHECK(krb5_ret_uint32(in,&data->os[1]), 0);     }
endif|#
directive|endif
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|NTLM_OEM_SUPPLIED_DOMAIN
condition|)
name|CHECK
argument_list|(
name|ret_sec_string
argument_list|(
name|in
argument_list|,
literal|0
argument_list|,
operator|&
name|domain
argument_list|,
operator|&
name|data
operator|->
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|NTLM_OEM_SUPPLIED_WORKSTATION
condition|)
name|CHECK
argument_list|(
name|ret_sec_string
argument_list|(
name|in
argument_list|,
literal|0
argument_list|,
operator|&
name|hostname
argument_list|,
operator|&
name|data
operator|->
name|hostname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|in
condition|)
name|krb5_storage_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|heim_ntlm_free_type1
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Encodes an ntlm_type1 message.  *  * @param type1 the ntlm_type1 message to encode.  * @param data is the return buffer with the encoded message, should be  * freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_encode_type1
parameter_list|(
specifier|const
name|struct
name|ntlm_type1
modifier|*
name|type1
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|data
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|struct
name|sec_buffer
name|domain
decl_stmt|,
name|hostname
decl_stmt|;
name|krb5_storage
modifier|*
name|out
decl_stmt|;
name|uint32_t
name|base
decl_stmt|,
name|flags
decl_stmt|;
name|flags
operator|=
name|type1
operator|->
name|flags
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|type1
operator|->
name|domain
condition|)
block|{
name|base
operator|+=
literal|8
expr_stmt|;
name|flags
operator||=
name|NTLM_OEM_SUPPLIED_DOMAIN
expr_stmt|;
block|}
if|if
condition|(
name|type1
operator|->
name|hostname
condition|)
block|{
name|base
operator|+=
literal|8
expr_stmt|;
name|flags
operator||=
name|NTLM_OEM_SUPPLIED_WORKSTATION
expr_stmt|;
block|}
if|if
condition|(
name|type1
operator|->
name|os
index|[
literal|0
index|]
condition|)
name|base
operator|+=
literal|8
expr_stmt|;
name|domain
operator|.
name|offset
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|type1
operator|->
name|domain
condition|)
block|{
name|domain
operator|.
name|length
operator|=
name|len_string
argument_list|(
literal|0
argument_list|,
name|type1
operator|->
name|domain
argument_list|)
expr_stmt|;
name|domain
operator|.
name|allocated
operator|=
name|domain
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|domain
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|domain
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
block|}
name|hostname
operator|.
name|offset
operator|=
name|domain
operator|.
name|allocated
operator|+
name|domain
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|type1
operator|->
name|hostname
condition|)
block|{
name|hostname
operator|.
name|length
operator|=
name|len_string
argument_list|(
literal|0
argument_list|,
name|type1
operator|->
name|hostname
argument_list|)
expr_stmt|;
name|hostname
operator|.
name|allocated
operator|=
name|hostname
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|hostname
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|hostname
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
block|}
name|out
operator|=
name|krb5_storage_emem
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|krb5_storage_set_byteorder
argument_list|(
name|out
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|out
argument_list|,
name|ntlmsigature
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|hostname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|CHECK(krb5_store_uint32(out, type1->os[0]), 0); 	CHECK(krb5_store_uint32(out, type1->os[1]), 0);
endif|#
directive|endif
if|if
condition|(
name|type1
operator|->
name|domain
condition|)
name|CHECK
argument_list|(
name|put_string
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
name|type1
operator|->
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|->
name|hostname
condition|)
name|CHECK
argument_list|(
name|put_string
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
name|type1
operator|->
name|hostname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|krb5_data
name|d
decl_stmt|;
name|ret
operator|=
name|krb5_storage_to_data
argument_list|(
name|out
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|data
operator|->
name|data
operator|=
name|d
operator|.
name|data
expr_stmt|;
name|data
operator|->
name|length
operator|=
name|d
operator|.
name|length
expr_stmt|;
block|}
name|out
label|:
name|krb5_storage_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Frees the ntlm_type2 message  *  * @param data message to be freed  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|void
name|heim_ntlm_free_type2
parameter_list|(
name|struct
name|ntlm_type2
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|->
name|targetname
condition|)
name|free
argument_list|(
name|data
operator|->
name|targetname
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
operator|&
name|data
operator|->
name|targetinfo
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|heim_ntlm_decode_type2
parameter_list|(
specifier|const
name|struct
name|ntlm_buf
modifier|*
name|buf
parameter_list|,
name|struct
name|ntlm_type2
modifier|*
name|type2
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|unsigned
name|char
name|sig
index|[
literal|8
index|]
decl_stmt|;
name|uint32_t
name|type
decl_stmt|,
name|ctx
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|sec_buffer
name|targetname
decl_stmt|,
name|targetinfo
decl_stmt|;
name|krb5_storage
modifier|*
name|in
decl_stmt|;
name|int
name|ucs2
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|type2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|type2
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
name|krb5_storage_from_readonly_mem
argument_list|(
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|krb5_storage_set_byteorder
argument_list|(
name|in
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|in
argument_list|,
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|memcmp
argument_list|(
name|ntlmsigature
argument_list|,
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|type
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|targetname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type2
operator|->
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type2
operator|->
name|flags
operator|&
name|NTLM_NEG_UNICODE
condition|)
name|ucs2
operator|=
literal|1
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|in
argument_list|,
name|type2
operator|->
name|challenge
argument_list|,
sizeof|sizeof
argument_list|(
name|type2
operator|->
name|challenge
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|type2
operator|->
name|challenge
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|ctx
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* context */
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|ctx
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|targetinfo
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* os version */
if|if
condition|(
name|type2
operator|->
name|flags
operator|&
name|NTLM_NEG_VERSION
condition|)
block|{
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type2
operator|->
name|os
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type2
operator|->
name|os
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|ret_sec_string
argument_list|(
name|in
argument_list|,
name|ucs2
argument_list|,
operator|&
name|targetname
argument_list|,
operator|&
name|type2
operator|->
name|targetname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_buf
argument_list|(
name|in
argument_list|,
operator|&
name|targetinfo
argument_list|,
operator|&
name|type2
operator|->
name|targetinfo
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|in
condition|)
name|krb5_storage_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|heim_ntlm_free_type2
argument_list|(
name|type2
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Encodes an ntlm_type2 message.  *  * @param type2 the ntlm_type2 message to encode.  * @param data is the return buffer with the encoded message, should be  * freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_encode_type2
parameter_list|(
specifier|const
name|struct
name|ntlm_type2
modifier|*
name|type2
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sec_buffer
name|targetname
decl_stmt|,
name|targetinfo
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_storage
modifier|*
name|out
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|base
decl_stmt|;
name|int
name|ucs2
init|=
literal|0
decl_stmt|;
name|base
operator|=
literal|48
expr_stmt|;
if|if
condition|(
name|type2
operator|->
name|flags
operator|&
name|NTLM_NEG_VERSION
condition|)
name|base
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|type2
operator|->
name|flags
operator|&
name|NTLM_NEG_UNICODE
condition|)
name|ucs2
operator|=
literal|1
expr_stmt|;
name|targetname
operator|.
name|offset
operator|=
name|base
expr_stmt|;
name|targetname
operator|.
name|length
operator|=
name|len_string
argument_list|(
name|ucs2
argument_list|,
name|type2
operator|->
name|targetname
argument_list|)
expr_stmt|;
name|targetname
operator|.
name|allocated
operator|=
name|targetname
operator|.
name|length
expr_stmt|;
name|targetinfo
operator|.
name|offset
operator|=
name|targetname
operator|.
name|allocated
operator|+
name|targetname
operator|.
name|offset
expr_stmt|;
name|targetinfo
operator|.
name|length
operator|=
name|type2
operator|->
name|targetinfo
operator|.
name|length
expr_stmt|;
name|targetinfo
operator|.
name|allocated
operator|=
name|type2
operator|->
name|targetinfo
operator|.
name|length
expr_stmt|;
name|out
operator|=
name|krb5_storage_emem
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|krb5_storage_set_byteorder
argument_list|(
name|out
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|out
argument_list|,
name|ntlmsigature
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|targetname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
name|type2
operator|->
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|out
argument_list|,
name|type2
operator|->
name|challenge
argument_list|,
sizeof|sizeof
argument_list|(
name|type2
operator|->
name|challenge
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|type2
operator|->
name|challenge
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* context */
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|targetinfo
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* os version */
if|if
condition|(
name|type2
operator|->
name|flags
operator|&
name|NTLM_NEG_VERSION
condition|)
block|{
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
name|type2
operator|->
name|os
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
name|type2
operator|->
name|os
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|put_string
argument_list|(
name|out
argument_list|,
name|ucs2
argument_list|,
name|type2
operator|->
name|targetname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|out
argument_list|,
name|type2
operator|->
name|targetinfo
operator|.
name|data
argument_list|,
name|type2
operator|->
name|targetinfo
operator|.
name|length
argument_list|)
argument_list|,
name|type2
operator|->
name|targetinfo
operator|.
name|length
argument_list|)
expr_stmt|;
block|{
name|krb5_data
name|d
decl_stmt|;
name|ret
operator|=
name|krb5_storage_to_data
argument_list|(
name|out
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|data
operator|->
name|data
operator|=
name|d
operator|.
name|data
expr_stmt|;
name|data
operator|->
name|length
operator|=
name|d
operator|.
name|length
expr_stmt|;
block|}
name|out
label|:
name|krb5_storage_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Frees the ntlm_type3 message  *  * @param data message to be freed  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|void
name|heim_ntlm_free_type3
parameter_list|(
name|struct
name|ntlm_type3
modifier|*
name|data
parameter_list|)
block|{
name|heim_ntlm_free_buf
argument_list|(
operator|&
name|data
operator|->
name|lm
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
operator|&
name|data
operator|->
name|ntlm
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|targetname
condition|)
name|free
argument_list|(
name|data
operator|->
name|targetname
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|username
condition|)
name|free
argument_list|(
name|data
operator|->
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|ws
condition|)
name|free
argument_list|(
name|data
operator|->
name|ws
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
operator|&
name|data
operator|->
name|sessionkey
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|int
name|heim_ntlm_decode_type3
parameter_list|(
specifier|const
name|struct
name|ntlm_buf
modifier|*
name|buf
parameter_list|,
name|int
name|ucs2
parameter_list|,
name|struct
name|ntlm_type3
modifier|*
name|type3
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|unsigned
name|char
name|sig
index|[
literal|8
index|]
decl_stmt|;
name|uint32_t
name|type
decl_stmt|;
name|krb5_storage
modifier|*
name|in
decl_stmt|;
name|struct
name|sec_buffer
name|lm
decl_stmt|,
name|ntlm
decl_stmt|,
name|target
decl_stmt|,
name|username
decl_stmt|,
name|sessionkey
decl_stmt|,
name|ws
decl_stmt|;
name|uint32_t
name|min_offset
init|=
literal|72
decl_stmt|;
name|memset
argument_list|(
name|type3
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|type3
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sessionkey
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sessionkey
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
name|krb5_storage_from_readonly_mem
argument_list|(
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|krb5_storage_set_byteorder
argument_list|(
name|in
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|in
argument_list|,
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|memcmp
argument_list|(
name|ntlmsigature
argument_list|,
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|type
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|lm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lm
operator|.
name|allocated
condition|)
name|min_offset
operator|=
name|min
argument_list|(
name|min_offset
argument_list|,
name|lm
operator|.
name|offset
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|ntlm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntlm
operator|.
name|allocated
condition|)
name|min_offset
operator|=
name|min
argument_list|(
name|min_offset
argument_list|,
name|ntlm
operator|.
name|offset
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|.
name|allocated
condition|)
name|min_offset
operator|=
name|min
argument_list|(
name|min_offset
argument_list|,
name|target
operator|.
name|offset
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|username
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|username
operator|.
name|allocated
condition|)
name|min_offset
operator|=
name|min
argument_list|(
name|min_offset
argument_list|,
name|username
operator|.
name|offset
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|ws
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|.
name|allocated
condition|)
name|min_offset
operator|=
name|min
argument_list|(
name|min_offset
argument_list|,
name|ws
operator|.
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_offset
operator|>
literal|52
condition|)
block|{
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|sessionkey
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|min_offset
operator|=
name|max
argument_list|(
name|min_offset
argument_list|,
name|sessionkey
operator|.
name|offset
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type3
operator|->
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|min_offset
operator|>
literal|52
operator|+
literal|8
operator|+
literal|4
operator|+
literal|8
condition|)
block|{
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type3
operator|->
name|os
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type3
operator|->
name|os
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|ret_buf
argument_list|(
name|in
argument_list|,
operator|&
name|lm
argument_list|,
operator|&
name|type3
operator|->
name|lm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_buf
argument_list|(
name|in
argument_list|,
operator|&
name|ntlm
argument_list|,
operator|&
name|type3
operator|->
name|ntlm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_string
argument_list|(
name|in
argument_list|,
name|ucs2
argument_list|,
operator|&
name|target
argument_list|,
operator|&
name|type3
operator|->
name|targetname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_string
argument_list|(
name|in
argument_list|,
name|ucs2
argument_list|,
operator|&
name|username
argument_list|,
operator|&
name|type3
operator|->
name|username
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_string
argument_list|(
name|in
argument_list|,
name|ucs2
argument_list|,
operator|&
name|ws
argument_list|,
operator|&
name|type3
operator|->
name|ws
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sessionkey
operator|.
name|offset
condition|)
name|CHECK
argument_list|(
name|ret_buf
argument_list|(
name|in
argument_list|,
operator|&
name|sessionkey
argument_list|,
operator|&
name|type3
operator|->
name|sessionkey
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|in
condition|)
name|krb5_storage_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|heim_ntlm_free_type3
argument_list|(
name|type3
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Encodes an ntlm_type3 message.  *  * @param type3 the ntlm_type3 message to encode.  * @param data is the return buffer with the encoded message, should be  * freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_encode_type3
parameter_list|(
specifier|const
name|struct
name|ntlm_type3
modifier|*
name|type3
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sec_buffer
name|lm
decl_stmt|,
name|ntlm
decl_stmt|,
name|target
decl_stmt|,
name|username
decl_stmt|,
name|sessionkey
decl_stmt|,
name|ws
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_storage
modifier|*
name|out
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|base
decl_stmt|;
name|int
name|ucs2
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|lm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lm
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ntlm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlm
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|target
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|username
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|username
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ws
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ws
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sessionkey
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sessionkey
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
literal|52
expr_stmt|;
name|base
operator|+=
literal|8
expr_stmt|;
comment|/* sessionkey sec buf */
name|base
operator|+=
literal|4
expr_stmt|;
comment|/* flags */
if|if
condition|(
name|type3
operator|->
name|os
index|[
literal|0
index|]
condition|)
block|{
name|base
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|type3
operator|->
name|flags
operator|&
name|NTLM_NEG_UNICODE
condition|)
name|ucs2
operator|=
literal|1
expr_stmt|;
name|target
operator|.
name|offset
operator|=
name|base
expr_stmt|;
name|target
operator|.
name|length
operator|=
name|len_string
argument_list|(
name|ucs2
argument_list|,
name|type3
operator|->
name|targetname
argument_list|)
expr_stmt|;
name|target
operator|.
name|allocated
operator|=
name|target
operator|.
name|length
expr_stmt|;
name|username
operator|.
name|offset
operator|=
name|target
operator|.
name|offset
operator|+
name|target
operator|.
name|allocated
expr_stmt|;
name|username
operator|.
name|length
operator|=
name|len_string
argument_list|(
name|ucs2
argument_list|,
name|type3
operator|->
name|username
argument_list|)
expr_stmt|;
name|username
operator|.
name|allocated
operator|=
name|username
operator|.
name|length
expr_stmt|;
name|ws
operator|.
name|offset
operator|=
name|username
operator|.
name|offset
operator|+
name|username
operator|.
name|allocated
expr_stmt|;
name|ws
operator|.
name|length
operator|=
name|len_string
argument_list|(
name|ucs2
argument_list|,
name|type3
operator|->
name|ws
argument_list|)
expr_stmt|;
name|ws
operator|.
name|allocated
operator|=
name|ws
operator|.
name|length
expr_stmt|;
name|lm
operator|.
name|offset
operator|=
name|ws
operator|.
name|offset
operator|+
name|ws
operator|.
name|allocated
expr_stmt|;
name|lm
operator|.
name|length
operator|=
name|type3
operator|->
name|lm
operator|.
name|length
expr_stmt|;
name|lm
operator|.
name|allocated
operator|=
name|type3
operator|->
name|lm
operator|.
name|length
expr_stmt|;
name|ntlm
operator|.
name|offset
operator|=
name|lm
operator|.
name|offset
operator|+
name|lm
operator|.
name|allocated
expr_stmt|;
name|ntlm
operator|.
name|length
operator|=
name|type3
operator|->
name|ntlm
operator|.
name|length
expr_stmt|;
name|ntlm
operator|.
name|allocated
operator|=
name|ntlm
operator|.
name|length
expr_stmt|;
name|sessionkey
operator|.
name|offset
operator|=
name|ntlm
operator|.
name|offset
operator|+
name|ntlm
operator|.
name|allocated
expr_stmt|;
name|sessionkey
operator|.
name|length
operator|=
name|type3
operator|->
name|sessionkey
operator|.
name|length
expr_stmt|;
name|sessionkey
operator|.
name|allocated
operator|=
name|type3
operator|->
name|sessionkey
operator|.
name|length
expr_stmt|;
name|out
operator|=
name|krb5_storage_emem
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|krb5_storage_set_byteorder
argument_list|(
name|out
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|out
argument_list|,
name|ntlmsigature
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
literal|3
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|lm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|ntlm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|username
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|ws
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|sessionkey
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
name|type3
operator|->
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|CHECK(krb5_store_uint32(out, 0), 0);
comment|/* os0 */
block|CHECK(krb5_store_uint32(out, 0), 0);
comment|/* os1 */
endif|#
directive|endif
name|CHECK
argument_list|(
name|put_string
argument_list|(
name|out
argument_list|,
name|ucs2
argument_list|,
name|type3
operator|->
name|targetname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|put_string
argument_list|(
name|out
argument_list|,
name|ucs2
argument_list|,
name|type3
operator|->
name|username
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|put_string
argument_list|(
name|out
argument_list|,
name|ucs2
argument_list|,
name|type3
operator|->
name|ws
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|put_buf
argument_list|(
name|out
argument_list|,
operator|&
name|type3
operator|->
name|lm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|put_buf
argument_list|(
name|out
argument_list|,
operator|&
name|type3
operator|->
name|ntlm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|put_buf
argument_list|(
name|out
argument_list|,
operator|&
name|type3
operator|->
name|sessionkey
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|krb5_data
name|d
decl_stmt|;
name|ret
operator|=
name|krb5_storage_to_data
argument_list|(
name|out
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|data
operator|->
name|data
operator|=
name|d
operator|.
name|data
expr_stmt|;
name|data
operator|->
name|length
operator|=
name|d
operator|.
name|length
expr_stmt|;
block|}
name|out
label|:
name|krb5_storage_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|splitandenc
parameter_list|(
name|unsigned
name|char
modifier|*
name|hash
parameter_list|,
name|unsigned
name|char
modifier|*
name|challenge
parameter_list|,
name|unsigned
name|char
modifier|*
name|answer
parameter_list|)
block|{
name|EVP_CIPHER_CTX
name|ctx
decl_stmt|;
name|unsigned
name|char
name|key
index|[
literal|8
index|]
decl_stmt|;
name|key
index|[
literal|0
index|]
operator|=
name|hash
index|[
literal|0
index|]
expr_stmt|;
name|key
index|[
literal|1
index|]
operator|=
operator|(
name|hash
index|[
literal|0
index|]
operator|<<
literal|7
operator|)
operator||
operator|(
name|hash
index|[
literal|1
index|]
operator|>>
literal|1
operator|)
expr_stmt|;
name|key
index|[
literal|2
index|]
operator|=
operator|(
name|hash
index|[
literal|1
index|]
operator|<<
literal|6
operator|)
operator||
operator|(
name|hash
index|[
literal|2
index|]
operator|>>
literal|2
operator|)
expr_stmt|;
name|key
index|[
literal|3
index|]
operator|=
operator|(
name|hash
index|[
literal|2
index|]
operator|<<
literal|5
operator|)
operator||
operator|(
name|hash
index|[
literal|3
index|]
operator|>>
literal|3
operator|)
expr_stmt|;
name|key
index|[
literal|4
index|]
operator|=
operator|(
name|hash
index|[
literal|3
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|hash
index|[
literal|4
index|]
operator|>>
literal|4
operator|)
expr_stmt|;
name|key
index|[
literal|5
index|]
operator|=
operator|(
name|hash
index|[
literal|4
index|]
operator|<<
literal|3
operator|)
operator||
operator|(
name|hash
index|[
literal|5
index|]
operator|>>
literal|5
operator|)
expr_stmt|;
name|key
index|[
literal|6
index|]
operator|=
operator|(
name|hash
index|[
literal|5
index|]
operator|<<
literal|2
operator|)
operator||
operator|(
name|hash
index|[
literal|6
index|]
operator|>>
literal|6
operator|)
expr_stmt|;
name|key
index|[
literal|7
index|]
operator|=
operator|(
name|hash
index|[
literal|6
index|]
operator|<<
literal|1
operator|)
expr_stmt|;
name|EVP_CIPHER_CTX_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|EVP_CipherInit_ex
argument_list|(
operator|&
name|ctx
argument_list|,
name|EVP_des_cbc
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|EVP_Cipher
argument_list|(
operator|&
name|ctx
argument_list|,
name|answer
argument_list|,
name|challenge
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Calculate the NTLM key, the password is assumed to be in UTF8.  *  * @param password password to calcute the key for.  * @param key calcuted key, should be freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_nt_key
parameter_list|(
specifier|const
name|char
modifier|*
name|password
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|ntlm_buf
name|buf
decl_stmt|;
name|EVP_MD_CTX
modifier|*
name|m
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|key
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|MD5_DIGEST_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|data
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|key
operator|->
name|length
operator|=
name|MD5_DIGEST_LENGTH
expr_stmt|;
name|ret
operator|=
name|ascii2ucs2le
argument_list|(
name|password
argument_list|,
literal|0
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|heim_ntlm_free_buf
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|m
operator|=
name|EVP_MD_CTX_create
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|heim_ntlm_free_buf
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|EVP_DigestInit_ex
argument_list|(
name|m
argument_list|,
name|EVP_md4
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
name|m
argument_list|,
name|buf
operator|.
name|data
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|EVP_DigestFinal_ex
argument_list|(
name|m
argument_list|,
name|key
operator|->
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_destroy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Calculate NTLMv1 response hash  *  * @param key the ntlm v1 key  * @param len length of key  * @param challenge sent by the server  * @param answer calculated answer, should be freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_calculate_ntlm1
parameter_list|(
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
name|challenge
index|[
literal|8
index|]
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|answer
parameter_list|)
block|{
name|unsigned
name|char
name|res
index|[
literal|21
index|]
decl_stmt|;
if|if
condition|(
name|len
operator|!=
name|MD4_DIGEST_LENGTH
condition|)
return|return
name|HNTLM_ERR_INVALID_LENGTH
return|;
name|memcpy
argument_list|(
name|res
argument_list|,
name|key
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|res
index|[
name|MD4_DIGEST_LENGTH
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
operator|-
name|MD4_DIGEST_LENGTH
argument_list|)
expr_stmt|;
name|answer
operator|->
name|data
operator|=
name|malloc
argument_list|(
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|->
name|data
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|answer
operator|->
name|length
operator|=
literal|24
expr_stmt|;
name|splitandenc
argument_list|(
operator|&
name|res
index|[
literal|0
index|]
argument_list|,
name|challenge
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|answer
operator|->
name|data
operator|)
operator|+
literal|0
argument_list|)
expr_stmt|;
name|splitandenc
argument_list|(
operator|&
name|res
index|[
literal|7
index|]
argument_list|,
name|challenge
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|answer
operator|->
name|data
operator|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|splitandenc
argument_list|(
operator|&
name|res
index|[
literal|14
index|]
argument_list|,
name|challenge
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|answer
operator|->
name|data
operator|)
operator|+
literal|16
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|heim_ntlm_v1_base_session
parameter_list|(
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|session
parameter_list|)
block|{
name|EVP_MD_CTX
modifier|*
name|m
decl_stmt|;
name|session
operator|->
name|length
operator|=
name|MD4_DIGEST_LENGTH
expr_stmt|;
name|session
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|session
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|session
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|session
operator|->
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|m
operator|=
name|EVP_MD_CTX_create
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|heim_ntlm_free_buf
argument_list|(
name|session
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|EVP_DigestInit_ex
argument_list|(
name|m
argument_list|,
name|EVP_md4
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
name|m
argument_list|,
name|key
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EVP_DigestFinal_ex
argument_list|(
name|m
argument_list|,
name|session
operator|->
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_destroy
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|heim_ntlm_v2_base_session
parameter_list|(
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|ntlmResponse
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|session
parameter_list|)
block|{
name|unsigned
name|int
name|hmaclen
decl_stmt|;
name|HMAC_CTX
name|c
decl_stmt|;
if|if
condition|(
name|ntlmResponse
operator|->
name|length
operator|<=
literal|16
condition|)
return|return
name|HNTLM_ERR_INVALID_LENGTH
return|;
name|session
operator|->
name|data
operator|=
name|malloc
argument_list|(
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|session
operator|->
name|data
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|session
operator|->
name|length
operator|=
literal|16
expr_stmt|;
comment|/* Note: key is the NTLMv2 key */
name|HMAC_CTX_init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|HMAC_Init_ex
argument_list|(
operator|&
name|c
argument_list|,
name|key
argument_list|,
name|len
argument_list|,
name|EVP_md5
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|HMAC_Update
argument_list|(
operator|&
name|c
argument_list|,
name|ntlmResponse
operator|->
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|HMAC_Final
argument_list|(
operator|&
name|c
argument_list|,
name|session
operator|->
name|data
argument_list|,
operator|&
name|hmaclen
argument_list|)
expr_stmt|;
name|HMAC_CTX_cleanup
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|heim_ntlm_keyex_wrap
parameter_list|(
name|struct
name|ntlm_buf
modifier|*
name|base_session
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|session
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|encryptedSession
parameter_list|)
block|{
name|EVP_CIPHER_CTX
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|session
operator|->
name|length
operator|=
name|MD4_DIGEST_LENGTH
expr_stmt|;
name|session
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|session
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|session
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|session
operator|->
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|encryptedSession
operator|->
name|length
operator|=
name|MD4_DIGEST_LENGTH
expr_stmt|;
name|encryptedSession
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|encryptedSession
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|encryptedSession
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|heim_ntlm_free_buf
argument_list|(
name|session
argument_list|)
expr_stmt|;
name|encryptedSession
operator|->
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|EVP_CIPHER_CTX_init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EVP_CipherInit_ex
argument_list|(
operator|&
name|c
argument_list|,
name|EVP_rc4
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|base_session
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
block|{
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
name|encryptedSession
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
name|session
argument_list|)
expr_stmt|;
return|return
name|HNTLM_ERR_CRYPTO
return|;
block|}
if|if
condition|(
name|RAND_bytes
argument_list|(
name|session
operator|->
name|data
argument_list|,
name|session
operator|->
name|length
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
name|encryptedSession
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
name|session
argument_list|)
expr_stmt|;
return|return
name|HNTLM_ERR_RAND
return|;
block|}
name|EVP_Cipher
argument_list|(
operator|&
name|c
argument_list|,
name|encryptedSession
operator|->
name|data
argument_list|,
name|session
operator|->
name|data
argument_list|,
name|encryptedSession
operator|->
name|length
argument_list|)
expr_stmt|;
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Generates an NTLMv1 session random with assosited session master key.  *  * @param key the ntlm v1 key  * @param len length of key  * @param session generated session nonce, should be freed with heim_ntlm_free_buf().  * @param master calculated session master key, should be freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_build_ntlm1_master
parameter_list|(
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|session
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|master
parameter_list|)
block|{
name|struct
name|ntlm_buf
name|sess
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|heim_ntlm_v1_base_session
argument_list|(
name|key
argument_list|,
name|len
argument_list|,
operator|&
name|sess
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|heim_ntlm_keyex_wrap
argument_list|(
operator|&
name|sess
argument_list|,
name|session
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
operator|&
name|sess
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Generates an NTLMv2 session random with associated session master key.  *  * @param key the NTLMv2 key  * @param len length of key  * @param blob the NTLMv2 "blob"  * @param session generated session nonce, should be freed with heim_ntlm_free_buf().  * @param master calculated session master key, should be freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_build_ntlm2_master
parameter_list|(
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|blob
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|session
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|master
parameter_list|)
block|{
name|struct
name|ntlm_buf
name|sess
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|heim_ntlm_v2_base_session
argument_list|(
name|key
argument_list|,
name|len
argument_list|,
name|blob
argument_list|,
operator|&
name|sess
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|heim_ntlm_keyex_wrap
argument_list|(
operator|&
name|sess
argument_list|,
name|session
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
operator|&
name|sess
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Given a key and encrypted session, unwrap the session key  *  * @param baseKey the sessionBaseKey  * @param encryptedSession encrypted session, type3.session field.  * @param session generated session nonce, should be freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_keyex_unwrap
parameter_list|(
name|struct
name|ntlm_buf
modifier|*
name|baseKey
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|encryptedSession
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|session
parameter_list|)
block|{
name|EVP_CIPHER_CTX
name|c
decl_stmt|;
name|memset
argument_list|(
name|session
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|session
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|baseKey
operator|->
name|length
operator|!=
name|MD4_DIGEST_LENGTH
condition|)
return|return
name|HNTLM_ERR_INVALID_LENGTH
return|;
name|session
operator|->
name|length
operator|=
name|MD4_DIGEST_LENGTH
expr_stmt|;
name|session
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|session
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|session
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|session
operator|->
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|EVP_CIPHER_CTX_init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_CipherInit_ex
argument_list|(
operator|&
name|c
argument_list|,
name|EVP_rc4
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|baseKey
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
name|session
argument_list|)
expr_stmt|;
return|return
name|HNTLM_ERR_CRYPTO
return|;
block|}
name|EVP_Cipher
argument_list|(
operator|&
name|c
argument_list|,
name|session
operator|->
name|data
argument_list|,
name|encryptedSession
operator|->
name|data
argument_list|,
name|session
operator|->
name|length
argument_list|)
expr_stmt|;
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Generates an NTLMv2 session key.  *  * @param key the ntlm key  * @param len length of key  * @param username name of the user, as sent in the message, assumed to be in UTF8.  * @param target the name of the target, assumed to be in UTF8.  * @param ntlmv2 the ntlmv2 session key  *  * @return 0 on success, or an error code on failure.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_ntlmv2_key
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|unsigned
name|char
name|ntlmv2
index|[
literal|16
index|]
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|int
name|hmaclen
decl_stmt|;
name|HMAC_CTX
name|c
decl_stmt|;
name|HMAC_CTX_init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|HMAC_Init_ex
argument_list|(
operator|&
name|c
argument_list|,
name|key
argument_list|,
name|len
argument_list|,
name|EVP_md5
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|{
name|struct
name|ntlm_buf
name|buf
decl_stmt|;
comment|/* uppercase username and turn it into ucs2-le */
name|ret
operator|=
name|ascii2ucs2le
argument_list|(
name|username
argument_list|,
literal|1
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|HMAC_Update
argument_list|(
operator|&
name|c
argument_list|,
name|buf
operator|.
name|data
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
operator|.
name|data
argument_list|)
expr_stmt|;
comment|/* uppercase target and turn into ucs2-le */
name|ret
operator|=
name|ascii2ucs2le
argument_list|(
name|target
argument_list|,
literal|1
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|HMAC_Update
argument_list|(
operator|&
name|c
argument_list|,
name|buf
operator|.
name|data
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
name|HMAC_Final
argument_list|(
operator|&
name|c
argument_list|,
name|ntlmv2
argument_list|,
operator|&
name|hmaclen
argument_list|)
expr_stmt|;
name|out
label|:
name|HMAC_CTX_cleanup
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_define
define|#
directive|define
name|NTTIME_EPOCH
value|0x019DB1DED53E8000LL
end_define

begin_function
specifier|static
name|uint64_t
name|unix2nttime
parameter_list|(
name|time_t
name|unix_time
parameter_list|)
block|{
name|long
name|long
name|wt
decl_stmt|;
name|wt
operator|=
name|unix_time
operator|*
operator|(
name|uint64_t
operator|)
literal|10000000
operator|+
operator|(
name|uint64_t
operator|)
name|NTTIME_EPOCH
expr_stmt|;
return|return
name|wt
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|nt2unixtime
parameter_list|(
name|uint64_t
name|t
parameter_list|)
block|{
name|t
operator|=
operator|(
operator|(
name|t
operator|-
operator|(
name|uint64_t
operator|)
name|NTTIME_EPOCH
operator|)
operator|/
operator|(
name|uint64_t
operator|)
literal|10000000
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|>
operator|(
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|time_t
argument_list|)
argument_list|(
operator|~
operator|(
name|uint64_t
operator|)
literal|0
argument_list|)
operator|)
operator|>>
literal|1
operator|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|time_t
operator|)
name|t
return|;
block|}
end_function

begin_comment
comment|/**  * Calculate LMv2 response  *  * @param key the ntlm key  * @param len length of key  * @param username name of the user, as sent in the message, assumed to be in UTF8.  * @param target the name of the target, assumed to be in UTF8.  * @param serverchallenge challenge as sent by the server in the type2 message.  * @param ntlmv2 calculated session key  * @param answer ntlm response answer, should be freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_calculate_lm2
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
specifier|const
name|unsigned
name|char
name|serverchallenge
index|[
literal|8
index|]
parameter_list|,
name|unsigned
name|char
name|ntlmv2
index|[
literal|16
index|]
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|answer
parameter_list|)
block|{
name|unsigned
name|char
name|clientchallenge
index|[
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|RAND_bytes
argument_list|(
name|clientchallenge
argument_list|,
sizeof|sizeof
argument_list|(
name|clientchallenge
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|HNTLM_ERR_RAND
return|;
comment|/* calculate ntlmv2 key */
name|heim_ntlm_ntlmv2_key
argument_list|(
name|key
argument_list|,
name|len
argument_list|,
name|username
argument_list|,
name|target
argument_list|,
name|ntlmv2
argument_list|)
expr_stmt|;
name|answer
operator|->
name|data
operator|=
name|malloc
argument_list|(
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|->
name|data
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|answer
operator|->
name|length
operator|=
literal|24
expr_stmt|;
name|heim_ntlm_derive_ntlm2_sess
argument_list|(
name|ntlmv2
argument_list|,
name|clientchallenge
argument_list|,
literal|8
argument_list|,
name|serverchallenge
argument_list|,
name|answer
operator|->
name|data
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|answer
operator|->
name|data
operator|)
operator|+
literal|16
argument_list|,
name|clientchallenge
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Calculate NTLMv2 response  *  * @param key the ntlm key  * @param len length of key  * @param username name of the user, as sent in the message, assumed to be in UTF8.  * @param target the name of the target, assumed to be in UTF8.  * @param serverchallenge challenge as sent by the server in the type2 message.  * @param infotarget infotarget as sent by the server in the type2 message.  * @param ntlmv2 calculated session key  * @param answer ntlm response answer, should be freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_calculate_ntlm2
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
specifier|const
name|unsigned
name|char
name|serverchallenge
index|[
literal|8
index|]
parameter_list|,
specifier|const
name|struct
name|ntlm_buf
modifier|*
name|infotarget
parameter_list|,
name|unsigned
name|char
name|ntlmv2
index|[
literal|16
index|]
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|answer
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_data
name|data
decl_stmt|;
name|unsigned
name|char
name|ntlmv2answer
index|[
literal|16
index|]
decl_stmt|;
name|krb5_storage
modifier|*
name|sp
decl_stmt|;
name|unsigned
name|char
name|clientchallenge
index|[
literal|8
index|]
decl_stmt|;
name|uint64_t
name|t
decl_stmt|;
name|t
operator|=
name|unix2nttime
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RAND_bytes
argument_list|(
name|clientchallenge
argument_list|,
sizeof|sizeof
argument_list|(
name|clientchallenge
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|HNTLM_ERR_RAND
return|;
comment|/* calculate ntlmv2 key */
name|heim_ntlm_ntlmv2_key
argument_list|(
name|key
argument_list|,
name|len
argument_list|,
name|username
argument_list|,
name|target
argument_list|,
name|ntlmv2
argument_list|)
expr_stmt|;
comment|/* calculate and build ntlmv2 answer */
name|sp
operator|=
name|krb5_storage_emem
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|krb5_storage_set_flags
argument_list|(
name|sp
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|sp
argument_list|,
literal|0x00000101
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* timestamp le 64 bit ts */
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|sp
argument_list|,
name|t
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|sp
argument_list|,
name|t
operator|>>
literal|32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|sp
argument_list|,
name|clientchallenge
argument_list|,
literal|8
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unknown but zero will work */
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|sp
argument_list|,
name|infotarget
operator|->
name|data
argument_list|,
name|infotarget
operator|->
name|length
argument_list|)
argument_list|,
name|infotarget
operator|->
name|length
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unknown but zero will work */
name|CHECK
argument_list|(
name|krb5_storage_to_data
argument_list|(
name|sp
argument_list|,
operator|&
name|data
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|krb5_storage_free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|NULL
expr_stmt|;
name|heim_ntlm_derive_ntlm2_sess
argument_list|(
name|ntlmv2
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|length
argument_list|,
name|serverchallenge
argument_list|,
name|ntlmv2answer
argument_list|)
expr_stmt|;
name|sp
operator|=
name|krb5_storage_emem
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|krb5_data_free
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|sp
argument_list|,
name|ntlmv2answer
argument_list|,
literal|16
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|sp
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|length
argument_list|)
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|krb5_data_free
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_to_data
argument_list|(
name|sp
argument_list|,
operator|&
name|data
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|krb5_storage_free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|NULL
expr_stmt|;
name|answer
operator|->
name|data
operator|=
name|data
operator|.
name|data
expr_stmt|;
name|answer
operator|->
name|length
operator|=
name|data
operator|.
name|length
expr_stmt|;
return|return
literal|0
return|;
name|out
label|:
if|if
condition|(
name|sp
condition|)
name|krb5_storage_free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|int
name|authtimediff
init|=
literal|3600
operator|*
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2 hours */
end_comment

begin_comment
comment|/**  * Verify NTLMv2 response.  *  * @param key the ntlm key  * @param len length of key  * @param username name of the user, as sent in the message, assumed to be in UTF8.  * @param target the name of the target, assumed to be in UTF8.  * @param now the time now (0 if the library should pick it up itself)  * @param serverchallenge challenge as sent by the server in the type2 message.  * @param answer ntlm response answer, should be freed with heim_ntlm_free_buf().  * @param infotarget infotarget as sent by the server in the type2 message.  * @param ntlmv2 calculated session key  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_verify_ntlm2
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|time_t
name|now
parameter_list|,
specifier|const
name|unsigned
name|char
name|serverchallenge
index|[
literal|8
index|]
parameter_list|,
specifier|const
name|struct
name|ntlm_buf
modifier|*
name|answer
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|infotarget
parameter_list|,
name|unsigned
name|char
name|ntlmv2
index|[
literal|16
index|]
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|unsigned
name|char
name|clientanswer
index|[
literal|16
index|]
decl_stmt|;
name|unsigned
name|char
name|clientnonce
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|char
name|serveranswer
index|[
literal|16
index|]
decl_stmt|;
name|krb5_storage
modifier|*
name|sp
decl_stmt|;
name|time_t
name|authtime
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint64_t
name|t
decl_stmt|;
name|infotarget
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|infotarget
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|answer
operator|->
name|length
operator|<
literal|16
condition|)
return|return
name|HNTLM_ERR_INVALID_LENGTH
return|;
if|if
condition|(
name|now
operator|==
literal|0
condition|)
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* calculate ntlmv2 key */
name|heim_ntlm_ntlmv2_key
argument_list|(
name|key
argument_list|,
name|len
argument_list|,
name|username
argument_list|,
name|target
argument_list|,
name|ntlmv2
argument_list|)
expr_stmt|;
comment|/* calculate and build ntlmv2 answer */
name|sp
operator|=
name|krb5_storage_from_readonly_mem
argument_list|(
name|answer
operator|->
name|data
argument_list|,
name|answer
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|krb5_storage_set_flags
argument_list|(
name|sp
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|sp
argument_list|,
name|clientanswer
argument_list|,
literal|16
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|sp
argument_list|,
operator|&
name|temp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|temp
argument_list|,
literal|0x00000101
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|sp
argument_list|,
operator|&
name|temp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* timestamp le 64 bit ts */
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|sp
argument_list|,
operator|&
name|temp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|temp
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|sp
argument_list|,
operator|&
name|temp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|temp
operator|)
operator|<<
literal|32
expr_stmt|;
name|authtime
operator|=
name|nt2unixtime
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|authtime
operator|-
name|now
argument_list|)
argument_list|)
operator|>
name|authtimediff
condition|)
block|{
name|ret
operator|=
name|HNTLM_ERR_TIME_SKEW
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* client challenge */
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|sp
argument_list|,
name|clientnonce
argument_list|,
literal|8
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|sp
argument_list|,
operator|&
name|temp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unknown */
comment|/* should really unparse the infotarget, but lets pick up everything */
name|infotarget
operator|->
name|length
operator|=
name|answer
operator|->
name|length
operator|-
name|krb5_storage_seek
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|infotarget
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|infotarget
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|infotarget
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|sp
argument_list|,
name|infotarget
operator|->
name|data
argument_list|,
name|infotarget
operator|->
name|length
argument_list|)
argument_list|,
name|infotarget
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* XXX remove the unknown ?? */
name|krb5_storage_free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|answer
operator|->
name|length
operator|<
literal|16
condition|)
block|{
name|ret
operator|=
name|HNTLM_ERR_INVALID_LENGTH
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|heim_ntlm_derive_ntlm2_sess
argument_list|(
name|ntlmv2
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|answer
operator|->
name|data
operator|)
operator|+
literal|16
argument_list|,
name|answer
operator|->
name|length
operator|-
literal|16
argument_list|,
name|serverchallenge
argument_list|,
name|serveranswer
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|serveranswer
argument_list|,
name|clientanswer
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|heim_ntlm_free_buf
argument_list|(
name|infotarget
argument_list|)
expr_stmt|;
return|return
name|HNTLM_ERR_AUTH
return|;
block|}
return|return
literal|0
return|;
name|out
label|:
name|heim_ntlm_free_buf
argument_list|(
name|infotarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
name|krb5_storage_free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the NTLM2 Session Response  *  * @param clnt_nonce client nonce  * @param svr_chal server challage  * @param ntlm2_hash ntlm hash  * @param lm The LM response, should be freed with heim_ntlm_free_buf().  * @param ntlm The NTLM response, should be freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_calculate_ntlm2_sess
parameter_list|(
specifier|const
name|unsigned
name|char
name|clnt_nonce
index|[
literal|8
index|]
parameter_list|,
specifier|const
name|unsigned
name|char
name|svr_chal
index|[
literal|8
index|]
parameter_list|,
specifier|const
name|unsigned
name|char
name|ntlm_hash
index|[
literal|16
index|]
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|lm
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|ntlm
parameter_list|)
block|{
name|unsigned
name|char
name|ntlm2_sess_hash
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|char
name|res
index|[
literal|21
index|]
decl_stmt|,
modifier|*
name|resp
decl_stmt|;
name|int
name|code
decl_stmt|;
name|code
operator|=
name|heim_ntlm_calculate_ntlm2_sess_hash
argument_list|(
name|clnt_nonce
argument_list|,
name|svr_chal
argument_list|,
name|ntlm2_sess_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
block|{
return|return
name|code
return|;
block|}
name|lm
operator|->
name|data
operator|=
name|malloc
argument_list|(
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|lm
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
name|lm
operator|->
name|length
operator|=
literal|24
expr_stmt|;
name|ntlm
operator|->
name|data
operator|=
name|malloc
argument_list|(
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntlm
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|lm
operator|->
name|data
argument_list|)
expr_stmt|;
name|lm
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|ntlm
operator|->
name|length
operator|=
literal|24
expr_stmt|;
comment|/* first setup the lm resp */
name|memset
argument_list|(
name|lm
operator|->
name|data
argument_list|,
literal|0
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lm
operator|->
name|data
argument_list|,
name|clnt_nonce
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|res
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
argument_list|,
name|ntlm_hash
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|resp
operator|=
name|ntlm
operator|->
name|data
expr_stmt|;
name|splitandenc
argument_list|(
operator|&
name|res
index|[
literal|0
index|]
argument_list|,
name|ntlm2_sess_hash
argument_list|,
name|resp
operator|+
literal|0
argument_list|)
expr_stmt|;
name|splitandenc
argument_list|(
operator|&
name|res
index|[
literal|7
index|]
argument_list|,
name|ntlm2_sess_hash
argument_list|,
name|resp
operator|+
literal|8
argument_list|)
expr_stmt|;
name|splitandenc
argument_list|(
operator|&
name|res
index|[
literal|14
index|]
argument_list|,
name|ntlm2_sess_hash
argument_list|,
name|resp
operator|+
literal|16
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the NTLM2 Session "Verifier"  *  * @param clnt_nonce client nonce  * @param svr_chal server challage  * @param hash The NTLM session verifier  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_calculate_ntlm2_sess_hash
parameter_list|(
specifier|const
name|unsigned
name|char
name|clnt_nonce
index|[
literal|8
index|]
parameter_list|,
specifier|const
name|unsigned
name|char
name|svr_chal
index|[
literal|8
index|]
parameter_list|,
name|unsigned
name|char
name|verifier
index|[
literal|8
index|]
parameter_list|)
block|{
name|unsigned
name|char
name|ntlm2_sess_hash
index|[
name|MD5_DIGEST_LENGTH
index|]
decl_stmt|;
name|EVP_MD_CTX
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|EVP_MD_CTX_create
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|EVP_DigestInit_ex
argument_list|(
name|m
argument_list|,
name|EVP_md5
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
name|m
argument_list|,
name|svr_chal
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* session nonce part 1 */
name|EVP_DigestUpdate
argument_list|(
name|m
argument_list|,
name|clnt_nonce
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* session nonce part 2 */
name|EVP_DigestFinal_ex
argument_list|(
name|m
argument_list|,
name|ntlm2_sess_hash
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* will only use first 8 bytes */
name|EVP_MD_CTX_destroy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|verifier
argument_list|,
name|ntlm2_sess_hash
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Derive a NTLM2 session key  *  * @param sessionkey session key from domain controller  * @param clnt_nonce client nonce  * @param svr_chal server challenge  * @param derivedkey salted session key  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|void
name|heim_ntlm_derive_ntlm2_sess
parameter_list|(
specifier|const
name|unsigned
name|char
name|sessionkey
index|[
literal|16
index|]
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|clnt_nonce
parameter_list|,
name|size_t
name|clnt_nonce_length
parameter_list|,
specifier|const
name|unsigned
name|char
name|svr_chal
index|[
literal|8
index|]
parameter_list|,
name|unsigned
name|char
name|derivedkey
index|[
literal|16
index|]
parameter_list|)
block|{
name|unsigned
name|int
name|hmaclen
decl_stmt|;
name|HMAC_CTX
name|c
decl_stmt|;
comment|/* HMAC(Ksession, serverchallenge || clientchallenge) */
name|HMAC_CTX_init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|HMAC_Init_ex
argument_list|(
operator|&
name|c
argument_list|,
name|sessionkey
argument_list|,
literal|16
argument_list|,
name|EVP_md5
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|HMAC_Update
argument_list|(
operator|&
name|c
argument_list|,
name|svr_chal
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|HMAC_Update
argument_list|(
operator|&
name|c
argument_list|,
name|clnt_nonce
argument_list|,
name|clnt_nonce_length
argument_list|)
expr_stmt|;
name|HMAC_Final
argument_list|(
operator|&
name|c
argument_list|,
name|derivedkey
argument_list|,
operator|&
name|hmaclen
argument_list|)
expr_stmt|;
name|HMAC_CTX_cleanup
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

