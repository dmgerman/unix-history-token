begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997 - 2008 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"krb5_locl.h"
end_include

begin_struct
struct|struct
name|_krb5_key_usage
block|{
name|unsigned
name|usage
decl_stmt|;
name|struct
name|_krb5_key_data
name|key
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|HEIMDAL_SMALLER
end_ifndef

begin_define
define|#
directive|define
name|DES3_OLD_ENCTYPE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|krb5_error_code
name|_get_derived_key
parameter_list|(
name|krb5_context
parameter_list|,
name|krb5_crypto
parameter_list|,
name|unsigned
parameter_list|,
name|struct
name|_krb5_key_data
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|_krb5_key_data
modifier|*
name|_new_derived_key
parameter_list|(
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_key_schedule
parameter_list|(
name|krb5_context
parameter_list|,
name|struct
name|_krb5_key_data
modifier|*
parameter_list|,
name|struct
name|_krb5_encryption_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*   * Converts etype to a user readable string and sets as a side effect  * the krb5_error_message containing this string. Returns  * KRB5_PROG_ETYPE_NOSUPP in not the conversion of the etype failed in  * which case the error code of the etype convesion is returned.  */
end_comment

begin_function
specifier|static
name|krb5_error_code
name|unsupported_enctype
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_enctype
name|etype
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|ret
operator|=
name|krb5_enctype_to_string
argument_list|(
name|context
argument_list|,
name|etype
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_ETYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"Encryption type %s not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_ETYPE_NOSUPP
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_enctype_keysize
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_enctype
name|type
parameter_list|,
name|size_t
modifier|*
name|keysize
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|_krb5_find_enctype
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|et
operator|==
name|NULL
condition|)
block|{
return|return
name|unsupported_enctype
argument_list|(
name|context
argument_list|,
name|type
argument_list|)
return|;
block|}
operator|*
name|keysize
operator|=
name|et
operator|->
name|keytype
operator|->
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_enctype_keybits
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_enctype
name|type
parameter_list|,
name|size_t
modifier|*
name|keybits
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|_krb5_find_enctype
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|et
operator|==
name|NULL
condition|)
block|{
return|return
name|unsupported_enctype
argument_list|(
name|context
argument_list|,
name|type
argument_list|)
return|;
block|}
operator|*
name|keybits
operator|=
name|et
operator|->
name|keytype
operator|->
name|bits
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_generate_random_keyblock
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_enctype
name|type
parameter_list|,
name|krb5_keyblock
modifier|*
name|key
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|_krb5_find_enctype
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|et
operator|==
name|NULL
condition|)
block|{
return|return
name|unsupported_enctype
argument_list|(
name|context
argument_list|,
name|type
argument_list|)
return|;
block|}
name|ret
operator|=
name|krb5_data_alloc
argument_list|(
operator|&
name|key
operator|->
name|keyvalue
argument_list|,
name|et
operator|->
name|keytype
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|key
operator|->
name|keytype
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|et
operator|->
name|keytype
operator|->
name|random_key
condition|)
call|(
modifier|*
name|et
operator|->
name|keytype
operator|->
name|random_key
call|)
argument_list|(
name|context
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|krb5_generate_random_block
argument_list|(
name|key
operator|->
name|keyvalue
operator|.
name|data
argument_list|,
name|key
operator|->
name|keyvalue
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|_key_schedule
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|struct
name|_krb5_key_data
modifier|*
name|key
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|_krb5_find_enctype
argument_list|(
name|key
operator|->
name|key
operator|->
name|keytype
argument_list|)
decl_stmt|;
name|struct
name|_krb5_key_type
modifier|*
name|kt
decl_stmt|;
if|if
condition|(
name|et
operator|==
name|NULL
condition|)
block|{
return|return
name|unsupported_enctype
argument_list|(
name|context
argument_list|,
name|key
operator|->
name|key
operator|->
name|keytype
argument_list|)
return|;
block|}
name|kt
operator|=
name|et
operator|->
name|keytype
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|schedule
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|key
operator|->
name|schedule
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
name|ALLOC
argument_list|(
name|key
operator|->
name|schedule
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|schedule
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|ret
operator|=
name|krb5_data_alloc
argument_list|(
name|key
operator|->
name|schedule
argument_list|,
name|kt
operator|->
name|schedule_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|key
operator|->
name|schedule
argument_list|)
expr_stmt|;
name|key
operator|->
name|schedule
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
call|(
modifier|*
name|kt
operator|->
name|schedule
call|)
argument_list|(
name|context
argument_list|,
name|kt
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/************************************************************  *                                                          *  ************************************************************/
end_comment

begin_function
specifier|static
name|krb5_error_code
name|SHA1_checksum
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|struct
name|_krb5_key_data
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|usage
parameter_list|,
name|Checksum
modifier|*
name|C
parameter_list|)
block|{
if|if
condition|(
name|EVP_Digest
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|C
operator|->
name|checksum
operator|.
name|data
argument_list|,
name|NULL
argument_list|,
name|EVP_sha1
argument_list|()
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|1
condition|)
name|krb5_abortx
argument_list|(
name|context
argument_list|,
literal|"sha1 checksum failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* HMAC according to RFC2104 */
end_comment

begin_function
name|krb5_error_code
name|_krb5_internal_hmac
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|struct
name|_krb5_checksum_type
modifier|*
name|cm
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|usage
parameter_list|,
name|struct
name|_krb5_key_data
modifier|*
name|keyblock
parameter_list|,
name|Checksum
modifier|*
name|result
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ipad
decl_stmt|,
modifier|*
name|opad
decl_stmt|;
name|unsigned
name|char
modifier|*
name|key
decl_stmt|;
name|size_t
name|key_len
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|ipad
operator|=
name|malloc
argument_list|(
name|cm
operator|->
name|blocksize
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipad
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|opad
operator|=
name|malloc
argument_list|(
name|cm
operator|->
name|blocksize
operator|+
name|cm
operator|->
name|checksumsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|opad
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ipad
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|memset
argument_list|(
name|ipad
argument_list|,
literal|0x36
argument_list|,
name|cm
operator|->
name|blocksize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|opad
argument_list|,
literal|0x5c
argument_list|,
name|cm
operator|->
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyblock
operator|->
name|key
operator|->
name|keyvalue
operator|.
name|length
operator|>
name|cm
operator|->
name|blocksize
condition|)
block|{
call|(
modifier|*
name|cm
operator|->
name|checksum
call|)
argument_list|(
name|context
argument_list|,
name|keyblock
argument_list|,
name|keyblock
operator|->
name|key
operator|->
name|keyvalue
operator|.
name|data
argument_list|,
name|keyblock
operator|->
name|key
operator|->
name|keyvalue
operator|.
name|length
argument_list|,
name|usage
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|key
operator|=
name|result
operator|->
name|checksum
operator|.
name|data
expr_stmt|;
name|key_len
operator|=
name|result
operator|->
name|checksum
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|key
operator|=
name|keyblock
operator|->
name|key
operator|->
name|keyvalue
operator|.
name|data
expr_stmt|;
name|key_len
operator|=
name|keyblock
operator|->
name|key
operator|->
name|keyvalue
operator|.
name|length
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|key_len
condition|;
name|i
operator|++
control|)
block|{
name|ipad
index|[
name|i
index|]
operator|^=
name|key
index|[
name|i
index|]
expr_stmt|;
name|opad
index|[
name|i
index|]
operator|^=
name|key
index|[
name|i
index|]
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|ipad
operator|+
name|cm
operator|->
name|blocksize
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cm
operator|->
name|checksum
call|)
argument_list|(
name|context
argument_list|,
name|keyblock
argument_list|,
name|ipad
argument_list|,
name|cm
operator|->
name|blocksize
operator|+
name|len
argument_list|,
name|usage
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|opad
operator|+
name|cm
operator|->
name|blocksize
argument_list|,
name|result
operator|->
name|checksum
operator|.
name|data
argument_list|,
name|result
operator|->
name|checksum
operator|.
name|length
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cm
operator|->
name|checksum
call|)
argument_list|(
name|context
argument_list|,
name|keyblock
argument_list|,
name|opad
argument_list|,
name|cm
operator|->
name|blocksize
operator|+
name|cm
operator|->
name|checksumsize
argument_list|,
name|usage
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ipad
argument_list|,
literal|0
argument_list|,
name|cm
operator|->
name|blocksize
operator|+
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ipad
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|opad
argument_list|,
literal|0
argument_list|,
name|cm
operator|->
name|blocksize
operator|+
name|cm
operator|->
name|checksumsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|opad
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_hmac
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_cksumtype
name|cktype
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|usage
parameter_list|,
name|krb5_keyblock
modifier|*
name|key
parameter_list|,
name|Checksum
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|_krb5_checksum_type
modifier|*
name|c
init|=
name|_krb5_find_checksum
argument_list|(
name|cktype
argument_list|)
decl_stmt|;
name|struct
name|_krb5_key_data
name|kd
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_SUMTYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"checksum type %d not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|cktype
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
block|}
name|kd
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|kd
operator|.
name|schedule
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|_krb5_internal_hmac
argument_list|(
name|context
argument_list|,
name|c
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|usage
argument_list|,
operator|&
name|kd
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|kd
operator|.
name|schedule
condition|)
name|krb5_free_data
argument_list|(
name|context
argument_list|,
name|kd
operator|.
name|schedule
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|krb5_error_code
name|_krb5_SP_HMAC_SHA1_checksum
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|struct
name|_krb5_key_data
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|usage
parameter_list|,
name|Checksum
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|_krb5_checksum_type
modifier|*
name|c
init|=
name|_krb5_find_checksum
argument_list|(
name|CKSUMTYPE_SHA1
argument_list|)
decl_stmt|;
name|Checksum
name|res
decl_stmt|;
name|char
name|sha1_data
index|[
literal|20
index|]
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|res
operator|.
name|checksum
operator|.
name|data
operator|=
name|sha1_data
expr_stmt|;
name|res
operator|.
name|checksum
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|sha1_data
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_krb5_internal_hmac
argument_list|(
name|context
argument_list|,
name|c
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|usage
argument_list|,
name|key
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|krb5_abortx
argument_list|(
name|context
argument_list|,
literal|"hmac failed"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|result
operator|->
name|checksum
operator|.
name|data
argument_list|,
name|res
operator|.
name|checksum
operator|.
name|data
argument_list|,
name|result
operator|->
name|checksum
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|_krb5_checksum_type
name|_krb5_checksum_sha1
init|=
block|{
name|CKSUMTYPE_SHA1
block|,
literal|"sha1"
block|,
literal|64
block|,
literal|20
block|,
name|F_CPROOF
block|,
name|SHA1_checksum
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|_krb5_checksum_type
modifier|*
name|_krb5_find_checksum
parameter_list|(
name|krb5_cksumtype
name|type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_krb5_num_checksums
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|_krb5_checksum_types
index|[
name|i
index|]
operator|->
name|type
operator|==
name|type
condition|)
return|return
name|_krb5_checksum_types
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|get_checksum_key
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
comment|/* not krb5_key_usage */
name|struct
name|_krb5_checksum_type
modifier|*
name|ct
parameter_list|,
name|struct
name|_krb5_key_data
modifier|*
modifier|*
name|key
parameter_list|)
block|{
name|krb5_error_code
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ct
operator|->
name|flags
operator|&
name|F_DERIVED
condition|)
name|ret
operator|=
name|_get_derived_key
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|usage
argument_list|,
name|key
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ct
operator|->
name|flags
operator|&
name|F_VARIANT
condition|)
block|{
name|size_t
name|i
decl_stmt|;
operator|*
name|key
operator|=
name|_new_derived_key
argument_list|(
name|crypto
argument_list|,
literal|0xff
comment|/* KRB5_KU_RFC1510_VARIANT */
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|key
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|ret
operator|=
name|krb5_copy_keyblock
argument_list|(
name|context
argument_list|,
name|crypto
operator|->
name|key
operator|.
name|key
argument_list|,
operator|&
operator|(
operator|*
name|key
operator|)
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|*
name|key
operator|)
operator|->
name|key
operator|->
name|keyvalue
operator|.
name|length
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|*
name|key
operator|)
operator|->
name|key
operator|->
name|keyvalue
operator|.
name|data
operator|)
index|[
name|i
index|]
operator|^=
literal|0xF0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|key
operator|=
operator|&
name|crypto
operator|->
name|key
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|ret
operator|=
name|_key_schedule
argument_list|(
name|context
argument_list|,
operator|*
name|key
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|create_checksum
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|struct
name|_krb5_checksum_type
modifier|*
name|ct
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|Checksum
modifier|*
name|result
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|struct
name|_krb5_key_data
modifier|*
name|dkey
decl_stmt|;
name|int
name|keyed_checksum
decl_stmt|;
if|if
condition|(
name|ct
operator|->
name|flags
operator|&
name|F_DISABLED
condition|)
block|{
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
block|}
name|keyed_checksum
operator|=
operator|(
name|ct
operator|->
name|flags
operator|&
name|F_KEYED
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|keyed_checksum
operator|&&
name|crypto
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_SUMTYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"Checksum type %s is keyed but no "
literal|"crypto context (key) was passed in"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|ct
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
comment|/* XXX */
block|}
if|if
condition|(
name|keyed_checksum
condition|)
block|{
name|ret
operator|=
name|get_checksum_key
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|usage
argument_list|,
name|ct
argument_list|,
operator|&
name|dkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
else|else
name|dkey
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|cksumtype
operator|=
name|ct
operator|->
name|type
expr_stmt|;
name|ret
operator|=
name|krb5_data_alloc
argument_list|(
operator|&
name|result
operator|->
name|checksum
argument_list|,
name|ct
operator|->
name|checksumsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
return|return
call|(
modifier|*
name|ct
operator|->
name|checksum
call|)
argument_list|(
name|context
argument_list|,
name|dkey
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|usage
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arcfour_checksum_p
parameter_list|(
name|struct
name|_krb5_checksum_type
modifier|*
name|ct
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|)
block|{
return|return
operator|(
name|ct
operator|->
name|type
operator|==
name|CKSUMTYPE_HMAC_MD5
operator|)
operator|&&
operator|(
name|crypto
operator|->
name|key
operator|.
name|key
operator|->
name|keytype
operator|==
name|KEYTYPE_ARCFOUR
operator|)
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_create_checksum
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|krb5_key_usage
name|usage
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|Checksum
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|_krb5_checksum_type
modifier|*
name|ct
init|=
name|NULL
decl_stmt|;
name|unsigned
name|keyusage
decl_stmt|;
comment|/* type 0 -> pick from crypto */
if|if
condition|(
name|type
condition|)
block|{
name|ct
operator|=
name|_krb5_find_checksum
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crypto
condition|)
block|{
name|ct
operator|=
name|crypto
operator|->
name|et
operator|->
name|keyed_checksum
expr_stmt|;
if|if
condition|(
name|ct
operator|==
name|NULL
condition|)
name|ct
operator|=
name|crypto
operator|->
name|et
operator|->
name|checksum
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_SUMTYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"checksum type %d not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
block|}
if|if
condition|(
name|arcfour_checksum_p
argument_list|(
name|ct
argument_list|,
name|crypto
argument_list|)
condition|)
block|{
name|keyusage
operator|=
name|usage
expr_stmt|;
name|_krb5_usage2arcfour
argument_list|(
name|context
argument_list|,
operator|&
name|keyusage
argument_list|)
expr_stmt|;
block|}
else|else
name|keyusage
operator|=
name|CHECKSUM_USAGE
argument_list|(
name|usage
argument_list|)
expr_stmt|;
return|return
name|create_checksum
argument_list|(
name|context
argument_list|,
name|ct
argument_list|,
name|crypto
argument_list|,
name|keyusage
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|verify_checksum
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
comment|/* not krb5_key_usage */
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|Checksum
modifier|*
name|cksum
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|struct
name|_krb5_key_data
modifier|*
name|dkey
decl_stmt|;
name|int
name|keyed_checksum
decl_stmt|;
name|Checksum
name|c
decl_stmt|;
name|struct
name|_krb5_checksum_type
modifier|*
name|ct
decl_stmt|;
name|ct
operator|=
name|_krb5_find_checksum
argument_list|(
name|cksum
operator|->
name|cksumtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|==
name|NULL
operator|||
operator|(
name|ct
operator|->
name|flags
operator|&
name|F_DISABLED
operator|)
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_SUMTYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"checksum type %d not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|cksum
operator|->
name|cksumtype
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
block|}
if|if
condition|(
name|ct
operator|->
name|checksumsize
operator|!=
name|cksum
operator|->
name|checksum
operator|.
name|length
condition|)
block|{
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5KRB_AP_ERR_BAD_INTEGRITY
argument_list|,
name|N_
argument_list|(
literal|"Decrypt integrity check failed for checksum type %s, "
literal|"length was %u, expected %u"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|ct
operator|->
name|name
argument_list|,
operator|(
name|unsigned
operator|)
name|cksum
operator|->
name|checksum
operator|.
name|length
argument_list|,
operator|(
name|unsigned
operator|)
name|ct
operator|->
name|checksumsize
argument_list|)
expr_stmt|;
return|return
name|KRB5KRB_AP_ERR_BAD_INTEGRITY
return|;
comment|/* XXX */
block|}
name|keyed_checksum
operator|=
operator|(
name|ct
operator|->
name|flags
operator|&
name|F_KEYED
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|keyed_checksum
condition|)
block|{
name|struct
name|_krb5_checksum_type
modifier|*
name|kct
decl_stmt|;
if|if
condition|(
name|crypto
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_SUMTYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"Checksum type %s is keyed but no "
literal|"crypto context (key) was passed in"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|ct
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
comment|/* XXX */
block|}
name|kct
operator|=
name|crypto
operator|->
name|et
operator|->
name|keyed_checksum
expr_stmt|;
if|if
condition|(
name|kct
operator|==
name|NULL
operator|||
name|kct
operator|->
name|type
operator|!=
name|ct
operator|->
name|type
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_SUMTYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"Checksum type %s is keyed, but "
literal|"the key type %s passed didnt have that checksum "
literal|"type as the keyed type"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|ct
operator|->
name|name
argument_list|,
name|crypto
operator|->
name|et
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
comment|/* XXX */
block|}
name|ret
operator|=
name|get_checksum_key
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|usage
argument_list|,
name|ct
argument_list|,
operator|&
name|dkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
else|else
name|dkey
operator|=
name|NULL
expr_stmt|;
comment|/*      * If checksum have a verify function, lets use that instead of      * calling ->checksum and then compare result.      */
if|if
condition|(
name|ct
operator|->
name|verify
condition|)
block|{
name|ret
operator|=
call|(
modifier|*
name|ct
operator|->
name|verify
call|)
argument_list|(
name|context
argument_list|,
name|dkey
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|usage
argument_list|,
name|cksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|,
name|N_
argument_list|(
literal|"Decrypt integrity check failed for checksum "
literal|"type %s, key type %s"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|ct
operator|->
name|name
argument_list|,
operator|(
name|crypto
operator|!=
name|NULL
operator|)
condition|?
name|crypto
operator|->
name|et
operator|->
name|name
else|:
literal|"(none)"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|krb5_data_alloc
argument_list|(
operator|&
name|c
operator|.
name|checksum
argument_list|,
name|ct
operator|->
name|checksumsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
call|(
modifier|*
name|ct
operator|->
name|checksum
call|)
argument_list|(
name|context
argument_list|,
name|dkey
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|usage
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|krb5_data_free
argument_list|(
operator|&
name|c
operator|.
name|checksum
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|krb5_data_ct_cmp
argument_list|(
operator|&
name|c
operator|.
name|checksum
argument_list|,
operator|&
name|cksum
operator|->
name|checksum
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|KRB5KRB_AP_ERR_BAD_INTEGRITY
expr_stmt|;
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|,
name|N_
argument_list|(
literal|"Decrypt integrity check failed for checksum "
literal|"type %s, key type %s"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|ct
operator|->
name|name
argument_list|,
name|crypto
condition|?
name|crypto
operator|->
name|et
operator|->
name|name
else|:
literal|"(unkeyed)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|krb5_data_free
argument_list|(
operator|&
name|c
operator|.
name|checksum
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_verify_checksum
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|krb5_key_usage
name|usage
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|Checksum
modifier|*
name|cksum
parameter_list|)
block|{
name|struct
name|_krb5_checksum_type
modifier|*
name|ct
decl_stmt|;
name|unsigned
name|keyusage
decl_stmt|;
name|ct
operator|=
name|_krb5_find_checksum
argument_list|(
name|cksum
operator|->
name|cksumtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_SUMTYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"checksum type %d not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|cksum
operator|->
name|cksumtype
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
block|}
if|if
condition|(
name|arcfour_checksum_p
argument_list|(
name|ct
argument_list|,
name|crypto
argument_list|)
condition|)
block|{
name|keyusage
operator|=
name|usage
expr_stmt|;
name|_krb5_usage2arcfour
argument_list|(
name|context
argument_list|,
operator|&
name|keyusage
argument_list|)
expr_stmt|;
block|}
else|else
name|keyusage
operator|=
name|CHECKSUM_USAGE
argument_list|(
name|usage
argument_list|)
expr_stmt|;
return|return
name|verify_checksum
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|keyusage
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|cksum
argument_list|)
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_crypto_get_checksum_type
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|krb5_cksumtype
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|_krb5_checksum_type
modifier|*
name|ct
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|crypto
operator|!=
name|NULL
condition|)
block|{
name|ct
operator|=
name|crypto
operator|->
name|et
operator|->
name|keyed_checksum
expr_stmt|;
if|if
condition|(
name|ct
operator|==
name|NULL
condition|)
name|ct
operator|=
name|crypto
operator|->
name|et
operator|->
name|checksum
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_SUMTYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"checksum type not found"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
block|}
operator|*
name|type
operator|=
name|ct
operator|->
name|type
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_checksumsize
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_cksumtype
name|type
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|struct
name|_krb5_checksum_type
modifier|*
name|ct
init|=
name|_krb5_find_checksum
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ct
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_SUMTYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"checksum type %d not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
block|}
operator|*
name|size
operator|=
name|ct
operator|->
name|checksumsize
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_boolean
name|KRB5_LIB_CALL
name|krb5_checksum_is_keyed
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_cksumtype
name|type
parameter_list|)
block|{
name|struct
name|_krb5_checksum_type
modifier|*
name|ct
init|=
name|_krb5_find_checksum
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ct
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|context
condition|)
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_SUMTYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"checksum type %d not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
block|}
return|return
name|ct
operator|->
name|flags
operator|&
name|F_KEYED
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_boolean
name|KRB5_LIB_CALL
name|krb5_checksum_is_collision_proof
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_cksumtype
name|type
parameter_list|)
block|{
name|struct
name|_krb5_checksum_type
modifier|*
name|ct
init|=
name|_krb5_find_checksum
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ct
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|context
condition|)
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_SUMTYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"checksum type %d not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
block|}
return|return
name|ct
operator|->
name|flags
operator|&
name|F_CPROOF
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_checksum_disable
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_cksumtype
name|type
parameter_list|)
block|{
name|struct
name|_krb5_checksum_type
modifier|*
name|ct
init|=
name|_krb5_find_checksum
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ct
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|context
condition|)
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_SUMTYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"checksum type %d not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
block|}
name|ct
operator|->
name|flags
operator||=
name|F_DISABLED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/************************************************************  *                                                          *  ************************************************************/
end_comment

begin_function
name|struct
name|_krb5_encryption_type
modifier|*
name|_krb5_find_enctype
parameter_list|(
name|krb5_enctype
name|type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_krb5_num_etypes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|type
operator|==
name|type
condition|)
return|return
name|_krb5_etypes
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_enctype_to_string
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_enctype
name|etype
parameter_list|,
name|char
modifier|*
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|_krb5_find_enctype
argument_list|(
name|etype
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_ETYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"encryption type %d not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|etype
argument_list|)
expr_stmt|;
operator|*
name|string
operator|=
name|NULL
expr_stmt|;
return|return
name|KRB5_PROG_ETYPE_NOSUPP
return|;
block|}
operator|*
name|string
operator|=
name|strdup
argument_list|(
name|e
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_string_to_enctype
parameter_list|(
name|krb5_context
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|krb5_enctype
modifier|*
name|etype
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_krb5_num_etypes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|string
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|etype
operator|=
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|type
expr_stmt|;
return|return
literal|0
return|;
block|}
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_ETYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"encryption type %s not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_ETYPE_NOSUPP
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_enctype_to_keytype
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_enctype
name|etype
parameter_list|,
name|krb5_keytype
modifier|*
name|keytype
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|e
init|=
name|_krb5_find_enctype
argument_list|(
name|etype
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
return|return
name|unsupported_enctype
argument_list|(
name|context
argument_list|,
name|etype
argument_list|)
return|;
block|}
operator|*
name|keytype
operator|=
name|e
operator|->
name|keytype
operator|->
name|type
expr_stmt|;
comment|/* XXX */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Check if a enctype is valid, return 0 if it is.  *  * @param context Kerberos context  * @param etype enctype to check if its valid or not  *  * @return Return an error code for an failure or 0 on success (enctype valid).  * @ingroup krb5_crypto  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_enctype_valid
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_enctype
name|etype
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|e
init|=
name|_krb5_find_enctype
argument_list|(
name|etype
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|F_DISABLED
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|context
operator|==
name|NULL
condition|)
return|return
name|KRB5_PROG_ETYPE_NOSUPP
return|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
return|return
name|unsupported_enctype
argument_list|(
name|context
argument_list|,
name|etype
argument_list|)
return|;
block|}
comment|/* Must be (e->flags& F_DISABLED) */
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_ETYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"encryption type %s is disabled"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|e
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_ETYPE_NOSUPP
return|;
block|}
end_function

begin_comment
comment|/**  * Return the coresponding encryption type for a checksum type.  *  * @param context Kerberos context  * @param ctype The checksum type to get the result enctype for  * @param etype The returned encryption, when the matching etype is  * not found, etype is set to ETYPE_NULL.  *  * @return Return an error code for an failure or 0 on success.  * @ingroup krb5_crypto  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_cksumtype_to_enctype
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_cksumtype
name|ctype
parameter_list|,
name|krb5_enctype
modifier|*
name|etype
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|*
name|etype
operator|=
name|ETYPE_NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_krb5_num_etypes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|keyed_checksum
operator|&&
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|keyed_checksum
operator|->
name|type
operator|==
name|ctype
condition|)
block|{
operator|*
name|etype
operator|=
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|type
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_SUMTYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"checksum type %d not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|ctype
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_cksumtype_valid
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_cksumtype
name|ctype
parameter_list|)
block|{
name|struct
name|_krb5_checksum_type
modifier|*
name|c
init|=
name|_krb5_find_checksum
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_SUMTYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"checksum type %d not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
block|}
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|F_DISABLED
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_SUMTYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"checksum type %s is disabled"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_SUMTYPE_NOSUPP
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_boolean
name|derived_crypto
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|)
block|{
return|return
operator|(
name|crypto
operator|->
name|et
operator|->
name|flags
operator|&
name|F_DERIVED
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_boolean
name|special_crypto
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|)
block|{
return|return
operator|(
name|crypto
operator|->
name|et
operator|->
name|flags
operator|&
name|F_SPECIAL
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CHECKSUMSIZE
parameter_list|(
name|C
parameter_list|)
value|((C)->checksumsize)
end_define

begin_define
define|#
directive|define
name|CHECKSUMTYPE
parameter_list|(
name|C
parameter_list|)
value|((C)->type)
end_define

begin_function
specifier|static
name|krb5_error_code
name|encrypt_internal_derived
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|krb5_data
modifier|*
name|result
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|,
name|block_sz
decl_stmt|,
name|checksum_sz
decl_stmt|,
name|total_sz
decl_stmt|;
name|Checksum
name|cksum
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|struct
name|_krb5_key_data
modifier|*
name|dkey
decl_stmt|;
specifier|const
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|crypto
operator|->
name|et
decl_stmt|;
name|checksum_sz
operator|=
name|CHECKSUMSIZE
argument_list|(
name|et
operator|->
name|keyed_checksum
argument_list|)
expr_stmt|;
name|sz
operator|=
name|et
operator|->
name|confoundersize
operator|+
name|len
expr_stmt|;
name|block_sz
operator|=
operator|(
name|sz
operator|+
name|et
operator|->
name|padsize
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|et
operator|->
name|padsize
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* pad */
name|total_sz
operator|=
name|block_sz
operator|+
name|checksum_sz
expr_stmt|;
name|p
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|total_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|q
operator|=
name|p
expr_stmt|;
name|krb5_generate_random_block
argument_list|(
name|q
argument_list|,
name|et
operator|->
name|confoundersize
argument_list|)
expr_stmt|;
comment|/* XXX */
name|q
operator|+=
name|et
operator|->
name|confoundersize
expr_stmt|;
name|memcpy
argument_list|(
name|q
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ret
operator|=
name|create_checksum
argument_list|(
name|context
argument_list|,
name|et
operator|->
name|keyed_checksum
argument_list|,
name|crypto
argument_list|,
name|INTEGRITY_USAGE
argument_list|(
name|usage
argument_list|)
argument_list|,
name|p
argument_list|,
name|block_sz
argument_list|,
operator|&
name|cksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|cksum
operator|.
name|checksum
operator|.
name|length
operator|!=
name|checksum_sz
condition|)
block|{
name|free_Checksum
argument_list|(
operator|&
name|cksum
argument_list|)
expr_stmt|;
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ret
operator|=
name|KRB5_CRYPTO_INTERNAL
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
goto|goto
name|fail
goto|;
name|memcpy
argument_list|(
name|p
operator|+
name|block_sz
argument_list|,
name|cksum
operator|.
name|checksum
operator|.
name|data
argument_list|,
name|cksum
operator|.
name|checksum
operator|.
name|length
argument_list|)
expr_stmt|;
name|free_Checksum
argument_list|(
operator|&
name|cksum
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_get_derived_key
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|ENCRYPTION_USAGE
argument_list|(
name|usage
argument_list|)
argument_list|,
operator|&
name|dkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|fail
goto|;
name|ret
operator|=
name|_key_schedule
argument_list|(
name|context
argument_list|,
name|dkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|fail
goto|;
name|ret
operator|=
call|(
modifier|*
name|et
operator|->
name|encrypt
call|)
argument_list|(
name|context
argument_list|,
name|dkey
argument_list|,
name|p
argument_list|,
name|block_sz
argument_list|,
literal|1
argument_list|,
name|usage
argument_list|,
name|ivec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|fail
goto|;
name|result
operator|->
name|data
operator|=
name|p
expr_stmt|;
name|result
operator|->
name|length
operator|=
name|total_sz
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|total_sz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|encrypt_internal
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|krb5_data
modifier|*
name|result
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|,
name|block_sz
decl_stmt|,
name|checksum_sz
decl_stmt|;
name|Checksum
name|cksum
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
specifier|const
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|crypto
operator|->
name|et
decl_stmt|;
name|checksum_sz
operator|=
name|CHECKSUMSIZE
argument_list|(
name|et
operator|->
name|checksum
argument_list|)
expr_stmt|;
name|sz
operator|=
name|et
operator|->
name|confoundersize
operator|+
name|checksum_sz
operator|+
name|len
expr_stmt|;
name|block_sz
operator|=
operator|(
name|sz
operator|+
name|et
operator|->
name|padsize
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|et
operator|->
name|padsize
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* pad */
name|p
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|block_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|q
operator|=
name|p
expr_stmt|;
name|krb5_generate_random_block
argument_list|(
name|q
argument_list|,
name|et
operator|->
name|confoundersize
argument_list|)
expr_stmt|;
comment|/* XXX */
name|q
operator|+=
name|et
operator|->
name|confoundersize
expr_stmt|;
name|memset
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
name|checksum_sz
argument_list|)
expr_stmt|;
name|q
operator|+=
name|checksum_sz
expr_stmt|;
name|memcpy
argument_list|(
name|q
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ret
operator|=
name|create_checksum
argument_list|(
name|context
argument_list|,
name|et
operator|->
name|checksum
argument_list|,
name|crypto
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|block_sz
argument_list|,
operator|&
name|cksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|cksum
operator|.
name|checksum
operator|.
name|length
operator|!=
name|checksum_sz
condition|)
block|{
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|free_Checksum
argument_list|(
operator|&
name|cksum
argument_list|)
expr_stmt|;
name|ret
operator|=
name|KRB5_CRYPTO_INTERNAL
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
goto|goto
name|fail
goto|;
name|memcpy
argument_list|(
name|p
operator|+
name|et
operator|->
name|confoundersize
argument_list|,
name|cksum
operator|.
name|checksum
operator|.
name|data
argument_list|,
name|cksum
operator|.
name|checksum
operator|.
name|length
argument_list|)
expr_stmt|;
name|free_Checksum
argument_list|(
operator|&
name|cksum
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_key_schedule
argument_list|(
name|context
argument_list|,
operator|&
name|crypto
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|fail
goto|;
name|ret
operator|=
call|(
modifier|*
name|et
operator|->
name|encrypt
call|)
argument_list|(
name|context
argument_list|,
operator|&
name|crypto
operator|->
name|key
argument_list|,
name|p
argument_list|,
name|block_sz
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|ivec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|block_sz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|result
operator|->
name|data
operator|=
name|p
expr_stmt|;
name|result
operator|->
name|length
operator|=
name|block_sz
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|block_sz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|encrypt_internal_special
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|int
name|usage
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|krb5_data
modifier|*
name|result
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|crypto
operator|->
name|et
decl_stmt|;
name|size_t
name|cksum_sz
init|=
name|CHECKSUMSIZE
argument_list|(
name|et
operator|->
name|checksum
argument_list|)
decl_stmt|;
name|size_t
name|sz
init|=
name|len
operator|+
name|cksum_sz
operator|+
name|et
operator|->
name|confoundersize
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|tmp
operator|=
name|malloc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|p
operator|=
name|tmp
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|cksum_sz
argument_list|)
expr_stmt|;
name|p
operator|+=
name|cksum_sz
expr_stmt|;
name|krb5_generate_random_block
argument_list|(
name|p
argument_list|,
name|et
operator|->
name|confoundersize
argument_list|)
expr_stmt|;
name|p
operator|+=
name|et
operator|->
name|confoundersize
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|et
operator|->
name|encrypt
call|)
argument_list|(
name|context
argument_list|,
operator|&
name|crypto
operator|->
name|key
argument_list|,
name|tmp
argument_list|,
name|sz
argument_list|,
name|TRUE
argument_list|,
name|usage
argument_list|,
name|ivec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|memset
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|result
operator|->
name|data
operator|=
name|tmp
expr_stmt|;
name|result
operator|->
name|length
operator|=
name|sz
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|decrypt_internal_derived
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|krb5_data
modifier|*
name|result
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|)
block|{
name|size_t
name|checksum_sz
decl_stmt|;
name|Checksum
name|cksum
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|struct
name|_krb5_key_data
modifier|*
name|dkey
decl_stmt|;
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|crypto
operator|->
name|et
decl_stmt|;
name|unsigned
name|long
name|l
decl_stmt|;
name|checksum_sz
operator|=
name|CHECKSUMSIZE
argument_list|(
name|et
operator|->
name|keyed_checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|checksum_sz
operator|+
name|et
operator|->
name|confoundersize
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_BAD_MSIZE
argument_list|,
name|N_
argument_list|(
literal|"Encrypted data shorter then "
literal|"checksum + confunder"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|KRB5_BAD_MSIZE
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|len
operator|-
name|checksum_sz
operator|)
operator|%
name|et
operator|->
name|padsize
operator|)
operator|!=
literal|0
condition|)
block|{
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|KRB5_BAD_MSIZE
return|;
block|}
name|p
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
operator|&&
name|p
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|-=
name|checksum_sz
expr_stmt|;
name|ret
operator|=
name|_get_derived_key
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|ENCRYPTION_USAGE
argument_list|(
name|usage
argument_list|)
argument_list|,
operator|&
name|dkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|_key_schedule
argument_list|(
name|context
argument_list|,
name|dkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
call|(
modifier|*
name|et
operator|->
name|encrypt
call|)
argument_list|(
name|context
argument_list|,
name|dkey
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|usage
argument_list|,
name|ivec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|cksum
operator|.
name|checksum
operator|.
name|data
operator|=
name|p
operator|+
name|len
expr_stmt|;
name|cksum
operator|.
name|checksum
operator|.
name|length
operator|=
name|checksum_sz
expr_stmt|;
name|cksum
operator|.
name|cksumtype
operator|=
name|CHECKSUMTYPE
argument_list|(
name|et
operator|->
name|keyed_checksum
argument_list|)
expr_stmt|;
name|ret
operator|=
name|verify_checksum
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|INTEGRITY_USAGE
argument_list|(
name|usage
argument_list|)
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
operator|&
name|cksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|l
operator|=
name|len
operator|-
name|et
operator|->
name|confoundersize
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|et
operator|->
name|confoundersize
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|result
operator|->
name|data
operator|=
name|realloc
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|data
operator|==
name|NULL
operator|&&
name|l
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|result
operator|->
name|length
operator|=
name|l
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|decrypt_internal
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|krb5_data
modifier|*
name|result
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|Checksum
name|cksum
decl_stmt|;
name|size_t
name|checksum_sz
decl_stmt|,
name|l
decl_stmt|;
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|crypto
operator|->
name|et
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|%
name|et
operator|->
name|padsize
operator|)
operator|!=
literal|0
condition|)
block|{
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|KRB5_BAD_MSIZE
return|;
block|}
name|checksum_sz
operator|=
name|CHECKSUMSIZE
argument_list|(
name|et
operator|->
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|checksum_sz
operator|+
name|et
operator|->
name|confoundersize
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_BAD_MSIZE
argument_list|,
name|N_
argument_list|(
literal|"Encrypted data shorter then "
literal|"checksum + confunder"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|KRB5_BAD_MSIZE
return|;
block|}
name|p
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
operator|&&
name|p
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_key_schedule
argument_list|(
name|context
argument_list|,
operator|&
name|crypto
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
call|(
modifier|*
name|et
operator|->
name|encrypt
call|)
argument_list|(
name|context
argument_list|,
operator|&
name|crypto
operator|->
name|key
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ivec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|krb5_data_copy
argument_list|(
operator|&
name|cksum
operator|.
name|checksum
argument_list|,
name|p
operator|+
name|et
operator|->
name|confoundersize
argument_list|,
name|checksum_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|memset
argument_list|(
name|p
operator|+
name|et
operator|->
name|confoundersize
argument_list|,
literal|0
argument_list|,
name|checksum_sz
argument_list|)
expr_stmt|;
name|cksum
operator|.
name|cksumtype
operator|=
name|CHECKSUMTYPE
argument_list|(
name|et
operator|->
name|checksum
argument_list|)
expr_stmt|;
name|ret
operator|=
name|verify_checksum
argument_list|(
name|context
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
operator|&
name|cksum
argument_list|)
expr_stmt|;
name|free_Checksum
argument_list|(
operator|&
name|cksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|l
operator|=
name|len
operator|-
name|et
operator|->
name|confoundersize
operator|-
name|checksum_sz
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|et
operator|->
name|confoundersize
operator|+
name|checksum_sz
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|result
operator|->
name|data
operator|=
name|realloc
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|data
operator|==
name|NULL
operator|&&
name|l
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|result
operator|->
name|length
operator|=
name|l
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|decrypt_internal_special
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|int
name|usage
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|krb5_data
modifier|*
name|result
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|crypto
operator|->
name|et
decl_stmt|;
name|size_t
name|cksum_sz
init|=
name|CHECKSUMSIZE
argument_list|(
name|et
operator|->
name|checksum
argument_list|)
decl_stmt|;
name|size_t
name|sz
init|=
name|len
operator|-
name|cksum_sz
operator|-
name|et
operator|->
name|confoundersize
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|%
name|et
operator|->
name|padsize
operator|)
operator|!=
literal|0
condition|)
block|{
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|KRB5_BAD_MSIZE
return|;
block|}
if|if
condition|(
name|len
operator|<
name|cksum_sz
operator|+
name|et
operator|->
name|confoundersize
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_BAD_MSIZE
argument_list|,
name|N_
argument_list|(
literal|"Encrypted data shorter then "
literal|"checksum + confunder"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|KRB5_BAD_MSIZE
return|;
block|}
name|p
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|et
operator|->
name|encrypt
call|)
argument_list|(
name|context
argument_list|,
operator|&
name|crypto
operator|->
name|key
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
name|FALSE
argument_list|,
name|usage
argument_list|,
name|ivec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|memmove
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|cksum_sz
operator|+
name|et
operator|->
name|confoundersize
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|result
operator|->
name|data
operator|=
name|realloc
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|data
operator|==
name|NULL
operator|&&
name|sz
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|result
operator|->
name|length
operator|=
name|sz
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_crypto_iov
modifier|*
name|find_iv
parameter_list|(
name|krb5_crypto_iov
modifier|*
name|data
parameter_list|,
name|size_t
name|num_data
parameter_list|,
name|unsigned
name|type
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|==
name|type
condition|)
return|return
operator|&
name|data
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Inline encrypt a kerberos message  *  * @param context Kerberos context  * @param crypto Kerberos crypto context  * @param usage Key usage for this buffer  * @param data array of buffers to process  * @param num_data length of array  * @param ivec initial cbc/cts vector  *  * @return Return an error code or 0.  * @ingroup krb5_crypto  *  * Kerberos encrypted data look like this:  *  * 1. KRB5_CRYPTO_TYPE_HEADER  * 2. array [1,...] KRB5_CRYPTO_TYPE_DATA and array [0,...]  *    KRB5_CRYPTO_TYPE_SIGN_ONLY in any order, however the receiver  *    have to aware of the order. KRB5_CRYPTO_TYPE_SIGN_ONLY is  *    commonly used headers and trailers.  * 3. KRB5_CRYPTO_TYPE_PADDING, at least on padsize long if padsize> 1  * 4. KRB5_CRYPTO_TYPE_TRAILER  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_encrypt_iov_ivec
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
name|krb5_crypto_iov
modifier|*
name|data
parameter_list|,
name|int
name|num_data
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|)
block|{
name|size_t
name|headersz
decl_stmt|,
name|trailersz
decl_stmt|,
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|sz
decl_stmt|,
name|block_sz
decl_stmt|,
name|pad_sz
decl_stmt|;
name|Checksum
name|cksum
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|struct
name|_krb5_key_data
modifier|*
name|dkey
decl_stmt|;
specifier|const
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|crypto
operator|->
name|et
decl_stmt|;
name|krb5_crypto_iov
modifier|*
name|tiv
decl_stmt|,
modifier|*
name|piv
decl_stmt|,
modifier|*
name|hiv
decl_stmt|;
if|if
condition|(
name|num_data
operator|<
literal|0
condition|)
block|{
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|KRB5_CRYPTO_INTERNAL
return|;
block|}
if|if
condition|(
operator|!
name|derived_crypto
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
condition|)
block|{
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|KRB5_CRYPTO_INTERNAL
return|;
block|}
name|headersz
operator|=
name|et
operator|->
name|confoundersize
expr_stmt|;
name|trailersz
operator|=
name|CHECKSUMSIZE
argument_list|(
name|et
operator|->
name|keyed_checksum
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_DATA
condition|)
continue|continue;
name|len
operator|+=
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
expr_stmt|;
block|}
name|sz
operator|=
name|headersz
operator|+
name|len
expr_stmt|;
name|block_sz
operator|=
operator|(
name|sz
operator|+
name|et
operator|->
name|padsize
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|et
operator|->
name|padsize
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* pad */
name|pad_sz
operator|=
name|block_sz
operator|-
name|sz
expr_stmt|;
comment|/* header */
name|hiv
operator|=
name|find_iv
argument_list|(
name|data
argument_list|,
name|num_data
argument_list|,
name|KRB5_CRYPTO_TYPE_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|hiv
operator|==
name|NULL
operator|||
name|hiv
operator|->
name|data
operator|.
name|length
operator|!=
name|headersz
condition|)
return|return
name|KRB5_BAD_MSIZE
return|;
name|krb5_generate_random_block
argument_list|(
name|hiv
operator|->
name|data
operator|.
name|data
argument_list|,
name|hiv
operator|->
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
comment|/* padding */
name|piv
operator|=
name|find_iv
argument_list|(
name|data
argument_list|,
name|num_data
argument_list|,
name|KRB5_CRYPTO_TYPE_PADDING
argument_list|)
expr_stmt|;
comment|/* its ok to have no TYPE_PADDING if there is no padding */
if|if
condition|(
name|piv
operator|==
name|NULL
operator|&&
name|pad_sz
operator|!=
literal|0
condition|)
return|return
name|KRB5_BAD_MSIZE
return|;
if|if
condition|(
name|piv
condition|)
block|{
if|if
condition|(
name|piv
operator|->
name|data
operator|.
name|length
operator|<
name|pad_sz
condition|)
return|return
name|KRB5_BAD_MSIZE
return|;
name|piv
operator|->
name|data
operator|.
name|length
operator|=
name|pad_sz
expr_stmt|;
if|if
condition|(
name|pad_sz
condition|)
name|memset
argument_list|(
name|piv
operator|->
name|data
operator|.
name|data
argument_list|,
name|pad_sz
argument_list|,
name|pad_sz
argument_list|)
expr_stmt|;
else|else
name|piv
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* trailer */
name|tiv
operator|=
name|find_iv
argument_list|(
name|data
argument_list|,
name|num_data
argument_list|,
name|KRB5_CRYPTO_TYPE_TRAILER
argument_list|)
expr_stmt|;
if|if
condition|(
name|tiv
operator|==
name|NULL
operator|||
name|tiv
operator|->
name|data
operator|.
name|length
operator|!=
name|trailersz
condition|)
return|return
name|KRB5_BAD_MSIZE
return|;
comment|/*      * XXX replace with EVP_Sign? at least make create_checksum an iov      * function.      * XXX CTS EVP is broken, can't handle multi buffers :(      */
name|len
operator|=
name|block_sz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_SIGN_ONLY
condition|)
continue|continue;
name|len
operator|+=
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
expr_stmt|;
block|}
name|p
operator|=
name|q
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|q
argument_list|,
name|hiv
operator|->
name|data
operator|.
name|data
argument_list|,
name|hiv
operator|->
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|q
operator|+=
name|hiv
operator|->
name|data
operator|.
name|length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_DATA
operator|&&
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_SIGN_ONLY
condition|)
continue|continue;
name|memcpy
argument_list|(
name|q
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|data
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|q
operator|+=
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|piv
condition|)
name|memset
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
name|piv
operator|->
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|ret
operator|=
name|create_checksum
argument_list|(
name|context
argument_list|,
name|et
operator|->
name|keyed_checksum
argument_list|,
name|crypto
argument_list|,
name|INTEGRITY_USAGE
argument_list|(
name|usage
argument_list|)
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
operator|&
name|cksum
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|cksum
operator|.
name|checksum
operator|.
name|length
operator|!=
name|trailersz
condition|)
block|{
name|free_Checksum
argument_list|(
operator|&
name|cksum
argument_list|)
expr_stmt|;
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ret
operator|=
name|KRB5_CRYPTO_INTERNAL
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* save cksum at end */
name|memcpy
argument_list|(
name|tiv
operator|->
name|data
operator|.
name|data
argument_list|,
name|cksum
operator|.
name|checksum
operator|.
name|data
argument_list|,
name|cksum
operator|.
name|checksum
operator|.
name|length
argument_list|)
expr_stmt|;
name|free_Checksum
argument_list|(
operator|&
name|cksum
argument_list|)
expr_stmt|;
comment|/* XXX replace with EVP_Cipher */
name|p
operator|=
name|q
operator|=
name|malloc
argument_list|(
name|block_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|memcpy
argument_list|(
name|q
argument_list|,
name|hiv
operator|->
name|data
operator|.
name|data
argument_list|,
name|hiv
operator|->
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|q
operator|+=
name|hiv
operator|->
name|data
operator|.
name|length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_DATA
condition|)
continue|continue;
name|memcpy
argument_list|(
name|q
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|data
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|q
operator|+=
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|piv
condition|)
name|memset
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
name|piv
operator|->
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_get_derived_key
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|ENCRYPTION_USAGE
argument_list|(
name|usage
argument_list|)
argument_list|,
operator|&
name|dkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|_key_schedule
argument_list|(
name|context
argument_list|,
name|dkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
call|(
modifier|*
name|et
operator|->
name|encrypt
call|)
argument_list|(
name|context
argument_list|,
name|dkey
argument_list|,
name|p
argument_list|,
name|block_sz
argument_list|,
literal|1
argument_list|,
name|usage
argument_list|,
name|ivec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* now copy data back to buffers */
name|q
operator|=
name|p
expr_stmt|;
name|memcpy
argument_list|(
name|hiv
operator|->
name|data
operator|.
name|data
argument_list|,
name|q
argument_list|,
name|hiv
operator|->
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|q
operator|+=
name|hiv
operator|->
name|data
operator|.
name|length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_DATA
condition|)
continue|continue;
name|memcpy
argument_list|(
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|data
argument_list|,
name|q
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|q
operator|+=
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|piv
condition|)
name|memcpy
argument_list|(
name|piv
operator|->
name|data
operator|.
name|data
argument_list|,
name|q
argument_list|,
name|pad_sz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Inline decrypt a Kerberos message.  *  * @param context Kerberos context  * @param crypto Kerberos crypto context  * @param usage Key usage for this buffer  * @param data array of buffers to process  * @param num_data length of array  * @param ivec initial cbc/cts vector  *  * @return Return an error code or 0.  * @ingroup krb5_crypto  *  * 1. KRB5_CRYPTO_TYPE_HEADER  * 2. one KRB5_CRYPTO_TYPE_DATA and array [0,...] of KRB5_CRYPTO_TYPE_SIGN_ONLY in  *  any order, however the receiver have to aware of the  *  order. KRB5_CRYPTO_TYPE_SIGN_ONLY is commonly used unencrypoted  *  protocol headers and trailers. The output data will be of same  *  size as the input data or shorter.  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_decrypt_iov_ivec
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
name|krb5_crypto_iov
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|num_data
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|size_t
name|headersz
decl_stmt|,
name|trailersz
decl_stmt|,
name|len
decl_stmt|;
name|Checksum
name|cksum
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|struct
name|_krb5_key_data
modifier|*
name|dkey
decl_stmt|;
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|crypto
operator|->
name|et
decl_stmt|;
name|krb5_crypto_iov
modifier|*
name|tiv
decl_stmt|,
modifier|*
name|hiv
decl_stmt|;
if|if
condition|(
operator|!
name|derived_crypto
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
condition|)
block|{
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|KRB5_CRYPTO_INTERNAL
return|;
block|}
name|headersz
operator|=
name|et
operator|->
name|confoundersize
expr_stmt|;
name|hiv
operator|=
name|find_iv
argument_list|(
name|data
argument_list|,
name|num_data
argument_list|,
name|KRB5_CRYPTO_TYPE_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|hiv
operator|==
name|NULL
operator|||
name|hiv
operator|->
name|data
operator|.
name|length
operator|!=
name|headersz
condition|)
return|return
name|KRB5_BAD_MSIZE
return|;
comment|/* trailer */
name|trailersz
operator|=
name|CHECKSUMSIZE
argument_list|(
name|et
operator|->
name|keyed_checksum
argument_list|)
expr_stmt|;
name|tiv
operator|=
name|find_iv
argument_list|(
name|data
argument_list|,
name|num_data
argument_list|,
name|KRB5_CRYPTO_TYPE_TRAILER
argument_list|)
expr_stmt|;
if|if
condition|(
name|tiv
operator|->
name|data
operator|.
name|length
operator|!=
name|trailersz
condition|)
return|return
name|KRB5_BAD_MSIZE
return|;
comment|/* Find length of data we will decrypt */
name|len
operator|=
name|headersz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_DATA
condition|)
continue|continue;
name|len
operator|+=
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|%
name|et
operator|->
name|padsize
operator|)
operator|!=
literal|0
condition|)
block|{
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|KRB5_BAD_MSIZE
return|;
block|}
comment|/* XXX replace with EVP_Cipher */
name|p
operator|=
name|q
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|memcpy
argument_list|(
name|q
argument_list|,
name|hiv
operator|->
name|data
operator|.
name|data
argument_list|,
name|hiv
operator|->
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|q
operator|+=
name|hiv
operator|->
name|data
operator|.
name|length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_DATA
condition|)
continue|continue;
name|memcpy
argument_list|(
name|q
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|data
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|q
operator|+=
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
expr_stmt|;
block|}
name|ret
operator|=
name|_get_derived_key
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|ENCRYPTION_USAGE
argument_list|(
name|usage
argument_list|)
argument_list|,
operator|&
name|dkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|_key_schedule
argument_list|(
name|context
argument_list|,
name|dkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
call|(
modifier|*
name|et
operator|->
name|encrypt
call|)
argument_list|(
name|context
argument_list|,
name|dkey
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|usage
argument_list|,
name|ivec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* copy data back to buffers */
name|memcpy
argument_list|(
name|hiv
operator|->
name|data
operator|.
name|data
argument_list|,
name|p
argument_list|,
name|hiv
operator|->
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|hiv
operator|->
name|data
operator|.
name|length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_DATA
condition|)
continue|continue;
name|memcpy
argument_list|(
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|data
argument_list|,
name|q
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|q
operator|+=
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
expr_stmt|;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* check signature */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_SIGN_ONLY
condition|)
continue|continue;
name|len
operator|+=
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
expr_stmt|;
block|}
name|p
operator|=
name|q
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|memcpy
argument_list|(
name|q
argument_list|,
name|hiv
operator|->
name|data
operator|.
name|data
argument_list|,
name|hiv
operator|->
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|q
operator|+=
name|hiv
operator|->
name|data
operator|.
name|length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_DATA
operator|&&
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_SIGN_ONLY
condition|)
continue|continue;
name|memcpy
argument_list|(
name|q
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|data
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|q
operator|+=
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
expr_stmt|;
block|}
name|cksum
operator|.
name|checksum
operator|.
name|data
operator|=
name|tiv
operator|->
name|data
operator|.
name|data
expr_stmt|;
name|cksum
operator|.
name|checksum
operator|.
name|length
operator|=
name|tiv
operator|->
name|data
operator|.
name|length
expr_stmt|;
name|cksum
operator|.
name|cksumtype
operator|=
name|CHECKSUMTYPE
argument_list|(
name|et
operator|->
name|keyed_checksum
argument_list|)
expr_stmt|;
name|ret
operator|=
name|verify_checksum
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|INTEGRITY_USAGE
argument_list|(
name|usage
argument_list|)
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
operator|&
name|cksum
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Create a Kerberos message checksum.  *  * @param context Kerberos context  * @param crypto Kerberos crypto context  * @param usage Key usage for this buffer  * @param data array of buffers to process  * @param num_data length of array  * @param type output data  *  * @return Return an error code or 0.  * @ingroup krb5_crypto  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_create_checksum_iov
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
name|krb5_crypto_iov
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|num_data
parameter_list|,
name|krb5_cksumtype
modifier|*
name|type
parameter_list|)
block|{
name|Checksum
name|cksum
decl_stmt|;
name|krb5_crypto_iov
modifier|*
name|civ
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|derived_crypto
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
condition|)
block|{
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|KRB5_CRYPTO_INTERNAL
return|;
block|}
name|civ
operator|=
name|find_iv
argument_list|(
name|data
argument_list|,
name|num_data
argument_list|,
name|KRB5_CRYPTO_TYPE_CHECKSUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|civ
operator|==
name|NULL
condition|)
return|return
name|KRB5_BAD_MSIZE
return|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_DATA
operator|&&
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_SIGN_ONLY
condition|)
continue|continue;
name|len
operator|+=
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
expr_stmt|;
block|}
name|p
operator|=
name|q
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_DATA
operator|&&
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_SIGN_ONLY
condition|)
continue|continue;
name|memcpy
argument_list|(
name|q
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|data
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|q
operator|+=
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
expr_stmt|;
block|}
name|ret
operator|=
name|krb5_create_checksum
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|usage
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
operator|&
name|cksum
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|type
condition|)
operator|*
name|type
operator|=
name|cksum
operator|.
name|cksumtype
expr_stmt|;
if|if
condition|(
name|cksum
operator|.
name|checksum
operator|.
name|length
operator|>
name|civ
operator|->
name|data
operator|.
name|length
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_BAD_MSIZE
argument_list|,
name|N_
argument_list|(
literal|"Checksum larger then input buffer"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|free_Checksum
argument_list|(
operator|&
name|cksum
argument_list|)
expr_stmt|;
return|return
name|KRB5_BAD_MSIZE
return|;
block|}
name|civ
operator|->
name|data
operator|.
name|length
operator|=
name|cksum
operator|.
name|checksum
operator|.
name|length
expr_stmt|;
name|memcpy
argument_list|(
name|civ
operator|->
name|data
operator|.
name|data
argument_list|,
name|cksum
operator|.
name|checksum
operator|.
name|data
argument_list|,
name|civ
operator|->
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|free_Checksum
argument_list|(
operator|&
name|cksum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Verify a Kerberos message checksum.  *  * @param context Kerberos context  * @param crypto Kerberos crypto context  * @param usage Key usage for this buffer  * @param data array of buffers to process  * @param num_data length of array  * @param type return checksum type if not NULL  *  * @return Return an error code or 0.  * @ingroup krb5_crypto  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_verify_checksum_iov
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
name|krb5_crypto_iov
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|num_data
parameter_list|,
name|krb5_cksumtype
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|crypto
operator|->
name|et
decl_stmt|;
name|Checksum
name|cksum
decl_stmt|;
name|krb5_crypto_iov
modifier|*
name|civ
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|derived_crypto
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
condition|)
block|{
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|KRB5_CRYPTO_INTERNAL
return|;
block|}
name|civ
operator|=
name|find_iv
argument_list|(
name|data
argument_list|,
name|num_data
argument_list|,
name|KRB5_CRYPTO_TYPE_CHECKSUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|civ
operator|==
name|NULL
condition|)
return|return
name|KRB5_BAD_MSIZE
return|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_DATA
operator|&&
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_SIGN_ONLY
condition|)
continue|continue;
name|len
operator|+=
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
expr_stmt|;
block|}
name|p
operator|=
name|q
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_DATA
operator|&&
name|data
index|[
name|i
index|]
operator|.
name|flags
operator|!=
name|KRB5_CRYPTO_TYPE_SIGN_ONLY
condition|)
continue|continue;
name|memcpy
argument_list|(
name|q
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|data
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|q
operator|+=
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
expr_stmt|;
block|}
name|cksum
operator|.
name|cksumtype
operator|=
name|CHECKSUMTYPE
argument_list|(
name|et
operator|->
name|keyed_checksum
argument_list|)
expr_stmt|;
name|cksum
operator|.
name|checksum
operator|.
name|length
operator|=
name|civ
operator|->
name|data
operator|.
name|length
expr_stmt|;
name|cksum
operator|.
name|checksum
operator|.
name|data
operator|=
name|civ
operator|->
name|data
operator|.
name|data
expr_stmt|;
name|ret
operator|=
name|krb5_verify_checksum
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|usage
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
operator|&
name|cksum
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|type
condition|)
operator|*
name|type
operator|=
name|cksum
operator|.
name|cksumtype
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_crypto_length
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|int
name|type
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
operator|!
name|derived_crypto
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|EINVAL
argument_list|,
literal|"not a derived crypto"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|KRB5_CRYPTO_TYPE_EMPTY
case|:
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KRB5_CRYPTO_TYPE_HEADER
case|:
operator|*
name|len
operator|=
name|crypto
operator|->
name|et
operator|->
name|blocksize
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KRB5_CRYPTO_TYPE_DATA
case|:
case|case
name|KRB5_CRYPTO_TYPE_SIGN_ONLY
case|:
comment|/* len must already been filled in */
return|return
literal|0
return|;
case|case
name|KRB5_CRYPTO_TYPE_PADDING
case|:
if|if
condition|(
name|crypto
operator|->
name|et
operator|->
name|padsize
operator|>
literal|1
condition|)
operator|*
name|len
operator|=
name|crypto
operator|->
name|et
operator|->
name|padsize
expr_stmt|;
else|else
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KRB5_CRYPTO_TYPE_TRAILER
case|:
operator|*
name|len
operator|=
name|CHECKSUMSIZE
argument_list|(
name|crypto
operator|->
name|et
operator|->
name|keyed_checksum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KRB5_CRYPTO_TYPE_CHECKSUM
case|:
if|if
condition|(
name|crypto
operator|->
name|et
operator|->
name|keyed_checksum
condition|)
operator|*
name|len
operator|=
name|CHECKSUMSIZE
argument_list|(
name|crypto
operator|->
name|et
operator|->
name|keyed_checksum
argument_list|)
expr_stmt|;
else|else
operator|*
name|len
operator|=
name|CHECKSUMSIZE
argument_list|(
name|crypto
operator|->
name|et
operator|->
name|checksum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|EINVAL
argument_list|,
literal|"%d not a supported type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_crypto_length_iov
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|krb5_crypto_iov
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|num_data
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_data
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|krb5_crypto_length
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
operator|&
name|data
index|[
name|i
index|]
operator|.
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_encrypt_ivec
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|krb5_data
modifier|*
name|result
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|)
block|{
if|if
condition|(
name|derived_crypto
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
condition|)
return|return
name|encrypt_internal_derived
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|usage
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|result
argument_list|,
name|ivec
argument_list|)
return|;
elseif|else
if|if
condition|(
name|special_crypto
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
condition|)
return|return
name|encrypt_internal_special
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|usage
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|result
argument_list|,
name|ivec
argument_list|)
return|;
else|else
return|return
name|encrypt_internal
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|result
argument_list|,
name|ivec
argument_list|)
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_encrypt
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|krb5_data
modifier|*
name|result
parameter_list|)
block|{
return|return
name|krb5_encrypt_ivec
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|usage
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|result
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_encrypt_EncryptedData
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|kvno
parameter_list|,
name|EncryptedData
modifier|*
name|result
parameter_list|)
block|{
name|result
operator|->
name|etype
operator|=
name|CRYPTO_ETYPE
argument_list|(
name|crypto
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvno
condition|)
block|{
name|ALLOC
argument_list|(
name|result
operator|->
name|kvno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|result
operator|->
name|kvno
operator|=
name|kvno
expr_stmt|;
block|}
else|else
name|result
operator|->
name|kvno
operator|=
name|NULL
expr_stmt|;
return|return
name|krb5_encrypt
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|usage
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
operator|&
name|result
operator|->
name|cipher
argument_list|)
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_decrypt_ivec
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|krb5_data
modifier|*
name|result
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|)
block|{
if|if
condition|(
name|derived_crypto
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
condition|)
return|return
name|decrypt_internal_derived
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|usage
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|result
argument_list|,
name|ivec
argument_list|)
return|;
elseif|else
if|if
condition|(
name|special_crypto
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
condition|)
return|return
name|decrypt_internal_special
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|usage
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|result
argument_list|,
name|ivec
argument_list|)
return|;
else|else
return|return
name|decrypt_internal
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|result
argument_list|,
name|ivec
argument_list|)
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_decrypt
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|krb5_data
modifier|*
name|result
parameter_list|)
block|{
return|return
name|krb5_decrypt_ivec
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|usage
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|result
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_decrypt_EncryptedData
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
specifier|const
name|EncryptedData
modifier|*
name|e
parameter_list|,
name|krb5_data
modifier|*
name|result
parameter_list|)
block|{
return|return
name|krb5_decrypt
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|usage
argument_list|,
name|e
operator|->
name|cipher
operator|.
name|data
argument_list|,
name|e
operator|->
name|cipher
operator|.
name|length
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************  *                                                          *  ************************************************************/
end_comment

begin_function
name|krb5_error_code
name|_krb5_derive_key
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|struct
name|_krb5_encryption_type
modifier|*
name|et
parameter_list|,
name|struct
name|_krb5_key_data
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|constant
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|k
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|nblocks
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|krb5_error_code
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|_krb5_key_type
modifier|*
name|kt
init|=
name|et
operator|->
name|keytype
decl_stmt|;
name|ret
operator|=
name|_key_schedule
argument_list|(
name|context
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|et
operator|->
name|blocksize
operator|*
literal|8
operator|<
name|kt
operator|->
name|bits
operator|||
name|len
operator|!=
name|et
operator|->
name|blocksize
condition|)
block|{
name|nblocks
operator|=
operator|(
name|kt
operator|->
name|bits
operator|+
name|et
operator|->
name|blocksize
operator|*
literal|8
operator|-
literal|1
operator|)
operator|/
operator|(
name|et
operator|->
name|blocksize
operator|*
literal|8
operator|)
expr_stmt|;
name|k
operator|=
name|malloc
argument_list|(
name|nblocks
operator|*
name|et
operator|->
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|_krb5_n_fold
argument_list|(
name|constant
argument_list|,
name|len
argument_list|,
name|k
argument_list|,
name|et
operator|->
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblocks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|k
operator|+
name|i
operator|*
name|et
operator|->
name|blocksize
argument_list|,
name|k
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
name|et
operator|->
name|blocksize
argument_list|,
name|et
operator|->
name|blocksize
argument_list|)
expr_stmt|;
call|(
modifier|*
name|et
operator|->
name|encrypt
call|)
argument_list|(
name|context
argument_list|,
name|key
argument_list|,
name|k
operator|+
name|i
operator|*
name|et
operator|->
name|blocksize
argument_list|,
name|et
operator|->
name|blocksize
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* this case is probably broken, but won't be run anyway */
name|void
modifier|*
name|c
init|=
name|malloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|size_t
name|res_len
init|=
operator|(
name|kt
operator|->
name|bits
operator|+
literal|7
operator|)
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
operator|&&
name|c
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memcpy
argument_list|(
name|c
argument_list|,
name|constant
argument_list|,
name|len
argument_list|)
expr_stmt|;
call|(
modifier|*
name|et
operator|->
name|encrypt
call|)
argument_list|(
name|context
argument_list|,
name|key
argument_list|,
name|c
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|k
operator|=
name|malloc
argument_list|(
name|res_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_len
operator|!=
literal|0
operator|&&
name|k
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|_krb5_n_fold
argument_list|(
name|c
argument_list|,
name|len
argument_list|,
name|k
argument_list|,
name|res_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* XXX keytype dependent post-processing */
switch|switch
condition|(
name|kt
operator|->
name|type
condition|)
block|{
case|case
name|ETYPE_OLD_DES3_CBC_SHA1
case|:
name|_krb5_DES3_random_to_key
argument_list|(
name|context
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|k
argument_list|,
name|nblocks
operator|*
name|et
operator|->
name|blocksize
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCTYPE_AES128_CTS_HMAC_SHA1_96
case|:
case|case
name|ENCTYPE_AES256_CTS_HMAC_SHA1_96
case|:
name|memcpy
argument_list|(
name|key
operator|->
name|key
operator|->
name|keyvalue
operator|.
name|data
argument_list|,
name|k
argument_list|,
name|key
operator|->
name|key
operator|->
name|keyvalue
operator|.
name|length
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|KRB5_CRYPTO_INTERNAL
expr_stmt|;
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ret
argument_list|,
name|N_
argument_list|(
literal|"derive_key() called with unknown keytype (%u)"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|kt
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
if|if
condition|(
name|key
operator|->
name|schedule
condition|)
block|{
name|free_key_schedule
argument_list|(
name|context
argument_list|,
name|key
argument_list|,
name|et
argument_list|)
expr_stmt|;
name|key
operator|->
name|schedule
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|k
condition|)
block|{
name|memset
argument_list|(
name|k
argument_list|,
literal|0
argument_list|,
name|nblocks
operator|*
name|et
operator|->
name|blocksize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|_krb5_key_data
modifier|*
name|_new_derived_key
parameter_list|(
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|)
block|{
name|struct
name|_krb5_key_usage
modifier|*
name|d
init|=
name|crypto
operator|->
name|key_usage
decl_stmt|;
name|d
operator|=
name|realloc
argument_list|(
name|d
argument_list|,
operator|(
name|crypto
operator|->
name|num_key_usage
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|crypto
operator|->
name|key_usage
operator|=
name|d
expr_stmt|;
name|d
operator|+=
name|crypto
operator|->
name|num_key_usage
operator|++
expr_stmt|;
name|memset
argument_list|(
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|usage
operator|=
name|usage
expr_stmt|;
return|return
operator|&
name|d
operator|->
name|key
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_derive_key
parameter_list|(
name|krb5_context
name|context
parameter_list|,
specifier|const
name|krb5_keyblock
modifier|*
name|key
parameter_list|,
name|krb5_enctype
name|etype
parameter_list|,
specifier|const
name|void
modifier|*
name|constant
parameter_list|,
name|size_t
name|constant_len
parameter_list|,
name|krb5_keyblock
modifier|*
modifier|*
name|derived_key
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|struct
name|_krb5_encryption_type
modifier|*
name|et
decl_stmt|;
name|struct
name|_krb5_key_data
name|d
decl_stmt|;
operator|*
name|derived_key
operator|=
name|NULL
expr_stmt|;
name|et
operator|=
name|_krb5_find_enctype
argument_list|(
name|etype
argument_list|)
expr_stmt|;
if|if
condition|(
name|et
operator|==
name|NULL
condition|)
block|{
return|return
name|unsupported_enctype
argument_list|(
name|context
argument_list|,
name|etype
argument_list|)
return|;
block|}
name|ret
operator|=
name|krb5_copy_keyblock
argument_list|(
name|context
argument_list|,
name|key
argument_list|,
operator|&
name|d
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|d
operator|.
name|schedule
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|_krb5_derive_key
argument_list|(
name|context
argument_list|,
name|et
argument_list|,
operator|&
name|d
argument_list|,
name|constant
argument_list|,
name|constant_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|ret
operator|=
name|krb5_copy_keyblock
argument_list|(
name|context
argument_list|,
name|d
operator|.
name|key
argument_list|,
name|derived_key
argument_list|)
expr_stmt|;
name|_krb5_free_key_data
argument_list|(
name|context
argument_list|,
operator|&
name|d
argument_list|,
name|et
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|_get_derived_key
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|unsigned
name|usage
parameter_list|,
name|struct
name|_krb5_key_data
modifier|*
modifier|*
name|key
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|_krb5_key_data
modifier|*
name|d
decl_stmt|;
name|unsigned
name|char
name|constant
index|[
literal|5
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|crypto
operator|->
name|num_key_usage
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|crypto
operator|->
name|key_usage
index|[
name|i
index|]
operator|.
name|usage
operator|==
name|usage
condition|)
block|{
operator|*
name|key
operator|=
operator|&
name|crypto
operator|->
name|key_usage
index|[
name|i
index|]
operator|.
name|key
expr_stmt|;
return|return
literal|0
return|;
block|}
name|d
operator|=
name|_new_derived_key
argument_list|(
name|crypto
argument_list|,
name|usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|krb5_copy_keyblock
argument_list|(
name|context
argument_list|,
name|crypto
operator|->
name|key
operator|.
name|key
argument_list|,
operator|&
name|d
operator|->
name|key
argument_list|)
expr_stmt|;
name|_krb5_put_int
argument_list|(
name|constant
argument_list|,
name|usage
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|_krb5_derive_key
argument_list|(
name|context
argument_list|,
name|crypto
operator|->
name|et
argument_list|,
name|d
argument_list|,
name|constant
argument_list|,
sizeof|sizeof
argument_list|(
name|constant
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|key
operator|=
name|d
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Create a crypto context used for all encryption and signature  * operation. The encryption type to use is taken from the key, but  * can be overridden with the enctype parameter.  This can be useful  * for encryptions types which is compatiable (DES for example).  *  * To free the crypto context, use krb5_crypto_destroy().  *  * @param context Kerberos context  * @param key the key block information with all key data  * @param etype the encryption type  * @param crypto the resulting crypto context  *  * @return Return an error code or 0.  *  * @ingroup krb5_crypto  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_crypto_init
parameter_list|(
name|krb5_context
name|context
parameter_list|,
specifier|const
name|krb5_keyblock
modifier|*
name|key
parameter_list|,
name|krb5_enctype
name|etype
parameter_list|,
name|krb5_crypto
modifier|*
name|crypto
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|ALLOC
argument_list|(
operator|*
name|crypto
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|crypto
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
name|N_
argument_list|(
literal|"malloc: out of memory"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
name|etype
operator|==
name|ETYPE_NULL
condition|)
name|etype
operator|=
name|key
operator|->
name|keytype
expr_stmt|;
operator|(
operator|*
name|crypto
operator|)
operator|->
name|et
operator|=
name|_krb5_find_enctype
argument_list|(
name|etype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|crypto
operator|)
operator|->
name|et
operator|==
name|NULL
operator|||
operator|(
operator|(
operator|*
name|crypto
operator|)
operator|->
name|et
operator|->
name|flags
operator|&
name|F_DISABLED
operator|)
condition|)
block|{
name|free
argument_list|(
operator|*
name|crypto
argument_list|)
expr_stmt|;
operator|*
name|crypto
operator|=
name|NULL
expr_stmt|;
return|return
name|unsupported_enctype
argument_list|(
name|context
argument_list|,
name|etype
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|crypto
operator|)
operator|->
name|et
operator|->
name|keytype
operator|->
name|size
operator|!=
name|key
operator|->
name|keyvalue
operator|.
name|length
condition|)
block|{
name|free
argument_list|(
operator|*
name|crypto
argument_list|)
expr_stmt|;
operator|*
name|crypto
operator|=
name|NULL
expr_stmt|;
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_BAD_KEYSIZE
argument_list|,
literal|"encryption key has bad length"
argument_list|)
expr_stmt|;
return|return
name|KRB5_BAD_KEYSIZE
return|;
block|}
name|ret
operator|=
name|krb5_copy_keyblock
argument_list|(
name|context
argument_list|,
name|key
argument_list|,
operator|&
operator|(
operator|*
name|crypto
operator|)
operator|->
name|key
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
operator|*
name|crypto
argument_list|)
expr_stmt|;
operator|*
name|crypto
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
operator|(
operator|*
name|crypto
operator|)
operator|->
name|key
operator|.
name|schedule
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|crypto
operator|)
operator|->
name|num_key_usage
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|crypto
operator|)
operator|->
name|key_usage
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_key_schedule
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|struct
name|_krb5_key_data
modifier|*
name|key
parameter_list|,
name|struct
name|_krb5_encryption_type
modifier|*
name|et
parameter_list|)
block|{
if|if
condition|(
name|et
operator|->
name|keytype
operator|->
name|cleanup
condition|)
call|(
modifier|*
name|et
operator|->
name|keytype
operator|->
name|cleanup
call|)
argument_list|(
name|context
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|key
operator|->
name|schedule
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|key
operator|->
name|schedule
operator|->
name|length
argument_list|)
expr_stmt|;
name|krb5_free_data
argument_list|(
name|context
argument_list|,
name|key
operator|->
name|schedule
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_krb5_free_key_data
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|struct
name|_krb5_key_data
modifier|*
name|key
parameter_list|,
name|struct
name|_krb5_encryption_type
modifier|*
name|et
parameter_list|)
block|{
name|krb5_free_keyblock
argument_list|(
name|context
argument_list|,
name|key
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|schedule
condition|)
block|{
name|free_key_schedule
argument_list|(
name|context
argument_list|,
name|key
argument_list|,
name|et
argument_list|)
expr_stmt|;
name|key
operator|->
name|schedule
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_key_usage
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|struct
name|_krb5_key_usage
modifier|*
name|ku
parameter_list|,
name|struct
name|_krb5_encryption_type
modifier|*
name|et
parameter_list|)
block|{
name|_krb5_free_key_data
argument_list|(
name|context
argument_list|,
operator|&
name|ku
operator|->
name|key
argument_list|,
name|et
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Free a crypto context created by krb5_crypto_init().  *  * @param context Kerberos context  * @param crypto crypto context to free  *  * @return Return an error code or 0.  *  * @ingroup krb5_crypto  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_crypto_destroy
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|crypto
operator|->
name|num_key_usage
condition|;
name|i
operator|++
control|)
name|free_key_usage
argument_list|(
name|context
argument_list|,
operator|&
name|crypto
operator|->
name|key_usage
index|[
name|i
index|]
argument_list|,
name|crypto
operator|->
name|et
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|crypto
operator|->
name|key_usage
argument_list|)
expr_stmt|;
name|_krb5_free_key_data
argument_list|(
name|context
argument_list|,
operator|&
name|crypto
operator|->
name|key
argument_list|,
name|crypto
operator|->
name|et
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|crypto
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Return the blocksize used algorithm referenced by the crypto context  *  * @param context Kerberos context  * @param crypto crypto context to query  * @param blocksize the resulting blocksize  *  * @return Return an error code or 0.  *  * @ingroup krb5_crypto  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_crypto_getblocksize
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|size_t
modifier|*
name|blocksize
parameter_list|)
block|{
operator|*
name|blocksize
operator|=
name|crypto
operator|->
name|et
operator|->
name|blocksize
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Return the encryption type used by the crypto context  *  * @param context Kerberos context  * @param crypto crypto context to query  * @param enctype the resulting encryption type  *  * @return Return an error code or 0.  *  * @ingroup krb5_crypto  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_crypto_getenctype
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|krb5_enctype
modifier|*
name|enctype
parameter_list|)
block|{
operator|*
name|enctype
operator|=
name|crypto
operator|->
name|et
operator|->
name|type
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Return the padding size used by the crypto context  *  * @param context Kerberos context  * @param crypto crypto context to query  * @param padsize the return padding size  *  * @return Return an error code or 0.  *  * @ingroup krb5_crypto  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_crypto_getpadsize
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|size_t
modifier|*
name|padsize
parameter_list|)
block|{
operator|*
name|padsize
operator|=
name|crypto
operator|->
name|et
operator|->
name|padsize
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Return the confounder size used by the crypto context  *  * @param context Kerberos context  * @param crypto crypto context to query  * @param confoundersize the returned confounder size  *  * @return Return an error code or 0.  *  * @ingroup krb5_crypto  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_crypto_getconfoundersize
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|size_t
modifier|*
name|confoundersize
parameter_list|)
block|{
operator|*
name|confoundersize
operator|=
name|crypto
operator|->
name|et
operator|->
name|confoundersize
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Disable encryption type  *  * @param context Kerberos 5 context  * @param enctype encryption type to disable  *  * @return Return an error code or 0.  *  * @ingroup krb5_crypto  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_enctype_disable
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_enctype
name|enctype
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|_krb5_find_enctype
argument_list|(
name|enctype
argument_list|)
decl_stmt|;
if|if
condition|(
name|et
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|context
condition|)
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_ETYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"encryption type %d not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|enctype
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_ETYPE_NOSUPP
return|;
block|}
name|et
operator|->
name|flags
operator||=
name|F_DISABLED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Enable encryption type  *  * @param context Kerberos 5 context  * @param enctype encryption type to enable  *  * @return Return an error code or 0.  *  * @ingroup krb5_crypto  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_enctype_enable
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_enctype
name|enctype
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|_krb5_find_enctype
argument_list|(
name|enctype
argument_list|)
decl_stmt|;
if|if
condition|(
name|et
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|context
condition|)
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_ETYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"encryption type %d not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|enctype
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_ETYPE_NOSUPP
return|;
block|}
name|et
operator|->
name|flags
operator|&=
operator|~
name|F_DISABLED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Enable or disable all weak encryption types  *  * @param context Kerberos 5 context  * @param enable true to enable, false to disable  *  * @return Return an error code or 0.  *  * @ingroup krb5_crypto  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_allow_weak_crypto
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_boolean
name|enable
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_krb5_num_etypes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|F_WEAK
condition|)
block|{
if|if
condition|(
name|enable
condition|)
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|flags
operator|&=
operator|~
name|F_DISABLED
expr_stmt|;
else|else
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|flags
operator||=
name|F_DISABLED
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|wrapped_length
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|size_t
name|data_len
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|crypto
operator|->
name|et
decl_stmt|;
name|size_t
name|padsize
init|=
name|et
operator|->
name|padsize
decl_stmt|;
name|size_t
name|checksumsize
init|=
name|CHECKSUMSIZE
argument_list|(
name|et
operator|->
name|checksum
argument_list|)
decl_stmt|;
name|size_t
name|res
decl_stmt|;
name|res
operator|=
name|et
operator|->
name|confoundersize
operator|+
name|checksumsize
operator|+
name|data_len
expr_stmt|;
name|res
operator|=
operator|(
name|res
operator|+
name|padsize
operator|-
literal|1
operator|)
operator|/
name|padsize
operator|*
name|padsize
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|wrapped_length_dervied
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|size_t
name|data_len
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|crypto
operator|->
name|et
decl_stmt|;
name|size_t
name|padsize
init|=
name|et
operator|->
name|padsize
decl_stmt|;
name|size_t
name|res
decl_stmt|;
name|res
operator|=
name|et
operator|->
name|confoundersize
operator|+
name|data_len
expr_stmt|;
name|res
operator|=
operator|(
name|res
operator|+
name|padsize
operator|-
literal|1
operator|)
operator|/
name|padsize
operator|*
name|padsize
expr_stmt|;
if|if
condition|(
name|et
operator|->
name|keyed_checksum
condition|)
name|res
operator|+=
name|et
operator|->
name|keyed_checksum
operator|->
name|checksumsize
expr_stmt|;
else|else
name|res
operator|+=
name|et
operator|->
name|checksum
operator|->
name|checksumsize
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Return the size of an encrypted packet of length `data_len'  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|size_t
name|KRB5_LIB_CALL
name|krb5_get_wrapped_length
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|,
name|size_t
name|data_len
parameter_list|)
block|{
if|if
condition|(
name|derived_crypto
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
condition|)
return|return
name|wrapped_length_dervied
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|data_len
argument_list|)
return|;
else|else
return|return
name|wrapped_length
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|data_len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the size of an encrypted packet of length `data_len'  */
end_comment

begin_function
specifier|static
name|size_t
name|crypto_overhead
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|crypto
operator|->
name|et
decl_stmt|;
name|size_t
name|res
decl_stmt|;
name|res
operator|=
name|CHECKSUMSIZE
argument_list|(
name|et
operator|->
name|checksum
argument_list|)
expr_stmt|;
name|res
operator|+=
name|et
operator|->
name|confoundersize
expr_stmt|;
if|if
condition|(
name|et
operator|->
name|padsize
operator|>
literal|1
condition|)
name|res
operator|+=
name|et
operator|->
name|padsize
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|crypto_overhead_dervied
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|crypto
operator|->
name|et
decl_stmt|;
name|size_t
name|res
decl_stmt|;
if|if
condition|(
name|et
operator|->
name|keyed_checksum
condition|)
name|res
operator|=
name|CHECKSUMSIZE
argument_list|(
name|et
operator|->
name|keyed_checksum
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|CHECKSUMSIZE
argument_list|(
name|et
operator|->
name|checksum
argument_list|)
expr_stmt|;
name|res
operator|+=
name|et
operator|->
name|confoundersize
expr_stmt|;
if|if
condition|(
name|et
operator|->
name|padsize
operator|>
literal|1
condition|)
name|res
operator|+=
name|et
operator|->
name|padsize
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|size_t
name|KRB5_LIB_CALL
name|krb5_crypto_overhead
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_crypto
name|crypto
parameter_list|)
block|{
if|if
condition|(
name|derived_crypto
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
condition|)
return|return
name|crypto_overhead_dervied
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
return|;
else|else
return|return
name|crypto_overhead
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Converts the random bytestring to a protocol key according to  * Kerberos crypto frame work. It may be assumed that all the bits of  * the input string are equally random, even though the entropy  * present in the random source may be limited.  *  * @param context Kerberos 5 context  * @param type the enctype resulting key will be of  * @param data input random data to convert to a key  * @param size size of input random data, at least krb5_enctype_keysize() long  * @param key key, output key, free with krb5_free_keyblock_contents()  *  * @return Return an error code or 0.  *  * @ingroup krb5_crypto  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_random_to_key
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_enctype
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|krb5_keyblock
modifier|*
name|key
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|_krb5_find_enctype
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|et
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_ETYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"encryption type %d not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_ETYPE_NOSUPP
return|;
block|}
if|if
condition|(
operator|(
name|et
operator|->
name|keytype
operator|->
name|bits
operator|+
literal|7
operator|)
operator|/
literal|8
operator|>
name|size
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_ETYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"encryption key %s needs %d bytes "
literal|"of random to make an encryption key "
literal|"out of it"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|et
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|et
operator|->
name|keytype
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_ETYPE_NOSUPP
return|;
block|}
name|ret
operator|=
name|krb5_data_alloc
argument_list|(
operator|&
name|key
operator|->
name|keyvalue
argument_list|,
name|et
operator|->
name|keytype
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|key
operator|->
name|keytype
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|et
operator|->
name|keytype
operator|->
name|random_to_key
condition|)
call|(
modifier|*
name|et
operator|->
name|keytype
operator|->
name|random_to_key
call|)
argument_list|(
name|context
argument_list|,
name|key
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|key
operator|->
name|keyvalue
operator|.
name|data
argument_list|,
name|data
argument_list|,
name|et
operator|->
name|keytype
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_crypto_prf_length
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_enctype
name|type
parameter_list|,
name|size_t
modifier|*
name|length
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|_krb5_find_enctype
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|et
operator|==
name|NULL
operator|||
name|et
operator|->
name|prf_length
operator|==
literal|0
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_ETYPE_NOSUPP
argument_list|,
name|N_
argument_list|(
literal|"encryption type %d not supported"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_ETYPE_NOSUPP
return|;
block|}
operator|*
name|length
operator|=
name|et
operator|->
name|prf_length
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_crypto_prf
parameter_list|(
name|krb5_context
name|context
parameter_list|,
specifier|const
name|krb5_crypto
name|crypto
parameter_list|,
specifier|const
name|krb5_data
modifier|*
name|input
parameter_list|,
name|krb5_data
modifier|*
name|output
parameter_list|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|et
init|=
name|crypto
operator|->
name|et
decl_stmt|;
name|krb5_data_zero
argument_list|(
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|et
operator|->
name|prf
operator|==
name|NULL
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_ETYPE_NOSUPP
argument_list|,
literal|"kerberos prf for %s not supported"
argument_list|,
name|et
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_ETYPE_NOSUPP
return|;
block|}
return|return
call|(
modifier|*
name|et
operator|->
name|prf
call|)
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
name|input
argument_list|,
name|output
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|krb5_crypto_prfplus
parameter_list|(
name|krb5_context
name|context
parameter_list|,
specifier|const
name|krb5_crypto
name|crypto
parameter_list|,
specifier|const
name|krb5_data
modifier|*
name|input
parameter_list|,
name|size_t
name|length
parameter_list|,
name|krb5_data
modifier|*
name|output
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_data
name|input2
decl_stmt|;
name|unsigned
name|char
name|i
init|=
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|krb5_data_zero
argument_list|(
operator|&
name|input2
argument_list|)
expr_stmt|;
name|krb5_data_zero
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ret
operator|=
name|krb5_data_alloc
argument_list|(
name|output
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|krb5_data_alloc
argument_list|(
operator|&
name|input2
argument_list|,
name|input
operator|->
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|input2
operator|.
name|data
operator|)
operator|+
literal|1
argument_list|,
name|input
operator|->
name|data
argument_list|,
name|input
operator|->
name|length
argument_list|)
expr_stmt|;
name|p
operator|=
name|output
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|length
condition|)
block|{
name|krb5_data
name|block
decl_stmt|;
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|input2
operator|.
name|data
operator|)
index|[
literal|0
index|]
operator|=
name|i
operator|++
expr_stmt|;
name|ret
operator|=
name|krb5_crypto_prf
argument_list|(
name|context
argument_list|,
name|crypto
argument_list|,
operator|&
name|input2
argument_list|,
operator|&
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|block
operator|.
name|length
operator|<
name|length
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|block
operator|.
name|data
argument_list|,
name|block
operator|.
name|length
argument_list|)
expr_stmt|;
name|length
operator|-=
name|block
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|block
operator|.
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|+=
name|block
operator|.
name|length
expr_stmt|;
name|krb5_data_free
argument_list|(
operator|&
name|block
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|krb5_data_free
argument_list|(
operator|&
name|input2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|krb5_data_free
argument_list|(
name|output
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * The FX-CF2 key derivation function, used in FAST and preauth framework.  *  * @param context Kerberos 5 context  * @param crypto1 first key to combine  * @param crypto2 second key to combine  * @param pepper1 factor to combine with first key to garante uniqueness  * @param pepper2 factor to combine with second key to garante uniqueness  * @param enctype the encryption type of the resulting key  * @param res allocated key, free with krb5_free_keyblock_contents()  *  * @return Return an error code or 0.  *  * @ingroup krb5_crypto  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_crypto_fx_cf2
parameter_list|(
name|krb5_context
name|context
parameter_list|,
specifier|const
name|krb5_crypto
name|crypto1
parameter_list|,
specifier|const
name|krb5_crypto
name|crypto2
parameter_list|,
name|krb5_data
modifier|*
name|pepper1
parameter_list|,
name|krb5_data
modifier|*
name|pepper2
parameter_list|,
name|krb5_enctype
name|enctype
parameter_list|,
name|krb5_keyblock
modifier|*
name|res
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_data
name|os1
decl_stmt|,
name|os2
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|keysize
decl_stmt|;
name|memset
argument_list|(
name|res
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|krb5_enctype_keysize
argument_list|(
name|context
argument_list|,
name|enctype
argument_list|,
operator|&
name|keysize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|krb5_data_alloc
argument_list|(
operator|&
name|res
operator|->
name|keyvalue
argument_list|,
name|keysize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|krb5_crypto_prfplus
argument_list|(
name|context
argument_list|,
name|crypto1
argument_list|,
name|pepper1
argument_list|,
name|keysize
argument_list|,
operator|&
name|os1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|krb5_crypto_prfplus
argument_list|(
name|context
argument_list|,
name|crypto2
argument_list|,
name|pepper2
argument_list|,
name|keysize
argument_list|,
operator|&
name|os2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|res
operator|->
name|keytype
operator|=
name|enctype
expr_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|p1
init|=
name|os1
operator|.
name|data
decl_stmt|,
modifier|*
name|p2
init|=
name|os2
operator|.
name|data
decl_stmt|,
modifier|*
name|p3
init|=
name|res
operator|->
name|keyvalue
operator|.
name|data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keysize
condition|;
name|i
operator|++
control|)
name|p3
index|[
name|i
index|]
operator|=
name|p1
index|[
name|i
index|]
operator|^
name|p2
index|[
name|i
index|]
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|ret
condition|)
name|krb5_data_free
argument_list|(
operator|&
name|res
operator|->
name|keyvalue
argument_list|)
expr_stmt|;
name|krb5_data_free
argument_list|(
operator|&
name|os1
argument_list|)
expr_stmt|;
name|krb5_data_free
argument_list|(
operator|&
name|os2
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|HEIMDAL_SMALLER
end_ifndef

begin_comment
comment|/**  * Deprecated: keytypes doesn't exists, they are really enctypes.  *  * @ingroup krb5_deprecated  */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_error_code
name|KRB5_LIB_CALL
name|krb5_keytype_to_enctypes
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_keytype
name|keytype
parameter_list|,
name|unsigned
modifier|*
name|len
parameter_list|,
name|krb5_enctype
modifier|*
modifier|*
name|val
parameter_list|)
function|KRB5_DEPRECATED_FUNCTION
parameter_list|(
function|"Use X instead"
end_function

begin_block
unit|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|n
init|=
literal|0
decl_stmt|;
name|krb5_enctype
modifier|*
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
name|_krb5_num_etypes
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|keytype
operator|->
name|type
operator|==
name|keytype
operator|&&
operator|!
operator|(
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|F_PSEUDO
operator|)
operator|&&
name|krb5_enctype_valid
argument_list|(
name|context
argument_list|,
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|type
argument_list|)
operator|==
literal|0
condition|)
operator|++
name|n
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|KRB5_PROG_KEYTYPE_NOSUPP
argument_list|,
literal|"Keytype have no mapping"
argument_list|)
expr_stmt|;
return|return
name|KRB5_PROG_KEYTYPE_NOSUPP
return|;
block|}
name|ret
operator|=
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
operator|&&
name|n
operator|!=
literal|0
condition|)
block|{
name|krb5_set_error_message
argument_list|(
name|context
argument_list|,
name|ENOMEM
argument_list|,
literal|"malloc: out of memory"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|_krb5_num_etypes
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|keytype
operator|->
name|type
operator|==
name|keytype
operator|&&
operator|!
operator|(
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|F_PSEUDO
operator|)
operator|&&
name|krb5_enctype_valid
argument_list|(
name|context
argument_list|,
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|type
argument_list|)
operator|==
literal|0
condition|)
name|ret
index|[
name|n
operator|++
index|]
operator|=
name|_krb5_etypes
index|[
name|i
index|]
operator|->
name|type
expr_stmt|;
block|}
operator|*
name|len
operator|=
name|n
expr_stmt|;
operator|*
name|val
operator|=
name|ret
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/**  * Deprecated: keytypes doesn't exists, they are really enctypes.  *  * @ingroup krb5_deprecated  */
end_comment

begin_comment
comment|/* if two enctypes have compatible keys */
end_comment

begin_function
name|KRB5_LIB_FUNCTION
name|krb5_boolean
name|KRB5_LIB_CALL
name|krb5_enctypes_compatible_keys
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_enctype
name|etype1
parameter_list|,
name|krb5_enctype
name|etype2
parameter_list|)
function|KRB5_DEPRECATED_FUNCTION
parameter_list|(
function|"Use X instead"
end_function

begin_block
unit|)
block|{
name|struct
name|_krb5_encryption_type
modifier|*
name|e1
init|=
name|_krb5_find_enctype
argument_list|(
name|etype1
argument_list|)
decl_stmt|;
name|struct
name|_krb5_encryption_type
modifier|*
name|e2
init|=
name|_krb5_find_enctype
argument_list|(
name|etype2
argument_list|)
decl_stmt|;
return|return
name|e1
operator|!=
name|NULL
operator|&&
name|e2
operator|!=
name|NULL
operator|&&
name|e1
operator|->
name|keytype
operator|==
name|e2
operator|->
name|keytype
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HEIMDAL_SMALLER */
end_comment

end_unit

