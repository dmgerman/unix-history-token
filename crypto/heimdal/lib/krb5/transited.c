begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997 - 2000 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).   * All rights reserved.   *  * Redistribution and use in source and binary forms, with or without   * modification, are permitted provided that the following conditions   * are met:   *  * 1. Redistributions of source code must retain the above copyright   *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright   *    notice, this list of conditions and the following disclaimer in the   *    documentation and/or other materials provided with the distribution.   *  * 3. Neither the name of the Institute nor the names of its contributors   *    may be used to endorse or promote products derived from this software   *    without specific prior written permission.   *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF   * SUCH DAMAGE.   */
end_comment

begin_include
include|#
directive|include
file|"krb5_locl.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: transited.c,v 1.7 2000/02/07 13:30:41 joda Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* this is an attempt at one of the most horrible `compression'    schemes that has ever been invented; it's so amazingly brain-dead    that words can not describe it, and all this just to save a few    silly bytes */
end_comment

begin_struct
struct|struct
name|tr_realm
block|{
name|char
modifier|*
name|realm
decl_stmt|;
name|unsigned
name|leading_space
range|:
literal|1
decl_stmt|;
name|unsigned
name|leading_slash
range|:
literal|1
decl_stmt|;
name|unsigned
name|trailing_dot
range|:
literal|1
decl_stmt|;
name|struct
name|tr_realm
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|free_realms
parameter_list|(
name|struct
name|tr_realm
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|tr_realm
modifier|*
name|p
decl_stmt|;
while|while
condition|(
name|r
condition|)
block|{
name|p
operator|=
name|r
expr_stmt|;
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|realm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|make_path
parameter_list|(
name|struct
name|tr_realm
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
specifier|const
name|char
modifier|*
name|to
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|tr_realm
modifier|*
name|path
init|=
name|r
operator|->
name|next
decl_stmt|;
name|struct
name|tr_realm
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|from
argument_list|)
operator|<
name|strlen
argument_list|(
name|to
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|from
expr_stmt|;
name|from
operator|=
name|to
expr_stmt|;
name|to
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|from
operator|+
name|strlen
argument_list|(
name|from
argument_list|)
operator|-
name|strlen
argument_list|(
name|to
argument_list|)
argument_list|,
name|to
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|from
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|KRB5KDC_ERR_POLICY
return|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|to
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|tmp
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|path
expr_stmt|;
name|path
operator|=
name|tmp
expr_stmt|;
name|path
operator|->
name|realm
operator|=
name|strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|realm
operator|==
name|NULL
condition|)
block|{
name|r
operator|->
name|next
operator|=
name|path
expr_stmt|;
comment|/* XXX */
return|return
name|ENOMEM
return|;
empty_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|strlen
argument_list|(
name|to
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|from
operator|+
name|strlen
argument_list|(
name|from
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|p
operator|>=
name|from
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|from
condition|)
return|return
name|KRB5KDC_ERR_POLICY
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|p
operator|-
name|from
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|tmp
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|path
expr_stmt|;
name|path
operator|=
name|tmp
expr_stmt|;
name|path
operator|->
name|realm
operator|=
name|malloc
argument_list|(
name|p
operator|-
name|from
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|->
name|realm
operator|==
name|NULL
condition|)
block|{
name|r
operator|->
name|next
operator|=
name|path
expr_stmt|;
comment|/* XXX */
return|return
name|ENOMEM
return|;
block|}
name|memcpy
argument_list|(
name|path
operator|->
name|realm
argument_list|,
name|from
argument_list|,
name|p
operator|-
name|from
argument_list|)
expr_stmt|;
name|path
operator|->
name|realm
index|[
name|p
operator|-
name|from
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|--
expr_stmt|;
block|}
block|}
else|else
return|return
name|KRB5KDC_ERR_POLICY
return|;
name|r
operator|->
name|next
operator|=
name|path
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|make_paths
parameter_list|(
name|struct
name|tr_realm
modifier|*
name|realms
parameter_list|,
specifier|const
name|char
modifier|*
name|client_realm
parameter_list|,
specifier|const
name|char
modifier|*
name|server_realm
parameter_list|)
block|{
name|struct
name|tr_realm
modifier|*
name|r
decl_stmt|;
name|int
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|prev_realm
init|=
name|client_realm
decl_stmt|;
specifier|const
name|char
modifier|*
name|next_realm
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|r
operator|=
name|realms
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
comment|/* it *might* be that you can have more than one empty 	   component in a row, at least that's how I interpret the 	   "," exception in 1510 */
if|if
condition|(
name|r
operator|->
name|realm
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
while|while
condition|(
name|r
operator|->
name|next
operator|&&
name|r
operator|->
name|next
operator|->
name|realm
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|next
condition|)
name|next_realm
operator|=
name|r
operator|->
name|next
operator|->
name|realm
expr_stmt|;
else|else
name|next_realm
operator|=
name|server_realm
expr_stmt|;
name|ret
operator|=
name|make_path
argument_list|(
name|r
argument_list|,
name|prev_realm
argument_list|,
name|next_realm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free_realms
argument_list|(
name|realms
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
name|prev_realm
operator|=
name|r
operator|->
name|realm
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|expand_realms
parameter_list|(
name|struct
name|tr_realm
modifier|*
name|realms
parameter_list|,
specifier|const
name|char
modifier|*
name|client_realm
parameter_list|)
block|{
name|struct
name|tr_realm
modifier|*
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|prev_realm
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|r
operator|=
name|realms
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|trailing_dot
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|prev_realm
operator|==
name|NULL
condition|)
name|prev_realm
operator|=
name|client_realm
expr_stmt|;
name|tmp
operator|=
name|realloc
argument_list|(
name|r
operator|->
name|realm
argument_list|,
name|strlen
argument_list|(
name|r
operator|->
name|realm
argument_list|)
operator|+
name|strlen
argument_list|(
name|prev_realm
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|free_realms
argument_list|(
name|realms
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|r
operator|->
name|realm
operator|=
name|tmp
expr_stmt|;
name|strcat
argument_list|(
name|r
operator|->
name|realm
argument_list|,
name|prev_realm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|leading_slash
operator|&&
operator|!
name|r
operator|->
name|leading_space
operator|&&
name|prev_realm
condition|)
block|{
comment|/* yet another exception: if you use x500-names, the                leading realm doesn't have to be "quoted" with a space */
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|r
operator|->
name|realm
argument_list|)
operator|+
name|strlen
argument_list|(
name|prev_realm
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|free_realms
argument_list|(
name|realms
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|prev_realm
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
name|r
operator|->
name|realm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
operator|->
name|realm
argument_list|)
expr_stmt|;
name|r
operator|->
name|realm
operator|=
name|tmp
expr_stmt|;
block|}
name|prev_realm
operator|=
name|r
operator|->
name|realm
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|tr_realm
modifier|*
name|make_realm
parameter_list|(
name|char
modifier|*
name|realm
parameter_list|)
block|{
name|struct
name|tr_realm
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|quote
init|=
literal|0
decl_stmt|;
name|r
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|realm
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|r
operator|->
name|realm
operator|=
name|realm
expr_stmt|;
for|for
control|(
name|p
operator|=
name|q
operator|=
name|r
operator|->
name|realm
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|==
name|r
operator|->
name|realm
operator|&&
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
name|r
operator|->
name|leading_space
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|q
operator|==
name|r
operator|->
name|realm
operator|&&
operator|*
name|p
operator|==
literal|'/'
condition|)
name|r
operator|->
name|leading_slash
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|quote
condition|)
block|{
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
name|quote
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
name|quote
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|r
operator|->
name|trailing_dot
operator|=
literal|1
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|tr_realm
modifier|*
name|append_realm
parameter_list|(
name|struct
name|tr_realm
modifier|*
name|head
parameter_list|,
name|struct
name|tr_realm
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|tr_realm
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
name|r
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|r
return|;
block|}
name|p
operator|=
name|head
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|next
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|r
expr_stmt|;
return|return
name|head
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decode_realms
parameter_list|(
specifier|const
name|char
modifier|*
name|tr
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|tr_realm
modifier|*
modifier|*
name|realms
parameter_list|)
block|{
name|struct
name|tr_realm
modifier|*
name|r
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|int
name|quote
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|tr
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|quote
condition|)
block|{
name|quote
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tr
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
name|quote
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tr
index|[
name|i
index|]
operator|==
literal|','
condition|)
block|{
name|tmp
operator|=
name|malloc
argument_list|(
name|tr
operator|+
name|i
operator|-
name|start
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|start
argument_list|,
name|tr
operator|+
name|i
operator|-
name|start
argument_list|)
expr_stmt|;
name|tmp
index|[
name|tr
operator|+
name|i
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
name|make_realm
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|free_realms
argument_list|(
operator|*
name|realms
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
operator|*
name|realms
operator|=
name|append_realm
argument_list|(
operator|*
name|realms
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|start
operator|=
name|tr
operator|+
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|tmp
operator|=
name|malloc
argument_list|(
name|tr
operator|+
name|i
operator|-
name|start
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|start
argument_list|,
name|tr
operator|+
name|i
operator|-
name|start
argument_list|)
expr_stmt|;
name|tmp
index|[
name|tr
operator|+
name|i
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
name|make_realm
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|free_realms
argument_list|(
operator|*
name|realms
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
operator|*
name|realms
operator|=
name|append_realm
argument_list|(
operator|*
name|realms
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|krb5_error_code
name|krb5_domain_x500_decode
parameter_list|(
name|krb5_data
name|tr
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|realms
parameter_list|,
name|int
modifier|*
name|num_realms
parameter_list|,
specifier|const
name|char
modifier|*
name|client_realm
parameter_list|,
specifier|const
name|char
modifier|*
name|server_realm
parameter_list|)
block|{
name|struct
name|tr_realm
modifier|*
name|r
init|=
name|NULL
decl_stmt|;
name|struct
name|tr_realm
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|q
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* split string in components */
name|ret
operator|=
name|decode_realms
argument_list|(
name|tr
operator|.
name|data
argument_list|,
name|tr
operator|.
name|length
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* apply prefix rule */
name|ret
operator|=
name|expand_realms
argument_list|(
name|r
argument_list|,
name|client_realm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|make_paths
argument_list|(
name|r
argument_list|,
name|client_realm
argument_list|,
name|server_realm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* remove empty components */
name|q
operator|=
operator|&
name|r
expr_stmt|;
for|for
control|(
name|p
operator|=
name|r
init|;
name|p
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|->
name|realm
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|realm
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|q
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
block|{
name|char
modifier|*
modifier|*
name|R
decl_stmt|;
operator|*
name|realms
operator|=
name|NULL
expr_stmt|;
operator|*
name|num_realms
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|r
condition|)
block|{
name|R
operator|=
name|realloc
argument_list|(
operator|*
name|realms
argument_list|,
operator|(
operator|*
name|num_realms
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|realms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|R
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|*
name|realms
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|R
index|[
operator|*
name|num_realms
index|]
operator|=
name|r
operator|->
name|realm
expr_stmt|;
operator|(
operator|*
name|num_realms
operator|)
operator|++
expr_stmt|;
operator|*
name|realms
operator|=
name|R
expr_stmt|;
name|p
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|p
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|krb5_error_code
name|krb5_domain_x500_encode
parameter_list|(
name|char
modifier|*
modifier|*
name|realms
parameter_list|,
name|int
name|num_realms
parameter_list|,
name|krb5_data
modifier|*
name|encoding
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_realms
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|realms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|realms
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|len
operator|++
expr_stmt|;
block|}
name|len
operator|+=
name|num_realms
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_realms
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|&&
name|i
operator|<
name|num_realms
operator|-
literal|1
condition|)
name|strcat
argument_list|(
name|s
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|realms
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|strcat
argument_list|(
name|s
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
name|realms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|encoding
operator|->
name|data
operator|=
name|s
expr_stmt|;
name|encoding
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|krb5_error_code
name|krb5_check_transited_realms
parameter_list|(
name|krb5_context
name|context
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|realms
parameter_list|,
name|int
name|num_realms
parameter_list|,
name|int
modifier|*
name|bad_realm
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|bad_realms
init|=
name|krb5_config_get_strings
argument_list|(
name|context
argument_list|,
name|NULL
argument_list|,
literal|"libdefaults"
argument_list|,
literal|"transited_realms_reject"
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|bad_realms
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_realms
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|bad_realms
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
name|realms
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|KRB5KRB_AP_ERR_ILL_CR_TKT
expr_stmt|;
if|if
condition|(
name|bad_realm
condition|)
operator|*
name|bad_realm
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|krb5_config_free_strings
argument_list|(
name|bad_realms
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|int main(int argc, char **argv) {     krb5_data x;     char **r;     int num, i;     x.data = argv[1];     x.length = strlen(x.data);     if(domain_expand(x,&r,&num, argv[2], argv[3])) 	exit(1);     for(i = 0; i< num; i++) 	printf("%s\n", r[i]);     return 0; }
endif|#
directive|endif
end_endif

end_unit

