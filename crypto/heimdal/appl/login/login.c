begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997 - 2001 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).   * All rights reserved.   *  * Redistribution and use in source and binary forms, with or without   * modification, are permitted provided that the following conditions   * are met:   *  * 1. Redistributions of source code must retain the above copyright   *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright   *    notice, this list of conditions and the following disclaimer in the   *    documentation and/or other materials provided with the distribution.   *  * 3. Neither the name of the Institute nor the names of its contributors   *    may be used to endorse or promote products derived from this software   *    without specific prior written permission.   *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF   * SUCH DAMAGE.   */
end_comment

begin_include
include|#
directive|include
file|"login_locl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CAPABILITY_H
end_ifdef

begin_include
include|#
directive|include
file|<capability.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_CAPABILITY_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/capability.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: login.c,v 1.46 2001/01/29 02:18:03 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|login_timeout
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|start_login_process
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|prog
decl_stmt|,
modifier|*
name|argv0
decl_stmt|;
name|prog
operator|=
name|login_conf_get_string
argument_list|(
literal|"login_program"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prog
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|argv0
operator|=
name|strrchr
argument_list|(
name|prog
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv0
condition|)
name|argv0
operator|++
expr_stmt|;
else|else
name|argv0
operator|=
name|prog
expr_stmt|;
return|return
name|simple_execle
argument_list|(
name|prog
argument_list|,
name|argv0
argument_list|,
name|NULL
argument_list|,
name|env
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|start_logout_process
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|prog
decl_stmt|,
modifier|*
name|argv0
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|prog
operator|=
name|login_conf_get_string
argument_list|(
literal|"logout_program"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prog
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|argv0
operator|=
name|strrchr
argument_list|(
name|prog
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv0
condition|)
name|argv0
operator|++
expr_stmt|;
else|else
name|argv0
operator|=
name|prog
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* avoid getting signals sent to the shell */
name|setpgid
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
comment|/* wait for the real login process to exit */
ifdef|#
directive|ifdef
name|HAVE_SETPROCTITLE
name|setproctitle
argument_list|(
literal|"waitpid %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|||
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|execle
argument_list|(
name|prog
argument_list|,
name|argv0
argument_list|,
name|NULL
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"exec %s"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"waitpid"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|exec_shell
parameter_list|(
specifier|const
name|char
modifier|*
name|shell
parameter_list|,
name|int
name|fallback
parameter_list|)
block|{
name|char
modifier|*
name|sh
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|extend_env
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_login_process
argument_list|()
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"login process"
argument_list|)
expr_stmt|;
name|start_logout_process
argument_list|()
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|shell
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|++
expr_stmt|;
else|else
name|p
operator|=
name|shell
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|sh
argument_list|,
literal|"-%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|execle
argument_list|(
name|shell
argument_list|,
name|sh
argument_list|,
name|NULL
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|fallback
condition|)
block|{
name|warnx
argument_list|(
literal|"Can't exec %s, trying %s"
argument_list|,
name|shell
argument_list|,
name|_PATH_BSHELL
argument_list|)
expr_stmt|;
name|execle
argument_list|(
name|_PATH_BSHELL
argument_list|,
literal|"-sh"
argument_list|,
name|NULL
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|_PATH_BSHELL
argument_list|)
expr_stmt|;
block|}
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|shell
argument_list|)
expr_stmt|;
block|}
end_function

begin_enum
specifier|static
enum|enum
block|{
name|NONE
init|=
literal|0
block|,
name|AUTH_KRB4
init|=
literal|1
block|,
name|AUTH_KRB5
init|=
literal|2
block|,
name|AUTH_OTP
init|=
literal|3
block|}
name|auth
enum|;
end_enum

begin_ifdef
ifdef|#
directive|ifdef
name|OTP
end_ifdef

begin_decl_stmt
specifier|static
name|OtpContext
name|otp_ctx
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|otp_verify
parameter_list|(
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
specifier|const
name|char
modifier|*
name|password
parameter_list|)
block|{
return|return
operator|(
name|otp_verify_user
argument_list|(
operator|&
name|otp_ctx
argument_list|,
name|password
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OTP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KRB5
end_ifdef

begin_decl_stmt
specifier|static
name|krb5_context
name|context
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|krb5_ccache
name|id
decl_stmt|,
name|id2
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|krb5_verify
parameter_list|(
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
specifier|const
name|char
modifier|*
name|password
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_principal
name|princ
decl_stmt|;
name|ret
operator|=
name|krb5_parse_name
argument_list|(
name|context
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|&
name|princ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
literal|1
return|;
name|ret
operator|=
name|krb5_cc_gen_new
argument_list|(
name|context
argument_list|,
operator|&
name|krb5_mcc_ops
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|krb5_free_principal
argument_list|(
name|context
argument_list|,
name|princ
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ret
operator|=
name|krb5_verify_user_lrealm
argument_list|(
name|context
argument_list|,
name|princ
argument_list|,
name|id
argument_list|,
name|password
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|krb5_free_principal
argument_list|(
name|context
argument_list|,
name|princ
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KRB4
end_ifdef

begin_function
specifier|static
name|krb5_error_code
name|krb5_to4
parameter_list|(
name|krb5_ccache
name|id
parameter_list|)
block|{
if|if
condition|(
name|krb5_config_get_bool
argument_list|(
name|context
argument_list|,
name|NULL
argument_list|,
literal|"libdefaults"
argument_list|,
literal|"krb4_get_tickets"
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|CREDENTIALS
name|c
decl_stmt|;
name|krb5_creds
name|mcred
decl_stmt|,
name|cred
decl_stmt|;
name|char
name|krb4tkfile
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_principal
name|princ
decl_stmt|;
name|ret
operator|=
name|krb5_cc_get_principal
argument_list|(
name|context
argument_list|,
name|id
argument_list|,
operator|&
name|princ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|krb5_make_principal
argument_list|(
name|context
argument_list|,
operator|&
name|mcred
operator|.
name|server
argument_list|,
name|princ
operator|->
name|realm
argument_list|,
literal|"krbtgt"
argument_list|,
name|princ
operator|->
name|realm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|krb5_free_principal
argument_list|(
name|context
argument_list|,
name|princ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|krb5_cc_retrieve_cred
argument_list|(
name|context
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|&
name|mcred
argument_list|,
operator|&
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|krb524_convert_creds_kdc
argument_list|(
name|context
argument_list|,
name|id
argument_list|,
operator|&
name|cred
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|krb4tkfile
argument_list|,
sizeof|sizeof
argument_list|(
name|krb4tkfile
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|TKT_ROOT
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|krb_set_tkt_string
argument_list|(
name|krb4tkfile
argument_list|)
expr_stmt|;
name|tf_setup
argument_list|(
operator|&
name|c
argument_list|,
name|c
operator|.
name|pname
argument_list|,
name|c
operator|.
name|pinst
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|krb5_free_creds_contents
argument_list|(
name|context
argument_list|,
operator|&
name|cred
argument_list|)
expr_stmt|;
block|}
name|krb5_free_principal
argument_list|(
name|context
argument_list|,
name|mcred
operator|.
name|server
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KRB4 */
end_comment

begin_function
specifier|static
name|int
name|krb5_start_session
parameter_list|(
specifier|const
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|char
name|residual
index|[
literal|64
index|]
decl_stmt|;
comment|/* copy credentials to file cache */
name|snprintf
argument_list|(
name|residual
argument_list|,
sizeof|sizeof
argument_list|(
name|residual
argument_list|)
argument_list|,
literal|"FILE:/tmp/krb5cc_%u"
argument_list|,
operator|(
name|unsigned
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
name|krb5_cc_resolve
argument_list|(
name|context
argument_list|,
name|residual
argument_list|,
operator|&
name|id2
argument_list|)
expr_stmt|;
name|ret
operator|=
name|krb5_cc_copy_cache
argument_list|(
name|context
argument_list|,
name|id
argument_list|,
name|id2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|add_env
argument_list|(
literal|"KRB5CCNAME"
argument_list|,
name|residual
argument_list|)
expr_stmt|;
else|else
block|{
name|krb5_cc_destroy
argument_list|(
name|context
argument_list|,
name|id2
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
ifdef|#
directive|ifdef
name|KRB4
name|krb5_to4
argument_list|(
name|id2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|krb5_cc_close
argument_list|(
name|context
argument_list|,
name|id2
argument_list|)
expr_stmt|;
name|krb5_cc_destroy
argument_list|(
name|context
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|krb5_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|krb5_free_context
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KRB4
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|pag_set
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|krb5_get_afs_tokens
parameter_list|(
specifier|const
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|)
block|{
name|char
name|cell
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|pw_dir
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|k_hasafs
argument_list|()
condition|)
return|return;
name|ret
operator|=
name|krb5_cc_default
argument_list|(
name|context
argument_list|,
operator|&
name|id2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|pw_dir
operator|=
name|pwd
operator|->
name|pw_dir
expr_stmt|;
if|if
condition|(
operator|!
name|pag_set
condition|)
block|{
name|k_setpag
argument_list|()
expr_stmt|;
name|pag_set
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|k_afs_cell_of_file
argument_list|(
name|pw_dir
argument_list|,
name|cell
argument_list|,
sizeof|sizeof
argument_list|(
name|cell
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|krb5_afslog_uid_home
argument_list|(
name|context
argument_list|,
name|id2
argument_list|,
name|cell
argument_list|,
name|NULL
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|krb5_afslog_uid_home
argument_list|(
name|context
argument_list|,
name|id2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|krb5_cc_close
argument_list|(
name|context
argument_list|,
name|id2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KRB4 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KRB5 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KRB4
end_ifdef

begin_function
specifier|static
name|int
name|krb4_verify
parameter_list|(
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
specifier|const
name|char
modifier|*
name|password
parameter_list|)
block|{
name|char
name|lrealm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|ticket_file
index|[
name|MaxPathLen
index|]
decl_stmt|;
name|ret
operator|=
name|krb_get_lrealm
argument_list|(
name|lrealm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
literal|1
return|;
name|snprintf
argument_list|(
name|ticket_file
argument_list|,
sizeof|sizeof
argument_list|(
name|ticket_file
argument_list|)
argument_list|,
literal|"%s%u_%u"
argument_list|,
name|TKT_ROOT
argument_list|,
operator|(
name|unsigned
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|,
operator|(
name|unsigned
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|krb_set_tkt_string
argument_list|(
name|ticket_file
argument_list|)
expr_stmt|;
name|ret
operator|=
name|krb_verify_user
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|""
argument_list|,
name|lrealm
argument_list|,
operator|(
name|char
operator|*
operator|)
name|password
argument_list|,
name|KRB_VERIFY_SECURE_FAIL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|chown
argument_list|(
name|ticket_file
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dest_tkt
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|add_env
argument_list|(
literal|"KRBTKFILE"
argument_list|,
name|ticket_file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|krb4_get_afs_tokens
parameter_list|(
specifier|const
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|)
block|{
name|char
name|cell
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|pw_dir
decl_stmt|;
if|if
condition|(
operator|!
name|k_hasafs
argument_list|()
condition|)
return|return;
name|pw_dir
operator|=
name|pwd
operator|->
name|pw_dir
expr_stmt|;
if|if
condition|(
operator|!
name|pag_set
condition|)
block|{
name|k_setpag
argument_list|()
expr_stmt|;
name|pag_set
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|k_afs_cell_of_file
argument_list|(
name|pw_dir
argument_list|,
name|cell
argument_list|,
sizeof|sizeof
argument_list|(
name|cell
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|krb_afslog_uid_home
argument_list|(
name|cell
argument_list|,
name|NULL
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|krb_afslog_uid_home
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KRB4 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|f_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|p_flag
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int r_flag;
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|version_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|help_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|remote_host
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|auth_level
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|getargs
name|args
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|'a'
block|,
name|arg_string
block|,
operator|&
name|auth_level
block|,
literal|"authentication mode"
block|}
block|,
if|#
directive|if
literal|0
block|{ NULL, 'd' },
endif|#
directive|endif
block|{
name|NULL
block|,
literal|'f'
block|,
name|arg_flag
block|,
operator|&
name|f_flag
block|,
literal|"pre-authenticated"
block|}
block|,
block|{
name|NULL
block|,
literal|'h'
block|,
name|arg_string
block|,
operator|&
name|remote_host
block|,
literal|"remote host"
block|,
literal|"hostname"
block|}
block|,
block|{
name|NULL
block|,
literal|'p'
block|,
name|arg_flag
block|,
operator|&
name|p_flag
block|,
literal|"don't purge environment"
block|}
block|,
if|#
directive|if
literal|0
block|{ NULL, 'r', arg_flag,&r_flag,	"rlogin protocol" },
endif|#
directive|endif
block|{
literal|"version"
block|,
literal|0
block|,
name|arg_flag
block|,
operator|&
name|version_flag
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
name|arg_flag
block|,
operator|&
name|help_flag
block|, }
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nargs
init|=
sizeof|sizeof
argument_list|(
name|args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|update_utmp
parameter_list|(
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|char
modifier|*
name|tty
parameter_list|,
name|char
modifier|*
name|ttyn
parameter_list|)
block|{
comment|/*      * Update the utmp files, both BSD and SYSV style.      */
if|if
condition|(
name|utmpx_login
argument_list|(
name|tty
argument_list|,
name|username
argument_list|,
name|hostname
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|f_flag
condition|)
block|{
name|printf
argument_list|(
literal|"No utmpx entry.  You must exec \"login\" from the "
literal|"lowest level shell.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|utmp_login
argument_list|(
name|ttyn
argument_list|,
name|username
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|checknologin
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|_PATH_NOLOGIN
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Actually log in the user.  `pwd' contains all the relevant  * information about the user.  `ttyn' is the complete name of the tty  * and `tty' the short name.  */
end_comment

begin_function
specifier|static
name|void
name|do_login
parameter_list|(
specifier|const
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
name|char
modifier|*
name|tty
parameter_list|,
name|char
modifier|*
name|ttyn
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GETSPNAM
name|struct
name|spwd
modifier|*
name|sp
decl_stmt|;
endif|#
directive|endif
name|int
name|rootlogin
init|=
operator|(
name|pwd
operator|->
name|pw_uid
operator|==
literal|0
operator|)
decl_stmt|;
name|gid_t
name|tty_gid
decl_stmt|;
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
specifier|const
name|char
modifier|*
name|home_dir
decl_stmt|;
if|if
condition|(
operator|!
name|rootlogin
condition|)
name|checknologin
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETSPNAM
name|sp
operator|=
name|getspnam
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|update_utmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|remote_host
condition|?
name|remote_host
else|:
literal|""
argument_list|,
name|tty
argument_list|,
name|ttyn
argument_list|)
expr_stmt|;
name|gr
operator|=
name|getgrnam
argument_list|(
literal|"tty"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|!=
name|NULL
condition|)
name|tty_gid
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
else|else
name|tty_gid
operator|=
name|pwd
operator|->
name|pw_gid
expr_stmt|;
if|if
condition|(
name|chown
argument_list|(
name|ttyn
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|tty_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"chown %s"
argument_list|,
name|ttyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootlogin
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|ttyn
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IWGRP
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"chmod %s"
argument_list|,
name|ttyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootlogin
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_SETLOGIN
if|if
condition|(
name|setlogin
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"setlogin(%s)"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootlogin
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_INITGROUPS
if|if
condition|(
name|initgroups
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"initgroups(%s, %u)"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|unsigned
operator|)
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootlogin
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|setgid
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"setgid(%u)"
argument_list|,
operator|(
name|unsigned
operator|)
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootlogin
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setuid
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|)
operator|||
operator|(
name|pwd
operator|->
name|pw_uid
operator|!=
literal|0
operator|&&
name|setuid
argument_list|(
literal|0
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"setuid(%u)"
argument_list|,
operator|(
name|unsigned
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootlogin
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* all kinds of different magic */
ifdef|#
directive|ifdef
name|HAVE_GETSPNAM
name|check_shadow
argument_list|(
name|pwd
argument_list|,
name|sp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|do_osfc2_magic
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETUDBNAM
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETLIM
argument_list|)
block|{
name|struct
name|udb
modifier|*
name|udb
decl_stmt|;
name|long
name|t
decl_stmt|;
specifier|const
name|long
name|maxcpu
init|=
literal|46116860184
decl_stmt|;
comment|/* some random constant */
name|udb
operator|=
name|getudbnam
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|udb
operator|==
name|UDB_NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Failed to get UDB entry."
argument_list|)
expr_stmt|;
name|t
operator|=
name|udb
operator|->
name|ue_pcpulim
index|[
name|UDBRC_INTER
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
operator|||
name|t
operator|>
name|maxcpu
condition|)
name|t
operator|=
name|CPUUNLIM
expr_stmt|;
else|else
name|t
operator|*=
literal|100
operator|*
name|CLOCKS_PER_SEC
expr_stmt|;
if|if
condition|(
name|limit
argument_list|(
name|C_PROC
argument_list|,
literal|0
argument_list|,
name|L_CPU
argument_list|,
name|t
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"limit C_PROC"
argument_list|)
expr_stmt|;
name|t
operator|=
name|udb
operator|->
name|ue_jcpulim
index|[
name|UDBRC_INTER
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
operator|||
name|t
operator|>
name|maxcpu
condition|)
name|t
operator|=
name|CPUUNLIM
expr_stmt|;
else|else
name|t
operator|*=
literal|100
operator|*
name|CLOCKS_PER_SEC
expr_stmt|;
if|if
condition|(
name|limit
argument_list|(
name|C_JOBPROCS
argument_list|,
literal|0
argument_list|,
name|L_CPU
argument_list|,
name|t
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"limit C_JOBPROCS"
argument_list|)
expr_stmt|;
name|nice
argument_list|(
name|udb
operator|->
name|ue_nice
index|[
name|UDBRC_INTER
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SGI_GETCAPABILITYBYNAME
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_CAP_SET_PROC
argument_list|)
comment|/* XXX SGI capability hack IRIX 6.x (x>= 0?) has something 	   called capabilities, that allow you to give away 	   permissions (such as chown) to specific processes. From 6.5 	   this is default on, and the default capability set seems to 	   not always be the empty set. The problem is that the 	   runtime linker refuses to do just about anything if the 	   process has *any* capabilities set, so we have to remove 	   them here (unless otherwise instructed by /etc/capability). 	   In IRIX< 6.5, these functions was called sgi_cap_setproc, 	   etc, but we ignore this fact (it works anyway). */
block|{
name|struct
name|user_cap
modifier|*
name|ucap
init|=
name|sgi_getcapabilitybyname
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
decl_stmt|;
name|cap_t
name|cap
decl_stmt|;
if|if
condition|(
name|ucap
operator|==
name|NULL
condition|)
name|cap
operator|=
name|cap_from_text
argument_list|(
literal|"all="
argument_list|)
expr_stmt|;
else|else
name|cap
operator|=
name|cap_from_text
argument_list|(
name|ucap
operator|->
name|ca_default
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cap_from_text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap_set_proc
argument_list|(
name|cap
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cap_set_proc"
argument_list|)
expr_stmt|;
name|cap_free
argument_list|(
name|cap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ucap
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|home_dir
operator|=
name|pwd
operator|->
name|pw_dir
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|home_dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No home directory \"%s\"!\n"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|"/"
argument_list|)
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|home_dir
operator|=
literal|"/"
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Logging in with home = \"/\".\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KRB5
if|if
condition|(
name|auth
operator|==
name|AUTH_KRB5
condition|)
block|{
name|krb5_start_session
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KRB4
elseif|else
if|if
condition|(
name|auth
operator|==
literal|0
condition|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_ccache
name|id
decl_stmt|;
name|ret
operator|=
name|krb5_cc_default
argument_list|(
name|context
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|krb5_to4
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|krb5_cc_close
argument_list|(
name|context
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
name|krb5_get_afs_tokens
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KRB4 */
name|krb5_finish
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* KRB5 */
ifdef|#
directive|ifdef
name|KRB4
name|krb4_get_afs_tokens
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KRB4 */
name|add_env
argument_list|(
literal|"PATH"
argument_list|,
name|_PATH_DEFPATH
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|str
init|=
name|login_conf_get_string
argument_list|(
literal|"environment"
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
block|{
name|login_read_env
argument_list|(
name|_PATH_ETC_ENVIRONMENT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|strsep_copy
argument_list|(
operator|&
name|str
argument_list|,
literal|","
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
name|login_read_env
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|add_env
argument_list|(
literal|"HOME"
argument_list|,
name|home_dir
argument_list|)
expr_stmt|;
name|add_env
argument_list|(
literal|"USER"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|add_env
argument_list|(
literal|"LOGNAME"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|add_env
argument_list|(
literal|"SHELL"
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
name|exec_shell
argument_list|(
name|pwd
operator|->
name|pw_shell
argument_list|,
name|rootlogin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_password
parameter_list|(
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
specifier|const
name|char
modifier|*
name|password
parameter_list|)
block|{
if|if
condition|(
name|pwd
operator|->
name|pw_passwd
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|pwd
operator|->
name|pw_passwd
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
ifdef|#
directive|ifdef
name|ALLOW_NULL_PASSWORD
return|return
name|password
index|[
literal|0
index|]
operator|!=
literal|'\0'
return|;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_passwd
argument_list|,
name|crypt
argument_list|(
name|password
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|KRB5
if|if
condition|(
name|krb5_verify
argument_list|(
name|pwd
argument_list|,
name|password
argument_list|)
operator|==
literal|0
condition|)
block|{
name|auth
operator|=
name|AUTH_KRB5
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KRB4
if|if
condition|(
name|krb4_verify
argument_list|(
name|pwd
argument_list|,
name|password
argument_list|)
operator|==
literal|0
condition|)
block|{
name|auth
operator|=
name|AUTH_KRB4
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OTP
if|if
condition|(
name|otp_verify
argument_list|(
name|pwd
argument_list|,
name|password
argument_list|)
operator|==
literal|0
condition|)
block|{
name|auth
operator|=
name|AUTH_OTP
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|int
name|status
parameter_list|)
block|{
name|arg_printusage
argument_list|(
name|args
argument_list|,
name|nargs
argument_list|,
name|NULL
argument_list|,
literal|"[username]"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|RETSIGTYPE
name|sig_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|sig
operator|==
name|SIGALRM
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Login timed out after %d seconds\n"
argument_list|,
name|login_timeout
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Login received signal, exiting\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|max_tries
init|=
literal|5
decl_stmt|;
name|int
name|try
decl_stmt|;
name|char
name|username
index|[
literal|32
index|]
decl_stmt|;
name|int
name|optind
init|=
literal|0
decl_stmt|;
name|int
name|ask
init|=
literal|1
decl_stmt|;
name|struct
name|sigaction
name|sa
decl_stmt|;
name|set_progname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KRB5
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|ret
operator|=
name|krb5_init_context
argument_list|(
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"krb5_init_context failed: %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|openlog
argument_list|(
literal|"login"
argument_list|,
name|LOG_ODELAY
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|optind
argument_list|)
condition|)
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|help_flag
condition|)
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|version_flag
condition|)
block|{
name|print_version
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"only root may use login, use su"
argument_list|)
expr_stmt|;
comment|/* Default tty settings. */
name|stty_default
argument_list|()
expr_stmt|;
if|if
condition|(
name|p_flag
condition|)
name|copy_env
argument_list|()
expr_stmt|;
else|else
block|{
comment|/* this set of variables is always preserved by BSD login */
if|if
condition|(
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
condition|)
name|add_env
argument_list|(
literal|"TERM"
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"TZ"
argument_list|)
condition|)
name|add_env
argument_list|(
literal|"TZ"
argument_list|,
name|getenv
argument_list|(
literal|"TZ"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|argv
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
operator|*
name|argv
argument_list|,
literal|'='
argument_list|)
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strlcpy
argument_list|(
name|username
argument_list|,
operator|*
name|argv
argument_list|,
sizeof|sizeof
argument_list|(
name|username
argument_list|)
argument_list|)
expr_stmt|;
name|ask
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|DCE
argument_list|)
operator|&&
name|defined
argument_list|(
name|AIX
argument_list|)
name|esetenv
argument_list|(
literal|"AUTHSTATE"
argument_list|,
literal|"DCE"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX should we care about environment on the command line? */
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|sig_handler
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|login_timeout
argument_list|)
expr_stmt|;
for|for
control|(
name|try
operator|=
literal|0
init|;
name|try
operator|<
name|max_tries
condition|;
name|try
operator|++
control|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|char
name|password
index|[
literal|128
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|ttname
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|tty
decl_stmt|,
modifier|*
name|ttyn
decl_stmt|;
name|char
name|prompt
index|[
literal|128
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|OTP
name|char
name|otp_str
index|[
literal|256
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ask
condition|)
block|{
name|f_flag
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|r_flag = 0;
endif|#
directive|endif
name|ret
operator|=
name|read_string
argument_list|(
literal|"login: "
argument_list|,
name|username
argument_list|,
sizeof|sizeof
argument_list|(
name|username
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|3
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|2
condition|)
name|sig_handler
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* exit */
block|}
name|pwd
operator|=
name|k_getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALLOW_NULL_PASSWORD
if|if
condition|(
name|pwd
operator|!=
name|NULL
operator|&&
operator|(
name|pwd
operator|->
name|pw_passwd
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|password
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|OTP
if|if
condition|(
name|auth_level
operator|&&
name|strcmp
argument_list|(
name|auth_level
argument_list|,
literal|"otp"
argument_list|)
operator|==
literal|0
operator|&&
name|otp_challenge
argument_list|(
operator|&
name|otp_ctx
argument_list|,
name|username
argument_list|,
name|otp_str
argument_list|,
sizeof|sizeof
argument_list|(
name|otp_str
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|snprintf
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
argument_list|(
name|prompt
argument_list|)
argument_list|,
literal|"%s's %s Password: "
argument_list|,
name|username
argument_list|,
name|otp_str
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|strncpy
argument_list|(
name|prompt
argument_list|,
literal|"Password: "
argument_list|,
sizeof|sizeof
argument_list|(
name|prompt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_flag
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|read_string
argument_list|(
name|prompt
argument_list|,
name|password
argument_list|,
sizeof|sizeof
argument_list|(
name|password
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|3
condition|)
block|{
name|ask
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ret
operator|==
operator|-
literal|2
condition|)
name|sig_handler
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Login incorrect.\n"
argument_list|)
expr_stmt|;
name|ask
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|f_flag
operator|==
literal|0
operator|&&
name|check_password
argument_list|(
name|pwd
argument_list|,
name|password
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Login incorrect.\n"
argument_list|)
expr_stmt|;
name|ask
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|ttyn
operator|=
name|ttyname
argument_list|(
name|STDIN_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyn
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ttname
argument_list|,
sizeof|sizeof
argument_list|(
name|ttname
argument_list|)
argument_list|,
literal|"%s??"
argument_list|,
name|_PATH_TTY
argument_list|)
expr_stmt|;
name|ttyn
operator|=
name|ttname
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|ttyn
argument_list|,
name|_PATH_DEV
argument_list|,
name|strlen
argument_list|(
name|_PATH_DEV
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|tty
operator|=
name|ttyn
operator|+
name|strlen
argument_list|(
name|_PATH_DEV
argument_list|)
expr_stmt|;
else|else
name|tty
operator|=
name|ttyn
expr_stmt|;
if|if
condition|(
name|login_access
argument_list|(
name|pwd
argument_list|,
name|remote_host
condition|?
name|remote_host
else|:
name|tty
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Permission denied\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_host
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s LOGIN REFUSED FROM %s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|remote_host
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s LOGIN REFUSED ON %s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|tty
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|do_login
argument_list|(
name|pwd
argument_list|,
name|tty
argument_list|,
name|ttyn
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

