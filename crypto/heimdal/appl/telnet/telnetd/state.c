begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"telnetd.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: state.c,v 1.14 2000/10/02 05:06:02 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|char
name|doopt
index|[]
init|=
block|{
name|IAC
block|,
name|DO
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|dont
index|[]
init|=
block|{
name|IAC
block|,
name|DONT
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|will
index|[]
init|=
block|{
name|IAC
block|,
name|WILL
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|wont
index|[]
init|=
block|{
name|IAC
block|,
name|WONT
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|not42
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Buffer for sub-options, and macros  * for suboptions buffer manipulations  */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|subbuffer
index|[
literal|2048
index|]
decl_stmt|,
modifier|*
name|subpointer
init|=
name|subbuffer
decl_stmt|,
modifier|*
name|subend
init|=
name|subbuffer
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SB_CLEAR
parameter_list|()
value|subpointer = subbuffer
end_define

begin_define
define|#
directive|define
name|SB_TERM
parameter_list|()
value|{ subend = subpointer; SB_CLEAR(); }
end_define

begin_define
define|#
directive|define
name|SB_ACCUM
parameter_list|(
name|c
parameter_list|)
value|if (subpointer< (subbuffer+sizeof subbuffer)) { \     *subpointer++ = (c); \ 			     }
end_define

begin_define
define|#
directive|define
name|SB_GET
parameter_list|()
value|((*subpointer++)&0xff)
end_define

begin_define
define|#
directive|define
name|SB_EOF
parameter_list|()
value|(subpointer>= subend)
end_define

begin_define
define|#
directive|define
name|SB_LEN
parameter_list|()
value|(subend - subpointer)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ENV_HACK
end_ifdef

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|subsave
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SB_SAVE
parameter_list|()
value|subsave = subpointer;
end_define

begin_define
define|#
directive|define
name|SB_RESTORE
parameter_list|()
value|subpointer = subsave;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * State for recv fsm  */
end_comment

begin_define
define|#
directive|define
name|TS_DATA
value|0
end_define

begin_comment
comment|/* base state */
end_comment

begin_define
define|#
directive|define
name|TS_IAC
value|1
end_define

begin_comment
comment|/* look for double IAC's */
end_comment

begin_define
define|#
directive|define
name|TS_CR
value|2
end_define

begin_comment
comment|/* CR-LF ->'s CR */
end_comment

begin_define
define|#
directive|define
name|TS_SB
value|3
end_define

begin_comment
comment|/* throw away begin's... */
end_comment

begin_define
define|#
directive|define
name|TS_SE
value|4
end_define

begin_comment
comment|/* ...end's (suboption negotiation) */
end_comment

begin_define
define|#
directive|define
name|TS_WILL
value|5
end_define

begin_comment
comment|/* will option negotiation */
end_comment

begin_define
define|#
directive|define
name|TS_WONT
value|6
end_define

begin_comment
comment|/* wont -''- */
end_comment

begin_define
define|#
directive|define
name|TS_DO
value|7
end_define

begin_comment
comment|/* do -''- */
end_comment

begin_define
define|#
directive|define
name|TS_DONT
value|8
end_define

begin_comment
comment|/* dont -''- */
end_comment

begin_function
name|void
name|telrcv
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
specifier|static
name|int
name|state
init|=
name|TS_DATA
decl_stmt|;
while|while
condition|(
name|ncc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|&
name|ptyobuf
index|[
name|BUFSIZ
index|]
operator|-
name|pfrontp
operator|)
operator|<
literal|2
condition|)
break|break;
name|c
operator|=
operator|*
name|netip
operator|++
operator|&
literal|0377
operator|,
name|ncc
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|ENCRYPTION
if|if
condition|(
name|decrypt_input
condition|)
name|c
operator|=
call|(
modifier|*
name|decrypt_input
call|)
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|TS_CR
case|:
name|state
operator|=
name|TS_DATA
expr_stmt|;
comment|/* Strip off \n or \0 after a \r */
if|if
condition|(
operator|(
name|c
operator|==
literal|0
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|TS_DATA
case|:
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|state
operator|=
name|TS_IAC
expr_stmt|;
break|break;
block|}
comment|/* 	     * We now map \r\n ==> \r for pragmatic reasons. 	     * Many client implementations send \r\n when 	     * the user hits the CarriageReturn key. 	     * 	     * We USED to map \r\n ==> \n, since \r\n says 	     * that we want to be in column 1 of the next 	     * printable line, and \n is the standard 	     * unix way of saying that (\r is only good 	     * if CRMOD is set, which it normally is). 	     */
if|if
condition|(
operator|(
name|c
operator|==
literal|'\r'
operator|)
operator|&&
name|his_state_is_wont
argument_list|(
name|TELOPT_BINARY
argument_list|)
condition|)
block|{
name|int
name|nc
init|=
operator|*
name|netip
decl_stmt|;
ifdef|#
directive|ifdef
name|ENCRYPTION
if|if
condition|(
name|decrypt_input
condition|)
name|nc
operator|=
call|(
modifier|*
name|decrypt_input
call|)
argument_list|(
name|nc
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|ENCRYPTION
if|if
condition|(
name|decrypt_input
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|decrypt_input
argument_list|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|state
operator|=
name|TS_CR
expr_stmt|;
block|}
block|}
operator|*
name|pfrontp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
name|TS_IAC
case|:
name|gotiac
label|:
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* 	     * Send the process on the pty side an 	     * interrupt.  Do this with a NULL or 	     * interrupt char; depending on the tty mode. 	     */
case|case
name|IP
case|:
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv IAC"
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|interrupt
argument_list|()
expr_stmt|;
break|break;
case|case
name|BREAK
case|:
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv IAC"
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|sendbrk
argument_list|()
expr_stmt|;
break|break;
comment|/* 	     * Are You There? 	     */
case|case
name|AYT
case|:
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv IAC"
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|recv_ayt
argument_list|()
expr_stmt|;
break|break;
comment|/* 	     * Abort Output 	     */
case|case
name|AO
case|:
block|{
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv IAC"
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|ptyflush
argument_list|()
expr_stmt|;
comment|/* half-hearted */
name|init_termbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|slctab
index|[
name|SLC_AO
index|]
operator|.
name|sptr
operator|&&
operator|*
name|slctab
index|[
name|SLC_AO
index|]
operator|.
name|sptr
operator|!=
call|(
name|cc_t
call|)
argument_list|(
name|_POSIX_VDISABLE
argument_list|)
condition|)
block|{
operator|*
name|pfrontp
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|slctab
index|[
name|SLC_AO
index|]
operator|.
name|sptr
expr_stmt|;
block|}
name|netclear
argument_list|()
expr_stmt|;
comment|/* clear buffer back */
name|output_data
argument_list|(
literal|"%c%c"
argument_list|,
name|IAC
argument_list|,
name|DM
argument_list|)
expr_stmt|;
name|neturg
operator|=
name|nfrontp
operator|-
literal|1
expr_stmt|;
comment|/* off by one XXX */
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: send IAC"
argument_list|,
name|DM
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Erase Character and 	 * Erase Line 	 */
case|case
name|EC
case|:
case|case
name|EL
case|:
block|{
name|cc_t
name|ch
decl_stmt|;
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv IAC"
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|ptyflush
argument_list|()
expr_stmt|;
comment|/* half-hearted */
name|init_termbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EC
condition|)
name|ch
operator|=
operator|*
name|slctab
index|[
name|SLC_EC
index|]
operator|.
name|sptr
expr_stmt|;
else|else
name|ch
operator|=
operator|*
name|slctab
index|[
name|SLC_EL
index|]
operator|.
name|sptr
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
call|(
name|cc_t
call|)
argument_list|(
name|_POSIX_VDISABLE
argument_list|)
condition|)
operator|*
name|pfrontp
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|ch
expr_stmt|;
break|break;
block|}
comment|/* 	 * Check for urgent data... 	 */
case|case
name|DM
case|:
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv IAC"
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|SYNCHing
operator|=
name|stilloob
argument_list|(
name|net
argument_list|)
expr_stmt|;
name|settimer
argument_list|(
name|gotDM
argument_list|)
expr_stmt|;
break|break;
comment|/* 	     * Begin option subnegotiation... 	     */
case|case
name|SB
case|:
name|state
operator|=
name|TS_SB
expr_stmt|;
name|SB_CLEAR
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|WILL
case|:
name|state
operator|=
name|TS_WILL
expr_stmt|;
continue|continue;
case|case
name|WONT
case|:
name|state
operator|=
name|TS_WONT
expr_stmt|;
continue|continue;
case|case
name|DO
case|:
name|state
operator|=
name|TS_DO
expr_stmt|;
continue|continue;
case|case
name|DONT
case|:
name|state
operator|=
name|TS_DONT
expr_stmt|;
continue|continue;
case|case
name|EOR
case|:
if|if
condition|(
name|his_state_is_will
argument_list|(
name|TELOPT_EOR
argument_list|)
condition|)
name|doeof
argument_list|()
expr_stmt|;
break|break;
comment|/* 	     * Handle RFC 10xx Telnet linemode option additions 	     * to command stream (EOF, SUSP, ABORT). 	     */
case|case
name|xEOF
case|:
name|doeof
argument_list|()
expr_stmt|;
break|break;
case|case
name|SUSP
case|:
name|sendsusp
argument_list|()
expr_stmt|;
break|break;
case|case
name|ABORT
case|:
name|sendbrk
argument_list|()
expr_stmt|;
break|break;
case|case
name|IAC
case|:
operator|*
name|pfrontp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
name|state
operator|=
name|TS_DATA
expr_stmt|;
break|break;
case|case
name|TS_SB
case|:
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|state
operator|=
name|TS_SE
expr_stmt|;
block|}
else|else
block|{
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TS_SE
case|:
if|if
condition|(
name|c
operator|!=
name|SE
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|IAC
condition|)
block|{
comment|/* 		     * bad form of suboption negotiation. 		     * handle it in such a way as to avoid 		     * damage to local state.  Parse 		     * suboption buffer found so far, 		     * then treat remaining stream as 		     * another command sequence. 		     */
comment|/* for DIAGNOSTICS */
name|SB_ACCUM
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|subpointer
operator|-=
literal|2
expr_stmt|;
name|SB_TERM
argument_list|()
expr_stmt|;
name|suboption
argument_list|()
expr_stmt|;
name|state
operator|=
name|TS_IAC
expr_stmt|;
goto|goto
name|gotiac
goto|;
block|}
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|TS_SB
expr_stmt|;
block|}
else|else
block|{
comment|/* for DIAGNOSTICS */
name|SB_ACCUM
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|SB_ACCUM
argument_list|(
name|SE
argument_list|)
expr_stmt|;
name|subpointer
operator|-=
literal|2
expr_stmt|;
name|SB_TERM
argument_list|()
expr_stmt|;
name|suboption
argument_list|()
expr_stmt|;
comment|/* handle sub-option */
name|state
operator|=
name|TS_DATA
expr_stmt|;
block|}
break|break;
case|case
name|TS_WILL
case|:
name|willoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_WONT
case|:
name|wontoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|TELOPT_ENCRYPT
operator|&&
name|his_do_dont_is_changing
argument_list|(
name|TELOPT_ENCRYPT
argument_list|)
condition|)
name|dontoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_DO
case|:
name|dooption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_DONT
case|:
name|dontoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
default|default:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"telnetd: panic state=%d\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"telnetd: panic state=%d\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end of telrcv */
end_comment

begin_comment
comment|/*  * The will/wont/do/dont state machines are based on Dave Borman's  * Telnet option processing state machine.  *  * These correspond to the following states:  *	my_state = the last negotiated state  *	want_state = what I want the state to go to  *	want_resp = how many requests I have sent  * All state defaults are negative, and resp defaults to 0.  *  * When initiating a request to change state to new_state:  *  * if ((want_resp == 0&& new_state == my_state) || want_state == new_state) {  *	do nothing;  * } else {  *	want_state = new_state;  *	send new_state;  *	want_resp++;  * }  *  * When receiving new_state:  *  * if (want_resp) {  *	want_resp--;  *	if (want_resp&& (new_state == my_state))  *		want_resp--;  * }  * if ((want_resp == 0)&& (new_state != want_state)) {  *	if (ok_to_switch_to new_state)  *		want_state = new_state;  *	else  *		want_resp++;  *	send want_state;  * }  * my_state = new_state;  *  * Note that new_state is implied in these functions by the function itself.  * will and do imply positive new_state, wont and dont imply negative.  *  * Finally, there is one catch.  If we send a negative response to a  * positive request, my_state will be the positive while want_state will  * remain negative.  my_state will revert to negative when the negative  * acknowlegment arrives from the peer.  Thus, my_state generally tells  * us not only the last negotiated state, but also tells us what the peer  * wants to be doing as well.  It is important to understand this difference  * as we may wish to be processing data streams based on our desired state  * (want_state) or based on what the peer thinks the state is (my_state).  *  * This all works fine because if the peer sends a positive request, the data  * that we receive prior to negative acknowlegment will probably be affected  * by the positive state, and we can process it as such (if we can; if we  * can't then it really doesn't matter).  If it is that important, then the  * peer probably should be buffering until this option state negotiation  * is complete.  *  */
end_comment

begin_function
name|void
name|send_do
parameter_list|(
name|int
name|option
parameter_list|,
name|int
name|init
parameter_list|)
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|&&
name|his_state_is_will
argument_list|(
name|option
argument_list|)
operator|)
operator|||
name|his_want_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
return|return;
comment|/* 	 * Special case for TELOPT_TM:  We send a DO, but pretend 	 * that we sent a DONT, so that we can send more DOs if 	 * we want to. 	 */
if|if
condition|(
name|option
operator|==
name|TELOPT_TM
condition|)
name|set_his_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
else|else
name|set_his_want_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|do_dont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
block|}
name|output_data
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|doopt
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: send do"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AUTHENTICATION
end_ifdef

begin_function_decl
specifier|extern
name|void
name|auth_request
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ENCRYPTION
end_ifdef

begin_function_decl
specifier|extern
name|void
name|encrypt_send_support
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|willoption
parameter_list|(
name|int
name|option
parameter_list|)
block|{
name|int
name|changeok
init|=
literal|0
decl_stmt|;
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
init|=
literal|0
function_decl|;
comment|/*      * process input from peer.      */
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv will"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
condition|)
block|{
name|do_dont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|&&
name|his_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
name|do_dont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|his_want_state_is_wont
argument_list|(
name|option
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_BINARY
case|:
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_binaryin
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
name|changeok
operator|++
expr_stmt|;
break|break;
case|case
name|TELOPT_ECHO
case|:
comment|/* 		 * See comments below for more info. 		 */
name|not42
operator|=
literal|0
expr_stmt|;
comment|/* looks like a 4.2 system */
break|break;
case|case
name|TELOPT_TM
case|:
comment|/* 		 * We never respond to a WILL TM, and 		 * we leave the state WONT. 		 */
return|return;
case|case
name|TELOPT_LFLOW
case|:
comment|/* 		 * If we are going to support flow control 		 * option, then don't worry peer that we can't 		 * change the flow control characters. 		 */
name|slctab
index|[
name|SLC_XON
index|]
operator|.
name|defset
operator|.
name|flag
operator|&=
operator|~
name|SLC_LEVELBITS
expr_stmt|;
name|slctab
index|[
name|SLC_XON
index|]
operator|.
name|defset
operator|.
name|flag
operator||=
name|SLC_DEFAULT
expr_stmt|;
name|slctab
index|[
name|SLC_XOFF
index|]
operator|.
name|defset
operator|.
name|flag
operator|&=
operator|~
name|SLC_LEVELBITS
expr_stmt|;
name|slctab
index|[
name|SLC_XOFF
index|]
operator|.
name|defset
operator|.
name|flag
operator||=
name|SLC_DEFAULT
expr_stmt|;
case|case
name|TELOPT_TTYPE
case|:
case|case
name|TELOPT_SGA
case|:
case|case
name|TELOPT_NAWS
case|:
case|case
name|TELOPT_TSPEED
case|:
case|case
name|TELOPT_XDISPLOC
case|:
case|case
name|TELOPT_NEW_ENVIRON
case|:
case|case
name|TELOPT_OLD_ENVIRON
case|:
name|changeok
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|AUTHENTICATION
case|case
name|TELOPT_AUTHENTICATION
case|:
name|func
operator|=
name|auth_request
expr_stmt|;
name|changeok
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENCRYPTION
case|case
name|TELOPT_ENCRYPT
case|:
name|func
operator|=
name|encrypt_send_support
expr_stmt|;
name|changeok
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
if|if
condition|(
name|changeok
condition|)
block|{
name|set_his_want_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|send_do
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_dont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
name|send_dont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * Option processing that should happen when 	     * we receive conformation of a change in 	     * state that we had requested. 	     */
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_ECHO
case|:
name|not42
operator|=
literal|0
expr_stmt|;
comment|/* looks like a 4.2 system */
comment|/* 		 * Egads, he responded "WILL ECHO".  Turn 		 * it off right now! 		 */
name|send_dont
argument_list|(
name|option
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * "WILL ECHO".  Kludge upon kludge! 		 * A 4.2 client is now echoing user input at 		 * the tty.  This is probably undesireable and 		 * it should be stopped.  The client will 		 * respond WONT TM to the DO TM that we send to 		 * check for kludge linemode.  When the WONT TM 		 * arrives, linemode will be turned off and a 		 * change propogated to the pty.  This change 		 * will cause us to process the new pty state 		 * in localstat(), which will notice that 		 * linemode is off and send a WILL ECHO 		 * so that we are properly in character mode and 		 * all is well. 		 */
break|break;
ifdef|#
directive|ifdef
name|AUTHENTICATION
case|case
name|TELOPT_AUTHENTICATION
case|:
name|func
operator|=
name|auth_request
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENCRYPTION
case|case
name|TELOPT_ENCRYPT
case|:
name|func
operator|=
name|encrypt_send_support
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|TELOPT_LFLOW
case|:
name|func
operator|=
name|flowstat
expr_stmt|;
break|break;
block|}
block|}
block|}
name|set_his_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
call|(
modifier|*
name|func
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of willoption */
end_comment

begin_function
name|void
name|send_dont
parameter_list|(
name|int
name|option
parameter_list|,
name|int
name|init
parameter_list|)
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|&&
name|his_state_is_wont
argument_list|(
name|option
argument_list|)
operator|)
operator|||
name|his_want_state_is_wont
argument_list|(
name|option
argument_list|)
condition|)
return|return;
name|set_his_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|do_dont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
block|}
name|output_data
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|dont
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: send dont"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wontoption
parameter_list|(
name|int
name|option
parameter_list|)
block|{
comment|/*      * Process client input. 	 */
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv wont"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
condition|)
block|{
name|do_dont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|&&
name|his_state_is_wont
argument_list|(
name|option
argument_list|)
condition|)
name|do_dont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|his_want_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
block|{
comment|/* it is always ok to change to negative state */
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_ECHO
case|:
name|not42
operator|=
literal|1
expr_stmt|;
comment|/* doesn't seem to be a 4.2 system */
break|break;
case|case
name|TELOPT_BINARY
case|:
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_binaryin
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
break|break;
case|case
name|TELOPT_TM
case|:
comment|/* 		 * If we get a WONT TM, and had sent a DO TM, 		 * don't respond with a DONT TM, just leave it 		 * as is.  Short circut the state machine to 		 * achive this. 		 */
name|set_his_want_state_wont
argument_list|(
name|TELOPT_TM
argument_list|)
expr_stmt|;
return|return;
case|case
name|TELOPT_LFLOW
case|:
comment|/* 		 * If we are not going to support flow control 		 * option, then let peer know that we can't 		 * change the flow control characters. 		 */
name|slctab
index|[
name|SLC_XON
index|]
operator|.
name|defset
operator|.
name|flag
operator|&=
operator|~
name|SLC_LEVELBITS
expr_stmt|;
name|slctab
index|[
name|SLC_XON
index|]
operator|.
name|defset
operator|.
name|flag
operator||=
name|SLC_CANTCHANGE
expr_stmt|;
name|slctab
index|[
name|SLC_XOFF
index|]
operator|.
name|defset
operator|.
name|flag
operator|&=
operator|~
name|SLC_LEVELBITS
expr_stmt|;
name|slctab
index|[
name|SLC_XOFF
index|]
operator|.
name|defset
operator|.
name|flag
operator||=
name|SLC_CANTCHANGE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|AUTHENTICATION
case|case
name|TELOPT_AUTHENTICATION
case|:
name|auth_finished
argument_list|(
literal|0
argument_list|,
name|AUTH_REJECT
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* 		 * For options that we might spin waiting for 		 * sub-negotiation, if the client turns off the 		 * option rather than responding to the request, 		 * we have to treat it here as if we got a response 		 * to the sub-negotiation, (by updating the timers) 		 * so that we'll break out of the loop. 		 */
case|case
name|TELOPT_TTYPE
case|:
name|settimer
argument_list|(
name|ttypesubopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELOPT_TSPEED
case|:
name|settimer
argument_list|(
name|tspeedsubopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELOPT_XDISPLOC
case|:
name|settimer
argument_list|(
name|xdisplocsubopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELOPT_OLD_ENVIRON
case|:
name|settimer
argument_list|(
name|oenvironsubopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELOPT_NEW_ENVIRON
case|:
name|settimer
argument_list|(
name|environsubopt
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|set_his_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|his_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
name|send_dont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_TM
case|:
break|break;
ifdef|#
directive|ifdef
name|AUTHENTICATION
case|case
name|TELOPT_AUTHENTICATION
case|:
name|auth_finished
argument_list|(
literal|0
argument_list|,
name|AUTH_REJECT
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
block|}
name|set_his_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of wontoption */
end_comment

begin_function
name|void
name|send_will
parameter_list|(
name|int
name|option
parameter_list|,
name|int
name|init
parameter_list|)
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|&&
name|my_state_is_will
argument_list|(
name|option
argument_list|)
operator|)
operator|||
name|my_want_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
return|return;
name|set_my_want_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|will_wont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
block|}
name|output_data
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|will
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: send will"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When we get a DONT SGA, we will try once to turn it  * back on.  If the other side responds DONT SGA, we  * leave it at that.  This is so that when we talk to  * clients that understand KLUDGELINEMODE but not LINEMODE,  * we'll keep them in char-at-a-time mode.  */
end_comment

begin_decl_stmt
name|int
name|turn_on_sga
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|dooption
parameter_list|(
name|int
name|option
parameter_list|)
block|{
name|int
name|changeok
init|=
literal|0
decl_stmt|;
comment|/*      * Process client input.      */
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv do"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
condition|)
block|{
name|will_wont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
operator|&&
name|my_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
name|will_wont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|my_want_state_is_wont
argument_list|(
name|option
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_ECHO
case|:
block|{
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_setecho
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
block|}
name|changeok
operator|++
expr_stmt|;
break|break;
case|case
name|TELOPT_BINARY
case|:
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_binaryout
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
name|changeok
operator|++
expr_stmt|;
break|break;
case|case
name|TELOPT_SGA
case|:
name|turn_on_sga
operator|=
literal|0
expr_stmt|;
name|changeok
operator|++
expr_stmt|;
break|break;
case|case
name|TELOPT_STATUS
case|:
name|changeok
operator|++
expr_stmt|;
break|break;
case|case
name|TELOPT_TM
case|:
comment|/* 	     * Special case for TM.  We send a WILL, but 	     * pretend we sent a WONT. 	     */
name|send_will
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_my_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|set_my_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
return|return;
case|case
name|TELOPT_LOGOUT
case|:
comment|/* 	     * When we get a LOGOUT option, respond 	     * with a WILL LOGOUT, make sure that 	     * it gets written out to the network, 	     * and then just go away... 	     */
name|set_my_want_state_will
argument_list|(
name|TELOPT_LOGOUT
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_LOGOUT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_my_state_will
argument_list|(
name|TELOPT_LOGOUT
argument_list|)
expr_stmt|;
name|netflush
argument_list|()
expr_stmt|;
name|cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
break|break;
ifdef|#
directive|ifdef
name|ENCRYPTION
case|case
name|TELOPT_ENCRYPT
case|:
name|changeok
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|TELOPT_LINEMODE
case|:
case|case
name|TELOPT_TTYPE
case|:
case|case
name|TELOPT_NAWS
case|:
case|case
name|TELOPT_TSPEED
case|:
case|case
name|TELOPT_LFLOW
case|:
case|case
name|TELOPT_XDISPLOC
case|:
ifdef|#
directive|ifdef
name|TELOPT_ENVIRON
case|case
name|TELOPT_NEW_ENVIRON
case|:
endif|#
directive|endif
case|case
name|TELOPT_OLD_ENVIRON
case|:
default|default:
break|break;
block|}
if|if
condition|(
name|changeok
condition|)
block|{
name|set_my_want_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|will_wont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
name|send_wont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|set_my_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of dooption */
end_comment

begin_function
name|void
name|send_wont
parameter_list|(
name|int
name|option
parameter_list|,
name|int
name|init
parameter_list|)
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|&&
name|my_state_is_wont
argument_list|(
name|option
argument_list|)
operator|)
operator|||
name|my_want_state_is_wont
argument_list|(
name|option
argument_list|)
condition|)
return|return;
name|set_my_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|will_wont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
block|}
name|output_data
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|wont
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: send wont"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dontoption
parameter_list|(
name|int
name|option
parameter_list|)
block|{
comment|/*      * Process client input. 	 */
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv dont"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
condition|)
block|{
name|will_wont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
operator|&&
name|my_state_is_wont
argument_list|(
name|option
argument_list|)
condition|)
name|will_wont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|my_want_state_is_will
argument_list|(
name|option
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_BINARY
case|:
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_binaryout
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
break|break;
case|case
name|TELOPT_ECHO
case|:
comment|/* we should stop echoing */
block|{
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_setecho
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|TELOPT_SGA
case|:
name|set_my_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
name|send_wont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_my_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|turn_on_sga
operator|^=
literal|1
condition|)
name|send_will
argument_list|(
name|option
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|set_my_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
name|send_wont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|set_my_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of dontoption */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENV_HACK
end_ifdef

begin_decl_stmt
name|int
name|env_ovar
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|env_ovalue
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ENV_HACK */
end_comment

begin_define
define|#
directive|define
name|env_ovar
value|OLD_ENV_VAR
end_define

begin_define
define|#
directive|define
name|env_ovalue
value|OLD_ENV_VALUE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENV_HACK */
end_comment

begin_comment
comment|/*  * suboption()  *  *	Look at the sub-option buffer, and try to be helpful to the other  * side.  *  *	Currently we recognize:  *  *	Terminal type is  *	Linemode  *	Window size  *	Terminal speed  */
end_comment

begin_function
name|void
name|suboption
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|subchar
decl_stmt|;
name|DIAG
argument_list|(
argument|TD_OPTIONS
argument_list|,
argument|{netflush(); printsub(
literal|'<'
argument|, subpointer, SB_LEN()+
literal|2
argument|);}
argument_list|)
empty_stmt|;
name|subchar
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|subchar
condition|)
block|{
case|case
name|TELOPT_TSPEED
case|:
block|{
name|int
name|xspeed
decl_stmt|,
name|rspeed
decl_stmt|;
if|if
condition|(
name|his_state_is_wont
argument_list|(
name|TELOPT_TSPEED
argument_list|)
condition|)
comment|/* Ignore if option disabled */
break|break;
name|settimer
argument_list|(
name|tspeedsubopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
operator|||
name|SB_GET
argument_list|()
operator|!=
name|TELQUAL_IS
condition|)
return|return;
name|xspeed
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|subpointer
argument_list|)
expr_stmt|;
while|while
condition|(
name|SB_GET
argument_list|()
operator|!=
literal|','
operator|&&
operator|!
name|SB_EOF
argument_list|()
condition|)
empty_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|rspeed
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|subpointer
argument_list|)
expr_stmt|;
name|clientstat
argument_list|(
name|TELOPT_TSPEED
argument_list|,
name|xspeed
argument_list|,
name|rspeed
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end of case TELOPT_TSPEED */
case|case
name|TELOPT_TTYPE
case|:
block|{
comment|/* Yaaaay! */
specifier|static
name|char
name|terminalname
index|[
literal|41
index|]
decl_stmt|;
if|if
condition|(
name|his_state_is_wont
argument_list|(
name|TELOPT_TTYPE
argument_list|)
condition|)
comment|/* Ignore if option disabled */
break|break;
name|settimer
argument_list|(
name|ttypesubopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
operator|||
name|SB_GET
argument_list|()
operator|!=
name|TELQUAL_IS
condition|)
block|{
return|return;
comment|/* ??? XXX but, this is the most robust */
block|}
name|terminaltype
operator|=
name|terminalname
expr_stmt|;
while|while
condition|(
operator|(
name|terminaltype
operator|<
operator|(
name|terminalname
operator|+
sizeof|sizeof
name|terminalname
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|!
name|SB_EOF
argument_list|()
condition|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
operator|*
name|terminaltype
operator|++
operator|=
name|c
expr_stmt|;
comment|/* accumulate name */
block|}
operator|*
name|terminaltype
operator|=
literal|0
expr_stmt|;
name|terminaltype
operator|=
name|terminalname
expr_stmt|;
break|break;
block|}
comment|/* end of case TELOPT_TTYPE */
case|case
name|TELOPT_NAWS
case|:
block|{
name|int
name|xwinsize
decl_stmt|,
name|ywinsize
decl_stmt|;
if|if
condition|(
name|his_state_is_wont
argument_list|(
name|TELOPT_NAWS
argument_list|)
condition|)
comment|/* Ignore if option disabled */
break|break;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|xwinsize
operator|=
name|SB_GET
argument_list|()
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|xwinsize
operator||=
name|SB_GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|ywinsize
operator|=
name|SB_GET
argument_list|()
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|ywinsize
operator||=
name|SB_GET
argument_list|()
expr_stmt|;
name|clientstat
argument_list|(
name|TELOPT_NAWS
argument_list|,
name|xwinsize
argument_list|,
name|ywinsize
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end of case TELOPT_NAWS */
case|case
name|TELOPT_STATUS
case|:
block|{
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
break|break;
name|mode
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|TELQUAL_SEND
case|:
if|if
condition|(
name|my_state_is_will
argument_list|(
name|TELOPT_STATUS
argument_list|)
condition|)
name|send_status
argument_list|()
expr_stmt|;
break|break;
case|case
name|TELQUAL_IS
case|:
break|break;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* end of case TELOPT_STATUS */
case|case
name|TELOPT_XDISPLOC
case|:
block|{
if|if
condition|(
name|SB_EOF
argument_list|()
operator|||
name|SB_GET
argument_list|()
operator|!=
name|TELQUAL_IS
condition|)
return|return;
name|settimer
argument_list|(
name|xdisplocsubopt
argument_list|)
expr_stmt|;
name|subpointer
index|[
name|SB_LEN
argument_list|()
index|]
operator|=
literal|'\0'
expr_stmt|;
name|esetenv
argument_list|(
literal|"DISPLAY"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|subpointer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end of case TELOPT_XDISPLOC */
ifdef|#
directive|ifdef
name|TELOPT_NEW_ENVIRON
case|case
name|TELOPT_NEW_ENVIRON
case|:
endif|#
directive|endif
case|case
name|TELOPT_OLD_ENVIRON
case|:
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|varp
decl_stmt|,
modifier|*
name|valp
decl_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|TELQUAL_IS
condition|)
block|{
if|if
condition|(
name|subchar
operator|==
name|TELOPT_OLD_ENVIRON
condition|)
name|settimer
argument_list|(
name|oenvironsubopt
argument_list|)
expr_stmt|;
else|else
name|settimer
argument_list|(
name|environsubopt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
name|TELQUAL_INFO
condition|)
block|{
return|return;
block|}
ifdef|#
directive|ifdef
name|TELOPT_NEW_ENVIRON
if|if
condition|(
name|subchar
operator|==
name|TELOPT_NEW_ENVIRON
condition|)
block|{
while|while
condition|(
operator|!
name|SB_EOF
argument_list|()
condition|)
block|{
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|NEW_ENV_VAR
operator|)
operator|||
operator|(
name|c
operator|==
name|ENV_USERVAR
operator|)
condition|)
break|break;
block|}
block|}
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|ENV_HACK
comment|/* 		 * We only want to do this if we haven't already decided 		 * whether or not the other side has its VALUE and VAR 		 * reversed. 		 */
if|if
condition|(
name|env_ovar
operator|<
literal|0
condition|)
block|{
name|int
name|last
init|=
operator|-
literal|1
decl_stmt|;
comment|/* invalid value */
name|int
name|empty
init|=
literal|0
decl_stmt|;
name|int
name|got_var
init|=
literal|0
decl_stmt|,
name|got_value
init|=
literal|0
decl_stmt|,
name|got_uservar
init|=
literal|0
decl_stmt|;
comment|/* 		     * The other side might have its VALUE and VAR values 		     * reversed.  To be interoperable, we need to determine 		     * which way it is.  If the first recognized character 		     * is a VAR or VALUE, then that will tell us what 		     * type of client it is.  If the fist recognized 		     * character is a USERVAR, then we continue scanning 		     * the suboption looking for two consecutive 		     * VAR or VALUE fields.  We should not get two 		     * consecutive VALUE fields, so finding two 		     * consecutive VALUE or VAR fields will tell us 		     * what the client is. 		     */
name|SB_SAVE
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|SB_EOF
argument_list|()
condition|)
block|{
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OLD_ENV_VAR
case|:
if|if
condition|(
name|last
operator|<
literal|0
operator|||
name|last
operator|==
name|OLD_ENV_VAR
operator|||
operator|(
name|empty
operator|&&
operator|(
name|last
operator|==
name|OLD_ENV_VALUE
operator|)
operator|)
condition|)
goto|goto
name|env_ovar_ok
goto|;
name|got_var
operator|++
expr_stmt|;
name|last
operator|=
name|OLD_ENV_VAR
expr_stmt|;
break|break;
case|case
name|OLD_ENV_VALUE
case|:
if|if
condition|(
name|last
operator|<
literal|0
operator|||
name|last
operator|==
name|OLD_ENV_VALUE
operator|||
operator|(
name|empty
operator|&&
operator|(
name|last
operator|==
name|OLD_ENV_VAR
operator|)
operator|)
condition|)
goto|goto
name|env_ovar_wrong
goto|;
name|got_value
operator|++
expr_stmt|;
name|last
operator|=
name|OLD_ENV_VALUE
expr_stmt|;
break|break;
case|case
name|ENV_USERVAR
case|:
comment|/* count strings of USERVAR as one */
if|if
condition|(
name|last
operator|!=
name|ENV_USERVAR
condition|)
name|got_uservar
operator|++
expr_stmt|;
if|if
condition|(
name|empty
condition|)
block|{
if|if
condition|(
name|last
operator|==
name|OLD_ENV_VALUE
condition|)
goto|goto
name|env_ovar_ok
goto|;
if|if
condition|(
name|last
operator|==
name|OLD_ENV_VAR
condition|)
goto|goto
name|env_ovar_wrong
goto|;
block|}
name|last
operator|=
name|ENV_USERVAR
expr_stmt|;
break|break;
case|case
name|ENV_ESC
case|:
if|if
condition|(
operator|!
name|SB_EOF
argument_list|()
condition|)
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
name|empty
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|empty
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|empty
condition|)
block|{
if|if
condition|(
name|last
operator|==
name|OLD_ENV_VALUE
condition|)
goto|goto
name|env_ovar_ok
goto|;
if|if
condition|(
name|last
operator|==
name|OLD_ENV_VAR
condition|)
goto|goto
name|env_ovar_wrong
goto|;
block|}
comment|/* 		     * Ok, the first thing was a USERVAR, and there 		     * are not two consecutive VAR or VALUE commands, 		     * and none of the VAR or VALUE commands are empty. 		     * If the client has sent us a well-formed option, 		     * then the number of VALUEs received should always 		     * be less than or equal to the number of VARs and 		     * USERVARs received. 		     * 		     * If we got exactly as many VALUEs as VARs and 		     * USERVARs, the client has the same definitions. 		     * 		     * If we got exactly as many VARs as VALUEs and 		     * USERVARS, the client has reversed definitions. 		     */
if|if
condition|(
name|got_uservar
operator|+
name|got_var
operator|==
name|got_value
condition|)
block|{
name|env_ovar_ok
label|:
name|env_ovar
operator|=
name|OLD_ENV_VAR
expr_stmt|;
name|env_ovalue
operator|=
name|OLD_ENV_VALUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|got_uservar
operator|+
name|got_value
operator|==
name|got_var
condition|)
block|{
name|env_ovar_wrong
label|:
name|env_ovar
operator|=
name|OLD_ENV_VALUE
expr_stmt|;
name|env_ovalue
operator|=
name|OLD_ENV_VAR
expr_stmt|;
name|DIAG
argument_list|(
argument|TD_OPTIONS
argument_list|,
argument|{ 			    output_data(
literal|"ENVIRON VALUE and VAR are reversed!\r\n"
argument|); 			}
argument_list|)
empty_stmt|;
block|}
block|}
name|SB_RESTORE
argument_list|()
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|!
name|SB_EOF
argument_list|()
condition|)
block|{
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|env_ovar
operator|)
operator|||
operator|(
name|c
operator|==
name|ENV_USERVAR
operator|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|cp
operator|=
name|varp
operator|=
operator|(
name|char
operator|*
operator|)
name|subpointer
expr_stmt|;
name|valp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|SB_EOF
argument_list|()
condition|)
block|{
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|subchar
operator|==
name|TELOPT_OLD_ENVIRON
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|env_ovar
condition|)
name|c
operator|=
name|NEW_ENV_VAR
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|env_ovalue
condition|)
name|c
operator|=
name|NEW_ENV_VALUE
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|NEW_ENV_VALUE
case|:
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|subpointer
expr_stmt|;
break|break;
case|case
name|NEW_ENV_VAR
case|:
case|case
name|ENV_USERVAR
case|:
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|valp
condition|)
name|esetenv
argument_list|(
name|varp
argument_list|,
name|valp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|unsetenv
argument_list|(
name|varp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|varp
operator|=
operator|(
name|char
operator|*
operator|)
name|subpointer
expr_stmt|;
name|valp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ENV_ESC
case|:
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
break|break;
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|valp
condition|)
name|esetenv
argument_list|(
name|varp
argument_list|,
name|valp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|unsetenv
argument_list|(
name|varp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end of case TELOPT_NEW_ENVIRON */
ifdef|#
directive|ifdef
name|AUTHENTICATION
case|case
name|TELOPT_AUTHENTICATION
case|:
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
break|break;
switch|switch
condition|(
name|SB_GET
argument_list|()
condition|)
block|{
case|case
name|TELQUAL_SEND
case|:
case|case
name|TELQUAL_REPLY
case|:
comment|/* 	     * These are sent by us and cannot be sent by 	     * the client. 	     */
break|break;
case|case
name|TELQUAL_IS
case|:
name|auth_is
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELQUAL_NAME
case|:
name|auth_name
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENCRYPTION
case|case
name|TELOPT_ENCRYPT
case|:
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
break|break;
switch|switch
condition|(
name|SB_GET
argument_list|()
condition|)
block|{
case|case
name|ENCRYPT_SUPPORT
case|:
name|encrypt_support
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_IS
case|:
name|encrypt_is
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_REPLY
case|:
name|encrypt_reply
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_START
case|:
name|encrypt_start
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_END
case|:
name|encrypt_end
argument_list|()
expr_stmt|;
break|break;
case|case
name|ENCRYPT_REQSTART
case|:
name|encrypt_request_start
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_REQEND
case|:
comment|/* 	     * We can always send an REQEND so that we cannot 	     * get stuck encrypting.  We should only get this 	     * if we have been able to get in the correct mode 	     * anyhow. 	     */
name|encrypt_request_end
argument_list|()
expr_stmt|;
break|break;
case|case
name|ENCRYPT_ENC_KEYID
case|:
name|encrypt_enc_keyid
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_DEC_KEYID
case|:
name|encrypt_dec_keyid
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
comment|/* end of switch */
block|}
end_function

begin_comment
comment|/* end of suboption */
end_comment

begin_function
name|void
name|doclientstat
parameter_list|(
name|void
parameter_list|)
block|{
name|clientstat
argument_list|(
name|TELOPT_LINEMODE
argument_list|,
name|WILL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ADD
parameter_list|(
name|c
parameter_list|)
value|*ncp++ = c
end_define

begin_define
define|#
directive|define
name|ADD_DATA
parameter_list|(
name|c
parameter_list|)
value|{ *ncp++ = c; if (c == SE || c == IAC) *ncp++ = c; }
end_define

begin_function
name|void
name|send_status
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|statusbuf
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ncp
decl_stmt|;
name|unsigned
name|char
name|i
decl_stmt|;
name|ncp
operator|=
name|statusbuf
expr_stmt|;
name|netflush
argument_list|()
expr_stmt|;
comment|/* get rid of anything waiting to go out */
name|ADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|SB
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|TELOPT_STATUS
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|TELQUAL_IS
argument_list|)
expr_stmt|;
comment|/*      * We check the want_state rather than the current state,      * because if we received a DO/WILL for an option that we      * don't support, and the other side didn't send a DONT/WONT      * in response to our WONT/DONT, then the "state" will be      * WILL/DO, and the "want_state" will be WONT/DONT.  We      * need to go by the latter.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
name|char
operator|)
name|NTELOPTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|my_want_state_is_will
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|ADD
argument_list|(
name|WILL
argument_list|)
expr_stmt|;
name|ADD_DATA
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|his_want_state_is_will
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|ADD
argument_list|(
name|DO
argument_list|)
expr_stmt|;
name|ADD_DATA
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|his_want_state_is_will
argument_list|(
name|TELOPT_LFLOW
argument_list|)
condition|)
block|{
name|ADD
argument_list|(
name|SB
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|TELOPT_LFLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|flowmode
condition|)
block|{
name|ADD
argument_list|(
name|LFLOW_ON
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD
argument_list|(
name|LFLOW_OFF
argument_list|)
expr_stmt|;
block|}
name|ADD
argument_list|(
name|SE
argument_list|)
expr_stmt|;
if|if
condition|(
name|restartany
operator|>=
literal|0
condition|)
block|{
name|ADD
argument_list|(
name|SB
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|TELOPT_LFLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|restartany
condition|)
block|{
name|ADD
argument_list|(
name|LFLOW_RESTART_ANY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD
argument_list|(
name|LFLOW_RESTART_XON
argument_list|)
expr_stmt|;
block|}
name|ADD
argument_list|(
name|SE
argument_list|)
expr_stmt|;
block|}
block|}
name|ADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|SE
argument_list|)
expr_stmt|;
name|writenet
argument_list|(
name|statusbuf
argument_list|,
name|ncp
operator|-
name|statusbuf
argument_list|)
expr_stmt|;
name|netflush
argument_list|()
expr_stmt|;
comment|/* Send it on its way */
name|DIAG
argument_list|(
argument|TD_OPTIONS
argument_list|,
argument|{printsub(
literal|'>'
argument|, statusbuf, ncp - statusbuf); netflush();}
argument_list|)
empty_stmt|;
block|}
end_function

end_unit

