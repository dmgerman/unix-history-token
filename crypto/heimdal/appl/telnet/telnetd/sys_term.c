begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"telnetd.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: sys_term.c,v 1.97 2000/12/08 23:32:06 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_CRAY
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_UTMPX_H
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|PARENT_DOES_UTMP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTMP_H
end_ifdef

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTMPX_H
end_ifdef

begin_include
include|#
directive|include
file|<utmpx.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTMPX_H
end_ifdef

begin_decl_stmt
name|struct
name|utmpx
name|wtmp
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_UTMP_H
argument_list|)
end_elif

begin_decl_stmt
name|struct
name|utmp
name|wtmp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UTMPX_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRUCT_UTMP_UT_HOST
end_ifdef

begin_decl_stmt
name|int
name|utmp_len
init|=
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_host
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|utmp_len
init|=
name|MaxHostNameLen
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UTMP_FILE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|_PATH_UTMP
end_ifdef

begin_define
define|#
directive|define
name|UTMP_FILE
value|_PATH_UTMP
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UTMP_FILE
value|"/etc/utmp"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WTMP_FILE
argument_list|)
operator|&&
name|defined
argument_list|(
name|_PATH_WTMP
argument_list|)
end_if

begin_define
define|#
directive|define
name|WTMP_FILE
value|_PATH_WTMP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PARENT_DOES_UTMP
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|WTMP_FILE
end_ifdef

begin_decl_stmt
name|char
name|wtmpf
index|[]
init|=
name|WTMP_FILE
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|wtmpf
index|[]
init|=
literal|"/usr/adm/wtmp"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|utmpf
index|[]
init|=
name|UTMP_FILE
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* PARENT_DOES_UTMP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WTMP_FILE
end_ifdef

begin_decl_stmt
name|char
name|wtmpf
index|[]
init|=
name|WTMP_FILE
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|wtmpf
index|[]
init|=
literal|"/etc/wtmp"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PARENT_DOES_UTMP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TMPDIR_H
end_ifdef

begin_include
include|#
directive|include
file|<tmpdir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRAY */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMSPTY
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SAC_H
end_ifdef

begin_include
include|#
directive|include
file|<sac.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STROPTS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stropts.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STREAMSPTY */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STREAM_H
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_UIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_undef
undef|#
directive|undef
name|SE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|__linux
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|HAVE_SYS_TTY
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|t_erase
end_ifdef

begin_undef
undef|#
directive|undef
name|t_erase
end_undef

begin_undef
undef|#
directive|undef
name|t_kill
end_undef

begin_undef
undef|#
directive|undef
name|t_intrc
end_undef

begin_undef
undef|#
directive|undef
name|t_quitc
end_undef

begin_undef
undef|#
directive|undef
name|t_startc
end_undef

begin_undef
undef|#
directive|undef
name|t_stopc
end_undef

begin_undef
undef|#
directive|undef
name|t_eofc
end_undef

begin_undef
undef|#
directive|undef
name|t_brkc
end_undef

begin_undef
undef|#
directive|undef
name|t_suspc
end_undef

begin_undef
undef|#
directive|undef
name|t_dsuspc
end_undef

begin_undef
undef|#
directive|undef
name|t_rprntc
end_undef

begin_undef
undef|#
directive|undef
name|t_flushc
end_undef

begin_undef
undef|#
directive|undef
name|t_werasc
end_undef

begin_undef
undef|#
directive|undef
name|t_lnextc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMIOS_H
end_ifdef

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMIO_H
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTIL_H
end_ifdef

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TCSANOW
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|TCSETS
end_ifdef

begin_define
define|#
directive|define
name|TCSANOW
value|TCSETS
end_define

begin_define
define|#
directive|define
name|TCSADRAIN
value|TCSETSW
end_define

begin_define
define|#
directive|define
name|tcgetattr
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
value|ioctl(f, TCGETS, (char *)t)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|TCSETA
end_ifdef

begin_define
define|#
directive|define
name|TCSANOW
value|TCSETA
end_define

begin_define
define|#
directive|define
name|TCSADRAIN
value|TCSETAW
end_define

begin_define
define|#
directive|define
name|tcgetattr
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
value|ioctl(f, TCGETA, (char *)t)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TCSANOW
value|TIOCSETA
end_define

begin_define
define|#
directive|define
name|TCSADRAIN
value|TIOCSETAW
end_define

begin_define
define|#
directive|define
name|tcgetattr
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
value|ioctl(f, TIOCGETA, (char *)t)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|tcsetattr
parameter_list|(
name|f
parameter_list|,
name|a
parameter_list|,
name|t
parameter_list|)
value|ioctl(f, a, t)
end_define

begin_define
define|#
directive|define
name|cfsetospeed
parameter_list|(
name|tp
parameter_list|,
name|val
parameter_list|)
value|(tp)->c_cflag&= ~CBAUD; \ (tp)->c_cflag |= (val)
end_define

begin_define
define|#
directive|define
name|cfgetospeed
parameter_list|(
name|tp
parameter_list|)
value|((tp)->c_cflag& CBAUD)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|CIBAUD
end_ifdef

begin_define
define|#
directive|define
name|cfsetispeed
parameter_list|(
name|tp
parameter_list|,
name|val
parameter_list|)
value|(tp)->c_cflag&= ~CIBAUD; \      (tp)->c_cflag |= ((val)<<IBSHIFT)
end_define

begin_define
define|#
directive|define
name|cfgetispeed
parameter_list|(
name|tp
parameter_list|)
value|(((tp)->c_cflag& CIBAUD)>>IBSHIFT)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|cfsetispeed
parameter_list|(
name|tp
parameter_list|,
name|val
parameter_list|)
value|(tp)->c_cflag&= ~CBAUD; \      (tp)->c_cflag |= (val)
end_define

begin_define
define|#
directive|define
name|cfgetispeed
parameter_list|(
name|tp
parameter_list|)
value|((tp)->c_cflag& CBAUD)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCSANOW */
end_comment

begin_decl_stmt
name|struct
name|termios
name|termbuf
decl_stmt|,
name|termbuf2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pty control structure */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMSPTY
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ttyfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|really_stream
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
modifier|*
name|new_login
init|=
name|_PATH_LOGIN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * init_termbuf()  * copy_termbuf(cp)  * set_termbuf()  *  * These three routines are used to get and set the "termbuf" structure  * to and from the kernel.  init_termbuf() gets the current settings.  * copy_termbuf() hands in a new "termbuf" to write to the kernel, and  * set_termbuf() writes the structure into the kernel.  */
end_comment

begin_function
name|void
name|init_termbuf
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|STREAMSPTY
if|if
condition|(
name|really_stream
condition|)
name|tcgetattr
argument_list|(
name|ttyfd
argument_list|,
operator|&
name|termbuf
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|tcgetattr
argument_list|(
name|ourpty
argument_list|,
operator|&
name|termbuf
argument_list|)
expr_stmt|;
name|termbuf2
operator|=
name|termbuf
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_termbuf
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*      * Only make the necessary changes. 	 */
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|termbuf
argument_list|,
operator|&
name|termbuf2
argument_list|,
sizeof|sizeof
argument_list|(
name|termbuf
argument_list|)
argument_list|)
condition|)
ifdef|#
directive|ifdef
name|STREAMSPTY
if|if
condition|(
name|really_stream
condition|)
name|tcsetattr
argument_list|(
name|ttyfd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|termbuf
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|tcsetattr
argument_list|(
name|ourpty
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|termbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * spcset(func, valp, valpp)  *  * This function takes various special characters (func), and  * sets *valp to the current value of that character, and  * *valpp to point to where in the "termbuf" structure that  * value is kept.  *  * It returns the SLC_ level of support for this function.  */
end_comment

begin_function
name|int
name|spcset
parameter_list|(
name|int
name|func
parameter_list|,
name|cc_t
modifier|*
name|valp
parameter_list|,
name|cc_t
modifier|*
modifier|*
name|valpp
parameter_list|)
block|{
define|#
directive|define
name|setval
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|*valp = termbuf.c_cc[a]; \     *valpp =&termbuf.c_cc[a]; \ 				   return(b);
define|#
directive|define
name|defval
parameter_list|(
name|a
parameter_list|)
value|*valp = ((cc_t)a); *valpp = (cc_t *)0; return(SLC_DEFAULT);
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|SLC_EOF
case|:
name|setval
argument_list|(
name|VEOF
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
case|case
name|SLC_EC
case|:
name|setval
argument_list|(
name|VERASE
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
case|case
name|SLC_EL
case|:
name|setval
argument_list|(
name|VKILL
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
case|case
name|SLC_IP
case|:
name|setval
argument_list|(
name|VINTR
argument_list|,
name|SLC_VARIABLE
operator||
name|SLC_FLUSHIN
operator||
name|SLC_FLUSHOUT
argument_list|)
expr_stmt|;
case|case
name|SLC_ABORT
case|:
name|setval
argument_list|(
name|VQUIT
argument_list|,
name|SLC_VARIABLE
operator||
name|SLC_FLUSHIN
operator||
name|SLC_FLUSHOUT
argument_list|)
expr_stmt|;
case|case
name|SLC_XON
case|:
ifdef|#
directive|ifdef
name|VSTART
name|setval
argument_list|(
name|VSTART
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0x13
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_XOFF
case|:
ifdef|#
directive|ifdef
name|VSTOP
name|setval
argument_list|(
name|VSTOP
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0x11
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_EW
case|:
ifdef|#
directive|ifdef
name|VWERASE
name|setval
argument_list|(
name|VWERASE
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_RP
case|:
ifdef|#
directive|ifdef
name|VREPRINT
name|setval
argument_list|(
name|VREPRINT
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_LNEXT
case|:
ifdef|#
directive|ifdef
name|VLNEXT
name|setval
argument_list|(
name|VLNEXT
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_AO
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VDISCARD
argument_list|)
operator|&&
name|defined
argument_list|(
name|VFLUSHO
argument_list|)
define|#
directive|define
name|VDISCARD
value|VFLUSHO
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VDISCARD
name|setval
argument_list|(
name|VDISCARD
argument_list|,
name|SLC_VARIABLE
operator||
name|SLC_FLUSHOUT
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_SUSP
case|:
ifdef|#
directive|ifdef
name|VSUSP
name|setval
argument_list|(
name|VSUSP
argument_list|,
name|SLC_VARIABLE
operator||
name|SLC_FLUSHIN
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VEOL
case|case
name|SLC_FORW1
case|:
name|setval
argument_list|(
name|VEOL
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VEOL2
case|case
name|SLC_FORW2
case|:
name|setval
argument_list|(
name|VEOL2
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_AYT
case|:
ifdef|#
directive|ifdef
name|VSTATUS
name|setval
argument_list|(
name|VSTATUS
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_BRK
case|:
case|case
name|SLC_SYNCH
case|:
case|case
name|SLC_EOR
case|:
name|defval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
operator|*
name|valp
operator|=
literal|0
expr_stmt|;
operator|*
name|valpp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|SLC_NOSUPPORT
operator|)
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_CRAY
end_ifdef

begin_comment
comment|/*  * getnpty()  *  * Return the number of pty's configured into the system.  */
end_comment

begin_function
name|int
name|getnpty
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|_SC_CRAY_NPTY
name|int
name|numptys
decl_stmt|;
if|if
condition|(
operator|(
name|numptys
operator|=
name|sysconf
argument_list|(
name|_SC_CRAY_NPTY
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|numptys
return|;
else|else
endif|#
directive|endif
comment|/* _SC_CRAY_NPTY */
return|return
literal|128
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRAY */
end_comment

begin_comment
comment|/*  * getpty()  *  * Allocate a pty.  As a side effect, the external character  * array "line" contains the name of the slave side.  *  * Returns the file descriptor of the opened pty.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|Xline
index|[]
init|=
literal|"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|line
init|=
name|Xline
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_CRAY
end_ifdef

begin_decl_stmt
name|char
name|myline
index|[]
init|=
literal|"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRAY */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_PTSNAME
argument_list|)
operator|&&
name|defined
argument_list|(
name|STREAMSPTY
argument_list|)
end_if

begin_function
specifier|static
name|char
modifier|*
name|ptsname
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TTYNAME
return|return
name|ttyname
argument_list|(
name|fd
argument_list|)
return|;
else|#
directive|else
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|getpty
parameter_list|(
name|int
modifier|*
name|ptynum
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__osf__
comment|/* XXX */
name|int
name|master
decl_stmt|;
name|int
name|slave
decl_stmt|;
if|if
condition|(
name|openpty
argument_list|(
operator|&
name|master
argument_list|,
operator|&
name|slave
argument_list|,
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|slave
argument_list|)
expr_stmt|;
return|return
name|master
return|;
block|}
return|return
operator|-
literal|1
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAVE__GETPTY
name|int
name|master
decl_stmt|,
name|slave
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|_getpty
argument_list|(
operator|&
name|master
argument_list|,
name|O_RDWR
argument_list|,
literal|0600
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|strlcpy
argument_list|(
name|line
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|Xline
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|master
return|;
else|#
directive|else
name|int
name|p
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|SunOS
operator|==
literal|40
name|int
name|dummy
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/*&& defined(HAVE_OPENPTY) */
block|int master;     int slave;     if(openpty(&master,&slave, line, 0, 0) == 0){ 	close(slave); 	return master;     }
else|#
directive|else
ifdef|#
directive|ifdef
name|STREAMSPTY
name|char
modifier|*
name|clone
index|[]
init|=
block|{
literal|"/dev/ptc"
block|,
literal|"/dev/ptmx"
block|,
literal|"/dev/ptm"
block|,
literal|"/dev/ptym/clone"
block|,
literal|0
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|clone
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
block|{
name|p
operator|=
name|open
argument_list|(
operator|*
name|q
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GRANTPT
name|grantpt
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_UNLOCKPT
name|unlockpt
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strlcpy
argument_list|(
name|line
argument_list|,
name|ptsname
argument_list|(
name|p
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Xline
argument_list|)
argument_list|)
expr_stmt|;
name|really_stream
operator|=
literal|1
expr_stmt|;
return|return
name|p
return|;
block|}
block|}
endif|#
directive|endif
comment|/* STREAMSPTY */
ifndef|#
directive|ifndef
name|_CRAY
ifndef|#
directive|ifndef
name|__hpux
name|snprintf
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|Xline
argument_list|)
argument_list|,
literal|"/dev/ptyXX"
argument_list|)
expr_stmt|;
name|p1
operator|=
operator|&
name|line
index|[
literal|8
index|]
expr_stmt|;
name|p2
operator|=
operator|&
name|line
index|[
literal|9
index|]
expr_stmt|;
else|#
directive|else
name|snprintf
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|Xline
argument_list|)
argument_list|,
literal|"/dev/ptym/ptyXX"
argument_list|)
expr_stmt|;
name|p1
operator|=
operator|&
name|line
index|[
literal|13
index|]
expr_stmt|;
name|p2
operator|=
operator|&
name|line
index|[
literal|14
index|]
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|cp
operator|=
literal|"pqrstuvwxyzPQRST"
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|struct
name|stat
name|stb
decl_stmt|;
operator|*
name|p1
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|p2
operator|=
literal|'0'
expr_stmt|;
comment|/* 	 * This stat() check is just to keep us from 	 * looping through all 256 combinations if there 	 * aren't that many ptys available. 	 */
if|if
condition|(
name|stat
argument_list|(
name|line
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p2
operator|=
literal|"0123456789abcdef"
index|[
name|i
index|]
expr_stmt|;
name|p
operator|=
name|open
argument_list|(
name|line
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|__hpux
name|line
index|[
literal|5
index|]
operator|=
literal|'t'
expr_stmt|;
else|#
directive|else
for|for
control|(
name|p1
operator|=
operator|&
name|line
index|[
literal|8
index|]
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
operator|*
name|p1
operator|=
operator|*
operator|(
name|p1
operator|+
literal|1
operator|)
expr_stmt|;
name|line
index|[
literal|9
index|]
operator|=
literal|'t'
expr_stmt|;
endif|#
directive|endif
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|line
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|#
directive|if
name|SunOS
operator|==
literal|40
if|if
condition|(
name|ioctl
argument_list|(
name|p
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|dummy
argument_list|)
operator|==
literal|0
operator|||
name|errno
operator|!=
name|EIO
condition|)
block|{
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|line
index|[
literal|5
index|]
operator|=
literal|'p'
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* SunOS == 40 */
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
block|}
else|#
directive|else
comment|/* CRAY */
extern|extern lowpty
operator|,
extern|highpty;
name|struct
name|stat
name|sb
decl_stmt|;
for|for
control|(
operator|*
name|ptynum
operator|=
name|lowpty
init|;
operator|*
name|ptynum
operator|<=
name|highpty
condition|;
operator|(
operator|*
name|ptynum
operator|)
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|myline
argument_list|,
sizeof|sizeof
argument_list|(
name|myline
argument_list|)
argument_list|,
literal|"/dev/pty/%03d"
argument_list|,
operator|*
name|ptynum
argument_list|)
expr_stmt|;
name|p
operator|=
name|open
argument_list|(
name|myline
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<
literal|0
condition|)
continue|continue;
name|snprintf
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|Xline
argument_list|)
argument_list|,
literal|"/dev/ttyp%03d"
argument_list|,
operator|*
name|ptynum
argument_list|)
expr_stmt|;
comment|/* 	 * Here are some shenanigans to make sure that there 	 * are no listeners lurking on the line. 	 */
if|if
condition|(
name|stat
argument_list|(
name|line
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sb
operator|.
name|st_uid
operator|||
name|sb
operator|.
name|st_gid
operator|||
name|sb
operator|.
name|st_mode
operator|!=
literal|0600
condition|)
block|{
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|line
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|open
argument_list|(
name|myline
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<
literal|0
condition|)
continue|continue;
block|}
comment|/* 	 * Now it should be safe...check for accessability. 	 */
if|if
condition|(
name|access
argument_list|(
name|line
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
else|else
block|{
comment|/* no tty side to pty so skip it */
name|close
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* CRAY */
endif|#
directive|endif
comment|/* STREAMSPTY */
endif|#
directive|endif
comment|/* OPENPTY */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|tty_isecho
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|termbuf
operator|.
name|c_lflag
operator|&
name|ECHO
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tty_flowmode
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|termbuf
operator|.
name|c_iflag
operator|&
name|IXON
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tty_restartany
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|termbuf
operator|.
name|c_iflag
operator|&
name|IXANY
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tty_setecho
parameter_list|(
name|int
name|on
parameter_list|)
block|{
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|c_lflag
operator||=
name|ECHO
expr_stmt|;
else|else
name|termbuf
operator|.
name|c_lflag
operator|&=
operator|~
name|ECHO
expr_stmt|;
block|}
end_function

begin_function
name|int
name|tty_israw
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|!
operator|(
name|termbuf
operator|.
name|c_lflag
operator|&
name|ICANON
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tty_binaryin
parameter_list|(
name|int
name|on
parameter_list|)
block|{
if|if
condition|(
name|on
condition|)
block|{
name|termbuf
operator|.
name|c_iflag
operator|&=
operator|~
name|ISTRIP
expr_stmt|;
block|}
else|else
block|{
name|termbuf
operator|.
name|c_iflag
operator||=
name|ISTRIP
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tty_binaryout
parameter_list|(
name|int
name|on
parameter_list|)
block|{
if|if
condition|(
name|on
condition|)
block|{
name|termbuf
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARENB
operator|)
expr_stmt|;
name|termbuf
operator|.
name|c_cflag
operator||=
name|CS8
expr_stmt|;
name|termbuf
operator|.
name|c_oflag
operator|&=
operator|~
name|OPOST
expr_stmt|;
block|}
else|else
block|{
name|termbuf
operator|.
name|c_cflag
operator|&=
operator|~
name|CSIZE
expr_stmt|;
name|termbuf
operator|.
name|c_cflag
operator||=
name|CS7
operator||
name|PARENB
expr_stmt|;
name|termbuf
operator|.
name|c_oflag
operator||=
name|OPOST
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|tty_isbinaryin
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|!
operator|(
name|termbuf
operator|.
name|c_iflag
operator|&
name|ISTRIP
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tty_isbinaryout
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|!
operator|(
name|termbuf
operator|.
name|c_oflag
operator|&
name|OPOST
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tty_issofttab
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OXTABS
return|return
operator|(
name|termbuf
operator|.
name|c_oflag
operator|&
name|OXTABS
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TABDLY
return|return
operator|(
operator|(
name|termbuf
operator|.
name|c_oflag
operator|&
name|TABDLY
operator|)
operator|==
name|TAB3
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|tty_setsofttab
parameter_list|(
name|int
name|on
parameter_list|)
block|{
if|if
condition|(
name|on
condition|)
block|{
ifdef|#
directive|ifdef
name|OXTABS
name|termbuf
operator|.
name|c_oflag
operator||=
name|OXTABS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TABDLY
name|termbuf
operator|.
name|c_oflag
operator|&=
operator|~
name|TABDLY
expr_stmt|;
name|termbuf
operator|.
name|c_oflag
operator||=
name|TAB3
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|OXTABS
name|termbuf
operator|.
name|c_oflag
operator|&=
operator|~
name|OXTABS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TABDLY
name|termbuf
operator|.
name|c_oflag
operator|&=
operator|~
name|TABDLY
expr_stmt|;
name|termbuf
operator|.
name|c_oflag
operator||=
name|TAB0
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|int
name|tty_islitecho
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ECHOCTL
return|return
operator|(
operator|!
operator|(
name|termbuf
operator|.
name|c_lflag
operator|&
name|ECHOCTL
operator|)
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TCTLECH
return|return
operator|(
operator|!
operator|(
name|termbuf
operator|.
name|c_lflag
operator|&
name|TCTLECH
operator|)
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ECHOCTL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TCTLECH
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* assumes ctl chars are echoed '^x' */
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|tty_setlitecho
parameter_list|(
name|int
name|on
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ECHOCTL
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|c_lflag
operator|&=
operator|~
name|ECHOCTL
expr_stmt|;
else|else
name|termbuf
operator|.
name|c_lflag
operator||=
name|ECHOCTL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TCTLECH
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|c_lflag
operator|&=
operator|~
name|TCTLECH
expr_stmt|;
else|else
name|termbuf
operator|.
name|c_lflag
operator||=
name|TCTLECH
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|tty_iscrnl
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|termbuf
operator|.
name|c_iflag
operator|&
name|ICRNL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to guess whether speeds are "encoded" (4.2BSD) or just numeric (4.4BSD).  */
end_comment

begin_if
if|#
directive|if
name|B4800
operator|!=
literal|4800
end_if

begin_define
define|#
directive|define
name|DECODE_BAUD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DECODE_BAUD
end_ifdef

begin_comment
comment|/*  * A table of available terminal speeds  */
end_comment

begin_struct
struct|struct
name|termspeeds
block|{
name|int
name|speed
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|termspeeds
index|[]
init|=
block|{
block|{
literal|0
block|,
name|B0
block|}
block|,
block|{
literal|50
block|,
name|B50
block|}
block|,
block|{
literal|75
block|,
name|B75
block|}
block|,
block|{
literal|110
block|,
name|B110
block|}
block|,
block|{
literal|134
block|,
name|B134
block|}
block|,
block|{
literal|150
block|,
name|B150
block|}
block|,
block|{
literal|200
block|,
name|B200
block|}
block|,
block|{
literal|300
block|,
name|B300
block|}
block|,
block|{
literal|600
block|,
name|B600
block|}
block|,
block|{
literal|1200
block|,
name|B1200
block|}
block|,
block|{
literal|1800
block|,
name|B1800
block|}
block|,
block|{
literal|2400
block|,
name|B2400
block|}
block|,
block|{
literal|4800
block|,
name|B4800
block|}
block|,
ifdef|#
directive|ifdef
name|B7200
block|{
literal|7200
block|,
name|B7200
block|}
block|,
endif|#
directive|endif
block|{
literal|9600
block|,
name|B9600
block|}
block|,
ifdef|#
directive|ifdef
name|B14400
block|{
literal|14400
block|,
name|B14400
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B19200
block|{
literal|19200
block|,
name|B19200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B28800
block|{
literal|28800
block|,
name|B28800
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B38400
block|{
literal|38400
block|,
name|B38400
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B57600
block|{
literal|57600
block|,
name|B57600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B115200
block|{
literal|115200
block|,
name|B115200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B230400
block|{
literal|230400
block|,
name|B230400
block|}
block|,
endif|#
directive|endif
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DECODE_BUAD */
end_comment

begin_function
name|void
name|tty_tspeed
parameter_list|(
name|int
name|val
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DECODE_BAUD
name|struct
name|termspeeds
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|termspeeds
init|;
operator|(
name|tp
operator|->
name|speed
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|val
operator|>
name|tp
operator|->
name|speed
operator|)
condition|;
name|tp
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|tp
operator|->
name|speed
operator|==
operator|-
literal|1
condition|)
comment|/* back up to last valid value */
operator|--
name|tp
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|termbuf
argument_list|,
name|tp
operator|->
name|value
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* DECODE_BUAD */
name|cfsetospeed
argument_list|(
operator|&
name|termbuf
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DECODE_BUAD */
block|}
end_function

begin_function
name|void
name|tty_rspeed
parameter_list|(
name|int
name|val
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DECODE_BAUD
name|struct
name|termspeeds
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|termspeeds
init|;
operator|(
name|tp
operator|->
name|speed
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|val
operator|>
name|tp
operator|->
name|speed
operator|)
condition|;
name|tp
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|tp
operator|->
name|speed
operator|==
operator|-
literal|1
condition|)
comment|/* back up to last valid value */
operator|--
name|tp
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|termbuf
argument_list|,
name|tp
operator|->
name|value
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* DECODE_BAUD */
name|cfsetispeed
argument_list|(
operator|&
name|termbuf
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DECODE_BAUD */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PARENT_DOES_UTMP
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|utmp
name|wtmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|wtmpf
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|utmp_sig_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|utmp_sig_reset
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|utmp_sig_wait
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|utmp_sig_notify
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PARENT_DOES_UTMP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMSPTY
end_ifdef

begin_comment
comment|/* I_FIND seems to live a life of its own */
end_comment

begin_function
specifier|static
name|int
name|my_find
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|module
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|I_FIND
argument_list|)
operator|&&
name|defined
argument_list|(
name|I_LIST
argument_list|)
specifier|static
name|int
name|flag
decl_stmt|;
specifier|static
name|struct
name|str_list
name|sl
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|flag
condition|)
block|{
name|n
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_LIST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl(fd, I_LIST, 0)"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sl
operator|.
name|sl_modlist
operator|=
operator|(
expr|struct
name|str_mlist
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|str_mlist
argument_list|)
argument_list|)
expr_stmt|;
name|sl
operator|.
name|sl_nmods
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_LIST
argument_list|,
operator|&
name|sl
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl(fd, I_LIST, n)"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|flag
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sl
operator|.
name|sl_nmods
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sl
operator|.
name|sl_modlist
index|[
name|i
index|]
operator|.
name|l_name
argument_list|,
name|module
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|maybe_push_modules
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
modifier|*
name|modules
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
name|err
decl_stmt|;
for|for
control|(
name|p
operator|=
name|modules
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|err
operator|=
name|my_find
argument_list|(
name|fd
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
name|err
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINVAL
condition|)
name|fatalperror
argument_list|(
name|net
argument_list|,
literal|"my_find()"
argument_list|)
expr_stmt|;
comment|/* module not pushed or does not exist */
block|}
comment|/* p points to null or to an already pushed module, now push all        modules before this one */
for|for
control|(
name|p
operator|--
init|;
name|p
operator|>=
name|modules
condition|;
name|p
operator|--
control|)
block|{
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_PUSH
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINVAL
condition|)
name|fatalperror
argument_list|(
name|net
argument_list|,
literal|"I_PUSH"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * getptyslave()  *  * Open the slave side of the pty, and do any initialization  * that is necessary.  The return value is a file descriptor  * for the slave side.  */
end_comment

begin_function
name|void
name|getptyslave
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|t
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|winsize
name|ws
decl_stmt|;
specifier|extern
name|int
name|def_row
decl_stmt|,
name|def_col
decl_stmt|;
specifier|extern
name|int
name|def_tspeed
decl_stmt|,
name|def_rspeed
decl_stmt|;
comment|/*      * Opening the slave side may cause initilization of the      * kernel tty structure.  We need remember the state of      * 	if linemode was turned on      *	terminal window size      *	terminal speed      * so that we can re-set them if we need to.      */
comment|/*      * Make sure that we don't have a controlling tty, and      * that we are the session (process group) leader.      */
ifdef|#
directive|ifdef
name|HAVE_SETSID
if|if
condition|(
name|setsid
argument_list|()
operator|<
literal|0
condition|)
name|fatalperror
argument_list|(
name|net
argument_list|,
literal|"setsid()"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TIOCNOTTY
name|t
operator|=
name|open
argument_list|(
name|_PATH_TTY
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|>=
literal|0
condition|)
block|{
name|ioctl
argument_list|(
name|t
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PARENT_DOES_UTMP
comment|/*      * Wait for our parent to get the utmp stuff to get done.      */
name|utmp_sig_wait
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|t
operator|=
name|cleanopen
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|fatalperror
argument_list|(
name|net
argument_list|,
name|line
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STREAMSPTY
name|ttyfd
operator|=
name|t
expr_stmt|;
comment|/*      * Not all systems have (or need) modules ttcompat and pckt so      * don't flag it as a fatal error if they don't exist.      */
if|if
condition|(
name|really_stream
condition|)
block|{
comment|/* these are the streams modules that we want pushed. note 	       that they are in reverse order, ptem will be pushed 	       first. maybe_push_modules() will try to push all modules 	       before the first one that isn't already pushed. i.e if 	       ldterm is pushed, only ttcompat will be attempted.  	       all this is because we don't know which modules are 	       available, and we don't know which modules are already 	       pushed (via autopush, for instance).  	       */
name|char
modifier|*
name|ttymodules
index|[]
init|=
block|{
literal|"ttcompat"
block|,
literal|"ldterm"
block|,
literal|"ptem"
block|,
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
name|ptymodules
index|[]
init|=
block|{
literal|"pckt"
block|,
name|NULL
block|}
decl_stmt|;
name|maybe_push_modules
argument_list|(
name|t
argument_list|,
name|ttymodules
argument_list|)
expr_stmt|;
name|maybe_push_modules
argument_list|(
name|ourpty
argument_list|,
name|ptymodules
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * set up the tty modes as we like them to be.      */
name|init_termbuf
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSWINSZ
if|if
condition|(
name|def_row
operator|||
name|def_col
condition|)
block|{
name|memset
argument_list|(
operator|&
name|ws
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ws
argument_list|)
argument_list|)
expr_stmt|;
name|ws
operator|.
name|ws_col
operator|=
name|def_col
expr_stmt|;
name|ws
operator|.
name|ws_row
operator|=
name|def_row
expr_stmt|;
name|ioctl
argument_list|(
name|t
argument_list|,
name|TIOCSWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ws
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * Settings for sgtty based systems      */
comment|/*      * Settings for UNICOS (and HPUX)      */
if|#
directive|if
name|defined
argument_list|(
name|_CRAY
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
name|termbuf
operator|.
name|c_oflag
operator|=
name|OPOST
operator||
name|ONLCR
operator||
name|TAB3
expr_stmt|;
name|termbuf
operator|.
name|c_iflag
operator|=
name|IGNPAR
operator||
name|ISTRIP
operator||
name|ICRNL
operator||
name|IXON
expr_stmt|;
name|termbuf
operator|.
name|c_lflag
operator|=
name|ISIG
operator||
name|ICANON
operator||
name|ECHO
operator||
name|ECHOE
operator||
name|ECHOK
expr_stmt|;
name|termbuf
operator|.
name|c_cflag
operator|=
name|EXTB
operator||
name|HUPCL
operator||
name|CS8
expr_stmt|;
endif|#
directive|endif
comment|/*      * Settings for all other termios/termio based      * systems, other than 4.4BSD.  In 4.4BSD the      * kernel does the initial terminal setup.      */
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|_CRAY
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|)
operator|&&
operator|(
name|BSD
operator|<=
literal|43
operator|)
ifndef|#
directive|ifndef
name|OXTABS
define|#
directive|define
name|OXTABS
value|0
endif|#
directive|endif
name|termbuf
operator|.
name|c_lflag
operator||=
name|ECHO
expr_stmt|;
name|termbuf
operator|.
name|c_oflag
operator||=
name|ONLCR
operator||
name|OXTABS
expr_stmt|;
name|termbuf
operator|.
name|c_iflag
operator||=
name|ICRNL
expr_stmt|;
name|termbuf
operator|.
name|c_iflag
operator|&=
operator|~
name|IXOFF
expr_stmt|;
endif|#
directive|endif
name|tty_rspeed
argument_list|(
operator|(
name|def_rspeed
operator|>
literal|0
operator|)
condition|?
name|def_rspeed
else|:
literal|9600
argument_list|)
expr_stmt|;
name|tty_tspeed
argument_list|(
operator|(
name|def_tspeed
operator|>
literal|0
operator|)
condition|?
name|def_tspeed
else|:
literal|9600
argument_list|)
expr_stmt|;
comment|/*      * Set the tty modes, and make this our controlling tty.      */
name|set_termbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|login_tty
argument_list|(
name|t
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatalperror
argument_list|(
name|net
argument_list|,
literal|"login_tty"
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|>
literal|2
condition|)
name|close
argument_list|(
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourpty
operator|>
literal|2
condition|)
block|{
name|close
argument_list|(
name|ourpty
argument_list|)
expr_stmt|;
name|ourpty
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|O_NOCTTY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Open the specified slave side of the pty,  * making sure that we have a clean tty.  */
end_comment

begin_function
name|int
name|cleanopen
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|STREAMSPTY
if|if
condition|(
operator|!
name|really_stream
condition|)
endif|#
directive|endif
block|{
comment|/* 	     * Make sure that other people can't open the 	     * slave side of the connection. 	     */
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|line
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_REVOKE
name|revoke
argument_list|(
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t
operator|=
name|open
argument_list|(
name|line
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*      * Hangup anybody else using this ttyp, then reopen it for      * ourselves.      */
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|_CRAY
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|)
operator|&&
operator|(
name|BSD
operator|<=
literal|43
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|STREAMSPTY
argument_list|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_VHANGUP
name|vhangup
argument_list|()
expr_stmt|;
else|#
directive|else
endif|#
directive|endif
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|t
operator|=
name|open
argument_list|(
name|line
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|_CRAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|TCVHUP
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|t
argument_list|,
name|TCVHUP
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|i
operator|=
name|open
argument_list|(
name|line
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|i
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(CRAY)&& defined(TCVHUP) */
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD4_4
argument_list|)
end_if

begin_function
name|int
name|login_tty
parameter_list|(
name|int
name|t
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TIOCSCTTY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|t
argument_list|,
name|TIOCSCTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|fatalperror
argument_list|(
name|net
argument_list|,
literal|"ioctl(sctty)"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_CRAY
comment|/*      * Close the hard fd to /dev/ttypXXX, and re-open through      * the indirect /dev/tty interface.      */
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|fatalperror
argument_list|(
name|net
argument_list|,
literal|"open(/dev/tty)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/*      * We get our controlling tty assigned as a side-effect      * of opening up a tty device.  But on BSD based systems,      * this only happens if our process group is zero.  The      * setsid() call above may have set our pgrp, so clear      * it out before opening the tty...      */
ifdef|#
directive|ifdef
name|HAVE_SETPGID
name|setpgid
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|setpgrp
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if setpgid isn't available, setpgrp 		      probably takes arguments */
endif|#
directive|endif
name|close
argument_list|(
name|open
argument_list|(
name|line
argument_list|,
name|O_RDWR
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
name|dup2
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|1
condition|)
name|dup2
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|2
condition|)
name|dup2
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|2
condition|)
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD<= 43 */
end_comment

begin_comment
comment|/*  * This comes from ../../bsd/tty.c and should not really be here.  */
end_comment

begin_comment
comment|/*  * Clean the tty name.  Return a pointer to the cleaned version.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|clean_ttyname
parameter_list|(
name|char
modifier|*
name|tty
parameter_list|)
block|{
name|char
modifier|*
name|res
init|=
name|tty
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|res
argument_list|,
name|_PATH_DEV
argument_list|,
name|strlen
argument_list|(
name|_PATH_DEV
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|res
operator|+=
name|strlen
argument_list|(
name|_PATH_DEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|res
argument_list|,
literal|"pty/"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|res
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|res
argument_list|,
literal|"ptym/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|res
operator|+=
literal|5
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Generate a name usable as an `ut_id', typically without `tty'.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRUCT_UTMP_UT_ID
end_ifdef

begin_function
specifier|static
name|char
modifier|*
name|make_id
parameter_list|(
name|char
modifier|*
name|tty
parameter_list|)
block|{
name|char
modifier|*
name|res
init|=
name|tty
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|res
argument_list|,
literal|"pts/"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|res
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|res
argument_list|,
literal|"tty"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|res
operator|+=
literal|3
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * startslave(host)  *  * Given a hostname, do whatever  * is necessary to startup the login process on the slave side of the pty.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|startslave
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|int
name|autologin
parameter_list|,
name|char
modifier|*
name|autoname
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTHENTICATION
if|if
condition|(
operator|!
name|autoname
operator|||
operator|!
name|autoname
index|[
literal|0
index|]
condition|)
name|autologin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|autologin
operator|<
name|auth_level
condition|)
block|{
name|fatal
argument_list|(
name|net
argument_list|,
literal|"Authorization failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|{
name|char
modifier|*
name|tbuf
init|=
literal|"\r\n*** Connection not encrypted! "
literal|"Communication may be eavesdropped. ***\r\n"
decl_stmt|;
ifdef|#
directive|ifdef
name|ENCRYPTION
if|if
condition|(
operator|!
name|no_warn
operator|&&
operator|(
name|encrypt_output
operator|==
literal|0
operator|||
name|decrypt_input
operator|==
literal|0
operator|)
condition|)
endif|#
directive|endif
name|writenet
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tbuf
argument_list|,
name|strlen
argument_list|(
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PARENT_DOES_UTMP
name|utmp_sig_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PARENT_DOES_UTMP */
if|if
condition|(
operator|(
name|i
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|fatalperror
argument_list|(
name|net
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
ifdef|#
directive|ifdef
name|PARENT_DOES_UTMP
comment|/* 	 * Cray parent will create utmp entry for child and send 	 * signal to child to tell when done.  Child waits for signal 	 * before doing anything important. 	 */
name|int
name|pid
init|=
name|i
decl_stmt|;
name|void
name|sigjob
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|setpgrp
argument_list|()
expr_stmt|;
name|utmp_sig_reset
argument_list|()
expr_stmt|;
comment|/* reset handler to default */
comment|/* 	 * Create utmp entry for child 	 */
name|wtmp
operator|.
name|ut_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|wtmp
operator|.
name|ut_type
operator|=
name|LOGIN_PROCESS
expr_stmt|;
name|wtmp
operator|.
name|ut_pid
operator|=
name|pid
expr_stmt|;
name|strncpy
argument_list|(
name|wtmp
operator|.
name|ut_user
argument_list|,
literal|"LOGIN"
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_user
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|wtmp
operator|.
name|ut_host
argument_list|,
name|host
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|wtmp
operator|.
name|ut_line
argument_list|,
name|clean_ttyname
argument_list|(
name|line
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_UTMP_UT_ID
name|strncpy
argument_list|(
name|wtmp
operator|.
name|ut_id
argument_list|,
name|wtmp
operator|.
name|ut_line
operator|+
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pututline
argument_list|(
operator|&
name|wtmp
argument_list|)
expr_stmt|;
name|endutent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|wtmpf
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|write
argument_list|(
name|i
argument_list|,
operator|&
name|wtmp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_CRAY
name|signal
argument_list|(
name|WJSIGNAL
argument_list|,
name|sigjob
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|utmp_sig_notify
argument_list|(
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PARENT_DOES_UTMP */
block|}
else|else
block|{
name|getptyslave
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DCE
argument_list|)
comment|/* if we authenticated via K5, try and join the PAG */
name|kerberos5_dfspag
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|start_login
argument_list|(
name|host
argument_list|,
name|autologin
argument_list|,
name|autoname
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|envinit
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_env
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|getenv
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
name|envp
operator|=
name|envinit
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|envp
operator|=
name|getenv
argument_list|(
literal|"TZ"
argument_list|)
operator|)
condition|)
operator|*
name|envp
operator|++
operator|-=
literal|3
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_CRAY
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
else|else
operator|*
name|envp
operator|++
operator|=
literal|"TZ=GMT0"
expr_stmt|;
endif|#
directive|endif
operator|*
name|envp
operator|=
literal|0
expr_stmt|;
name|environ
operator|=
name|envinit
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * scrub_env()  *  * We only accept the environment variables listed below.  */
end_comment

begin_function
specifier|static
name|void
name|scrub_env
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|reject
index|[]
init|=
block|{
literal|"TERMCAP=/"
block|,
name|NULL
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|accept
index|[]
init|=
block|{
literal|"XAUTH="
block|,
literal|"XAUTHORITY="
block|,
literal|"DISPLAY="
block|,
literal|"TERM="
block|,
literal|"EDITOR="
block|,
literal|"PAGER="
block|,
literal|"PRINTER="
block|,
literal|"LOGNAME="
block|,
literal|"POSIXLY_CORRECT="
block|,
literal|"TERMCAP="
block|,
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|,
modifier|*
modifier|*
name|cpp2
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|cpp2
operator|=
name|cpp
operator|=
name|environ
init|;
operator|*
name|cpp
condition|;
name|cpp
operator|++
control|)
block|{
name|int
name|reject_it
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|reject
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
operator|*
name|p
argument_list|,
name|strlen
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reject_it
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reject_it
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|accept
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
operator|*
name|p
argument_list|,
name|strlen
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|!=
name|NULL
condition|)
operator|*
name|cpp2
operator|++
operator|=
operator|*
name|cpp
expr_stmt|;
block|}
operator|*
name|cpp2
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|arg_val
block|{
name|int
name|size
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|addarg
parameter_list|(
name|struct
name|arg_val
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * start_login(host)  *  * Assuming that we are now running as a child processes, this  * function will turn us into the login process.  */
end_comment

begin_function
name|void
name|start_login
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|int
name|autologin
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|arg_val
name|argv
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_UTMPX_H
name|int
name|pid
init|=
name|getpid
argument_list|()
decl_stmt|;
name|struct
name|utmpx
name|utmpx
decl_stmt|;
name|char
modifier|*
name|clean_tty
decl_stmt|;
comment|/*      * Create utmp entry for child      */
name|clean_tty
operator|=
name|clean_ttyname
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|utmpx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|utmpx
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|utmpx
operator|.
name|ut_user
argument_list|,
literal|".telnet"
argument_list|,
sizeof|sizeof
argument_list|(
name|utmpx
operator|.
name|ut_user
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|utmpx
operator|.
name|ut_line
argument_list|,
name|clean_tty
argument_list|,
sizeof|sizeof
argument_list|(
name|utmpx
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_UTMP_UT_ID
name|strncpy
argument_list|(
name|utmpx
operator|.
name|ut_id
argument_list|,
name|make_id
argument_list|(
name|clean_tty
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|utmpx
operator|.
name|ut_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|utmpx
operator|.
name|ut_pid
operator|=
name|pid
expr_stmt|;
name|utmpx
operator|.
name|ut_type
operator|=
name|LOGIN_PROCESS
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|utmpx
operator|.
name|ut_tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pututxline
argument_list|(
operator|&
name|utmpx
argument_list|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|net
argument_list|,
literal|"pututxline failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scrub_env
argument_list|()
expr_stmt|;
comment|/*      * -h : pass on name of host.      *		WARNING:  -h is accepted by login if and only if      *			getuid() == 0.      * -p : don't clobber the environment (so terminal type stays set).      *      * -f : force this login, he has already been authenticated      */
comment|/* init argv structure */
name|argv
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|argv
operator|.
name|argc
operator|=
literal|0
expr_stmt|;
name|argv
operator|.
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*so we can call realloc later */
name|addarg
argument_list|(
operator|&
name|argv
argument_list|,
literal|"login"
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
operator|&
name|argv
argument_list|,
literal|"-h"
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
operator|&
name|argv
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
operator|&
name|argv
argument_list|,
literal|"-p"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
condition|)
name|user
operator|=
name|name
expr_stmt|;
else|else
name|user
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTHENTICATION
if|if
condition|(
name|auth_level
operator|<
literal|0
operator|||
name|autologin
operator|!=
name|AUTH_VALID
condition|)
block|{
if|if
condition|(
operator|!
name|no_warn
condition|)
block|{
name|printf
argument_list|(
literal|"User not authenticated. "
argument_list|)
expr_stmt|;
if|if
condition|(
name|require_otp
condition|)
name|printf
argument_list|(
literal|"Using one-time password\r\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Using plaintext username and password\r\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|require_otp
condition|)
block|{
name|addarg
argument_list|(
operator|&
name|argv
argument_list|,
literal|"-a"
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
operator|&
name|argv
argument_list|,
literal|"otp"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log_unauth
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"unauthenticated access from %s (%s)"
argument_list|,
name|host
argument_list|,
name|user
condition|?
name|user
else|:
literal|"unknown user"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|auth_level
operator|>=
literal|0
operator|&&
name|autologin
operator|==
name|AUTH_VALID
condition|)
name|addarg
argument_list|(
operator|&
name|argv
argument_list|,
literal|"-f"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|user
condition|)
block|{
name|addarg
argument_list|(
operator|&
name|argv
argument_list|,
literal|"--"
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
operator|&
name|argv
argument_list|,
name|strdup
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getenv
argument_list|(
literal|"USER"
argument_list|)
condition|)
block|{
comment|/* 	 * Assume that login will set the USER variable 	 * correctly.  For SysV systems, this means that 	 * USER will no longer be set, just LOGNAME by 	 * login.  (The problem is that if the auto-login 	 * fails, and the user then specifies a different 	 * account name, he can get logged in with both 	 * LOGNAME and USER in his environment, but the 	 * USER value will be wrong. 	 */
name|unsetenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
block|}
name|closelog
argument_list|()
expr_stmt|;
comment|/*      * This sleep(1) is in here so that telnetd can      * finish up with the tty.  There's a race condition      * the login banner message gets lost...      */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|new_login
argument_list|,
name|argv
operator|.
name|argv
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m\n"
argument_list|,
name|new_login
argument_list|)
expr_stmt|;
name|fatalperror
argument_list|(
name|net
argument_list|,
name|new_login
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
specifier|static
name|void
name|addarg
parameter_list|(
name|struct
name|arg_val
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
name|argv
operator|->
name|size
operator|<=
name|argv
operator|->
name|argc
operator|+
literal|1
condition|)
block|{
name|argv
operator|->
name|argv
operator|=
name|realloc
argument_list|(
name|argv
operator|->
name|argv
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|argv
operator|->
name|size
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|->
name|argv
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|net
argument_list|,
literal|"realloc: out of memory"
argument_list|)
expr_stmt|;
name|argv
operator|->
name|size
operator|+=
literal|10
expr_stmt|;
block|}
name|argv
operator|->
name|argv
index|[
name|argv
operator|->
name|argc
operator|++
index|]
operator|=
name|val
expr_stmt|;
name|argv
operator|->
name|argv
index|[
name|argv
operator|->
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rmut()  *  * This is the function called by cleanup() to  * remove the utmp entry for this person.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTMPX_H
end_ifdef

begin_function
specifier|static
name|void
name|rmut
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|utmpx
name|utmpx
decl_stmt|,
modifier|*
name|non_save_utxp
decl_stmt|;
name|char
modifier|*
name|clean_tty
init|=
name|clean_ttyname
argument_list|(
name|line
argument_list|)
decl_stmt|;
comment|/*      * This updates the utmpx and utmp entries and make a wtmp/x entry      */
name|setutxent
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|utmpx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|utmpx
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|utmpx
operator|.
name|ut_line
argument_list|,
name|clean_tty
argument_list|,
sizeof|sizeof
argument_list|(
name|utmpx
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|utmpx
operator|.
name|ut_type
operator|=
name|LOGIN_PROCESS
expr_stmt|;
name|non_save_utxp
operator|=
name|getutxline
argument_list|(
operator|&
name|utmpx
argument_list|)
expr_stmt|;
if|if
condition|(
name|non_save_utxp
condition|)
block|{
name|struct
name|utmpx
modifier|*
name|utxp
decl_stmt|;
name|char
name|user0
decl_stmt|;
name|utxp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|utmpx
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|utxp
operator|=
operator|*
name|non_save_utxp
expr_stmt|;
name|user0
operator|=
name|utxp
operator|->
name|ut_user
index|[
literal|0
index|]
expr_stmt|;
name|utxp
operator|->
name|ut_user
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|utxp
operator|->
name|ut_type
operator|=
name|DEAD_PROCESS
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_UTMPX_UT_EXIT
ifdef|#
directive|ifdef
name|_STRUCT___EXIT_STATUS
name|utxp
operator|->
name|ut_exit
operator|.
name|__e_termination
operator|=
literal|0
expr_stmt|;
name|utxp
operator|->
name|ut_exit
operator|.
name|__e_exit
operator|=
literal|0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__osf__
argument_list|)
comment|/* XXX */
name|utxp
operator|->
name|ut_exit
operator|.
name|ut_termination
operator|=
literal|0
expr_stmt|;
name|utxp
operator|->
name|ut_exit
operator|.
name|ut_exit
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|utxp
operator|->
name|ut_exit
operator|.
name|e_termination
operator|=
literal|0
expr_stmt|;
name|utxp
operator|->
name|ut_exit
operator|.
name|e_exit
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|gettimeofday
argument_list|(
operator|&
name|utxp
operator|->
name|ut_tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pututxline
argument_list|(
name|utxp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WTMPX_FILE
name|utxp
operator|->
name|ut_user
index|[
literal|0
index|]
operator|=
name|user0
expr_stmt|;
name|updwtmpx
argument_list|(
name|WTMPX_FILE
argument_list|,
name|utxp
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|WTMP_FILE
argument_list|)
comment|/* This is a strange system with a utmpx and a wtmp! */
block|{
name|int
name|f
init|=
name|open
argument_list|(
name|wtmpf
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
decl_stmt|;
name|struct
name|utmp
name|wtmp
decl_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|wtmp
operator|.
name|ut_line
argument_list|,
name|clean_tty
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|wtmp
operator|.
name|ut_name
argument_list|,
literal|""
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_name
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_UTMP_UT_HOST
name|strncpy
argument_list|(
name|wtmp
operator|.
name|ut_host
argument_list|,
literal|""
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wtmp
operator|.
name|ut_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|f
argument_list|,
operator|&
name|wtmp
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|free
argument_list|(
name|utxp
argument_list|)
expr_stmt|;
block|}
name|endutxent
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of rmut */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_UTMPX_H
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|_CRAY
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|)
operator|&&
name|BSD
operator|<=
literal|43
end_if

begin_function
specifier|static
name|void
name|rmut
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|f
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|struct
name|utmp
modifier|*
name|u
decl_stmt|,
modifier|*
name|utmp
decl_stmt|;
name|int
name|nutmp
decl_stmt|;
name|struct
name|stat
name|statbf
decl_stmt|;
name|char
modifier|*
name|clean_tty
init|=
name|clean_ttyname
argument_list|(
name|line
argument_list|)
decl_stmt|;
name|f
operator|=
name|open
argument_list|(
name|utmpf
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
name|fstat
argument_list|(
name|f
argument_list|,
operator|&
name|statbf
argument_list|)
expr_stmt|;
name|utmp
operator|=
operator|(
expr|struct
name|utmp
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|statbf
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|utmp
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"utmp malloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|statbf
operator|.
name|st_size
operator|&&
name|utmp
condition|)
block|{
name|nutmp
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|utmp
argument_list|,
operator|(
name|int
operator|)
name|statbf
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|nutmp
operator|/=
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
name|utmp
init|;
name|u
operator|<
operator|&
name|utmp
index|[
name|nutmp
index|]
condition|;
name|u
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|u
operator|->
name|ut_line
argument_list|,
name|clean_tty
argument_list|,
sizeof|sizeof
argument_list|(
name|u
operator|->
name|ut_line
argument_list|)
argument_list|)
operator|||
name|u
operator|->
name|ut_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
continue|continue;
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
operator|(
name|long
operator|)
name|u
operator|)
operator|-
operator|(
operator|(
name|long
operator|)
name|utmp
operator|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|u
operator|->
name|ut_name
argument_list|,
literal|""
argument_list|,
sizeof|sizeof
argument_list|(
name|u
operator|->
name|ut_name
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_UTMP_UT_HOST
name|strncpy
argument_list|(
name|u
operator|->
name|ut_host
argument_list|,
literal|""
argument_list|,
sizeof|sizeof
argument_list|(
name|u
operator|->
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|u
operator|->
name|ut_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|f
argument_list|,
name|u
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
name|f
operator|=
name|open
argument_list|(
name|wtmpf
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|wtmp
operator|.
name|ut_line
argument_list|,
name|clean_tty
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|wtmp
operator|.
name|ut_name
argument_list|,
literal|""
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_name
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_UTMP_UT_HOST
name|strncpy
argument_list|(
name|wtmp
operator|.
name|ut_host
argument_list|,
literal|""
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wtmp
operator|.
name|ut_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|f
argument_list|,
operator|&
name|wtmp
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
name|strlen
argument_list|(
literal|"/dev/"
argument_list|)
index|]
operator|=
literal|'p'
expr_stmt|;
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of rmut */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRAY */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_UTMPX_H
argument_list|)
end_if

begin_function
specifier|static
name|void
name|rmut
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|struct
name|utmp
name|utmp
decl_stmt|;
name|struct
name|utmp
modifier|*
name|utptr
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* for /etc/wtmp */
name|utmp
operator|.
name|ut_type
operator|=
name|USER_PROCESS
expr_stmt|;
name|strncpy
argument_list|(
name|utmp
operator|.
name|ut_line
argument_list|,
name|clean_ttyname
argument_list|(
name|line
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|setutent
argument_list|()
expr_stmt|;
name|utptr
operator|=
name|getutline
argument_list|(
operator|&
name|utmp
argument_list|)
expr_stmt|;
comment|/* write it out only if it exists */
if|if
condition|(
name|utptr
condition|)
block|{
name|utptr
operator|->
name|ut_type
operator|=
name|DEAD_PROCESS
expr_stmt|;
name|utptr
operator|->
name|ut_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|pututline
argument_list|(
name|utptr
argument_list|)
expr_stmt|;
comment|/* set wtmp entry if wtmp file exists */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|wtmpf
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|write
argument_list|(
name|fd
argument_list|,
name|utptr
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
name|endutent
argument_list|()
expr_stmt|;
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
literal|14
index|]
operator|=
name|line
index|[
literal|13
index|]
expr_stmt|;
name|line
index|[
literal|13
index|]
operator|=
name|line
index|[
literal|12
index|]
expr_stmt|;
name|line
index|[
literal|8
index|]
operator|=
literal|'m'
expr_stmt|;
name|line
index|[
literal|9
index|]
operator|=
literal|'/'
expr_stmt|;
name|line
index|[
literal|10
index|]
operator|=
literal|'p'
expr_stmt|;
name|line
index|[
literal|11
index|]
operator|=
literal|'t'
expr_stmt|;
name|line
index|[
literal|12
index|]
operator|=
literal|'y'
expr_stmt|;
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * cleanup()  *  * This is the routine to call when we are all through, to  * clean up anything that needs to be cleaned up.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PARENT_DOES_UTMP
end_ifdef

begin_function
name|void
name|cleanup
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_CRAY
specifier|static
name|int
name|incleanup
init|=
literal|0
decl_stmt|;
name|int
name|t
decl_stmt|;
name|int
name|child_status
decl_stmt|;
comment|/* status of child process as returned by waitpid */
name|int
name|flags
init|=
name|WNOHANG
operator||
name|WUNTRACED
decl_stmt|;
comment|/*      * 1: Pick up the zombie, if we are being called      *    as the signal handler.      * 2: If we are a nested cleanup(), return.      * 3: Try to clean up TMPDIR.      * 4: Fill in utmp with shutdown of process.      * 5: Close down the network and pty connections.      * 6: Finish up the TMPDIR cleanup, if needed.      */
if|if
condition|(
name|sig
operator|==
name|SIGCHLD
condition|)
block|{
while|while
condition|(
name|waitpid
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|child_status
argument_list|,
name|flags
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* VOID */
comment|/* Check if the child process was stopped 	 * rather than exited.  We want cleanup only if 	 * the child has died. 	 */
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|child_status
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|t
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|incleanup
condition|)
block|{
name|sigsetmask
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|incleanup
operator|=
literal|1
expr_stmt|;
name|sigsetmask
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|cleantmp
argument_list|(
operator|&
name|wtmp
argument_list|)
expr_stmt|;
name|setutent
argument_list|()
expr_stmt|;
comment|/* just to make sure */
endif|#
directive|endif
comment|/* CRAY */
name|rmut
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ourpty
argument_list|)
expr_stmt|;
name|shutdown
argument_list|(
name|net
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_CRAY
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|cleantmp
argument_list|(
operator|&
name|wtmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CRAY */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* PARENT_DOES_UTMP */
end_comment

begin_function
name|void
name|cleanup
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UTMPX_H
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_LOGWTMP
argument_list|)
name|rmut
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_VHANGUP
ifndef|#
directive|ifndef
name|__sgi
name|vhangup
argument_list|()
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
endif|#
directive|endif
else|#
directive|else
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|line
operator|+
sizeof|sizeof
argument_list|(
literal|"/dev/"
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|logout
argument_list|(
name|p
argument_list|)
condition|)
name|logwtmp
argument_list|(
name|p
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'p'
expr_stmt|;
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|shutdown
argument_list|(
name|net
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PARENT_DOES_UTMP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PARENT_DOES_UTMP
end_ifdef

begin_comment
comment|/*  * _utmp_sig_rcv  * utmp_sig_init  * utmp_sig_wait  *	These three functions are used to coordinate the handling of  *	the utmp file between the server and the soon-to-be-login shell.  *	The server actually creates the utmp structure, the child calls  *	utmp_sig_wait(), until the server calls utmp_sig_notify() and  *	signals the future-login shell to proceed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|caught
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NZ when signal intercepted */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* address of previous handler */
end_comment

begin_function
name|void
name|_utmp_sig_rcv
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|caught
operator|=
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|utmp_sig_init
parameter_list|()
block|{
comment|/*      * register signal handler for UTMP creation      */
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|func
operator|=
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|_utmp_sig_rcv
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatalperror
argument_list|(
name|net
argument_list|,
literal|"telnetd/signal"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|utmp_sig_reset
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* reset handler to default */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_define
define|#
directive|define
name|sigoff
parameter_list|()
end_define

begin_comment
comment|/* do nothing */
end_comment

begin_define
define|#
directive|define
name|sigon
parameter_list|()
end_define

begin_comment
comment|/* do nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|utmp_sig_wait
parameter_list|()
block|{
comment|/*      * Wait for parent to write our utmp entry. 	 */
name|sigoff
argument_list|()
expr_stmt|;
while|while
condition|(
name|caught
operator|==
literal|0
condition|)
block|{
name|pause
argument_list|()
expr_stmt|;
comment|/* wait until we get a signal (sigon) */
name|sigoff
argument_list|()
expr_stmt|;
comment|/* turn off signals while we check caught */
block|}
name|sigon
argument_list|()
expr_stmt|;
comment|/* turn on signals again */
block|}
end_function

begin_function
name|void
name|utmp_sig_notify
parameter_list|(
name|pid
parameter_list|)
block|{
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGUSR1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_CRAY
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|gotsigjob
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|sigjob
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|jid
decl_stmt|;
name|struct
name|jobtemp
modifier|*
name|jp
decl_stmt|;
while|while
condition|(
operator|(
name|jid
operator|=
name|waitjob
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|jid
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|gotsigjob
operator|++
expr_stmt|;
name|jobend
argument_list|(
name|jid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	jid_getutid:  *		called by jobend() before calling cleantmp()  *		to find the correct $TMPDIR to cleanup.  */
end_comment

begin_function
name|struct
name|utmp
modifier|*
name|jid_getutid
parameter_list|(
name|jid
parameter_list|)
name|int
name|jid
decl_stmt|;
block|{
name|struct
name|utmp
modifier|*
name|cur
init|=
name|NULL
decl_stmt|;
name|setutent
argument_list|()
expr_stmt|;
comment|/* just to make sure */
while|while
condition|(
name|cur
operator|=
name|getutent
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|cur
operator|->
name|ut_type
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|jid
operator|==
name|cur
operator|->
name|ut_jid
operator|)
condition|)
block|{
return|return
operator|(
name|cur
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clean up the TMPDIR that login created.  * The first time this is called we pick up the info  * from the utmp.  If the job has already gone away,  * then we'll clean up and be done.  If not, then  * when this is called the second time it will wait  * for the signal that the job is done.  */
end_comment

begin_function
name|int
name|cleantmp
parameter_list|(
name|wtp
parameter_list|)
name|struct
name|utmp
modifier|*
name|wtp
decl_stmt|;
block|{
name|struct
name|utmp
modifier|*
name|utp
decl_stmt|;
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|omask
decl_stmt|,
name|ret
decl_stmt|;
specifier|extern
name|struct
name|utmp
modifier|*
name|getutid
argument_list|(
specifier|const
expr|struct
name|utmp
operator|*
name|_Id
argument_list|)
decl_stmt|;
name|mask
operator|=
name|sigmask
argument_list|(
name|WJSIGNAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|0
condition|)
block|{
name|omask
operator|=
name|sigblock
argument_list|(
name|mask
argument_list|)
expr_stmt|;
while|while
condition|(
name|gotsigjob
operator|==
literal|0
condition|)
name|sigpause
argument_list|(
name|omask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|first
operator|=
literal|0
expr_stmt|;
name|setutent
argument_list|()
expr_stmt|;
comment|/* just to make sure */
name|utp
operator|=
name|getutid
argument_list|(
name|wtp
argument_list|)
expr_stmt|;
if|if
condition|(
name|utp
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't get /etc/utmp entry to clean TMPDIR"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*      * Nothing to clean up if the user shell was never started.      */
if|if
condition|(
name|utp
operator|->
name|ut_type
operator|!=
name|USER_PROCESS
operator|||
name|utp
operator|->
name|ut_jid
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/*      * Block the WJSIGNAL while we are in jobend().      */
name|omask
operator|=
name|sigblock
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|ret
operator|=
name|jobend
argument_list|(
name|utp
operator|->
name|ut_jid
argument_list|,
name|utp
operator|->
name|ut_tpath
argument_list|,
name|utp
operator|->
name|ut_user
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|jobend
parameter_list|(
name|jid
parameter_list|,
name|path
parameter_list|,
name|user
parameter_list|)
name|int
name|jid
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
block|{
specifier|static
name|int
name|saved_jid
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|pty_saved_jid
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|saved_path
index|[
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_tpath
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|char
name|saved_user
index|[
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_user
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
comment|/*      * this little piece of code comes into play      * only when ptyreconnect is used to reconnect      * to an previous session.      *      * this is the only time when the      * "saved_jid != jid" code is executed.      */
if|if
condition|(
name|saved_jid
operator|&&
name|saved_jid
operator|!=
name|jid
condition|)
block|{
if|if
condition|(
operator|!
name|path
condition|)
block|{
comment|/* called from signal handler */
name|pty_saved_jid
operator|=
name|jid
expr_stmt|;
block|}
else|else
block|{
name|pty_saved_jid
operator|=
name|saved_jid
expr_stmt|;
block|}
block|}
if|if
condition|(
name|path
condition|)
block|{
name|strncpy
argument_list|(
name|saved_path
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_tpath
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|saved_user
argument_list|,
name|user
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_user
argument_list|)
argument_list|)
expr_stmt|;
name|saved_path
index|[
sizeof|sizeof
argument_list|(
name|saved_path
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|saved_user
index|[
sizeof|sizeof
argument_list|(
name|saved_user
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|saved_jid
operator|==
literal|0
condition|)
block|{
name|saved_jid
operator|=
name|jid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* if the jid has changed, get the correct entry from the utmp file */
if|if
condition|(
name|saved_jid
operator|!=
name|jid
condition|)
block|{
name|struct
name|utmp
modifier|*
name|utp
init|=
name|NULL
decl_stmt|;
name|struct
name|utmp
modifier|*
name|jid_getutid
parameter_list|()
function_decl|;
name|utp
operator|=
name|jid_getutid
argument_list|(
name|pty_saved_jid
argument_list|)
expr_stmt|;
if|if
condition|(
name|utp
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't get /etc/utmp entry to clean TMPDIR"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cleantmpdir
argument_list|(
name|jid
argument_list|,
name|utp
operator|->
name|ut_tpath
argument_list|,
name|utp
operator|->
name|ut_user
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cleantmpdir
argument_list|(
name|jid
argument_list|,
name|saved_path
argument_list|,
name|saved_user
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fork a child process to clean up the TMPDIR  */
end_comment

begin_macro
name|cleantmpdir
argument_list|(
argument|jid
argument_list|,
argument|tpath
argument_list|,
argument|user
argument_list|)
end_macro

begin_decl_stmt
name|int
name|jid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|user
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"TMPDIR cleanup(%s): fork() failed: %m\n"
argument_list|,
name|tpath
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|execl
argument_list|(
name|CLEANTMPCMD
argument_list|,
name|CLEANTMPCMD
argument_list|,
name|user
argument_list|,
name|tpath
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"TMPDIR cleanup(%s): execl(%s) failed: %m\n"
argument_list|,
name|tpath
argument_list|,
name|CLEANTMPCMD
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
default|default:
comment|/* 	 * Forget about child.  We will exit, and 	 * /etc/init will pick it up. 	 */
break|break;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRAY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(PARENT_DOES_UTMP) */
end_comment

end_unit

