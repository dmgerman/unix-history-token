begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dso_dlfcn.c -*- mode:C; c-file-style: "eay" -*- */
end_comment

begin_comment
comment|/*  * Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL project  * 2000.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/*  * We need to do this early, because stdio.h includes the header files that  * handle _GNU_SOURCE and other similar macros.  Defining it later is simply  * too late, because those headers are protected from re- inclusion.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_comment
comment|/* make sure dladdr is declared */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/dso.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DSO_DLFCN
end_ifndef

begin_function
name|DSO_METHOD
modifier|*
name|DSO_METHOD_dlfcn
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DLFCN_H
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__osf__
end_ifdef

begin_define
define|#
directive|define
name|__EXTENSIONS__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_define
define|#
directive|define
name|HAVE_DLINFO
value|1
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_AIX
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__SCO_VERSION__
argument_list|)
operator|||
name|defined
argument_list|(
name|_SCO_ELF
argument_list|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|RTLD_NEXT
argument_list|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|RTLD_SELF
argument_list|)
operator|)
operator|||
expr|\
name|defined
argument_list|(
name|__ANDROID__
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|HAVE_DLINFO
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Part of the hack in "dlfcn_load" ... */
end_comment

begin_define
define|#
directive|define
name|DSO_MAX_TRANSLATED_SIZE
value|256
end_define

begin_function_decl
specifier|static
name|int
name|dlfcn_load
parameter_list|(
name|DSO
modifier|*
name|dso
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlfcn_unload
parameter_list|(
name|DSO
modifier|*
name|dso
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|dlfcn_bind_var
parameter_list|(
name|DSO
modifier|*
name|dso
parameter_list|,
specifier|const
name|char
modifier|*
name|symname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|DSO_FUNC_TYPE
name|dlfcn_bind_func
parameter_list|(
name|DSO
modifier|*
name|dso
parameter_list|,
specifier|const
name|char
modifier|*
name|symname
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int dlfcn_unbind(DSO *dso, char *symname, void *symptr); static int dlfcn_init(DSO *dso); static int dlfcn_finish(DSO *dso); static long dlfcn_ctrl(DSO *dso, int cmd, long larg, void *parg);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|char
modifier|*
name|dlfcn_name_converter
parameter_list|(
name|DSO
modifier|*
name|dso
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|dlfcn_merger
parameter_list|(
name|DSO
modifier|*
name|dso
parameter_list|,
specifier|const
name|char
modifier|*
name|filespec1
parameter_list|,
specifier|const
name|char
modifier|*
name|filespec2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlfcn_pathbyaddr
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
name|sz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|dlfcn_globallookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|DSO_METHOD
name|dso_meth_dlfcn
init|=
block|{
literal|"OpenSSL 'dlfcn' shared library method"
block|,
name|dlfcn_load
block|,
name|dlfcn_unload
block|,
name|dlfcn_bind_var
block|,
name|dlfcn_bind_func
block|,
comment|/* For now, "unbind" doesn't exist */
if|#
directive|if
literal|0
block|NULL,
comment|/* unbind_var */
block|NULL,
comment|/* unbind_func */
endif|#
directive|endif
name|NULL
block|,
comment|/* ctrl */
name|dlfcn_name_converter
block|,
name|dlfcn_merger
block|,
name|NULL
block|,
comment|/* init */
name|NULL
block|,
comment|/* finish */
name|dlfcn_pathbyaddr
block|,
name|dlfcn_globallookup
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|DSO_METHOD
modifier|*
name|DSO_METHOD_dlfcn
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|&
name|dso_meth_dlfcn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prior to using the dlopen() function, we should decide on the flag we  * send. There's a few different ways of doing this and it's a messy  * venn-diagram to match up which platforms support what. So as we don't have  * autoconf yet, I'm implementing a hack that could be hacked further  * relatively easily to deal with cases as we find them. Initially this is to  * cope with OpenBSD.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|DL_LAZY
end_ifdef

begin_define
define|#
directive|define
name|DLOPEN_FLAG
value|DL_LAZY
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|RTLD_NOW
end_ifdef

begin_define
define|#
directive|define
name|DLOPEN_FLAG
value|RTLD_NOW
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DLOPEN_FLAG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_SYS_SUNOS
end_ifdef

begin_define
define|#
directive|define
name|DLOPEN_FLAG
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DLOPEN_FLAG
value|RTLD_NOW
end_define

begin_comment
comment|/* Hope this works everywhere else */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * For this DSO_METHOD, our meth_data STACK will contain; (i) the handle  * (void*) returned from dlopen().  */
end_comment

begin_function
specifier|static
name|int
name|dlfcn_load
parameter_list|(
name|DSO
modifier|*
name|dso
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|NULL
decl_stmt|;
comment|/* See applicable comments in dso_dl.c */
name|char
modifier|*
name|filename
init|=
name|DSO_convert_filename
argument_list|(
name|dso
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|DLOPEN_FLAG
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_LOAD
argument_list|,
name|DSO_R_NO_FILENAME
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
ifdef|#
directive|ifdef
name|RTLD_GLOBAL
if|if
condition|(
name|dso
operator|->
name|flags
operator|&
name|DSO_FLAG_GLOBAL_SYMBOLS
condition|)
name|flags
operator||=
name|RTLD_GLOBAL
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|dlopen
argument_list|(
name|filename
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_LOAD
argument_list|,
name|DSO_R_LOAD_FAILED
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|4
argument_list|,
literal|"filename("
argument_list|,
name|filename
argument_list|,
literal|"): "
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|sk_void_push
argument_list|(
name|dso
operator|->
name|meth_data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|)
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_LOAD
argument_list|,
name|DSO_R_STACK_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Success */
name|dso
operator|->
name|loaded_filename
operator|=
name|filename
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|err
label|:
comment|/* Cleanup! */
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|dlclose
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlfcn_unload
parameter_list|(
name|DSO
modifier|*
name|dso
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|dso
operator|==
name|NULL
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_UNLOAD
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sk_void_num
argument_list|(
name|dso
operator|->
name|meth_data
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ptr
operator|=
name|sk_void_pop
argument_list|(
name|dso
operator|->
name|meth_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_UNLOAD
argument_list|,
name|DSO_R_NULL_HANDLE
argument_list|)
expr_stmt|;
comment|/*          * Should push the value back onto the stack in case of a retry.          */
name|sk_void_push
argument_list|(
name|dso
operator|->
name|meth_data
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* For now I'm not aware of any errors associated with dlclose() */
name|dlclose
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|dlfcn_bind_var
parameter_list|(
name|DSO
modifier|*
name|dso
parameter_list|,
specifier|const
name|char
modifier|*
name|symname
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
operator|(
name|dso
operator|==
name|NULL
operator|)
operator|||
operator|(
name|symname
operator|==
name|NULL
operator|)
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_BIND_VAR
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sk_void_num
argument_list|(
name|dso
operator|->
name|meth_data
argument_list|)
operator|<
literal|1
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_BIND_VAR
argument_list|,
name|DSO_R_STACK_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ptr
operator|=
name|sk_void_value
argument_list|(
name|dso
operator|->
name|meth_data
argument_list|,
name|sk_void_num
argument_list|(
name|dso
operator|->
name|meth_data
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_BIND_VAR
argument_list|,
name|DSO_R_NULL_HANDLE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sym
operator|=
name|dlsym
argument_list|(
name|ptr
argument_list|,
name|symname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_BIND_VAR
argument_list|,
name|DSO_R_SYM_FAILURE
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|4
argument_list|,
literal|"symname("
argument_list|,
name|symname
argument_list|,
literal|"): "
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|sym
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|DSO_FUNC_TYPE
name|dlfcn_bind_func
parameter_list|(
name|DSO
modifier|*
name|dso
parameter_list|,
specifier|const
name|char
modifier|*
name|symname
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
union|union
block|{
name|DSO_FUNC_TYPE
name|sym
decl_stmt|;
name|void
modifier|*
name|dlret
decl_stmt|;
block|}
name|u
union|;
if|if
condition|(
operator|(
name|dso
operator|==
name|NULL
operator|)
operator|||
operator|(
name|symname
operator|==
name|NULL
operator|)
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_BIND_FUNC
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sk_void_num
argument_list|(
name|dso
operator|->
name|meth_data
argument_list|)
operator|<
literal|1
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_BIND_FUNC
argument_list|,
name|DSO_R_STACK_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ptr
operator|=
name|sk_void_value
argument_list|(
name|dso
operator|->
name|meth_data
argument_list|,
name|sk_void_num
argument_list|(
name|dso
operator|->
name|meth_data
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_BIND_FUNC
argument_list|,
name|DSO_R_NULL_HANDLE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|u
operator|.
name|dlret
operator|=
name|dlsym
argument_list|(
name|ptr
argument_list|,
name|symname
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|dlret
operator|==
name|NULL
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_BIND_FUNC
argument_list|,
name|DSO_R_SYM_FAILURE
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|4
argument_list|,
literal|"symname("
argument_list|,
name|symname
argument_list|,
literal|"): "
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
name|u
operator|.
name|sym
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|dlfcn_merger
parameter_list|(
name|DSO
modifier|*
name|dso
parameter_list|,
specifier|const
name|char
modifier|*
name|filespec1
parameter_list|,
specifier|const
name|char
modifier|*
name|filespec2
parameter_list|)
block|{
name|char
modifier|*
name|merged
decl_stmt|;
if|if
condition|(
operator|!
name|filespec1
operator|&&
operator|!
name|filespec2
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_MERGER
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*      * If the first file specification is a rooted path, it rules. same goes      * if the second file specification is missing.      */
if|if
condition|(
operator|!
name|filespec2
operator|||
operator|(
name|filespec1
operator|!=
name|NULL
operator|&&
name|filespec1
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
name|merged
operator|=
name|OPENSSL_malloc
argument_list|(
name|strlen
argument_list|(
name|filespec1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|merged
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_MERGER
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|merged
argument_list|,
name|filespec1
argument_list|)
expr_stmt|;
block|}
comment|/*      * If the first file specification is missing, the second one rules.      */
elseif|else
if|if
condition|(
operator|!
name|filespec1
condition|)
block|{
name|merged
operator|=
name|OPENSSL_malloc
argument_list|(
name|strlen
argument_list|(
name|filespec2
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|merged
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_MERGER
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|merged
argument_list|,
name|filespec2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*          * This part isn't as trivial as it looks.  It assumes that the          * second file specification really is a directory, and makes no          * checks whatsoever.  Therefore, the result becomes the          * concatenation of filespec2 followed by a slash followed by          * filespec1.          */
name|int
name|spec2len
decl_stmt|,
name|len
decl_stmt|;
name|spec2len
operator|=
name|strlen
argument_list|(
name|filespec2
argument_list|)
expr_stmt|;
name|len
operator|=
name|spec2len
operator|+
name|strlen
argument_list|(
name|filespec1
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec2len
operator|&&
name|filespec2
index|[
name|spec2len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|spec2len
operator|--
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
name|merged
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|merged
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_MERGER
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|merged
argument_list|,
name|filespec2
argument_list|)
expr_stmt|;
name|merged
index|[
name|spec2len
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|merged
index|[
name|spec2len
operator|+
literal|1
index|]
argument_list|,
name|filespec1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|merged
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_SYS_MACOSX
end_ifdef

begin_define
define|#
directive|define
name|DSO_ext
value|".dylib"
end_define

begin_define
define|#
directive|define
name|DSO_extlen
value|6
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DSO_ext
value|".so"
end_define

begin_define
define|#
directive|define
name|DSO_extlen
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|char
modifier|*
name|dlfcn_name_converter
parameter_list|(
name|DSO
modifier|*
name|dso
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
modifier|*
name|translated
decl_stmt|;
name|int
name|len
decl_stmt|,
name|rsize
decl_stmt|,
name|transform
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|len
operator|+
literal|1
expr_stmt|;
name|transform
operator|=
operator|(
name|strstr
argument_list|(
name|filename
argument_list|,
literal|"/"
argument_list|)
operator|==
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|transform
condition|)
block|{
comment|/* We will convert this to "%s.so" or "lib%s.so" etc */
name|rsize
operator|+=
name|DSO_extlen
expr_stmt|;
comment|/* The length of ".so" */
if|if
condition|(
operator|(
name|DSO_flags
argument_list|(
name|dso
argument_list|)
operator|&
name|DSO_FLAG_NAME_TRANSLATION_EXT_ONLY
operator|)
operator|==
literal|0
condition|)
name|rsize
operator|+=
literal|3
expr_stmt|;
comment|/* The length of "lib" */
block|}
name|translated
operator|=
name|OPENSSL_malloc
argument_list|(
name|rsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|translated
operator|==
name|NULL
condition|)
block|{
name|DSOerr
argument_list|(
name|DSO_F_DLFCN_NAME_CONVERTER
argument_list|,
name|DSO_R_NAME_TRANSLATION_FAILED
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|transform
condition|)
block|{
if|if
condition|(
operator|(
name|DSO_flags
argument_list|(
name|dso
argument_list|)
operator|&
name|DSO_FLAG_NAME_TRANSLATION_EXT_ONLY
operator|)
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|translated
argument_list|,
literal|"lib%s"
name|DSO_ext
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|translated
argument_list|,
literal|"%s"
name|DSO_ext
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|translated
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|translated
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__sgi
end_ifdef

begin_comment
comment|/*- This is a quote from IRIX manual for dladdr(3c):<dlfcn.h> does not contain a prototype for dladdr or definition of      Dl_info.  The #include<dlfcn.h>  in the SYNOPSIS line is traditional,      but contains no dladdr prototype and no IRIX library contains an      implementation.  Write your own declaration based on the code below.       The following code is dependent on internal interfaces that are not      part of the IRIX compatibility guarantee; however, there is no future      intention to change this interface, so on a practical level, the code      below is safe to use on IRIX. */
end_comment

begin_include
include|#
directive|include
file|<rld_interface.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_RLD_INTERFACE_DLFCN_H_DLADDR
end_ifndef

begin_define
define|#
directive|define
name|_RLD_INTERFACE_DLFCN_H_DLADDR
end_define

begin_typedef
typedef|typedef
struct|struct
name|Dl_info
block|{
specifier|const
name|char
modifier|*
name|dli_fname
decl_stmt|;
name|void
modifier|*
name|dli_fbase
decl_stmt|;
specifier|const
name|char
modifier|*
name|dli_sname
decl_stmt|;
name|void
modifier|*
name|dli_saddr
decl_stmt|;
name|int
name|dli_version
decl_stmt|;
name|int
name|dli_reserved1
decl_stmt|;
name|long
name|dli_reserved
index|[
literal|4
index|]
decl_stmt|;
block|}
name|Dl_info
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|struct
name|Dl_info
name|Dl_info
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_RLD_DLADDR
value|14
end_define

begin_function
specifier|static
name|int
name|dladdr
parameter_list|(
name|void
modifier|*
name|address
parameter_list|,
name|Dl_info
modifier|*
name|dl
parameter_list|)
block|{
name|void
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|_rld_new_interface
argument_list|(
name|_RLD_DLADDR
argument_list|,
name|address
argument_list|,
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|v
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __sgi */
end_comment

begin_function
specifier|static
name|int
name|dlfcn_pathbyaddr
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_DLINFO
name|Dl_info
name|dli
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
union|union
block|{
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|void
modifier|*
name|p
decl_stmt|;
block|}
name|t
init|=
block|{
name|dlfcn_pathbyaddr
block|}
union|;
name|addr
operator|=
name|t
operator|.
name|p
expr_stmt|;
block|}
if|if
condition|(
name|dladdr
argument_list|(
name|addr
argument_list|,
operator|&
name|dli
argument_list|)
condition|)
block|{
name|len
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|dli
operator|.
name|dli_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|<=
literal|0
condition|)
return|return
name|len
operator|+
literal|1
return|;
if|if
condition|(
name|len
operator|>=
name|sz
condition|)
name|len
operator|=
name|sz
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|path
argument_list|,
name|dli
operator|.
name|dli_fname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|path
index|[
name|len
operator|++
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|len
return|;
block|}
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"dlfcn_pathbyaddr(): "
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|dlfcn_globallookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|void
modifier|*
name|ret
init|=
name|NULL
decl_stmt|,
modifier|*
name|handle
init|=
name|dlopen
argument_list|(
name|NULL
argument_list|,
name|RTLD_LAZY
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
condition|)
block|{
name|ret
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dlclose
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DSO_DLFCN */
end_comment

end_unit

