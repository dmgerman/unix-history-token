begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* v3_utl.c */
end_comment

begin_comment
comment|/*  * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL  * project.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1999-2003 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* X509 v3 extension utilities */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/conf.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509v3.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_function_decl
specifier|static
name|char
modifier|*
name|strip_spaces
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sk_strcmp
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|STACK_OF
argument_list|(
name|OPENSSL_STRING
argument_list|)
operator|*
name|get_email
argument_list|(
name|X509_NAME
operator|*
name|name
argument_list|,
name|GENERAL_NAMES
operator|*
name|gens
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|str_free
parameter_list|(
name|OPENSSL_STRING
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|append_ia5
argument_list|(
name|STACK_OF
argument_list|(
name|OPENSSL_STRING
argument_list|)
operator|*
operator|*
name|sk
argument_list|,
name|ASN1_IA5STRING
operator|*
name|email
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ipv4_from_asc
parameter_list|(
name|unsigned
name|char
modifier|*
name|v4
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipv6_from_asc
parameter_list|(
name|unsigned
name|char
modifier|*
name|v6
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipv6_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|elem
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|usr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipv6_hex
parameter_list|(
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|int
name|inlen
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add a CONF_VALUE name value pair to stack */
end_comment

begin_decl_stmt
name|int
name|X509V3_add_value
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
specifier|const
name|char
operator|*
name|value
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
operator|*
name|extlist
argument_list|)
block|{
name|CONF_VALUE
modifier|*
name|vtmp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tname
init|=
name|NULL
decl_stmt|,
modifier|*
name|tvalue
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
operator|(
name|tname
operator|=
name|BUF_strdup
argument_list|(
name|name
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|value
operator|&&
operator|!
operator|(
name|tvalue
operator|=
name|BUF_strdup
argument_list|(
name|value
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
operator|(
name|vtmp
operator|=
operator|(
name|CONF_VALUE
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CONF_VALUE
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
operator|*
name|extlist
operator|&&
operator|!
operator|(
operator|*
name|extlist
operator|=
name|sk_CONF_VALUE_new_null
argument_list|()
operator|)
condition|)
goto|goto
name|err
goto|;
name|vtmp
operator|->
name|section
operator|=
name|NULL
expr_stmt|;
name|vtmp
operator|->
name|name
operator|=
name|tname
expr_stmt|;
name|vtmp
operator|->
name|value
operator|=
name|tvalue
expr_stmt|;
if|if
condition|(
operator|!
name|sk_CONF_VALUE_push
argument_list|(
operator|*
name|extlist
argument_list|,
name|vtmp
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
literal|1
return|;
name|err
label|:
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_ADD_VALUE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtmp
condition|)
name|OPENSSL_free
argument_list|(
name|vtmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tname
condition|)
name|OPENSSL_free
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvalue
condition|)
name|OPENSSL_free
argument_list|(
name|tvalue
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|X509V3_add_value_uchar
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
specifier|const
name|unsigned
name|char
operator|*
name|value
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
operator|*
name|extlist
argument_list|)
block|{
return|return
name|X509V3_add_value
argument_list|(
name|name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|value
argument_list|,
name|extlist
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Free function for STACK_OF(CONF_VALUE) */
end_comment

begin_function
name|void
name|X509V3_conf_free
parameter_list|(
name|CONF_VALUE
modifier|*
name|conf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|conf
condition|)
return|return;
if|if
condition|(
name|conf
operator|->
name|name
condition|)
name|OPENSSL_free
argument_list|(
name|conf
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|->
name|value
condition|)
name|OPENSSL_free
argument_list|(
name|conf
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|->
name|section
condition|)
name|OPENSSL_free
argument_list|(
name|conf
operator|->
name|section
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|X509V3_add_value_bool
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
name|int
name|asn1_bool
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
operator|*
name|extlist
argument_list|)
block|{
if|if
condition|(
name|asn1_bool
condition|)
return|return
name|X509V3_add_value
argument_list|(
name|name
argument_list|,
literal|"TRUE"
argument_list|,
name|extlist
argument_list|)
return|;
return|return
name|X509V3_add_value
argument_list|(
name|name
argument_list|,
literal|"FALSE"
argument_list|,
name|extlist
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|X509V3_add_value_bool_nf
argument_list|(
name|char
operator|*
name|name
argument_list|,
name|int
name|asn1_bool
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
operator|*
name|extlist
argument_list|)
block|{
if|if
condition|(
name|asn1_bool
condition|)
return|return
name|X509V3_add_value
argument_list|(
name|name
argument_list|,
literal|"TRUE"
argument_list|,
name|extlist
argument_list|)
return|;
return|return
literal|1
return|;
block|}
end_decl_stmt

begin_function
name|char
modifier|*
name|i2s_ASN1_ENUMERATED
parameter_list|(
name|X509V3_EXT_METHOD
modifier|*
name|method
parameter_list|,
name|ASN1_ENUMERATED
modifier|*
name|a
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|bntmp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|strtmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|bntmp
operator|=
name|ASN1_ENUMERATED_to_BN
argument_list|(
name|a
argument_list|,
name|NULL
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|strtmp
operator|=
name|BN_bn2dec
argument_list|(
name|bntmp
argument_list|)
operator|)
condition|)
name|X509V3err
argument_list|(
name|X509V3_F_I2S_ASN1_ENUMERATED
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bntmp
argument_list|)
expr_stmt|;
return|return
name|strtmp
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|i2s_ASN1_INTEGER
parameter_list|(
name|X509V3_EXT_METHOD
modifier|*
name|method
parameter_list|,
name|ASN1_INTEGER
modifier|*
name|a
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|bntmp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|strtmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|bntmp
operator|=
name|ASN1_INTEGER_to_BN
argument_list|(
name|a
argument_list|,
name|NULL
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|strtmp
operator|=
name|BN_bn2dec
argument_list|(
name|bntmp
argument_list|)
operator|)
condition|)
name|X509V3err
argument_list|(
name|X509V3_F_I2S_ASN1_INTEGER
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bntmp
argument_list|)
expr_stmt|;
return|return
name|strtmp
return|;
block|}
end_function

begin_function
name|ASN1_INTEGER
modifier|*
name|s2i_ASN1_INTEGER
parameter_list|(
name|X509V3_EXT_METHOD
modifier|*
name|method
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|bn
init|=
name|NULL
decl_stmt|;
name|ASN1_INTEGER
modifier|*
name|aint
decl_stmt|;
name|int
name|isneg
decl_stmt|,
name|ishex
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_S2I_ASN1_INTEGER
argument_list|,
name|X509V3_R_INVALID_NULL_VALUE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bn
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|value
operator|++
expr_stmt|;
name|isneg
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|isneg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|value
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
operator|(
name|value
index|[
literal|1
index|]
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|value
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
operator|)
condition|)
block|{
name|value
operator|+=
literal|2
expr_stmt|;
name|ishex
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ishex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ishex
condition|)
name|ret
operator|=
name|BN_hex2bn
argument_list|(
operator|&
name|bn
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|BN_dec2bn
argument_list|(
operator|&
name|bn
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|||
name|value
index|[
name|ret
index|]
condition|)
block|{
name|BN_free
argument_list|(
name|bn
argument_list|)
expr_stmt|;
name|X509V3err
argument_list|(
name|X509V3_F_S2I_ASN1_INTEGER
argument_list|,
name|X509V3_R_BN_DEC2BN_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|isneg
operator|&&
name|BN_is_zero
argument_list|(
name|bn
argument_list|)
condition|)
name|isneg
operator|=
literal|0
expr_stmt|;
name|aint
operator|=
name|BN_to_ASN1_INTEGER
argument_list|(
name|bn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aint
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_S2I_ASN1_INTEGER
argument_list|,
name|X509V3_R_BN_TO_ASN1_INTEGER_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|isneg
condition|)
name|aint
operator|->
name|type
operator||=
name|V_ASN1_NEG
expr_stmt|;
return|return
name|aint
return|;
block|}
end_function

begin_decl_stmt
name|int
name|X509V3_add_value_int
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
name|ASN1_INTEGER
operator|*
name|aint
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
operator|*
name|extlist
argument_list|)
block|{
name|char
modifier|*
name|strtmp
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|aint
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|strtmp
operator|=
name|i2s_ASN1_INTEGER
argument_list|(
name|NULL
argument_list|,
name|aint
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|X509V3_add_value
argument_list|(
name|name
argument_list|,
name|strtmp
argument_list|,
name|extlist
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|strtmp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_decl_stmt

begin_function
name|int
name|X509V3_get_value_bool
parameter_list|(
name|CONF_VALUE
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|asn1_bool
parameter_list|)
block|{
name|char
modifier|*
name|btmp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|btmp
operator|=
name|value
operator|->
name|value
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"TRUE"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"true"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"Y"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"y"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"YES"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"yes"
argument_list|)
condition|)
block|{
operator|*
name|asn1_bool
operator|=
literal|0xff
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"FALSE"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"false"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"N"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"n"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"NO"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"no"
argument_list|)
condition|)
block|{
operator|*
name|asn1_bool
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|err
label|:
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_GET_VALUE_BOOL
argument_list|,
name|X509V3_R_INVALID_BOOLEAN_STRING
argument_list|)
expr_stmt|;
name|X509V3_conf_err
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|X509V3_get_value_int
parameter_list|(
name|CONF_VALUE
modifier|*
name|value
parameter_list|,
name|ASN1_INTEGER
modifier|*
modifier|*
name|aint
parameter_list|)
block|{
name|ASN1_INTEGER
modifier|*
name|itmp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|itmp
operator|=
name|s2i_ASN1_INTEGER
argument_list|(
name|NULL
argument_list|,
name|value
operator|->
name|value
argument_list|)
operator|)
condition|)
block|{
name|X509V3_conf_err
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|aint
operator|=
name|itmp
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HDR_NAME
value|1
end_define

begin_define
define|#
directive|define
name|HDR_VALUE
value|2
end_define

begin_comment
comment|/*  * #define DEBUG  */
end_comment

begin_expr_stmt
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
name|X509V3_parse_list
argument_list|(
argument|const char *line
argument_list|)
block|{
name|char
operator|*
name|p
block|,
operator|*
name|q
block|,
name|c
block|;
name|char
operator|*
name|ntmp
block|,
operator|*
name|vtmp
block|;
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
name|values
operator|=
name|NULL
block|;
name|char
operator|*
name|linebuf
block|;
name|int
name|state
block|;
comment|/* We are going to modify the line so copy it first */
name|linebuf
operator|=
name|BUF_strdup
argument_list|(
name|line
argument_list|)
block|;
if|if
condition|(
name|linebuf
operator|==
name|NULL
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|state
operator|=
name|HDR_NAME
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ntmp
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Go through all characters */
end_comment

begin_for
for|for
control|(
name|p
operator|=
name|linebuf
operator|,
name|q
operator|=
name|linebuf
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\r'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|HDR_NAME
case|:
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|state
operator|=
name|HDR_VALUE
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|ntmp
operator|=
name|strip_spaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ntmp
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|X509V3_R_INVALID_NULL_NAME
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|ntmp
operator|=
name|strip_spaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s\n", ntmp);
endif|#
directive|endif
if|if
condition|(
operator|!
name|ntmp
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|X509V3_R_INVALID_NULL_NAME
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|X509V3_add_value
argument_list|(
name|ntmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|values
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HDR_VALUE
case|:
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|state
operator|=
name|HDR_NAME
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|vtmp
operator|=
name|strip_spaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s\n", ntmp);
endif|#
directive|endif
if|if
condition|(
operator|!
name|vtmp
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|X509V3_R_INVALID_NULL_VALUE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|X509V3_add_value
argument_list|(
name|ntmp
argument_list|,
name|vtmp
argument_list|,
operator|&
name|values
argument_list|)
expr_stmt|;
name|ntmp
operator|=
name|NULL
expr_stmt|;
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
end_for

begin_if
if|if
condition|(
name|state
operator|==
name|HDR_VALUE
condition|)
block|{
name|vtmp
operator|=
name|strip_spaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s=%s\n", ntmp, vtmp);
endif|#
directive|endif
if|if
condition|(
operator|!
name|vtmp
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|X509V3_R_INVALID_NULL_VALUE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|X509V3_add_value
argument_list|(
name|ntmp
argument_list|,
name|vtmp
argument_list|,
operator|&
name|values
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntmp
operator|=
name|strip_spaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s\n", ntmp);
endif|#
directive|endif
if|if
condition|(
operator|!
name|ntmp
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|X509V3_R_INVALID_NULL_NAME
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|X509V3_add_value
argument_list|(
name|ntmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|values
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|OPENSSL_free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|values
return|;
end_return

begin_label
name|err
label|:
end_label

begin_expr_stmt
name|OPENSSL_free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sk_CONF_VALUE_pop_free
argument_list|(
name|values
argument_list|,
name|X509V3_conf_free
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|NULL
return|;
end_return

begin_comment
unit|}
comment|/* Delete leading and trailing spaces from a string */
end_comment

begin_function
unit|static
name|char
modifier|*
name|strip_spaces
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Skip over leading spaces */
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
return|return
name|NULL
return|;
name|q
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|q
operator|!=
name|p
operator|)
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|q
argument_list|)
condition|)
name|q
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|q
condition|)
name|q
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
return|return
name|NULL
return|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* hex string utilities */
end_comment

begin_comment
comment|/*  * Given a buffer of length 'len' return a OPENSSL_malloc'ed string with its  * hex representation @@@ (Contents of buffer are always kept in ASCII, also  * on EBCDIC machines)  */
end_comment

begin_function
name|char
modifier|*
name|hex_to_string
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|long
name|len
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
specifier|static
name|char
name|hexdig
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|||
operator|!
name|len
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
operator|*
literal|3
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_HEX_TO_STRING
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|q
operator|=
name|tmp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|buffer
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
operator|*
name|q
operator|++
operator|=
name|hexdig
index|[
operator|(
operator|*
name|p
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|hexdig
index|[
operator|*
name|p
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
name|q
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|CHARSET_EBCDIC
name|ebcdic2ascii
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|q
operator|-
name|tmp
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/*  * Give a string of hex digits convert to a buffer  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|string_to_hex
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|long
modifier|*
name|len
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|hexbuf
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|,
name|cl
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_STRING_TO_HEX
argument_list|,
name|X509V3_R_INVALID_NULL_ARGUMENT
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|hexbuf
operator|=
name|OPENSSL_malloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|>>
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str
operator|,
name|q
operator|=
name|hexbuf
init|;
operator|*
name|p
condition|;
control|)
block|{
name|ch
operator|=
operator|*
name|p
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|CHARSET_EBCDIC
name|ch
operator|=
name|os_toebcdic
index|[
name|ch
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ch
operator|==
literal|':'
condition|)
continue|continue;
name|cl
operator|=
operator|*
name|p
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|CHARSET_EBCDIC
name|cl
operator|=
name|os_toebcdic
index|[
name|cl
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cl
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_STRING_TO_HEX
argument_list|,
name|X509V3_R_ODD_NUMBER_OF_DIGITS
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|hexbuf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|isupper
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
name|tolower
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|cl
argument_list|)
condition|)
name|cl
operator|=
name|tolower
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
name|ch
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'f'
operator|)
condition|)
name|ch
operator|-=
literal|'a'
operator|-
literal|10
expr_stmt|;
else|else
goto|goto
name|badhex
goto|;
if|if
condition|(
operator|(
name|cl
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|cl
operator|<=
literal|'9'
operator|)
condition|)
name|cl
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cl
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|cl
operator|<=
literal|'f'
operator|)
condition|)
name|cl
operator|-=
literal|'a'
operator|-
literal|10
expr_stmt|;
else|else
goto|goto
name|badhex
goto|;
operator|*
name|q
operator|++
operator|=
operator|(
name|ch
operator|<<
literal|4
operator|)
operator||
name|cl
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
operator|*
name|len
operator|=
name|q
operator|-
name|hexbuf
expr_stmt|;
return|return
name|hexbuf
return|;
name|err
label|:
if|if
condition|(
name|hexbuf
condition|)
name|OPENSSL_free
argument_list|(
name|hexbuf
argument_list|)
expr_stmt|;
name|X509V3err
argument_list|(
name|X509V3_F_STRING_TO_HEX
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
name|badhex
label|:
name|OPENSSL_free
argument_list|(
name|hexbuf
argument_list|)
expr_stmt|;
name|X509V3err
argument_list|(
name|X509V3_F_STRING_TO_HEX
argument_list|,
name|X509V3_R_ILLEGAL_HEX_DIGIT
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * V2I name comparison function: returns zero if 'name' matches cmp or cmp.*  */
end_comment

begin_function
name|int
name|name_cmp
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|cmp
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|ret
decl_stmt|;
name|char
name|c
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|strncmp
argument_list|(
name|name
argument_list|,
name|cmp
argument_list|,
name|len
argument_list|)
operator|)
condition|)
return|return
name|ret
return|;
name|c
operator|=
name|name
index|[
name|len
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|||
operator|(
name|c
operator|==
literal|'.'
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sk_strcmp
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|b
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
operator|*
name|a
argument_list|,
operator|*
name|b
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|STACK_OF
argument_list|(
name|OPENSSL_STRING
argument_list|)
operator|*
name|X509_get1_email
argument_list|(
argument|X509 *x
argument_list|)
block|{
name|GENERAL_NAMES
operator|*
name|gens
block|;
name|STACK_OF
argument_list|(
name|OPENSSL_STRING
argument_list|)
operator|*
name|ret
block|;
name|gens
operator|=
name|X509_get_ext_d2i
argument_list|(
name|x
argument_list|,
name|NID_subject_alt_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
block|;
name|ret
operator|=
name|get_email
argument_list|(
name|X509_get_subject_name
argument_list|(
name|x
argument_list|)
argument_list|,
name|gens
argument_list|)
block|;
name|sk_GENERAL_NAME_pop_free
argument_list|(
name|gens
argument_list|,
name|GENERAL_NAME_free
argument_list|)
block|;
return|return
name|ret
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|STACK_OF
argument_list|(
name|OPENSSL_STRING
argument_list|)
operator|*
name|X509_get1_ocsp
argument_list|(
argument|X509 *x
argument_list|)
block|{
name|AUTHORITY_INFO_ACCESS
operator|*
name|info
block|;
name|STACK_OF
argument_list|(
name|OPENSSL_STRING
argument_list|)
operator|*
name|ret
operator|=
name|NULL
block|;
name|int
name|i
block|;
name|info
operator|=
name|X509_get_ext_d2i
argument_list|(
name|x
argument_list|,
name|NID_info_access
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
block|;
if|if
condition|(
operator|!
name|info
condition|)
return|return
name|NULL
return|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_ACCESS_DESCRIPTION_num
argument_list|(
name|info
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ACCESS_DESCRIPTION
modifier|*
name|ad
init|=
name|sk_ACCESS_DESCRIPTION_value
argument_list|(
name|info
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|OBJ_obj2nid
argument_list|(
name|ad
operator|->
name|method
argument_list|)
operator|==
name|NID_ad_OCSP
condition|)
block|{
if|if
condition|(
name|ad
operator|->
name|location
operator|->
name|type
operator|==
name|GEN_URI
condition|)
block|{
if|if
condition|(
operator|!
name|append_ia5
argument_list|(
operator|&
name|ret
argument_list|,
name|ad
operator|->
name|location
operator|->
name|d
operator|.
name|uniformResourceIdentifier
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
end_for

begin_expr_stmt
name|AUTHORITY_INFO_ACCESS_free
argument_list|(
name|info
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|ret
return|;
end_return

begin_expr_stmt
unit|}  STACK_OF
operator|(
name|OPENSSL_STRING
operator|)
operator|*
name|X509_REQ_get1_email
argument_list|(
argument|X509_REQ *x
argument_list|)
block|{
name|GENERAL_NAMES
operator|*
name|gens
block|;
name|STACK_OF
argument_list|(
name|X509_EXTENSION
argument_list|)
operator|*
name|exts
block|;
name|STACK_OF
argument_list|(
name|OPENSSL_STRING
argument_list|)
operator|*
name|ret
block|;
name|exts
operator|=
name|X509_REQ_get_extensions
argument_list|(
name|x
argument_list|)
block|;
name|gens
operator|=
name|X509V3_get_d2i
argument_list|(
name|exts
argument_list|,
name|NID_subject_alt_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
block|;
name|ret
operator|=
name|get_email
argument_list|(
name|X509_REQ_get_subject_name
argument_list|(
name|x
argument_list|)
argument_list|,
name|gens
argument_list|)
block|;
name|sk_GENERAL_NAME_pop_free
argument_list|(
name|gens
argument_list|,
name|GENERAL_NAME_free
argument_list|)
block|;
name|sk_X509_EXTENSION_pop_free
argument_list|(
name|exts
argument_list|,
name|X509_EXTENSION_free
argument_list|)
block|;
return|return
name|ret
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|static
name|STACK_OF
argument_list|(
name|OPENSSL_STRING
argument_list|)
operator|*
name|get_email
argument_list|(
argument|X509_NAME *name
argument_list|,
argument|GENERAL_NAMES *gens
argument_list|)
block|{
name|STACK_OF
argument_list|(
name|OPENSSL_STRING
argument_list|)
operator|*
name|ret
operator|=
name|NULL
block|;
name|X509_NAME_ENTRY
operator|*
name|ne
block|;
name|ASN1_IA5STRING
operator|*
name|email
block|;
name|GENERAL_NAME
operator|*
name|gen
block|;
name|int
name|i
block|;
comment|/* Now add any email address(es) to STACK */
name|i
operator|=
operator|-
literal|1
block|;
comment|/* First supplied X509_NAME */
while|while
condition|(
operator|(
name|i
operator|=
name|X509_NAME_get_index_by_NID
argument_list|(
name|name
argument_list|,
name|NID_pkcs9_emailAddress
argument_list|,
name|i
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|ne
operator|=
name|X509_NAME_get_entry
argument_list|(
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|email
operator|=
name|X509_NAME_ENTRY_get_data
argument_list|(
name|ne
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|append_ia5
argument_list|(
operator|&
name|ret
argument_list|,
name|email
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_GENERAL_NAME_num
argument_list|(
name|gens
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|gen
operator|=
name|sk_GENERAL_NAME_value
argument_list|(
name|gens
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
operator|->
name|type
operator|!=
name|GEN_EMAIL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|append_ia5
argument_list|(
operator|&
name|ret
argument_list|,
name|gen
operator|->
name|d
operator|.
name|ia5
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
end_for

begin_return
return|return
name|ret
return|;
end_return

begin_function
unit|}  static
name|void
name|str_free
parameter_list|(
name|OPENSSL_STRING
name|str
parameter_list|)
block|{
name|OPENSSL_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|append_ia5
argument_list|(
name|STACK_OF
argument_list|(
name|OPENSSL_STRING
argument_list|)
operator|*
operator|*
name|sk
argument_list|,
name|ASN1_IA5STRING
operator|*
name|email
argument_list|)
block|{
name|char
modifier|*
name|emtmp
decl_stmt|;
comment|/* First some sanity checks */
if|if
condition|(
name|email
operator|->
name|type
operator|!=
name|V_ASN1_IA5STRING
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|email
operator|->
name|data
operator|||
operator|!
name|email
operator|->
name|length
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|*
name|sk
condition|)
operator|*
name|sk
operator|=
name|sk_OPENSSL_STRING_new
argument_list|(
name|sk_strcmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|sk
condition|)
return|return
literal|0
return|;
comment|/* Don't add duplicates */
if|if
condition|(
name|sk_OPENSSL_STRING_find
argument_list|(
operator|*
name|sk
argument_list|,
operator|(
name|char
operator|*
operator|)
name|email
operator|->
name|data
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|emtmp
operator|=
name|BUF_strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|email
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|emtmp
operator|||
operator|!
name|sk_OPENSSL_STRING_push
argument_list|(
operator|*
name|sk
argument_list|,
name|emtmp
argument_list|)
condition|)
block|{
name|X509_email_free
argument_list|(
operator|*
name|sk
argument_list|)
expr_stmt|;
operator|*
name|sk
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|X509_email_free
argument_list|(
name|STACK_OF
argument_list|(
name|OPENSSL_STRING
argument_list|)
operator|*
name|sk
argument_list|)
block|{
name|sk_OPENSSL_STRING_pop_free
argument_list|(
name|sk
argument_list|,
name|str_free
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|equal_fn
function_decl|)
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|pattern
parameter_list|,
name|size_t
name|pattern_len
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|subject
parameter_list|,
name|size_t
name|subject_len
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Skip pattern prefix to match "wildcard" subject */
end_comment

begin_function
specifier|static
name|void
name|skip_prefix
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|size_t
modifier|*
name|plen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|subject
parameter_list|,
name|size_t
name|subject_len
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|pattern
init|=
operator|*
name|p
decl_stmt|;
name|size_t
name|pattern_len
init|=
operator|*
name|plen
decl_stmt|;
comment|/*      * If subject starts with a leading '.' followed by more octets, and      * pattern is longer, compare just an equal-length suffix with the      * full subject (starting at the '.'), provided the prefix contains      * no NULs.      */
if|if
condition|(
operator|(
name|flags
operator|&
name|_X509_CHECK_FLAG_DOT_SUBDOMAINS
operator|)
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|pattern_len
operator|>
name|subject_len
operator|&&
operator|*
name|pattern
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS
operator|)
operator|&&
operator|*
name|pattern
operator|==
literal|'.'
condition|)
break|break;
operator|++
name|pattern
expr_stmt|;
operator|--
name|pattern_len
expr_stmt|;
block|}
comment|/* Skip if entire prefix acceptable */
if|if
condition|(
name|pattern_len
operator|==
name|subject_len
condition|)
block|{
operator|*
name|p
operator|=
name|pattern
expr_stmt|;
operator|*
name|plen
operator|=
name|pattern_len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compare while ASCII ignoring case. */
end_comment

begin_function
specifier|static
name|int
name|equal_nocase
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|pattern
parameter_list|,
name|size_t
name|pattern_len
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|subject
parameter_list|,
name|size_t
name|subject_len
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|skip_prefix
argument_list|(
operator|&
name|pattern
argument_list|,
operator|&
name|pattern_len
argument_list|,
name|subject
argument_list|,
name|subject_len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern_len
operator|!=
name|subject_len
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|pattern_len
condition|)
block|{
name|unsigned
name|char
name|l
init|=
operator|*
name|pattern
decl_stmt|;
name|unsigned
name|char
name|r
init|=
operator|*
name|subject
decl_stmt|;
comment|/* The pattern must not contain NUL characters. */
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|l
operator|!=
name|r
condition|)
block|{
if|if
condition|(
literal|'A'
operator|<=
name|l
operator|&&
name|l
operator|<=
literal|'Z'
condition|)
name|l
operator|=
operator|(
name|l
operator|-
literal|'A'
operator|)
operator|+
literal|'a'
expr_stmt|;
if|if
condition|(
literal|'A'
operator|<=
name|r
operator|&&
name|r
operator|<=
literal|'Z'
condition|)
name|r
operator|=
operator|(
name|r
operator|-
literal|'A'
operator|)
operator|+
literal|'a'
expr_stmt|;
if|if
condition|(
name|l
operator|!=
name|r
condition|)
return|return
literal|0
return|;
block|}
operator|++
name|pattern
expr_stmt|;
operator|++
name|subject
expr_stmt|;
operator|--
name|pattern_len
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Compare using memcmp. */
end_comment

begin_function
specifier|static
name|int
name|equal_case
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|pattern
parameter_list|,
name|size_t
name|pattern_len
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|subject
parameter_list|,
name|size_t
name|subject_len
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|skip_prefix
argument_list|(
operator|&
name|pattern
argument_list|,
operator|&
name|pattern_len
argument_list|,
name|subject
argument_list|,
name|subject_len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern_len
operator|!=
name|subject_len
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|memcmp
argument_list|(
name|pattern
argument_list|,
name|subject
argument_list|,
name|pattern_len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * RFC 5280, section 7.5, requires that only the domain is compared in a  * case-insensitive manner.  */
end_comment

begin_function
specifier|static
name|int
name|equal_email
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|a
parameter_list|,
name|size_t
name|a_len
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|b
parameter_list|,
name|size_t
name|b_len
parameter_list|,
name|unsigned
name|int
name|unused_flags
parameter_list|)
block|{
name|size_t
name|i
init|=
name|a_len
decl_stmt|;
if|if
condition|(
name|a_len
operator|!=
name|b_len
condition|)
return|return
literal|0
return|;
comment|/*      * We search backwards for the '@' character, so that we do not have to      * deal with quoted local-parts.  The domain part is compared in a      * case-insensitive manner.      */
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
operator|--
name|i
expr_stmt|;
if|if
condition|(
name|a
index|[
name|i
index|]
operator|==
literal|'@'
operator|||
name|b
index|[
name|i
index|]
operator|==
literal|'@'
condition|)
block|{
if|if
condition|(
operator|!
name|equal_nocase
argument_list|(
name|a
operator|+
name|i
argument_list|,
name|a_len
operator|-
name|i
argument_list|,
name|b
operator|+
name|i
argument_list|,
name|a_len
operator|-
name|i
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
name|a_len
expr_stmt|;
return|return
name|equal_case
argument_list|(
name|a
argument_list|,
name|i
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare the prefix and suffix with the subject, and check that the  * characters in-between are valid.  */
end_comment

begin_function
specifier|static
name|int
name|wildcard_match
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|prefix
parameter_list|,
name|size_t
name|prefix_len
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|suffix
parameter_list|,
name|size_t
name|suffix_len
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|subject
parameter_list|,
name|size_t
name|subject_len
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|wildcard_start
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|wildcard_end
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|allow_multi
init|=
literal|0
decl_stmt|;
name|int
name|allow_idna
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|subject_len
operator|<
name|prefix_len
operator|+
name|suffix_len
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|equal_nocase
argument_list|(
name|prefix
argument_list|,
name|prefix_len
argument_list|,
name|subject
argument_list|,
name|prefix_len
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|0
return|;
name|wildcard_start
operator|=
name|subject
operator|+
name|prefix_len
expr_stmt|;
name|wildcard_end
operator|=
name|subject
operator|+
operator|(
name|subject_len
operator|-
name|suffix_len
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|equal_nocase
argument_list|(
name|wildcard_end
argument_list|,
name|suffix_len
argument_list|,
name|suffix
argument_list|,
name|suffix_len
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/*      * If the wildcard makes up the entire first label, it must match at      * least one character.      */
if|if
condition|(
name|prefix_len
operator|==
literal|0
operator|&&
operator|*
name|suffix
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|wildcard_start
operator|==
name|wildcard_end
condition|)
return|return
literal|0
return|;
name|allow_idna
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS
condition|)
name|allow_multi
operator|=
literal|1
expr_stmt|;
block|}
comment|/* IDNA labels cannot match partial wildcards */
if|if
condition|(
operator|!
name|allow_idna
operator|&&
name|subject_len
operator|>=
literal|4
operator|&&
name|strncasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|subject
argument_list|,
literal|"xn--"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* The wildcard may match a literal '*' */
if|if
condition|(
name|wildcard_end
operator|==
name|wildcard_start
operator|+
literal|1
operator|&&
operator|*
name|wildcard_start
operator|==
literal|'*'
condition|)
return|return
literal|1
return|;
comment|/*      * Check that the part matched by the wildcard contains only      * permitted characters and only matches a single label unless      * allow_multi is set.      */
for|for
control|(
name|p
operator|=
name|wildcard_start
init|;
name|p
operator|!=
name|wildcard_end
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|!
operator|(
operator|(
literal|'0'
operator|<=
operator|*
name|p
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
operator|||
operator|(
literal|'A'
operator|<=
operator|*
name|p
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
literal|'a'
operator|<=
operator|*
name|p
operator|&&
operator|*
name|p
operator|<=
literal|'z'
operator|)
operator|||
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|(
name|allow_multi
operator|&&
operator|*
name|p
operator|==
literal|'.'
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|LABEL_START
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|LABEL_END
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|LABEL_HYPHEN
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|LABEL_IDNA
value|(1<< 3)
end_define

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|valid_star
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|star
init|=
literal|0
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|state
init|=
name|LABEL_START
decl_stmt|;
name|int
name|dots
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
comment|/*          * Locate first and only legal wildcard, either at the start          * or end of a non-IDNA first and not final label.          */
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|'*'
condition|)
block|{
name|int
name|atstart
init|=
operator|(
name|state
operator|&
name|LABEL_START
operator|)
decl_stmt|;
name|int
name|atend
init|=
operator|(
name|i
operator|==
name|len
operator|-
literal|1
operator|||
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'.'
operator|)
decl_stmt|;
comment|/*-              * At most one wildcard per pattern.              * No wildcards in IDNA labels.              * No wildcards after the first label.              */
if|if
condition|(
name|star
operator|!=
name|NULL
operator|||
operator|(
name|state
operator|&
name|LABEL_IDNA
operator|)
operator|!=
literal|0
operator|||
name|dots
condition|)
return|return
name|NULL
return|;
comment|/* Only full-label '*.example.com' wildcards? */
if|if
condition|(
operator|(
name|flags
operator|&
name|X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS
operator|)
operator|&&
operator|(
operator|!
name|atstart
operator|||
operator|!
name|atend
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* No 'foo*bar' wildcards */
if|if
condition|(
operator|!
name|atstart
operator|&&
operator|!
name|atend
condition|)
return|return
name|NULL
return|;
name|star
operator|=
operator|&
name|p
index|[
name|i
index|]
expr_stmt|;
name|state
operator|&=
operator|~
name|LABEL_START
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
literal|'a'
operator|<=
name|p
index|[
name|i
index|]
operator|&&
name|p
index|[
name|i
index|]
operator|<=
literal|'z'
operator|)
operator|||
operator|(
literal|'A'
operator|<=
name|p
index|[
name|i
index|]
operator|&&
name|p
index|[
name|i
index|]
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
literal|'0'
operator|<=
name|p
index|[
name|i
index|]
operator|&&
name|p
index|[
name|i
index|]
operator|<=
literal|'9'
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|state
operator|&
name|LABEL_START
operator|)
operator|!=
literal|0
operator|&&
name|len
operator|-
name|i
operator|>=
literal|4
operator|&&
name|strncasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|p
index|[
name|i
index|]
argument_list|,
literal|"xn--"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|state
operator||=
name|LABEL_IDNA
expr_stmt|;
name|state
operator|&=
operator|~
operator|(
name|LABEL_HYPHEN
operator||
name|LABEL_START
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|(
name|state
operator|&
operator|(
name|LABEL_HYPHEN
operator||
name|LABEL_START
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|state
operator|=
name|LABEL_START
expr_stmt|;
operator|++
name|dots
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|(
name|state
operator|&
name|LABEL_HYPHEN
operator|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|state
operator||=
name|LABEL_HYPHEN
expr_stmt|;
block|}
else|else
return|return
name|NULL
return|;
block|}
comment|/*      * The final label must not end in a hyphen or ".", and      * there must be at least two dots after the star.      */
if|if
condition|(
operator|(
name|state
operator|&
operator|(
name|LABEL_START
operator||
name|LABEL_HYPHEN
operator|)
operator|)
operator|!=
literal|0
operator|||
name|dots
operator|<
literal|2
condition|)
return|return
name|NULL
return|;
return|return
name|star
return|;
block|}
end_function

begin_comment
comment|/* Compare using wildcards. */
end_comment

begin_function
specifier|static
name|int
name|equal_wildcard
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|pattern
parameter_list|,
name|size_t
name|pattern_len
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|subject
parameter_list|,
name|size_t
name|subject_len
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|star
init|=
name|NULL
decl_stmt|;
comment|/*      * Subject names starting with '.' can only match a wildcard pattern      * via a subject sub-domain pattern suffix match.      */
if|if
condition|(
operator|!
operator|(
name|subject_len
operator|>
literal|1
operator|&&
name|subject
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
condition|)
name|star
operator|=
name|valid_star
argument_list|(
name|pattern
argument_list|,
name|pattern_len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|star
operator|==
name|NULL
condition|)
return|return
name|equal_nocase
argument_list|(
name|pattern
argument_list|,
name|pattern_len
argument_list|,
name|subject
argument_list|,
name|subject_len
argument_list|,
name|flags
argument_list|)
return|;
return|return
name|wildcard_match
argument_list|(
name|pattern
argument_list|,
name|star
operator|-
name|pattern
argument_list|,
name|star
operator|+
literal|1
argument_list|,
operator|(
name|pattern
operator|+
name|pattern_len
operator|)
operator|-
name|star
operator|-
literal|1
argument_list|,
name|subject
argument_list|,
name|subject_len
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare an ASN1_STRING to a supplied string. If they match return 1. If  * cmp_type> 0 only compare if string matches the type, otherwise convert it  * to UTF8.  */
end_comment

begin_function
specifier|static
name|int
name|do_check_string
parameter_list|(
name|ASN1_STRING
modifier|*
name|a
parameter_list|,
name|int
name|cmp_type
parameter_list|,
name|equal_fn
name|equal
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|b
parameter_list|,
name|size_t
name|blen
parameter_list|,
name|char
modifier|*
modifier|*
name|peername
parameter_list|)
block|{
name|int
name|rv
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|a
operator|->
name|data
operator|||
operator|!
name|a
operator|->
name|length
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cmp_type
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cmp_type
operator|!=
name|a
operator|->
name|type
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cmp_type
operator|==
name|V_ASN1_IA5STRING
condition|)
name|rv
operator|=
name|equal
argument_list|(
name|a
operator|->
name|data
argument_list|,
name|a
operator|->
name|length
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|b
argument_list|,
name|blen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|->
name|length
operator|==
operator|(
name|int
operator|)
name|blen
operator|&&
operator|!
name|memcmp
argument_list|(
name|a
operator|->
name|data
argument_list|,
name|b
argument_list|,
name|blen
argument_list|)
condition|)
name|rv
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rv
operator|>
literal|0
operator|&&
name|peername
condition|)
operator|*
name|peername
operator|=
name|BUF_strndup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
operator|->
name|data
argument_list|,
name|a
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|astrlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|astr
decl_stmt|;
name|astrlen
operator|=
name|ASN1_STRING_to_UTF8
argument_list|(
operator|&
name|astr
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|astrlen
operator|<
literal|0
condition|)
block|{
comment|/*              * -1 could be an internal malloc failure or a decoding error from              * malformed input; we can't distinguish.              */
return|return
operator|-
literal|1
return|;
block|}
name|rv
operator|=
name|equal
argument_list|(
name|astr
argument_list|,
name|astrlen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|b
argument_list|,
name|blen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|>
literal|0
operator|&&
name|peername
condition|)
operator|*
name|peername
operator|=
name|BUF_strndup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|astr
argument_list|,
name|astrlen
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|astr
argument_list|)
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_x509_check
parameter_list|(
name|X509
modifier|*
name|x
parameter_list|,
specifier|const
name|char
modifier|*
name|chk
parameter_list|,
name|size_t
name|chklen
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|int
name|check_type
parameter_list|,
name|char
modifier|*
modifier|*
name|peername
parameter_list|)
block|{
name|GENERAL_NAMES
modifier|*
name|gens
init|=
name|NULL
decl_stmt|;
name|X509_NAME
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|cnid
decl_stmt|;
name|int
name|alt_type
decl_stmt|;
name|int
name|san_present
init|=
literal|0
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|equal_fn
name|equal
decl_stmt|;
comment|/* See below, this flag is internal-only */
name|flags
operator|&=
operator|~
name|_X509_CHECK_FLAG_DOT_SUBDOMAINS
expr_stmt|;
if|if
condition|(
name|check_type
operator|==
name|GEN_EMAIL
condition|)
block|{
name|cnid
operator|=
name|NID_pkcs9_emailAddress
expr_stmt|;
name|alt_type
operator|=
name|V_ASN1_IA5STRING
expr_stmt|;
name|equal
operator|=
name|equal_email
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|check_type
operator|==
name|GEN_DNS
condition|)
block|{
name|cnid
operator|=
name|NID_commonName
expr_stmt|;
comment|/* Implicit client-side DNS sub-domain pattern */
if|if
condition|(
name|chklen
operator|>
literal|1
operator|&&
name|chk
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|flags
operator||=
name|_X509_CHECK_FLAG_DOT_SUBDOMAINS
expr_stmt|;
name|alt_type
operator|=
name|V_ASN1_IA5STRING
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|X509_CHECK_FLAG_NO_WILDCARDS
condition|)
name|equal
operator|=
name|equal_nocase
expr_stmt|;
else|else
name|equal
operator|=
name|equal_wildcard
expr_stmt|;
block|}
else|else
block|{
name|cnid
operator|=
literal|0
expr_stmt|;
name|alt_type
operator|=
name|V_ASN1_OCTET_STRING
expr_stmt|;
name|equal
operator|=
name|equal_case
expr_stmt|;
block|}
if|if
condition|(
name|chklen
operator|==
literal|0
condition|)
name|chklen
operator|=
name|strlen
argument_list|(
name|chk
argument_list|)
expr_stmt|;
name|gens
operator|=
name|X509_get_ext_d2i
argument_list|(
name|x
argument_list|,
name|NID_subject_alt_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gens
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_GENERAL_NAME_num
argument_list|(
name|gens
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|GENERAL_NAME
modifier|*
name|gen
decl_stmt|;
name|ASN1_STRING
modifier|*
name|cstr
decl_stmt|;
name|gen
operator|=
name|sk_GENERAL_NAME_value
argument_list|(
name|gens
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
operator|->
name|type
operator|!=
name|check_type
condition|)
continue|continue;
name|san_present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|check_type
operator|==
name|GEN_EMAIL
condition|)
name|cstr
operator|=
name|gen
operator|->
name|d
operator|.
name|rfc822Name
expr_stmt|;
elseif|else
if|if
condition|(
name|check_type
operator|==
name|GEN_DNS
condition|)
name|cstr
operator|=
name|gen
operator|->
name|d
operator|.
name|dNSName
expr_stmt|;
else|else
name|cstr
operator|=
name|gen
operator|->
name|d
operator|.
name|iPAddress
expr_stmt|;
comment|/* Positive on success, negative on error! */
if|if
condition|(
operator|(
name|rv
operator|=
name|do_check_string
argument_list|(
name|cstr
argument_list|,
name|alt_type
argument_list|,
name|equal
argument_list|,
name|flags
argument_list|,
name|chk
argument_list|,
name|chklen
argument_list|,
name|peername
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|GENERAL_NAMES_free
argument_list|(
name|gens
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
name|rv
return|;
if|if
condition|(
operator|!
name|cnid
operator|||
operator|(
name|san_present
operator|&&
operator|!
operator|(
name|flags
operator|&
name|X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT
operator|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|name
operator|=
name|X509_get_subject_name
argument_list|(
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|X509_NAME_get_index_by_NID
argument_list|(
name|name
argument_list|,
name|cnid
argument_list|,
name|i
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|X509_NAME_ENTRY
modifier|*
name|ne
decl_stmt|;
name|ASN1_STRING
modifier|*
name|str
decl_stmt|;
name|ne
operator|=
name|X509_NAME_get_entry
argument_list|(
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|str
operator|=
name|X509_NAME_ENTRY_get_data
argument_list|(
name|ne
argument_list|)
expr_stmt|;
comment|/* Positive on success, negative on error! */
if|if
condition|(
operator|(
name|rv
operator|=
name|do_check_string
argument_list|(
name|str
argument_list|,
operator|-
literal|1
argument_list|,
name|equal
argument_list|,
name|flags
argument_list|,
name|chk
argument_list|,
name|chklen
argument_list|,
name|peername
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rv
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|X509_check_host
parameter_list|(
name|X509
modifier|*
name|x
parameter_list|,
specifier|const
name|char
modifier|*
name|chk
parameter_list|,
name|size_t
name|chklen
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|char
modifier|*
modifier|*
name|peername
parameter_list|)
block|{
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
return|return
operator|-
literal|2
return|;
comment|/*      * Embedded NULs are disallowed, except as the last character of a      * string of length 2 or more (tolerate caller including terminating      * NUL in string length).      */
if|if
condition|(
name|chklen
operator|==
literal|0
condition|)
name|chklen
operator|=
name|strlen
argument_list|(
name|chk
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|memchr
argument_list|(
name|chk
argument_list|,
literal|'\0'
argument_list|,
name|chklen
operator|>
literal|1
condition|?
name|chklen
operator|-
literal|1
else|:
name|chklen
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
name|chklen
operator|>
literal|1
operator|&&
name|chk
index|[
name|chklen
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
operator|--
name|chklen
expr_stmt|;
return|return
name|do_x509_check
argument_list|(
name|x
argument_list|,
name|chk
argument_list|,
name|chklen
argument_list|,
name|flags
argument_list|,
name|GEN_DNS
argument_list|,
name|peername
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|X509_check_email
parameter_list|(
name|X509
modifier|*
name|x
parameter_list|,
specifier|const
name|char
modifier|*
name|chk
parameter_list|,
name|size_t
name|chklen
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
return|return
operator|-
literal|2
return|;
comment|/*      * Embedded NULs are disallowed, except as the last character of a      * string of length 2 or more (tolerate caller including terminating      * NUL in string length).      */
if|if
condition|(
name|chklen
operator|==
literal|0
condition|)
name|chklen
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|chk
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|memchr
argument_list|(
name|chk
argument_list|,
literal|'\0'
argument_list|,
name|chklen
operator|>
literal|1
condition|?
name|chklen
operator|-
literal|1
else|:
name|chklen
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
name|chklen
operator|>
literal|1
operator|&&
name|chk
index|[
name|chklen
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
operator|--
name|chklen
expr_stmt|;
return|return
name|do_x509_check
argument_list|(
name|x
argument_list|,
name|chk
argument_list|,
name|chklen
argument_list|,
name|flags
argument_list|,
name|GEN_EMAIL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|X509_check_ip
parameter_list|(
name|X509
modifier|*
name|x
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|chk
parameter_list|,
name|size_t
name|chklen
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
return|return
operator|-
literal|2
return|;
return|return
name|do_x509_check
argument_list|(
name|x
argument_list|,
operator|(
name|char
operator|*
operator|)
name|chk
argument_list|,
name|chklen
argument_list|,
name|flags
argument_list|,
name|GEN_IPADD
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|X509_check_ip_asc
parameter_list|(
name|X509
modifier|*
name|x
parameter_list|,
specifier|const
name|char
modifier|*
name|ipasc
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|char
name|ipout
index|[
literal|16
index|]
decl_stmt|;
name|size_t
name|iplen
decl_stmt|;
if|if
condition|(
name|ipasc
operator|==
name|NULL
condition|)
return|return
operator|-
literal|2
return|;
name|iplen
operator|=
operator|(
name|size_t
operator|)
name|a2i_ipadd
argument_list|(
name|ipout
argument_list|,
name|ipasc
argument_list|)
expr_stmt|;
if|if
condition|(
name|iplen
operator|==
literal|0
condition|)
return|return
operator|-
literal|2
return|;
return|return
name|do_x509_check
argument_list|(
name|x
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ipout
argument_list|,
name|iplen
argument_list|,
name|flags
argument_list|,
name|GEN_IPADD
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert IP addresses both IPv4 and IPv6 into an OCTET STRING compatible  * with RFC3280.  */
end_comment

begin_function
name|ASN1_OCTET_STRING
modifier|*
name|a2i_IPADDRESS
parameter_list|(
specifier|const
name|char
modifier|*
name|ipasc
parameter_list|)
block|{
name|unsigned
name|char
name|ipout
index|[
literal|16
index|]
decl_stmt|;
name|ASN1_OCTET_STRING
modifier|*
name|ret
decl_stmt|;
name|int
name|iplen
decl_stmt|;
comment|/* If string contains a ':' assume IPv6 */
name|iplen
operator|=
name|a2i_ipadd
argument_list|(
name|ipout
argument_list|,
name|ipasc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iplen
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
name|ASN1_OCTET_STRING_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|ASN1_OCTET_STRING_set
argument_list|(
name|ret
argument_list|,
name|ipout
argument_list|,
name|iplen
argument_list|)
condition|)
block|{
name|ASN1_OCTET_STRING_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|ASN1_OCTET_STRING
modifier|*
name|a2i_IPADDRESS_NC
parameter_list|(
specifier|const
name|char
modifier|*
name|ipasc
parameter_list|)
block|{
name|ASN1_OCTET_STRING
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|ipout
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|iptmp
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|iplen1
decl_stmt|,
name|iplen2
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|ipasc
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NULL
return|;
name|iptmp
operator|=
name|BUF_strdup
argument_list|(
name|ipasc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iptmp
condition|)
return|return
name|NULL
return|;
name|p
operator|=
name|iptmp
operator|+
operator|(
name|p
operator|-
name|ipasc
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|iplen1
operator|=
name|a2i_ipadd
argument_list|(
name|ipout
argument_list|,
name|iptmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iplen1
condition|)
goto|goto
name|err
goto|;
name|iplen2
operator|=
name|a2i_ipadd
argument_list|(
name|ipout
operator|+
name|iplen1
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|iptmp
argument_list|)
expr_stmt|;
name|iptmp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|iplen2
operator|||
operator|(
name|iplen1
operator|!=
name|iplen2
operator|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|ASN1_OCTET_STRING_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|ASN1_OCTET_STRING_set
argument_list|(
name|ret
argument_list|,
name|ipout
argument_list|,
name|iplen1
operator|+
name|iplen2
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
name|ret
return|;
name|err
label|:
if|if
condition|(
name|iptmp
condition|)
name|OPENSSL_free
argument_list|(
name|iptmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|ASN1_OCTET_STRING_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|a2i_ipadd
parameter_list|(
name|unsigned
name|char
modifier|*
name|ipout
parameter_list|,
specifier|const
name|char
modifier|*
name|ipasc
parameter_list|)
block|{
comment|/* If string contains a ':' assume IPv6 */
if|if
condition|(
name|strchr
argument_list|(
name|ipasc
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ipv6_from_asc
argument_list|(
name|ipout
argument_list|,
name|ipasc
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|16
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ipv4_from_asc
argument_list|(
name|ipout
argument_list|,
name|ipasc
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|4
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ipv4_from_asc
parameter_list|(
name|unsigned
name|char
modifier|*
name|v4
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|)
block|{
name|int
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|in
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
operator|&
name|a0
argument_list|,
operator|&
name|a1
argument_list|,
operator|&
name|a2
argument_list|,
operator|&
name|a3
argument_list|)
operator|!=
literal|4
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|a0
operator|<
literal|0
operator|)
operator|||
operator|(
name|a0
operator|>
literal|255
operator|)
operator|||
operator|(
name|a1
operator|<
literal|0
operator|)
operator|||
operator|(
name|a1
operator|>
literal|255
operator|)
operator|||
operator|(
name|a2
operator|<
literal|0
operator|)
operator|||
operator|(
name|a2
operator|>
literal|255
operator|)
operator|||
operator|(
name|a3
operator|<
literal|0
operator|)
operator|||
operator|(
name|a3
operator|>
literal|255
operator|)
condition|)
return|return
literal|0
return|;
name|v4
index|[
literal|0
index|]
operator|=
name|a0
expr_stmt|;
name|v4
index|[
literal|1
index|]
operator|=
name|a1
expr_stmt|;
name|v4
index|[
literal|2
index|]
operator|=
name|a2
expr_stmt|;
name|v4
index|[
literal|3
index|]
operator|=
name|a3
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Temporary store for IPV6 output */
name|unsigned
name|char
name|tmp
index|[
literal|16
index|]
decl_stmt|;
comment|/* Total number of bytes in tmp */
name|int
name|total
decl_stmt|;
comment|/* The position of a zero (corresponding to '::') */
name|int
name|zero_pos
decl_stmt|;
comment|/* Number of zeroes */
name|int
name|zero_cnt
decl_stmt|;
block|}
name|IPV6_STAT
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|ipv6_from_asc
parameter_list|(
name|unsigned
name|char
modifier|*
name|v6
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|)
block|{
name|IPV6_STAT
name|v6stat
decl_stmt|;
name|v6stat
operator|.
name|total
operator|=
literal|0
expr_stmt|;
name|v6stat
operator|.
name|zero_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|v6stat
operator|.
name|zero_cnt
operator|=
literal|0
expr_stmt|;
comment|/*      * Treat the IPv6 representation as a list of values separated by ':'.      * The presence of a '::' will parse as one, two or three zero length      * elements.      */
if|if
condition|(
operator|!
name|CONF_parse_list
argument_list|(
name|in
argument_list|,
literal|':'
argument_list|,
literal|0
argument_list|,
name|ipv6_cb
argument_list|,
operator|&
name|v6stat
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Now for some sanity checks */
if|if
condition|(
name|v6stat
operator|.
name|zero_pos
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* If no '::' must have exactly 16 bytes */
if|if
condition|(
name|v6stat
operator|.
name|total
operator|!=
literal|16
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* If '::' must have less than 16 bytes */
if|if
condition|(
name|v6stat
operator|.
name|total
operator|==
literal|16
condition|)
return|return
literal|0
return|;
comment|/* More than three zeroes is an error */
if|if
condition|(
name|v6stat
operator|.
name|zero_cnt
operator|>
literal|3
condition|)
return|return
literal|0
return|;
comment|/* Can only have three zeroes if nothing else present */
elseif|else
if|if
condition|(
name|v6stat
operator|.
name|zero_cnt
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|v6stat
operator|.
name|total
operator|>
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* Can only have two zeroes if at start or end */
elseif|else
if|if
condition|(
name|v6stat
operator|.
name|zero_cnt
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|v6stat
operator|.
name|zero_pos
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|v6stat
operator|.
name|zero_pos
operator|!=
name|v6stat
operator|.
name|total
operator|)
condition|)
return|return
literal|0
return|;
block|}
else|else
comment|/* Can only have one zero if *not* start or end */
block|{
if|if
condition|(
operator|(
name|v6stat
operator|.
name|zero_pos
operator|==
literal|0
operator|)
operator|||
operator|(
name|v6stat
operator|.
name|zero_pos
operator|==
name|v6stat
operator|.
name|total
operator|)
condition|)
return|return
literal|0
return|;
block|}
block|}
comment|/* Format result */
if|if
condition|(
name|v6stat
operator|.
name|zero_pos
operator|>=
literal|0
condition|)
block|{
comment|/* Copy initial part */
name|memcpy
argument_list|(
name|v6
argument_list|,
name|v6stat
operator|.
name|tmp
argument_list|,
name|v6stat
operator|.
name|zero_pos
argument_list|)
expr_stmt|;
comment|/* Zero middle */
name|memset
argument_list|(
name|v6
operator|+
name|v6stat
operator|.
name|zero_pos
argument_list|,
literal|0
argument_list|,
literal|16
operator|-
name|v6stat
operator|.
name|total
argument_list|)
expr_stmt|;
comment|/* Copy final part */
if|if
condition|(
name|v6stat
operator|.
name|total
operator|!=
name|v6stat
operator|.
name|zero_pos
condition|)
name|memcpy
argument_list|(
name|v6
operator|+
name|v6stat
operator|.
name|zero_pos
operator|+
literal|16
operator|-
name|v6stat
operator|.
name|total
argument_list|,
name|v6stat
operator|.
name|tmp
operator|+
name|v6stat
operator|.
name|zero_pos
argument_list|,
name|v6stat
operator|.
name|total
operator|-
name|v6stat
operator|.
name|zero_pos
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|v6
argument_list|,
name|v6stat
operator|.
name|tmp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipv6_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|elem
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|usr
parameter_list|)
block|{
name|IPV6_STAT
modifier|*
name|s
init|=
name|usr
decl_stmt|;
comment|/* Error if 16 bytes written */
if|if
condition|(
name|s
operator|->
name|total
operator|==
literal|16
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* Zero length element, corresponds to '::' */
if|if
condition|(
name|s
operator|->
name|zero_pos
operator|==
operator|-
literal|1
condition|)
name|s
operator|->
name|zero_pos
operator|=
name|s
operator|->
name|total
expr_stmt|;
comment|/* If we've already got a :: its an error */
elseif|else
if|if
condition|(
name|s
operator|->
name|zero_pos
operator|!=
name|s
operator|->
name|total
condition|)
return|return
literal|0
return|;
name|s
operator|->
name|zero_cnt
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* If more than 4 characters could be final a.b.c.d form */
if|if
condition|(
name|len
operator|>
literal|4
condition|)
block|{
comment|/* Need at least 4 bytes left */
if|if
condition|(
name|s
operator|->
name|total
operator|>
literal|12
condition|)
return|return
literal|0
return|;
comment|/* Must be end of string */
if|if
condition|(
name|elem
index|[
name|len
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ipv4_from_asc
argument_list|(
name|s
operator|->
name|tmp
operator|+
name|s
operator|->
name|total
argument_list|,
name|elem
argument_list|)
condition|)
return|return
literal|0
return|;
name|s
operator|->
name|total
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ipv6_hex
argument_list|(
name|s
operator|->
name|tmp
operator|+
name|s
operator|->
name|total
argument_list|,
name|elem
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
name|s
operator|->
name|total
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a string of up to 4 hex digits into the corresponding IPv6 form.  */
end_comment

begin_function
specifier|static
name|int
name|ipv6_hex
parameter_list|(
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|int
name|inlen
parameter_list|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|num
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inlen
operator|>
literal|4
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|inlen
operator|--
condition|)
block|{
name|c
operator|=
operator|*
name|in
operator|++
expr_stmt|;
name|num
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
condition|)
name|num
operator||=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'F'
operator|)
condition|)
name|num
operator||=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'f'
operator|)
condition|)
name|num
operator||=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
name|out
index|[
literal|0
index|]
operator|=
name|num
operator|>>
literal|8
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|num
operator|&
literal|0xff
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
name|int
name|X509V3_NAME_from_section
argument_list|(
name|X509_NAME
operator|*
name|nm
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
name|dn_sk
argument_list|,
name|unsigned
name|long
name|chtype
argument_list|)
block|{
name|CONF_VALUE
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mval
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|nm
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_CONF_VALUE_num
argument_list|(
name|dn_sk
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|sk_CONF_VALUE_value
argument_list|(
name|dn_sk
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|type
operator|=
name|v
operator|->
name|name
expr_stmt|;
comment|/*          * Skip past any leading X. X: X, etc to allow for multiple instances          */
for|for
control|(
name|p
operator|=
name|type
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
ifndef|#
directive|ifndef
name|CHARSET_EBCDIC
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|','
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'.'
operator|)
condition|)
else|#
directive|else
if|if
condition|(
operator|(
operator|*
name|p
operator|==
name|os_toascii
index|[
literal|':'
index|]
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
name|os_toascii
index|[
literal|','
index|]
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
name|os_toascii
index|[
literal|'.'
index|]
operator|)
condition|)
endif|#
directive|endif
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|type
operator|=
name|p
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|CHARSET_EBCDIC
if|if
condition|(
operator|*
name|type
operator|==
literal|'+'
condition|)
else|#
directive|else
if|if
condition|(
operator|*
name|type
operator|==
name|os_toascii
index|[
literal|'+'
index|]
condition|)
endif|#
directive|endif
block|{
name|mval
operator|=
operator|-
literal|1
expr_stmt|;
name|type
operator|++
expr_stmt|;
block|}
else|else
name|mval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|X509_NAME_add_entry_by_txt
argument_list|(
name|nm
argument_list|,
name|type
argument_list|,
name|chtype
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|v
operator|->
name|value
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|mval
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_decl_stmt

end_unit

