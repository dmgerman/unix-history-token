begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* v3_utl.c */
end_comment

begin_comment
comment|/* Written by Dr Stephen N Henson (shenson@bigfoot.com) for the OpenSSL  * project.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1999-2003 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* X509 v3 extension utilities */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/conf.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509v3.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_function_decl
specifier|static
name|char
modifier|*
name|strip_spaces
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sk_strcmp
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|STACK
modifier|*
name|get_email
parameter_list|(
name|X509_NAME
modifier|*
name|name
parameter_list|,
name|GENERAL_NAMES
modifier|*
name|gens
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|str_free
parameter_list|(
name|void
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|append_ia5
parameter_list|(
name|STACK
modifier|*
modifier|*
name|sk
parameter_list|,
name|ASN1_IA5STRING
modifier|*
name|email
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipv4_from_asc
parameter_list|(
name|unsigned
name|char
modifier|*
name|v4
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipv6_from_asc
parameter_list|(
name|unsigned
name|char
modifier|*
name|v6
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipv6_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|elem
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|usr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipv6_hex
parameter_list|(
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|int
name|inlen
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add a CONF_VALUE name value pair to stack */
end_comment

begin_decl_stmt
name|int
name|X509V3_add_value
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
specifier|const
name|char
operator|*
name|value
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
operator|*
name|extlist
argument_list|)
block|{
name|CONF_VALUE
modifier|*
name|vtmp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tname
init|=
name|NULL
decl_stmt|,
modifier|*
name|tvalue
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
operator|(
name|tname
operator|=
name|BUF_strdup
argument_list|(
name|name
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|value
operator|&&
operator|!
operator|(
name|tvalue
operator|=
name|BUF_strdup
argument_list|(
name|value
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|vtmp
operator|=
operator|(
name|CONF_VALUE
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CONF_VALUE
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
operator|*
name|extlist
operator|&&
operator|!
operator|(
operator|*
name|extlist
operator|=
name|sk_CONF_VALUE_new_null
argument_list|()
operator|)
condition|)
goto|goto
name|err
goto|;
name|vtmp
operator|->
name|section
operator|=
name|NULL
expr_stmt|;
name|vtmp
operator|->
name|name
operator|=
name|tname
expr_stmt|;
name|vtmp
operator|->
name|value
operator|=
name|tvalue
expr_stmt|;
if|if
condition|(
operator|!
name|sk_CONF_VALUE_push
argument_list|(
operator|*
name|extlist
argument_list|,
name|vtmp
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
literal|1
return|;
name|err
label|:
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_ADD_VALUE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtmp
condition|)
name|OPENSSL_free
argument_list|(
name|vtmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tname
condition|)
name|OPENSSL_free
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvalue
condition|)
name|OPENSSL_free
argument_list|(
name|tvalue
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|X509V3_add_value_uchar
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
specifier|const
name|unsigned
name|char
operator|*
name|value
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
operator|*
name|extlist
argument_list|)
block|{
return|return
name|X509V3_add_value
argument_list|(
name|name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|value
argument_list|,
name|extlist
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Free function for STACK_OF(CONF_VALUE) */
end_comment

begin_function
name|void
name|X509V3_conf_free
parameter_list|(
name|CONF_VALUE
modifier|*
name|conf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|conf
condition|)
return|return;
if|if
condition|(
name|conf
operator|->
name|name
condition|)
name|OPENSSL_free
argument_list|(
name|conf
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|->
name|value
condition|)
name|OPENSSL_free
argument_list|(
name|conf
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|->
name|section
condition|)
name|OPENSSL_free
argument_list|(
name|conf
operator|->
name|section
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|X509V3_add_value_bool
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
name|int
name|asn1_bool
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
operator|*
name|extlist
argument_list|)
block|{
if|if
condition|(
name|asn1_bool
condition|)
return|return
name|X509V3_add_value
argument_list|(
name|name
argument_list|,
literal|"TRUE"
argument_list|,
name|extlist
argument_list|)
return|;
return|return
name|X509V3_add_value
argument_list|(
name|name
argument_list|,
literal|"FALSE"
argument_list|,
name|extlist
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|X509V3_add_value_bool_nf
argument_list|(
name|char
operator|*
name|name
argument_list|,
name|int
name|asn1_bool
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
operator|*
name|extlist
argument_list|)
block|{
if|if
condition|(
name|asn1_bool
condition|)
return|return
name|X509V3_add_value
argument_list|(
name|name
argument_list|,
literal|"TRUE"
argument_list|,
name|extlist
argument_list|)
return|;
return|return
literal|1
return|;
block|}
end_decl_stmt

begin_function
name|char
modifier|*
name|i2s_ASN1_ENUMERATED
parameter_list|(
name|X509V3_EXT_METHOD
modifier|*
name|method
parameter_list|,
name|ASN1_ENUMERATED
modifier|*
name|a
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|bntmp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|strtmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|bntmp
operator|=
name|ASN1_ENUMERATED_to_BN
argument_list|(
name|a
argument_list|,
name|NULL
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|strtmp
operator|=
name|BN_bn2dec
argument_list|(
name|bntmp
argument_list|)
operator|)
condition|)
name|X509V3err
argument_list|(
name|X509V3_F_I2S_ASN1_ENUMERATED
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bntmp
argument_list|)
expr_stmt|;
return|return
name|strtmp
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|i2s_ASN1_INTEGER
parameter_list|(
name|X509V3_EXT_METHOD
modifier|*
name|method
parameter_list|,
name|ASN1_INTEGER
modifier|*
name|a
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|bntmp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|strtmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|bntmp
operator|=
name|ASN1_INTEGER_to_BN
argument_list|(
name|a
argument_list|,
name|NULL
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|strtmp
operator|=
name|BN_bn2dec
argument_list|(
name|bntmp
argument_list|)
operator|)
condition|)
name|X509V3err
argument_list|(
name|X509V3_F_I2S_ASN1_INTEGER
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bntmp
argument_list|)
expr_stmt|;
return|return
name|strtmp
return|;
block|}
end_function

begin_function
name|ASN1_INTEGER
modifier|*
name|s2i_ASN1_INTEGER
parameter_list|(
name|X509V3_EXT_METHOD
modifier|*
name|method
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|bn
init|=
name|NULL
decl_stmt|;
name|ASN1_INTEGER
modifier|*
name|aint
decl_stmt|;
name|int
name|isneg
decl_stmt|,
name|ishex
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_S2I_ASN1_INTEGER
argument_list|,
name|X509V3_R_INVALID_NULL_VALUE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bn
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|value
operator|++
expr_stmt|;
name|isneg
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|isneg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|value
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
operator|(
name|value
index|[
literal|1
index|]
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|value
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
operator|)
condition|)
block|{
name|value
operator|+=
literal|2
expr_stmt|;
name|ishex
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ishex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ishex
condition|)
name|ret
operator|=
name|BN_hex2bn
argument_list|(
operator|&
name|bn
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|BN_dec2bn
argument_list|(
operator|&
name|bn
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|||
name|value
index|[
name|ret
index|]
condition|)
block|{
name|BN_free
argument_list|(
name|bn
argument_list|)
expr_stmt|;
name|X509V3err
argument_list|(
name|X509V3_F_S2I_ASN1_INTEGER
argument_list|,
name|X509V3_R_BN_DEC2BN_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|isneg
operator|&&
name|BN_is_zero
argument_list|(
name|bn
argument_list|)
condition|)
name|isneg
operator|=
literal|0
expr_stmt|;
name|aint
operator|=
name|BN_to_ASN1_INTEGER
argument_list|(
name|bn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aint
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_S2I_ASN1_INTEGER
argument_list|,
name|X509V3_R_BN_TO_ASN1_INTEGER_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|isneg
condition|)
name|aint
operator|->
name|type
operator||=
name|V_ASN1_NEG
expr_stmt|;
return|return
name|aint
return|;
block|}
end_function

begin_decl_stmt
name|int
name|X509V3_add_value_int
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
name|ASN1_INTEGER
operator|*
name|aint
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
operator|*
name|extlist
argument_list|)
block|{
name|char
modifier|*
name|strtmp
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|aint
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|strtmp
operator|=
name|i2s_ASN1_INTEGER
argument_list|(
name|NULL
argument_list|,
name|aint
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|X509V3_add_value
argument_list|(
name|name
argument_list|,
name|strtmp
argument_list|,
name|extlist
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|strtmp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_decl_stmt

begin_function
name|int
name|X509V3_get_value_bool
parameter_list|(
name|CONF_VALUE
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|asn1_bool
parameter_list|)
block|{
name|char
modifier|*
name|btmp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|btmp
operator|=
name|value
operator|->
name|value
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"TRUE"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"true"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"Y"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"y"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"YES"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"yes"
argument_list|)
condition|)
block|{
operator|*
name|asn1_bool
operator|=
literal|0xff
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"FALSE"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"false"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"N"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"n"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"NO"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"no"
argument_list|)
condition|)
block|{
operator|*
name|asn1_bool
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|err
label|:
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_GET_VALUE_BOOL
argument_list|,
name|X509V3_R_INVALID_BOOLEAN_STRING
argument_list|)
expr_stmt|;
name|X509V3_conf_err
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|X509V3_get_value_int
parameter_list|(
name|CONF_VALUE
modifier|*
name|value
parameter_list|,
name|ASN1_INTEGER
modifier|*
modifier|*
name|aint
parameter_list|)
block|{
name|ASN1_INTEGER
modifier|*
name|itmp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|itmp
operator|=
name|s2i_ASN1_INTEGER
argument_list|(
name|NULL
argument_list|,
name|value
operator|->
name|value
argument_list|)
operator|)
condition|)
block|{
name|X509V3_conf_err
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|aint
operator|=
name|itmp
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HDR_NAME
value|1
end_define

begin_define
define|#
directive|define
name|HDR_VALUE
value|2
end_define

begin_comment
comment|/*#define DEBUG*/
end_comment

begin_expr_stmt
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
name|X509V3_parse_list
argument_list|(
argument|const char *line
argument_list|)
block|{
name|char
operator|*
name|p
block|,
operator|*
name|q
block|,
name|c
block|;
name|char
operator|*
name|ntmp
block|,
operator|*
name|vtmp
block|;
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
name|values
operator|=
name|NULL
block|;
name|char
operator|*
name|linebuf
block|;
name|int
name|state
block|;
comment|/* We are going to modify the line so copy it first */
name|linebuf
operator|=
name|BUF_strdup
argument_list|(
name|line
argument_list|)
block|;
name|state
operator|=
name|HDR_NAME
block|;
name|ntmp
operator|=
name|NULL
block|;
comment|/* Go through all characters */
for|for
control|(
name|p
operator|=
name|linebuf
operator|,
name|q
operator|=
name|linebuf
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\r'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|HDR_NAME
case|:
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|state
operator|=
name|HDR_VALUE
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|ntmp
operator|=
name|strip_spaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ntmp
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|X509V3_R_INVALID_NULL_NAME
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_if
unit|} else
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|ntmp
operator|=
name|strip_spaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s\n", ntmp);
endif|#
directive|endif
if|if
condition|(
operator|!
name|ntmp
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|X509V3_R_INVALID_NULL_NAME
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|X509V3_add_value
argument_list|(
name|ntmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|values
argument_list|)
expr_stmt|;
block|}
end_if

begin_break
break|break ;
end_break

begin_case
case|case
name|HDR_VALUE
case|:
end_case

begin_if
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|state
operator|=
name|HDR_NAME
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|vtmp
operator|=
name|strip_spaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s\n", ntmp);
endif|#
directive|endif
if|if
condition|(
operator|!
name|vtmp
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|X509V3_R_INVALID_NULL_VALUE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|X509V3_add_value
argument_list|(
name|ntmp
argument_list|,
name|vtmp
argument_list|,
operator|&
name|values
argument_list|)
expr_stmt|;
name|ntmp
operator|=
name|NULL
expr_stmt|;
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
end_if

begin_if
unit|} 	}
if|if
condition|(
name|state
operator|==
name|HDR_VALUE
condition|)
block|{
name|vtmp
operator|=
name|strip_spaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s=%s\n", ntmp, vtmp);
endif|#
directive|endif
if|if
condition|(
operator|!
name|vtmp
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|X509V3_R_INVALID_NULL_VALUE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|X509V3_add_value
argument_list|(
name|ntmp
argument_list|,
name|vtmp
argument_list|,
operator|&
name|values
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntmp
operator|=
name|strip_spaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s\n", ntmp);
endif|#
directive|endif
if|if
condition|(
operator|!
name|ntmp
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|X509V3_R_INVALID_NULL_NAME
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|X509V3_add_value
argument_list|(
name|ntmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|values
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|OPENSSL_free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|values
return|;
end_return

begin_label
name|err
label|:
end_label

begin_expr_stmt
name|OPENSSL_free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sk_CONF_VALUE_pop_free
argument_list|(
name|values
argument_list|,
name|X509V3_conf_free
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|NULL
return|;
end_return

begin_comment
unit|}
comment|/* Delete leading and trailing spaces from a string */
end_comment

begin_function
unit|static
name|char
modifier|*
name|strip_spaces
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Skip over leading spaces */
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
return|return
name|NULL
return|;
name|q
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|q
operator|!=
name|p
operator|)
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|q
argument_list|)
condition|)
name|q
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|q
condition|)
name|q
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
return|return
name|NULL
return|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* hex string utilities */
end_comment

begin_comment
comment|/* Given a buffer of length 'len' return a OPENSSL_malloc'ed string with its  * hex representation  * @@@ (Contents of buffer are always kept in ASCII, also on EBCDIC machines)  */
end_comment

begin_function
name|char
modifier|*
name|hex_to_string
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|long
name|len
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
specifier|static
name|char
name|hexdig
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|||
operator|!
name|len
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
operator|*
literal|3
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_HEX_TO_STRING
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|q
operator|=
name|tmp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|buffer
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
operator|*
name|q
operator|++
operator|=
name|hexdig
index|[
operator|(
operator|*
name|p
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|hexdig
index|[
operator|*
name|p
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
name|q
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|CHARSET_EBCDIC
name|ebcdic2ascii
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|q
operator|-
name|tmp
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* Give a string of hex digits convert to  * a buffer  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|string_to_hex
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|long
modifier|*
name|len
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|hexbuf
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|,
name|cl
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_STRING_TO_HEX
argument_list|,
name|X509V3_R_INVALID_NULL_ARGUMENT
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|hexbuf
operator|=
name|OPENSSL_malloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|>>
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str
operator|,
name|q
operator|=
name|hexbuf
init|;
operator|*
name|p
condition|;
control|)
block|{
name|ch
operator|=
operator|*
name|p
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|CHARSET_EBCDIC
name|ch
operator|=
name|os_toebcdic
index|[
name|ch
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ch
operator|==
literal|':'
condition|)
continue|continue;
name|cl
operator|=
operator|*
name|p
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|CHARSET_EBCDIC
name|cl
operator|=
name|os_toebcdic
index|[
name|cl
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cl
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_STRING_TO_HEX
argument_list|,
name|X509V3_R_ODD_NUMBER_OF_DIGITS
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|hexbuf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|isupper
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
name|tolower
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|cl
argument_list|)
condition|)
name|cl
operator|=
name|tolower
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
name|ch
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'f'
operator|)
condition|)
name|ch
operator|-=
literal|'a'
operator|-
literal|10
expr_stmt|;
else|else
goto|goto
name|badhex
goto|;
if|if
condition|(
operator|(
name|cl
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|cl
operator|<=
literal|'9'
operator|)
condition|)
name|cl
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cl
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|cl
operator|<=
literal|'f'
operator|)
condition|)
name|cl
operator|-=
literal|'a'
operator|-
literal|10
expr_stmt|;
else|else
goto|goto
name|badhex
goto|;
operator|*
name|q
operator|++
operator|=
operator|(
name|ch
operator|<<
literal|4
operator|)
operator||
name|cl
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
operator|*
name|len
operator|=
name|q
operator|-
name|hexbuf
expr_stmt|;
return|return
name|hexbuf
return|;
name|err
label|:
if|if
condition|(
name|hexbuf
condition|)
name|OPENSSL_free
argument_list|(
name|hexbuf
argument_list|)
expr_stmt|;
name|X509V3err
argument_list|(
name|X509V3_F_STRING_TO_HEX
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
name|badhex
label|:
name|OPENSSL_free
argument_list|(
name|hexbuf
argument_list|)
expr_stmt|;
name|X509V3err
argument_list|(
name|X509V3_F_STRING_TO_HEX
argument_list|,
name|X509V3_R_ILLEGAL_HEX_DIGIT
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* V2I name comparison function: returns zero if 'name' matches  * cmp or cmp.*  */
end_comment

begin_function
name|int
name|name_cmp
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|cmp
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|ret
decl_stmt|;
name|char
name|c
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|strncmp
argument_list|(
name|name
argument_list|,
name|cmp
argument_list|,
name|len
argument_list|)
operator|)
condition|)
return|return
name|ret
return|;
name|c
operator|=
name|name
index|[
name|len
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|||
operator|(
name|c
operator|==
literal|'.'
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sk_strcmp
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|b
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
operator|*
name|a
argument_list|,
operator|*
name|b
argument_list|)
return|;
block|}
end_function

begin_function
name|STACK
modifier|*
name|X509_get1_email
parameter_list|(
name|X509
modifier|*
name|x
parameter_list|)
block|{
name|GENERAL_NAMES
modifier|*
name|gens
decl_stmt|;
name|STACK
modifier|*
name|ret
decl_stmt|;
name|gens
operator|=
name|X509_get_ext_d2i
argument_list|(
name|x
argument_list|,
name|NID_subject_alt_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|get_email
argument_list|(
name|X509_get_subject_name
argument_list|(
name|x
argument_list|)
argument_list|,
name|gens
argument_list|)
expr_stmt|;
name|sk_GENERAL_NAME_pop_free
argument_list|(
name|gens
argument_list|,
name|GENERAL_NAME_free
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|STACK
modifier|*
name|X509_REQ_get1_email
parameter_list|(
name|X509_REQ
modifier|*
name|x
parameter_list|)
block|{
name|GENERAL_NAMES
modifier|*
name|gens
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509_EXTENSION
argument_list|)
operator|*
name|exts
expr_stmt|;
name|STACK
modifier|*
name|ret
decl_stmt|;
name|exts
operator|=
name|X509_REQ_get_extensions
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|gens
operator|=
name|X509V3_get_d2i
argument_list|(
name|exts
argument_list|,
name|NID_subject_alt_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|get_email
argument_list|(
name|X509_REQ_get_subject_name
argument_list|(
name|x
argument_list|)
argument_list|,
name|gens
argument_list|)
expr_stmt|;
name|sk_GENERAL_NAME_pop_free
argument_list|(
name|gens
argument_list|,
name|GENERAL_NAME_free
argument_list|)
expr_stmt|;
name|sk_X509_EXTENSION_pop_free
argument_list|(
name|exts
argument_list|,
name|X509_EXTENSION_free
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|STACK
modifier|*
name|get_email
parameter_list|(
name|X509_NAME
modifier|*
name|name
parameter_list|,
name|GENERAL_NAMES
modifier|*
name|gens
parameter_list|)
block|{
name|STACK
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|X509_NAME_ENTRY
modifier|*
name|ne
decl_stmt|;
name|ASN1_IA5STRING
modifier|*
name|email
decl_stmt|;
name|GENERAL_NAME
modifier|*
name|gen
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Now add any email address(es) to STACK */
name|i
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* First supplied X509_NAME */
while|while
condition|(
operator|(
name|i
operator|=
name|X509_NAME_get_index_by_NID
argument_list|(
name|name
argument_list|,
name|NID_pkcs9_emailAddress
argument_list|,
name|i
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|ne
operator|=
name|X509_NAME_get_entry
argument_list|(
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|email
operator|=
name|X509_NAME_ENTRY_get_data
argument_list|(
name|ne
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|append_ia5
argument_list|(
operator|&
name|ret
argument_list|,
name|email
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_GENERAL_NAME_num
argument_list|(
name|gens
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|gen
operator|=
name|sk_GENERAL_NAME_value
argument_list|(
name|gens
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
operator|->
name|type
operator|!=
name|GEN_EMAIL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|append_ia5
argument_list|(
operator|&
name|ret
argument_list|,
name|gen
operator|->
name|d
operator|.
name|ia5
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|str_free
parameter_list|(
name|void
modifier|*
name|str
parameter_list|)
block|{
name|OPENSSL_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|append_ia5
parameter_list|(
name|STACK
modifier|*
modifier|*
name|sk
parameter_list|,
name|ASN1_IA5STRING
modifier|*
name|email
parameter_list|)
block|{
name|char
modifier|*
name|emtmp
decl_stmt|;
comment|/* First some sanity checks */
if|if
condition|(
name|email
operator|->
name|type
operator|!=
name|V_ASN1_IA5STRING
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|email
operator|->
name|data
operator|||
operator|!
name|email
operator|->
name|length
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|*
name|sk
condition|)
operator|*
name|sk
operator|=
name|sk_new
argument_list|(
name|sk_strcmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|sk
condition|)
return|return
literal|0
return|;
comment|/* Don't add duplicates */
if|if
condition|(
name|sk_find
argument_list|(
operator|*
name|sk
argument_list|,
operator|(
name|char
operator|*
operator|)
name|email
operator|->
name|data
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|emtmp
operator|=
name|BUF_strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|email
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|emtmp
operator|||
operator|!
name|sk_push
argument_list|(
operator|*
name|sk
argument_list|,
name|emtmp
argument_list|)
condition|)
block|{
name|X509_email_free
argument_list|(
operator|*
name|sk
argument_list|)
expr_stmt|;
operator|*
name|sk
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|X509_email_free
parameter_list|(
name|STACK
modifier|*
name|sk
parameter_list|)
block|{
name|sk_pop_free
argument_list|(
name|sk
argument_list|,
name|str_free
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert IP addresses both IPv4 and IPv6 into an   * OCTET STRING compatible with RFC3280.  */
end_comment

begin_function
name|ASN1_OCTET_STRING
modifier|*
name|a2i_IPADDRESS
parameter_list|(
specifier|const
name|char
modifier|*
name|ipasc
parameter_list|)
block|{
name|unsigned
name|char
name|ipout
index|[
literal|16
index|]
decl_stmt|;
name|ASN1_OCTET_STRING
modifier|*
name|ret
decl_stmt|;
name|int
name|iplen
decl_stmt|;
comment|/* If string contains a ':' assume IPv6 */
name|iplen
operator|=
name|a2i_ipadd
argument_list|(
name|ipout
argument_list|,
name|ipasc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iplen
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
name|ASN1_OCTET_STRING_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|ASN1_OCTET_STRING_set
argument_list|(
name|ret
argument_list|,
name|ipout
argument_list|,
name|iplen
argument_list|)
condition|)
block|{
name|ASN1_OCTET_STRING_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|ASN1_OCTET_STRING
modifier|*
name|a2i_IPADDRESS_NC
parameter_list|(
specifier|const
name|char
modifier|*
name|ipasc
parameter_list|)
block|{
name|ASN1_OCTET_STRING
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|ipout
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|iptmp
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|iplen1
decl_stmt|,
name|iplen2
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|ipasc
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NULL
return|;
name|iptmp
operator|=
name|BUF_strdup
argument_list|(
name|ipasc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iptmp
condition|)
return|return
name|NULL
return|;
name|p
operator|=
name|iptmp
operator|+
operator|(
name|p
operator|-
name|ipasc
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|iplen1
operator|=
name|a2i_ipadd
argument_list|(
name|ipout
argument_list|,
name|iptmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iplen1
condition|)
goto|goto
name|err
goto|;
name|iplen2
operator|=
name|a2i_ipadd
argument_list|(
name|ipout
operator|+
name|iplen1
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|iptmp
argument_list|)
expr_stmt|;
name|iptmp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|iplen2
operator|||
operator|(
name|iplen1
operator|!=
name|iplen2
operator|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|ASN1_OCTET_STRING_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|ASN1_OCTET_STRING_set
argument_list|(
name|ret
argument_list|,
name|ipout
argument_list|,
name|iplen1
operator|+
name|iplen2
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
name|ret
return|;
name|err
label|:
if|if
condition|(
name|iptmp
condition|)
name|OPENSSL_free
argument_list|(
name|iptmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|ASN1_OCTET_STRING_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|a2i_ipadd
parameter_list|(
name|unsigned
name|char
modifier|*
name|ipout
parameter_list|,
specifier|const
name|char
modifier|*
name|ipasc
parameter_list|)
block|{
comment|/* If string contains a ':' assume IPv6 */
if|if
condition|(
name|strchr
argument_list|(
name|ipasc
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ipv6_from_asc
argument_list|(
name|ipout
argument_list|,
name|ipasc
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|16
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ipv4_from_asc
argument_list|(
name|ipout
argument_list|,
name|ipasc
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|4
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ipv4_from_asc
parameter_list|(
name|unsigned
name|char
modifier|*
name|v4
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|)
block|{
name|int
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|in
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
operator|&
name|a0
argument_list|,
operator|&
name|a1
argument_list|,
operator|&
name|a2
argument_list|,
operator|&
name|a3
argument_list|)
operator|!=
literal|4
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|a0
operator|<
literal|0
operator|)
operator|||
operator|(
name|a0
operator|>
literal|255
operator|)
operator|||
operator|(
name|a1
operator|<
literal|0
operator|)
operator|||
operator|(
name|a1
operator|>
literal|255
operator|)
operator|||
operator|(
name|a2
operator|<
literal|0
operator|)
operator|||
operator|(
name|a2
operator|>
literal|255
operator|)
operator|||
operator|(
name|a3
operator|<
literal|0
operator|)
operator|||
operator|(
name|a3
operator|>
literal|255
operator|)
condition|)
return|return
literal|0
return|;
name|v4
index|[
literal|0
index|]
operator|=
name|a0
expr_stmt|;
name|v4
index|[
literal|1
index|]
operator|=
name|a1
expr_stmt|;
name|v4
index|[
literal|2
index|]
operator|=
name|a2
expr_stmt|;
name|v4
index|[
literal|3
index|]
operator|=
name|a3
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Temporary store for IPV6 output */
name|unsigned
name|char
name|tmp
index|[
literal|16
index|]
decl_stmt|;
comment|/* Total number of bytes in tmp */
name|int
name|total
decl_stmt|;
comment|/* The position of a zero (corresponding to '::') */
name|int
name|zero_pos
decl_stmt|;
comment|/* Number of zeroes */
name|int
name|zero_cnt
decl_stmt|;
block|}
name|IPV6_STAT
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|ipv6_from_asc
parameter_list|(
name|unsigned
name|char
modifier|*
name|v6
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|)
block|{
name|IPV6_STAT
name|v6stat
decl_stmt|;
name|v6stat
operator|.
name|total
operator|=
literal|0
expr_stmt|;
name|v6stat
operator|.
name|zero_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|v6stat
operator|.
name|zero_cnt
operator|=
literal|0
expr_stmt|;
comment|/* Treat the IPv6 representation as a list of values 	 * separated by ':'. The presence of a '::' will parse  	 * as one, two or three zero length elements. 	 */
if|if
condition|(
operator|!
name|CONF_parse_list
argument_list|(
name|in
argument_list|,
literal|':'
argument_list|,
literal|0
argument_list|,
name|ipv6_cb
argument_list|,
operator|&
name|v6stat
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Now for some sanity checks */
if|if
condition|(
name|v6stat
operator|.
name|zero_pos
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* If no '::' must have exactly 16 bytes */
if|if
condition|(
name|v6stat
operator|.
name|total
operator|!=
literal|16
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* If '::' must have less than 16 bytes */
if|if
condition|(
name|v6stat
operator|.
name|total
operator|==
literal|16
condition|)
return|return
literal|0
return|;
comment|/* More than three zeroes is an error */
if|if
condition|(
name|v6stat
operator|.
name|zero_cnt
operator|>
literal|3
condition|)
return|return
literal|0
return|;
comment|/* Can only have three zeroes if nothing else present */
elseif|else
if|if
condition|(
name|v6stat
operator|.
name|zero_cnt
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|v6stat
operator|.
name|total
operator|>
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* Can only have two zeroes if at start or end */
elseif|else
if|if
condition|(
name|v6stat
operator|.
name|zero_cnt
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|v6stat
operator|.
name|zero_pos
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|v6stat
operator|.
name|zero_pos
operator|!=
name|v6stat
operator|.
name|total
operator|)
condition|)
return|return
literal|0
return|;
block|}
else|else
comment|/* Can only have one zero if *not* start or end */
block|{
if|if
condition|(
operator|(
name|v6stat
operator|.
name|zero_pos
operator|==
literal|0
operator|)
operator|||
operator|(
name|v6stat
operator|.
name|zero_pos
operator|==
name|v6stat
operator|.
name|total
operator|)
condition|)
return|return
literal|0
return|;
block|}
block|}
comment|/* Format result */
comment|/* Copy initial part */
if|if
condition|(
name|v6stat
operator|.
name|zero_pos
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|v6
argument_list|,
name|v6stat
operator|.
name|tmp
argument_list|,
name|v6stat
operator|.
name|zero_pos
argument_list|)
expr_stmt|;
comment|/* Zero middle */
if|if
condition|(
name|v6stat
operator|.
name|total
operator|!=
literal|16
condition|)
name|memset
argument_list|(
name|v6
operator|+
name|v6stat
operator|.
name|zero_pos
argument_list|,
literal|0
argument_list|,
literal|16
operator|-
name|v6stat
operator|.
name|total
argument_list|)
expr_stmt|;
comment|/* Copy final part */
if|if
condition|(
name|v6stat
operator|.
name|total
operator|!=
name|v6stat
operator|.
name|zero_pos
condition|)
name|memcpy
argument_list|(
name|v6
operator|+
name|v6stat
operator|.
name|zero_pos
operator|+
literal|16
operator|-
name|v6stat
operator|.
name|total
argument_list|,
name|v6stat
operator|.
name|tmp
operator|+
name|v6stat
operator|.
name|zero_pos
argument_list|,
name|v6stat
operator|.
name|total
operator|-
name|v6stat
operator|.
name|zero_pos
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipv6_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|elem
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|usr
parameter_list|)
block|{
name|IPV6_STAT
modifier|*
name|s
init|=
name|usr
decl_stmt|;
comment|/* Error if 16 bytes written */
if|if
condition|(
name|s
operator|->
name|total
operator|==
literal|16
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* Zero length element, corresponds to '::' */
if|if
condition|(
name|s
operator|->
name|zero_pos
operator|==
operator|-
literal|1
condition|)
name|s
operator|->
name|zero_pos
operator|=
name|s
operator|->
name|total
expr_stmt|;
comment|/* If we've already got a :: its an error */
elseif|else
if|if
condition|(
name|s
operator|->
name|zero_pos
operator|!=
name|s
operator|->
name|total
condition|)
return|return
literal|0
return|;
name|s
operator|->
name|zero_cnt
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* If more than 4 characters could be final a.b.c.d form */
if|if
condition|(
name|len
operator|>
literal|4
condition|)
block|{
comment|/* Need at least 4 bytes left */
if|if
condition|(
name|s
operator|->
name|total
operator|>
literal|12
condition|)
return|return
literal|0
return|;
comment|/* Must be end of string */
if|if
condition|(
name|elem
index|[
name|len
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ipv4_from_asc
argument_list|(
name|s
operator|->
name|tmp
operator|+
name|s
operator|->
name|total
argument_list|,
name|elem
argument_list|)
condition|)
return|return
literal|0
return|;
name|s
operator|->
name|total
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ipv6_hex
argument_list|(
name|s
operator|->
name|tmp
operator|+
name|s
operator|->
name|total
argument_list|,
name|elem
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
name|s
operator|->
name|total
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Convert a string of up to 4 hex digits into the corresponding  * IPv6 form.  */
end_comment

begin_function
specifier|static
name|int
name|ipv6_hex
parameter_list|(
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|int
name|inlen
parameter_list|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|num
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inlen
operator|>
literal|4
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|inlen
operator|--
condition|)
block|{
name|c
operator|=
operator|*
name|in
operator|++
expr_stmt|;
name|num
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
condition|)
name|num
operator||=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'F'
operator|)
condition|)
name|num
operator||=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'f'
operator|)
condition|)
name|num
operator||=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
name|out
index|[
literal|0
index|]
operator|=
name|num
operator|>>
literal|8
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|num
operator|&
literal|0xff
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
name|int
name|X509V3_NAME_from_section
argument_list|(
name|X509_NAME
operator|*
name|nm
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
name|dn_sk
argument_list|,
name|unsigned
name|long
name|chtype
argument_list|)
block|{
name|CONF_VALUE
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mval
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|nm
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_CONF_VALUE_num
argument_list|(
name|dn_sk
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|sk_CONF_VALUE_value
argument_list|(
name|dn_sk
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|type
operator|=
name|v
operator|->
name|name
expr_stmt|;
comment|/* Skip past any leading X. X: X, etc to allow for 		 * multiple instances  		 */
for|for
control|(
name|p
operator|=
name|type
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
ifndef|#
directive|ifndef
name|CHARSET_EBCDIC
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|','
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'.'
operator|)
condition|)
else|#
directive|else
if|if
condition|(
operator|(
operator|*
name|p
operator|==
name|os_toascii
index|[
literal|':'
index|]
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
name|os_toascii
index|[
literal|','
index|]
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
name|os_toascii
index|[
literal|'.'
index|]
operator|)
condition|)
endif|#
directive|endif
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|type
operator|=
name|p
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|CHARSET_EBCDIC
if|if
condition|(
operator|*
name|type
operator|==
literal|'+'
condition|)
else|#
directive|else
if|if
condition|(
operator|*
name|type
operator|==
name|os_toascii
index|[
literal|'+'
index|]
condition|)
endif|#
directive|endif
block|{
name|mval
operator|=
operator|-
literal|1
expr_stmt|;
name|type
operator|++
expr_stmt|;
block|}
else|else
name|mval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|X509_NAME_add_entry_by_txt
argument_list|(
name|nm
argument_list|,
name|type
argument_list|,
name|chtype
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|v
operator|->
name|value
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|mval
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_decl_stmt

end_unit

