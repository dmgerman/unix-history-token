begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* v3_utl.c */
end_comment

begin_comment
comment|/* Written by Dr Stephen N Henson (shenson@bigfoot.com) for the OpenSSL  * project 1999.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* X509 v3 extension utilities */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/conf.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509v3.h>
end_include

begin_function_decl
specifier|static
name|char
modifier|*
name|strip_spaces
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sk_strcmp
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|STACK
modifier|*
name|get_email
argument_list|(
name|X509_NAME
operator|*
name|name
argument_list|,
name|STACK_OF
argument_list|(
name|GENERAL_NAME
argument_list|)
operator|*
name|gens
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|str_free
parameter_list|(
name|void
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|append_ia5
parameter_list|(
name|STACK
modifier|*
modifier|*
name|sk
parameter_list|,
name|ASN1_IA5STRING
modifier|*
name|email
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add a CONF_VALUE name value pair to stack */
end_comment

begin_decl_stmt
name|int
name|X509V3_add_value
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
specifier|const
name|char
operator|*
name|value
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
operator|*
name|extlist
argument_list|)
block|{
name|CONF_VALUE
modifier|*
name|vtmp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tname
init|=
name|NULL
decl_stmt|,
modifier|*
name|tvalue
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|name
operator|&&
operator|!
operator|(
name|tname
operator|=
name|BUF_strdup
argument_list|(
name|name
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|value
operator|&&
operator|!
operator|(
name|tvalue
operator|=
name|BUF_strdup
argument_list|(
name|value
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|vtmp
operator|=
operator|(
name|CONF_VALUE
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CONF_VALUE
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
operator|*
name|extlist
operator|&&
operator|!
operator|(
operator|*
name|extlist
operator|=
name|sk_CONF_VALUE_new_null
argument_list|()
operator|)
condition|)
goto|goto
name|err
goto|;
name|vtmp
operator|->
name|section
operator|=
name|NULL
expr_stmt|;
name|vtmp
operator|->
name|name
operator|=
name|tname
expr_stmt|;
name|vtmp
operator|->
name|value
operator|=
name|tvalue
expr_stmt|;
if|if
condition|(
operator|!
name|sk_CONF_VALUE_push
argument_list|(
operator|*
name|extlist
argument_list|,
name|vtmp
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
literal|1
return|;
name|err
label|:
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_ADD_VALUE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtmp
condition|)
name|OPENSSL_free
argument_list|(
name|vtmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tname
condition|)
name|OPENSSL_free
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvalue
condition|)
name|OPENSSL_free
argument_list|(
name|tvalue
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|X509V3_add_value_uchar
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
specifier|const
name|unsigned
name|char
operator|*
name|value
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
operator|*
name|extlist
argument_list|)
block|{
return|return
name|X509V3_add_value
argument_list|(
name|name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|value
argument_list|,
name|extlist
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Free function for STACK_OF(CONF_VALUE) */
end_comment

begin_function
name|void
name|X509V3_conf_free
parameter_list|(
name|CONF_VALUE
modifier|*
name|conf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|conf
condition|)
return|return;
if|if
condition|(
name|conf
operator|->
name|name
condition|)
name|OPENSSL_free
argument_list|(
name|conf
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|->
name|value
condition|)
name|OPENSSL_free
argument_list|(
name|conf
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|->
name|section
condition|)
name|OPENSSL_free
argument_list|(
name|conf
operator|->
name|section
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|X509V3_add_value_bool
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
name|int
name|asn1_bool
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
operator|*
name|extlist
argument_list|)
block|{
if|if
condition|(
name|asn1_bool
condition|)
return|return
name|X509V3_add_value
argument_list|(
name|name
argument_list|,
literal|"TRUE"
argument_list|,
name|extlist
argument_list|)
return|;
return|return
name|X509V3_add_value
argument_list|(
name|name
argument_list|,
literal|"FALSE"
argument_list|,
name|extlist
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|X509V3_add_value_bool_nf
argument_list|(
name|char
operator|*
name|name
argument_list|,
name|int
name|asn1_bool
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
operator|*
name|extlist
argument_list|)
block|{
if|if
condition|(
name|asn1_bool
condition|)
return|return
name|X509V3_add_value
argument_list|(
name|name
argument_list|,
literal|"TRUE"
argument_list|,
name|extlist
argument_list|)
return|;
return|return
literal|1
return|;
block|}
end_decl_stmt

begin_function
name|char
modifier|*
name|i2s_ASN1_ENUMERATED
parameter_list|(
name|X509V3_EXT_METHOD
modifier|*
name|method
parameter_list|,
name|ASN1_ENUMERATED
modifier|*
name|a
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|bntmp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|strtmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|bntmp
operator|=
name|ASN1_ENUMERATED_to_BN
argument_list|(
name|a
argument_list|,
name|NULL
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|strtmp
operator|=
name|BN_bn2dec
argument_list|(
name|bntmp
argument_list|)
operator|)
condition|)
name|X509V3err
argument_list|(
name|X509V3_F_I2S_ASN1_ENUMERATED
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bntmp
argument_list|)
expr_stmt|;
return|return
name|strtmp
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|i2s_ASN1_INTEGER
parameter_list|(
name|X509V3_EXT_METHOD
modifier|*
name|method
parameter_list|,
name|ASN1_INTEGER
modifier|*
name|a
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|bntmp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|strtmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|bntmp
operator|=
name|ASN1_INTEGER_to_BN
argument_list|(
name|a
argument_list|,
name|NULL
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|strtmp
operator|=
name|BN_bn2dec
argument_list|(
name|bntmp
argument_list|)
operator|)
condition|)
name|X509V3err
argument_list|(
name|X509V3_F_I2S_ASN1_INTEGER
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bntmp
argument_list|)
expr_stmt|;
return|return
name|strtmp
return|;
block|}
end_function

begin_function
name|ASN1_INTEGER
modifier|*
name|s2i_ASN1_INTEGER
parameter_list|(
name|X509V3_EXT_METHOD
modifier|*
name|method
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|bn
init|=
name|NULL
decl_stmt|;
name|ASN1_INTEGER
modifier|*
name|aint
decl_stmt|;
name|bn
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_S2I_ASN1_INTEGER
argument_list|,
name|X509V3_R_INVALID_NULL_VALUE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|BN_dec2bn
argument_list|(
operator|&
name|bn
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_S2I_ASN1_INTEGER
argument_list|,
name|X509V3_R_BN_DEC2BN_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|aint
operator|=
name|BN_to_ASN1_INTEGER
argument_list|(
name|bn
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_S2I_ASN1_INTEGER
argument_list|,
name|X509V3_R_BN_TO_ASN1_INTEGER_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|BN_free
argument_list|(
name|bn
argument_list|)
expr_stmt|;
return|return
name|aint
return|;
block|}
end_function

begin_decl_stmt
name|int
name|X509V3_add_value_int
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
name|ASN1_INTEGER
operator|*
name|aint
argument_list|,
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
operator|*
name|extlist
argument_list|)
block|{
name|char
modifier|*
name|strtmp
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|aint
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|strtmp
operator|=
name|i2s_ASN1_INTEGER
argument_list|(
name|NULL
argument_list|,
name|aint
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|X509V3_add_value
argument_list|(
name|name
argument_list|,
name|strtmp
argument_list|,
name|extlist
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|strtmp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_decl_stmt

begin_function
name|int
name|X509V3_get_value_bool
parameter_list|(
name|CONF_VALUE
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|asn1_bool
parameter_list|)
block|{
name|char
modifier|*
name|btmp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|btmp
operator|=
name|value
operator|->
name|value
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"TRUE"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"true"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"Y"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"y"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"YES"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"yes"
argument_list|)
condition|)
block|{
operator|*
name|asn1_bool
operator|=
literal|0xff
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"FALSE"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"false"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"N"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"n"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"NO"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|btmp
argument_list|,
literal|"no"
argument_list|)
condition|)
block|{
operator|*
name|asn1_bool
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|err
label|:
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_GET_VALUE_BOOL
argument_list|,
name|X509V3_R_INVALID_BOOLEAN_STRING
argument_list|)
expr_stmt|;
name|X509V3_conf_err
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|X509V3_get_value_int
parameter_list|(
name|CONF_VALUE
modifier|*
name|value
parameter_list|,
name|ASN1_INTEGER
modifier|*
modifier|*
name|aint
parameter_list|)
block|{
name|ASN1_INTEGER
modifier|*
name|itmp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|itmp
operator|=
name|s2i_ASN1_INTEGER
argument_list|(
name|NULL
argument_list|,
name|value
operator|->
name|value
argument_list|)
operator|)
condition|)
block|{
name|X509V3_conf_err
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|aint
operator|=
name|itmp
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HDR_NAME
value|1
end_define

begin_define
define|#
directive|define
name|HDR_VALUE
value|2
end_define

begin_comment
comment|/*#define DEBUG*/
end_comment

begin_expr_stmt
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
name|X509V3_parse_list
argument_list|(
argument|char *line
argument_list|)
block|{
name|char
operator|*
name|p
block|,
operator|*
name|q
block|,
name|c
block|;
name|char
operator|*
name|ntmp
block|,
operator|*
name|vtmp
block|;
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
name|values
operator|=
name|NULL
block|;
name|char
operator|*
name|linebuf
block|;
name|int
name|state
block|;
comment|/* We are going to modify the line so copy it first */
name|linebuf
operator|=
name|BUF_strdup
argument_list|(
name|line
argument_list|)
block|;
name|state
operator|=
name|HDR_NAME
block|;
name|ntmp
operator|=
name|NULL
block|;
comment|/* Go through all characters */
for|for
control|(
name|p
operator|=
name|linebuf
operator|,
name|q
operator|=
name|linebuf
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\r'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|HDR_NAME
case|:
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|state
operator|=
name|HDR_VALUE
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|ntmp
operator|=
name|strip_spaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ntmp
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|X509V3_R_INVALID_NULL_NAME
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_if
unit|} else
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|ntmp
operator|=
name|strip_spaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|ntmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ntmp
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|X509V3_R_INVALID_NULL_NAME
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|X509V3_add_value
argument_list|(
name|ntmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|values
argument_list|)
expr_stmt|;
block|}
end_if

begin_break
break|break ;
end_break

begin_case
case|case
name|HDR_VALUE
case|:
end_case

begin_if
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|state
operator|=
name|HDR_NAME
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|vtmp
operator|=
name|strip_spaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|ntmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|vtmp
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|X509V3_R_INVALID_NULL_VALUE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|X509V3_add_value
argument_list|(
name|ntmp
argument_list|,
name|vtmp
argument_list|,
operator|&
name|values
argument_list|)
expr_stmt|;
name|ntmp
operator|=
name|NULL
expr_stmt|;
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
end_if

begin_if
unit|} 	}
if|if
condition|(
name|state
operator|==
name|HDR_VALUE
condition|)
block|{
name|vtmp
operator|=
name|strip_spaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%s=%s\n"
argument_list|,
name|ntmp
argument_list|,
name|vtmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|vtmp
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|X509V3_R_INVALID_NULL_VALUE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|X509V3_add_value
argument_list|(
name|ntmp
argument_list|,
name|vtmp
argument_list|,
operator|&
name|values
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntmp
operator|=
name|strip_spaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|ntmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ntmp
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_X509V3_PARSE_LIST
argument_list|,
name|X509V3_R_INVALID_NULL_NAME
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|X509V3_add_value
argument_list|(
name|ntmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|values
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|OPENSSL_free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|values
return|;
end_return

begin_label
name|err
label|:
end_label

begin_expr_stmt
name|OPENSSL_free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sk_CONF_VALUE_pop_free
argument_list|(
name|values
argument_list|,
name|X509V3_conf_free
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|NULL
return|;
end_return

begin_comment
unit|}
comment|/* Delete leading and trailing spaces from a string */
end_comment

begin_function
unit|static
name|char
modifier|*
name|strip_spaces
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Skip over leading spaces */
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
return|return
name|NULL
return|;
name|q
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|q
operator|!=
name|p
operator|)
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|q
argument_list|)
condition|)
name|q
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|q
condition|)
name|q
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
return|return
name|NULL
return|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* hex string utilities */
end_comment

begin_comment
comment|/* Given a buffer of length 'len' return a OPENSSL_malloc'ed string with its  * hex representation  * @@@ (Contents of buffer are always kept in ASCII, also on EBCDIC machines)  */
end_comment

begin_function
name|char
modifier|*
name|hex_to_string
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|long
name|len
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|hexdig
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|||
operator|!
name|len
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
operator|*
literal|3
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_HEX_TO_STRING
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|q
operator|=
name|tmp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|buffer
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
operator|*
name|q
operator|++
operator|=
name|hexdig
index|[
operator|(
operator|*
name|p
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|hexdig
index|[
operator|*
name|p
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
name|q
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|CHARSET_EBCDIC
name|ebcdic2ascii
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|q
operator|-
name|tmp
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* Give a string of hex digits convert to  * a buffer  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|string_to_hex
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|long
modifier|*
name|len
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|hexbuf
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|,
name|cl
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_STRING_TO_HEX
argument_list|,
name|X509V3_R_INVALID_NULL_ARGUMENT
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|hexbuf
operator|=
name|OPENSSL_malloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|>>
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str
operator|,
name|q
operator|=
name|hexbuf
init|;
operator|*
name|p
condition|;
control|)
block|{
name|ch
operator|=
operator|*
name|p
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|CHARSET_EBCDIC
name|ch
operator|=
name|os_toebcdic
index|[
name|ch
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ch
operator|==
literal|':'
condition|)
continue|continue;
name|cl
operator|=
operator|*
name|p
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|CHARSET_EBCDIC
name|cl
operator|=
name|os_toebcdic
index|[
name|cl
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cl
condition|)
block|{
name|X509V3err
argument_list|(
name|X509V3_F_STRING_TO_HEX
argument_list|,
name|X509V3_R_ODD_NUMBER_OF_DIGITS
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|hexbuf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|isupper
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
name|tolower
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|cl
argument_list|)
condition|)
name|cl
operator|=
name|tolower
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
name|ch
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'f'
operator|)
condition|)
name|ch
operator|-=
literal|'a'
operator|-
literal|10
expr_stmt|;
else|else
goto|goto
name|badhex
goto|;
if|if
condition|(
operator|(
name|cl
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|cl
operator|<=
literal|'9'
operator|)
condition|)
name|cl
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cl
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|cl
operator|<=
literal|'f'
operator|)
condition|)
name|cl
operator|-=
literal|'a'
operator|-
literal|10
expr_stmt|;
else|else
goto|goto
name|badhex
goto|;
operator|*
name|q
operator|++
operator|=
operator|(
name|ch
operator|<<
literal|4
operator|)
operator||
name|cl
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
operator|*
name|len
operator|=
name|q
operator|-
name|hexbuf
expr_stmt|;
return|return
name|hexbuf
return|;
name|err
label|:
if|if
condition|(
name|hexbuf
condition|)
name|OPENSSL_free
argument_list|(
name|hexbuf
argument_list|)
expr_stmt|;
name|X509V3err
argument_list|(
name|X509V3_F_STRING_TO_HEX
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
name|badhex
label|:
name|OPENSSL_free
argument_list|(
name|hexbuf
argument_list|)
expr_stmt|;
name|X509V3err
argument_list|(
name|X509V3_F_STRING_TO_HEX
argument_list|,
name|X509V3_R_ILLEGAL_HEX_DIGIT
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* V2I name comparison function: returns zero if 'name' matches  * cmp or cmp.*  */
end_comment

begin_function
name|int
name|name_cmp
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|cmp
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|ret
decl_stmt|;
name|char
name|c
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|strncmp
argument_list|(
name|name
argument_list|,
name|cmp
argument_list|,
name|len
argument_list|)
operator|)
condition|)
return|return
name|ret
return|;
name|c
operator|=
name|name
index|[
name|len
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|||
operator|(
name|c
operator|==
literal|'.'
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sk_strcmp
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|b
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
operator|*
name|a
argument_list|,
operator|*
name|b
argument_list|)
return|;
block|}
end_function

begin_function
name|STACK
modifier|*
name|X509_get1_email
parameter_list|(
name|X509
modifier|*
name|x
parameter_list|)
block|{
name|STACK_OF
argument_list|(
name|GENERAL_NAME
argument_list|)
operator|*
name|gens
expr_stmt|;
name|STACK
modifier|*
name|ret
decl_stmt|;
name|gens
operator|=
name|X509_get_ext_d2i
argument_list|(
name|x
argument_list|,
name|NID_subject_alt_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|get_email
argument_list|(
name|X509_get_subject_name
argument_list|(
name|x
argument_list|)
argument_list|,
name|gens
argument_list|)
expr_stmt|;
name|sk_GENERAL_NAME_pop_free
argument_list|(
name|gens
argument_list|,
name|GENERAL_NAME_free
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|STACK
modifier|*
name|X509_REQ_get1_email
parameter_list|(
name|X509_REQ
modifier|*
name|x
parameter_list|)
block|{
name|STACK_OF
argument_list|(
name|GENERAL_NAME
argument_list|)
operator|*
name|gens
expr_stmt|;
name|STACK_OF
argument_list|(
name|X509_EXTENSION
argument_list|)
operator|*
name|exts
expr_stmt|;
name|STACK
modifier|*
name|ret
decl_stmt|;
name|exts
operator|=
name|X509_REQ_get_extensions
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|gens
operator|=
name|X509V3_get_d2i
argument_list|(
name|exts
argument_list|,
name|NID_subject_alt_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|get_email
argument_list|(
name|X509_REQ_get_subject_name
argument_list|(
name|x
argument_list|)
argument_list|,
name|gens
argument_list|)
expr_stmt|;
name|sk_GENERAL_NAME_pop_free
argument_list|(
name|gens
argument_list|,
name|GENERAL_NAME_free
argument_list|)
expr_stmt|;
name|sk_X509_EXTENSION_pop_free
argument_list|(
name|exts
argument_list|,
name|X509_EXTENSION_free
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|STACK
modifier|*
name|get_email
argument_list|(
name|X509_NAME
operator|*
name|name
argument_list|,
name|STACK_OF
argument_list|(
name|GENERAL_NAME
argument_list|)
operator|*
name|gens
argument_list|)
block|{
name|STACK
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|X509_NAME_ENTRY
modifier|*
name|ne
decl_stmt|;
name|ASN1_IA5STRING
modifier|*
name|email
decl_stmt|;
name|GENERAL_NAME
modifier|*
name|gen
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Now add any email address(es) to STACK */
name|i
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* First supplied X509_NAME */
while|while
condition|(
operator|(
name|i
operator|=
name|X509_NAME_get_index_by_NID
argument_list|(
name|name
argument_list|,
name|NID_pkcs9_emailAddress
argument_list|,
name|i
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|ne
operator|=
name|X509_NAME_get_entry
argument_list|(
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|email
operator|=
name|X509_NAME_ENTRY_get_data
argument_list|(
name|ne
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|append_ia5
argument_list|(
operator|&
name|ret
argument_list|,
name|email
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_GENERAL_NAME_num
argument_list|(
name|gens
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|gen
operator|=
name|sk_GENERAL_NAME_value
argument_list|(
name|gens
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
operator|->
name|type
operator|!=
name|GEN_EMAIL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|append_ia5
argument_list|(
operator|&
name|ret
argument_list|,
name|gen
operator|->
name|d
operator|.
name|ia5
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|str_free
parameter_list|(
name|void
modifier|*
name|str
parameter_list|)
block|{
name|OPENSSL_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|append_ia5
parameter_list|(
name|STACK
modifier|*
modifier|*
name|sk
parameter_list|,
name|ASN1_IA5STRING
modifier|*
name|email
parameter_list|)
block|{
name|char
modifier|*
name|emtmp
decl_stmt|;
comment|/* First some sanity checks */
if|if
condition|(
name|email
operator|->
name|type
operator|!=
name|V_ASN1_IA5STRING
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|email
operator|->
name|data
operator|||
operator|!
name|email
operator|->
name|length
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|*
name|sk
condition|)
operator|*
name|sk
operator|=
name|sk_new
argument_list|(
name|sk_strcmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|sk
condition|)
return|return
literal|0
return|;
comment|/* Don't add duplicates */
if|if
condition|(
name|sk_find
argument_list|(
operator|*
name|sk
argument_list|,
operator|(
name|char
operator|*
operator|)
name|email
operator|->
name|data
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|emtmp
operator|=
name|BUF_strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|email
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|emtmp
operator|||
operator|!
name|sk_push
argument_list|(
operator|*
name|sk
argument_list|,
name|emtmp
argument_list|)
condition|)
block|{
name|X509_email_free
argument_list|(
operator|*
name|sk
argument_list|)
expr_stmt|;
operator|*
name|sk
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|X509_email_free
parameter_list|(
name|STACK
modifier|*
name|sk
parameter_list|)
block|{
name|sk_pop_free
argument_list|(
name|sk
argument_list|,
name|str_free
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

