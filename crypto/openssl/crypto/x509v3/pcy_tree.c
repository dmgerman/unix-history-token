begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pcy_tree.c */
end_comment

begin_comment
comment|/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL  * project 2004.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2004 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/x509.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509v3.h>
end_include

begin_include
include|#
directive|include
file|"pcy_int.h"
end_include

begin_comment
comment|/* Initialize policy tree. Return values:  *  0 Some internal error occured.  * -1 Inconsistent or invalid extensions in certificates.  *  1 Tree initialized OK.  *  2 Policy tree is empty.  *  5 Tree OK and requireExplicitPolicy true.  *  6 Tree empty and requireExplicitPolicy true.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tree_init
argument_list|(
name|X509_POLICY_TREE
operator|*
operator|*
name|ptree
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|certs
argument_list|,
name|unsigned
name|int
name|flags
argument_list|)
block|{
name|X509_POLICY_TREE
modifier|*
name|tree
decl_stmt|;
name|X509_POLICY_LEVEL
modifier|*
name|level
decl_stmt|;
specifier|const
name|X509_POLICY_CACHE
modifier|*
name|cache
decl_stmt|;
name|X509_POLICY_DATA
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|X509
modifier|*
name|x
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|explicit_policy
decl_stmt|;
name|int
name|any_skip
decl_stmt|;
name|int
name|map_skip
decl_stmt|;
operator|*
name|ptree
operator|=
name|NULL
expr_stmt|;
name|n
operator|=
name|sk_X509_num
argument_list|(
name|certs
argument_list|)
expr_stmt|;
comment|/* Disable policy mapping for now... */
name|flags
operator||=
name|X509_V_FLAG_INHIBIT_MAP
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|X509_V_FLAG_EXPLICIT_POLICY
condition|)
name|explicit_policy
operator|=
literal|0
expr_stmt|;
else|else
name|explicit_policy
operator|=
name|n
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|X509_V_FLAG_INHIBIT_ANY
condition|)
name|any_skip
operator|=
literal|0
expr_stmt|;
else|else
name|any_skip
operator|=
name|n
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|X509_V_FLAG_INHIBIT_MAP
condition|)
name|map_skip
operator|=
literal|0
expr_stmt|;
else|else
name|map_skip
operator|=
name|n
operator|+
literal|1
expr_stmt|;
comment|/* Can't do anything with just a trust anchor */
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
literal|1
return|;
comment|/* First setup policy cache in all certificates apart from the 	 * trust anchor. Note any bad cache results on the way. Also can 	 * calculate explicit_policy value at this point. 	 */
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|x
operator|=
name|sk_X509_value
argument_list|(
name|certs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|X509_check_purpose
argument_list|(
name|x
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cache
operator|=
name|policy_cache_set
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If cache NULL something bad happened: return immediately */
if|if
condition|(
name|cache
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* If inconsistent extensions keep a note of it but continue */
if|if
condition|(
name|x
operator|->
name|ex_flags
operator|&
name|EXFLAG_INVALID_POLICY
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Otherwise if we have no data (hence no CertificatePolicies) 		 * and haven't already set an inconsistent code note it. 		 */
elseif|else
if|if
condition|(
operator|(
name|ret
operator|==
literal|1
operator|)
operator|&&
operator|!
name|cache
operator|->
name|data
condition|)
name|ret
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|explicit_policy
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|x
operator|->
name|ex_flags
operator|&
name|EXFLAG_SI
operator|)
condition|)
name|explicit_policy
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|cache
operator|->
name|explicit_skip
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|cache
operator|->
name|explicit_skip
operator|<
name|explicit_policy
operator|)
condition|)
name|explicit_policy
operator|=
name|cache
operator|->
name|explicit_skip
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|2
operator|&&
operator|!
name|explicit_policy
condition|)
return|return
literal|6
return|;
return|return
name|ret
return|;
block|}
comment|/* If we get this far initialize the tree */
name|tree
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|X509_POLICY_TREE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree
condition|)
return|return
literal|0
return|;
name|tree
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|tree
operator|->
name|levels
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|X509_POLICY_LEVEL
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
name|tree
operator|->
name|nlevel
operator|=
literal|0
expr_stmt|;
name|tree
operator|->
name|extra_data
operator|=
name|NULL
expr_stmt|;
name|tree
operator|->
name|auth_policies
operator|=
name|NULL
expr_stmt|;
name|tree
operator|->
name|user_policies
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|tree
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|tree
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memset
argument_list|(
name|tree
operator|->
name|levels
argument_list|,
literal|0
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|X509_POLICY_LEVEL
argument_list|)
argument_list|)
expr_stmt|;
name|tree
operator|->
name|nlevel
operator|=
name|n
expr_stmt|;
name|level
operator|=
name|tree
operator|->
name|levels
expr_stmt|;
comment|/* Root data: initialize to anyPolicy */
name|data
operator|=
name|policy_data_new
argument_list|(
name|NULL
argument_list|,
name|OBJ_nid2obj
argument_list|(
name|NID_any_policy
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|||
operator|!
name|level_add_node
argument_list|(
name|level
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|,
name|tree
argument_list|)
condition|)
goto|goto
name|bad_tree
goto|;
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|level
operator|++
expr_stmt|;
name|x
operator|=
name|sk_X509_value
argument_list|(
name|certs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cache
operator|=
name|policy_cache_set
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|CRYPTO_add
argument_list|(
operator|&
name|x
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_X509
argument_list|)
expr_stmt|;
name|level
operator|->
name|cert
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|!
name|cache
operator|->
name|anyPolicy
condition|)
name|level
operator|->
name|flags
operator||=
name|X509_V_FLAG_INHIBIT_ANY
expr_stmt|;
comment|/* Determine inhibit any and inhibit map flags */
if|if
condition|(
name|any_skip
operator|==
literal|0
condition|)
block|{
comment|/* Any matching allowed if certificate is self 			 * issued and not the last in the chain. 			 */
if|if
condition|(
operator|!
operator|(
name|x
operator|->
name|ex_flags
operator|&
name|EXFLAG_SI
operator|)
operator|||
operator|(
name|i
operator|==
literal|0
operator|)
condition|)
name|level
operator|->
name|flags
operator||=
name|X509_V_FLAG_INHIBIT_ANY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|x
operator|->
name|ex_flags
operator|&
name|EXFLAG_SI
operator|)
condition|)
name|any_skip
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|cache
operator|->
name|any_skip
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|cache
operator|->
name|any_skip
operator|<
name|any_skip
operator|)
condition|)
name|any_skip
operator|=
name|cache
operator|->
name|any_skip
expr_stmt|;
block|}
if|if
condition|(
name|map_skip
operator|==
literal|0
condition|)
name|level
operator|->
name|flags
operator||=
name|X509_V_FLAG_INHIBIT_MAP
expr_stmt|;
else|else
block|{
name|map_skip
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|cache
operator|->
name|map_skip
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|cache
operator|->
name|map_skip
operator|<
name|map_skip
operator|)
condition|)
name|map_skip
operator|=
name|cache
operator|->
name|map_skip
expr_stmt|;
block|}
block|}
operator|*
name|ptree
operator|=
name|tree
expr_stmt|;
if|if
condition|(
name|explicit_policy
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|5
return|;
name|bad_tree
label|:
name|X509_policy_tree_free
argument_list|(
name|tree
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* This corresponds to RFC3280 XXXX XXXXX:  * link any data from CertificatePolicies onto matching parent  * or anyPolicy if no match.  */
end_comment

begin_function
specifier|static
name|int
name|tree_link_nodes
parameter_list|(
name|X509_POLICY_LEVEL
modifier|*
name|curr
parameter_list|,
specifier|const
name|X509_POLICY_CACHE
modifier|*
name|cache
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|X509_POLICY_LEVEL
modifier|*
name|last
decl_stmt|;
name|X509_POLICY_DATA
modifier|*
name|data
decl_stmt|;
name|X509_POLICY_NODE
modifier|*
name|parent
decl_stmt|;
name|last
operator|=
name|curr
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_POLICY_DATA_num
argument_list|(
name|cache
operator|->
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|sk_X509_POLICY_DATA_value
argument_list|(
name|cache
operator|->
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* If a node is mapped any it doesn't have a corresponding 		 * CertificatePolicies entry.  		 * However such an identical node would be created 		 * if anyPolicy matching is enabled because there would be 		 * no match with the parent valid_policy_set. So we create 		 * link because then it will have the mapping flags 		 * right and we can prune it later. 		 */
if|if
condition|(
operator|(
name|data
operator|->
name|flags
operator|&
name|POLICY_DATA_FLAG_MAPPED_ANY
operator|)
operator|&&
operator|!
operator|(
name|curr
operator|->
name|flags
operator|&
name|X509_V_FLAG_INHIBIT_ANY
operator|)
condition|)
continue|continue;
comment|/* Look for matching node in parent */
name|parent
operator|=
name|level_find_node
argument_list|(
name|last
argument_list|,
name|data
operator|->
name|valid_policy
argument_list|)
expr_stmt|;
comment|/* If no match link to anyPolicy */
if|if
condition|(
operator|!
name|parent
condition|)
name|parent
operator|=
name|last
operator|->
name|anyPolicy
expr_stmt|;
if|if
condition|(
name|parent
operator|&&
operator|!
name|level_add_node
argument_list|(
name|curr
argument_list|,
name|data
argument_list|,
name|parent
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This corresponds to RFC3280 XXXX XXXXX:  * Create new data for any unmatched policies in the parent and link  * to anyPolicy.  */
end_comment

begin_function
specifier|static
name|int
name|tree_link_any
parameter_list|(
name|X509_POLICY_LEVEL
modifier|*
name|curr
parameter_list|,
specifier|const
name|X509_POLICY_CACHE
modifier|*
name|cache
parameter_list|,
name|X509_POLICY_TREE
modifier|*
name|tree
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|X509_POLICY_DATA
modifier|*
name|data
decl_stmt|;
name|X509_POLICY_NODE
modifier|*
name|node
decl_stmt|;
name|X509_POLICY_LEVEL
modifier|*
name|last
decl_stmt|;
name|last
operator|=
name|curr
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_POLICY_NODE_num
argument_list|(
name|last
operator|->
name|nodes
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|sk_X509_POLICY_NODE_value
argument_list|(
name|last
operator|->
name|nodes
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Skip any node with any children: we only want unmathced 		 * nodes. 		 * 		 * Note: need something better for policy mapping 		 * because each node may have multiple children  		 */
if|if
condition|(
name|node
operator|->
name|nchild
condition|)
continue|continue;
comment|/* Create a new node with qualifiers from anyPolicy and 		 * id from unmatched node. 		 */
name|data
operator|=
name|policy_data_new
argument_list|(
name|NULL
argument_list|,
name|node
operator|->
name|data
operator|->
name|valid_policy
argument_list|,
name|node_critical
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Curr may not have anyPolicy */
name|data
operator|->
name|qualifier_set
operator|=
name|cache
operator|->
name|anyPolicy
operator|->
name|qualifier_set
expr_stmt|;
name|data
operator|->
name|flags
operator||=
name|POLICY_DATA_FLAG_SHARED_QUALIFIERS
expr_stmt|;
if|if
condition|(
operator|!
name|level_add_node
argument_list|(
name|curr
argument_list|,
name|data
argument_list|,
name|node
argument_list|,
name|tree
argument_list|)
condition|)
block|{
name|policy_data_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Finally add link to anyPolicy */
if|if
condition|(
name|last
operator|->
name|anyPolicy
condition|)
block|{
if|if
condition|(
operator|!
name|level_add_node
argument_list|(
name|curr
argument_list|,
name|cache
operator|->
name|anyPolicy
argument_list|,
name|last
operator|->
name|anyPolicy
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Prune the tree: delete any child mapped child data on the current level  * then proceed up the tree deleting any data with no children. If we ever  * have no data on a level we can halt because the tree will be empty.  */
end_comment

begin_function
specifier|static
name|int
name|tree_prune
parameter_list|(
name|X509_POLICY_TREE
modifier|*
name|tree
parameter_list|,
name|X509_POLICY_LEVEL
modifier|*
name|curr
parameter_list|)
block|{
name|X509_POLICY_NODE
modifier|*
name|node
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|sk_X509_POLICY_NODE_num
argument_list|(
name|curr
operator|->
name|nodes
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|node
operator|=
name|sk_X509_POLICY_NODE_value
argument_list|(
name|curr
operator|->
name|nodes
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Delete any mapped data: see RFC3280 XXXX */
if|if
condition|(
name|node
operator|->
name|data
operator|->
name|flags
operator|&
name|POLICY_DATA_FLAG_MAP_MASK
condition|)
block|{
name|node
operator|->
name|parent
operator|->
name|nchild
operator|--
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|node
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sk_X509_POLICY_NODE_delete
argument_list|(
name|curr
operator|->
name|nodes
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
operator|--
name|curr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sk_X509_POLICY_NODE_num
argument_list|(
name|curr
operator|->
name|nodes
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|node
operator|=
name|sk_X509_POLICY_NODE_value
argument_list|(
name|curr
operator|->
name|nodes
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|nchild
operator|==
literal|0
condition|)
block|{
name|node
operator|->
name|parent
operator|->
name|nchild
operator|--
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|node
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sk_X509_POLICY_NODE_delete
argument_list|(
name|curr
operator|->
name|nodes
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|curr
operator|->
name|anyPolicy
operator|&&
operator|!
name|curr
operator|->
name|anyPolicy
operator|->
name|nchild
condition|)
block|{
if|if
condition|(
name|curr
operator|->
name|anyPolicy
operator|->
name|parent
condition|)
name|curr
operator|->
name|anyPolicy
operator|->
name|parent
operator|->
name|nchild
operator|--
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|curr
operator|->
name|anyPolicy
argument_list|)
expr_stmt|;
name|curr
operator|->
name|anyPolicy
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|curr
operator|==
name|tree
operator|->
name|levels
condition|)
block|{
comment|/* If we zapped anyPolicy at top then tree is empty */
if|if
condition|(
operator|!
name|curr
operator|->
name|anyPolicy
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|tree_add_auth_node
argument_list|(
name|STACK_OF
argument_list|(
name|X509_POLICY_NODE
argument_list|)
operator|*
operator|*
name|pnodes
argument_list|,
name|X509_POLICY_NODE
operator|*
name|pcy
argument_list|)
block|{
if|if
condition|(
operator|!
operator|*
name|pnodes
condition|)
block|{
operator|*
name|pnodes
operator|=
name|policy_node_cmp_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pnodes
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|sk_X509_POLICY_NODE_find
argument_list|(
operator|*
name|pnodes
argument_list|,
name|pcy
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|sk_X509_POLICY_NODE_push
argument_list|(
operator|*
name|pnodes
argument_list|,
name|pcy
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Calculate the authority set based on policy tree.  * The 'pnodes' parameter is used as a store for the set of policy nodes  * used to calculate the user set. If the authority set is not anyPolicy  * then pnodes will just point to the authority set. If however the authority  * set is anyPolicy then the set of valid policies (other than anyPolicy)  * is store in pnodes. The return value of '2' is used in this case to indicate  * that pnodes should be freed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tree_calculate_authority_set
argument_list|(
name|X509_POLICY_TREE
operator|*
name|tree
argument_list|,
name|STACK_OF
argument_list|(
name|X509_POLICY_NODE
argument_list|)
operator|*
operator|*
name|pnodes
argument_list|)
block|{
name|X509_POLICY_LEVEL
modifier|*
name|curr
decl_stmt|;
name|X509_POLICY_NODE
modifier|*
name|node
decl_stmt|,
modifier|*
name|anyptr
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509_POLICY_NODE
argument_list|)
operator|*
operator|*
name|addnodes
expr_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|curr
operator|=
name|tree
operator|->
name|levels
operator|+
name|tree
operator|->
name|nlevel
operator|-
literal|1
expr_stmt|;
comment|/* If last level contains anyPolicy set is anyPolicy */
if|if
condition|(
name|curr
operator|->
name|anyPolicy
condition|)
block|{
if|if
condition|(
operator|!
name|tree_add_auth_node
argument_list|(
operator|&
name|tree
operator|->
name|auth_policies
argument_list|,
name|curr
operator|->
name|anyPolicy
argument_list|)
condition|)
return|return
literal|0
return|;
name|addnodes
operator|=
name|pnodes
expr_stmt|;
block|}
else|else
comment|/* Add policies to authority set */
name|addnodes
operator|=
operator|&
name|tree
operator|->
name|auth_policies
expr_stmt|;
name|curr
operator|=
name|tree
operator|->
name|levels
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|tree
operator|->
name|nlevel
condition|;
name|i
operator|++
control|)
block|{
comment|/* If no anyPolicy node on this this level it can't 		 * appear on lower levels so end search. 		 */
if|if
condition|(
operator|!
operator|(
name|anyptr
operator|=
name|curr
operator|->
name|anyPolicy
operator|)
condition|)
break|break;
name|curr
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sk_X509_POLICY_NODE_num
argument_list|(
name|curr
operator|->
name|nodes
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|node
operator|=
name|sk_X509_POLICY_NODE_value
argument_list|(
name|curr
operator|->
name|nodes
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|node
operator|->
name|parent
operator|==
name|anyptr
operator|)
operator|&&
operator|!
name|tree_add_auth_node
argument_list|(
name|addnodes
argument_list|,
name|node
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|addnodes
operator|==
name|pnodes
condition|)
return|return
literal|2
return|;
operator|*
name|pnodes
operator|=
name|tree
operator|->
name|auth_policies
expr_stmt|;
return|return
literal|1
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tree_calculate_user_set
argument_list|(
name|X509_POLICY_TREE
operator|*
name|tree
argument_list|,
name|STACK_OF
argument_list|(
name|ASN1_OBJECT
argument_list|)
operator|*
name|policy_oids
argument_list|,
name|STACK_OF
argument_list|(
name|X509_POLICY_NODE
argument_list|)
operator|*
name|auth_nodes
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|X509_POLICY_NODE
modifier|*
name|node
decl_stmt|;
name|ASN1_OBJECT
modifier|*
name|oid
decl_stmt|;
name|X509_POLICY_NODE
modifier|*
name|anyPolicy
decl_stmt|;
name|X509_POLICY_DATA
modifier|*
name|extra
decl_stmt|;
comment|/* Check if anyPolicy present in authority constrained policy set: 	 * this will happen if it is a leaf node. 	 */
if|if
condition|(
name|sk_ASN1_OBJECT_num
argument_list|(
name|policy_oids
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
name|anyPolicy
operator|=
name|tree
operator|->
name|levels
index|[
name|tree
operator|->
name|nlevel
operator|-
literal|1
index|]
operator|.
name|anyPolicy
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_ASN1_OBJECT_num
argument_list|(
name|policy_oids
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|oid
operator|=
name|sk_ASN1_OBJECT_value
argument_list|(
name|policy_oids
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|OBJ_obj2nid
argument_list|(
name|oid
argument_list|)
operator|==
name|NID_any_policy
condition|)
block|{
name|tree
operator|->
name|flags
operator||=
name|POLICY_FLAG_ANY_POLICY
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_ASN1_OBJECT_num
argument_list|(
name|policy_oids
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|oid
operator|=
name|sk_ASN1_OBJECT_value
argument_list|(
name|policy_oids
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|node
operator|=
name|tree_find_sk
argument_list|(
name|auth_nodes
argument_list|,
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
if|if
condition|(
operator|!
name|anyPolicy
condition|)
continue|continue;
comment|/* Create a new node with policy ID from user set 			 * and qualifiers from anyPolicy. 			 */
name|extra
operator|=
name|policy_data_new
argument_list|(
name|NULL
argument_list|,
name|oid
argument_list|,
name|node_critical
argument_list|(
name|anyPolicy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extra
condition|)
return|return
literal|0
return|;
name|extra
operator|->
name|qualifier_set
operator|=
name|anyPolicy
operator|->
name|data
operator|->
name|qualifier_set
expr_stmt|;
name|extra
operator|->
name|flags
operator|=
name|POLICY_DATA_FLAG_SHARED_QUALIFIERS
operator||
name|POLICY_DATA_FLAG_EXTRA_NODE
expr_stmt|;
name|node
operator|=
name|level_add_node
argument_list|(
name|NULL
argument_list|,
name|extra
argument_list|,
name|anyPolicy
operator|->
name|parent
argument_list|,
name|tree
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tree
operator|->
name|user_policies
condition|)
block|{
name|tree
operator|->
name|user_policies
operator|=
name|sk_X509_POLICY_NODE_new_null
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|tree
operator|->
name|user_policies
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|sk_X509_POLICY_NODE_push
argument_list|(
name|tree
operator|->
name|user_policies
argument_list|,
name|node
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|tree_evaluate
parameter_list|(
name|X509_POLICY_TREE
modifier|*
name|tree
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|X509_POLICY_LEVEL
modifier|*
name|curr
init|=
name|tree
operator|->
name|levels
operator|+
literal|1
decl_stmt|;
specifier|const
name|X509_POLICY_CACHE
modifier|*
name|cache
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|tree
operator|->
name|nlevel
condition|;
name|i
operator|++
operator|,
name|curr
operator|++
control|)
block|{
name|cache
operator|=
name|policy_cache_set
argument_list|(
name|curr
operator|->
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree_link_nodes
argument_list|(
name|curr
argument_list|,
name|cache
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|curr
operator|->
name|flags
operator|&
name|X509_V_FLAG_INHIBIT_ANY
operator|)
operator|&&
operator|!
name|tree_link_any
argument_list|(
name|curr
argument_list|,
name|cache
argument_list|,
name|tree
argument_list|)
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|tree_prune
argument_list|(
name|tree
argument_list|,
name|curr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
return|return
name|ret
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|exnode_free
parameter_list|(
name|X509_POLICY_NODE
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|data
operator|&&
operator|(
name|node
operator|->
name|data
operator|->
name|flags
operator|&
name|POLICY_DATA_FLAG_EXTRA_NODE
operator|)
condition|)
name|OPENSSL_free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|X509_policy_tree_free
parameter_list|(
name|X509_POLICY_TREE
modifier|*
name|tree
parameter_list|)
block|{
name|X509_POLICY_LEVEL
modifier|*
name|curr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|tree
condition|)
return|return;
name|sk_X509_POLICY_NODE_free
argument_list|(
name|tree
operator|->
name|auth_policies
argument_list|)
expr_stmt|;
name|sk_X509_POLICY_NODE_pop_free
argument_list|(
name|tree
operator|->
name|user_policies
argument_list|,
name|exnode_free
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|curr
operator|=
name|tree
operator|->
name|levels
init|;
name|i
operator|<
name|tree
operator|->
name|nlevel
condition|;
name|i
operator|++
operator|,
name|curr
operator|++
control|)
block|{
if|if
condition|(
name|curr
operator|->
name|cert
condition|)
name|X509_free
argument_list|(
name|curr
operator|->
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|nodes
condition|)
name|sk_X509_POLICY_NODE_pop_free
argument_list|(
name|curr
operator|->
name|nodes
argument_list|,
name|policy_node_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|anyPolicy
condition|)
name|policy_node_free
argument_list|(
name|curr
operator|->
name|anyPolicy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tree
operator|->
name|extra_data
condition|)
name|sk_X509_POLICY_DATA_pop_free
argument_list|(
name|tree
operator|->
name|extra_data
argument_list|,
name|policy_data_free
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|tree
operator|->
name|levels
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Application policy checking function.  * Return codes:  *  0 	Internal Error.  *  1   Successful.  * -1   One or more certificates contain invalid or inconsistent extensions  * -2	User constrained policy set empty and requireExplicit true.  */
end_comment

begin_decl_stmt
name|int
name|X509_policy_check
argument_list|(
name|X509_POLICY_TREE
operator|*
operator|*
name|ptree
argument_list|,
name|int
operator|*
name|pexplicit_policy
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|certs
argument_list|,
name|STACK_OF
argument_list|(
name|ASN1_OBJECT
argument_list|)
operator|*
name|policy_oids
argument_list|,
name|unsigned
name|int
name|flags
argument_list|)
block|{
name|int
name|ret
decl_stmt|;
name|X509_POLICY_TREE
modifier|*
name|tree
init|=
name|NULL
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509_POLICY_NODE
argument_list|)
operator|*
name|nodes
operator|,
operator|*
name|auth_nodes
operator|=
name|NULL
expr_stmt|;
operator|*
name|ptree
operator|=
name|NULL
expr_stmt|;
operator|*
name|pexplicit_policy
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|tree_init
argument_list|(
operator|&
name|tree
argument_list|,
name|certs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
comment|/* Tree empty requireExplicit False: OK */
case|case
literal|2
case|:
return|return
literal|1
return|;
comment|/* Some internal error */
case|case
literal|0
case|:
return|return
literal|0
return|;
comment|/* Tree empty requireExplicit True: Error */
case|case
literal|6
case|:
operator|*
name|pexplicit_policy
operator|=
literal|1
expr_stmt|;
return|return
operator|-
literal|2
return|;
comment|/* Tree OK requireExplicit True: OK and continue */
case|case
literal|5
case|:
operator|*
name|pexplicit_policy
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Tree OK: continue */
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|tree
condition|)
comment|/* 			 * tree_init() returns success and a null tree 			 * if it's just looking at a trust anchor. 			 * I'm not sure that returning success here is 			 * correct, but I'm sure that reporting this 			 * as an internal error which our caller 			 * interprets as a malloc failure is wrong. 			 */
return|return
literal|1
return|;
break|break;
block|}
if|if
condition|(
operator|!
name|tree
condition|)
goto|goto
name|error
goto|;
name|ret
operator|=
name|tree_evaluate
argument_list|(
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* Return value 2 means tree empty */
if|if
condition|(
name|ret
operator|==
literal|2
condition|)
block|{
name|X509_policy_tree_free
argument_list|(
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pexplicit_policy
condition|)
return|return
operator|-
literal|2
return|;
else|else
return|return
literal|1
return|;
block|}
comment|/* Tree is not empty: continue */
name|ret
operator|=
name|tree_calculate_authority_set
argument_list|(
name|tree
argument_list|,
operator|&
name|auth_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|tree_calculate_user_set
argument_list|(
name|tree
argument_list|,
name|policy_oids
argument_list|,
name|auth_nodes
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|ret
operator|==
literal|2
condition|)
name|sk_X509_POLICY_NODE_free
argument_list|(
name|auth_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
condition|)
operator|*
name|ptree
operator|=
name|tree
expr_stmt|;
if|if
condition|(
operator|*
name|pexplicit_policy
condition|)
block|{
name|nodes
operator|=
name|X509_policy_tree_get0_user_policies
argument_list|(
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|sk_X509_POLICY_NODE_num
argument_list|(
name|nodes
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|-
literal|2
return|;
block|}
return|return
literal|1
return|;
name|error
label|:
name|X509_policy_tree_free
argument_list|(
name|tree
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

end_unit

