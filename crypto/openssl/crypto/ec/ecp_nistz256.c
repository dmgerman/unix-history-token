begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *                                                                            *  * Copyright 2014 Intel Corporation                                           *  *                                                                            *  * Licensed under the Apache License, Version 2.0 (the "License");            *  * you may not use this file except in compliance with the License.           *  * You may obtain a copy of the License at                                    *  *                                                                            *  *    http://www.apache.org/licenses/LICENSE-2.0                              *  *                                                                            *  * Unless required by applicable law or agreed to in writing, software        *  * distributed under the License is distributed on an "AS IS" BASIS,          *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *  * See the License for the specific language governing permissions and        *  * limitations under the License.                                             *  *                                                                            *  ******************************************************************************  *                                                                            *  * Developers and authors:                                                    *  * Shay Gueron (1, 2), and Vlad Krasnov (1)                                   *  * (1) Intel Corporation, Israel Development Center                           *  * (2) University of Haifa                                                    *  * Reference:                                                                 *  * S.Gueron and V.Krasnov, "Fast Prime Field Elliptic Curve Cryptography with *  *                          256 Bit Primes"                                   *  *                                                                            *  ******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ec.h>
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|"ec_lcl.h"
end_include

begin_if
if|#
directive|if
name|BN_BITS2
operator|!=
literal|64
end_if

begin_define
define|#
directive|define
name|TOBN
parameter_list|(
name|hi
parameter_list|,
name|lo
parameter_list|)
value|lo,hi
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TOBN
parameter_list|(
name|hi
parameter_list|,
name|lo
parameter_list|)
value|((BN_ULONG)hi<<32|lo)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|ALIGN32
value|__attribute((aligned(32)))
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_elif

begin_define
define|#
directive|define
name|ALIGN32
value|__declspec(align(32))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ALIGN32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ALIGNPTR
parameter_list|(
name|p
parameter_list|,
name|N
parameter_list|)
value|((unsigned char *)p+N-(size_t)p%N)
end_define

begin_define
define|#
directive|define
name|P256_LIMBS
value|(256/BN_BITS2)
end_define

begin_typedef
typedef|typedef
name|unsigned
name|short
name|u16
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|BN_ULONG
name|X
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|Y
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|Z
index|[
name|P256_LIMBS
index|]
decl_stmt|;
block|}
name|P256_POINT
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|BN_ULONG
name|X
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|Y
index|[
name|P256_LIMBS
index|]
decl_stmt|;
block|}
name|P256_POINT_AFFINE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|P256_POINT_AFFINE
name|PRECOMP256_ROW
index|[
literal|64
index|]
typedef|;
end_typedef

begin_comment
comment|/* structure for precomputed multiples of the generator */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ec_pre_comp_st
block|{
specifier|const
name|EC_GROUP
modifier|*
name|group
decl_stmt|;
comment|/* Parent EC_GROUP object */
name|size_t
name|w
decl_stmt|;
comment|/* Window size */
comment|/*      * Constant time access to the X and Y coordinates of the pre-computed,      * generator multiplies, in the Montgomery domain. Pre-calculated      * multiplies are stored in affine form.      */
name|PRECOMP256_ROW
modifier|*
name|precomp
decl_stmt|;
name|void
modifier|*
name|precomp_storage
decl_stmt|;
name|int
name|references
decl_stmt|;
block|}
name|EC_PRE_COMP
typedef|;
end_typedef

begin_comment
comment|/* Functions implemented in assembly */
end_comment

begin_comment
comment|/*  * Most of below mentioned functions *preserve* the property of inputs  * being fully reduced, i.e. being in [0, modulus) range. Simply put if  * inputs are fully reduced, then output is too. Note that reverse is  * not true, in sense that given partially reduced inputs output can be  * either, not unlikely reduced. And "most" in first sentence refers to  * the fact that given the calculations flow one can tolerate that  * addition, 1st function below, produces partially reduced result *if*  * multiplications by 2 and 3, which customarily use addition, fully  * reduce it. This effectively gives two options: a) addition produces  * fully reduced result [as long as inputs are, just like remaining  * functions]; b) addition is allowed to produce partially reduced  * result, but multiplications by 2 and 3 perform additional reduction  * step. Choice between the two can be platform-specific, but it was a)  * in all cases so far...  */
end_comment

begin_comment
comment|/* Modular add: res = a+b mod P   */
end_comment

begin_function_decl
name|void
name|ecp_nistz256_add
parameter_list|(
name|BN_ULONG
name|res
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|a
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|b
index|[
name|P256_LIMBS
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Modular mul by 2: res = 2*a mod P */
end_comment

begin_function_decl
name|void
name|ecp_nistz256_mul_by_2
parameter_list|(
name|BN_ULONG
name|res
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|a
index|[
name|P256_LIMBS
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Modular mul by 3: res = 3*a mod P */
end_comment

begin_function_decl
name|void
name|ecp_nistz256_mul_by_3
parameter_list|(
name|BN_ULONG
name|res
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|a
index|[
name|P256_LIMBS
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Modular div by 2: res = a/2 mod P */
end_comment

begin_function_decl
name|void
name|ecp_nistz256_div_by_2
parameter_list|(
name|BN_ULONG
name|res
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|a
index|[
name|P256_LIMBS
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Modular sub: res = a-b mod P   */
end_comment

begin_function_decl
name|void
name|ecp_nistz256_sub
parameter_list|(
name|BN_ULONG
name|res
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|a
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|b
index|[
name|P256_LIMBS
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Modular neg: res = -a mod P    */
end_comment

begin_function_decl
name|void
name|ecp_nistz256_neg
parameter_list|(
name|BN_ULONG
name|res
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|a
index|[
name|P256_LIMBS
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Montgomery mul: res = a*b*2^-256 mod P */
end_comment

begin_function_decl
name|void
name|ecp_nistz256_mul_mont
parameter_list|(
name|BN_ULONG
name|res
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|a
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|b
index|[
name|P256_LIMBS
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Montgomery sqr: res = a*a*2^-256 mod P */
end_comment

begin_function_decl
name|void
name|ecp_nistz256_sqr_mont
parameter_list|(
name|BN_ULONG
name|res
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|a
index|[
name|P256_LIMBS
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Convert a number from Montgomery domain, by multiplying with 1 */
end_comment

begin_function_decl
name|void
name|ecp_nistz256_from_mont
parameter_list|(
name|BN_ULONG
name|res
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|in
index|[
name|P256_LIMBS
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Convert a number to Montgomery domain, by multiplying with 2^512 mod P*/
end_comment

begin_function_decl
name|void
name|ecp_nistz256_to_mont
parameter_list|(
name|BN_ULONG
name|res
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|in
index|[
name|P256_LIMBS
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions that perform constant time access to the precomputed tables */
end_comment

begin_function_decl
name|void
name|ecp_nistz256_select_w5
parameter_list|(
name|P256_POINT
modifier|*
name|val
parameter_list|,
specifier|const
name|P256_POINT
modifier|*
name|in_t
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ecp_nistz256_select_w7
parameter_list|(
name|P256_POINT_AFFINE
modifier|*
name|val
parameter_list|,
specifier|const
name|P256_POINT_AFFINE
modifier|*
name|in_t
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* One converted into the Montgomery domain */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|BN_ULONG
name|ONE
index|[
name|P256_LIMBS
index|]
init|=
block|{
name|TOBN
argument_list|(
literal|0x00000000
argument_list|,
literal|0x00000001
argument_list|)
block|,
name|TOBN
argument_list|(
literal|0xffffffff
argument_list|,
literal|0x00000000
argument_list|)
block|,
name|TOBN
argument_list|(
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|)
block|,
name|TOBN
argument_list|(
literal|0x00000000
argument_list|,
literal|0xfffffffe
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
modifier|*
name|ecp_nistz256_pre_comp_dup
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ecp_nistz256_pre_comp_free
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ecp_nistz256_pre_comp_clear_free
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|EC_PRE_COMP
modifier|*
name|ecp_nistz256_pre_comp_new
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Precomputed tables for the default generator */
end_comment

begin_include
include|#
directive|include
file|"ecp_nistz256_table.c"
end_include

begin_comment
comment|/* Recode window to a signed digit, see ecp_nistputil.c for details */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|_booth_recode_w5
parameter_list|(
name|unsigned
name|int
name|in
parameter_list|)
block|{
name|unsigned
name|int
name|s
decl_stmt|,
name|d
decl_stmt|;
name|s
operator|=
operator|~
operator|(
operator|(
name|in
operator|>>
literal|5
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|d
operator|=
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|-
name|in
operator|-
literal|1
expr_stmt|;
name|d
operator|=
operator|(
name|d
operator|&
name|s
operator|)
operator||
operator|(
name|in
operator|&
operator|~
name|s
operator|)
expr_stmt|;
name|d
operator|=
operator|(
name|d
operator|>>
literal|1
operator|)
operator|+
operator|(
name|d
operator|&
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|d
operator|<<
literal|1
operator|)
operator|+
operator|(
name|s
operator|&
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|_booth_recode_w7
parameter_list|(
name|unsigned
name|int
name|in
parameter_list|)
block|{
name|unsigned
name|int
name|s
decl_stmt|,
name|d
decl_stmt|;
name|s
operator|=
operator|~
operator|(
operator|(
name|in
operator|>>
literal|7
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|d
operator|=
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|-
name|in
operator|-
literal|1
expr_stmt|;
name|d
operator|=
operator|(
name|d
operator|&
name|s
operator|)
operator||
operator|(
name|in
operator|&
operator|~
name|s
operator|)
expr_stmt|;
name|d
operator|=
operator|(
name|d
operator|>>
literal|1
operator|)
operator|+
operator|(
name|d
operator|&
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|d
operator|<<
literal|1
operator|)
operator|+
operator|(
name|s
operator|&
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_conditional
parameter_list|(
name|BN_ULONG
name|dst
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|src
index|[
name|P256_LIMBS
index|]
parameter_list|,
name|BN_ULONG
name|move
parameter_list|)
block|{
name|BN_ULONG
name|mask1
init|=
operator|-
name|move
decl_stmt|;
name|BN_ULONG
name|mask2
init|=
operator|~
name|mask1
decl_stmt|;
name|dst
index|[
literal|0
index|]
operator|=
operator|(
name|src
index|[
literal|0
index|]
operator|&
name|mask1
operator|)
operator|^
operator|(
name|dst
index|[
literal|0
index|]
operator|&
name|mask2
operator|)
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
operator|(
name|src
index|[
literal|1
index|]
operator|&
name|mask1
operator|)
operator|^
operator|(
name|dst
index|[
literal|1
index|]
operator|&
name|mask2
operator|)
expr_stmt|;
name|dst
index|[
literal|2
index|]
operator|=
operator|(
name|src
index|[
literal|2
index|]
operator|&
name|mask1
operator|)
operator|^
operator|(
name|dst
index|[
literal|2
index|]
operator|&
name|mask2
operator|)
expr_stmt|;
name|dst
index|[
literal|3
index|]
operator|=
operator|(
name|src
index|[
literal|3
index|]
operator|&
name|mask1
operator|)
operator|^
operator|(
name|dst
index|[
literal|3
index|]
operator|&
name|mask2
operator|)
expr_stmt|;
if|if
condition|(
name|P256_LIMBS
operator|==
literal|8
condition|)
block|{
name|dst
index|[
literal|4
index|]
operator|=
operator|(
name|src
index|[
literal|4
index|]
operator|&
name|mask1
operator|)
operator|^
operator|(
name|dst
index|[
literal|4
index|]
operator|&
name|mask2
operator|)
expr_stmt|;
name|dst
index|[
literal|5
index|]
operator|=
operator|(
name|src
index|[
literal|5
index|]
operator|&
name|mask1
operator|)
operator|^
operator|(
name|dst
index|[
literal|5
index|]
operator|&
name|mask2
operator|)
expr_stmt|;
name|dst
index|[
literal|6
index|]
operator|=
operator|(
name|src
index|[
literal|6
index|]
operator|&
name|mask1
operator|)
operator|^
operator|(
name|dst
index|[
literal|6
index|]
operator|&
name|mask2
operator|)
expr_stmt|;
name|dst
index|[
literal|7
index|]
operator|=
operator|(
name|src
index|[
literal|7
index|]
operator|&
name|mask1
operator|)
operator|^
operator|(
name|dst
index|[
literal|7
index|]
operator|&
name|mask2
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|BN_ULONG
name|is_zero
parameter_list|(
name|BN_ULONG
name|in
parameter_list|)
block|{
name|in
operator||=
operator|(
literal|0
operator|-
name|in
operator|)
expr_stmt|;
name|in
operator|=
operator|~
name|in
expr_stmt|;
name|in
operator|&=
name|BN_MASK2
expr_stmt|;
name|in
operator|>>=
name|BN_BITS2
operator|-
literal|1
expr_stmt|;
return|return
name|in
return|;
block|}
end_function

begin_function
specifier|static
name|BN_ULONG
name|is_equal
parameter_list|(
specifier|const
name|BN_ULONG
name|a
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|b
index|[
name|P256_LIMBS
index|]
parameter_list|)
block|{
name|BN_ULONG
name|res
decl_stmt|;
name|res
operator|=
name|a
index|[
literal|0
index|]
operator|^
name|b
index|[
literal|0
index|]
expr_stmt|;
name|res
operator||=
name|a
index|[
literal|1
index|]
operator|^
name|b
index|[
literal|1
index|]
expr_stmt|;
name|res
operator||=
name|a
index|[
literal|2
index|]
operator|^
name|b
index|[
literal|2
index|]
expr_stmt|;
name|res
operator||=
name|a
index|[
literal|3
index|]
operator|^
name|b
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|P256_LIMBS
operator|==
literal|8
condition|)
block|{
name|res
operator||=
name|a
index|[
literal|4
index|]
operator|^
name|b
index|[
literal|4
index|]
expr_stmt|;
name|res
operator||=
name|a
index|[
literal|5
index|]
operator|^
name|b
index|[
literal|5
index|]
expr_stmt|;
name|res
operator||=
name|a
index|[
literal|6
index|]
operator|^
name|b
index|[
literal|6
index|]
expr_stmt|;
name|res
operator||=
name|a
index|[
literal|7
index|]
operator|^
name|b
index|[
literal|7
index|]
expr_stmt|;
block|}
return|return
name|is_zero
argument_list|(
name|res
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|BN_ULONG
name|is_one
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|z
parameter_list|)
block|{
name|BN_ULONG
name|res
init|=
literal|0
decl_stmt|;
name|BN_ULONG
modifier|*
name|a
init|=
name|z
operator|->
name|d
decl_stmt|;
if|if
condition|(
name|z
operator|->
name|top
operator|==
operator|(
name|P256_LIMBS
operator|-
name|P256_LIMBS
operator|/
literal|8
operator|)
condition|)
block|{
name|res
operator|=
name|a
index|[
literal|0
index|]
operator|^
name|ONE
index|[
literal|0
index|]
expr_stmt|;
name|res
operator||=
name|a
index|[
literal|1
index|]
operator|^
name|ONE
index|[
literal|1
index|]
expr_stmt|;
name|res
operator||=
name|a
index|[
literal|2
index|]
operator|^
name|ONE
index|[
literal|2
index|]
expr_stmt|;
name|res
operator||=
name|a
index|[
literal|3
index|]
operator|^
name|ONE
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|P256_LIMBS
operator|==
literal|8
condition|)
block|{
name|res
operator||=
name|a
index|[
literal|4
index|]
operator|^
name|ONE
index|[
literal|4
index|]
expr_stmt|;
name|res
operator||=
name|a
index|[
literal|5
index|]
operator|^
name|ONE
index|[
literal|5
index|]
expr_stmt|;
name|res
operator||=
name|a
index|[
literal|6
index|]
operator|^
name|ONE
index|[
literal|6
index|]
expr_stmt|;
comment|/*              * no check for a[7] (being zero) on 32-bit platforms,              * because value of "one" takes only 7 limbs.              */
block|}
name|res
operator|=
name|is_zero
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecp_nistz256_set_words
parameter_list|(
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|BN_ULONG
name|words
index|[
name|P256_LIMBS
index|]
parameter_list|)
block|{
if|if
condition|(
name|bn_wexpand
argument_list|(
name|a
argument_list|,
name|P256_LIMBS
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_SET_WORDS
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|a
operator|->
name|d
argument_list|,
name|words
argument_list|,
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
operator|*
name|P256_LIMBS
argument_list|)
expr_stmt|;
name|a
operator|->
name|top
operator|=
name|P256_LIMBS
expr_stmt|;
name|bn_correct_top
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ECP_NISTZ256_REFERENCE_IMPLEMENTATION
end_ifndef

begin_function_decl
name|void
name|ecp_nistz256_point_double
parameter_list|(
name|P256_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|P256_POINT
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ecp_nistz256_point_add
parameter_list|(
name|P256_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|P256_POINT
modifier|*
name|a
parameter_list|,
specifier|const
name|P256_POINT
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ecp_nistz256_point_add_affine
parameter_list|(
name|P256_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|P256_POINT
modifier|*
name|a
parameter_list|,
specifier|const
name|P256_POINT_AFFINE
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Point double: r = 2*a */
end_comment

begin_function
specifier|static
name|void
name|ecp_nistz256_point_double
parameter_list|(
name|P256_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|P256_POINT
modifier|*
name|a
parameter_list|)
block|{
name|BN_ULONG
name|S
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|M
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|Zsqr
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|tmp0
index|[
name|P256_LIMBS
index|]
decl_stmt|;
specifier|const
name|BN_ULONG
modifier|*
name|in_x
init|=
name|a
operator|->
name|X
decl_stmt|;
specifier|const
name|BN_ULONG
modifier|*
name|in_y
init|=
name|a
operator|->
name|Y
decl_stmt|;
specifier|const
name|BN_ULONG
modifier|*
name|in_z
init|=
name|a
operator|->
name|Z
decl_stmt|;
name|BN_ULONG
modifier|*
name|res_x
init|=
name|r
operator|->
name|X
decl_stmt|;
name|BN_ULONG
modifier|*
name|res_y
init|=
name|r
operator|->
name|Y
decl_stmt|;
name|BN_ULONG
modifier|*
name|res_z
init|=
name|r
operator|->
name|Z
decl_stmt|;
name|ecp_nistz256_mul_by_2
argument_list|(
name|S
argument_list|,
name|in_y
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|Zsqr
argument_list|,
name|in_z
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|S
argument_list|,
name|S
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|res_z
argument_list|,
name|in_z
argument_list|,
name|in_y
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_by_2
argument_list|(
name|res_z
argument_list|,
name|res_z
argument_list|)
expr_stmt|;
name|ecp_nistz256_add
argument_list|(
name|M
argument_list|,
name|in_x
argument_list|,
name|Zsqr
argument_list|)
expr_stmt|;
name|ecp_nistz256_sub
argument_list|(
name|Zsqr
argument_list|,
name|in_x
argument_list|,
name|Zsqr
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|res_y
argument_list|,
name|S
argument_list|)
expr_stmt|;
name|ecp_nistz256_div_by_2
argument_list|(
name|res_y
argument_list|,
name|res_y
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|M
argument_list|,
name|M
argument_list|,
name|Zsqr
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_by_3
argument_list|(
name|M
argument_list|,
name|M
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|S
argument_list|,
name|S
argument_list|,
name|in_x
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_by_2
argument_list|(
name|tmp0
argument_list|,
name|S
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|res_x
argument_list|,
name|M
argument_list|)
expr_stmt|;
name|ecp_nistz256_sub
argument_list|(
name|res_x
argument_list|,
name|res_x
argument_list|,
name|tmp0
argument_list|)
expr_stmt|;
name|ecp_nistz256_sub
argument_list|(
name|S
argument_list|,
name|S
argument_list|,
name|res_x
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|S
argument_list|,
name|S
argument_list|,
name|M
argument_list|)
expr_stmt|;
name|ecp_nistz256_sub
argument_list|(
name|res_y
argument_list|,
name|S
argument_list|,
name|res_y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Point addition: r = a+b */
end_comment

begin_function
specifier|static
name|void
name|ecp_nistz256_point_add
parameter_list|(
name|P256_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|P256_POINT
modifier|*
name|a
parameter_list|,
specifier|const
name|P256_POINT
modifier|*
name|b
parameter_list|)
block|{
name|BN_ULONG
name|U2
index|[
name|P256_LIMBS
index|]
decl_stmt|,
name|S2
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|U1
index|[
name|P256_LIMBS
index|]
decl_stmt|,
name|S1
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|Z1sqr
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|Z2sqr
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|H
index|[
name|P256_LIMBS
index|]
decl_stmt|,
name|R
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|Hsqr
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|Rsqr
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|Hcub
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|res_x
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|res_y
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|res_z
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|in1infty
decl_stmt|,
name|in2infty
decl_stmt|;
specifier|const
name|BN_ULONG
modifier|*
name|in1_x
init|=
name|a
operator|->
name|X
decl_stmt|;
specifier|const
name|BN_ULONG
modifier|*
name|in1_y
init|=
name|a
operator|->
name|Y
decl_stmt|;
specifier|const
name|BN_ULONG
modifier|*
name|in1_z
init|=
name|a
operator|->
name|Z
decl_stmt|;
specifier|const
name|BN_ULONG
modifier|*
name|in2_x
init|=
name|b
operator|->
name|X
decl_stmt|;
specifier|const
name|BN_ULONG
modifier|*
name|in2_y
init|=
name|b
operator|->
name|Y
decl_stmt|;
specifier|const
name|BN_ULONG
modifier|*
name|in2_z
init|=
name|b
operator|->
name|Z
decl_stmt|;
comment|/*      * Infinity in encoded as (,,0)      */
name|in1infty
operator|=
operator|(
name|in1_z
index|[
literal|0
index|]
operator||
name|in1_z
index|[
literal|1
index|]
operator||
name|in1_z
index|[
literal|2
index|]
operator||
name|in1_z
index|[
literal|3
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|P256_LIMBS
operator|==
literal|8
condition|)
name|in1infty
operator||=
operator|(
name|in1_z
index|[
literal|4
index|]
operator||
name|in1_z
index|[
literal|5
index|]
operator||
name|in1_z
index|[
literal|6
index|]
operator||
name|in1_z
index|[
literal|7
index|]
operator|)
expr_stmt|;
name|in2infty
operator|=
operator|(
name|in2_z
index|[
literal|0
index|]
operator||
name|in2_z
index|[
literal|1
index|]
operator||
name|in2_z
index|[
literal|2
index|]
operator||
name|in2_z
index|[
literal|3
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|P256_LIMBS
operator|==
literal|8
condition|)
name|in2infty
operator||=
operator|(
name|in2_z
index|[
literal|4
index|]
operator||
name|in2_z
index|[
literal|5
index|]
operator||
name|in2_z
index|[
literal|6
index|]
operator||
name|in2_z
index|[
literal|7
index|]
operator|)
expr_stmt|;
name|in1infty
operator|=
name|is_zero
argument_list|(
name|in1infty
argument_list|)
expr_stmt|;
name|in2infty
operator|=
name|is_zero
argument_list|(
name|in2infty
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|Z2sqr
argument_list|,
name|in2_z
argument_list|)
expr_stmt|;
comment|/* Z2^2 */
name|ecp_nistz256_sqr_mont
argument_list|(
name|Z1sqr
argument_list|,
name|in1_z
argument_list|)
expr_stmt|;
comment|/* Z1^2 */
name|ecp_nistz256_mul_mont
argument_list|(
name|S1
argument_list|,
name|Z2sqr
argument_list|,
name|in2_z
argument_list|)
expr_stmt|;
comment|/* S1 = Z2^3 */
name|ecp_nistz256_mul_mont
argument_list|(
name|S2
argument_list|,
name|Z1sqr
argument_list|,
name|in1_z
argument_list|)
expr_stmt|;
comment|/* S2 = Z1^3 */
name|ecp_nistz256_mul_mont
argument_list|(
name|S1
argument_list|,
name|S1
argument_list|,
name|in1_y
argument_list|)
expr_stmt|;
comment|/* S1 = Y1*Z2^3 */
name|ecp_nistz256_mul_mont
argument_list|(
name|S2
argument_list|,
name|S2
argument_list|,
name|in2_y
argument_list|)
expr_stmt|;
comment|/* S2 = Y2*Z1^3 */
name|ecp_nistz256_sub
argument_list|(
name|R
argument_list|,
name|S2
argument_list|,
name|S1
argument_list|)
expr_stmt|;
comment|/* R = S2 - S1 */
name|ecp_nistz256_mul_mont
argument_list|(
name|U1
argument_list|,
name|in1_x
argument_list|,
name|Z2sqr
argument_list|)
expr_stmt|;
comment|/* U1 = X1*Z2^2 */
name|ecp_nistz256_mul_mont
argument_list|(
name|U2
argument_list|,
name|in2_x
argument_list|,
name|Z1sqr
argument_list|)
expr_stmt|;
comment|/* U2 = X2*Z1^2 */
name|ecp_nistz256_sub
argument_list|(
name|H
argument_list|,
name|U2
argument_list|,
name|U1
argument_list|)
expr_stmt|;
comment|/* H = U2 - U1 */
comment|/*      * This should not happen during sign/ecdh, so no constant time violation      */
if|if
condition|(
name|is_equal
argument_list|(
name|U1
argument_list|,
name|U2
argument_list|)
operator|&&
operator|!
name|in1infty
operator|&&
operator|!
name|in2infty
condition|)
block|{
if|if
condition|(
name|is_equal
argument_list|(
name|S1
argument_list|,
name|S2
argument_list|)
condition|)
block|{
name|ecp_nistz256_point_double
argument_list|(
name|r
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ecp_nistz256_sqr_mont
argument_list|(
name|Rsqr
argument_list|,
name|R
argument_list|)
expr_stmt|;
comment|/* R^2 */
name|ecp_nistz256_mul_mont
argument_list|(
name|res_z
argument_list|,
name|H
argument_list|,
name|in1_z
argument_list|)
expr_stmt|;
comment|/* Z3 = H*Z1*Z2 */
name|ecp_nistz256_sqr_mont
argument_list|(
name|Hsqr
argument_list|,
name|H
argument_list|)
expr_stmt|;
comment|/* H^2 */
name|ecp_nistz256_mul_mont
argument_list|(
name|res_z
argument_list|,
name|res_z
argument_list|,
name|in2_z
argument_list|)
expr_stmt|;
comment|/* Z3 = H*Z1*Z2 */
name|ecp_nistz256_mul_mont
argument_list|(
name|Hcub
argument_list|,
name|Hsqr
argument_list|,
name|H
argument_list|)
expr_stmt|;
comment|/* H^3 */
name|ecp_nistz256_mul_mont
argument_list|(
name|U2
argument_list|,
name|U1
argument_list|,
name|Hsqr
argument_list|)
expr_stmt|;
comment|/* U1*H^2 */
name|ecp_nistz256_mul_by_2
argument_list|(
name|Hsqr
argument_list|,
name|U2
argument_list|)
expr_stmt|;
comment|/* 2*U1*H^2 */
name|ecp_nistz256_sub
argument_list|(
name|res_x
argument_list|,
name|Rsqr
argument_list|,
name|Hsqr
argument_list|)
expr_stmt|;
name|ecp_nistz256_sub
argument_list|(
name|res_x
argument_list|,
name|res_x
argument_list|,
name|Hcub
argument_list|)
expr_stmt|;
name|ecp_nistz256_sub
argument_list|(
name|res_y
argument_list|,
name|U2
argument_list|,
name|res_x
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|S2
argument_list|,
name|S1
argument_list|,
name|Hcub
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|res_y
argument_list|,
name|R
argument_list|,
name|res_y
argument_list|)
expr_stmt|;
name|ecp_nistz256_sub
argument_list|(
name|res_y
argument_list|,
name|res_y
argument_list|,
name|S2
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|res_x
argument_list|,
name|in2_x
argument_list|,
name|in1infty
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|res_y
argument_list|,
name|in2_y
argument_list|,
name|in1infty
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|res_z
argument_list|,
name|in2_z
argument_list|,
name|in1infty
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|res_x
argument_list|,
name|in1_x
argument_list|,
name|in2infty
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|res_y
argument_list|,
name|in1_y
argument_list|,
name|in2infty
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|res_z
argument_list|,
name|in1_z
argument_list|,
name|in2infty
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
operator|->
name|X
argument_list|,
name|res_x
argument_list|,
sizeof|sizeof
argument_list|(
name|res_x
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
operator|->
name|Y
argument_list|,
name|res_y
argument_list|,
sizeof|sizeof
argument_list|(
name|res_y
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
operator|->
name|Z
argument_list|,
name|res_z
argument_list|,
sizeof|sizeof
argument_list|(
name|res_z
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Point addition when b is known to be affine: r = a+b */
end_comment

begin_function
specifier|static
name|void
name|ecp_nistz256_point_add_affine
parameter_list|(
name|P256_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|P256_POINT
modifier|*
name|a
parameter_list|,
specifier|const
name|P256_POINT_AFFINE
modifier|*
name|b
parameter_list|)
block|{
name|BN_ULONG
name|U2
index|[
name|P256_LIMBS
index|]
decl_stmt|,
name|S2
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|Z1sqr
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|H
index|[
name|P256_LIMBS
index|]
decl_stmt|,
name|R
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|Hsqr
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|Rsqr
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|Hcub
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|res_x
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|res_y
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|res_z
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|in1infty
decl_stmt|,
name|in2infty
decl_stmt|;
specifier|const
name|BN_ULONG
modifier|*
name|in1_x
init|=
name|a
operator|->
name|X
decl_stmt|;
specifier|const
name|BN_ULONG
modifier|*
name|in1_y
init|=
name|a
operator|->
name|Y
decl_stmt|;
specifier|const
name|BN_ULONG
modifier|*
name|in1_z
init|=
name|a
operator|->
name|Z
decl_stmt|;
specifier|const
name|BN_ULONG
modifier|*
name|in2_x
init|=
name|b
operator|->
name|X
decl_stmt|;
specifier|const
name|BN_ULONG
modifier|*
name|in2_y
init|=
name|b
operator|->
name|Y
decl_stmt|;
comment|/*      * Infinity in encoded as (,,0)      */
name|in1infty
operator|=
operator|(
name|in1_z
index|[
literal|0
index|]
operator||
name|in1_z
index|[
literal|1
index|]
operator||
name|in1_z
index|[
literal|2
index|]
operator||
name|in1_z
index|[
literal|3
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|P256_LIMBS
operator|==
literal|8
condition|)
name|in1infty
operator||=
operator|(
name|in1_z
index|[
literal|4
index|]
operator||
name|in1_z
index|[
literal|5
index|]
operator||
name|in1_z
index|[
literal|6
index|]
operator||
name|in1_z
index|[
literal|7
index|]
operator|)
expr_stmt|;
comment|/*      * In affine representation we encode infinity as (0,0), which is      * not on the curve, so it is OK      */
name|in2infty
operator|=
operator|(
name|in2_x
index|[
literal|0
index|]
operator||
name|in2_x
index|[
literal|1
index|]
operator||
name|in2_x
index|[
literal|2
index|]
operator||
name|in2_x
index|[
literal|3
index|]
operator||
name|in2_y
index|[
literal|0
index|]
operator||
name|in2_y
index|[
literal|1
index|]
operator||
name|in2_y
index|[
literal|2
index|]
operator||
name|in2_y
index|[
literal|3
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|P256_LIMBS
operator|==
literal|8
condition|)
name|in2infty
operator||=
operator|(
name|in2_x
index|[
literal|4
index|]
operator||
name|in2_x
index|[
literal|5
index|]
operator||
name|in2_x
index|[
literal|6
index|]
operator||
name|in2_x
index|[
literal|7
index|]
operator||
name|in2_y
index|[
literal|4
index|]
operator||
name|in2_y
index|[
literal|5
index|]
operator||
name|in2_y
index|[
literal|6
index|]
operator||
name|in2_y
index|[
literal|7
index|]
operator|)
expr_stmt|;
name|in1infty
operator|=
name|is_zero
argument_list|(
name|in1infty
argument_list|)
expr_stmt|;
name|in2infty
operator|=
name|is_zero
argument_list|(
name|in2infty
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|Z1sqr
argument_list|,
name|in1_z
argument_list|)
expr_stmt|;
comment|/* Z1^2 */
name|ecp_nistz256_mul_mont
argument_list|(
name|U2
argument_list|,
name|in2_x
argument_list|,
name|Z1sqr
argument_list|)
expr_stmt|;
comment|/* U2 = X2*Z1^2 */
name|ecp_nistz256_sub
argument_list|(
name|H
argument_list|,
name|U2
argument_list|,
name|in1_x
argument_list|)
expr_stmt|;
comment|/* H = U2 - U1 */
name|ecp_nistz256_mul_mont
argument_list|(
name|S2
argument_list|,
name|Z1sqr
argument_list|,
name|in1_z
argument_list|)
expr_stmt|;
comment|/* S2 = Z1^3 */
name|ecp_nistz256_mul_mont
argument_list|(
name|res_z
argument_list|,
name|H
argument_list|,
name|in1_z
argument_list|)
expr_stmt|;
comment|/* Z3 = H*Z1*Z2 */
name|ecp_nistz256_mul_mont
argument_list|(
name|S2
argument_list|,
name|S2
argument_list|,
name|in2_y
argument_list|)
expr_stmt|;
comment|/* S2 = Y2*Z1^3 */
name|ecp_nistz256_sub
argument_list|(
name|R
argument_list|,
name|S2
argument_list|,
name|in1_y
argument_list|)
expr_stmt|;
comment|/* R = S2 - S1 */
name|ecp_nistz256_sqr_mont
argument_list|(
name|Hsqr
argument_list|,
name|H
argument_list|)
expr_stmt|;
comment|/* H^2 */
name|ecp_nistz256_sqr_mont
argument_list|(
name|Rsqr
argument_list|,
name|R
argument_list|)
expr_stmt|;
comment|/* R^2 */
name|ecp_nistz256_mul_mont
argument_list|(
name|Hcub
argument_list|,
name|Hsqr
argument_list|,
name|H
argument_list|)
expr_stmt|;
comment|/* H^3 */
name|ecp_nistz256_mul_mont
argument_list|(
name|U2
argument_list|,
name|in1_x
argument_list|,
name|Hsqr
argument_list|)
expr_stmt|;
comment|/* U1*H^2 */
name|ecp_nistz256_mul_by_2
argument_list|(
name|Hsqr
argument_list|,
name|U2
argument_list|)
expr_stmt|;
comment|/* 2*U1*H^2 */
name|ecp_nistz256_sub
argument_list|(
name|res_x
argument_list|,
name|Rsqr
argument_list|,
name|Hsqr
argument_list|)
expr_stmt|;
name|ecp_nistz256_sub
argument_list|(
name|res_x
argument_list|,
name|res_x
argument_list|,
name|Hcub
argument_list|)
expr_stmt|;
name|ecp_nistz256_sub
argument_list|(
name|H
argument_list|,
name|U2
argument_list|,
name|res_x
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|S2
argument_list|,
name|in1_y
argument_list|,
name|Hcub
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|H
argument_list|,
name|H
argument_list|,
name|R
argument_list|)
expr_stmt|;
name|ecp_nistz256_sub
argument_list|(
name|res_y
argument_list|,
name|H
argument_list|,
name|S2
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|res_x
argument_list|,
name|in2_x
argument_list|,
name|in1infty
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|res_x
argument_list|,
name|in1_x
argument_list|,
name|in2infty
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|res_y
argument_list|,
name|in2_y
argument_list|,
name|in1infty
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|res_y
argument_list|,
name|in1_y
argument_list|,
name|in2infty
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|res_z
argument_list|,
name|ONE
argument_list|,
name|in1infty
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|res_z
argument_list|,
name|in1_z
argument_list|,
name|in2infty
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
operator|->
name|X
argument_list|,
name|res_x
argument_list|,
sizeof|sizeof
argument_list|(
name|res_x
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
operator|->
name|Y
argument_list|,
name|res_y
argument_list|,
sizeof|sizeof
argument_list|(
name|res_y
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
operator|->
name|Z
argument_list|,
name|res_z
argument_list|,
sizeof|sizeof
argument_list|(
name|res_z
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* r = in^-1 mod p */
end_comment

begin_function
specifier|static
name|void
name|ecp_nistz256_mod_inverse
parameter_list|(
name|BN_ULONG
name|r
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BN_ULONG
name|in
index|[
name|P256_LIMBS
index|]
parameter_list|)
block|{
comment|/*      * The poly is ffffffff 00000001 00000000 00000000 00000000 ffffffff      * ffffffff ffffffff We use FLT and used poly-2 as exponent      */
name|BN_ULONG
name|p2
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|p4
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|p8
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|p16
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|p32
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|res
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|p2
argument_list|,
name|res
argument_list|,
name|in
argument_list|)
expr_stmt|;
comment|/* 3*p */
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|p4
argument_list|,
name|res
argument_list|,
name|p2
argument_list|)
expr_stmt|;
comment|/* f*p */
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|p4
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|p8
argument_list|,
name|res
argument_list|,
name|p4
argument_list|)
expr_stmt|;
comment|/* ff*p */
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|p8
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|p16
argument_list|,
name|res
argument_list|,
name|p8
argument_list|)
expr_stmt|;
comment|/* ffff*p */
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|p16
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|p32
argument_list|,
name|res
argument_list|,
name|p16
argument_list|)
expr_stmt|;
comment|/* ffffffff*p */
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|p32
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|,
name|in
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|*
literal|4
condition|;
name|i
operator|++
control|)
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|,
name|p32
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|,
name|p32
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|,
name|p16
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|,
name|p8
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|,
name|p4
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|res
argument_list|,
name|res
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
argument_list|,
name|res
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ecp_nistz256_bignum_to_field_elem copies the contents of |in| to |out| and  * returns one if it fits. Otherwise it returns zero.  */
end_comment

begin_function
specifier|static
name|int
name|ecp_nistz256_bignum_to_field_elem
parameter_list|(
name|BN_ULONG
name|out
index|[
name|P256_LIMBS
index|]
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|in
parameter_list|)
block|{
if|if
condition|(
name|in
operator|->
name|top
operator|>
name|P256_LIMBS
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
operator|*
name|P256_LIMBS
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
operator|*
name|in
operator|->
name|top
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* r = sum(scalar[i]*point[i]) */
end_comment

begin_function
specifier|static
name|int
name|ecp_nistz256_windowed_mul
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|P256_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
modifier|*
name|scalar
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
modifier|*
name|point
parameter_list|,
name|int
name|num
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|unsigned
name|char
argument_list|(
operator|*
name|p_str
argument_list|)
decl|[33]
init|=
name|NULL
decl_stmt|;
specifier|const
name|unsigned
name|int
name|window_size
init|=
literal|5
decl_stmt|;
specifier|const
name|unsigned
name|int
name|mask
init|=
operator|(
literal|1
operator|<<
operator|(
name|window_size
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|wvalue
decl_stmt|;
name|BN_ULONG
name|tmp
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|ALIGN32
name|P256_POINT
name|h
decl_stmt|;
specifier|const
name|BIGNUM
modifier|*
modifier|*
name|scalars
init|=
name|NULL
decl_stmt|;
name|P256_POINT
argument_list|(
operator|*
name|table
argument_list|)
index|[
literal|16
index|]
operator|=
name|NULL
expr_stmt|;
name|void
modifier|*
name|table_storage
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|table_storage
operator|=
name|OPENSSL_malloc
argument_list|(
name|num
operator|*
literal|16
operator|*
sizeof|sizeof
argument_list|(
name|P256_POINT
argument_list|)
operator|+
literal|64
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|p_str
operator|=
name|OPENSSL_malloc
argument_list|(
name|num
operator|*
literal|33
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|scalars
operator|=
name|OPENSSL_malloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
name|BIGNUM
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_WINDOWED_MUL
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|table
operator|=
operator|(
name|void
operator|*
operator|)
name|ALIGNPTR
argument_list|(
name|table_storage
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|P256_POINT
modifier|*
name|row
init|=
name|table
index|[
name|i
index|]
decl_stmt|;
comment|/* This is an unusual input, we don't guarantee constant-timeness. */
if|if
condition|(
operator|(
name|BN_num_bits
argument_list|(
name|scalar
index|[
name|i
index|]
argument_list|)
operator|>
literal|256
operator|)
operator|||
name|BN_is_negative
argument_list|(
name|scalar
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|BIGNUM
modifier|*
name|mod
decl_stmt|;
if|if
condition|(
operator|(
name|mod
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_nnmod
argument_list|(
name|mod
argument_list|,
name|scalar
index|[
name|i
index|]
argument_list|,
operator|&
name|group
operator|->
name|order
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_WINDOWED_MUL
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|scalars
index|[
name|i
index|]
operator|=
name|mod
expr_stmt|;
block|}
else|else
name|scalars
index|[
name|i
index|]
operator|=
name|scalar
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|scalars
index|[
name|i
index|]
operator|->
name|top
operator|*
name|BN_BYTES
condition|;
name|j
operator|+=
name|BN_BYTES
control|)
block|{
name|BN_ULONG
name|d
init|=
name|scalars
index|[
name|i
index|]
operator|->
name|d
index|[
name|j
operator|/
name|BN_BYTES
index|]
decl_stmt|;
name|p_str
index|[
name|i
index|]
index|[
name|j
operator|+
literal|0
index|]
operator|=
name|d
operator|&
literal|0xff
expr_stmt|;
name|p_str
index|[
name|i
index|]
index|[
name|j
operator|+
literal|1
index|]
operator|=
operator|(
name|d
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|p_str
index|[
name|i
index|]
index|[
name|j
operator|+
literal|2
index|]
operator|=
operator|(
name|d
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|p_str
index|[
name|i
index|]
index|[
name|j
operator|+
literal|3
index|]
operator|=
operator|(
name|d
operator|>>=
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|BN_BYTES
operator|==
literal|8
condition|)
block|{
name|d
operator|>>=
literal|8
expr_stmt|;
name|p_str
index|[
name|i
index|]
index|[
name|j
operator|+
literal|4
index|]
operator|=
name|d
operator|&
literal|0xff
expr_stmt|;
name|p_str
index|[
name|i
index|]
index|[
name|j
operator|+
literal|5
index|]
operator|=
operator|(
name|d
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|p_str
index|[
name|i
index|]
index|[
name|j
operator|+
literal|6
index|]
operator|=
operator|(
name|d
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|p_str
index|[
name|i
index|]
index|[
name|j
operator|+
literal|7
index|]
operator|=
operator|(
name|d
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|j
operator|<
literal|33
condition|;
name|j
operator|++
control|)
name|p_str
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
comment|/* table[0] is implicitly (0,0,0) (the point at infinity),          * therefore it is not stored. All other values are actually          * stored with an offset of -1 in table.          */
if|if
condition|(
operator|!
name|ecp_nistz256_bignum_to_field_elem
argument_list|(
name|row
index|[
literal|1
operator|-
literal|1
index|]
operator|.
name|X
argument_list|,
operator|&
name|point
index|[
name|i
index|]
operator|->
name|X
argument_list|)
operator|||
operator|!
name|ecp_nistz256_bignum_to_field_elem
argument_list|(
name|row
index|[
literal|1
operator|-
literal|1
index|]
operator|.
name|Y
argument_list|,
operator|&
name|point
index|[
name|i
index|]
operator|->
name|Y
argument_list|)
operator|||
operator|!
name|ecp_nistz256_bignum_to_field_elem
argument_list|(
name|row
index|[
literal|1
operator|-
literal|1
index|]
operator|.
name|Z
argument_list|,
operator|&
name|point
index|[
name|i
index|]
operator|->
name|Z
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_WINDOWED_MUL
argument_list|,
name|EC_R_COORDINATES_OUT_OF_RANGE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ecp_nistz256_point_double
argument_list|(
operator|&
name|row
index|[
literal|2
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|1
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_add
argument_list|(
operator|&
name|row
index|[
literal|3
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|2
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|1
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_double
argument_list|(
operator|&
name|row
index|[
literal|4
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|2
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_double
argument_list|(
operator|&
name|row
index|[
literal|6
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|3
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_double
argument_list|(
operator|&
name|row
index|[
literal|8
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|4
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_double
argument_list|(
operator|&
name|row
index|[
literal|12
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|6
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_add
argument_list|(
operator|&
name|row
index|[
literal|5
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|4
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|1
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_add
argument_list|(
operator|&
name|row
index|[
literal|7
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|6
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|1
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_add
argument_list|(
operator|&
name|row
index|[
literal|9
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|8
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|1
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_add
argument_list|(
operator|&
name|row
index|[
literal|13
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|12
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|1
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_double
argument_list|(
operator|&
name|row
index|[
literal|14
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|7
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_double
argument_list|(
operator|&
name|row
index|[
literal|10
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|5
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_add
argument_list|(
operator|&
name|row
index|[
literal|15
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|14
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|1
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_add
argument_list|(
operator|&
name|row
index|[
literal|11
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|10
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|1
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_add
argument_list|(
operator|&
name|row
index|[
literal|16
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|15
operator|-
literal|1
index|]
argument_list|,
operator|&
name|row
index|[
literal|1
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|index
operator|=
literal|255
expr_stmt|;
name|wvalue
operator|=
name|p_str
index|[
literal|0
index|]
index|[
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
literal|8
index|]
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|>>
operator|(
operator|(
name|index
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|ecp_nistz256_select_w5
argument_list|(
name|r
argument_list|,
name|table
index|[
literal|0
index|]
argument_list|,
name|_booth_recode_w5
argument_list|(
name|wvalue
argument_list|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|index
operator|>=
literal|5
condition|)
block|{
for|for
control|(
name|i
operator|=
operator|(
name|index
operator|==
literal|255
condition|?
literal|1
else|:
literal|0
operator|)
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|off
init|=
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
literal|8
decl_stmt|;
name|wvalue
operator|=
name|p_str
index|[
name|i
index|]
index|[
name|off
index|]
operator||
name|p_str
index|[
name|i
index|]
index|[
name|off
operator|+
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|>>
operator|(
operator|(
name|index
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|wvalue
operator|=
name|_booth_recode_w5
argument_list|(
name|wvalue
argument_list|)
expr_stmt|;
name|ecp_nistz256_select_w5
argument_list|(
operator|&
name|h
argument_list|,
name|table
index|[
name|i
index|]
argument_list|,
name|wvalue
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|tmp
argument_list|,
name|h
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|h
operator|.
name|Y
argument_list|,
name|tmp
argument_list|,
operator|(
name|wvalue
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_add
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
block|}
name|index
operator|-=
name|window_size
expr_stmt|;
name|ecp_nistz256_point_double
argument_list|(
name|r
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_double
argument_list|(
name|r
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_double
argument_list|(
name|r
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_double
argument_list|(
name|r
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_double
argument_list|(
name|r
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/* Final window */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|wvalue
operator|=
name|p_str
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|<<
literal|1
operator|)
operator|&
name|mask
expr_stmt|;
name|wvalue
operator|=
name|_booth_recode_w5
argument_list|(
name|wvalue
argument_list|)
expr_stmt|;
name|ecp_nistz256_select_w5
argument_list|(
operator|&
name|h
argument_list|,
name|table
index|[
name|i
index|]
argument_list|,
name|wvalue
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|tmp
argument_list|,
name|h
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|h
operator|.
name|Y
argument_list|,
name|tmp
argument_list|,
name|wvalue
operator|&
literal|1
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_add
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|table_storage
condition|)
name|OPENSSL_free
argument_list|(
name|table_storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_str
condition|)
name|OPENSSL_free
argument_list|(
name|p_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|scalars
condition|)
name|OPENSSL_free
argument_list|(
name|scalars
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Coordinates of G, for which we have precomputed tables */
end_comment

begin_decl_stmt
specifier|const
specifier|static
name|BN_ULONG
name|def_xG
index|[
name|P256_LIMBS
index|]
init|=
block|{
name|TOBN
argument_list|(
literal|0x79e730d4
argument_list|,
literal|0x18a9143c
argument_list|)
block|,
name|TOBN
argument_list|(
literal|0x75ba95fc
argument_list|,
literal|0x5fedb601
argument_list|)
block|,
name|TOBN
argument_list|(
literal|0x79fb732b
argument_list|,
literal|0x77622510
argument_list|)
block|,
name|TOBN
argument_list|(
literal|0x18905f76
argument_list|,
literal|0xa53755c6
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
specifier|static
name|BN_ULONG
name|def_yG
index|[
name|P256_LIMBS
index|]
init|=
block|{
name|TOBN
argument_list|(
literal|0xddf25357
argument_list|,
literal|0xce95560a
argument_list|)
block|,
name|TOBN
argument_list|(
literal|0x8b4ab8e4
argument_list|,
literal|0xba19e45c
argument_list|)
block|,
name|TOBN
argument_list|(
literal|0xd2e88688
argument_list|,
literal|0xdd21f325
argument_list|)
block|,
name|TOBN
argument_list|(
literal|0x8571ff18
argument_list|,
literal|0x25885d85
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ecp_nistz256_is_affine_G returns one if |generator| is the standard, P-256  * generator.  */
end_comment

begin_function
specifier|static
name|int
name|ecp_nistz256_is_affine_G
parameter_list|(
specifier|const
name|EC_POINT
modifier|*
name|generator
parameter_list|)
block|{
return|return
operator|(
name|generator
operator|->
name|X
operator|.
name|top
operator|==
name|P256_LIMBS
operator|)
operator|&&
operator|(
name|generator
operator|->
name|Y
operator|.
name|top
operator|==
name|P256_LIMBS
operator|)
operator|&&
name|is_equal
argument_list|(
name|generator
operator|->
name|X
operator|.
name|d
argument_list|,
name|def_xG
argument_list|)
operator|&&
name|is_equal
argument_list|(
name|generator
operator|->
name|Y
operator|.
name|d
argument_list|,
name|def_yG
argument_list|)
operator|&&
name|is_one
argument_list|(
operator|&
name|generator
operator|->
name|Z
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecp_nistz256_mult_precompute
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
comment|/*      * We precompute a table for a Booth encoded exponent (wNAF) based      * computation. Each table holds 64 values for safe access, with an      * implicit value of infinity at index zero. We use window of size 7, and      * therefore require ceil(256/7) = 37 tables.      */
name|BIGNUM
modifier|*
name|order
decl_stmt|;
name|EC_POINT
modifier|*
name|P
init|=
name|NULL
decl_stmt|,
modifier|*
name|T
init|=
name|NULL
decl_stmt|;
specifier|const
name|EC_POINT
modifier|*
name|generator
decl_stmt|;
name|EC_PRE_COMP
modifier|*
name|pre_comp
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|size_t
name|w
decl_stmt|;
name|PRECOMP256_ROW
modifier|*
name|preComputedTable
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|precomp_storage
init|=
name|NULL
decl_stmt|;
comment|/* if there is an old EC_PRE_COMP object, throw it away */
name|EC_EX_DATA_free_data
argument_list|(
operator|&
name|group
operator|->
name|extra_data
argument_list|,
name|ecp_nistz256_pre_comp_dup
argument_list|,
name|ecp_nistz256_pre_comp_free
argument_list|,
name|ecp_nistz256_pre_comp_clear_free
argument_list|)
expr_stmt|;
name|generator
operator|=
name|EC_GROUP_get0_generator
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|generator
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_MULT_PRECOMPUTE
argument_list|,
name|EC_R_UNDEFINED_GENERATOR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ecp_nistz256_is_affine_G
argument_list|(
name|generator
argument_list|)
condition|)
block|{
comment|/*          * No need to calculate tables for the standard generator because we          * have them statically.          */
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|pre_comp
operator|=
name|ecp_nistz256_pre_comp_new
argument_list|(
name|group
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|order
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|EC_GROUP_get_order
argument_list|(
name|group
argument_list|,
name|order
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|BN_is_zero
argument_list|(
name|order
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_MULT_PRECOMPUTE
argument_list|,
name|EC_R_UNKNOWN_ORDER
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|w
operator|=
literal|7
expr_stmt|;
if|if
condition|(
operator|(
name|precomp_storage
operator|=
name|OPENSSL_malloc
argument_list|(
literal|37
operator|*
literal|64
operator|*
sizeof|sizeof
argument_list|(
name|P256_POINT_AFFINE
argument_list|)
operator|+
literal|64
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_MULT_PRECOMPUTE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|preComputedTable
operator|=
operator|(
name|void
operator|*
operator|)
name|ALIGNPTR
argument_list|(
name|precomp_storage
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
name|P
operator|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|T
operator|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|P
operator|==
name|NULL
operator|||
name|T
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/*      * The zero entry is implicitly infinity, and we skip it, storing other      * values with -1 offset.      */
if|if
condition|(
operator|!
name|EC_POINT_copy
argument_list|(
name|T
argument_list|,
name|generator
argument_list|)
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|64
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_copy
argument_list|(
name|P
argument_list|,
name|T
argument_list|)
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|37
condition|;
name|j
operator|++
control|)
block|{
comment|/*              * It would be faster to use EC_POINTs_make_affine and              * make multiple points affine at the same time.              */
if|if
condition|(
operator|!
name|EC_POINT_make_affine
argument_list|(
name|group
argument_list|,
name|P
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|ecp_nistz256_bignum_to_field_elem
argument_list|(
name|preComputedTable
index|[
name|j
index|]
index|[
name|k
index|]
operator|.
name|X
argument_list|,
operator|&
name|P
operator|->
name|X
argument_list|)
operator|||
operator|!
name|ecp_nistz256_bignum_to_field_elem
argument_list|(
name|preComputedTable
index|[
name|j
index|]
index|[
name|k
index|]
operator|.
name|Y
argument_list|,
operator|&
name|P
operator|->
name|Y
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_MULT_PRECOMPUTE
argument_list|,
name|EC_R_COORDINATES_OUT_OF_RANGE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_dbl
argument_list|(
name|group
argument_list|,
name|P
argument_list|,
name|P
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|EC_POINT_add
argument_list|(
name|group
argument_list|,
name|T
argument_list|,
name|T
argument_list|,
name|generator
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
name|pre_comp
operator|->
name|group
operator|=
name|group
expr_stmt|;
name|pre_comp
operator|->
name|w
operator|=
name|w
expr_stmt|;
name|pre_comp
operator|->
name|precomp
operator|=
name|preComputedTable
expr_stmt|;
name|pre_comp
operator|->
name|precomp_storage
operator|=
name|precomp_storage
expr_stmt|;
name|precomp_storage
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|EC_EX_DATA_set_data
argument_list|(
operator|&
name|group
operator|->
name|extra_data
argument_list|,
name|pre_comp
argument_list|,
name|ecp_nistz256_pre_comp_dup
argument_list|,
name|ecp_nistz256_pre_comp_free
argument_list|,
name|ecp_nistz256_pre_comp_clear_free
argument_list|)
condition|)
block|{
goto|goto
name|err
goto|;
block|}
name|pre_comp
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_comp
condition|)
name|ecp_nistz256_pre_comp_free
argument_list|(
name|pre_comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|precomp_storage
condition|)
name|OPENSSL_free
argument_list|(
name|precomp_storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|P
condition|)
name|EC_POINT_free
argument_list|(
name|P
argument_list|)
expr_stmt|;
if|if
condition|(
name|T
condition|)
name|EC_POINT_free
argument_list|(
name|T
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Note that by default ECP_NISTZ256_AVX2 is undefined. While it's great  * code processing 4 points in parallel, corresponding serial operation  * is several times slower, because it uses 29x29=58-bit multiplication  * as opposite to 64x64=128-bit in integer-only scalar case. As result  * it doesn't provide *significant* performance improvement. Note that  * just defining ECP_NISTZ256_AVX2 is not sufficient to make it work,  * you'd need to compile even asm/ecp_nistz256-avx.pl module.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ECP_NISTZ256_AVX2
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|__x86_64
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|)
operator|||
expr|\
name|defined
argument_list|(
name|_M_AMD64
argument_list|)
operator|||
name|defined
argument_list|(
name|_MX64
argument_list|)
if|)
operator|||
if|\
operator|!
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|)
end_if

begin_comment
comment|/* this is for ALIGN32 */
end_comment

begin_undef
undef|#
directive|undef
name|ECP_NISTZ256_AVX2
end_undef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Constant time access, loading four values, from four consecutive tables */
end_comment

begin_function_decl
name|void
name|ecp_nistz256_avx2_select_w7
parameter_list|(
name|P256_POINT_AFFINE
modifier|*
name|val
parameter_list|,
specifier|const
name|P256_POINT_AFFINE
modifier|*
name|in_t
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ecp_nistz256_avx2_multi_select_w7
parameter_list|(
name|void
modifier|*
name|result
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|,
name|int
name|index0
parameter_list|,
name|int
name|index1
parameter_list|,
name|int
name|index2
parameter_list|,
name|int
name|index3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ecp_nistz256_avx2_transpose_convert
parameter_list|(
name|void
modifier|*
name|RESULTx4
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ecp_nistz256_avx2_convert_transpose_back
parameter_list|(
name|void
modifier|*
name|result
parameter_list|,
specifier|const
name|void
modifier|*
name|Ax4
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ecp_nistz256_avx2_point_add_affine_x4
parameter_list|(
name|void
modifier|*
name|RESULTx4
parameter_list|,
specifier|const
name|void
modifier|*
name|Ax4
parameter_list|,
specifier|const
name|void
modifier|*
name|Bx4
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ecp_nistz256_avx2_point_add_affines_x4
parameter_list|(
name|void
modifier|*
name|RESULTx4
parameter_list|,
specifier|const
name|void
modifier|*
name|Ax4
parameter_list|,
specifier|const
name|void
modifier|*
name|Bx4
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ecp_nistz256_avx2_to_mont
parameter_list|(
name|void
modifier|*
name|RESULTx4
parameter_list|,
specifier|const
name|void
modifier|*
name|Ax4
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ecp_nistz256_avx2_from_mont
parameter_list|(
name|void
modifier|*
name|RESULTx4
parameter_list|,
specifier|const
name|void
modifier|*
name|Ax4
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ecp_nistz256_avx2_set1
parameter_list|(
name|void
modifier|*
name|RESULTx4
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ecp_nistz_avx2_eligible
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|booth_recode_w7
parameter_list|(
name|unsigned
name|char
modifier|*
name|sign
parameter_list|,
name|unsigned
name|char
modifier|*
name|digit
parameter_list|,
name|unsigned
name|char
name|in
parameter_list|)
block|{
name|unsigned
name|char
name|s
decl_stmt|,
name|d
decl_stmt|;
name|s
operator|=
operator|~
operator|(
operator|(
name|in
operator|>>
literal|7
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|d
operator|=
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|-
name|in
operator|-
literal|1
expr_stmt|;
name|d
operator|=
operator|(
name|d
operator|&
name|s
operator|)
operator||
operator|(
name|in
operator|&
operator|~
name|s
operator|)
expr_stmt|;
name|d
operator|=
operator|(
name|d
operator|>>
literal|1
operator|)
operator|+
operator|(
name|d
operator|&
literal|1
operator|)
expr_stmt|;
operator|*
name|sign
operator|=
name|s
operator|&
literal|1
expr_stmt|;
operator|*
name|digit
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ecp_nistz256_avx2_mul_g performs multiplication by G, using only the  * precomputed table. It does 4 affine point additions in parallel,  * significantly speeding up point multiplication for a fixed value.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ecp_nistz256_avx2_mul_g
argument_list|(
name|P256_POINT
operator|*
name|r
argument_list|,
name|unsigned
name|char
name|p_str
index|[
literal|33
index|]
argument_list|,
specifier|const
name|P256_POINT_AFFINE
argument_list|(
operator|*
name|preComputedTable
argument_list|)
index|[
literal|64
index|]
argument_list|)
block|{
specifier|const
name|unsigned
name|int
name|window_size
init|=
literal|7
decl_stmt|;
specifier|const
name|unsigned
name|int
name|mask
init|=
operator|(
literal|1
operator|<<
operator|(
name|window_size
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|wvalue
decl_stmt|;
comment|/* Using 4 windows at a time */
name|unsigned
name|char
name|sign0
decl_stmt|,
name|digit0
decl_stmt|;
name|unsigned
name|char
name|sign1
decl_stmt|,
name|digit1
decl_stmt|;
name|unsigned
name|char
name|sign2
decl_stmt|,
name|digit2
decl_stmt|;
name|unsigned
name|char
name|sign3
decl_stmt|,
name|digit3
decl_stmt|;
name|unsigned
name|int
name|index
init|=
literal|0
decl_stmt|;
name|BN_ULONG
name|tmp
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ALIGN32
name|BN_ULONG
name|aX4
index|[
literal|4
operator|*
literal|9
operator|*
literal|3
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ALIGN32
name|BN_ULONG
name|bX4
index|[
literal|4
operator|*
literal|9
operator|*
literal|2
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ALIGN32
name|P256_POINT_AFFINE
name|point_arr
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|ALIGN32
name|P256_POINT
name|res_point_arr
index|[
name|P256_LIMBS
index|]
decl_stmt|;
comment|/* Initial four windows */
name|wvalue
operator|=
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
operator|&
name|p_str
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|<<
literal|1
operator|)
operator|&
name|mask
expr_stmt|;
name|index
operator|+=
name|window_size
expr_stmt|;
name|booth_recode_w7
argument_list|(
operator|&
name|sign0
argument_list|,
operator|&
name|digit0
argument_list|,
name|wvalue
argument_list|)
expr_stmt|;
name|wvalue
operator|=
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
operator|&
name|p_str
index|[
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
literal|8
index|]
operator|)
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|>>
operator|(
operator|(
name|index
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|index
operator|+=
name|window_size
expr_stmt|;
name|booth_recode_w7
argument_list|(
operator|&
name|sign1
argument_list|,
operator|&
name|digit1
argument_list|,
name|wvalue
argument_list|)
expr_stmt|;
name|wvalue
operator|=
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
operator|&
name|p_str
index|[
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
literal|8
index|]
operator|)
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|>>
operator|(
operator|(
name|index
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|index
operator|+=
name|window_size
expr_stmt|;
name|booth_recode_w7
argument_list|(
operator|&
name|sign2
argument_list|,
operator|&
name|digit2
argument_list|,
name|wvalue
argument_list|)
expr_stmt|;
name|wvalue
operator|=
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
operator|&
name|p_str
index|[
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
literal|8
index|]
operator|)
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|>>
operator|(
operator|(
name|index
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|index
operator|+=
name|window_size
expr_stmt|;
name|booth_recode_w7
argument_list|(
operator|&
name|sign3
argument_list|,
operator|&
name|digit3
argument_list|,
name|wvalue
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_multi_select_w7
argument_list|(
name|point_arr
argument_list|,
name|preComputedTable
index|[
literal|0
index|]
argument_list|,
name|digit0
argument_list|,
name|digit1
argument_list|,
name|digit2
argument_list|,
name|digit3
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|tmp
argument_list|,
name|point_arr
index|[
literal|0
index|]
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|point_arr
index|[
literal|0
index|]
operator|.
name|Y
argument_list|,
name|tmp
argument_list|,
name|sign0
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|tmp
argument_list|,
name|point_arr
index|[
literal|1
index|]
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|point_arr
index|[
literal|1
index|]
operator|.
name|Y
argument_list|,
name|tmp
argument_list|,
name|sign1
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|tmp
argument_list|,
name|point_arr
index|[
literal|2
index|]
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|point_arr
index|[
literal|2
index|]
operator|.
name|Y
argument_list|,
name|tmp
argument_list|,
name|sign2
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|tmp
argument_list|,
name|point_arr
index|[
literal|3
index|]
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|point_arr
index|[
literal|3
index|]
operator|.
name|Y
argument_list|,
name|tmp
argument_list|,
name|sign3
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_transpose_convert
argument_list|(
name|aX4
argument_list|,
name|point_arr
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_to_mont
argument_list|(
name|aX4
argument_list|,
name|aX4
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_to_mont
argument_list|(
operator|&
name|aX4
index|[
literal|4
operator|*
literal|9
index|]
argument_list|,
operator|&
name|aX4
index|[
literal|4
operator|*
literal|9
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_set1
argument_list|(
operator|&
name|aX4
index|[
literal|4
operator|*
literal|9
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
name|wvalue
operator|=
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
operator|&
name|p_str
index|[
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
literal|8
index|]
operator|)
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|>>
operator|(
operator|(
name|index
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|index
operator|+=
name|window_size
expr_stmt|;
name|booth_recode_w7
argument_list|(
operator|&
name|sign0
argument_list|,
operator|&
name|digit0
argument_list|,
name|wvalue
argument_list|)
expr_stmt|;
name|wvalue
operator|=
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
operator|&
name|p_str
index|[
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
literal|8
index|]
operator|)
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|>>
operator|(
operator|(
name|index
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|index
operator|+=
name|window_size
expr_stmt|;
name|booth_recode_w7
argument_list|(
operator|&
name|sign1
argument_list|,
operator|&
name|digit1
argument_list|,
name|wvalue
argument_list|)
expr_stmt|;
name|wvalue
operator|=
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
operator|&
name|p_str
index|[
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
literal|8
index|]
operator|)
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|>>
operator|(
operator|(
name|index
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|index
operator|+=
name|window_size
expr_stmt|;
name|booth_recode_w7
argument_list|(
operator|&
name|sign2
argument_list|,
operator|&
name|digit2
argument_list|,
name|wvalue
argument_list|)
expr_stmt|;
name|wvalue
operator|=
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
operator|&
name|p_str
index|[
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
literal|8
index|]
operator|)
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|>>
operator|(
operator|(
name|index
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|index
operator|+=
name|window_size
expr_stmt|;
name|booth_recode_w7
argument_list|(
operator|&
name|sign3
argument_list|,
operator|&
name|digit3
argument_list|,
name|wvalue
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_multi_select_w7
argument_list|(
name|point_arr
argument_list|,
name|preComputedTable
index|[
literal|4
operator|*
literal|1
index|]
argument_list|,
name|digit0
argument_list|,
name|digit1
argument_list|,
name|digit2
argument_list|,
name|digit3
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|tmp
argument_list|,
name|point_arr
index|[
literal|0
index|]
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|point_arr
index|[
literal|0
index|]
operator|.
name|Y
argument_list|,
name|tmp
argument_list|,
name|sign0
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|tmp
argument_list|,
name|point_arr
index|[
literal|1
index|]
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|point_arr
index|[
literal|1
index|]
operator|.
name|Y
argument_list|,
name|tmp
argument_list|,
name|sign1
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|tmp
argument_list|,
name|point_arr
index|[
literal|2
index|]
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|point_arr
index|[
literal|2
index|]
operator|.
name|Y
argument_list|,
name|tmp
argument_list|,
name|sign2
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|tmp
argument_list|,
name|point_arr
index|[
literal|3
index|]
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|point_arr
index|[
literal|3
index|]
operator|.
name|Y
argument_list|,
name|tmp
argument_list|,
name|sign3
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_transpose_convert
argument_list|(
name|bX4
argument_list|,
name|point_arr
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_to_mont
argument_list|(
name|bX4
argument_list|,
name|bX4
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_to_mont
argument_list|(
operator|&
name|bX4
index|[
literal|4
operator|*
literal|9
index|]
argument_list|,
operator|&
name|bX4
index|[
literal|4
operator|*
literal|9
index|]
argument_list|)
expr_stmt|;
comment|/* Optimized when both inputs are affine */
name|ecp_nistz256_avx2_point_add_affines_x4
argument_list|(
name|aX4
argument_list|,
name|aX4
argument_list|,
name|bX4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
name|wvalue
operator|=
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
operator|&
name|p_str
index|[
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
literal|8
index|]
operator|)
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|>>
operator|(
operator|(
name|index
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|index
operator|+=
name|window_size
expr_stmt|;
name|booth_recode_w7
argument_list|(
operator|&
name|sign0
argument_list|,
operator|&
name|digit0
argument_list|,
name|wvalue
argument_list|)
expr_stmt|;
name|wvalue
operator|=
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
operator|&
name|p_str
index|[
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
literal|8
index|]
operator|)
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|>>
operator|(
operator|(
name|index
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|index
operator|+=
name|window_size
expr_stmt|;
name|booth_recode_w7
argument_list|(
operator|&
name|sign1
argument_list|,
operator|&
name|digit1
argument_list|,
name|wvalue
argument_list|)
expr_stmt|;
name|wvalue
operator|=
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
operator|&
name|p_str
index|[
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
literal|8
index|]
operator|)
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|>>
operator|(
operator|(
name|index
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|index
operator|+=
name|window_size
expr_stmt|;
name|booth_recode_w7
argument_list|(
operator|&
name|sign2
argument_list|,
operator|&
name|digit2
argument_list|,
name|wvalue
argument_list|)
expr_stmt|;
name|wvalue
operator|=
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
operator|&
name|p_str
index|[
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
literal|8
index|]
operator|)
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|>>
operator|(
operator|(
name|index
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|index
operator|+=
name|window_size
expr_stmt|;
name|booth_recode_w7
argument_list|(
operator|&
name|sign3
argument_list|,
operator|&
name|digit3
argument_list|,
name|wvalue
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_multi_select_w7
argument_list|(
name|point_arr
argument_list|,
name|preComputedTable
index|[
literal|4
operator|*
name|i
index|]
argument_list|,
name|digit0
argument_list|,
name|digit1
argument_list|,
name|digit2
argument_list|,
name|digit3
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|tmp
argument_list|,
name|point_arr
index|[
literal|0
index|]
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|point_arr
index|[
literal|0
index|]
operator|.
name|Y
argument_list|,
name|tmp
argument_list|,
name|sign0
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|tmp
argument_list|,
name|point_arr
index|[
literal|1
index|]
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|point_arr
index|[
literal|1
index|]
operator|.
name|Y
argument_list|,
name|tmp
argument_list|,
name|sign1
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|tmp
argument_list|,
name|point_arr
index|[
literal|2
index|]
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|point_arr
index|[
literal|2
index|]
operator|.
name|Y
argument_list|,
name|tmp
argument_list|,
name|sign2
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|tmp
argument_list|,
name|point_arr
index|[
literal|3
index|]
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|point_arr
index|[
literal|3
index|]
operator|.
name|Y
argument_list|,
name|tmp
argument_list|,
name|sign3
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_transpose_convert
argument_list|(
name|bX4
argument_list|,
name|point_arr
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_to_mont
argument_list|(
name|bX4
argument_list|,
name|bX4
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_to_mont
argument_list|(
operator|&
name|bX4
index|[
literal|4
operator|*
literal|9
index|]
argument_list|,
operator|&
name|bX4
index|[
literal|4
operator|*
literal|9
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_point_add_affine_x4
argument_list|(
name|aX4
argument_list|,
name|aX4
argument_list|,
name|bX4
argument_list|)
expr_stmt|;
block|}
name|ecp_nistz256_avx2_from_mont
argument_list|(
operator|&
name|aX4
index|[
literal|4
operator|*
literal|9
operator|*
literal|0
index|]
argument_list|,
operator|&
name|aX4
index|[
literal|4
operator|*
literal|9
operator|*
literal|0
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_from_mont
argument_list|(
operator|&
name|aX4
index|[
literal|4
operator|*
literal|9
operator|*
literal|1
index|]
argument_list|,
operator|&
name|aX4
index|[
literal|4
operator|*
literal|9
operator|*
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_from_mont
argument_list|(
operator|&
name|aX4
index|[
literal|4
operator|*
literal|9
operator|*
literal|2
index|]
argument_list|,
operator|&
name|aX4
index|[
literal|4
operator|*
literal|9
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_convert_transpose_back
argument_list|(
name|res_point_arr
argument_list|,
name|aX4
argument_list|)
expr_stmt|;
comment|/* Last window is performed serially */
name|wvalue
operator|=
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
operator|&
name|p_str
index|[
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
literal|8
index|]
operator|)
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|>>
operator|(
operator|(
name|index
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|booth_recode_w7
argument_list|(
operator|&
name|sign0
argument_list|,
operator|&
name|digit0
argument_list|,
name|wvalue
argument_list|)
expr_stmt|;
name|ecp_nistz256_avx2_select_w7
argument_list|(
operator|(
name|P256_POINT_AFFINE
operator|*
operator|)
name|r
argument_list|,
name|preComputedTable
index|[
literal|36
index|]
argument_list|,
name|digit0
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|tmp
argument_list|,
name|r
operator|->
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|r
operator|->
name|Y
argument_list|,
name|tmp
argument_list|,
name|sign0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
operator|->
name|Z
argument_list|,
name|ONE
argument_list|,
sizeof|sizeof
argument_list|(
name|ONE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sum the four windows */
name|ecp_nistz256_point_add
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
operator|&
name|res_point_arr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_add
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
operator|&
name|res_point_arr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_add
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
operator|&
name|res_point_arr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_add
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
operator|&
name|res_point_arr
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ecp_nistz256_set_from_affine
parameter_list|(
name|EC_POINT
modifier|*
name|out
parameter_list|,
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|P256_POINT_AFFINE
modifier|*
name|in
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BIGNUM
name|x
decl_stmt|,
name|y
decl_stmt|;
name|BN_ULONG
name|d_x
index|[
name|P256_LIMBS
index|]
decl_stmt|,
name|d_y
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|memcpy
argument_list|(
name|d_x
argument_list|,
name|in
operator|->
name|X
argument_list|,
sizeof|sizeof
argument_list|(
name|d_x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|d
operator|=
name|d_x
expr_stmt|;
name|x
operator|.
name|dmax
operator|=
name|x
operator|.
name|top
operator|=
name|P256_LIMBS
expr_stmt|;
name|x
operator|.
name|neg
operator|=
literal|0
expr_stmt|;
name|x
operator|.
name|flags
operator|=
name|BN_FLG_STATIC_DATA
expr_stmt|;
name|memcpy
argument_list|(
name|d_y
argument_list|,
name|in
operator|->
name|Y
argument_list|,
sizeof|sizeof
argument_list|(
name|d_y
argument_list|)
argument_list|)
expr_stmt|;
name|y
operator|.
name|d
operator|=
name|d_y
expr_stmt|;
name|y
operator|.
name|dmax
operator|=
name|y
operator|.
name|top
operator|=
name|P256_LIMBS
expr_stmt|;
name|y
operator|.
name|neg
operator|=
literal|0
expr_stmt|;
name|y
operator|.
name|flags
operator|=
name|BN_FLG_STATIC_DATA
expr_stmt|;
name|ret
operator|=
name|EC_POINT_set_affine_coordinates_GFp
argument_list|(
name|group
argument_list|,
name|out
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* r = scalar*G + sum(scalars[i]*points[i]) */
end_comment

begin_function
specifier|static
name|int
name|ecp_nistz256_points_mul
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|scalar
parameter_list|,
name|size_t
name|num
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|points
index|[]
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|scalars
index|[]
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|no_precomp_for_generator
init|=
literal|0
decl_stmt|,
name|p_is_infinity
init|=
literal|0
decl_stmt|;
name|size_t
name|j
decl_stmt|;
name|unsigned
name|char
name|p_str
index|[
literal|33
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|const
name|PRECOMP256_ROW
modifier|*
name|preComputedTable
init|=
name|NULL
decl_stmt|;
specifier|const
name|EC_PRE_COMP
modifier|*
name|pre_comp
init|=
name|NULL
decl_stmt|;
specifier|const
name|EC_POINT
modifier|*
name|generator
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|index
init|=
literal|0
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
specifier|const
name|BIGNUM
modifier|*
modifier|*
name|new_scalars
init|=
name|NULL
decl_stmt|;
specifier|const
name|EC_POINT
modifier|*
modifier|*
name|new_points
init|=
name|NULL
decl_stmt|;
specifier|const
name|unsigned
name|int
name|window_size
init|=
literal|7
decl_stmt|;
specifier|const
name|unsigned
name|int
name|mask
init|=
operator|(
literal|1
operator|<<
operator|(
name|window_size
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|wvalue
decl_stmt|;
name|ALIGN32
union|union
block|{
name|P256_POINT
name|p
decl_stmt|;
name|P256_POINT_AFFINE
name|a
decl_stmt|;
block|}
name|t
union|,
name|p
union|;
name|BIGNUM
modifier|*
name|tmp_scalar
decl_stmt|;
if|if
condition|(
name|group
operator|->
name|meth
operator|!=
name|r
operator|->
name|meth
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_POINTS_MUL
argument_list|,
name|EC_R_INCOMPATIBLE_OBJECTS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|scalar
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|num
operator|==
literal|0
operator|)
condition|)
return|return
name|EC_POINT_set_to_infinity
argument_list|(
name|group
argument_list|,
name|r
argument_list|)
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|group
operator|->
name|meth
operator|!=
name|points
index|[
name|j
index|]
operator|->
name|meth
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_POINTS_MUL
argument_list|,
name|EC_R_INCOMPATIBLE_OBJECTS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|scalar
condition|)
block|{
name|generator
operator|=
name|EC_GROUP_get0_generator
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|generator
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_POINTS_MUL
argument_list|,
name|EC_R_UNDEFINED_GENERATOR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* look if we can use precomputed multiples of generator */
name|pre_comp
operator|=
name|EC_EX_DATA_get_data
argument_list|(
name|group
operator|->
name|extra_data
argument_list|,
name|ecp_nistz256_pre_comp_dup
argument_list|,
name|ecp_nistz256_pre_comp_free
argument_list|,
name|ecp_nistz256_pre_comp_clear_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_comp
condition|)
block|{
comment|/*              * If there is a precomputed table for the generator, check that              * it was generated with the same generator.              */
name|EC_POINT
modifier|*
name|pre_comp_generator
init|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
decl_stmt|;
if|if
condition|(
name|pre_comp_generator
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|ecp_nistz256_set_from_affine
argument_list|(
name|pre_comp_generator
argument_list|,
name|group
argument_list|,
name|pre_comp
operator|->
name|precomp
index|[
literal|0
index|]
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|EC_POINT_free
argument_list|(
name|pre_comp_generator
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
literal|0
operator|==
name|EC_POINT_cmp
argument_list|(
name|group
argument_list|,
name|generator
argument_list|,
name|pre_comp_generator
argument_list|,
name|ctx
argument_list|)
condition|)
name|preComputedTable
operator|=
operator|(
specifier|const
name|PRECOMP256_ROW
operator|*
operator|)
name|pre_comp
operator|->
name|precomp
expr_stmt|;
name|EC_POINT_free
argument_list|(
name|pre_comp_generator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preComputedTable
operator|==
name|NULL
operator|&&
name|ecp_nistz256_is_affine_G
argument_list|(
name|generator
argument_list|)
condition|)
block|{
comment|/*              * If there is no precomputed data, but the generator              * is the default, a hardcoded table of precomputed              * data is used. This is because applications, such as              * Apache, do not use EC_KEY_precompute_mult.              */
name|preComputedTable
operator|=
operator|(
specifier|const
name|PRECOMP256_ROW
operator|*
operator|)
name|ecp_nistz256_precomputed
expr_stmt|;
block|}
if|if
condition|(
name|preComputedTable
condition|)
block|{
if|if
condition|(
operator|(
name|BN_num_bits
argument_list|(
name|scalar
argument_list|)
operator|>
literal|256
operator|)
operator|||
name|BN_is_negative
argument_list|(
name|scalar
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|tmp_scalar
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_nnmod
argument_list|(
name|tmp_scalar
argument_list|,
name|scalar
argument_list|,
operator|&
name|group
operator|->
name|order
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_POINTS_MUL
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|scalar
operator|=
name|tmp_scalar
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scalar
operator|->
name|top
operator|*
name|BN_BYTES
condition|;
name|i
operator|+=
name|BN_BYTES
control|)
block|{
name|BN_ULONG
name|d
init|=
name|scalar
operator|->
name|d
index|[
name|i
operator|/
name|BN_BYTES
index|]
decl_stmt|;
name|p_str
index|[
name|i
operator|+
literal|0
index|]
operator|=
name|d
operator|&
literal|0xff
expr_stmt|;
name|p_str
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
name|d
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|p_str
index|[
name|i
operator|+
literal|2
index|]
operator|=
operator|(
name|d
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|p_str
index|[
name|i
operator|+
literal|3
index|]
operator|=
operator|(
name|d
operator|>>=
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|BN_BYTES
operator|==
literal|8
condition|)
block|{
name|d
operator|>>=
literal|8
expr_stmt|;
name|p_str
index|[
name|i
operator|+
literal|4
index|]
operator|=
name|d
operator|&
literal|0xff
expr_stmt|;
name|p_str
index|[
name|i
operator|+
literal|5
index|]
operator|=
operator|(
name|d
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|p_str
index|[
name|i
operator|+
literal|6
index|]
operator|=
operator|(
name|d
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|p_str
index|[
name|i
operator|+
literal|7
index|]
operator|=
operator|(
name|d
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|i
operator|<
literal|33
condition|;
name|i
operator|++
control|)
name|p_str
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ECP_NISTZ256_AVX2
argument_list|)
if|if
condition|(
name|ecp_nistz_avx2_eligible
argument_list|()
condition|)
block|{
name|ecp_nistz256_avx2_mul_g
argument_list|(
operator|&
name|p
operator|.
name|p
argument_list|,
name|p_str
argument_list|,
name|preComputedTable
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|BN_ULONG
name|infty
decl_stmt|;
comment|/* First window */
name|wvalue
operator|=
operator|(
name|p_str
index|[
literal|0
index|]
operator|<<
literal|1
operator|)
operator|&
name|mask
expr_stmt|;
name|index
operator|+=
name|window_size
expr_stmt|;
name|wvalue
operator|=
name|_booth_recode_w7
argument_list|(
name|wvalue
argument_list|)
expr_stmt|;
name|ecp_nistz256_select_w7
argument_list|(
operator|&
name|p
operator|.
name|a
argument_list|,
name|preComputedTable
index|[
literal|0
index|]
argument_list|,
name|wvalue
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|p
operator|.
name|p
operator|.
name|Z
argument_list|,
name|p
operator|.
name|p
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|p
operator|.
name|p
operator|.
name|Y
argument_list|,
name|p
operator|.
name|p
operator|.
name|Z
argument_list|,
name|wvalue
operator|&
literal|1
argument_list|)
expr_stmt|;
comment|/*                  * Since affine infinity is encoded as (0,0) and                  * Jacobian ias (,,0), we need to harmonize them                  * by assigning "one" or zero to Z.                  */
name|infty
operator|=
operator|(
name|p
operator|.
name|p
operator|.
name|X
index|[
literal|0
index|]
operator||
name|p
operator|.
name|p
operator|.
name|X
index|[
literal|1
index|]
operator||
name|p
operator|.
name|p
operator|.
name|X
index|[
literal|2
index|]
operator||
name|p
operator|.
name|p
operator|.
name|X
index|[
literal|3
index|]
operator||
name|p
operator|.
name|p
operator|.
name|Y
index|[
literal|0
index|]
operator||
name|p
operator|.
name|p
operator|.
name|Y
index|[
literal|1
index|]
operator||
name|p
operator|.
name|p
operator|.
name|Y
index|[
literal|2
index|]
operator||
name|p
operator|.
name|p
operator|.
name|Y
index|[
literal|3
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|P256_LIMBS
operator|==
literal|8
condition|)
name|infty
operator||=
operator|(
name|p
operator|.
name|p
operator|.
name|X
index|[
literal|4
index|]
operator||
name|p
operator|.
name|p
operator|.
name|X
index|[
literal|5
index|]
operator||
name|p
operator|.
name|p
operator|.
name|X
index|[
literal|6
index|]
operator||
name|p
operator|.
name|p
operator|.
name|X
index|[
literal|7
index|]
operator||
name|p
operator|.
name|p
operator|.
name|Y
index|[
literal|4
index|]
operator||
name|p
operator|.
name|p
operator|.
name|Y
index|[
literal|5
index|]
operator||
name|p
operator|.
name|p
operator|.
name|Y
index|[
literal|6
index|]
operator||
name|p
operator|.
name|p
operator|.
name|Y
index|[
literal|7
index|]
operator|)
expr_stmt|;
name|infty
operator|=
literal|0
operator|-
name|is_zero
argument_list|(
name|infty
argument_list|)
expr_stmt|;
name|infty
operator|=
operator|~
name|infty
expr_stmt|;
name|p
operator|.
name|p
operator|.
name|Z
index|[
literal|0
index|]
operator|=
name|ONE
index|[
literal|0
index|]
operator|&
name|infty
expr_stmt|;
name|p
operator|.
name|p
operator|.
name|Z
index|[
literal|1
index|]
operator|=
name|ONE
index|[
literal|1
index|]
operator|&
name|infty
expr_stmt|;
name|p
operator|.
name|p
operator|.
name|Z
index|[
literal|2
index|]
operator|=
name|ONE
index|[
literal|2
index|]
operator|&
name|infty
expr_stmt|;
name|p
operator|.
name|p
operator|.
name|Z
index|[
literal|3
index|]
operator|=
name|ONE
index|[
literal|3
index|]
operator|&
name|infty
expr_stmt|;
if|if
condition|(
name|P256_LIMBS
operator|==
literal|8
condition|)
block|{
name|p
operator|.
name|p
operator|.
name|Z
index|[
literal|4
index|]
operator|=
name|ONE
index|[
literal|4
index|]
operator|&
name|infty
expr_stmt|;
name|p
operator|.
name|p
operator|.
name|Z
index|[
literal|5
index|]
operator|=
name|ONE
index|[
literal|5
index|]
operator|&
name|infty
expr_stmt|;
name|p
operator|.
name|p
operator|.
name|Z
index|[
literal|6
index|]
operator|=
name|ONE
index|[
literal|6
index|]
operator|&
name|infty
expr_stmt|;
name|p
operator|.
name|p
operator|.
name|Z
index|[
literal|7
index|]
operator|=
name|ONE
index|[
literal|7
index|]
operator|&
name|infty
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|37
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|off
init|=
operator|(
name|index
operator|-
literal|1
operator|)
operator|/
literal|8
decl_stmt|;
name|wvalue
operator|=
name|p_str
index|[
name|off
index|]
operator||
name|p_str
index|[
name|off
operator|+
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|wvalue
operator|=
operator|(
name|wvalue
operator|>>
operator|(
operator|(
name|index
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|index
operator|+=
name|window_size
expr_stmt|;
name|wvalue
operator|=
name|_booth_recode_w7
argument_list|(
name|wvalue
argument_list|)
expr_stmt|;
name|ecp_nistz256_select_w7
argument_list|(
operator|&
name|t
operator|.
name|a
argument_list|,
name|preComputedTable
index|[
name|i
index|]
argument_list|,
name|wvalue
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|ecp_nistz256_neg
argument_list|(
name|t
operator|.
name|p
operator|.
name|Z
argument_list|,
name|t
operator|.
name|a
operator|.
name|Y
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|t
operator|.
name|a
operator|.
name|Y
argument_list|,
name|t
operator|.
name|p
operator|.
name|Z
argument_list|,
name|wvalue
operator|&
literal|1
argument_list|)
expr_stmt|;
name|ecp_nistz256_point_add_affine
argument_list|(
operator|&
name|p
operator|.
name|p
argument_list|,
operator|&
name|p
operator|.
name|p
argument_list|,
operator|&
name|t
operator|.
name|a
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|p_is_infinity
operator|=
literal|1
expr_stmt|;
name|no_precomp_for_generator
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|p_is_infinity
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|no_precomp_for_generator
condition|)
block|{
comment|/*          * Without a precomputed table for the generator, it has to be          * handled like a normal point.          */
name|new_scalars
operator|=
name|OPENSSL_malloc
argument_list|(
operator|(
name|num
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|BIGNUM
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_scalars
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_POINTS_MUL
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|new_points
operator|=
name|OPENSSL_malloc
argument_list|(
operator|(
name|num
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|EC_POINT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_points
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_POINTS_MUL
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|memcpy
argument_list|(
name|new_scalars
argument_list|,
name|scalars
argument_list|,
name|num
operator|*
sizeof|sizeof
argument_list|(
name|BIGNUM
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|new_scalars
index|[
name|num
index|]
operator|=
name|scalar
expr_stmt|;
name|memcpy
argument_list|(
name|new_points
argument_list|,
name|points
argument_list|,
name|num
operator|*
sizeof|sizeof
argument_list|(
name|EC_POINT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|new_points
index|[
name|num
index|]
operator|=
name|generator
expr_stmt|;
name|scalars
operator|=
name|new_scalars
expr_stmt|;
name|points
operator|=
name|new_points
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|num
condition|)
block|{
name|P256_POINT
modifier|*
name|out
init|=
operator|&
name|t
operator|.
name|p
decl_stmt|;
if|if
condition|(
name|p_is_infinity
condition|)
name|out
operator|=
operator|&
name|p
operator|.
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|ecp_nistz256_windowed_mul
argument_list|(
name|group
argument_list|,
name|out
argument_list|,
name|scalars
argument_list|,
name|points
argument_list|,
name|num
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|p_is_infinity
condition|)
name|ecp_nistz256_point_add
argument_list|(
operator|&
name|p
operator|.
name|p
argument_list|,
operator|&
name|p
operator|.
name|p
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
comment|/* Not constant-time, but we're only operating on the public output. */
if|if
condition|(
operator|!
name|ecp_nistz256_set_words
argument_list|(
operator|&
name|r
operator|->
name|X
argument_list|,
name|p
operator|.
name|p
operator|.
name|X
argument_list|)
operator|||
operator|!
name|ecp_nistz256_set_words
argument_list|(
operator|&
name|r
operator|->
name|Y
argument_list|,
name|p
operator|.
name|p
operator|.
name|Y
argument_list|)
operator|||
operator|!
name|ecp_nistz256_set_words
argument_list|(
operator|&
name|r
operator|->
name|Z
argument_list|,
name|p
operator|.
name|p
operator|.
name|Z
argument_list|)
condition|)
block|{
goto|goto
name|err
goto|;
block|}
name|r
operator|->
name|Z_is_one
operator|=
name|is_one
argument_list|(
operator|&
name|r
operator|->
name|Z
argument_list|)
operator|&
literal|1
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|ctx
condition|)
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_points
condition|)
name|OPENSSL_free
argument_list|(
name|new_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_scalars
condition|)
name|OPENSSL_free
argument_list|(
name|new_scalars
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecp_nistz256_get_affine
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|point
parameter_list|,
name|BIGNUM
modifier|*
name|x
parameter_list|,
name|BIGNUM
modifier|*
name|y
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BN_ULONG
name|z_inv2
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|z_inv3
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|x_aff
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|y_aff
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|point_x
index|[
name|P256_LIMBS
index|]
decl_stmt|,
name|point_y
index|[
name|P256_LIMBS
index|]
decl_stmt|,
name|point_z
index|[
name|P256_LIMBS
index|]
decl_stmt|;
name|BN_ULONG
name|x_ret
index|[
name|P256_LIMBS
index|]
decl_stmt|,
name|y_ret
index|[
name|P256_LIMBS
index|]
decl_stmt|;
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|point
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_GET_AFFINE
argument_list|,
name|EC_R_POINT_AT_INFINITY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|ecp_nistz256_bignum_to_field_elem
argument_list|(
name|point_x
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|)
operator|||
operator|!
name|ecp_nistz256_bignum_to_field_elem
argument_list|(
name|point_y
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|)
operator|||
operator|!
name|ecp_nistz256_bignum_to_field_elem
argument_list|(
name|point_z
argument_list|,
operator|&
name|point
operator|->
name|Z
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_GET_AFFINE
argument_list|,
name|EC_R_COORDINATES_OUT_OF_RANGE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ecp_nistz256_mod_inverse
argument_list|(
name|z_inv3
argument_list|,
name|point_z
argument_list|)
expr_stmt|;
name|ecp_nistz256_sqr_mont
argument_list|(
name|z_inv2
argument_list|,
name|z_inv3
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|x_aff
argument_list|,
name|z_inv2
argument_list|,
name|point_x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
block|{
name|ecp_nistz256_from_mont
argument_list|(
name|x_ret
argument_list|,
name|x_aff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ecp_nistz256_set_words
argument_list|(
name|x
argument_list|,
name|x_ret
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|y
operator|!=
name|NULL
condition|)
block|{
name|ecp_nistz256_mul_mont
argument_list|(
name|z_inv3
argument_list|,
name|z_inv3
argument_list|,
name|z_inv2
argument_list|)
expr_stmt|;
name|ecp_nistz256_mul_mont
argument_list|(
name|y_aff
argument_list|,
name|z_inv3
argument_list|,
name|point_y
argument_list|)
expr_stmt|;
name|ecp_nistz256_from_mont
argument_list|(
name|y_ret
argument_list|,
name|y_aff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ecp_nistz256_set_words
argument_list|(
name|y
argument_list|,
name|y_ret
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|EC_PRE_COMP
modifier|*
name|ecp_nistz256_pre_comp_new
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
name|EC_PRE_COMP
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|group
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
operator|(
name|EC_PRE_COMP
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EC_PRE_COMP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_ECP_NISTZ256_PRE_COMP_NEW
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|->
name|group
operator|=
name|group
expr_stmt|;
name|ret
operator|->
name|w
operator|=
literal|6
expr_stmt|;
comment|/* default */
name|ret
operator|->
name|precomp
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|precomp_storage
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|references
operator|=
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ecp_nistz256_pre_comp_dup
parameter_list|(
name|void
modifier|*
name|src_
parameter_list|)
block|{
name|EC_PRE_COMP
modifier|*
name|src
init|=
name|src_
decl_stmt|;
comment|/* no need to actually copy, these objects never change! */
name|CRYPTO_add
argument_list|(
operator|&
name|src
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_EC_PRE_COMP
argument_list|)
expr_stmt|;
return|return
name|src_
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecp_nistz256_pre_comp_free
parameter_list|(
name|void
modifier|*
name|pre_
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|EC_PRE_COMP
modifier|*
name|pre
init|=
name|pre_
decl_stmt|;
if|if
condition|(
operator|!
name|pre
condition|)
return|return;
name|i
operator|=
name|CRYPTO_add
argument_list|(
operator|&
name|pre
operator|->
name|references
argument_list|,
operator|-
literal|1
argument_list|,
name|CRYPTO_LOCK_EC_PRE_COMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|pre
operator|->
name|precomp_storage
condition|)
name|OPENSSL_free
argument_list|(
name|pre
operator|->
name|precomp_storage
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|pre
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecp_nistz256_pre_comp_clear_free
parameter_list|(
name|void
modifier|*
name|pre_
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|EC_PRE_COMP
modifier|*
name|pre
init|=
name|pre_
decl_stmt|;
if|if
condition|(
operator|!
name|pre
condition|)
return|return;
name|i
operator|=
name|CRYPTO_add
argument_list|(
operator|&
name|pre
operator|->
name|references
argument_list|,
operator|-
literal|1
argument_list|,
name|CRYPTO_LOCK_EC_PRE_COMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|pre
operator|->
name|precomp_storage
condition|)
block|{
name|OPENSSL_cleanse
argument_list|(
name|pre
operator|->
name|precomp
argument_list|,
literal|32
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|(
literal|1
operator|<<
name|pre
operator|->
name|w
operator|)
operator|*
literal|2
operator|*
literal|37
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|pre
operator|->
name|precomp_storage
argument_list|)
expr_stmt|;
block|}
name|OPENSSL_cleanse
argument_list|(
name|pre
argument_list|,
sizeof|sizeof
expr|*
name|pre
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|pre
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecp_nistz256_window_have_precompute_mult
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
comment|/* There is a hard-coded table for the default generator. */
specifier|const
name|EC_POINT
modifier|*
name|generator
init|=
name|EC_GROUP_get0_generator
argument_list|(
name|group
argument_list|)
decl_stmt|;
if|if
condition|(
name|generator
operator|!=
name|NULL
operator|&&
name|ecp_nistz256_is_affine_G
argument_list|(
name|generator
argument_list|)
condition|)
block|{
comment|/* There is a hard-coded table for the default generator. */
return|return
literal|1
return|;
block|}
return|return
name|EC_EX_DATA_get_data
argument_list|(
name|group
operator|->
name|extra_data
argument_list|,
name|ecp_nistz256_pre_comp_dup
argument_list|,
name|ecp_nistz256_pre_comp_free
argument_list|,
name|ecp_nistz256_pre_comp_clear_free
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|EC_METHOD
modifier|*
name|EC_GFp_nistz256_method
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|EC_METHOD
name|ret
init|=
block|{
name|EC_FLAGS_DEFAULT_OCT
block|,
name|NID_X9_62_prime_field
block|,
name|ec_GFp_mont_group_init
block|,
name|ec_GFp_mont_group_finish
block|,
name|ec_GFp_mont_group_clear_finish
block|,
name|ec_GFp_mont_group_copy
block|,
name|ec_GFp_mont_group_set_curve
block|,
name|ec_GFp_simple_group_get_curve
block|,
name|ec_GFp_simple_group_get_degree
block|,
name|ec_GFp_simple_group_check_discriminant
block|,
name|ec_GFp_simple_point_init
block|,
name|ec_GFp_simple_point_finish
block|,
name|ec_GFp_simple_point_clear_finish
block|,
name|ec_GFp_simple_point_copy
block|,
name|ec_GFp_simple_point_set_to_infinity
block|,
name|ec_GFp_simple_set_Jprojective_coordinates_GFp
block|,
name|ec_GFp_simple_get_Jprojective_coordinates_GFp
block|,
name|ec_GFp_simple_point_set_affine_coordinates
block|,
name|ecp_nistz256_get_affine
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|ec_GFp_simple_add
block|,
name|ec_GFp_simple_dbl
block|,
name|ec_GFp_simple_invert
block|,
name|ec_GFp_simple_is_at_infinity
block|,
name|ec_GFp_simple_is_on_curve
block|,
name|ec_GFp_simple_cmp
block|,
name|ec_GFp_simple_make_affine
block|,
name|ec_GFp_simple_points_make_affine
block|,
name|ecp_nistz256_points_mul
block|,
comment|/* mul */
name|ecp_nistz256_mult_precompute
block|,
comment|/* precompute_mult */
name|ecp_nistz256_window_have_precompute_mult
block|,
comment|/* have_precompute_mult */
name|ec_GFp_mont_field_mul
block|,
name|ec_GFp_mont_field_sqr
block|,
literal|0
block|,
comment|/* field_div */
name|ec_GFp_mont_field_encode
block|,
name|ec_GFp_mont_field_decode
block|,
name|ec_GFp_mont_field_set_to_one
block|}
decl_stmt|;
return|return
operator|&
name|ret
return|;
block|}
end_function

end_unit

