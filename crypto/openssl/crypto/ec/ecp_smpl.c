begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/ec/ecp_smpl.c */
end_comment

begin_comment
comment|/* Includes code written by Lenka Fibikova<fibikova@exp-math.uni-essen.de>  * for the OpenSSL project.   * Includes code written by Bodo Moeller for the OpenSSL project. */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.  * Portions of this software developed by SUN MICROSYSTEMS, INC.,  * and contributed to the OpenSSL project.  */
end_comment

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/symhacks.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
end_ifdef

begin_include
include|#
directive|include
file|<openssl/fips.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ec_lcl.h"
end_include

begin_function
specifier|const
name|EC_METHOD
modifier|*
name|EC_GFp_simple_method
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|EC_METHOD
name|ret
init|=
block|{
name|EC_FLAGS_DEFAULT_OCT
block|,
name|NID_X9_62_prime_field
block|,
name|ec_GFp_simple_group_init
block|,
name|ec_GFp_simple_group_finish
block|,
name|ec_GFp_simple_group_clear_finish
block|,
name|ec_GFp_simple_group_copy
block|,
name|ec_GFp_simple_group_set_curve
block|,
name|ec_GFp_simple_group_get_curve
block|,
name|ec_GFp_simple_group_get_degree
block|,
name|ec_GFp_simple_group_check_discriminant
block|,
name|ec_GFp_simple_point_init
block|,
name|ec_GFp_simple_point_finish
block|,
name|ec_GFp_simple_point_clear_finish
block|,
name|ec_GFp_simple_point_copy
block|,
name|ec_GFp_simple_point_set_to_infinity
block|,
name|ec_GFp_simple_set_Jprojective_coordinates_GFp
block|,
name|ec_GFp_simple_get_Jprojective_coordinates_GFp
block|,
name|ec_GFp_simple_point_set_affine_coordinates
block|,
name|ec_GFp_simple_point_get_affine_coordinates
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|ec_GFp_simple_add
block|,
name|ec_GFp_simple_dbl
block|,
name|ec_GFp_simple_invert
block|,
name|ec_GFp_simple_is_at_infinity
block|,
name|ec_GFp_simple_is_on_curve
block|,
name|ec_GFp_simple_cmp
block|,
name|ec_GFp_simple_make_affine
block|,
name|ec_GFp_simple_points_make_affine
block|,
literal|0
comment|/* mul */
block|,
literal|0
comment|/* precompute_mult */
block|,
literal|0
comment|/* have_precompute_mult */
block|,
name|ec_GFp_simple_field_mul
block|,
name|ec_GFp_simple_field_sqr
block|,
literal|0
comment|/* field_div */
block|,
literal|0
comment|/* field_encode */
block|,
literal|0
comment|/* field_decode */
block|,
literal|0
comment|/* field_set_to_one */
block|}
decl_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
if|if
condition|(
name|FIPS_mode
argument_list|()
condition|)
return|return
name|fips_ec_gfp_simple_method
argument_list|()
return|;
endif|#
directive|endif
return|return
operator|&
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Most method functions in this file are designed to work with  * non-trivial representations of field elements if necessary  * (see ecp_mont.c): while standard modular addition and subtraction  * are used, the field_mul and field_sqr methods will be used for  * multiplication, and field_encode and field_decode (if defined)  * will be used for converting between representations.   * Functions ec_GFp_simple_points_make_affine() and  * ec_GFp_simple_point_get_affine_coordinates() specifically assume  * that if a non-trivial representation is used, it is a Montgomery  * representation (i.e. 'encoding' means multiplying by some factor R).  */
end_comment

begin_function
name|int
name|ec_GFp_simple_group_init
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
name|BN_init
argument_list|(
operator|&
name|group
operator|->
name|field
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|group
operator|->
name|a
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|group
operator|->
name|b
argument_list|)
expr_stmt|;
name|group
operator|->
name|a_is_minus3
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|ec_GFp_simple_group_finish
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
name|BN_free
argument_list|(
operator|&
name|group
operator|->
name|field
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|group
operator|->
name|a
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|group
operator|->
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ec_GFp_simple_group_clear_finish
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
name|BN_clear_free
argument_list|(
operator|&
name|group
operator|->
name|field
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
operator|&
name|group
operator|->
name|a
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
operator|&
name|group
operator|->
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_group_copy
parameter_list|(
name|EC_GROUP
modifier|*
name|dest
parameter_list|,
specifier|const
name|EC_GROUP
modifier|*
name|src
parameter_list|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|dest
operator|->
name|field
argument_list|,
operator|&
name|src
operator|->
name|field
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|dest
operator|->
name|a
argument_list|,
operator|&
name|src
operator|->
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|dest
operator|->
name|b
argument_list|,
operator|&
name|src
operator|->
name|b
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|->
name|a_is_minus3
operator|=
name|src
operator|->
name|a_is_minus3
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_group_set_curve
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|tmp_a
decl_stmt|;
comment|/* p must be a prime> 3 */
if|if
condition|(
name|BN_num_bits
argument_list|(
name|p
argument_list|)
operator|<=
literal|2
operator|||
operator|!
name|BN_is_odd
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE
argument_list|,
name|EC_R_INVALID_FIELD
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|tmp_a
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_a
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* group->field */
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|group
operator|->
name|field
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|BN_set_negative
argument_list|(
operator|&
name|group
operator|->
name|field
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* group->a */
if|if
condition|(
operator|!
name|BN_nnmod
argument_list|(
name|tmp_a
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|group
operator|->
name|meth
operator|->
name|field_encode
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_encode
argument_list|(
name|group
argument_list|,
operator|&
name|group
operator|->
name|a
argument_list|,
name|tmp_a
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|group
operator|->
name|a
argument_list|,
name|tmp_a
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* group->b */
if|if
condition|(
operator|!
name|BN_nnmod
argument_list|(
operator|&
name|group
operator|->
name|b
argument_list|,
name|b
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|group
operator|->
name|meth
operator|->
name|field_encode
condition|)
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_encode
argument_list|(
name|group
argument_list|,
operator|&
name|group
operator|->
name|b
argument_list|,
operator|&
name|group
operator|->
name|b
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* group->a_is_minus3 */
if|if
condition|(
operator|!
name|BN_add_word
argument_list|(
name|tmp_a
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|group
operator|->
name|a_is_minus3
operator|=
operator|(
literal|0
operator|==
name|BN_cmp
argument_list|(
name|tmp_a
argument_list|,
operator|&
name|group
operator|->
name|field
argument_list|)
operator|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_group_get_curve
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|BIGNUM
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|p
argument_list|,
operator|&
name|group
operator|->
name|field
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|a
operator|!=
name|NULL
operator|||
name|b
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|group
operator|->
name|meth
operator|->
name|field_decode
condition|)
block|{
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_decode
argument_list|(
name|group
argument_list|,
name|a
argument_list|,
operator|&
name|group
operator|->
name|a
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_decode
argument_list|(
name|group
argument_list|,
name|b
argument_list|,
operator|&
name|group
operator|->
name|b
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|a
argument_list|,
operator|&
name|group
operator|->
name|a
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|b
argument_list|,
operator|&
name|group
operator|->
name|b
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|new_ctx
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_group_get_degree
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
return|return
name|BN_num_bits
argument_list|(
operator|&
name|group
operator|->
name|field
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_group_check_discriminant
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|BIGNUM
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|order
decl_stmt|,
modifier|*
name|tmp_1
decl_stmt|,
modifier|*
name|tmp_2
decl_stmt|;
specifier|const
name|BIGNUM
modifier|*
name|p
init|=
operator|&
name|group
operator|->
name|field
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_SIMPLE_GROUP_CHECK_DISCRIMINANT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|a
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|b
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|tmp_1
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|tmp_2
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|order
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|group
operator|->
name|meth
operator|->
name|field_decode
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_decode
argument_list|(
name|group
argument_list|,
name|a
argument_list|,
operator|&
name|group
operator|->
name|a
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_decode
argument_list|(
name|group
argument_list|,
name|b
argument_list|,
operator|&
name|group
operator|->
name|b
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|a
argument_list|,
operator|&
name|group
operator|->
name|a
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|b
argument_list|,
operator|&
name|group
operator|->
name|b
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* check the discriminant: 	 * y^2 = x^3 + a*x + b is an elliptic curve<=> 4*a^3 + 27*b^2 != 0 (mod p)           * 0 =< a, b< p */
if|if
condition|(
name|BN_is_zero
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|BN_is_zero
argument_list|(
name|b
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|BN_is_zero
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|BN_mod_sqr
argument_list|(
name|tmp_1
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_mul
argument_list|(
name|tmp_2
argument_list|,
name|tmp_1
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_lshift
argument_list|(
name|tmp_1
argument_list|,
name|tmp_2
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* tmp_1 = 4*a^3 */
if|if
condition|(
operator|!
name|BN_mod_sqr
argument_list|(
name|tmp_2
argument_list|,
name|b
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mul_word
argument_list|(
name|tmp_2
argument_list|,
literal|27
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* tmp_2 = 27*b^2 */
if|if
condition|(
operator|!
name|BN_mod_add
argument_list|(
name|a
argument_list|,
name|tmp_1
argument_list|,
name|tmp_2
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|BN_is_zero
argument_list|(
name|a
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_point_init
parameter_list|(
name|EC_POINT
modifier|*
name|point
parameter_list|)
block|{
name|BN_init
argument_list|(
operator|&
name|point
operator|->
name|X
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|point
operator|->
name|Y
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|)
expr_stmt|;
name|point
operator|->
name|Z_is_one
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|ec_GFp_simple_point_finish
parameter_list|(
name|EC_POINT
modifier|*
name|point
parameter_list|)
block|{
name|BN_free
argument_list|(
operator|&
name|point
operator|->
name|X
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|point
operator|->
name|Y
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ec_GFp_simple_point_clear_finish
parameter_list|(
name|EC_POINT
modifier|*
name|point
parameter_list|)
block|{
name|BN_clear_free
argument_list|(
operator|&
name|point
operator|->
name|X
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
operator|&
name|point
operator|->
name|Y
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|)
expr_stmt|;
name|point
operator|->
name|Z_is_one
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_point_copy
parameter_list|(
name|EC_POINT
modifier|*
name|dest
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|src
parameter_list|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|dest
operator|->
name|X
argument_list|,
operator|&
name|src
operator|->
name|X
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|dest
operator|->
name|Y
argument_list|,
operator|&
name|src
operator|->
name|Y
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|dest
operator|->
name|Z
argument_list|,
operator|&
name|src
operator|->
name|Z
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|->
name|Z_is_one
operator|=
name|src
operator|->
name|Z_is_one
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_point_set_to_infinity
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|point
parameter_list|)
block|{
name|point
operator|->
name|Z_is_one
operator|=
literal|0
expr_stmt|;
name|BN_zero
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_set_Jprojective_coordinates_GFp
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|point
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|x
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|y
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|z
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|BN_nnmod
argument_list|(
operator|&
name|point
operator|->
name|X
argument_list|,
name|x
argument_list|,
operator|&
name|group
operator|->
name|field
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|group
operator|->
name|meth
operator|->
name|field_encode
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_encode
argument_list|(
name|group
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|y
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|BN_nnmod
argument_list|(
operator|&
name|point
operator|->
name|Y
argument_list|,
name|y
argument_list|,
operator|&
name|group
operator|->
name|field
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|group
operator|->
name|meth
operator|->
name|field_encode
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_encode
argument_list|(
name|group
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
block|{
name|int
name|Z_is_one
decl_stmt|;
if|if
condition|(
operator|!
name|BN_nnmod
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|,
name|z
argument_list|,
operator|&
name|group
operator|->
name|field
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|Z_is_one
operator|=
name|BN_is_one
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|->
name|meth
operator|->
name|field_encode
condition|)
block|{
if|if
condition|(
name|Z_is_one
operator|&&
operator|(
name|group
operator|->
name|meth
operator|->
name|field_set_to_one
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_set_to_one
argument_list|(
name|group
argument_list|,
operator|&
name|point
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_encode
argument_list|(
name|group
argument_list|,
operator|&
name|point
operator|->
name|Z
argument_list|,
operator|&
name|point
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
name|point
operator|->
name|Z_is_one
operator|=
name|Z_is_one
expr_stmt|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_get_Jprojective_coordinates_GFp
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|point
parameter_list|,
name|BIGNUM
modifier|*
name|x
parameter_list|,
name|BIGNUM
modifier|*
name|y
parameter_list|,
name|BIGNUM
modifier|*
name|z
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|group
operator|->
name|meth
operator|->
name|field_decode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_decode
argument_list|(
name|group
argument_list|,
name|x
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|y
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_decode
argument_list|(
name|group
argument_list|,
name|y
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_decode
argument_list|(
name|group
argument_list|,
name|z
argument_list|,
operator|&
name|point
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|x
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|y
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|y
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|z
argument_list|,
operator|&
name|point
operator|->
name|Z
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_point_set_affine_coordinates
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|point
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|x
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|y
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|x
operator|==
name|NULL
operator|||
name|y
operator|==
name|NULL
condition|)
block|{
comment|/* unlike for projective coordinates, we do not tolerate this */
name|ECerr
argument_list|(
name|EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EC_POINT_set_Jprojective_coordinates_GFp
argument_list|(
name|group
argument_list|,
name|point
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|BN_value_one
argument_list|()
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_point_get_affine_coordinates
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|point
parameter_list|,
name|BIGNUM
modifier|*
name|x
parameter_list|,
name|BIGNUM
modifier|*
name|y
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|Z
decl_stmt|,
modifier|*
name|Z_1
decl_stmt|,
modifier|*
name|Z_2
decl_stmt|,
modifier|*
name|Z_3
decl_stmt|;
specifier|const
name|BIGNUM
modifier|*
name|Z_
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|point
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES
argument_list|,
name|EC_R_POINT_AT_INFINITY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|Z
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|Z_1
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|Z_2
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|Z_3
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Z_3
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* transform  (X, Y, Z)  into  (x, y) := (X/Z^2, Y/Z^3) */
if|if
condition|(
name|group
operator|->
name|meth
operator|->
name|field_decode
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_decode
argument_list|(
name|group
argument_list|,
name|Z
argument_list|,
operator|&
name|point
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|Z_
operator|=
name|Z
expr_stmt|;
block|}
else|else
block|{
name|Z_
operator|=
operator|&
name|point
operator|->
name|Z
expr_stmt|;
block|}
if|if
condition|(
name|BN_is_one
argument_list|(
name|Z_
argument_list|)
condition|)
block|{
if|if
condition|(
name|group
operator|->
name|meth
operator|->
name|field_decode
condition|)
block|{
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_decode
argument_list|(
name|group
argument_list|,
name|x
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|y
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_decode
argument_list|(
name|group
argument_list|,
name|y
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|x
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|y
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|y
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|BN_mod_inverse
argument_list|(
name|Z_1
argument_list|,
name|Z_
argument_list|,
operator|&
name|group
operator|->
name|field
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|group
operator|->
name|meth
operator|->
name|field_encode
operator|==
literal|0
condition|)
block|{
comment|/* field_sqr works on standard representation */
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_sqr
argument_list|(
name|group
argument_list|,
name|Z_2
argument_list|,
name|Z_1
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|BN_mod_sqr
argument_list|(
name|Z_2
argument_list|,
name|Z_1
argument_list|,
operator|&
name|group
operator|->
name|field
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
block|{
comment|/* in the Montgomery case, field_mul will cancel out Montgomery factor in X: */
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_mul
argument_list|(
name|group
argument_list|,
name|x
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|,
name|Z_2
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|y
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|group
operator|->
name|meth
operator|->
name|field_encode
operator|==
literal|0
condition|)
block|{
comment|/* field_mul works on standard representation */
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_mul
argument_list|(
name|group
argument_list|,
name|Z_3
argument_list|,
name|Z_2
argument_list|,
name|Z_1
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|BN_mod_mul
argument_list|(
name|Z_3
argument_list|,
name|Z_2
argument_list|,
name|Z_1
argument_list|,
operator|&
name|group
operator|->
name|field
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* in the Montgomery case, field_mul will cancel out Montgomery factor in Y: */
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_mul
argument_list|(
name|group
argument_list|,
name|y
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|,
name|Z_3
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_add
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|a
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
function_decl|(
modifier|*
name|field_mul
function_decl|)
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
parameter_list|,
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
name|BN_CTX
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|field_sqr
function_decl|)
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
parameter_list|,
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
name|BN_CTX
modifier|*
parameter_list|)
function_decl|;
specifier|const
name|BIGNUM
modifier|*
name|p
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|n0
decl_stmt|,
modifier|*
name|n1
decl_stmt|,
modifier|*
name|n2
decl_stmt|,
modifier|*
name|n3
decl_stmt|,
modifier|*
name|n4
decl_stmt|,
modifier|*
name|n5
decl_stmt|,
modifier|*
name|n6
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|a
operator|==
name|b
condition|)
return|return
name|EC_POINT_dbl
argument_list|(
name|group
argument_list|,
name|r
argument_list|,
name|a
argument_list|,
name|ctx
argument_list|)
return|;
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|a
argument_list|)
condition|)
return|return
name|EC_POINT_copy
argument_list|(
name|r
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|EC_POINT_copy
argument_list|(
name|r
argument_list|,
name|a
argument_list|)
return|;
name|field_mul
operator|=
name|group
operator|->
name|meth
operator|->
name|field_mul
expr_stmt|;
name|field_sqr
operator|=
name|group
operator|->
name|meth
operator|->
name|field_sqr
expr_stmt|;
name|p
operator|=
operator|&
name|group
operator|->
name|field
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|n0
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|n1
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|n2
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|n3
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|n4
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|n5
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|n6
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|n6
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
comment|/* Note that in this function we must not read components of 'a' or 'b' 	 * once we have written the corresponding components of 'r'. 	 * ('r' might be one of 'a' or 'b'.) 	 */
comment|/* n1, n2 */
if|if
condition|(
name|b
operator|->
name|Z_is_one
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|n1
argument_list|,
operator|&
name|a
operator|->
name|X
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|n2
argument_list|,
operator|&
name|a
operator|->
name|Y
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* n1 = X_a */
comment|/* n2 = Y_a */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|n0
argument_list|,
operator|&
name|b
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n1
argument_list|,
operator|&
name|a
operator|->
name|X
argument_list|,
name|n0
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* n1 = X_a * Z_b^2 */
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n0
argument_list|,
name|n0
argument_list|,
operator|&
name|b
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n2
argument_list|,
operator|&
name|a
operator|->
name|Y
argument_list|,
name|n0
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* n2 = Y_a * Z_b^3 */
block|}
comment|/* n3, n4 */
if|if
condition|(
name|a
operator|->
name|Z_is_one
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|n3
argument_list|,
operator|&
name|b
operator|->
name|X
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|n4
argument_list|,
operator|&
name|b
operator|->
name|Y
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* n3 = X_b */
comment|/* n4 = Y_b */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|n0
argument_list|,
operator|&
name|a
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n3
argument_list|,
operator|&
name|b
operator|->
name|X
argument_list|,
name|n0
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* n3 = X_b * Z_a^2 */
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n0
argument_list|,
name|n0
argument_list|,
operator|&
name|a
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n4
argument_list|,
operator|&
name|b
operator|->
name|Y
argument_list|,
name|n0
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* n4 = Y_b * Z_a^3 */
block|}
comment|/* n5, n6 */
if|if
condition|(
operator|!
name|BN_mod_sub_quick
argument_list|(
name|n5
argument_list|,
name|n1
argument_list|,
name|n3
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_mod_sub_quick
argument_list|(
name|n6
argument_list|,
name|n2
argument_list|,
name|n4
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* n5 = n1 - n3 */
comment|/* n6 = n2 - n4 */
if|if
condition|(
name|BN_is_zero
argument_list|(
name|n5
argument_list|)
condition|)
block|{
if|if
condition|(
name|BN_is_zero
argument_list|(
name|n6
argument_list|)
condition|)
block|{
comment|/* a is the same point as b */
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EC_POINT_dbl
argument_list|(
name|group
argument_list|,
name|r
argument_list|,
name|a
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|NULL
expr_stmt|;
goto|goto
name|end
goto|;
block|}
else|else
block|{
comment|/* a is the inverse of b */
name|BN_zero
argument_list|(
operator|&
name|r
operator|->
name|Z
argument_list|)
expr_stmt|;
name|r
operator|->
name|Z_is_one
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
comment|/* 'n7', 'n8' */
if|if
condition|(
operator|!
name|BN_mod_add_quick
argument_list|(
name|n1
argument_list|,
name|n1
argument_list|,
name|n3
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_mod_add_quick
argument_list|(
name|n2
argument_list|,
name|n2
argument_list|,
name|n4
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* 'n7' = n1 + n3 */
comment|/* 'n8' = n2 + n4 */
comment|/* Z_r */
if|if
condition|(
name|a
operator|->
name|Z_is_one
operator|&&
name|b
operator|->
name|Z_is_one
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|r
operator|->
name|Z
argument_list|,
name|n5
argument_list|)
condition|)
goto|goto
name|end
goto|;
block|}
else|else
block|{
if|if
condition|(
name|a
operator|->
name|Z_is_one
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|n0
argument_list|,
operator|&
name|b
operator|->
name|Z
argument_list|)
condition|)
goto|goto
name|end
goto|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|Z_is_one
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|n0
argument_list|,
operator|&
name|a
operator|->
name|Z
argument_list|)
condition|)
goto|goto
name|end
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n0
argument_list|,
operator|&
name|a
operator|->
name|Z
argument_list|,
operator|&
name|b
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
operator|&
name|r
operator|->
name|Z
argument_list|,
name|n0
argument_list|,
name|n5
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
block|}
name|r
operator|->
name|Z_is_one
operator|=
literal|0
expr_stmt|;
comment|/* Z_r = Z_a * Z_b * n5 */
comment|/* X_r */
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|n0
argument_list|,
name|n6
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|n4
argument_list|,
name|n5
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n3
argument_list|,
name|n1
argument_list|,
name|n4
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_mod_sub_quick
argument_list|(
operator|&
name|r
operator|->
name|X
argument_list|,
name|n0
argument_list|,
name|n3
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* X_r = n6^2 - n5^2 * 'n7' */
comment|/* 'n9' */
if|if
condition|(
operator|!
name|BN_mod_lshift1_quick
argument_list|(
name|n0
argument_list|,
operator|&
name|r
operator|->
name|X
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_mod_sub_quick
argument_list|(
name|n0
argument_list|,
name|n3
argument_list|,
name|n0
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* n9 = n5^2 * 'n7' - 2 * X_r */
comment|/* Y_r */
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n0
argument_list|,
name|n0
argument_list|,
name|n6
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n5
argument_list|,
name|n4
argument_list|,
name|n5
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* now n5 is n5^3 */
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|n5
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_mod_sub_quick
argument_list|(
name|n0
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|BN_is_odd
argument_list|(
name|n0
argument_list|)
condition|)
if|if
condition|(
operator|!
name|BN_add
argument_list|(
name|n0
argument_list|,
name|n0
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* now  0<= n0< 2*p,  and n0 is even */
if|if
condition|(
operator|!
name|BN_rshift1
argument_list|(
operator|&
name|r
operator|->
name|Y
argument_list|,
name|n0
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* Y_r = (n6 * 'n9' - 'n8' * 'n5^3') / 2 */
name|ret
operator|=
literal|1
expr_stmt|;
name|end
label|:
if|if
condition|(
name|ctx
condition|)
comment|/* otherwise we already called BN_CTX_end */
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_dbl
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|a
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
function_decl|(
modifier|*
name|field_mul
function_decl|)
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
parameter_list|,
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
name|BN_CTX
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|field_sqr
function_decl|)
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
parameter_list|,
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
name|BN_CTX
modifier|*
parameter_list|)
function_decl|;
specifier|const
name|BIGNUM
modifier|*
name|p
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|n0
decl_stmt|,
modifier|*
name|n1
decl_stmt|,
modifier|*
name|n2
decl_stmt|,
modifier|*
name|n3
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|a
argument_list|)
condition|)
block|{
name|BN_zero
argument_list|(
operator|&
name|r
operator|->
name|Z
argument_list|)
expr_stmt|;
name|r
operator|->
name|Z_is_one
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|field_mul
operator|=
name|group
operator|->
name|meth
operator|->
name|field_mul
expr_stmt|;
name|field_sqr
operator|=
name|group
operator|->
name|meth
operator|->
name|field_sqr
expr_stmt|;
name|p
operator|=
operator|&
name|group
operator|->
name|field
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|n0
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|n1
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|n2
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|n3
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|n3
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* Note that in this function we must not read components of 'a' 	 * once we have written the corresponding components of 'r'. 	 * ('r' might the same as 'a'.) 	 */
comment|/* n1 */
if|if
condition|(
name|a
operator|->
name|Z_is_one
condition|)
block|{
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|n0
argument_list|,
operator|&
name|a
operator|->
name|X
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_lshift1_quick
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_add_quick
argument_list|(
name|n0
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_add_quick
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
operator|&
name|group
operator|->
name|a
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* n1 = 3 * X_a^2 + a_curve */
block|}
elseif|else
if|if
condition|(
name|group
operator|->
name|a_is_minus3
condition|)
block|{
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|n1
argument_list|,
operator|&
name|a
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_add_quick
argument_list|(
name|n0
argument_list|,
operator|&
name|a
operator|->
name|X
argument_list|,
name|n1
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_sub_quick
argument_list|(
name|n2
argument_list|,
operator|&
name|a
operator|->
name|X
argument_list|,
name|n1
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|n2
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_lshift1_quick
argument_list|(
name|n0
argument_list|,
name|n1
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_add_quick
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* n1 = 3 * (X_a + Z_a^2) * (X_a - Z_a^2) 		 *    = 3 * X_a^2 - 3 * Z_a^4 */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|n0
argument_list|,
operator|&
name|a
operator|->
name|X
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_lshift1_quick
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_add_quick
argument_list|(
name|n0
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|n1
argument_list|,
operator|&
name|a
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|n1
argument_list|,
name|n1
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n1
argument_list|,
name|n1
argument_list|,
operator|&
name|group
operator|->
name|a
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_add_quick
argument_list|(
name|n1
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* n1 = 3 * X_a^2 + a_curve * Z_a^4 */
block|}
comment|/* Z_r */
if|if
condition|(
name|a
operator|->
name|Z_is_one
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|n0
argument_list|,
operator|&
name|a
operator|->
name|Y
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n0
argument_list|,
operator|&
name|a
operator|->
name|Y
argument_list|,
operator|&
name|a
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|BN_mod_lshift1_quick
argument_list|(
operator|&
name|r
operator|->
name|Z
argument_list|,
name|n0
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|r
operator|->
name|Z_is_one
operator|=
literal|0
expr_stmt|;
comment|/* Z_r = 2 * Y_a * Z_a */
comment|/* n2 */
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|n3
argument_list|,
operator|&
name|a
operator|->
name|Y
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n2
argument_list|,
operator|&
name|a
operator|->
name|X
argument_list|,
name|n3
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_lshift_quick
argument_list|(
name|n2
argument_list|,
name|n2
argument_list|,
literal|2
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* n2 = 4 * X_a * Y_a^2 */
comment|/* X_r */
if|if
condition|(
operator|!
name|BN_mod_lshift1_quick
argument_list|(
name|n0
argument_list|,
name|n2
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
operator|&
name|r
operator|->
name|X
argument_list|,
name|n1
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_sub_quick
argument_list|(
operator|&
name|r
operator|->
name|X
argument_list|,
operator|&
name|r
operator|->
name|X
argument_list|,
name|n0
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* X_r = n1^2 - 2 * n2 */
comment|/* n3 */
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|n0
argument_list|,
name|n3
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_lshift_quick
argument_list|(
name|n3
argument_list|,
name|n0
argument_list|,
literal|3
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* n3 = 8 * Y_a^4 */
comment|/* Y_r */
if|if
condition|(
operator|!
name|BN_mod_sub_quick
argument_list|(
name|n0
argument_list|,
name|n2
argument_list|,
operator|&
name|r
operator|->
name|X
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_sub_quick
argument_list|(
operator|&
name|r
operator|->
name|Y
argument_list|,
name|n0
argument_list|,
name|n3
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Y_r = n1 * (n2 - X_r) - n3 */
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_invert
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|point
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|point
argument_list|)
operator|||
name|BN_is_zero
argument_list|(
operator|&
name|point
operator|->
name|Y
argument_list|)
condition|)
comment|/* point is its own inverse */
return|return
literal|1
return|;
return|return
name|BN_usub
argument_list|(
operator|&
name|point
operator|->
name|Y
argument_list|,
operator|&
name|group
operator|->
name|field
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_is_at_infinity
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|point
parameter_list|)
block|{
return|return
name|BN_is_zero
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_is_on_curve
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|point
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
function_decl|(
modifier|*
name|field_mul
function_decl|)
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
parameter_list|,
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
name|BN_CTX
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|field_sqr
function_decl|)
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
parameter_list|,
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
name|BN_CTX
modifier|*
parameter_list|)
function_decl|;
specifier|const
name|BIGNUM
modifier|*
name|p
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|rh
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|Z4
decl_stmt|,
modifier|*
name|Z6
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|point
argument_list|)
condition|)
return|return
literal|1
return|;
name|field_mul
operator|=
name|group
operator|->
name|meth
operator|->
name|field_mul
expr_stmt|;
name|field_sqr
operator|=
name|group
operator|->
name|meth
operator|->
name|field_sqr
expr_stmt|;
name|p
operator|=
operator|&
name|group
operator|->
name|field
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|rh
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|Z4
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|Z6
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Z6
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* We have a curve defined by a Weierstrass equation 	 *      y^2 = x^3 + a*x + b. 	 * The point to consider is given in Jacobian projective coordinates 	 * where  (X, Y, Z)  represents  (x, y) = (X/Z^2, Y/Z^3). 	 * Substituting this and multiplying by  Z^6  transforms the above equation into 	 *      Y^2 = X^3 + a*X*Z^4 + b*Z^6. 	 * To test this, we add up the right-hand side in 'rh'. 	 */
comment|/* rh := X^2 */
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|rh
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|point
operator|->
name|Z_is_one
condition|)
block|{
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|tmp
argument_list|,
operator|&
name|point
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|Z4
argument_list|,
name|tmp
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|Z6
argument_list|,
name|Z4
argument_list|,
name|tmp
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* rh := (rh + a*Z^4)*X */
if|if
condition|(
name|group
operator|->
name|a_is_minus3
condition|)
block|{
if|if
condition|(
operator|!
name|BN_mod_lshift1_quick
argument_list|(
name|tmp
argument_list|,
name|Z4
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_add_quick
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|Z4
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_sub_quick
argument_list|(
name|rh
argument_list|,
name|rh
argument_list|,
name|tmp
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|rh
argument_list|,
name|rh
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|tmp
argument_list|,
name|Z4
argument_list|,
operator|&
name|group
operator|->
name|a
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_add_quick
argument_list|(
name|rh
argument_list|,
name|rh
argument_list|,
name|tmp
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|rh
argument_list|,
name|rh
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* rh := rh + b*Z^6 */
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|tmp
argument_list|,
operator|&
name|group
operator|->
name|b
argument_list|,
name|Z6
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_add_quick
argument_list|(
name|rh
argument_list|,
name|rh
argument_list|,
name|tmp
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
comment|/* point->Z_is_one */
comment|/* rh := (rh + a)*X */
if|if
condition|(
operator|!
name|BN_mod_add_quick
argument_list|(
name|rh
argument_list|,
name|rh
argument_list|,
operator|&
name|group
operator|->
name|a
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|rh
argument_list|,
name|rh
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* rh := rh + b */
if|if
condition|(
operator|!
name|BN_mod_add_quick
argument_list|(
name|rh
argument_list|,
name|rh
argument_list|,
operator|&
name|group
operator|->
name|b
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* 'lh' := Y^2 */
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|tmp
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
operator|(
literal|0
operator|==
name|BN_ucmp
argument_list|(
name|tmp
argument_list|,
name|rh
argument_list|)
operator|)
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_cmp
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|a
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
comment|/* return values: 	 *  -1   error 	 *   0   equal (in affine coordinates) 	 *   1   not equal 	 */
name|int
function_decl|(
modifier|*
name|field_mul
function_decl|)
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
parameter_list|,
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
name|BN_CTX
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|field_sqr
function_decl|)
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
parameter_list|,
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
name|BN_CTX
modifier|*
parameter_list|)
function_decl|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|Za23
decl_stmt|,
modifier|*
name|Zb23
decl_stmt|;
specifier|const
name|BIGNUM
modifier|*
name|tmp1_
decl_stmt|,
modifier|*
name|tmp2_
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|a
argument_list|)
condition|)
block|{
return|return
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|b
argument_list|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|Z_is_one
operator|&&
name|b
operator|->
name|Z_is_one
condition|)
block|{
return|return
operator|(
operator|(
name|BN_cmp
argument_list|(
operator|&
name|a
operator|->
name|X
argument_list|,
operator|&
name|b
operator|->
name|X
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|BN_cmp
argument_list|(
operator|&
name|a
operator|->
name|Y
argument_list|,
operator|&
name|b
operator|->
name|Y
argument_list|)
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
name|field_mul
operator|=
name|group
operator|->
name|meth
operator|->
name|field_mul
expr_stmt|;
name|field_sqr
operator|=
name|group
operator|->
name|meth
operator|->
name|field_sqr
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|Za23
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|Zb23
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Zb23
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
comment|/* We have to decide whether 	 *     (X_a/Z_a^2, Y_a/Z_a^3) = (X_b/Z_b^2, Y_b/Z_b^3), 	 * or equivalently, whether 	 *     (X_a*Z_b^2, Y_a*Z_b^3) = (X_b*Z_a^2, Y_b*Z_a^3). 	 */
if|if
condition|(
operator|!
name|b
operator|->
name|Z_is_one
condition|)
block|{
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|Zb23
argument_list|,
operator|&
name|b
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|tmp1
argument_list|,
operator|&
name|a
operator|->
name|X
argument_list|,
name|Zb23
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|tmp1_
operator|=
name|tmp1
expr_stmt|;
block|}
else|else
name|tmp1_
operator|=
operator|&
name|a
operator|->
name|X
expr_stmt|;
if|if
condition|(
operator|!
name|a
operator|->
name|Z_is_one
condition|)
block|{
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|Za23
argument_list|,
operator|&
name|a
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|tmp2
argument_list|,
operator|&
name|b
operator|->
name|X
argument_list|,
name|Za23
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|tmp2_
operator|=
name|tmp2
expr_stmt|;
block|}
else|else
name|tmp2_
operator|=
operator|&
name|b
operator|->
name|X
expr_stmt|;
comment|/* compare  X_a*Z_b^2  with  X_b*Z_a^2 */
if|if
condition|(
name|BN_cmp
argument_list|(
name|tmp1_
argument_list|,
name|tmp2_
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* points differ */
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|!
name|b
operator|->
name|Z_is_one
condition|)
block|{
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|Zb23
argument_list|,
name|Zb23
argument_list|,
operator|&
name|b
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|tmp1
argument_list|,
operator|&
name|a
operator|->
name|Y
argument_list|,
name|Zb23
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* tmp1_ = tmp1 */
block|}
else|else
name|tmp1_
operator|=
operator|&
name|a
operator|->
name|Y
expr_stmt|;
if|if
condition|(
operator|!
name|a
operator|->
name|Z_is_one
condition|)
block|{
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|Za23
argument_list|,
name|Za23
argument_list|,
operator|&
name|a
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|tmp2
argument_list|,
operator|&
name|b
operator|->
name|Y
argument_list|,
name|Za23
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* tmp2_ = tmp2 */
block|}
else|else
name|tmp2_
operator|=
operator|&
name|b
operator|->
name|Y
expr_stmt|;
comment|/* compare  Y_a*Z_b^3  with  Y_b*Z_a^3 */
if|if
condition|(
name|BN_cmp
argument_list|(
name|tmp1_
argument_list|,
name|tmp2_
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* points differ */
goto|goto
name|end
goto|;
block|}
comment|/* points are equal */
name|ret
operator|=
literal|0
expr_stmt|;
name|end
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_make_affine
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|point
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|point
operator|->
name|Z_is_one
operator|||
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|point
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|x
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|y
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|EC_POINT_get_affine_coordinates_GFp
argument_list|(
name|group
argument_list|,
name|point
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|EC_POINT_set_affine_coordinates_GFp
argument_list|(
name|group
argument_list|,
name|point
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|point
operator|->
name|Z_is_one
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_SIMPLE_MAKE_AFFINE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_points_make_affine
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|size_t
name|num
parameter_list|,
name|EC_POINT
modifier|*
name|points
index|[]
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|tmp_Z
decl_stmt|;
name|BIGNUM
modifier|*
modifier|*
name|prod_Z
init|=
name|NULL
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|tmp_Z
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
operator|||
name|tmp_Z
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|prod_Z
operator|=
name|OPENSSL_malloc
argument_list|(
name|num
operator|*
sizeof|sizeof
name|prod_Z
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|prod_Z
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|prod_Z
index|[
name|i
index|]
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|prod_Z
index|[
name|i
index|]
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* Set each prod_Z[i] to the product of points[0]->Z .. points[i]->Z, 	 * skipping any zero-valued inputs (pretend that they're 1). */
if|if
condition|(
operator|!
name|BN_is_zero
argument_list|(
operator|&
name|points
index|[
literal|0
index|]
operator|->
name|Z
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|prod_Z
index|[
literal|0
index|]
argument_list|,
operator|&
name|points
index|[
literal|0
index|]
operator|->
name|Z
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
name|group
operator|->
name|meth
operator|->
name|field_set_to_one
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_set_to_one
argument_list|(
name|group
argument_list|,
name|prod_Z
index|[
literal|0
index|]
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|BN_one
argument_list|(
name|prod_Z
index|[
literal|0
index|]
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|BN_is_zero
argument_list|(
operator|&
name|points
index|[
name|i
index|]
operator|->
name|Z
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_mul
argument_list|(
name|group
argument_list|,
name|prod_Z
index|[
name|i
index|]
argument_list|,
name|prod_Z
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
operator|&
name|points
index|[
name|i
index|]
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|prod_Z
index|[
name|i
index|]
argument_list|,
name|prod_Z
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
comment|/* Now use a single explicit inversion to replace every 	 * non-zero points[i]->Z by its inverse. */
if|if
condition|(
operator|!
name|BN_mod_inverse
argument_list|(
name|tmp
argument_list|,
name|prod_Z
index|[
name|num
operator|-
literal|1
index|]
argument_list|,
operator|&
name|group
operator|->
name|field
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|group
operator|->
name|meth
operator|->
name|field_encode
operator|!=
literal|0
condition|)
block|{
comment|/* In the Montgomery case, we just turned  R*H  (representing H) 		 * into  1/(R*H),  but we need  R*(1/H)  (representing 1/H); 		 * i.e. we need to multiply by the Montgomery factor twice. */
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_encode
argument_list|(
name|group
argument_list|,
name|tmp
argument_list|,
name|tmp
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_encode
argument_list|(
name|group
argument_list|,
name|tmp
argument_list|,
name|tmp
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|i
operator|=
name|num
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
comment|/* Loop invariant: tmp is the product of the inverses of 		 * points[0]->Z .. points[i]->Z (zero-valued inputs skipped). */
if|if
condition|(
operator|!
name|BN_is_zero
argument_list|(
operator|&
name|points
index|[
name|i
index|]
operator|->
name|Z
argument_list|)
condition|)
block|{
comment|/* Set tmp_Z to the inverse of points[i]->Z (as product 			 * of Z inverses 0 .. i, Z values 0 .. i - 1). */
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_mul
argument_list|(
name|group
argument_list|,
name|tmp_Z
argument_list|,
name|prod_Z
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|tmp
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Update tmp to satisfy the loop invariant for i - 1. */
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_mul
argument_list|(
name|group
argument_list|,
name|tmp
argument_list|,
name|tmp
argument_list|,
operator|&
name|points
index|[
name|i
index|]
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Replace points[i]->Z by its inverse. */
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|points
index|[
name|i
index|]
operator|->
name|Z
argument_list|,
name|tmp_Z
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|BN_is_zero
argument_list|(
operator|&
name|points
index|[
literal|0
index|]
operator|->
name|Z
argument_list|)
condition|)
block|{
comment|/* Replace points[0]->Z by its inverse. */
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|points
index|[
literal|0
index|]
operator|->
name|Z
argument_list|,
name|tmp
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* Finally, fix up the X and Y coordinates for all points. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|EC_POINT
modifier|*
name|p
init|=
name|points
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|BN_is_zero
argument_list|(
operator|&
name|p
operator|->
name|Z
argument_list|)
condition|)
block|{
comment|/* turn  (X, Y, 1/Z)  into  (X/Z^2, Y/Z^3, 1) */
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_sqr
argument_list|(
name|group
argument_list|,
name|tmp
argument_list|,
operator|&
name|p
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_mul
argument_list|(
name|group
argument_list|,
operator|&
name|p
operator|->
name|X
argument_list|,
operator|&
name|p
operator|->
name|X
argument_list|,
name|tmp
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_mul
argument_list|(
name|group
argument_list|,
name|tmp
argument_list|,
name|tmp
argument_list|,
operator|&
name|p
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_mul
argument_list|(
name|group
argument_list|,
operator|&
name|p
operator|->
name|Y
argument_list|,
operator|&
name|p
operator|->
name|Y
argument_list|,
name|tmp
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|group
operator|->
name|meth
operator|->
name|field_set_to_one
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_set_to_one
argument_list|(
name|group
argument_list|,
operator|&
name|p
operator|->
name|Z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|BN_one
argument_list|(
operator|&
name|p
operator|->
name|Z
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
name|p
operator|->
name|Z_is_one
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|prod_Z
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|prod_Z
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
name|BN_clear_free
argument_list|(
name|prod_Z
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|OPENSSL_free
argument_list|(
name|prod_Z
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_field_mul
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|BN_mod_mul
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|group
operator|->
name|field
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_simple_field_sqr
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|BN_mod_sqr
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
operator|&
name|group
operator|->
name|field
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

end_unit

