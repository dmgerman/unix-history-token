begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/ec/ec_mult.c */
end_comment

begin_comment
comment|/*  * Originally written by Bodo Moeller and Nils Larsch for the OpenSSL project.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.  * Portions of this software developed by SUN MICROSYSTEMS, INC.,  * and contributed to the OpenSSL project.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|"ec_lcl.h"
end_include

begin_comment
comment|/*  * This file implements the wNAF-based interleaving multi-exponentiation method  * Formerly at:  *   http://www.informatik.tu-darmstadt.de/TI/Mitarbeiter/moeller.html#multiexp  * You might now find it here:  *   http://link.springer.com/chapter/10.1007%2F3-540-45537-X_13  *   http://www.bmoeller.de/pdf/TI-01-08.multiexp.pdf  * For multiplication with precomputation, we use wNAF splitting, formerly at:  *   http://www.informatik.tu-darmstadt.de/TI/Mitarbeiter/moeller.html#fastexp  */
end_comment

begin_comment
comment|/* structure for precomputed multiples of the generator */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ec_pre_comp_st
block|{
specifier|const
name|EC_GROUP
modifier|*
name|group
decl_stmt|;
comment|/* parent EC_GROUP object */
name|size_t
name|blocksize
decl_stmt|;
comment|/* block size for wNAF splitting */
name|size_t
name|numblocks
decl_stmt|;
comment|/* max. number of blocks for which we have                                  * precomputation */
name|size_t
name|w
decl_stmt|;
comment|/* window size */
name|EC_POINT
modifier|*
modifier|*
name|points
decl_stmt|;
comment|/* array with pre-calculated multiples of                                  * generator: 'num' pointers to EC_POINT                                  * objects followed by a NULL */
name|size_t
name|num
decl_stmt|;
comment|/* numblocks * 2^(w-1) */
name|int
name|references
decl_stmt|;
block|}
name|EC_PRE_COMP
typedef|;
end_typedef

begin_comment
comment|/* functions to manage EC_PRE_COMP within the EC_GROUP extra_data framework */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|ec_pre_comp_dup
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ec_pre_comp_free
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ec_pre_comp_clear_free
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|EC_PRE_COMP
modifier|*
name|ec_pre_comp_new
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
name|EC_PRE_COMP
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|group
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
operator|(
name|EC_PRE_COMP
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EC_PRE_COMP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_PRE_COMP_NEW
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|->
name|group
operator|=
name|group
expr_stmt|;
name|ret
operator|->
name|blocksize
operator|=
literal|8
expr_stmt|;
comment|/* default */
name|ret
operator|->
name|numblocks
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|w
operator|=
literal|4
expr_stmt|;
comment|/* default */
name|ret
operator|->
name|points
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|num
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|references
operator|=
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ec_pre_comp_dup
parameter_list|(
name|void
modifier|*
name|src_
parameter_list|)
block|{
name|EC_PRE_COMP
modifier|*
name|src
init|=
name|src_
decl_stmt|;
comment|/* no need to actually copy, these objects never change! */
name|CRYPTO_add
argument_list|(
operator|&
name|src
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_EC_PRE_COMP
argument_list|)
expr_stmt|;
return|return
name|src_
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ec_pre_comp_free
parameter_list|(
name|void
modifier|*
name|pre_
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|EC_PRE_COMP
modifier|*
name|pre
init|=
name|pre_
decl_stmt|;
if|if
condition|(
operator|!
name|pre
condition|)
return|return;
name|i
operator|=
name|CRYPTO_add
argument_list|(
operator|&
name|pre
operator|->
name|references
argument_list|,
operator|-
literal|1
argument_list|,
name|CRYPTO_LOCK_EC_PRE_COMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|pre
operator|->
name|points
condition|)
block|{
name|EC_POINT
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|pre
operator|->
name|points
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
name|EC_POINT_free
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|pre
operator|->
name|points
argument_list|)
expr_stmt|;
block|}
name|OPENSSL_free
argument_list|(
name|pre
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ec_pre_comp_clear_free
parameter_list|(
name|void
modifier|*
name|pre_
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|EC_PRE_COMP
modifier|*
name|pre
init|=
name|pre_
decl_stmt|;
if|if
condition|(
operator|!
name|pre
condition|)
return|return;
name|i
operator|=
name|CRYPTO_add
argument_list|(
operator|&
name|pre
operator|->
name|references
argument_list|,
operator|-
literal|1
argument_list|,
name|CRYPTO_LOCK_EC_PRE_COMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|pre
operator|->
name|points
condition|)
block|{
name|EC_POINT
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|pre
operator|->
name|points
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|EC_POINT_clear_free
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|OPENSSL_cleanse
argument_list|(
name|p
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
block|}
name|OPENSSL_free
argument_list|(
name|pre
operator|->
name|points
argument_list|)
expr_stmt|;
block|}
name|OPENSSL_cleanse
argument_list|(
name|pre
argument_list|,
sizeof|sizeof
expr|*
name|pre
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|pre
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Determine the modified width-(w+1) Non-Adjacent Form (wNAF) of 'scalar'.  * This is an array  r[]  of values that are either zero or odd with an  * absolute value less than  2^w  satisfying  *     scalar = \sum_j r[j]*2^j  * where at most one of any  w+1  consecutive digits is non-zero  * with the exception that the most significant digit may be only  * w-1 zeros away from that next non-zero digit.  */
end_comment

begin_function
specifier|static
name|signed
name|char
modifier|*
name|compute_wNAF
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|scalar
parameter_list|,
name|int
name|w
parameter_list|,
name|size_t
modifier|*
name|ret_len
parameter_list|)
block|{
name|int
name|window_val
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
name|signed
name|char
modifier|*
name|r
init|=
name|NULL
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|next_bit
decl_stmt|,
name|mask
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|BN_is_zero
argument_list|(
name|scalar
argument_list|)
condition|)
block|{
name|r
operator|=
name|OPENSSL_malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_COMPUTE_WNAF
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|r
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|ret_len
operator|=
literal|1
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|w
operator|<=
literal|0
operator|||
name|w
operator|>
literal|7
condition|)
block|{
comment|/* 'signed char' can represent integers with                                  * absolute values less than 2^7 */
name|ECerr
argument_list|(
name|EC_F_COMPUTE_WNAF
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|bit
operator|=
literal|1
operator|<<
name|w
expr_stmt|;
comment|/* at most 128 */
name|next_bit
operator|=
name|bit
operator|<<
literal|1
expr_stmt|;
comment|/* at most 256 */
name|mask
operator|=
name|next_bit
operator|-
literal|1
expr_stmt|;
comment|/* at most 255 */
if|if
condition|(
name|BN_is_negative
argument_list|(
name|scalar
argument_list|)
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|scalar
operator|->
name|d
operator|==
name|NULL
operator|||
name|scalar
operator|->
name|top
operator|==
literal|0
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_COMPUTE_WNAF
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|len
operator|=
name|BN_num_bits
argument_list|(
name|scalar
argument_list|)
expr_stmt|;
name|r
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* modified wNAF may be one digit longer                                   * than binary representation (*ret_len will                                   * be set to the actual length, i.e. at most                                   * BN_num_bits(scalar) + 1) */
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_COMPUTE_WNAF
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|window_val
operator|=
name|scalar
operator|->
name|d
index|[
literal|0
index|]
operator|&
name|mask
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|window_val
operator|!=
literal|0
operator|)
operator|||
operator|(
name|j
operator|+
name|w
operator|+
literal|1
operator|<
name|len
operator|)
condition|)
block|{
comment|/* if j+w+1>= len,                                                       * window_val will not                                                       * increase */
name|int
name|digit
init|=
literal|0
decl_stmt|;
comment|/* 0<= window_val<= 2^(w+1) */
if|if
condition|(
name|window_val
operator|&
literal|1
condition|)
block|{
comment|/* 0< window_val< 2^(w+1) */
if|if
condition|(
name|window_val
operator|&
name|bit
condition|)
block|{
name|digit
operator|=
name|window_val
operator|-
name|next_bit
expr_stmt|;
comment|/* -2^w< digit< 0 */
if|#
directive|if
literal|1
comment|/* modified wNAF */
if|if
condition|(
name|j
operator|+
name|w
operator|+
literal|1
operator|>=
name|len
condition|)
block|{
comment|/*                      * special case for generating modified wNAFs: no new                      * bits will be added into window_val, so using a                      * positive digit here will decrease the total length of                      * the representation                      */
name|digit
operator|=
name|window_val
operator|&
operator|(
name|mask
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* 0< digit< 2^w */
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|digit
operator|=
name|window_val
expr_stmt|;
comment|/* 0< digit< 2^w */
block|}
if|if
condition|(
name|digit
operator|<=
operator|-
name|bit
operator|||
name|digit
operator|>=
name|bit
operator|||
operator|!
operator|(
name|digit
operator|&
literal|1
operator|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_COMPUTE_WNAF
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|window_val
operator|-=
name|digit
expr_stmt|;
comment|/*              * now window_val is 0 or 2^(w+1) in standard wNAF generation;              * for modified window NAFs, it may also be 2^w              */
if|if
condition|(
name|window_val
operator|!=
literal|0
operator|&&
name|window_val
operator|!=
name|next_bit
operator|&&
name|window_val
operator|!=
name|bit
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_COMPUTE_WNAF
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|r
index|[
name|j
operator|++
index|]
operator|=
name|sign
operator|*
name|digit
expr_stmt|;
name|window_val
operator|>>=
literal|1
expr_stmt|;
name|window_val
operator|+=
name|bit
operator|*
name|BN_is_bit_set
argument_list|(
name|scalar
argument_list|,
name|j
operator|+
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|window_val
operator|>
name|next_bit
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_COMPUTE_WNAF
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|j
operator|>
name|len
operator|+
literal|1
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_COMPUTE_WNAF
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|len
operator|=
name|j
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
operator|*
name|ret_len
operator|=
name|len
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * TODO: table should be optimised for the wNAF-based implementation,  * sometimes smaller windows will give better performance (thus the  * boundaries should be increased)  */
end_comment

begin_define
define|#
directive|define
name|EC_window_bits_for_scalar_size
parameter_list|(
name|b
parameter_list|)
define|\
value|((size_t) \                  ((b)>= 2000 ? 6 : \                   (b)>=  800 ? 5 : \                   (b)>=  300 ? 4 : \                   (b)>=   70 ? 3 : \                   (b)>=   20 ? 2 : \                   1))
end_define

begin_comment
comment|/*-  * Compute  *      \sum scalars[i]*points[i],  * also including  *      scalar*generator  * in the addition if scalar != NULL  */
end_comment

begin_function
name|int
name|ec_wNAF_mul
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|scalar
parameter_list|,
name|size_t
name|num
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|points
index|[]
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|scalars
index|[]
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
specifier|const
name|EC_POINT
modifier|*
name|generator
init|=
name|NULL
decl_stmt|;
name|EC_POINT
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|size_t
name|totalnum
decl_stmt|;
name|size_t
name|blocksize
init|=
literal|0
decl_stmt|,
name|numblocks
init|=
literal|0
decl_stmt|;
comment|/* for wNAF splitting */
name|size_t
name|pre_points_per_block
init|=
literal|0
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|r_is_inverted
init|=
literal|0
decl_stmt|;
name|int
name|r_is_at_infinity
init|=
literal|1
decl_stmt|;
name|size_t
modifier|*
name|wsize
init|=
name|NULL
decl_stmt|;
comment|/* individual window sizes */
name|signed
name|char
modifier|*
modifier|*
name|wNAF
init|=
name|NULL
decl_stmt|;
comment|/* individual wNAFs */
name|size_t
modifier|*
name|wNAF_len
init|=
name|NULL
decl_stmt|;
name|size_t
name|max_len
init|=
literal|0
decl_stmt|;
name|size_t
name|num_val
decl_stmt|;
name|EC_POINT
modifier|*
modifier|*
name|val
init|=
name|NULL
decl_stmt|;
comment|/* precomputation */
name|EC_POINT
modifier|*
modifier|*
name|v
decl_stmt|;
name|EC_POINT
modifier|*
modifier|*
modifier|*
name|val_sub
init|=
name|NULL
decl_stmt|;
comment|/* pointers to sub-arrays of 'val' or                                  * 'pre_comp->points' */
specifier|const
name|EC_PRE_COMP
modifier|*
name|pre_comp
init|=
name|NULL
decl_stmt|;
name|int
name|num_scalar
init|=
literal|0
decl_stmt|;
comment|/* flag: will be set to 1 if 'scalar' must be                                  * treated like other scalars, i.e.                                  * precomputation is not available */
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|group
operator|->
name|meth
operator|!=
name|r
operator|->
name|meth
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_MUL
argument_list|,
name|EC_R_INCOMPATIBLE_OBJECTS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|scalar
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|num
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|EC_POINT_set_to_infinity
argument_list|(
name|group
argument_list|,
name|r
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|group
operator|->
name|meth
operator|!=
name|points
index|[
name|i
index|]
operator|->
name|meth
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_MUL
argument_list|,
name|EC_R_INCOMPATIBLE_OBJECTS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|scalar
operator|!=
name|NULL
condition|)
block|{
name|generator
operator|=
name|EC_GROUP_get0_generator
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|generator
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_MUL
argument_list|,
name|EC_R_UNDEFINED_GENERATOR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* look if we can use precomputed multiples of generator */
name|pre_comp
operator|=
name|EC_EX_DATA_get_data
argument_list|(
name|group
operator|->
name|extra_data
argument_list|,
name|ec_pre_comp_dup
argument_list|,
name|ec_pre_comp_free
argument_list|,
name|ec_pre_comp_clear_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_comp
operator|&&
name|pre_comp
operator|->
name|numblocks
operator|&&
operator|(
name|EC_POINT_cmp
argument_list|(
name|group
argument_list|,
name|generator
argument_list|,
name|pre_comp
operator|->
name|points
index|[
literal|0
index|]
argument_list|,
name|ctx
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|blocksize
operator|=
name|pre_comp
operator|->
name|blocksize
expr_stmt|;
comment|/*              * determine maximum number of blocks that wNAF splitting may              * yield (NB: maximum wNAF length is bit length plus one)              */
name|numblocks
operator|=
operator|(
name|BN_num_bits
argument_list|(
name|scalar
argument_list|)
operator|/
name|blocksize
operator|)
operator|+
literal|1
expr_stmt|;
comment|/*              * we cannot use more blocks than we have precomputation for              */
if|if
condition|(
name|numblocks
operator|>
name|pre_comp
operator|->
name|numblocks
condition|)
name|numblocks
operator|=
name|pre_comp
operator|->
name|numblocks
expr_stmt|;
name|pre_points_per_block
operator|=
operator|(
name|size_t
operator|)
literal|1
operator|<<
operator|(
name|pre_comp
operator|->
name|w
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* check that pre_comp looks sane */
if|if
condition|(
name|pre_comp
operator|->
name|num
operator|!=
operator|(
name|pre_comp
operator|->
name|numblocks
operator|*
name|pre_points_per_block
operator|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_MUL
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
else|else
block|{
comment|/* can't use precomputation */
name|pre_comp
operator|=
name|NULL
expr_stmt|;
name|numblocks
operator|=
literal|1
expr_stmt|;
name|num_scalar
operator|=
literal|1
expr_stmt|;
comment|/* treat 'scalar' like 'num'-th element of                                  * 'scalars' */
block|}
block|}
name|totalnum
operator|=
name|num
operator|+
name|numblocks
expr_stmt|;
name|wsize
operator|=
name|OPENSSL_malloc
argument_list|(
name|totalnum
operator|*
sizeof|sizeof
name|wsize
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wNAF_len
operator|=
name|OPENSSL_malloc
argument_list|(
name|totalnum
operator|*
sizeof|sizeof
name|wNAF_len
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wNAF
operator|=
name|OPENSSL_malloc
argument_list|(
operator|(
name|totalnum
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
name|wNAF
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* includes space                                                              * for pivot */
name|val_sub
operator|=
name|OPENSSL_malloc
argument_list|(
name|totalnum
operator|*
sizeof|sizeof
name|val_sub
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Ensure wNAF is initialised in case we end up going to err */
if|if
condition|(
name|wNAF
condition|)
name|wNAF
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* preliminary pivot */
if|if
condition|(
operator|!
name|wsize
operator|||
operator|!
name|wNAF_len
operator|||
operator|!
name|wNAF
operator|||
operator|!
name|val_sub
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_MUL
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/*      * num_val will be the total number of temporarily precomputed points      */
name|num_val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
operator|+
name|num_scalar
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|bits
decl_stmt|;
name|bits
operator|=
name|i
operator|<
name|num
condition|?
name|BN_num_bits
argument_list|(
name|scalars
index|[
name|i
index|]
argument_list|)
else|:
name|BN_num_bits
argument_list|(
name|scalar
argument_list|)
expr_stmt|;
name|wsize
index|[
name|i
index|]
operator|=
name|EC_window_bits_for_scalar_size
argument_list|(
name|bits
argument_list|)
expr_stmt|;
name|num_val
operator|+=
operator|(
name|size_t
operator|)
literal|1
operator|<<
operator|(
name|wsize
index|[
name|i
index|]
operator|-
literal|1
operator|)
expr_stmt|;
name|wNAF
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* make sure we always have a pivot */
name|wNAF
index|[
name|i
index|]
operator|=
name|compute_wNAF
argument_list|(
operator|(
name|i
operator|<
name|num
condition|?
name|scalars
index|[
name|i
index|]
else|:
name|scalar
operator|)
argument_list|,
name|wsize
index|[
name|i
index|]
argument_list|,
operator|&
name|wNAF_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wNAF
index|[
name|i
index|]
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|wNAF_len
index|[
name|i
index|]
operator|>
name|max_len
condition|)
name|max_len
operator|=
name|wNAF_len
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|numblocks
condition|)
block|{
comment|/* we go here iff scalar != NULL */
if|if
condition|(
name|pre_comp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|num_scalar
operator|!=
literal|1
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_MUL
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* we have already generated a wNAF for 'scalar' */
block|}
else|else
block|{
name|signed
name|char
modifier|*
name|tmp_wNAF
init|=
name|NULL
decl_stmt|;
name|size_t
name|tmp_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|num_scalar
operator|!=
literal|0
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_MUL
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/*              * use the window size for which we have precomputation              */
name|wsize
index|[
name|num
index|]
operator|=
name|pre_comp
operator|->
name|w
expr_stmt|;
name|tmp_wNAF
operator|=
name|compute_wNAF
argument_list|(
name|scalar
argument_list|,
name|wsize
index|[
name|num
index|]
argument_list|,
operator|&
name|tmp_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp_wNAF
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|tmp_len
operator|<=
name|max_len
condition|)
block|{
comment|/*                  * One of the other wNAFs is at least as long as the wNAF                  * belonging to the generator, so wNAF splitting will not buy                  * us anything.                  */
name|numblocks
operator|=
literal|1
expr_stmt|;
name|totalnum
operator|=
name|num
operator|+
literal|1
expr_stmt|;
comment|/* don't use wNAF splitting */
name|wNAF
index|[
name|num
index|]
operator|=
name|tmp_wNAF
expr_stmt|;
name|wNAF
index|[
name|num
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|wNAF_len
index|[
name|num
index|]
operator|=
name|tmp_len
expr_stmt|;
if|if
condition|(
name|tmp_len
operator|>
name|max_len
condition|)
name|max_len
operator|=
name|tmp_len
expr_stmt|;
comment|/*                  * pre_comp->points starts with the points that we need here:                  */
name|val_sub
index|[
name|num
index|]
operator|=
name|pre_comp
operator|->
name|points
expr_stmt|;
block|}
else|else
block|{
comment|/*                  * don't include tmp_wNAF directly into wNAF array - use wNAF                  * splitting and include the blocks                  */
name|signed
name|char
modifier|*
name|pp
decl_stmt|;
name|EC_POINT
modifier|*
modifier|*
name|tmp_points
decl_stmt|;
if|if
condition|(
name|tmp_len
operator|<
name|numblocks
operator|*
name|blocksize
condition|)
block|{
comment|/*                      * possibly we can do with fewer blocks than estimated                      */
name|numblocks
operator|=
operator|(
name|tmp_len
operator|+
name|blocksize
operator|-
literal|1
operator|)
operator|/
name|blocksize
expr_stmt|;
if|if
condition|(
name|numblocks
operator|>
name|pre_comp
operator|->
name|numblocks
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_MUL
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|totalnum
operator|=
name|num
operator|+
name|numblocks
expr_stmt|;
block|}
comment|/* split wNAF in 'numblocks' parts */
name|pp
operator|=
name|tmp_wNAF
expr_stmt|;
name|tmp_points
operator|=
name|pre_comp
operator|->
name|points
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num
init|;
name|i
operator|<
name|totalnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|totalnum
operator|-
literal|1
condition|)
block|{
name|wNAF_len
index|[
name|i
index|]
operator|=
name|blocksize
expr_stmt|;
if|if
condition|(
name|tmp_len
operator|<
name|blocksize
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_MUL
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|tmp_len
operator|-=
name|blocksize
expr_stmt|;
block|}
else|else
comment|/*                          * last block gets whatever is left (this could be                          * more or less than 'blocksize'!)                          */
name|wNAF_len
index|[
name|i
index|]
operator|=
name|tmp_len
expr_stmt|;
name|wNAF
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|wNAF
index|[
name|i
index|]
operator|=
name|OPENSSL_malloc
argument_list|(
name|wNAF_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wNAF
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_MUL
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|tmp_wNAF
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|memcpy
argument_list|(
name|wNAF
index|[
name|i
index|]
argument_list|,
name|pp
argument_list|,
name|wNAF_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wNAF_len
index|[
name|i
index|]
operator|>
name|max_len
condition|)
name|max_len
operator|=
name|wNAF_len
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|tmp_points
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_MUL
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|tmp_wNAF
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|val_sub
index|[
name|i
index|]
operator|=
name|tmp_points
expr_stmt|;
name|tmp_points
operator|+=
name|pre_points_per_block
expr_stmt|;
name|pp
operator|+=
name|blocksize
expr_stmt|;
block|}
name|OPENSSL_free
argument_list|(
name|tmp_wNAF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * All points we precompute now go into a single array 'val'.      * 'val_sub[i]' is a pointer to the subarray for the i-th point, or to a      * subarray of 'pre_comp->points' if we already have precomputation.      */
name|val
operator|=
name|OPENSSL_malloc
argument_list|(
operator|(
name|num_val
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_MUL
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|val
index|[
name|num_val
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* pivot element */
comment|/* allocate points for precomputation */
name|v
operator|=
name|val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
operator|+
name|num_scalar
condition|;
name|i
operator|++
control|)
block|{
name|val_sub
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
operator|(
name|size_t
operator|)
literal|1
operator|<<
operator|(
name|wsize
index|[
name|i
index|]
operator|-
literal|1
operator|)
operator|)
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|v
operator|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|v
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|v
operator|==
name|val
operator|+
name|num_val
operator|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_MUL
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|tmp
operator|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
comment|/*-      * prepare precomputed values:      *    val_sub[i][0] :=     points[i]      *    val_sub[i][1] := 3 * points[i]      *    val_sub[i][2] := 5 * points[i]      *    ...      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
operator|+
name|num_scalar
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|num
condition|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_copy
argument_list|(
name|val_sub
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|points
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|EC_POINT_copy
argument_list|(
name|val_sub
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|generator
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|wsize
index|[
name|i
index|]
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_dbl
argument_list|(
name|group
argument_list|,
name|tmp
argument_list|,
name|val_sub
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
operator|(
operator|(
name|size_t
operator|)
literal|1
operator|<<
operator|(
name|wsize
index|[
name|i
index|]
operator|-
literal|1
operator|)
operator|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_add
argument_list|(
name|group
argument_list|,
name|val_sub
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|val_sub
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
argument_list|,
name|tmp
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
block|}
if|#
directive|if
literal|1
comment|/* optional; EC_window_bits_for_scalar_size                                  * assumes we do this step */
if|if
condition|(
operator|!
name|EC_POINTs_make_affine
argument_list|(
name|group
argument_list|,
name|num_val
argument_list|,
name|val
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
endif|#
directive|endif
name|r_is_at_infinity
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
name|max_len
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|r_is_at_infinity
condition|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_dbl
argument_list|(
name|group
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wNAF_len
index|[
name|i
index|]
operator|>
operator|(
name|size_t
operator|)
name|k
condition|)
block|{
name|int
name|digit
init|=
name|wNAF
index|[
name|i
index|]
index|[
name|k
index|]
decl_stmt|;
name|int
name|is_neg
decl_stmt|;
if|if
condition|(
name|digit
condition|)
block|{
name|is_neg
operator|=
name|digit
operator|<
literal|0
expr_stmt|;
if|if
condition|(
name|is_neg
condition|)
name|digit
operator|=
operator|-
name|digit
expr_stmt|;
if|if
condition|(
name|is_neg
operator|!=
name|r_is_inverted
condition|)
block|{
if|if
condition|(
operator|!
name|r_is_at_infinity
condition|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_invert
argument_list|(
name|group
argument_list|,
name|r
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
name|r_is_inverted
operator|=
operator|!
name|r_is_inverted
expr_stmt|;
block|}
comment|/* digit> 0 */
if|if
condition|(
name|r_is_at_infinity
condition|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_copy
argument_list|(
name|r
argument_list|,
name|val_sub
index|[
name|i
index|]
index|[
name|digit
operator|>>
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|r_is_at_infinity
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|EC_POINT_add
argument_list|(
name|group
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|val_sub
index|[
name|i
index|]
index|[
name|digit
operator|>>
literal|1
index|]
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|r_is_at_infinity
condition|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_set_to_infinity
argument_list|(
name|group
argument_list|,
name|r
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
name|r_is_inverted
condition|)
if|if
condition|(
operator|!
name|EC_POINT_invert
argument_list|(
name|group
argument_list|,
name|r
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
name|EC_POINT_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wsize
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|wsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|wNAF_len
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|wNAF_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|wNAF
operator|!=
name|NULL
condition|)
block|{
name|signed
name|char
modifier|*
modifier|*
name|w
decl_stmt|;
for|for
control|(
name|w
operator|=
name|wNAF
init|;
operator|*
name|w
operator|!=
name|NULL
condition|;
name|w
operator|++
control|)
name|OPENSSL_free
argument_list|(
operator|*
name|w
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|wNAF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|v
operator|=
name|val
init|;
operator|*
name|v
operator|!=
name|NULL
condition|;
name|v
operator|++
control|)
name|EC_POINT_clear_free
argument_list|(
operator|*
name|v
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val_sub
operator|!=
name|NULL
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|val_sub
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*-  * ec_wNAF_precompute_mult()  * creates an EC_PRE_COMP object with preprecomputed multiples of the generator  * for use with wNAF splitting as implemented in ec_wNAF_mul().  *  * 'pre_comp->points' is an array of multiples of the generator  * of the following form:  * points[0] =     generator;  * points[1] = 3 * generator;  * ...  * points[2^(w-1)-1] =     (2^(w-1)-1) * generator;  * points[2^(w-1)]   =     2^blocksize * generator;  * points[2^(w-1)+1] = 3 * 2^blocksize * generator;  * ...  * points[2^(w-1)*(numblocks-1)-1] = (2^(w-1)) *  2^(blocksize*(numblocks-2)) * generator  * points[2^(w-1)*(numblocks-1)]   =              2^(blocksize*(numblocks-1)) * generator  * ...  * points[2^(w-1)*numblocks-1]     = (2^(w-1)) *  2^(blocksize*(numblocks-1)) * generator  * points[2^(w-1)*numblocks]       = NULL  */
end_comment

begin_function
name|int
name|ec_wNAF_precompute_mult
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|EC_POINT
modifier|*
name|generator
decl_stmt|;
name|EC_POINT
modifier|*
name|tmp_point
init|=
name|NULL
decl_stmt|,
modifier|*
name|base
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|var
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|order
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|bits
decl_stmt|,
name|w
decl_stmt|,
name|pre_points_per_block
decl_stmt|,
name|blocksize
decl_stmt|,
name|numblocks
decl_stmt|,
name|num
decl_stmt|;
name|EC_POINT
modifier|*
modifier|*
name|points
init|=
name|NULL
decl_stmt|;
name|EC_PRE_COMP
modifier|*
name|pre_comp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* if there is an old EC_PRE_COMP object, throw it away */
name|EC_EX_DATA_free_data
argument_list|(
operator|&
name|group
operator|->
name|extra_data
argument_list|,
name|ec_pre_comp_dup
argument_list|,
name|ec_pre_comp_free
argument_list|,
name|ec_pre_comp_clear_free
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pre_comp
operator|=
name|ec_pre_comp_new
argument_list|(
name|group
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|generator
operator|=
name|EC_GROUP_get0_generator
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|generator
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_PRECOMPUTE_MULT
argument_list|,
name|EC_R_UNDEFINED_GENERATOR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|order
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|EC_GROUP_get_order
argument_list|(
name|group
argument_list|,
name|order
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|BN_is_zero
argument_list|(
name|order
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_PRECOMPUTE_MULT
argument_list|,
name|EC_R_UNKNOWN_ORDER
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|bits
operator|=
name|BN_num_bits
argument_list|(
name|order
argument_list|)
expr_stmt|;
comment|/*      * The following parameters mean we precompute (approximately) one point      * per bit. TBD: The combination 8, 4 is perfect for 160 bits; for other      * bit lengths, other parameter combinations might provide better      * efficiency.      */
name|blocksize
operator|=
literal|8
expr_stmt|;
name|w
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|EC_window_bits_for_scalar_size
argument_list|(
name|bits
argument_list|)
operator|>
name|w
condition|)
block|{
comment|/* let's not make the window too small ... */
name|w
operator|=
name|EC_window_bits_for_scalar_size
argument_list|(
name|bits
argument_list|)
expr_stmt|;
block|}
name|numblocks
operator|=
operator|(
name|bits
operator|+
name|blocksize
operator|-
literal|1
operator|)
operator|/
name|blocksize
expr_stmt|;
comment|/* max. number of blocks                                                      * to use for wNAF                                                      * splitting */
name|pre_points_per_block
operator|=
operator|(
name|size_t
operator|)
literal|1
operator|<<
operator|(
name|w
operator|-
literal|1
operator|)
expr_stmt|;
name|num
operator|=
name|pre_points_per_block
operator|*
name|numblocks
expr_stmt|;
comment|/* number of points to compute                                              * and store */
name|points
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EC_POINT
operator|*
argument_list|)
operator|*
operator|(
name|num
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|points
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_PRECOMPUTE_MULT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|var
operator|=
name|points
expr_stmt|;
name|var
index|[
name|num
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* pivot */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|var
index|[
name|i
index|]
operator|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_PRECOMPUTE_MULT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|tmp_point
operator|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|base
operator|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
operator|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_PRECOMPUTE_MULT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|EC_POINT_copy
argument_list|(
name|base
argument_list|,
name|generator
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* do the precomputation */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numblocks
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|EC_POINT_dbl
argument_list|(
name|group
argument_list|,
name|tmp_point
argument_list|,
name|base
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|EC_POINT_copy
argument_list|(
operator|*
name|var
operator|++
argument_list|,
name|base
argument_list|)
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|pre_points_per_block
condition|;
name|j
operator|++
operator|,
name|var
operator|++
control|)
block|{
comment|/*              * calculate odd multiples of the current base point              */
if|if
condition|(
operator|!
name|EC_POINT_add
argument_list|(
name|group
argument_list|,
operator|*
name|var
argument_list|,
name|tmp_point
argument_list|,
operator|*
operator|(
name|var
operator|-
literal|1
operator|)
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|i
operator|<
name|numblocks
operator|-
literal|1
condition|)
block|{
comment|/*              * get the next base (multiply current one by 2^blocksize)              */
name|size_t
name|k
decl_stmt|;
if|if
condition|(
name|blocksize
operator|<=
literal|2
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_WNAF_PRECOMPUTE_MULT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|EC_POINT_dbl
argument_list|(
name|group
argument_list|,
name|base
argument_list|,
name|tmp_point
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|k
operator|=
literal|2
init|;
name|k
operator|<
name|blocksize
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_dbl
argument_list|(
name|group
argument_list|,
name|base
argument_list|,
name|base
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|EC_POINTs_make_affine
argument_list|(
name|group
argument_list|,
name|num
argument_list|,
name|points
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|pre_comp
operator|->
name|group
operator|=
name|group
expr_stmt|;
name|pre_comp
operator|->
name|blocksize
operator|=
name|blocksize
expr_stmt|;
name|pre_comp
operator|->
name|numblocks
operator|=
name|numblocks
expr_stmt|;
name|pre_comp
operator|->
name|w
operator|=
name|w
expr_stmt|;
name|pre_comp
operator|->
name|points
operator|=
name|points
expr_stmt|;
name|points
operator|=
name|NULL
expr_stmt|;
name|pre_comp
operator|->
name|num
operator|=
name|num
expr_stmt|;
if|if
condition|(
operator|!
name|EC_EX_DATA_set_data
argument_list|(
operator|&
name|group
operator|->
name|extra_data
argument_list|,
name|pre_comp
argument_list|,
name|ec_pre_comp_dup
argument_list|,
name|ec_pre_comp_free
argument_list|,
name|ec_pre_comp_clear_free
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|pre_comp
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_comp
condition|)
name|ec_pre_comp_free
argument_list|(
name|pre_comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
condition|)
block|{
name|EC_POINT
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|points
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
name|EC_POINT_free
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|points
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp_point
condition|)
name|EC_POINT_free
argument_list|(
name|tmp_point
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|EC_POINT_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_wNAF_have_precompute_mult
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
if|if
condition|(
name|EC_EX_DATA_get_data
argument_list|(
name|group
operator|->
name|extra_data
argument_list|,
name|ec_pre_comp_dup
argument_list|,
name|ec_pre_comp_free
argument_list|,
name|ec_pre_comp_clear_free
argument_list|)
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

end_unit

