begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/ec/ec_mult.c */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|"ec_lcl.h"
end_include

begin_comment
comment|/* TODO: optional precomputation of multiples of the generator */
end_comment

begin_comment
comment|/*  * wNAF-based interleaving multi-exponentation method  * (<URL:http://www.informatik.tu-darmstadt.de/TI/Mitarbeiter/moeller.html#multiexp>)  */
end_comment

begin_comment
comment|/* Determine the width-(w+1) Non-Adjacent Form (wNAF) of 'scalar'.  * This is an array  r[]  of values that are either zero or odd with an  * absolute value less than  2^w  satisfying  *     scalar = \sum_j r[j]*2^j  * where at most one of any  w+1  consecutive digits is non-zero.  */
end_comment

begin_function
specifier|static
name|signed
name|char
modifier|*
name|compute_wNAF
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|scalar
parameter_list|,
name|int
name|w
parameter_list|,
name|size_t
modifier|*
name|ret_len
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|c
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
name|signed
name|char
modifier|*
name|r
init|=
name|NULL
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|next_bit
decl_stmt|,
name|mask
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|c
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|w
operator|<=
literal|0
operator|||
name|w
operator|>
literal|7
condition|)
comment|/* 'signed char' can represent integers with absolute values less than 2^7 */
block|{
name|ECerr
argument_list|(
name|EC_F_COMPUTE_WNAF
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|bit
operator|=
literal|1
operator|<<
name|w
expr_stmt|;
comment|/* at most 128 */
name|next_bit
operator|=
name|bit
operator|<<
literal|1
expr_stmt|;
comment|/* at most 256 */
name|mask
operator|=
name|next_bit
operator|-
literal|1
expr_stmt|;
comment|/* at most 255 */
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|c
argument_list|,
name|scalar
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|c
operator|->
name|neg
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|neg
operator|=
literal|0
expr_stmt|;
block|}
name|len
operator|=
name|BN_num_bits
argument_list|(
name|c
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* wNAF may be one digit longer than binary representation */
name|r
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|BN_is_zero
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|u
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|BN_is_odd
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|d
operator|==
name|NULL
operator|||
name|c
operator|->
name|top
operator|==
literal|0
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_COMPUTE_WNAF
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|u
operator|=
name|c
operator|->
name|d
index|[
literal|0
index|]
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|u
operator|&
name|bit
condition|)
block|{
name|u
operator|-=
name|next_bit
expr_stmt|;
comment|/* u< 0 */
if|if
condition|(
operator|!
name|BN_add_word
argument_list|(
name|c
argument_list|,
operator|-
name|u
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
comment|/* u> 0 */
if|if
condition|(
operator|!
name|BN_sub_word
argument_list|(
name|c
argument_list|,
name|u
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|u
operator|<=
operator|-
name|bit
operator|||
name|u
operator|>=
name|bit
operator|||
operator|!
operator|(
name|u
operator|&
literal|1
operator|)
operator|||
name|c
operator|->
name|neg
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_COMPUTE_WNAF
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|r
index|[
name|j
operator|++
index|]
operator|=
name|sign
operator|*
name|u
expr_stmt|;
if|if
condition|(
name|BN_is_odd
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_COMPUTE_WNAF
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|BN_rshift1
argument_list|(
name|c
argument_list|,
name|c
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|j
operator|>
name|len
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_COMPUTE_WNAF
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|len
operator|=
name|j
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
operator|*
name|ret_len
operator|=
name|len
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* TODO: table should be optimised for the wNAF-based implementation,  *       sometimes smaller windows will give better performance  *       (thus the boundaries should be increased)  */
end_comment

begin_define
define|#
directive|define
name|EC_window_bits_for_scalar_size
parameter_list|(
name|b
parameter_list|)
define|\
value|((size_t) \ 		 ((b)>= 2000 ? 6 : \ 		  (b)>=  800 ? 5 : \ 		  (b)>=  300 ? 4 : \ 		  (b)>=   70 ? 3 : \ 		  (b)>=   20 ? 2 : \ 		   1))
end_define

begin_comment
comment|/* Compute  *      \sum scalars[i]*points[i],  * also including  *      scalar*generator  * in the addition if scalar != NULL  */
end_comment

begin_function
name|int
name|EC_POINTs_mul
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|scalar
parameter_list|,
name|size_t
name|num
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|points
index|[]
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|scalars
index|[]
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|EC_POINT
modifier|*
name|generator
init|=
name|NULL
decl_stmt|;
name|EC_POINT
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|size_t
name|totalnum
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|r_is_inverted
init|=
literal|0
decl_stmt|;
name|int
name|r_is_at_infinity
init|=
literal|1
decl_stmt|;
name|size_t
modifier|*
name|wsize
init|=
name|NULL
decl_stmt|;
comment|/* individual window sizes */
name|signed
name|char
modifier|*
modifier|*
name|wNAF
init|=
name|NULL
decl_stmt|;
comment|/* individual wNAFs */
name|size_t
modifier|*
name|wNAF_len
init|=
name|NULL
decl_stmt|;
name|size_t
name|max_len
init|=
literal|0
decl_stmt|;
name|size_t
name|num_val
decl_stmt|;
name|EC_POINT
modifier|*
modifier|*
name|val
init|=
name|NULL
decl_stmt|;
comment|/* precomputation */
name|EC_POINT
modifier|*
modifier|*
name|v
decl_stmt|;
name|EC_POINT
modifier|*
modifier|*
modifier|*
name|val_sub
init|=
name|NULL
decl_stmt|;
comment|/* pointers to sub-arrays of 'val' */
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|group
operator|->
name|meth
operator|!=
name|r
operator|->
name|meth
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_POINTS_MUL
argument_list|,
name|EC_R_INCOMPATIBLE_OBJECTS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|scalar
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|num
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|EC_POINT_set_to_infinity
argument_list|(
name|group
argument_list|,
name|r
argument_list|)
return|;
block|}
if|if
condition|(
name|scalar
operator|!=
name|NULL
condition|)
block|{
name|generator
operator|=
name|EC_GROUP_get0_generator
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|generator
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_POINTS_MUL
argument_list|,
name|EC_R_UNDEFINED_GENERATOR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|group
operator|->
name|meth
operator|!=
name|points
index|[
name|i
index|]
operator|->
name|meth
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_POINTS_MUL
argument_list|,
name|EC_R_INCOMPATIBLE_OBJECTS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|totalnum
operator|=
name|num
operator|+
operator|(
name|scalar
operator|!=
name|NULL
operator|)
expr_stmt|;
name|wsize
operator|=
name|OPENSSL_malloc
argument_list|(
name|totalnum
operator|*
sizeof|sizeof
name|wsize
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wNAF_len
operator|=
name|OPENSSL_malloc
argument_list|(
name|totalnum
operator|*
sizeof|sizeof
name|wNAF_len
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wNAF
operator|=
name|OPENSSL_malloc
argument_list|(
operator|(
name|totalnum
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
name|wNAF
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wNAF
operator|!=
name|NULL
condition|)
block|{
name|wNAF
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* preliminary pivot */
block|}
if|if
condition|(
name|wsize
operator|==
name|NULL
operator|||
name|wNAF_len
operator|==
name|NULL
operator|||
name|wNAF
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* num_val := total number of points to precompute */
name|num_val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalnum
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|bits
decl_stmt|;
name|bits
operator|=
name|i
operator|<
name|num
condition|?
name|BN_num_bits
argument_list|(
name|scalars
index|[
name|i
index|]
argument_list|)
else|:
name|BN_num_bits
argument_list|(
name|scalar
argument_list|)
expr_stmt|;
name|wsize
index|[
name|i
index|]
operator|=
name|EC_window_bits_for_scalar_size
argument_list|(
name|bits
argument_list|)
expr_stmt|;
name|num_val
operator|+=
literal|1u
operator|<<
operator|(
name|wsize
index|[
name|i
index|]
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* all precomputed points go into a single array 'val', 	 * 'val_sub[i]' is a pointer to the subarray for the i-th point */
name|val
operator|=
name|OPENSSL_malloc
argument_list|(
operator|(
name|num_val
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|val
index|[
name|num_val
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* pivot element */
name|val_sub
operator|=
name|OPENSSL_malloc
argument_list|(
name|totalnum
operator|*
sizeof|sizeof
name|val_sub
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|val_sub
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* allocate points for precomputation */
name|v
operator|=
name|val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalnum
condition|;
name|i
operator|++
control|)
block|{
name|val_sub
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1u
operator|<<
operator|(
name|wsize
index|[
name|i
index|]
operator|-
literal|1
operator|)
operator|)
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|v
operator|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|v
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|v
operator|==
name|val
operator|+
name|num_val
operator|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_POINTS_MUL
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
name|tmp
operator|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* prepare precomputed values: 	 *    val_sub[i][0] :=     points[i] 	 *    val_sub[i][1] := 3 * points[i] 	 *    val_sub[i][2] := 5 * points[i] 	 *    ... 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|num
condition|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_copy
argument_list|(
name|val_sub
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|points
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|EC_POINT_copy
argument_list|(
name|val_sub
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|generator
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|wsize
index|[
name|i
index|]
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_dbl
argument_list|(
name|group
argument_list|,
name|tmp
argument_list|,
name|val_sub
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
operator|(
literal|1u
operator|<<
operator|(
name|wsize
index|[
name|i
index|]
operator|-
literal|1
operator|)
operator|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_add
argument_list|(
name|group
argument_list|,
name|val_sub
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|val_sub
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
argument_list|,
name|tmp
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
name|wNAF
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* make sure we always have a pivot */
name|wNAF
index|[
name|i
index|]
operator|=
name|compute_wNAF
argument_list|(
operator|(
name|i
operator|<
name|num
condition|?
name|scalars
index|[
name|i
index|]
else|:
name|scalar
operator|)
argument_list|,
name|wsize
index|[
name|i
index|]
argument_list|,
operator|&
name|wNAF_len
index|[
name|i
index|]
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|wNAF
index|[
name|i
index|]
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|wNAF_len
index|[
name|i
index|]
operator|>
name|max_len
condition|)
name|max_len
operator|=
name|wNAF_len
index|[
name|i
index|]
expr_stmt|;
block|}
if|#
directive|if
literal|1
comment|/* optional; EC_window_bits_for_scalar_size assumes we do this step */
if|if
condition|(
operator|!
name|EC_POINTs_make_affine
argument_list|(
name|group
argument_list|,
name|num_val
argument_list|,
name|val
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
endif|#
directive|endif
name|r_is_at_infinity
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
name|max_len
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|r_is_at_infinity
condition|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_dbl
argument_list|(
name|group
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wNAF_len
index|[
name|i
index|]
operator|>
operator|(
name|size_t
operator|)
name|k
condition|)
block|{
name|int
name|digit
init|=
name|wNAF
index|[
name|i
index|]
index|[
name|k
index|]
decl_stmt|;
name|int
name|is_neg
decl_stmt|;
if|if
condition|(
name|digit
condition|)
block|{
name|is_neg
operator|=
name|digit
operator|<
literal|0
expr_stmt|;
if|if
condition|(
name|is_neg
condition|)
name|digit
operator|=
operator|-
name|digit
expr_stmt|;
if|if
condition|(
name|is_neg
operator|!=
name|r_is_inverted
condition|)
block|{
if|if
condition|(
operator|!
name|r_is_at_infinity
condition|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_invert
argument_list|(
name|group
argument_list|,
name|r
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
name|r_is_inverted
operator|=
operator|!
name|r_is_inverted
expr_stmt|;
block|}
comment|/* digit> 0 */
if|if
condition|(
name|r_is_at_infinity
condition|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_copy
argument_list|(
name|r
argument_list|,
name|val_sub
index|[
name|i
index|]
index|[
name|digit
operator|>>
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|r_is_at_infinity
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|EC_POINT_add
argument_list|(
name|group
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|val_sub
index|[
name|i
index|]
index|[
name|digit
operator|>>
literal|1
index|]
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|r_is_at_infinity
condition|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_set_to_infinity
argument_list|(
name|group
argument_list|,
name|r
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
name|r_is_inverted
condition|)
if|if
condition|(
operator|!
name|EC_POINT_invert
argument_list|(
name|group
argument_list|,
name|r
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
name|EC_POINT_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wsize
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|wsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|wNAF_len
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|wNAF_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|wNAF
operator|!=
name|NULL
condition|)
block|{
name|signed
name|char
modifier|*
modifier|*
name|w
decl_stmt|;
for|for
control|(
name|w
operator|=
name|wNAF
init|;
operator|*
name|w
operator|!=
name|NULL
condition|;
name|w
operator|++
control|)
name|OPENSSL_free
argument_list|(
operator|*
name|w
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|wNAF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|v
operator|=
name|val
init|;
operator|*
name|v
operator|!=
name|NULL
condition|;
name|v
operator|++
control|)
name|EC_POINT_clear_free
argument_list|(
operator|*
name|v
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val_sub
operator|!=
name|NULL
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|val_sub
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|EC_POINT_mul
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g_scalar
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|point
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p_scalar
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|EC_POINT
modifier|*
name|points
index|[
literal|1
index|]
decl_stmt|;
specifier|const
name|BIGNUM
modifier|*
name|scalars
index|[
literal|1
index|]
decl_stmt|;
name|points
index|[
literal|0
index|]
operator|=
name|point
expr_stmt|;
name|scalars
index|[
literal|0
index|]
operator|=
name|p_scalar
expr_stmt|;
return|return
name|EC_POINTs_mul
argument_list|(
name|group
argument_list|,
name|r
argument_list|,
name|g_scalar
argument_list|,
operator|(
name|point
operator|!=
name|NULL
operator|&&
name|p_scalar
operator|!=
name|NULL
operator|)
argument_list|,
name|points
argument_list|,
name|scalars
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|EC_GROUP_precompute_mult
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|EC_POINT
modifier|*
name|generator
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|order
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|generator
operator|=
name|EC_GROUP_get0_generator
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|generator
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GROUP_PRECOMPUTE_MULT
argument_list|,
name|EC_R_UNDEFINED_GENERATOR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|order
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|EC_GROUP_get_order
argument_list|(
name|group
argument_list|,
name|order
argument_list|,
name|ctx
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|BN_is_zero
argument_list|(
name|order
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GROUP_PRECOMPUTE_MULT
argument_list|,
name|EC_R_UNKNOWN_ORDER
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* TODO */
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

