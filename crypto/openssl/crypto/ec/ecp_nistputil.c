begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/ec/ecp_nistputil.c */
end_comment

begin_comment
comment|/*  * Written by Bodo Moeller for the OpenSSL project.  */
end_comment

begin_comment
comment|/* Copyright 2011 Google Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  *  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|<openssl/opensslconf.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC_NISTP_64_GCC_128
end_ifndef

begin_comment
comment|/*  * Common utility functions for ecp_nistp224.c, ecp_nistp256.c, ecp_nistp521.c.  */
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|"ec_lcl.h"
end_include

begin_comment
comment|/*  * Convert an array of points into affine coordinates. (If the point at  * infinity is found (Z = 0), it remains unchanged.) This function is  * essentially an equivalent to EC_POINTs_make_affine(), but works with the  * internal representation of points as used by ecp_nistp###.c rather than  * with (BIGNUM-based) EC_POINT data structures. point_array is the  * input/output buffer ('num' points in projective form, i.e. three  * coordinates each), based on an internal representation of field elements  * of size 'felem_size'. tmp_felems needs to point to a temporary array of  * 'num'+1 field elements for storage of intermediate values.  */
end_comment

begin_function
name|void
name|ec_GFp_nistp_points_make_affine_internal
parameter_list|(
name|size_t
name|num
parameter_list|,
name|void
modifier|*
name|point_array
parameter_list|,
name|size_t
name|felem_size
parameter_list|,
name|void
modifier|*
name|tmp_felems
parameter_list|,
name|void
function_decl|(
modifier|*
name|felem_one
function_decl|)
parameter_list|(
name|void
modifier|*
name|out
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|felem_is_zero
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|in
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|felem_assign
function_decl|)
parameter_list|(
name|void
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|felem_square
function_decl|)
parameter_list|(
name|void
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|felem_mul
function_decl|)
parameter_list|(
name|void
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|in1
parameter_list|,
specifier|const
name|void
modifier|*
name|in2
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|felem_inv
function_decl|)
parameter_list|(
name|void
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|felem_contract
function_decl|)
parameter_list|(
name|void
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|)
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|tmp_felem
parameter_list|(
name|I
parameter_list|)
value|(&((char *)tmp_felems)[(I) * felem_size])
define|#
directive|define
name|X
parameter_list|(
name|I
parameter_list|)
value|(&((char *)point_array)[3*(I) * felem_size])
define|#
directive|define
name|Y
parameter_list|(
name|I
parameter_list|)
value|(&((char *)point_array)[(3*(I) + 1) * felem_size])
define|#
directive|define
name|Z
parameter_list|(
name|I
parameter_list|)
value|(&((char *)point_array)[(3*(I) + 2) * felem_size])
if|if
condition|(
operator|!
name|felem_is_zero
argument_list|(
name|Z
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
name|felem_assign
argument_list|(
name|tmp_felem
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Z
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|felem_one
argument_list|(
name|tmp_felem
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|felem_is_zero
argument_list|(
name|Z
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|felem_mul
argument_list|(
name|tmp_felem
argument_list|(
name|i
argument_list|)
argument_list|,
name|tmp_felem
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|,
name|Z
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|felem_assign
argument_list|(
name|tmp_felem
argument_list|(
name|i
argument_list|)
argument_list|,
name|tmp_felem
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now each tmp_felem(i) is the product of Z(0) .. Z(i), skipping any      * zero-valued factors: if Z(i) = 0, we essentially pretend that Z(i) = 1      */
name|felem_inv
argument_list|(
name|tmp_felem
argument_list|(
name|num
operator|-
literal|1
argument_list|)
argument_list|,
name|tmp_felem
argument_list|(
name|num
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
comment|/*              * tmp_felem(i-1) is the product of Z(0) .. Z(i-1), tmp_felem(i)              * is the inverse of the product of Z(0) .. Z(i)              */
comment|/* 1/Z(i) */
name|felem_mul
argument_list|(
name|tmp_felem
argument_list|(
name|num
argument_list|)
argument_list|,
name|tmp_felem
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|,
name|tmp_felem
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|felem_assign
argument_list|(
name|tmp_felem
argument_list|(
name|num
argument_list|)
argument_list|,
name|tmp_felem
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 1/Z(0) */
if|if
condition|(
operator|!
name|felem_is_zero
argument_list|(
name|Z
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
comment|/*                  * For next iteration, replace tmp_felem(i-1) by its inverse                  */
name|felem_mul
argument_list|(
name|tmp_felem
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|,
name|tmp_felem
argument_list|(
name|i
argument_list|)
argument_list|,
name|Z
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/*              * Convert point (X, Y, Z) into affine form (X/(Z^2), Y/(Z^3), 1)              */
name|felem_square
argument_list|(
name|Z
argument_list|(
name|i
argument_list|)
argument_list|,
name|tmp_felem
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 1/(Z^2) */
name|felem_mul
argument_list|(
name|X
argument_list|(
name|i
argument_list|)
argument_list|,
name|X
argument_list|(
name|i
argument_list|)
argument_list|,
name|Z
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* X/(Z^2) */
name|felem_mul
argument_list|(
name|Z
argument_list|(
name|i
argument_list|)
argument_list|,
name|Z
argument_list|(
name|i
argument_list|)
argument_list|,
name|tmp_felem
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 1/(Z^3) */
name|felem_mul
argument_list|(
name|Y
argument_list|(
name|i
argument_list|)
argument_list|,
name|Y
argument_list|(
name|i
argument_list|)
argument_list|,
name|Z
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Y/(Z^3) */
name|felem_contract
argument_list|(
name|X
argument_list|(
name|i
argument_list|)
argument_list|,
name|X
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|felem_contract
argument_list|(
name|Y
argument_list|(
name|i
argument_list|)
argument_list|,
name|Y
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|felem_one
argument_list|(
name|Z
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
comment|/*                  * For next iteration, replace tmp_felem(i-1) by its inverse                  */
name|felem_assign
argument_list|(
name|tmp_felem
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|,
name|tmp_felem
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  * This function looks at 5+1 scalar bits (5 current, 1 adjacent less  * significant bit), and recodes them into a signed digit for use in fast point  * multiplication: the use of signed rather than unsigned digits means that  * fewer points need to be precomputed, given that point inversion is easy  * (a precomputed point dP makes -dP available as well).  *  * BACKGROUND:  *  * Signed digits for multiplication were introduced by Booth ("A signed binary  * multiplication technique", Quart. Journ. Mech. and Applied Math., vol. IV,  * pt. 2 (1951), pp. 236-240), in that case for multiplication of integers.  * Booth's original encoding did not generally improve the density of nonzero  * digits over the binary representation, and was merely meant to simplify the  * handling of signed factors given in two's complement; but it has since been  * shown to be the basis of various signed-digit representations that do have  * further advantages, including the wNAF, using the following general approach:  *  * (1) Given a binary representation  *  *       b_k  ...  b_2  b_1  b_0,  *  *     of a nonnegative integer (b_k in {0, 1}), rewrite it in digits 0, 1, -1  *     by using bit-wise subtraction as follows:  *  *        b_k b_(k-1)  ...  b_2  b_1  b_0  *      -     b_k      ...  b_3  b_2  b_1  b_0  *       -------------------------------------  *        s_k b_(k-1)  ...  s_3  s_2  s_1  s_0  *  *     A left-shift followed by subtraction of the original value yields a new  *     representation of the same value, using signed bits s_i = b_(i+1) - b_i.  *     This representation from Booth's paper has since appeared in the  *     literature under a variety of different names including "reversed binary  *     form", "alternating greedy expansion", "mutual opposite form", and  *     "sign-alternating {+-1}-representation".  *  *     An interesting property is that among the nonzero bits, values 1 and -1  *     strictly alternate.  *  * (2) Various window schemes can be applied to the Booth representation of  *     integers: for example, right-to-left sliding windows yield the wNAF  *     (a signed-digit encoding independently discovered by various researchers  *     in the 1990s), and left-to-right sliding windows yield a left-to-right  *     equivalent of the wNAF (independently discovered by various researchers  *     around 2004).  *  * To prevent leaking information through side channels in point multiplication,  * we need to recode the given integer into a regular pattern: sliding windows  * as in wNAFs won't do, we need their fixed-window equivalent -- which is a few  * decades older: we'll be using the so-called "modified Booth encoding" due to  * MacSorley ("High-speed arithmetic in binary computers", Proc. IRE, vol. 49  * (1961), pp. 67-91), in a radix-2^5 setting.  That is, we always combine five  * signed bits into a signed digit:  *  *       s_(4j + 4) s_(4j + 3) s_(4j + 2) s_(4j + 1) s_(4j)  *  * The sign-alternating property implies that the resulting digit values are  * integers from -16 to 16.  *  * Of course, we don't actually need to compute the signed digits s_i as an  * intermediate step (that's just a nice way to see how this scheme relates  * to the wNAF): a direct computation obtains the recoded digit from the  * six bits b_(4j + 4) ... b_(4j - 1).  *  * This function takes those five bits as an integer (0 .. 63), writing the  * recoded digit to *sign (0 for positive, 1 for negative) and *digit (absolute  * value, in the range 0 .. 8).  Note that this integer essentially provides the  * input bits "shifted to the left" by one position: for example, the input to  * compute the least significant recoded digit, given that there's no bit b_-1,  * has to be b_4 b_3 b_2 b_1 b_0 0.  *  */
end_comment

begin_function
name|void
name|ec_GFp_nistp_recode_scalar_bits
parameter_list|(
name|unsigned
name|char
modifier|*
name|sign
parameter_list|,
name|unsigned
name|char
modifier|*
name|digit
parameter_list|,
name|unsigned
name|char
name|in
parameter_list|)
block|{
name|unsigned
name|char
name|s
decl_stmt|,
name|d
decl_stmt|;
name|s
operator|=
operator|~
operator|(
operator|(
name|in
operator|>>
literal|5
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* sets all bits to MSB(in), 'in' seen as                                  * 6-bit value */
name|d
operator|=
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|-
name|in
operator|-
literal|1
expr_stmt|;
name|d
operator|=
operator|(
name|d
operator|&
name|s
operator|)
operator||
operator|(
name|in
operator|&
operator|~
name|s
operator|)
expr_stmt|;
name|d
operator|=
operator|(
name|d
operator|>>
literal|1
operator|)
operator|+
operator|(
name|d
operator|&
literal|1
operator|)
expr_stmt|;
operator|*
name|sign
operator|=
name|s
operator|&
literal|1
expr_stmt|;
operator|*
name|digit
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|void
modifier|*
name|dummy
init|=
operator|&
name|dummy
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

