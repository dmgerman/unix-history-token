begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/ec/ecp_nistp256.c */
end_comment

begin_comment
comment|/*  * Written by Adam Langley (Google) for the OpenSSL project  */
end_comment

begin_comment
comment|/* Copyright 2011 Google Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  *  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_comment
comment|/*  * A 64-bit implementation of the NIST P-256 elliptic curve point multiplication  *  * OpenSSL integration was taken from Emilia Kasper's work in ecp_nistp224.c.  * Otherwise based on Emilia's P224 work, which was inspired by my curve25519  * work which got its smarts from Daniel J. Bernstein's work on the same.  */
end_comment

begin_include
include|#
directive|include
file|<openssl/opensslconf.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC_NISTP_64_GCC_128
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_SYS_VMS
end_ifndef

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|"ec_lcl.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>
literal|3
operator|||
operator|(
name|__GNUC__
operator|==
literal|3
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|1
operator|)
operator|)
end_if

begin_comment
comment|/* even with gcc, the typedef won't work for 32-bit platforms */
end_comment

begin_typedef
typedef|typedef
name|__uint128_t
name|uint128_t
typedef|;
end_typedef

begin_comment
comment|/* nonstandard; implemented by gcc on 64-bit platforms */
end_comment

begin_typedef
typedef|typedef
name|__int128_t
name|int128_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"Need GCC 3.1 or later to define type uint128_t"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|uint8_t
name|u8
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint32_t
name|u32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint64_t
name|u64
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int64_t
name|s64
typedef|;
end_typedef

begin_comment
comment|/* The underlying field.  *  * P256 operates over GF(2^256-2^224+2^192+2^96-1). We can serialise an element  * of this field into 32 bytes. We call this an felem_bytearray. */
end_comment

begin_typedef
typedef|typedef
name|u8
name|felem_bytearray
index|[
literal|32
index|]
typedef|;
end_typedef

begin_comment
comment|/* These are the parameters of P256, taken from FIPS 186-3, page 86. These  * values are big-endian. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|felem_bytearray
name|nistp256_curve_params
index|[
literal|5
index|]
init|=
block|{
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
comment|/* p */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
block|,
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
comment|/* a = -3 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xfc
block|}
block|,
comment|/* b */
block|{
literal|0x5a
block|,
literal|0xc6
block|,
literal|0x35
block|,
literal|0xd8
block|,
literal|0xaa
block|,
literal|0x3a
block|,
literal|0x93
block|,
literal|0xe7
block|,
literal|0xb3
block|,
literal|0xeb
block|,
literal|0xbd
block|,
literal|0x55
block|,
literal|0x76
block|,
literal|0x98
block|,
literal|0x86
block|,
literal|0xbc
block|,
literal|0x65
block|,
literal|0x1d
block|,
literal|0x06
block|,
literal|0xb0
block|,
literal|0xcc
block|,
literal|0x53
block|,
literal|0xb0
block|,
literal|0xf6
block|,
literal|0x3b
block|,
literal|0xce
block|,
literal|0x3c
block|,
literal|0x3e
block|,
literal|0x27
block|,
literal|0xd2
block|,
literal|0x60
block|,
literal|0x4b
block|}
block|,
block|{
literal|0x6b
block|,
literal|0x17
block|,
literal|0xd1
block|,
literal|0xf2
block|,
literal|0xe1
block|,
literal|0x2c
block|,
literal|0x42
block|,
literal|0x47
block|,
comment|/* x */
literal|0xf8
block|,
literal|0xbc
block|,
literal|0xe6
block|,
literal|0xe5
block|,
literal|0x63
block|,
literal|0xa4
block|,
literal|0x40
block|,
literal|0xf2
block|,
literal|0x77
block|,
literal|0x03
block|,
literal|0x7d
block|,
literal|0x81
block|,
literal|0x2d
block|,
literal|0xeb
block|,
literal|0x33
block|,
literal|0xa0
block|,
literal|0xf4
block|,
literal|0xa1
block|,
literal|0x39
block|,
literal|0x45
block|,
literal|0xd8
block|,
literal|0x98
block|,
literal|0xc2
block|,
literal|0x96
block|}
block|,
block|{
literal|0x4f
block|,
literal|0xe3
block|,
literal|0x42
block|,
literal|0xe2
block|,
literal|0xfe
block|,
literal|0x1a
block|,
literal|0x7f
block|,
literal|0x9b
block|,
comment|/* y */
literal|0x8e
block|,
literal|0xe7
block|,
literal|0xeb
block|,
literal|0x4a
block|,
literal|0x7c
block|,
literal|0x0f
block|,
literal|0x9e
block|,
literal|0x16
block|,
literal|0x2b
block|,
literal|0xce
block|,
literal|0x33
block|,
literal|0x57
block|,
literal|0x6b
block|,
literal|0x31
block|,
literal|0x5e
block|,
literal|0xce
block|,
literal|0xcb
block|,
literal|0xb6
block|,
literal|0x40
block|,
literal|0x68
block|,
literal|0x37
block|,
literal|0xbf
block|,
literal|0x51
block|,
literal|0xf5
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The representation of field elements.  * ------------------------------------  *  * We represent field elements with either four 128-bit values, eight 128-bit  * values, or four 64-bit values. The field element represented is:  *   v[0]*2^0 + v[1]*2^64 + v[2]*2^128 + v[3]*2^192  (mod p)  * or:  *   v[0]*2^0 + v[1]*2^64 + v[2]*2^128 + ... + v[8]*2^512  (mod p)  *  * 128-bit values are called 'limbs'. Since the limbs are spaced only 64 bits  * apart, but are 128-bits wide, the most significant bits of each limb overlap  * with the least significant bits of the next.  *  * A field element with four limbs is an 'felem'. One with eight limbs is a  * 'longfelem'  *  * A field element with four, 64-bit values is called a 'smallfelem'. Small  * values are used as intermediate values before multiplication.  */
end_comment

begin_define
define|#
directive|define
name|NLIMBS
value|4
end_define

begin_typedef
typedef|typedef
name|uint128_t
name|limb
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|limb
name|felem
index|[
name|NLIMBS
index|]
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|limb
name|longfelem
index|[
name|NLIMBS
operator|*
literal|2
index|]
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|u64
name|smallfelem
index|[
name|NLIMBS
index|]
typedef|;
end_typedef

begin_comment
comment|/* This is the value of the prime as four 64-bit words, little-endian. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u64
name|kPrime
index|[
literal|4
index|]
init|=
block|{
literal|0xfffffffffffffffful
block|,
literal|0xffffffff
block|,
literal|0
block|,
literal|0xffffffff00000001ul
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u64
name|bottom63bits
init|=
literal|0x7ffffffffffffffful
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bin32_to_felem takes a little-endian byte array and converts it into felem  * form. This assumes that the CPU is little-endian. */
end_comment

begin_function
specifier|static
name|void
name|bin32_to_felem
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|u8
name|in
index|[
literal|32
index|]
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|=
operator|*
operator|(
operator|(
name|u64
operator|*
operator|)
operator|&
name|in
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
operator|*
operator|(
operator|(
name|u64
operator|*
operator|)
operator|&
name|in
index|[
literal|8
index|]
operator|)
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
operator|*
operator|(
operator|(
name|u64
operator|*
operator|)
operator|&
name|in
index|[
literal|16
index|]
operator|)
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
operator|*
operator|(
operator|(
name|u64
operator|*
operator|)
operator|&
name|in
index|[
literal|24
index|]
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* smallfelem_to_bin32 takes a smallfelem and serialises into a little endian,  * 32 byte array. This assumes that the CPU is little-endian. */
end_comment

begin_function
specifier|static
name|void
name|smallfelem_to_bin32
parameter_list|(
name|u8
name|out
index|[
literal|32
index|]
parameter_list|,
specifier|const
name|smallfelem
name|in
parameter_list|)
block|{
operator|*
operator|(
operator|(
name|u64
operator|*
operator|)
operator|&
name|out
index|[
literal|0
index|]
operator|)
operator|=
name|in
index|[
literal|0
index|]
expr_stmt|;
operator|*
operator|(
operator|(
name|u64
operator|*
operator|)
operator|&
name|out
index|[
literal|8
index|]
operator|)
operator|=
name|in
index|[
literal|1
index|]
expr_stmt|;
operator|*
operator|(
operator|(
name|u64
operator|*
operator|)
operator|&
name|out
index|[
literal|16
index|]
operator|)
operator|=
name|in
index|[
literal|2
index|]
expr_stmt|;
operator|*
operator|(
operator|(
name|u64
operator|*
operator|)
operator|&
name|out
index|[
literal|24
index|]
operator|)
operator|=
name|in
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* To preserve endianness when using BN_bn2bin and BN_bin2bn */
end_comment

begin_function
specifier|static
name|void
name|flip_endian
parameter_list|(
name|u8
modifier|*
name|out
parameter_list|,
specifier|const
name|u8
modifier|*
name|in
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|out
index|[
name|i
index|]
operator|=
name|in
index|[
name|len
operator|-
literal|1
operator|-
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* BN_to_felem converts an OpenSSL BIGNUM into an felem */
end_comment

begin_function
specifier|static
name|int
name|BN_to_felem
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|bn
parameter_list|)
block|{
name|felem_bytearray
name|b_in
decl_stmt|;
name|felem_bytearray
name|b_out
decl_stmt|;
name|unsigned
name|num_bytes
decl_stmt|;
comment|/* BN_bn2bin eats leading zeroes */
name|memset
argument_list|(
name|b_out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|b_out
argument_list|)
expr_stmt|;
name|num_bytes
operator|=
name|BN_num_bytes
argument_list|(
name|bn
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_bytes
operator|>
sizeof|sizeof
name|b_out
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_BN_TO_FELEM
argument_list|,
name|EC_R_BIGNUM_OUT_OF_RANGE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|BN_is_negative
argument_list|(
name|bn
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_BN_TO_FELEM
argument_list|,
name|EC_R_BIGNUM_OUT_OF_RANGE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|num_bytes
operator|=
name|BN_bn2bin
argument_list|(
name|bn
argument_list|,
name|b_in
argument_list|)
expr_stmt|;
name|flip_endian
argument_list|(
name|b_out
argument_list|,
name|b_in
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
name|bin32_to_felem
argument_list|(
name|out
argument_list|,
name|b_out
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* felem_to_BN converts an felem into an OpenSSL BIGNUM */
end_comment

begin_function
specifier|static
name|BIGNUM
modifier|*
name|smallfelem_to_BN
parameter_list|(
name|BIGNUM
modifier|*
name|out
parameter_list|,
specifier|const
name|smallfelem
name|in
parameter_list|)
block|{
name|felem_bytearray
name|b_in
decl_stmt|,
name|b_out
decl_stmt|;
name|smallfelem_to_bin32
argument_list|(
name|b_in
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|flip_endian
argument_list|(
name|b_out
argument_list|,
name|b_in
argument_list|,
sizeof|sizeof
name|b_out
argument_list|)
expr_stmt|;
return|return
name|BN_bin2bn
argument_list|(
name|b_out
argument_list|,
sizeof|sizeof
name|b_out
argument_list|,
name|out
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Field operations  * ---------------- */
end_comment

begin_function
specifier|static
name|void
name|smallfelem_one
parameter_list|(
name|smallfelem
name|out
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smallfelem_assign
parameter_list|(
name|smallfelem
name|out
parameter_list|,
specifier|const
name|smallfelem
name|in
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|in
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|felem_assign
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|in
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* felem_sum sets out = out + in. */
end_comment

begin_function
specifier|static
name|void
name|felem_sum
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|+=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|+=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|in
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* felem_small_sum sets out = out + in. */
end_comment

begin_function
specifier|static
name|void
name|felem_small_sum
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|smallfelem
name|in
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|+=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|+=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|in
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* felem_scalar sets out = out * scalar */
end_comment

begin_function
specifier|static
name|void
name|felem_scalar
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|u64
name|scalar
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|*=
name|scalar
expr_stmt|;
block|}
end_function

begin_comment
comment|/* longfelem_scalar sets out = out * scalar */
end_comment

begin_function
specifier|static
name|void
name|longfelem_scalar
parameter_list|(
name|longfelem
name|out
parameter_list|,
specifier|const
name|u64
name|scalar
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|7
index|]
operator|*=
name|scalar
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|two105m41m9
value|(((limb)1)<< 105) - (((limb)1)<< 41) - (((limb)1)<< 9)
end_define

begin_define
define|#
directive|define
name|two105
value|(((limb)1)<< 105)
end_define

begin_define
define|#
directive|define
name|two105m41p9
value|(((limb)1)<< 105) - (((limb)1)<< 41) + (((limb)1)<< 9)
end_define

begin_comment
comment|/* zero105 is 0 mod p */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|felem
name|zero105
init|=
block|{
name|two105m41m9
block|,
name|two105
block|,
name|two105m41p9
block|,
name|two105m41p9
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* smallfelem_neg sets |out| to |-small|  * On exit:  *   out[i]< out[i] + 2^105  */
end_comment

begin_function
specifier|static
name|void
name|smallfelem_neg
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|smallfelem
name|small
parameter_list|)
block|{
comment|/* In order to prevent underflow, we subtract from 0 mod p. */
name|out
index|[
literal|0
index|]
operator|=
name|zero105
index|[
literal|0
index|]
operator|-
name|small
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|zero105
index|[
literal|1
index|]
operator|-
name|small
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|zero105
index|[
literal|2
index|]
operator|-
name|small
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|zero105
index|[
literal|3
index|]
operator|-
name|small
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* felem_diff subtracts |in| from |out|  * On entry:  *   in[i]< 2^104  * On exit:  *   out[i]< out[i] + 2^105  */
end_comment

begin_function
specifier|static
name|void
name|felem_diff
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
comment|/* In order to prevent underflow, we add 0 mod p before subtracting. */
name|out
index|[
literal|0
index|]
operator|+=
name|zero105
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|+=
name|zero105
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
name|zero105
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|zero105
index|[
literal|3
index|]
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|-=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|-=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|-=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|-=
name|in
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|two107m43m11
value|(((limb)1)<< 107) - (((limb)1)<< 43) - (((limb)1)<< 11)
end_define

begin_define
define|#
directive|define
name|two107
value|(((limb)1)<< 107)
end_define

begin_define
define|#
directive|define
name|two107m43p11
value|(((limb)1)<< 107) - (((limb)1)<< 43) + (((limb)1)<< 11)
end_define

begin_comment
comment|/* zero107 is 0 mod p */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|felem
name|zero107
init|=
block|{
name|two107m43m11
block|,
name|two107
block|,
name|two107m43p11
block|,
name|two107m43p11
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An alternative felem_diff for larger inputs |in|  * felem_diff_zero107 subtracts |in| from |out|  * On entry:  *   in[i]< 2^106  * On exit:  *   out[i]< out[i] + 2^107  */
end_comment

begin_function
specifier|static
name|void
name|felem_diff_zero107
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
comment|/* In order to prevent underflow, we add 0 mod p before subtracting. */
name|out
index|[
literal|0
index|]
operator|+=
name|zero107
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|+=
name|zero107
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
name|zero107
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|zero107
index|[
literal|3
index|]
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|-=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|-=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|-=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|-=
name|in
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* longfelem_diff subtracts |in| from |out|  * On entry:  *   in[i]< 7*2^67  * On exit:  *   out[i]< out[i] + 2^70 + 2^40  */
end_comment

begin_function
specifier|static
name|void
name|longfelem_diff
parameter_list|(
name|longfelem
name|out
parameter_list|,
specifier|const
name|longfelem
name|in
parameter_list|)
block|{
specifier|static
specifier|const
name|limb
name|two70m8p6
init|=
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|70
operator|)
operator|-
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|6
operator|)
decl_stmt|;
specifier|static
specifier|const
name|limb
name|two70p40
init|=
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|70
operator|)
operator|+
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|40
operator|)
decl_stmt|;
specifier|static
specifier|const
name|limb
name|two70
init|=
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|70
operator|)
decl_stmt|;
specifier|static
specifier|const
name|limb
name|two70m40m38p6
init|=
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|70
operator|)
operator|-
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|40
operator|)
operator|-
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|38
operator|)
operator|+
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|6
operator|)
decl_stmt|;
specifier|static
specifier|const
name|limb
name|two70m6
init|=
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|70
operator|)
operator|-
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|6
operator|)
decl_stmt|;
comment|/* add 0 mod p to avoid underflow */
name|out
index|[
literal|0
index|]
operator|+=
name|two70m8p6
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|+=
name|two70p40
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
name|two70
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|two70m40m38p6
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|+=
name|two70m6
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|+=
name|two70m6
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|+=
name|two70m6
expr_stmt|;
name|out
index|[
literal|7
index|]
operator|+=
name|two70m6
expr_stmt|;
comment|/* in[i]< 7*2^67< 2^70 - 2^40 - 2^38 + 2^6 */
name|out
index|[
literal|0
index|]
operator|-=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|-=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|-=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|-=
name|in
index|[
literal|3
index|]
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|-=
name|in
index|[
literal|4
index|]
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|-=
name|in
index|[
literal|5
index|]
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|-=
name|in
index|[
literal|6
index|]
expr_stmt|;
name|out
index|[
literal|7
index|]
operator|-=
name|in
index|[
literal|7
index|]
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|two64m0
value|(((limb)1)<< 64) - 1
end_define

begin_define
define|#
directive|define
name|two110p32m0
value|(((limb)1)<< 110) + (((limb)1)<< 32) - 1
end_define

begin_define
define|#
directive|define
name|two64m46
value|(((limb)1)<< 64) - (((limb)1)<< 46)
end_define

begin_define
define|#
directive|define
name|two64m32
value|(((limb)1)<< 64) - (((limb)1)<< 32)
end_define

begin_comment
comment|/* zero110 is 0 mod p */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|felem
name|zero110
init|=
block|{
name|two64m0
block|,
name|two110p32m0
block|,
name|two64m46
block|,
name|two64m32
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* felem_shrink converts an felem into a smallfelem. The result isn't quite  * minimal as the value may be greater than p.  *  * On entry:  *   in[i]< 2^109  * On exit:  *   out[i]< 2^64  */
end_comment

begin_function
specifier|static
name|void
name|felem_shrink
parameter_list|(
name|smallfelem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
name|felem
name|tmp
decl_stmt|;
name|u64
name|a
decl_stmt|,
name|b
decl_stmt|,
name|mask
decl_stmt|;
name|s64
name|high
decl_stmt|,
name|low
decl_stmt|;
specifier|static
specifier|const
name|u64
name|kPrime3Test
init|=
literal|0x7fffffff00000001ul
decl_stmt|;
comment|/* 2^63 - 2^32 + 1 */
comment|/* Carry 2->3 */
name|tmp
index|[
literal|3
index|]
operator|=
name|zero110
index|[
literal|3
index|]
operator|+
name|in
index|[
literal|3
index|]
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|in
index|[
literal|2
index|]
operator|>>
literal|64
argument_list|)
operator|)
expr_stmt|;
comment|/* tmp[3]< 2^110 */
name|tmp
index|[
literal|2
index|]
operator|=
name|zero110
index|[
literal|2
index|]
operator|+
operator|(
name|u64
operator|)
name|in
index|[
literal|2
index|]
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
name|zero110
index|[
literal|0
index|]
operator|+
name|in
index|[
literal|0
index|]
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
name|zero110
index|[
literal|1
index|]
operator|+
name|in
index|[
literal|1
index|]
expr_stmt|;
comment|/* tmp[0]< 2**110, tmp[1]< 2^111, tmp[2]< 2**65 */
comment|/* We perform two partial reductions where we eliminate the 	 * high-word of tmp[3]. We don't update the other words till the end. 	 */
name|a
operator|=
name|tmp
index|[
literal|3
index|]
operator|>>
literal|64
expr_stmt|;
comment|/* a< 2^46 */
name|tmp
index|[
literal|3
index|]
operator|=
operator|(
name|u64
operator|)
name|tmp
index|[
literal|3
index|]
expr_stmt|;
name|tmp
index|[
literal|3
index|]
operator|-=
name|a
expr_stmt|;
name|tmp
index|[
literal|3
index|]
operator|+=
operator|(
operator|(
name|limb
operator|)
name|a
operator|)
operator|<<
literal|32
expr_stmt|;
comment|/* tmp[3]< 2^79 */
name|b
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|tmp
index|[
literal|3
index|]
operator|>>
literal|64
expr_stmt|;
comment|/* a< 2^15 */
name|b
operator|+=
name|a
expr_stmt|;
comment|/* b< 2^46 + 2^15< 2^47 */
name|tmp
index|[
literal|3
index|]
operator|=
operator|(
name|u64
operator|)
name|tmp
index|[
literal|3
index|]
expr_stmt|;
name|tmp
index|[
literal|3
index|]
operator|-=
name|a
expr_stmt|;
name|tmp
index|[
literal|3
index|]
operator|+=
operator|(
operator|(
name|limb
operator|)
name|a
operator|)
operator|<<
literal|32
expr_stmt|;
comment|/* tmp[3]< 2^64 + 2^47 */
comment|/* This adjusts the other two words to complete the two partial 	 * reductions. */
name|tmp
index|[
literal|0
index|]
operator|+=
name|b
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|-=
operator|(
operator|(
operator|(
name|limb
operator|)
name|b
operator|)
operator|<<
literal|32
operator|)
expr_stmt|;
comment|/* In order to make space in tmp[3] for the carry from 2 -> 3, we 	 * conditionally subtract kPrime if tmp[3] is large enough. */
name|high
operator|=
name|tmp
index|[
literal|3
index|]
operator|>>
literal|64
expr_stmt|;
comment|/* As tmp[3]< 2^65, high is either 1 or 0 */
name|high
operator|<<=
literal|63
expr_stmt|;
name|high
operator|>>=
literal|63
expr_stmt|;
comment|/* high is: 	 *   all ones   if the high word of tmp[3] is 1 	 *   all zeros  if the high word of tmp[3] if 0 */
name|low
operator|=
name|tmp
index|[
literal|3
index|]
expr_stmt|;
name|mask
operator|=
name|low
operator|>>
literal|63
expr_stmt|;
comment|/* mask is: 	 *   all ones   if the MSB of low is 1 	 *   all zeros  if the MSB of low if 0 */
name|low
operator|&=
name|bottom63bits
expr_stmt|;
name|low
operator|-=
name|kPrime3Test
expr_stmt|;
comment|/* if low was greater than kPrime3Test then the MSB is zero */
name|low
operator|=
operator|~
name|low
expr_stmt|;
name|low
operator|>>=
literal|63
expr_stmt|;
comment|/* low is: 	 *   all ones   if low was> kPrime3Test 	 *   all zeros  if low was<= kPrime3Test */
name|mask
operator|=
operator|(
name|mask
operator|&
name|low
operator|)
operator||
name|high
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator|-=
name|mask
operator|&
name|kPrime
index|[
literal|0
index|]
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|-=
name|mask
operator|&
name|kPrime
index|[
literal|1
index|]
expr_stmt|;
comment|/* kPrime[2] is zero, so omitted */
name|tmp
index|[
literal|3
index|]
operator|-=
name|mask
operator|&
name|kPrime
index|[
literal|3
index|]
expr_stmt|;
comment|/* tmp[3]< 2**64 - 2**32 + 1 */
name|tmp
index|[
literal|1
index|]
operator|+=
operator|(
call|(
name|u64
call|)
argument_list|(
name|tmp
index|[
literal|0
index|]
operator|>>
literal|64
argument_list|)
operator|)
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
operator|(
name|u64
operator|)
name|tmp
index|[
literal|0
index|]
expr_stmt|;
name|tmp
index|[
literal|2
index|]
operator|+=
operator|(
call|(
name|u64
call|)
argument_list|(
name|tmp
index|[
literal|1
index|]
operator|>>
literal|64
argument_list|)
operator|)
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
operator|(
name|u64
operator|)
name|tmp
index|[
literal|1
index|]
expr_stmt|;
name|tmp
index|[
literal|3
index|]
operator|+=
operator|(
call|(
name|u64
call|)
argument_list|(
name|tmp
index|[
literal|2
index|]
operator|>>
literal|64
argument_list|)
operator|)
expr_stmt|;
name|tmp
index|[
literal|2
index|]
operator|=
operator|(
name|u64
operator|)
name|tmp
index|[
literal|2
index|]
expr_stmt|;
comment|/* tmp[i]< 2^64 */
name|out
index|[
literal|0
index|]
operator|=
name|tmp
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|tmp
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|tmp
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|tmp
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* smallfelem_expand converts a smallfelem to an felem */
end_comment

begin_function
specifier|static
name|void
name|smallfelem_expand
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|smallfelem
name|in
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|in
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* smallfelem_square sets |out| = |small|^2  * On entry:  *   small[i]< 2^64  * On exit:  *   out[i]< 7 * 2^64< 2^67  */
end_comment

begin_function
specifier|static
name|void
name|smallfelem_square
parameter_list|(
name|longfelem
name|out
parameter_list|,
specifier|const
name|smallfelem
name|small
parameter_list|)
block|{
name|limb
name|a
decl_stmt|;
name|u64
name|high
decl_stmt|,
name|low
decl_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small
index|[
literal|0
index|]
operator|)
operator|*
name|small
index|[
literal|0
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
name|low
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small
index|[
literal|0
index|]
operator|)
operator|*
name|small
index|[
literal|1
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small
index|[
literal|0
index|]
operator|)
operator|*
name|small
index|[
literal|2
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|*=
literal|2
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small
index|[
literal|0
index|]
operator|)
operator|*
name|small
index|[
literal|3
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small
index|[
literal|1
index|]
operator|)
operator|*
name|small
index|[
literal|2
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|*=
literal|2
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|+=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small
index|[
literal|1
index|]
operator|)
operator|*
name|small
index|[
literal|1
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small
index|[
literal|1
index|]
operator|)
operator|*
name|small
index|[
literal|3
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|*=
literal|2
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small
index|[
literal|2
index|]
operator|)
operator|*
name|small
index|[
literal|3
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|*=
literal|2
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|=
name|high
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|+=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small
index|[
literal|2
index|]
operator|)
operator|*
name|small
index|[
literal|2
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|+=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small
index|[
literal|3
index|]
operator|)
operator|*
name|small
index|[
literal|3
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|7
index|]
operator|=
name|high
expr_stmt|;
block|}
end_function

begin_comment
comment|/* felem_square sets |out| = |in|^2  * On entry:  *   in[i]< 2^109  * On exit:  *   out[i]< 7 * 2^64< 2^67  */
end_comment

begin_function
specifier|static
name|void
name|felem_square
parameter_list|(
name|longfelem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
name|u64
name|small
index|[
literal|4
index|]
decl_stmt|;
name|felem_shrink
argument_list|(
name|small
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|smallfelem_square
argument_list|(
name|out
argument_list|,
name|small
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* smallfelem_mul sets |out| = |small1| * |small2|  * On entry:  *   small1[i]< 2^64  *   small2[i]< 2^64  * On exit:  *   out[i]< 7 * 2^64< 2^67  */
end_comment

begin_function
specifier|static
name|void
name|smallfelem_mul
parameter_list|(
name|longfelem
name|out
parameter_list|,
specifier|const
name|smallfelem
name|small1
parameter_list|,
specifier|const
name|smallfelem
name|small2
parameter_list|)
block|{
name|limb
name|a
decl_stmt|;
name|u64
name|high
decl_stmt|,
name|low
decl_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|0
index|]
operator|)
operator|*
name|small2
index|[
literal|0
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
name|low
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|0
index|]
operator|)
operator|*
name|small2
index|[
literal|1
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|1
index|]
operator|)
operator|*
name|small2
index|[
literal|0
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|0
index|]
operator|)
operator|*
name|small2
index|[
literal|2
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|1
index|]
operator|)
operator|*
name|small2
index|[
literal|1
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|2
index|]
operator|)
operator|*
name|small2
index|[
literal|0
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|0
index|]
operator|)
operator|*
name|small2
index|[
literal|3
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|1
index|]
operator|)
operator|*
name|small2
index|[
literal|2
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|+=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|2
index|]
operator|)
operator|*
name|small2
index|[
literal|1
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|+=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|3
index|]
operator|)
operator|*
name|small2
index|[
literal|0
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|+=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|1
index|]
operator|)
operator|*
name|small2
index|[
literal|3
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|2
index|]
operator|)
operator|*
name|small2
index|[
literal|2
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|+=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|3
index|]
operator|)
operator|*
name|small2
index|[
literal|1
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|+=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|2
index|]
operator|)
operator|*
name|small2
index|[
literal|3
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|3
index|]
operator|)
operator|*
name|small2
index|[
literal|2
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|+=
name|high
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint128_t
operator|)
name|small1
index|[
literal|3
index|]
operator|)
operator|*
name|small2
index|[
literal|3
index|]
expr_stmt|;
name|low
operator|=
name|a
expr_stmt|;
name|high
operator|=
name|a
operator|>>
literal|64
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|+=
name|low
expr_stmt|;
name|out
index|[
literal|7
index|]
operator|=
name|high
expr_stmt|;
block|}
end_function

begin_comment
comment|/* felem_mul sets |out| = |in1| * |in2|  * On entry:  *   in1[i]< 2^109  *   in2[i]< 2^109  * On exit:  *   out[i]< 7 * 2^64< 2^67  */
end_comment

begin_function
specifier|static
name|void
name|felem_mul
parameter_list|(
name|longfelem
name|out
parameter_list|,
specifier|const
name|felem
name|in1
parameter_list|,
specifier|const
name|felem
name|in2
parameter_list|)
block|{
name|smallfelem
name|small1
decl_stmt|,
name|small2
decl_stmt|;
name|felem_shrink
argument_list|(
name|small1
argument_list|,
name|in1
argument_list|)
expr_stmt|;
name|felem_shrink
argument_list|(
name|small2
argument_list|,
name|in2
argument_list|)
expr_stmt|;
name|smallfelem_mul
argument_list|(
name|out
argument_list|,
name|small1
argument_list|,
name|small2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* felem_small_mul sets |out| = |small1| * |in2|  * On entry:  *   small1[i]< 2^64  *   in2[i]< 2^109  * On exit:  *   out[i]< 7 * 2^64< 2^67  */
end_comment

begin_function
specifier|static
name|void
name|felem_small_mul
parameter_list|(
name|longfelem
name|out
parameter_list|,
specifier|const
name|smallfelem
name|small1
parameter_list|,
specifier|const
name|felem
name|in2
parameter_list|)
block|{
name|smallfelem
name|small2
decl_stmt|;
name|felem_shrink
argument_list|(
name|small2
argument_list|,
name|in2
argument_list|)
expr_stmt|;
name|smallfelem_mul
argument_list|(
name|out
argument_list|,
name|small1
argument_list|,
name|small2
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|two100m36m4
value|(((limb)1)<< 100) - (((limb)1)<< 36) - (((limb)1)<< 4)
end_define

begin_define
define|#
directive|define
name|two100
value|(((limb)1)<< 100)
end_define

begin_define
define|#
directive|define
name|two100m36p4
value|(((limb)1)<< 100) - (((limb)1)<< 36) + (((limb)1)<< 4)
end_define

begin_comment
comment|/* zero100 is 0 mod p */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|felem
name|zero100
init|=
block|{
name|two100m36m4
block|,
name|two100
block|,
name|two100m36p4
block|,
name|two100m36p4
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal function for the different flavours of felem_reduce.  * felem_reduce_ reduces the higher coefficients in[4]-in[7].  * On entry:  *   out[0]>= in[6] + 2^32*in[6] + in[7] + 2^32*in[7]   *   out[1]>= in[7] + 2^32*in[4]  *   out[2]>= in[5] + 2^32*in[5]  *   out[3]>= in[4] + 2^32*in[5] + 2^32*in[6]  * On exit:  *   out[0]<= out[0] + in[4] + 2^32*in[5]  *   out[1]<= out[1] + in[5] + 2^33*in[6]  *   out[2]<= out[2] + in[7] + 2*in[6] + 2^33*in[7]  *   out[3]<= out[3] + 2^32*in[4] + 3*in[7]  */
end_comment

begin_function
specifier|static
name|void
name|felem_reduce_
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|longfelem
name|in
parameter_list|)
block|{
name|int128_t
name|c
decl_stmt|;
comment|/* combine common terms from below */
name|c
operator|=
name|in
index|[
literal|4
index|]
operator|+
operator|(
name|in
index|[
literal|5
index|]
operator|<<
literal|32
operator|)
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|+=
name|c
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|-=
name|c
expr_stmt|;
name|c
operator|=
name|in
index|[
literal|5
index|]
operator|-
name|in
index|[
literal|7
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|+=
name|c
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|-=
name|c
expr_stmt|;
comment|/* the remaining terms */
comment|/* 256: [(0,1),(96,-1),(192,-1),(224,1)] */
name|out
index|[
literal|1
index|]
operator|-=
operator|(
name|in
index|[
literal|4
index|]
operator|<<
literal|32
operator|)
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
operator|(
name|in
index|[
literal|4
index|]
operator|<<
literal|32
operator|)
expr_stmt|;
comment|/* 320: [(32,1),(64,1),(128,-1),(160,-1),(224,-1)] */
name|out
index|[
literal|2
index|]
operator|-=
operator|(
name|in
index|[
literal|5
index|]
operator|<<
literal|32
operator|)
expr_stmt|;
comment|/* 384: [(0,-1),(32,-1),(96,2),(128,2),(224,-1)] */
name|out
index|[
literal|0
index|]
operator|-=
name|in
index|[
literal|6
index|]
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|-=
operator|(
name|in
index|[
literal|6
index|]
operator|<<
literal|32
operator|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|+=
operator|(
name|in
index|[
literal|6
index|]
operator|<<
literal|33
operator|)
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
operator|(
name|in
index|[
literal|6
index|]
operator|*
literal|2
operator|)
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|-=
operator|(
name|in
index|[
literal|6
index|]
operator|<<
literal|32
operator|)
expr_stmt|;
comment|/* 448: [(0,-1),(32,-1),(64,-1),(128,1),(160,2),(192,3)] */
name|out
index|[
literal|0
index|]
operator|-=
name|in
index|[
literal|7
index|]
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|-=
operator|(
name|in
index|[
literal|7
index|]
operator|<<
literal|32
operator|)
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
operator|(
name|in
index|[
literal|7
index|]
operator|<<
literal|33
operator|)
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
operator|(
name|in
index|[
literal|7
index|]
operator|*
literal|3
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* felem_reduce converts a longfelem into an felem.  * To be called directly after felem_square or felem_mul.  * On entry:  *   in[0]< 2^64, in[1]< 3*2^64, in[2]< 5*2^64, in[3]< 7*2^64  *   in[4]< 7*2^64, in[5]< 5*2^64, in[6]< 3*2^64, in[7]< 2*64  * On exit:  *   out[i]< 2^101  */
end_comment

begin_function
specifier|static
name|void
name|felem_reduce
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|longfelem
name|in
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|=
name|zero100
index|[
literal|0
index|]
operator|+
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|zero100
index|[
literal|1
index|]
operator|+
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|zero100
index|[
literal|2
index|]
operator|+
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|zero100
index|[
literal|3
index|]
operator|+
name|in
index|[
literal|3
index|]
expr_stmt|;
name|felem_reduce_
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
expr_stmt|;
comment|/* out[0]> 2^100 - 2^36 - 2^4 - 3*2^64 - 3*2^96 - 2^64 - 2^96> 0 	 * out[1]> 2^100 - 2^64 - 7*2^96> 0 	 * out[2]> 2^100 - 2^36 + 2^4 - 5*2^64 - 5*2^96> 0 	 * out[3]> 2^100 - 2^36 + 2^4 - 7*2^64 - 5*2^96 - 3*2^96> 0 	 * 	 * out[0]< 2^100 + 2^64 + 7*2^64 + 5*2^96< 2^101 	 * out[1]< 2^100 + 3*2^64 + 5*2^64 + 3*2^97< 2^101 	 * out[2]< 2^100 + 5*2^64 + 2^64 + 3*2^65 + 2^97< 2^101 	 * out[3]< 2^100 + 7*2^64 + 7*2^96 + 3*2^64< 2^101 	 */
block|}
end_function

begin_comment
comment|/* felem_reduce_zero105 converts a larger longfelem into an felem.  * On entry:  *   in[0]< 2^71  * On exit:  *   out[i]< 2^106  */
end_comment

begin_function
specifier|static
name|void
name|felem_reduce_zero105
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|longfelem
name|in
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|=
name|zero105
index|[
literal|0
index|]
operator|+
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|zero105
index|[
literal|1
index|]
operator|+
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|zero105
index|[
literal|2
index|]
operator|+
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|zero105
index|[
literal|3
index|]
operator|+
name|in
index|[
literal|3
index|]
expr_stmt|;
name|felem_reduce_
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
expr_stmt|;
comment|/* out[0]> 2^105 - 2^41 - 2^9 - 2^71 - 2^103 - 2^71 - 2^103> 0 	 * out[1]> 2^105 - 2^71 - 2^103> 0 	 * out[2]> 2^105 - 2^41 + 2^9 - 2^71 - 2^103> 0 	 * out[3]> 2^105 - 2^41 + 2^9 - 2^71 - 2^103 - 2^103> 0 	 * 	 * out[0]< 2^105 + 2^71 + 2^71 + 2^103< 2^106 	 * out[1]< 2^105 + 2^71 + 2^71 + 2^103< 2^106 	 * out[2]< 2^105 + 2^71 + 2^71 + 2^71 + 2^103< 2^106 	 * out[3]< 2^105 + 2^71 + 2^103 + 2^71< 2^106 	 */
block|}
end_function

begin_comment
comment|/* subtract_u64 sets *result = *result - v and *carry to one if the subtraction  * underflowed. */
end_comment

begin_function
specifier|static
name|void
name|subtract_u64
parameter_list|(
name|u64
modifier|*
name|result
parameter_list|,
name|u64
modifier|*
name|carry
parameter_list|,
name|u64
name|v
parameter_list|)
block|{
name|uint128_t
name|r
init|=
operator|*
name|result
decl_stmt|;
name|r
operator|-=
name|v
expr_stmt|;
operator|*
name|carry
operator|=
operator|(
name|r
operator|>>
literal|64
operator|)
operator|&
literal|1
expr_stmt|;
operator|*
name|result
operator|=
operator|(
name|u64
operator|)
name|r
expr_stmt|;
block|}
end_function

begin_comment
comment|/* felem_contract converts |in| to its unique, minimal representation.  * On entry:  *   in[i]< 2^109  */
end_comment

begin_function
specifier|static
name|void
name|felem_contract
parameter_list|(
name|smallfelem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|u64
name|all_equal_so_far
init|=
literal|0
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|,
name|carry
decl_stmt|;
name|felem_shrink
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
expr_stmt|;
comment|/* small is minimal except that the value might be> p */
name|all_equal_so_far
operator|--
expr_stmt|;
comment|/* We are doing a constant time test if out>= kPrime. We need to 	 * compare each u64, from most-significant to least significant. For 	 * each one, if all words so far have been equal (m is all ones) then a 	 * non-equal result is the answer. Otherwise we continue. */
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|--
control|)
block|{
name|u64
name|equal
decl_stmt|;
name|uint128_t
name|a
init|=
operator|(
operator|(
name|uint128_t
operator|)
name|kPrime
index|[
name|i
index|]
operator|)
operator|-
name|out
index|[
name|i
index|]
decl_stmt|;
comment|/* if out[i]> kPrime[i] then a will underflow and the high 		 * 64-bits will all be set. */
name|result
operator||=
name|all_equal_so_far
operator|&
operator|(
call|(
name|u64
call|)
argument_list|(
name|a
operator|>>
literal|64
argument_list|)
operator|)
expr_stmt|;
comment|/* if kPrime[i] == out[i] then |equal| will be all zeros and 		 * the decrement will make it all ones. */
name|equal
operator|=
name|kPrime
index|[
name|i
index|]
operator|^
name|out
index|[
name|i
index|]
expr_stmt|;
name|equal
operator|--
expr_stmt|;
name|equal
operator|&=
name|equal
operator|<<
literal|32
expr_stmt|;
name|equal
operator|&=
name|equal
operator|<<
literal|16
expr_stmt|;
name|equal
operator|&=
name|equal
operator|<<
literal|8
expr_stmt|;
name|equal
operator|&=
name|equal
operator|<<
literal|4
expr_stmt|;
name|equal
operator|&=
name|equal
operator|<<
literal|2
expr_stmt|;
name|equal
operator|&=
name|equal
operator|<<
literal|1
expr_stmt|;
name|equal
operator|=
operator|(
operator|(
name|s64
operator|)
name|equal
operator|)
operator|>>
literal|63
expr_stmt|;
name|all_equal_so_far
operator|&=
name|equal
expr_stmt|;
block|}
comment|/* if all_equal_so_far is still all ones then the two values are equal 	 * and so out>= kPrime is true. */
name|result
operator||=
name|all_equal_so_far
expr_stmt|;
comment|/* if out>= kPrime then we subtract kPrime. */
name|subtract_u64
argument_list|(
operator|&
name|out
index|[
literal|0
index|]
argument_list|,
operator|&
name|carry
argument_list|,
name|result
operator|&
name|kPrime
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|subtract_u64
argument_list|(
operator|&
name|out
index|[
literal|1
index|]
argument_list|,
operator|&
name|carry
argument_list|,
name|carry
argument_list|)
expr_stmt|;
name|subtract_u64
argument_list|(
operator|&
name|out
index|[
literal|2
index|]
argument_list|,
operator|&
name|carry
argument_list|,
name|carry
argument_list|)
expr_stmt|;
name|subtract_u64
argument_list|(
operator|&
name|out
index|[
literal|3
index|]
argument_list|,
operator|&
name|carry
argument_list|,
name|carry
argument_list|)
expr_stmt|;
name|subtract_u64
argument_list|(
operator|&
name|out
index|[
literal|1
index|]
argument_list|,
operator|&
name|carry
argument_list|,
name|result
operator|&
name|kPrime
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|subtract_u64
argument_list|(
operator|&
name|out
index|[
literal|2
index|]
argument_list|,
operator|&
name|carry
argument_list|,
name|carry
argument_list|)
expr_stmt|;
name|subtract_u64
argument_list|(
operator|&
name|out
index|[
literal|3
index|]
argument_list|,
operator|&
name|carry
argument_list|,
name|carry
argument_list|)
expr_stmt|;
name|subtract_u64
argument_list|(
operator|&
name|out
index|[
literal|2
index|]
argument_list|,
operator|&
name|carry
argument_list|,
name|result
operator|&
name|kPrime
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|subtract_u64
argument_list|(
operator|&
name|out
index|[
literal|3
index|]
argument_list|,
operator|&
name|carry
argument_list|,
name|carry
argument_list|)
expr_stmt|;
name|subtract_u64
argument_list|(
operator|&
name|out
index|[
literal|3
index|]
argument_list|,
operator|&
name|carry
argument_list|,
name|result
operator|&
name|kPrime
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smallfelem_square_contract
parameter_list|(
name|smallfelem
name|out
parameter_list|,
specifier|const
name|smallfelem
name|in
parameter_list|)
block|{
name|longfelem
name|longtmp
decl_stmt|;
name|felem
name|tmp
decl_stmt|;
name|smallfelem_square
argument_list|(
name|longtmp
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|tmp
argument_list|,
name|longtmp
argument_list|)
expr_stmt|;
name|felem_contract
argument_list|(
name|out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smallfelem_mul_contract
parameter_list|(
name|smallfelem
name|out
parameter_list|,
specifier|const
name|smallfelem
name|in1
parameter_list|,
specifier|const
name|smallfelem
name|in2
parameter_list|)
block|{
name|longfelem
name|longtmp
decl_stmt|;
name|felem
name|tmp
decl_stmt|;
name|smallfelem_mul
argument_list|(
name|longtmp
argument_list|,
name|in1
argument_list|,
name|in2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|tmp
argument_list|,
name|longtmp
argument_list|)
expr_stmt|;
name|felem_contract
argument_list|(
name|out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* felem_is_zero returns a limb with all bits set if |in| == 0 (mod p) and 0  * otherwise.  * On entry:  *   small[i]< 2^64  */
end_comment

begin_function
specifier|static
name|limb
name|smallfelem_is_zero
parameter_list|(
specifier|const
name|smallfelem
name|small
parameter_list|)
block|{
name|limb
name|result
decl_stmt|;
name|u64
name|is_p
decl_stmt|;
name|u64
name|is_zero
init|=
name|small
index|[
literal|0
index|]
operator||
name|small
index|[
literal|1
index|]
operator||
name|small
index|[
literal|2
index|]
operator||
name|small
index|[
literal|3
index|]
decl_stmt|;
name|is_zero
operator|--
expr_stmt|;
name|is_zero
operator|&=
name|is_zero
operator|<<
literal|32
expr_stmt|;
name|is_zero
operator|&=
name|is_zero
operator|<<
literal|16
expr_stmt|;
name|is_zero
operator|&=
name|is_zero
operator|<<
literal|8
expr_stmt|;
name|is_zero
operator|&=
name|is_zero
operator|<<
literal|4
expr_stmt|;
name|is_zero
operator|&=
name|is_zero
operator|<<
literal|2
expr_stmt|;
name|is_zero
operator|&=
name|is_zero
operator|<<
literal|1
expr_stmt|;
name|is_zero
operator|=
operator|(
operator|(
name|s64
operator|)
name|is_zero
operator|)
operator|>>
literal|63
expr_stmt|;
name|is_p
operator|=
operator|(
name|small
index|[
literal|0
index|]
operator|^
name|kPrime
index|[
literal|0
index|]
operator|)
operator||
operator|(
name|small
index|[
literal|1
index|]
operator|^
name|kPrime
index|[
literal|1
index|]
operator|)
operator||
operator|(
name|small
index|[
literal|2
index|]
operator|^
name|kPrime
index|[
literal|2
index|]
operator|)
operator||
operator|(
name|small
index|[
literal|3
index|]
operator|^
name|kPrime
index|[
literal|3
index|]
operator|)
expr_stmt|;
name|is_p
operator|--
expr_stmt|;
name|is_p
operator|&=
name|is_p
operator|<<
literal|32
expr_stmt|;
name|is_p
operator|&=
name|is_p
operator|<<
literal|16
expr_stmt|;
name|is_p
operator|&=
name|is_p
operator|<<
literal|8
expr_stmt|;
name|is_p
operator|&=
name|is_p
operator|<<
literal|4
expr_stmt|;
name|is_p
operator|&=
name|is_p
operator|<<
literal|2
expr_stmt|;
name|is_p
operator|&=
name|is_p
operator|<<
literal|1
expr_stmt|;
name|is_p
operator|=
operator|(
operator|(
name|s64
operator|)
name|is_p
operator|)
operator|>>
literal|63
expr_stmt|;
name|is_zero
operator||=
name|is_p
expr_stmt|;
name|result
operator|=
name|is_zero
expr_stmt|;
name|result
operator||=
operator|(
operator|(
name|limb
operator|)
name|is_zero
operator|)
operator|<<
literal|64
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smallfelem_is_zero_int
parameter_list|(
specifier|const
name|smallfelem
name|small
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|smallfelem_is_zero
argument_list|(
name|small
argument_list|)
operator|&
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* felem_inv calculates |out| = |in|^{-1}  *  * Based on Fermat's Little Theorem:  *   a^p = a (mod p)  *   a^{p-1} = 1 (mod p)  *   a^{p-2} = a^{-1} (mod p)  */
end_comment

begin_function
specifier|static
name|void
name|felem_inv
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
name|felem
name|ftmp
decl_stmt|,
name|ftmp2
decl_stmt|;
comment|/* each e_I will hold |in|^{2^I - 1} */
name|felem
name|e2
decl_stmt|,
name|e4
decl_stmt|,
name|e8
decl_stmt|,
name|e16
decl_stmt|,
name|e32
decl_stmt|,
name|e64
decl_stmt|;
name|longfelem
name|tmp
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^1 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|in
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^2 - 2^0 */
name|felem_assign
argument_list|(
name|e2
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^3 - 2^1 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^4 - 2^2 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^4 - 2^0 */
name|felem_assign
argument_list|(
name|e4
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^5 - 2^1 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^6 - 2^2 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^7 - 2^3 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^8 - 2^4 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|,
name|e4
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^8 - 2^0 */
name|felem_assign
argument_list|(
name|e8
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 2^16 - 2^8 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|,
name|e8
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^16 - 2^0 */
name|felem_assign
argument_list|(
name|e16
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 2^32 - 2^16 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|,
name|e16
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^32 - 2^0 */
name|felem_assign
argument_list|(
name|e32
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 2^64 - 2^32 */
name|felem_assign
argument_list|(
name|e64
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^64 - 2^32 + 2^0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|192
condition|;
name|i
operator|++
control|)
block|{
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 2^256 - 2^224 + 2^192 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|e64
argument_list|,
name|e32
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^64 - 2^0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 2^80 - 2^16 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|,
name|e16
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^80 - 2^0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 2^88 - 2^8 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|,
name|e8
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^88 - 2^0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 2^92 - 2^4 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|,
name|e4
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^92 - 2^0 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^93 - 2^1 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^94 - 2^2 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^94 - 2^0 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^95 - 2^1 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^96 - 2^2 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^96 - 3 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^256 - 2^224 + 2^192 + 2^96 - 3 */
block|}
end_function

begin_function
specifier|static
name|void
name|smallfelem_inv_contract
parameter_list|(
name|smallfelem
name|out
parameter_list|,
specifier|const
name|smallfelem
name|in
parameter_list|)
block|{
name|felem
name|tmp
decl_stmt|;
name|smallfelem_expand
argument_list|(
name|tmp
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|felem_inv
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|felem_contract
argument_list|(
name|out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Group operations  * ----------------  *  * Building on top of the field operations we have the operations on the  * elliptic curve group itself. Points on the curve are represented in Jacobian  * coordinates */
end_comment

begin_comment
comment|/* point_double calculates 2*(x_in, y_in, z_in)  *  * The method is taken from:  *   http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b  *  * Outputs can equal corresponding inputs, i.e., x_out == x_in is allowed.  * while x_out == y_in is not (maybe this works, but it's not tested). */
end_comment

begin_function
specifier|static
name|void
name|point_double
parameter_list|(
name|felem
name|x_out
parameter_list|,
name|felem
name|y_out
parameter_list|,
name|felem
name|z_out
parameter_list|,
specifier|const
name|felem
name|x_in
parameter_list|,
specifier|const
name|felem
name|y_in
parameter_list|,
specifier|const
name|felem
name|z_in
parameter_list|)
block|{
name|longfelem
name|tmp
decl_stmt|,
name|tmp2
decl_stmt|;
name|felem
name|delta
decl_stmt|,
name|gamma
decl_stmt|,
name|beta
decl_stmt|,
name|alpha
decl_stmt|,
name|ftmp
decl_stmt|,
name|ftmp2
decl_stmt|;
name|smallfelem
name|small1
decl_stmt|,
name|small2
decl_stmt|;
name|felem_assign
argument_list|(
name|ftmp
argument_list|,
name|x_in
argument_list|)
expr_stmt|;
comment|/* ftmp[i]< 2^106 */
name|felem_assign
argument_list|(
name|ftmp2
argument_list|,
name|x_in
argument_list|)
expr_stmt|;
comment|/* ftmp2[i]< 2^106 */
comment|/* delta = z^2 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|z_in
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|delta
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* delta[i]< 2^101 */
comment|/* gamma = y^2 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|y_in
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|gamma
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* gamma[i]< 2^101 */
name|felem_shrink
argument_list|(
name|small1
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
comment|/* beta = x*gamma */
name|felem_small_mul
argument_list|(
name|tmp
argument_list|,
name|small1
argument_list|,
name|x_in
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|beta
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* beta[i]< 2^101 */
comment|/* alpha = 3*(x-delta)*(x+delta) */
name|felem_diff
argument_list|(
name|ftmp
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* ftmp[i]< 2^105 + 2^106< 2^107 */
name|felem_sum
argument_list|(
name|ftmp2
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* ftmp2[i]< 2^105 + 2^106< 2^107 */
name|felem_scalar
argument_list|(
name|ftmp2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* ftmp2[i]< 3 * 2^107< 2^109 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* alpha[i]< 2^101 */
name|felem_shrink
argument_list|(
name|small2
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
comment|/* x' = alpha^2 - 8*beta */
name|smallfelem_square
argument_list|(
name|tmp
argument_list|,
name|small2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|x_out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|felem_assign
argument_list|(
name|ftmp
argument_list|,
name|beta
argument_list|)
expr_stmt|;
name|felem_scalar
argument_list|(
name|ftmp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* ftmp[i]< 8 * 2^101 = 2^104 */
name|felem_diff
argument_list|(
name|x_out
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
comment|/* x_out[i]< 2^105 + 2^101< 2^106 */
comment|/* z' = (y + z)^2 - gamma - delta */
name|felem_sum
argument_list|(
name|delta
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
comment|/* delta[i]< 2^101 + 2^101 = 2^102 */
name|felem_assign
argument_list|(
name|ftmp
argument_list|,
name|y_in
argument_list|)
expr_stmt|;
name|felem_sum
argument_list|(
name|ftmp
argument_list|,
name|z_in
argument_list|)
expr_stmt|;
comment|/* ftmp[i]< 2^106 + 2^106 = 2^107 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|z_out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|felem_diff
argument_list|(
name|z_out
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* z_out[i]< 2^105 + 2^101< 2^106 */
comment|/* y' = alpha*(4*beta - x') - 8*gamma^2 */
name|felem_scalar
argument_list|(
name|beta
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* beta[i]< 4 * 2^101 = 2^103 */
name|felem_diff_zero107
argument_list|(
name|beta
argument_list|,
name|x_out
argument_list|)
expr_stmt|;
comment|/* beta[i]< 2^107 + 2^103< 2^108 */
name|felem_small_mul
argument_list|(
name|tmp
argument_list|,
name|small2
argument_list|,
name|beta
argument_list|)
expr_stmt|;
comment|/* tmp[i]< 7 * 2^64< 2^67 */
name|smallfelem_square
argument_list|(
name|tmp2
argument_list|,
name|small1
argument_list|)
expr_stmt|;
comment|/* tmp2[i]< 7 * 2^64 */
name|longfelem_scalar
argument_list|(
name|tmp2
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* tmp2[i]< 8 * 7 * 2^64 = 7 * 2^67 */
name|longfelem_diff
argument_list|(
name|tmp
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
comment|/* tmp[i]< 2^67 + 2^70 + 2^40< 2^71 */
name|felem_reduce_zero105
argument_list|(
name|y_out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* y_out[i]< 2^106 */
block|}
end_function

begin_comment
comment|/* point_double_small is the same as point_double, except that it operates on  * smallfelems */
end_comment

begin_function
specifier|static
name|void
name|point_double_small
parameter_list|(
name|smallfelem
name|x_out
parameter_list|,
name|smallfelem
name|y_out
parameter_list|,
name|smallfelem
name|z_out
parameter_list|,
specifier|const
name|smallfelem
name|x_in
parameter_list|,
specifier|const
name|smallfelem
name|y_in
parameter_list|,
specifier|const
name|smallfelem
name|z_in
parameter_list|)
block|{
name|felem
name|felem_x_out
decl_stmt|,
name|felem_y_out
decl_stmt|,
name|felem_z_out
decl_stmt|;
name|felem
name|felem_x_in
decl_stmt|,
name|felem_y_in
decl_stmt|,
name|felem_z_in
decl_stmt|;
name|smallfelem_expand
argument_list|(
name|felem_x_in
argument_list|,
name|x_in
argument_list|)
expr_stmt|;
name|smallfelem_expand
argument_list|(
name|felem_y_in
argument_list|,
name|y_in
argument_list|)
expr_stmt|;
name|smallfelem_expand
argument_list|(
name|felem_z_in
argument_list|,
name|z_in
argument_list|)
expr_stmt|;
name|point_double
argument_list|(
name|felem_x_out
argument_list|,
name|felem_y_out
argument_list|,
name|felem_z_out
argument_list|,
name|felem_x_in
argument_list|,
name|felem_y_in
argument_list|,
name|felem_z_in
argument_list|)
expr_stmt|;
name|felem_shrink
argument_list|(
name|x_out
argument_list|,
name|felem_x_out
argument_list|)
expr_stmt|;
name|felem_shrink
argument_list|(
name|y_out
argument_list|,
name|felem_y_out
argument_list|)
expr_stmt|;
name|felem_shrink
argument_list|(
name|z_out
argument_list|,
name|felem_z_out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* copy_conditional copies in to out iff mask is all ones. */
end_comment

begin_function
specifier|static
name|void
name|copy_conditional
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|,
name|limb
name|mask
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NLIMBS
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|limb
name|tmp
init|=
name|mask
operator|&
operator|(
name|in
index|[
name|i
index|]
operator|^
name|out
index|[
name|i
index|]
operator|)
decl_stmt|;
name|out
index|[
name|i
index|]
operator|^=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* copy_small_conditional copies in to out iff mask is all ones. */
end_comment

begin_function
specifier|static
name|void
name|copy_small_conditional
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|smallfelem
name|in
parameter_list|,
name|limb
name|mask
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
specifier|const
name|u64
name|mask64
init|=
name|mask
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NLIMBS
condition|;
operator|++
name|i
control|)
block|{
name|out
index|[
name|i
index|]
operator|=
operator|(
call|(
name|limb
call|)
argument_list|(
name|in
index|[
name|i
index|]
operator|&
name|mask64
argument_list|)
operator|)
operator||
operator|(
name|out
index|[
name|i
index|]
operator|&
operator|~
name|mask
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* point_add calcuates (x1, y1, z1) + (x2, y2, z2)  *  * The method is taken from:  *   http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#addition-add-2007-bl,  * adapted for mixed addition (z2 = 1, or z2 = 0 for the point at infinity).  *  * This function includes a branch for checking whether the two input points  * are equal, (while not equal to the point at infinity). This case never  * happens during single point multiplication, so there is no timing leak for  * ECDH or ECDSA signing. */
end_comment

begin_function
specifier|static
name|void
name|point_add
parameter_list|(
name|felem
name|x3
parameter_list|,
name|felem
name|y3
parameter_list|,
name|felem
name|z3
parameter_list|,
specifier|const
name|felem
name|x1
parameter_list|,
specifier|const
name|felem
name|y1
parameter_list|,
specifier|const
name|felem
name|z1
parameter_list|,
specifier|const
name|int
name|mixed
parameter_list|,
specifier|const
name|smallfelem
name|x2
parameter_list|,
specifier|const
name|smallfelem
name|y2
parameter_list|,
specifier|const
name|smallfelem
name|z2
parameter_list|)
block|{
name|felem
name|ftmp
decl_stmt|,
name|ftmp2
decl_stmt|,
name|ftmp3
decl_stmt|,
name|ftmp4
decl_stmt|,
name|ftmp5
decl_stmt|,
name|ftmp6
decl_stmt|,
name|x_out
decl_stmt|,
name|y_out
decl_stmt|,
name|z_out
decl_stmt|;
name|longfelem
name|tmp
decl_stmt|,
name|tmp2
decl_stmt|;
name|smallfelem
name|small1
decl_stmt|,
name|small2
decl_stmt|,
name|small3
decl_stmt|,
name|small4
decl_stmt|,
name|small5
decl_stmt|;
name|limb
name|x_equal
decl_stmt|,
name|y_equal
decl_stmt|,
name|z1_is_zero
decl_stmt|,
name|z2_is_zero
decl_stmt|;
name|felem_shrink
argument_list|(
name|small3
argument_list|,
name|z1
argument_list|)
expr_stmt|;
name|z1_is_zero
operator|=
name|smallfelem_is_zero
argument_list|(
name|small3
argument_list|)
expr_stmt|;
name|z2_is_zero
operator|=
name|smallfelem_is_zero
argument_list|(
name|z2
argument_list|)
expr_stmt|;
comment|/* ftmp = z1z1 = z1**2 */
name|smallfelem_square
argument_list|(
name|tmp
argument_list|,
name|small3
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* ftmp[i]< 2^101 */
name|felem_shrink
argument_list|(
name|small1
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mixed
condition|)
block|{
comment|/* ftmp2 = z2z2 = z2**2 */
name|smallfelem_square
argument_list|(
name|tmp
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* ftmp2[i]< 2^101 */
name|felem_shrink
argument_list|(
name|small2
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_shrink
argument_list|(
name|small5
argument_list|,
name|x1
argument_list|)
expr_stmt|;
comment|/* u1 = ftmp3 = x1*z2z2 */
name|smallfelem_mul
argument_list|(
name|tmp
argument_list|,
name|small5
argument_list|,
name|small2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp3
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* ftmp3[i]< 2^101 */
comment|/* ftmp5 = z1 + z2 */
name|felem_assign
argument_list|(
name|ftmp5
argument_list|,
name|z1
argument_list|)
expr_stmt|;
name|felem_small_sum
argument_list|(
name|ftmp5
argument_list|,
name|z2
argument_list|)
expr_stmt|;
comment|/* ftmp5[i]< 2^107 */
comment|/* ftmp5 = (z1 + z2)**2 - (z1z1 + z2z2) = 2z1z2 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp5
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp5
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* ftmp2 = z2z2 + z1z1 */
name|felem_sum
argument_list|(
name|ftmp2
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
comment|/* ftmp2[i]< 2^101 + 2^101 = 2^102 */
name|felem_diff
argument_list|(
name|ftmp5
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
comment|/* ftmp5[i]< 2^105 + 2^101< 2^106 */
comment|/* ftmp2 = z2 * z2z2 */
name|smallfelem_mul
argument_list|(
name|tmp
argument_list|,
name|small2
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* s1 = ftmp2 = y1 * z2**3 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|y1
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp6
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* ftmp6[i]< 2^101 */
block|}
else|else
block|{
comment|/* We'll assume z2 = 1 (special case z2 = 0 is handled later) */
comment|/* u1 = ftmp3 = x1*z2z2 */
name|felem_assign
argument_list|(
name|ftmp3
argument_list|,
name|x1
argument_list|)
expr_stmt|;
comment|/* ftmp3[i]< 2^106 */
comment|/* ftmp5 = 2z1z2 */
name|felem_assign
argument_list|(
name|ftmp5
argument_list|,
name|z1
argument_list|)
expr_stmt|;
name|felem_scalar
argument_list|(
name|ftmp5
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* ftmp5[i]< 2*2^106 = 2^107 */
comment|/* s1 = ftmp2 = y1 * z2**3 */
name|felem_assign
argument_list|(
name|ftmp6
argument_list|,
name|y1
argument_list|)
expr_stmt|;
comment|/* ftmp6[i]< 2^106 */
block|}
comment|/* u2 = x2*z1z1 */
name|smallfelem_mul
argument_list|(
name|tmp
argument_list|,
name|x2
argument_list|,
name|small1
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp4
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* h = ftmp4 = u2 - u1 */
name|felem_diff_zero107
argument_list|(
name|ftmp4
argument_list|,
name|ftmp3
argument_list|)
expr_stmt|;
comment|/* ftmp4[i]< 2^107 + 2^101< 2^108 */
name|felem_shrink
argument_list|(
name|small4
argument_list|,
name|ftmp4
argument_list|)
expr_stmt|;
name|x_equal
operator|=
name|smallfelem_is_zero
argument_list|(
name|small4
argument_list|)
expr_stmt|;
comment|/* z_out = ftmp5 * h */
name|felem_small_mul
argument_list|(
name|tmp
argument_list|,
name|small4
argument_list|,
name|ftmp5
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|z_out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* z_out[i]< 2^101 */
comment|/* ftmp = z1 * z1z1 */
name|smallfelem_mul
argument_list|(
name|tmp
argument_list|,
name|small1
argument_list|,
name|small3
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* s2 = tmp = y2 * z1**3 */
name|felem_small_mul
argument_list|(
name|tmp
argument_list|,
name|y2
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp5
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* r = ftmp5 = (s2 - s1)*2 */
name|felem_diff_zero107
argument_list|(
name|ftmp5
argument_list|,
name|ftmp6
argument_list|)
expr_stmt|;
comment|/* ftmp5[i]< 2^107 + 2^107 = 2^108*/
name|felem_scalar
argument_list|(
name|ftmp5
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* ftmp5[i]< 2^109 */
name|felem_shrink
argument_list|(
name|small1
argument_list|,
name|ftmp5
argument_list|)
expr_stmt|;
name|y_equal
operator|=
name|smallfelem_is_zero
argument_list|(
name|small1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_equal
operator|&&
name|y_equal
operator|&&
operator|!
name|z1_is_zero
operator|&&
operator|!
name|z2_is_zero
condition|)
block|{
name|point_double
argument_list|(
name|x3
argument_list|,
name|y3
argument_list|,
name|z3
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|z1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* I = ftmp = (2h)**2 */
name|felem_assign
argument_list|(
name|ftmp
argument_list|,
name|ftmp4
argument_list|)
expr_stmt|;
name|felem_scalar
argument_list|(
name|ftmp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* ftmp[i]< 2*2^108 = 2^109 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* J = ftmp2 = h * I */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp4
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* V = ftmp4 = U1 * I */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp3
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp4
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* x_out = r**2 - J - 2V */
name|smallfelem_square
argument_list|(
name|tmp
argument_list|,
name|small1
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|x_out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|felem_assign
argument_list|(
name|ftmp3
argument_list|,
name|ftmp4
argument_list|)
expr_stmt|;
name|felem_scalar
argument_list|(
name|ftmp4
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|felem_sum
argument_list|(
name|ftmp4
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
comment|/* ftmp4[i]< 2*2^101 + 2^101< 2^103 */
name|felem_diff
argument_list|(
name|x_out
argument_list|,
name|ftmp4
argument_list|)
expr_stmt|;
comment|/* x_out[i]< 2^105 + 2^101 */
comment|/* y_out = r(V-x_out) - 2 * s1 * J */
name|felem_diff_zero107
argument_list|(
name|ftmp3
argument_list|,
name|x_out
argument_list|)
expr_stmt|;
comment|/* ftmp3[i]< 2^107 + 2^101< 2^108 */
name|felem_small_mul
argument_list|(
name|tmp
argument_list|,
name|small1
argument_list|,
name|ftmp3
argument_list|)
expr_stmt|;
name|felem_mul
argument_list|(
name|tmp2
argument_list|,
name|ftmp6
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|longfelem_scalar
argument_list|(
name|tmp2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* tmp2[i]< 2*2^67 = 2^68 */
name|longfelem_diff
argument_list|(
name|tmp
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
comment|/* tmp[i]< 2^67 + 2^70 + 2^40< 2^71 */
name|felem_reduce_zero105
argument_list|(
name|y_out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* y_out[i]< 2^106 */
name|copy_small_conditional
argument_list|(
name|x_out
argument_list|,
name|x2
argument_list|,
name|z1_is_zero
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|x_out
argument_list|,
name|x1
argument_list|,
name|z2_is_zero
argument_list|)
expr_stmt|;
name|copy_small_conditional
argument_list|(
name|y_out
argument_list|,
name|y2
argument_list|,
name|z1_is_zero
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|y_out
argument_list|,
name|y1
argument_list|,
name|z2_is_zero
argument_list|)
expr_stmt|;
name|copy_small_conditional
argument_list|(
name|z_out
argument_list|,
name|z2
argument_list|,
name|z1_is_zero
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|z_out
argument_list|,
name|z1
argument_list|,
name|z2_is_zero
argument_list|)
expr_stmt|;
name|felem_assign
argument_list|(
name|x3
argument_list|,
name|x_out
argument_list|)
expr_stmt|;
name|felem_assign
argument_list|(
name|y3
argument_list|,
name|y_out
argument_list|)
expr_stmt|;
name|felem_assign
argument_list|(
name|z3
argument_list|,
name|z_out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* point_add_small is the same as point_add, except that it operates on  * smallfelems */
end_comment

begin_function
specifier|static
name|void
name|point_add_small
parameter_list|(
name|smallfelem
name|x3
parameter_list|,
name|smallfelem
name|y3
parameter_list|,
name|smallfelem
name|z3
parameter_list|,
name|smallfelem
name|x1
parameter_list|,
name|smallfelem
name|y1
parameter_list|,
name|smallfelem
name|z1
parameter_list|,
name|smallfelem
name|x2
parameter_list|,
name|smallfelem
name|y2
parameter_list|,
name|smallfelem
name|z2
parameter_list|)
block|{
name|felem
name|felem_x3
decl_stmt|,
name|felem_y3
decl_stmt|,
name|felem_z3
decl_stmt|;
name|felem
name|felem_x1
decl_stmt|,
name|felem_y1
decl_stmt|,
name|felem_z1
decl_stmt|;
name|smallfelem_expand
argument_list|(
name|felem_x1
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|smallfelem_expand
argument_list|(
name|felem_y1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|smallfelem_expand
argument_list|(
name|felem_z1
argument_list|,
name|z1
argument_list|)
expr_stmt|;
name|point_add
argument_list|(
name|felem_x3
argument_list|,
name|felem_y3
argument_list|,
name|felem_z3
argument_list|,
name|felem_x1
argument_list|,
name|felem_y1
argument_list|,
name|felem_z1
argument_list|,
literal|0
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|felem_shrink
argument_list|(
name|x3
argument_list|,
name|felem_x3
argument_list|)
expr_stmt|;
name|felem_shrink
argument_list|(
name|y3
argument_list|,
name|felem_y3
argument_list|)
expr_stmt|;
name|felem_shrink
argument_list|(
name|z3
argument_list|,
name|felem_z3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Base point pre computation  * --------------------------  *  * Two different sorts of precomputed tables are used in the following code.  * Each contain various points on the curve, where each point is three field  * elements (x, y, z).  *  * For the base point table, z is usually 1 (0 for the point at infinity).  * This table has 2 * 16 elements, starting with the following:  * index | bits    | point  * ------+---------+------------------------------  *     0 | 0 0 0 0 | 0G  *     1 | 0 0 0 1 | 1G  *     2 | 0 0 1 0 | 2^64G  *     3 | 0 0 1 1 | (2^64 + 1)G  *     4 | 0 1 0 0 | 2^128G  *     5 | 0 1 0 1 | (2^128 + 1)G  *     6 | 0 1 1 0 | (2^128 + 2^64)G  *     7 | 0 1 1 1 | (2^128 + 2^64 + 1)G  *     8 | 1 0 0 0 | 2^192G  *     9 | 1 0 0 1 | (2^192 + 1)G  *    10 | 1 0 1 0 | (2^192 + 2^64)G  *    11 | 1 0 1 1 | (2^192 + 2^64 + 1)G  *    12 | 1 1 0 0 | (2^192 + 2^128)G  *    13 | 1 1 0 1 | (2^192 + 2^128 + 1)G  *    14 | 1 1 1 0 | (2^192 + 2^128 + 2^64)G  *    15 | 1 1 1 1 | (2^192 + 2^128 + 2^64 + 1)G  * followed by a copy of this with each element multiplied by 2^32.  *  * The reason for this is so that we can clock bits into four different  * locations when doing simple scalar multiplies against the base point,  * and then another four locations using the second 16 elements.  *  * Tables for other points have table[i] = iG for i in 0 .. 16. */
end_comment

begin_comment
comment|/* gmul is the table of precomputed base points */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|smallfelem
name|gmul
index|[
literal|2
index|]
index|[
literal|16
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xf4a13945d898c296
block|,
literal|0x77037d812deb33a0
block|,
literal|0xf8bce6e563a440f2
block|,
literal|0x6b17d1f2e12c4247
block|}
block|,
block|{
literal|0xcbb6406837bf51f5
block|,
literal|0x2bce33576b315ece
block|,
literal|0x8ee7eb4a7c0f9e16
block|,
literal|0x4fe342e2fe1a7f9b
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x90e75cb48e14db63
block|,
literal|0x29493baaad651f7e
block|,
literal|0x8492592e326e25de
block|,
literal|0x0fa822bc2811aaa5
block|}
block|,
block|{
literal|0xe41124545f462ee7
block|,
literal|0x34b1a65050fe82f5
block|,
literal|0x6f4ad4bcb3df188b
block|,
literal|0xbff44ae8f5dba80d
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x93391ce2097992af
block|,
literal|0xe96c98fd0d35f1fa
block|,
literal|0xb257c0de95e02789
block|,
literal|0x300a4bbc89d6726f
block|}
block|,
block|{
literal|0xaa54a291c08127a0
block|,
literal|0x5bb1eeada9d806a5
block|,
literal|0x7f1ddb25ff1e3c6f
block|,
literal|0x72aac7e0d09b4644
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x57c84fc9d789bd85
block|,
literal|0xfc35ff7dc297eac3
block|,
literal|0xfb982fd588c6766e
block|,
literal|0x447d739beedb5e67
block|}
block|,
block|{
literal|0x0c7e33c972e25b32
block|,
literal|0x3d349b95a7fae500
block|,
literal|0xe12e9d953a4aaff7
block|,
literal|0x2d4825ab834131ee
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x13949c932a1d367f
block|,
literal|0xef7fbd2b1a0a11b7
block|,
literal|0xddc6068bb91dfc60
block|,
literal|0xef9519328a9c72ff
block|}
block|,
block|{
literal|0x196035a77376d8a8
block|,
literal|0x23183b0895ca1740
block|,
literal|0xc1ee9807022c219c
block|,
literal|0x611e9fc37dbb2c9b
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xcae2b1920b57f4bc
block|,
literal|0x2936df5ec6c9bc36
block|,
literal|0x7dea6482e11238bf
block|,
literal|0x550663797b51f5d8
block|}
block|,
block|{
literal|0x44ffe216348a964c
block|,
literal|0x9fb3d576dbdefbe1
block|,
literal|0x0afa40018d9d50e5
block|,
literal|0x157164848aecb851
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xe48ecafffc5cde01
block|,
literal|0x7ccd84e70d715f26
block|,
literal|0xa2e8f483f43e4391
block|,
literal|0xeb5d7745b21141ea
block|}
block|,
block|{
literal|0xcac917e2731a3479
block|,
literal|0x85f22cfe2844b645
block|,
literal|0x0990e6a158006cee
block|,
literal|0xeafd72ebdbecc17b
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x6cf20ffb313728be
block|,
literal|0x96439591a3c6b94a
block|,
literal|0x2736ff8344315fc5
block|,
literal|0xa6d39677a7849276
block|}
block|,
block|{
literal|0xf2bab833c357f5f4
block|,
literal|0x824a920c2284059b
block|,
literal|0x66b8babd2d27ecdf
block|,
literal|0x674f84749b0b8816
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x2df48c04677c8a3e
block|,
literal|0x74e02f080203a56b
block|,
literal|0x31855f7db8c7fedb
block|,
literal|0x4e769e7672c9ddad
block|}
block|,
block|{
literal|0xa4c36165b824bbb0
block|,
literal|0xfb9ae16f3b9122a5
block|,
literal|0x1ec0057206947281
block|,
literal|0x42b99082de830663
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x6ef95150dda868b9
block|,
literal|0xd1f89e799c0ce131
block|,
literal|0x7fdc1ca008a1c478
block|,
literal|0x78878ef61c6ce04d
block|}
block|,
block|{
literal|0x9c62b9121fe0d976
block|,
literal|0x6ace570ebde08d4f
block|,
literal|0xde53142c12309def
block|,
literal|0xb6cb3f5d7b72c321
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x7f991ed2c31a3573
block|,
literal|0x5b82dd5bd54fb496
block|,
literal|0x595c5220812ffcae
block|,
literal|0x0c88bc4d716b1287
block|}
block|,
block|{
literal|0x3a57bf635f48aca8
block|,
literal|0x7c8181f4df2564f3
block|,
literal|0x18d1b5b39c04e6aa
block|,
literal|0xdd5ddea3f3901dc6
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xe96a79fb3e72ad0c
block|,
literal|0x43a0a28c42ba792f
block|,
literal|0xefe0a423083e49f3
block|,
literal|0x68f344af6b317466
block|}
block|,
block|{
literal|0xcdfe17db3fb24d4a
block|,
literal|0x668bfc2271f5c626
block|,
literal|0x604ed93c24d67ff3
block|,
literal|0x31b9c405f8540a20
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xd36b4789a2582e7f
block|,
literal|0x0d1a10144ec39c28
block|,
literal|0x663c62c3edbad7a0
block|,
literal|0x4052bf4b6f461db9
block|}
block|,
block|{
literal|0x235a27c3188d25eb
block|,
literal|0xe724f33999bfcc5b
block|,
literal|0x862be6bd71d70cc8
block|,
literal|0xfecf4d5190b0fc61
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x74346c10a1d4cfac
block|,
literal|0xafdf5cc08526a7a4
block|,
literal|0x123202a8f62bff7a
block|,
literal|0x1eddbae2c802e41a
block|}
block|,
block|{
literal|0x8fa0af2dd603f844
block|,
literal|0x36e06b7e4c701917
block|,
literal|0x0c45f45273db33a0
block|,
literal|0x43104d86560ebcfc
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x9615b5110d1d78e5
block|,
literal|0x66b0de3225c4744b
block|,
literal|0x0a4a46fb6aaf363a
block|,
literal|0xb48e26b484f7a21c
block|}
block|,
block|{
literal|0x06ebb0f621a01b2d
block|,
literal|0xc004e4048b7b0f98
block|,
literal|0x64131bcdfed6f668
block|,
literal|0xfac015404d4d3dab
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x3a5a9e22185a5943
block|,
literal|0x1ab919365c65dfb6
block|,
literal|0x21656b32262c71da
block|,
literal|0x7fe36b40af22af89
block|}
block|,
block|{
literal|0xd50d152c699ca101
block|,
literal|0x74b3d5867b8af212
block|,
literal|0x9f09f40407dca6f1
block|,
literal|0xe697d45825b63624
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xa84aa9397512218e
block|,
literal|0xe9a521b074ca0141
block|,
literal|0x57880b3a18a2e902
block|,
literal|0x4a5b506612a677a6
block|}
block|,
block|{
literal|0x0beada7a4c4f3840
block|,
literal|0x626db15419e26d9d
block|,
literal|0xc42604fbe1627d40
block|,
literal|0xeb13461ceac089f1
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xf9faed0927a43281
block|,
literal|0x5e52c4144103ecbc
block|,
literal|0xc342967aa815c857
block|,
literal|0x0781b8291c6a220a
block|}
block|,
block|{
literal|0x5a8343ceeac55f80
block|,
literal|0x88f80eeee54a05e3
block|,
literal|0x97b2a14f12916434
block|,
literal|0x690cde8df0151593
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xaee9c75df7f82f2a
block|,
literal|0x9e4c35874afdf43a
block|,
literal|0xf5622df437371326
block|,
literal|0x8a535f566ec73617
block|}
block|,
block|{
literal|0xc5f9a0ac223094b7
block|,
literal|0xcde533864c8c7669
block|,
literal|0x37e02819085a92bf
block|,
literal|0x0455c08468b08bd7
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x0c0a6e2c9477b5d9
block|,
literal|0xf9a4bf62876dc444
block|,
literal|0x5050a949b6cdc279
block|,
literal|0x06bada7ab77f8276
block|}
block|,
block|{
literal|0xc8b4aed1ea48dac9
block|,
literal|0xdebd8a4b7ea1070f
block|,
literal|0x427d49101366eb70
block|,
literal|0x5b476dfd0e6cb18a
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x7c5c3e44278c340a
block|,
literal|0x4d54606812d66f3b
block|,
literal|0x29a751b1ae23c5d8
block|,
literal|0x3e29864e8a2ec908
block|}
block|,
block|{
literal|0x142d2a6626dbb850
block|,
literal|0xad1744c4765bd780
block|,
literal|0x1f150e68e322d1ed
block|,
literal|0x239b90ea3dc31e7e
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x78c416527a53322a
block|,
literal|0x305dde6709776f8e
block|,
literal|0xdbcab759f8862ed4
block|,
literal|0x820f4dd949f72ff7
block|}
block|,
block|{
literal|0x6cc544a62b5debd4
block|,
literal|0x75be5d937b4e8cc4
block|,
literal|0x1b481b1b215c14d3
block|,
literal|0x140406ec783a05ec
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x6a703f10e895df07
block|,
literal|0xfd75f3fa01876bd8
block|,
literal|0xeb5b06e70ce08ffe
block|,
literal|0x68f6b8542783dfee
block|}
block|,
block|{
literal|0x90c76f8a78712655
block|,
literal|0xcf5293d2f310bf7f
block|,
literal|0xfbc8044dfda45028
block|,
literal|0xcbe1feba92e40ce6
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xe998ceea4396e4c1
block|,
literal|0xfc82ef0b6acea274
block|,
literal|0x230f729f2250e927
block|,
literal|0xd0b2f94d2f420109
block|}
block|,
block|{
literal|0x4305adddb38d4966
block|,
literal|0x10b838f8624c3b45
block|,
literal|0x7db2636658954e7a
block|,
literal|0x971459828b0719e5
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x4bd6b72623369fc9
block|,
literal|0x57f2929e53d0b876
block|,
literal|0xc2d5cba4f2340687
block|,
literal|0x961610004a866aba
block|}
block|,
block|{
literal|0x49997bcd2e407a5e
block|,
literal|0x69ab197d92ddcb24
block|,
literal|0x2cf1f2438fe5131c
block|,
literal|0x7acb9fadcee75e44
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x254e839423d2d4c0
block|,
literal|0xf57f0c917aea685b
block|,
literal|0xa60d880f6f75aaea
block|,
literal|0x24eb9acca333bf5b
block|}
block|,
block|{
literal|0xe3de4ccb1cda5dea
block|,
literal|0xfeef9341c51a6b4f
block|,
literal|0x743125f88bac4c4d
block|,
literal|0x69f891c5acd079cc
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xeee44b35702476b5
block|,
literal|0x7ed031a0e45c2258
block|,
literal|0xb422d1e7bd6f8514
block|,
literal|0xe51f547c5972a107
block|}
block|,
block|{
literal|0xa25bcd6fc9cf343d
block|,
literal|0x8ca922ee097c184e
block|,
literal|0xa62f98b3a9fe9a06
block|,
literal|0x1c309a2b25bb1387
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x9295dbeb1967c459
block|,
literal|0xb00148833472c98e
block|,
literal|0xc504977708011828
block|,
literal|0x20b87b8aa2c4e503
block|}
block|,
block|{
literal|0x3063175de057c277
block|,
literal|0x1bd539338fe582dd
block|,
literal|0x0d11adef5f69a044
block|,
literal|0xf5c6fa49919776be
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x8c944e760fd59e11
block|,
literal|0x3876cba1102fad5f
block|,
literal|0xa454c3fad83faa56
block|,
literal|0x1ed7d1b9332010b9
block|}
block|,
block|{
literal|0xa1011a270024b889
block|,
literal|0x05e4d0dcac0cd344
block|,
literal|0x52b520f0eb6a2a24
block|,
literal|0x3a2b03f03217257a
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xf20fc2afdf1d043d
block|,
literal|0xf330240db58d5a62
block|,
literal|0xfc7d229ca0058c3b
block|,
literal|0x15fee545c78dd9f6
block|}
block|,
block|{
literal|0x501e82885bc98cda
block|,
literal|0x41ef80e5d046ac04
block|,
literal|0x557d9f49461210fb
block|,
literal|0x4ab5b6b2b8753f81
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* select_point selects the |idx|th point from a precomputation table and  * copies it to out. */
end_comment

begin_function
specifier|static
name|void
name|select_point
parameter_list|(
specifier|const
name|u64
name|idx
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
specifier|const
name|smallfelem
name|pre_comp
index|[
literal|16
index|]
index|[
literal|3
index|]
parameter_list|,
name|smallfelem
name|out
index|[
literal|3
index|]
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u64
modifier|*
name|outlimbs
init|=
operator|&
name|out
index|[
literal|0
index|]
index|[
literal|0
index|]
decl_stmt|;
name|memset
argument_list|(
name|outlimbs
argument_list|,
literal|0
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|smallfelem
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|u64
modifier|*
name|inlimbs
init|=
operator|(
name|u64
operator|*
operator|)
operator|&
name|pre_comp
index|[
name|i
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
decl_stmt|;
name|u64
name|mask
init|=
name|i
operator|^
name|idx
decl_stmt|;
name|mask
operator||=
name|mask
operator|>>
literal|4
expr_stmt|;
name|mask
operator||=
name|mask
operator|>>
literal|2
expr_stmt|;
name|mask
operator||=
name|mask
operator|>>
literal|1
expr_stmt|;
name|mask
operator|&=
literal|1
expr_stmt|;
name|mask
operator|--
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NLIMBS
operator|*
literal|3
condition|;
name|j
operator|++
control|)
name|outlimbs
index|[
name|j
index|]
operator||=
name|inlimbs
index|[
name|j
index|]
operator|&
name|mask
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* get_bit returns the |i|th bit in |in| */
end_comment

begin_function
specifier|static
name|char
name|get_bit
parameter_list|(
specifier|const
name|felem_bytearray
name|in
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|>=
literal|256
operator|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|in
index|[
name|i
operator|>>
literal|3
index|]
operator|>>
operator|(
name|i
operator|&
literal|7
operator|)
operator|)
operator|&
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Interleaved point multiplication using precomputed point multiples:  * The small point multiples 0*P, 1*P, ..., 17*P are in pre_comp[],  * the scalars in scalars[]. If g_scalar is non-NULL, we also add this multiple  * of the generator, using certain (large) precomputed multiples in g_pre_comp.  * Output point (X, Y, Z) is stored in x_out, y_out, z_out */
end_comment

begin_function
specifier|static
name|void
name|batch_mul
parameter_list|(
name|felem
name|x_out
parameter_list|,
name|felem
name|y_out
parameter_list|,
name|felem
name|z_out
parameter_list|,
specifier|const
name|felem_bytearray
name|scalars
index|[]
parameter_list|,
specifier|const
name|unsigned
name|num_points
parameter_list|,
specifier|const
name|u8
modifier|*
name|g_scalar
parameter_list|,
specifier|const
name|int
name|mixed
parameter_list|,
specifier|const
name|smallfelem
name|pre_comp
index|[]
index|[
literal|17
index|]
index|[
literal|3
index|]
parameter_list|,
specifier|const
name|smallfelem
name|g_pre_comp
index|[
literal|2
index|]
index|[
literal|16
index|]
index|[
literal|3
index|]
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|skip
decl_stmt|;
name|unsigned
name|num
decl_stmt|,
name|gen_mul
init|=
operator|(
name|g_scalar
operator|!=
name|NULL
operator|)
decl_stmt|;
name|felem
name|nq
index|[
literal|3
index|]
decl_stmt|,
name|ftmp
decl_stmt|;
name|smallfelem
name|tmp
index|[
literal|3
index|]
decl_stmt|;
name|u64
name|bits
decl_stmt|;
name|u8
name|sign
decl_stmt|,
name|digit
decl_stmt|;
comment|/* set nq to the point at infinity */
name|memset
argument_list|(
name|nq
argument_list|,
literal|0
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|felem
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop over all scalars msb-to-lsb, interleaving additions 	 * of multiples of the generator (two in each of the last 32 rounds) 	 * and additions of other points multiples (every 5th round). 	 */
name|skip
operator|=
literal|1
expr_stmt|;
comment|/* save two point operations in the first round */
for|for
control|(
name|i
operator|=
operator|(
name|num_points
condition|?
literal|255
else|:
literal|31
operator|)
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
comment|/* double */
if|if
condition|(
operator|!
name|skip
condition|)
name|point_double
argument_list|(
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|,
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* add multiples of the generator */
if|if
condition|(
name|gen_mul
operator|&&
operator|(
name|i
operator|<=
literal|31
operator|)
condition|)
block|{
comment|/* first, look 32 bits upwards */
name|bits
operator|=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
operator|+
literal|224
argument_list|)
operator|<<
literal|3
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
operator|+
literal|160
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
operator|+
literal|96
argument_list|)
operator|<<
literal|1
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/* select the point to add, in constant time */
name|select_point
argument_list|(
name|bits
argument_list|,
literal|16
argument_list|,
name|g_pre_comp
index|[
literal|1
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
block|{
name|point_add
argument_list|(
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|,
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|,
literal|1
comment|/* mixed */
argument_list|,
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|tmp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|smallfelem_expand
argument_list|(
name|nq
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|smallfelem_expand
argument_list|(
name|nq
index|[
literal|1
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|smallfelem_expand
argument_list|(
name|nq
index|[
literal|2
index|]
argument_list|,
name|tmp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
block|}
comment|/* second, look at the current position */
name|bits
operator|=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
operator|+
literal|192
argument_list|)
operator|<<
literal|3
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
operator|+
literal|128
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
operator|+
literal|64
argument_list|)
operator|<<
literal|1
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* select the point to add, in constant time */
name|select_point
argument_list|(
name|bits
argument_list|,
literal|16
argument_list|,
name|g_pre_comp
index|[
literal|0
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|point_add
argument_list|(
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|,
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|,
literal|1
comment|/* mixed */
argument_list|,
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|tmp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* do other additions every 5 doublings */
if|if
condition|(
name|num_points
operator|&&
operator|(
name|i
operator|%
literal|5
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* loop over all scalars */
for|for
control|(
name|num
operator|=
literal|0
init|;
name|num
operator|<
name|num_points
condition|;
operator|++
name|num
control|)
block|{
name|bits
operator|=
name|get_bit
argument_list|(
name|scalars
index|[
name|num
index|]
argument_list|,
name|i
operator|+
literal|4
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|scalars
index|[
name|num
index|]
argument_list|,
name|i
operator|+
literal|3
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|scalars
index|[
name|num
index|]
argument_list|,
name|i
operator|+
literal|2
argument_list|)
operator|<<
literal|3
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|scalars
index|[
name|num
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|scalars
index|[
name|num
index|]
argument_list|,
name|i
argument_list|)
operator|<<
literal|1
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|scalars
index|[
name|num
index|]
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ec_GFp_nistp_recode_scalar_bits
argument_list|(
operator|&
name|sign
argument_list|,
operator|&
name|digit
argument_list|,
name|bits
argument_list|)
expr_stmt|;
comment|/* select the point to add or subtract, in constant time */
name|select_point
argument_list|(
name|digit
argument_list|,
literal|17
argument_list|,
name|pre_comp
index|[
name|num
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|smallfelem_neg
argument_list|(
name|ftmp
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* (X, -Y, Z) is the negative point */
name|copy_small_conditional
argument_list|(
name|ftmp
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
operator|(
operator|(
operator|(
name|limb
operator|)
name|sign
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|felem_contract
argument_list|(
name|tmp
index|[
literal|1
index|]
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
block|{
name|point_add
argument_list|(
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|,
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|,
name|mixed
argument_list|,
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|tmp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|smallfelem_expand
argument_list|(
name|nq
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|smallfelem_expand
argument_list|(
name|nq
index|[
literal|1
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|smallfelem_expand
argument_list|(
name|nq
index|[
literal|2
index|]
argument_list|,
name|tmp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
name|felem_assign
argument_list|(
name|x_out
argument_list|,
name|nq
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|felem_assign
argument_list|(
name|y_out
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|felem_assign
argument_list|(
name|z_out
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Precomputation for the group generator. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|smallfelem
name|g_pre_comp
index|[
literal|2
index|]
index|[
literal|16
index|]
index|[
literal|3
index|]
decl_stmt|;
name|int
name|references
decl_stmt|;
block|}
name|NISTP256_PRE_COMP
typedef|;
end_typedef

begin_function
specifier|const
name|EC_METHOD
modifier|*
name|EC_GFp_nistp256_method
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|EC_METHOD
name|ret
init|=
block|{
name|EC_FLAGS_DEFAULT_OCT
block|,
name|NID_X9_62_prime_field
block|,
name|ec_GFp_nistp256_group_init
block|,
name|ec_GFp_simple_group_finish
block|,
name|ec_GFp_simple_group_clear_finish
block|,
name|ec_GFp_nist_group_copy
block|,
name|ec_GFp_nistp256_group_set_curve
block|,
name|ec_GFp_simple_group_get_curve
block|,
name|ec_GFp_simple_group_get_degree
block|,
name|ec_GFp_simple_group_check_discriminant
block|,
name|ec_GFp_simple_point_init
block|,
name|ec_GFp_simple_point_finish
block|,
name|ec_GFp_simple_point_clear_finish
block|,
name|ec_GFp_simple_point_copy
block|,
name|ec_GFp_simple_point_set_to_infinity
block|,
name|ec_GFp_simple_set_Jprojective_coordinates_GFp
block|,
name|ec_GFp_simple_get_Jprojective_coordinates_GFp
block|,
name|ec_GFp_simple_point_set_affine_coordinates
block|,
name|ec_GFp_nistp256_point_get_affine_coordinates
block|,
literal|0
comment|/* point_set_compressed_coordinates */
block|,
literal|0
comment|/* point2oct */
block|,
literal|0
comment|/* oct2point */
block|,
name|ec_GFp_simple_add
block|,
name|ec_GFp_simple_dbl
block|,
name|ec_GFp_simple_invert
block|,
name|ec_GFp_simple_is_at_infinity
block|,
name|ec_GFp_simple_is_on_curve
block|,
name|ec_GFp_simple_cmp
block|,
name|ec_GFp_simple_make_affine
block|,
name|ec_GFp_simple_points_make_affine
block|,
name|ec_GFp_nistp256_points_mul
block|,
name|ec_GFp_nistp256_precompute_mult
block|,
name|ec_GFp_nistp256_have_precompute_mult
block|,
name|ec_GFp_nist_field_mul
block|,
name|ec_GFp_nist_field_sqr
block|,
literal|0
comment|/* field_div */
block|,
literal|0
comment|/* field_encode */
block|,
literal|0
comment|/* field_decode */
block|,
literal|0
comment|/* field_set_to_one */
block|}
decl_stmt|;
return|return
operator|&
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*		       FUNCTIONS TO MANAGE PRECOMPUTATION  */
end_comment

begin_function
specifier|static
name|NISTP256_PRE_COMP
modifier|*
name|nistp256_pre_comp_new
parameter_list|()
block|{
name|NISTP256_PRE_COMP
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|ret
operator|=
operator|(
name|NISTP256_PRE_COMP
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_NISTP256_PRE_COMP_NEW
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|memset
argument_list|(
name|ret
operator|->
name|g_pre_comp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
operator|->
name|g_pre_comp
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|references
operator|=
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|nistp256_pre_comp_dup
parameter_list|(
name|void
modifier|*
name|src_
parameter_list|)
block|{
name|NISTP256_PRE_COMP
modifier|*
name|src
init|=
name|src_
decl_stmt|;
comment|/* no need to actually copy, these objects never change! */
name|CRYPTO_add
argument_list|(
operator|&
name|src
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_EC_PRE_COMP
argument_list|)
expr_stmt|;
return|return
name|src_
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nistp256_pre_comp_free
parameter_list|(
name|void
modifier|*
name|pre_
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|NISTP256_PRE_COMP
modifier|*
name|pre
init|=
name|pre_
decl_stmt|;
if|if
condition|(
operator|!
name|pre
condition|)
return|return;
name|i
operator|=
name|CRYPTO_add
argument_list|(
operator|&
name|pre
operator|->
name|references
argument_list|,
operator|-
literal|1
argument_list|,
name|CRYPTO_LOCK_EC_PRE_COMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return;
name|OPENSSL_free
argument_list|(
name|pre
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nistp256_pre_comp_clear_free
parameter_list|(
name|void
modifier|*
name|pre_
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|NISTP256_PRE_COMP
modifier|*
name|pre
init|=
name|pre_
decl_stmt|;
if|if
condition|(
operator|!
name|pre
condition|)
return|return;
name|i
operator|=
name|CRYPTO_add
argument_list|(
operator|&
name|pre
operator|->
name|references
argument_list|,
operator|-
literal|1
argument_list|,
name|CRYPTO_LOCK_EC_PRE_COMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return;
name|OPENSSL_cleanse
argument_list|(
name|pre
argument_list|,
sizeof|sizeof
expr|*
name|pre
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|pre
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*			   OPENSSL EC_METHOD FUNCTIONS  */
end_comment

begin_function
name|int
name|ec_GFp_nistp256_group_init
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|ec_GFp_simple_group_init
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|group
operator|->
name|a_is_minus3
operator|=
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_nistp256_group_set_curve
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|curve_p
decl_stmt|,
modifier|*
name|curve_a
decl_stmt|,
modifier|*
name|curve_b
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|curve_p
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|curve_a
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|curve_b
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|err
goto|;
name|BN_bin2bn
argument_list|(
name|nistp256_curve_params
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|felem_bytearray
argument_list|)
argument_list|,
name|curve_p
argument_list|)
expr_stmt|;
name|BN_bin2bn
argument_list|(
name|nistp256_curve_params
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|felem_bytearray
argument_list|)
argument_list|,
name|curve_a
argument_list|)
expr_stmt|;
name|BN_bin2bn
argument_list|(
name|nistp256_curve_params
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|felem_bytearray
argument_list|)
argument_list|,
name|curve_b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BN_cmp
argument_list|(
name|curve_p
argument_list|,
name|p
argument_list|)
operator|)
operator|||
operator|(
name|BN_cmp
argument_list|(
name|curve_a
argument_list|,
name|a
argument_list|)
operator|)
operator|||
operator|(
name|BN_cmp
argument_list|(
name|curve_b
argument_list|,
name|b
argument_list|)
operator|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP256_GROUP_SET_CURVE
argument_list|,
name|EC_R_WRONG_CURVE_PARAMETERS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|group
operator|->
name|field_mod_func
operator|=
name|BN_nist_mod_256
expr_stmt|;
name|ret
operator|=
name|ec_GFp_simple_group_set_curve
argument_list|(
name|group
argument_list|,
name|p
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Takes the Jacobian coordinates (X, Y, Z) of a point and returns  * (X', Y') = (X/Z^2, Y/Z^3) */
end_comment

begin_function
name|int
name|ec_GFp_nistp256_point_get_affine_coordinates
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|point
parameter_list|,
name|BIGNUM
modifier|*
name|x
parameter_list|,
name|BIGNUM
modifier|*
name|y
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|felem
name|z1
decl_stmt|,
name|z2
decl_stmt|,
name|x_in
decl_stmt|,
name|y_in
decl_stmt|;
name|smallfelem
name|x_out
decl_stmt|,
name|y_out
decl_stmt|;
name|longfelem
name|tmp
decl_stmt|;
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|point
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES
argument_list|,
name|EC_R_POINT_AT_INFINITY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|x_in
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|y_in
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|z1
argument_list|,
operator|&
name|point
operator|->
name|Z
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|felem_inv
argument_list|(
name|z2
argument_list|,
name|z1
argument_list|)
expr_stmt|;
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|z1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|x_in
argument_list|,
name|z1
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|x_in
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|felem_contract
argument_list|(
name|x_out
argument_list|,
name|x_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|smallfelem_to_BN
argument_list|(
name|x
argument_list|,
name|x_out
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|z1
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|z1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|y_in
argument_list|,
name|z1
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|y_in
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|felem_contract
argument_list|(
name|y_out
argument_list|,
name|y_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|smallfelem_to_BN
argument_list|(
name|y
argument_list|,
name|y_out
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_points_affine
parameter_list|(
name|size_t
name|num
parameter_list|,
name|smallfelem
name|points
index|[
comment|/* num */
index|]
index|[
literal|3
index|]
parameter_list|,
name|smallfelem
name|tmp_smallfelems
index|[
comment|/* num+1 */
index|]
parameter_list|)
block|{
comment|/* Runs in constant time, unless an input is the point at infinity 	 * (which normally shouldn't happen). */
name|ec_GFp_nistp_points_make_affine_internal
argument_list|(
name|num
argument_list|,
name|points
argument_list|,
sizeof|sizeof
argument_list|(
name|smallfelem
argument_list|)
argument_list|,
name|tmp_smallfelems
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|smallfelem_one
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|smallfelem_is_zero_int
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|smallfelem_assign
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|smallfelem_square_contract
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|smallfelem_mul_contract
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|smallfelem_inv_contract
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|smallfelem_assign
comment|/* nothing to contract */
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Computes scalar*generator + \sum scalars[i]*points[i], ignoring NULL values  * Result is stored in r (r can equal one of the inputs). */
end_comment

begin_function
name|int
name|ec_GFp_nistp256_points_mul
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|scalar
parameter_list|,
name|size_t
name|num
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|points
index|[]
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|scalars
index|[]
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|mixed
init|=
literal|0
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|,
modifier|*
name|tmp_scalar
decl_stmt|;
name|felem_bytearray
name|g_secret
decl_stmt|;
name|felem_bytearray
modifier|*
name|secrets
init|=
name|NULL
decl_stmt|;
name|smallfelem
argument_list|(
operator|*
name|pre_comp
argument_list|)
index|[
literal|17
index|]
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|smallfelem
modifier|*
name|tmp_smallfelems
init|=
name|NULL
decl_stmt|;
name|felem_bytearray
name|tmp
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|num_bytes
decl_stmt|;
name|int
name|have_pre_comp
init|=
literal|0
decl_stmt|;
name|size_t
name|num_points
init|=
name|num
decl_stmt|;
name|smallfelem
name|x_in
decl_stmt|,
name|y_in
decl_stmt|,
name|z_in
decl_stmt|;
name|felem
name|x_out
decl_stmt|,
name|y_out
decl_stmt|,
name|z_out
decl_stmt|;
name|NISTP256_PRE_COMP
modifier|*
name|pre
init|=
name|NULL
decl_stmt|;
specifier|const
name|smallfelem
argument_list|(
operator|*
name|g_pre_comp
argument_list|)
index|[
literal|16
index|]
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|EC_POINT
modifier|*
name|generator
init|=
name|NULL
decl_stmt|;
specifier|const
name|EC_POINT
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
specifier|const
name|BIGNUM
modifier|*
name|p_scalar
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|x
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|y
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|z
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|tmp_scalar
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|scalar
operator|!=
name|NULL
condition|)
block|{
name|pre
operator|=
name|EC_EX_DATA_get_data
argument_list|(
name|group
operator|->
name|extra_data
argument_list|,
name|nistp256_pre_comp_dup
argument_list|,
name|nistp256_pre_comp_free
argument_list|,
name|nistp256_pre_comp_clear_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre
condition|)
comment|/* we have precomputation, try to use it */
name|g_pre_comp
operator|=
operator|(
specifier|const
name|smallfelem
argument_list|(
operator|*
argument_list|)
index|[
literal|16
index|]
index|[
literal|3
index|]
operator|)
name|pre
operator|->
name|g_pre_comp
expr_stmt|;
else|else
comment|/* try to use the standard precomputation */
name|g_pre_comp
operator|=
operator|&
name|gmul
index|[
literal|0
index|]
expr_stmt|;
name|generator
operator|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|generator
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* get the generator from precomputation */
if|if
condition|(
operator|!
name|smallfelem_to_BN
argument_list|(
name|x
argument_list|,
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|smallfelem_to_BN
argument_list|(
name|y
argument_list|,
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|smallfelem_to_BN
argument_list|(
name|z
argument_list|,
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP256_POINTS_MUL
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|EC_POINT_set_Jprojective_coordinates_GFp
argument_list|(
name|group
argument_list|,
name|generator
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
literal|0
operator|==
name|EC_POINT_cmp
argument_list|(
name|group
argument_list|,
name|generator
argument_list|,
name|group
operator|->
name|generator
argument_list|,
name|ctx
argument_list|)
condition|)
comment|/* precomputation matches generator */
name|have_pre_comp
operator|=
literal|1
expr_stmt|;
else|else
comment|/* we don't have valid precomputation: 			 * treat the generator as a random point */
name|num_points
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|num_points
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|num_points
operator|>=
literal|3
condition|)
block|{
comment|/* unless we precompute multiples for just one or two points, 			 * converting those into affine form is time well spent  */
name|mixed
operator|=
literal|1
expr_stmt|;
block|}
name|secrets
operator|=
name|OPENSSL_malloc
argument_list|(
name|num_points
operator|*
sizeof|sizeof
argument_list|(
name|felem_bytearray
argument_list|)
argument_list|)
expr_stmt|;
name|pre_comp
operator|=
name|OPENSSL_malloc
argument_list|(
name|num_points
operator|*
literal|17
operator|*
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|smallfelem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mixed
condition|)
name|tmp_smallfelems
operator|=
name|OPENSSL_malloc
argument_list|(
operator|(
name|num_points
operator|*
literal|17
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|smallfelem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|secrets
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pre_comp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mixed
operator|&&
operator|(
name|tmp_smallfelems
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP256_POINTS_MUL
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* we treat NULL scalars as 0, and NULL points as points at infinity, 		 * i.e., they contribute nothing to the linear combination */
name|memset
argument_list|(
name|secrets
argument_list|,
literal|0
argument_list|,
name|num_points
operator|*
sizeof|sizeof
argument_list|(
name|felem_bytearray
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pre_comp
argument_list|,
literal|0
argument_list|,
name|num_points
operator|*
literal|17
operator|*
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|smallfelem
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_points
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
name|num
condition|)
comment|/* we didn't have a valid precomputation, so we pick 				 * the generator */
block|{
name|p
operator|=
name|EC_GROUP_get0_generator
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|p_scalar
operator|=
name|scalar
expr_stmt|;
block|}
else|else
comment|/* the i^th point */
block|{
name|p
operator|=
name|points
index|[
name|i
index|]
expr_stmt|;
name|p_scalar
operator|=
name|scalars
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_scalar
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|p
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* reduce scalar to 0<= scalar< 2^256 */
if|if
condition|(
operator|(
name|BN_num_bits
argument_list|(
name|p_scalar
argument_list|)
operator|>
literal|256
operator|)
operator|||
operator|(
name|BN_is_negative
argument_list|(
name|p_scalar
argument_list|)
operator|)
condition|)
block|{
comment|/* this is an unusual input, and we don't guarantee 					 * constant-timeness */
if|if
condition|(
operator|!
name|BN_nnmod
argument_list|(
name|tmp_scalar
argument_list|,
name|p_scalar
argument_list|,
operator|&
name|group
operator|->
name|order
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP256_POINTS_MUL
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|num_bytes
operator|=
name|BN_bn2bin
argument_list|(
name|tmp_scalar
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|num_bytes
operator|=
name|BN_bn2bin
argument_list|(
name|p_scalar
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|flip_endian
argument_list|(
name|secrets
index|[
name|i
index|]
argument_list|,
name|tmp
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
comment|/* precompute multiples */
if|if
condition|(
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|x_out
argument_list|,
operator|&
name|p
operator|->
name|X
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|y_out
argument_list|,
operator|&
name|p
operator|->
name|Y
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|z_out
argument_list|,
operator|&
name|p
operator|->
name|Z
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
name|felem_shrink
argument_list|(
name|pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|x_out
argument_list|)
expr_stmt|;
name|felem_shrink
argument_list|(
name|pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|y_out
argument_list|)
expr_stmt|;
name|felem_shrink
argument_list|(
name|pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
name|z_out
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<=
literal|16
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|j
operator|&
literal|1
condition|)
block|{
name|point_add_small
argument_list|(
name|pre_comp
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|0
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|2
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|point_double_small
argument_list|(
name|pre_comp
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|0
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|2
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
operator|/
literal|2
index|]
index|[
literal|0
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
operator|/
literal|2
index|]
index|[
literal|1
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
operator|/
literal|2
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|mixed
condition|)
name|make_points_affine
argument_list|(
name|num_points
operator|*
literal|17
argument_list|,
name|pre_comp
index|[
literal|0
index|]
argument_list|,
name|tmp_smallfelems
argument_list|)
expr_stmt|;
block|}
comment|/* the scalar for the generator */
if|if
condition|(
operator|(
name|scalar
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|have_pre_comp
operator|)
condition|)
block|{
name|memset
argument_list|(
name|g_secret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|g_secret
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reduce scalar to 0<= scalar< 2^256 */
if|if
condition|(
operator|(
name|BN_num_bits
argument_list|(
name|scalar
argument_list|)
operator|>
literal|256
operator|)
operator|||
operator|(
name|BN_is_negative
argument_list|(
name|scalar
argument_list|)
operator|)
condition|)
block|{
comment|/* this is an unusual input, and we don't guarantee 			 * constant-timeness */
if|if
condition|(
operator|!
name|BN_nnmod
argument_list|(
name|tmp_scalar
argument_list|,
name|scalar
argument_list|,
operator|&
name|group
operator|->
name|order
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP256_POINTS_MUL
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|num_bytes
operator|=
name|BN_bn2bin
argument_list|(
name|tmp_scalar
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|num_bytes
operator|=
name|BN_bn2bin
argument_list|(
name|scalar
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|flip_endian
argument_list|(
name|g_secret
argument_list|,
name|tmp
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
comment|/* do the multiplication with generator precomputation*/
name|batch_mul
argument_list|(
name|x_out
argument_list|,
name|y_out
argument_list|,
name|z_out
argument_list|,
operator|(
specifier|const
name|felem_bytearray
argument_list|(
operator|*
argument_list|)
operator|)
name|secrets
argument_list|,
name|num_points
argument_list|,
name|g_secret
argument_list|,
name|mixed
argument_list|,
operator|(
specifier|const
name|smallfelem
argument_list|(
operator|*
argument_list|)
index|[
literal|17
index|]
index|[
literal|3
index|]
operator|)
name|pre_comp
argument_list|,
name|g_pre_comp
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* do the multiplication without generator precomputation */
name|batch_mul
argument_list|(
name|x_out
argument_list|,
name|y_out
argument_list|,
name|z_out
argument_list|,
operator|(
specifier|const
name|felem_bytearray
argument_list|(
operator|*
argument_list|)
operator|)
name|secrets
argument_list|,
name|num_points
argument_list|,
name|NULL
argument_list|,
name|mixed
argument_list|,
operator|(
specifier|const
name|smallfelem
argument_list|(
operator|*
argument_list|)
index|[
literal|17
index|]
index|[
literal|3
index|]
operator|)
name|pre_comp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* reduce the output to its unique minimal representation */
name|felem_contract
argument_list|(
name|x_in
argument_list|,
name|x_out
argument_list|)
expr_stmt|;
name|felem_contract
argument_list|(
name|y_in
argument_list|,
name|y_out
argument_list|)
expr_stmt|;
name|felem_contract
argument_list|(
name|z_in
argument_list|,
name|z_out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|smallfelem_to_BN
argument_list|(
name|x
argument_list|,
name|x_in
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|smallfelem_to_BN
argument_list|(
name|y
argument_list|,
name|y_in
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|smallfelem_to_BN
argument_list|(
name|z
argument_list|,
name|z_in
argument_list|)
operator|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP256_POINTS_MUL
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
name|EC_POINT_set_Jprojective_coordinates_GFp
argument_list|(
name|group
argument_list|,
name|r
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|generator
operator|!=
name|NULL
condition|)
name|EC_POINT_free
argument_list|(
name|generator
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|secrets
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|secrets
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_comp
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|pre_comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_smallfelems
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|tmp_smallfelems
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_nistp256_precompute_mult
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|NISTP256_PRE_COMP
modifier|*
name|pre
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|EC_POINT
modifier|*
name|generator
init|=
name|NULL
decl_stmt|;
name|smallfelem
name|tmp_smallfelems
index|[
literal|32
index|]
decl_stmt|;
name|felem
name|x_tmp
decl_stmt|,
name|y_tmp
decl_stmt|,
name|z_tmp
decl_stmt|;
comment|/* throw away old precomputation */
name|EC_EX_DATA_free_data
argument_list|(
operator|&
name|group
operator|->
name|extra_data
argument_list|,
name|nistp256_pre_comp_dup
argument_list|,
name|nistp256_pre_comp_free
argument_list|,
name|nistp256_pre_comp_clear_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|x
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|y
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|err
goto|;
comment|/* get the generator */
if|if
condition|(
name|group
operator|->
name|generator
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|generator
operator|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|generator
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|BN_bin2bn
argument_list|(
name|nistp256_curve_params
index|[
literal|3
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|felem_bytearray
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|BN_bin2bn
argument_list|(
name|nistp256_curve_params
index|[
literal|4
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|felem_bytearray
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EC_POINT_set_affine_coordinates_GFp
argument_list|(
name|group
argument_list|,
name|generator
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|(
name|pre
operator|=
name|nistp256_pre_comp_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* if the generator is the standard one, use built-in precomputation */
if|if
condition|(
literal|0
operator|==
name|EC_POINT_cmp
argument_list|(
name|group
argument_list|,
name|generator
argument_list|,
name|group
operator|->
name|generator
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|pre
operator|->
name|g_pre_comp
argument_list|,
name|gmul
argument_list|,
sizeof|sizeof
argument_list|(
name|pre
operator|->
name|g_pre_comp
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|x_tmp
argument_list|,
operator|&
name|group
operator|->
name|generator
operator|->
name|X
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|y_tmp
argument_list|,
operator|&
name|group
operator|->
name|generator
operator|->
name|Y
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|z_tmp
argument_list|,
operator|&
name|group
operator|->
name|generator
operator|->
name|Z
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
name|felem_shrink
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|x_tmp
argument_list|)
expr_stmt|;
name|felem_shrink
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|y_tmp
argument_list|)
expr_stmt|;
name|felem_shrink
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
name|z_tmp
argument_list|)
expr_stmt|;
comment|/* compute 2^64*G, 2^128*G, 2^192*G for the first table, 	 * 2^32*G, 2^96*G, 2^160*G, 2^224*G for the second one 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|8
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
name|point_double_small
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|31
condition|;
operator|++
name|j
control|)
block|{
name|point_double_small
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|8
condition|)
break|break;
name|point_double_small
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|31
condition|;
operator|++
name|j
control|)
block|{
name|point_double_small
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|/* g_pre_comp[i][0] is the point at infinity */
name|memset
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the remaining multiples */
comment|/* 2^64*G + 2^128*G resp. 2^96*G + 2^160*G */
name|point_add_small
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|6
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|6
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|6
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|4
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|4
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|4
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 2^64*G + 2^192*G resp. 2^96*G + 2^224*G */
name|point_add_small
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|10
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|10
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|10
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|8
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|8
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|8
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 2^128*G + 2^192*G resp. 2^160*G + 2^224*G */
name|point_add_small
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|12
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|12
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|12
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|8
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|8
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|8
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|4
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|4
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|4
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 2^64*G + 2^128*G + 2^192*G resp. 2^96*G + 2^160*G + 2^224*G */
name|point_add_small
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|14
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|14
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|14
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|12
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|12
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|12
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|8
condition|;
operator|++
name|j
control|)
block|{
comment|/* odd multiples: add G resp. 2^32*G */
name|point_add_small
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
operator|*
name|j
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
operator|*
name|j
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
operator|*
name|j
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|make_points_affine
argument_list|(
literal|31
argument_list|,
operator|&
operator|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|)
argument_list|,
name|tmp_smallfelems
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EC_EX_DATA_set_data
argument_list|(
operator|&
name|group
operator|->
name|extra_data
argument_list|,
name|pre
argument_list|,
name|nistp256_pre_comp_dup
argument_list|,
name|nistp256_pre_comp_free
argument_list|,
name|nistp256_pre_comp_clear_free
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
literal|1
expr_stmt|;
name|pre
operator|=
name|NULL
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|generator
operator|!=
name|NULL
condition|)
name|EC_POINT_free
argument_list|(
name|generator
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre
condition|)
name|nistp256_pre_comp_free
argument_list|(
name|pre
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_nistp256_have_precompute_mult
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
if|if
condition|(
name|EC_EX_DATA_get_data
argument_list|(
name|group
operator|->
name|extra_data
argument_list|,
name|nistp256_pre_comp_dup
argument_list|,
name|nistp256_pre_comp_free
argument_list|,
name|nistp256_pre_comp_clear_free
argument_list|)
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|void
modifier|*
name|dummy
init|=
operator|&
name|dummy
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

