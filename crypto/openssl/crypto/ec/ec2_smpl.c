begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/ec/ec2_smpl.c */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.  *  * The Elliptic Curve Public-Key Crypto Library (ECC Code) included  * herein is developed by SUN MICROSYSTEMS, INC., and is contributed  * to the OpenSSL project.  *  * The ECC Code is licensed pursuant to the OpenSSL open source  * license provided below.  *  * The software is originally written by Sheueling Chang Shantz and  * Douglas Stebila of Sun Microsystems Laboratories.  *  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|"ec_lcl.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC2M
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
end_ifdef

begin_include
include|#
directive|include
file|<openssl/fips.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|const
name|EC_METHOD
modifier|*
name|EC_GF2m_simple_method
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|EC_METHOD
name|ret
init|=
block|{
name|EC_FLAGS_DEFAULT_OCT
block|,
name|NID_X9_62_characteristic_two_field
block|,
name|ec_GF2m_simple_group_init
block|,
name|ec_GF2m_simple_group_finish
block|,
name|ec_GF2m_simple_group_clear_finish
block|,
name|ec_GF2m_simple_group_copy
block|,
name|ec_GF2m_simple_group_set_curve
block|,
name|ec_GF2m_simple_group_get_curve
block|,
name|ec_GF2m_simple_group_get_degree
block|,
name|ec_GF2m_simple_group_check_discriminant
block|,
name|ec_GF2m_simple_point_init
block|,
name|ec_GF2m_simple_point_finish
block|,
name|ec_GF2m_simple_point_clear_finish
block|,
name|ec_GF2m_simple_point_copy
block|,
name|ec_GF2m_simple_point_set_to_infinity
block|,
literal|0
comment|/* set_Jprojective_coordinates_GFp */
block|,
literal|0
comment|/* get_Jprojective_coordinates_GFp */
block|,
name|ec_GF2m_simple_point_set_affine_coordinates
block|,
name|ec_GF2m_simple_point_get_affine_coordinates
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|ec_GF2m_simple_add
block|,
name|ec_GF2m_simple_dbl
block|,
name|ec_GF2m_simple_invert
block|,
name|ec_GF2m_simple_is_at_infinity
block|,
name|ec_GF2m_simple_is_on_curve
block|,
name|ec_GF2m_simple_cmp
block|,
name|ec_GF2m_simple_make_affine
block|,
name|ec_GF2m_simple_points_make_affine
block|,
comment|/* the following three method functions are defined in ec2_mult.c */
name|ec_GF2m_simple_mul
block|,
name|ec_GF2m_precompute_mult
block|,
name|ec_GF2m_have_precompute_mult
block|,
name|ec_GF2m_simple_field_mul
block|,
name|ec_GF2m_simple_field_sqr
block|,
name|ec_GF2m_simple_field_div
block|,
literal|0
comment|/* field_encode */
block|,
literal|0
comment|/* field_decode */
block|,
literal|0
comment|/* field_set_to_one */
block|}
decl_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
if|if
condition|(
name|FIPS_mode
argument_list|()
condition|)
return|return
name|fips_ec_gf2m_simple_method
argument_list|()
return|;
endif|#
directive|endif
return|return
operator|&
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Initialize a GF(2^m)-based EC_GROUP structure.  * Note that all other members are handled by EC_GROUP_new.  */
end_comment

begin_function
name|int
name|ec_GF2m_simple_group_init
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
name|BN_init
argument_list|(
operator|&
name|group
operator|->
name|field
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|group
operator|->
name|a
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|group
operator|->
name|b
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Free a GF(2^m)-based EC_GROUP structure.  * Note that all other members are handled by EC_GROUP_free.  */
end_comment

begin_function
name|void
name|ec_GF2m_simple_group_finish
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
name|BN_free
argument_list|(
operator|&
name|group
operator|->
name|field
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|group
operator|->
name|a
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|group
operator|->
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear and free a GF(2^m)-based EC_GROUP structure.  * Note that all other members are handled by EC_GROUP_clear_free.  */
end_comment

begin_function
name|void
name|ec_GF2m_simple_group_clear_finish
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
name|BN_clear_free
argument_list|(
operator|&
name|group
operator|->
name|field
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
operator|&
name|group
operator|->
name|a
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
operator|&
name|group
operator|->
name|b
argument_list|)
expr_stmt|;
name|group
operator|->
name|poly
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|group
operator|->
name|poly
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|group
operator|->
name|poly
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|group
operator|->
name|poly
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|group
operator|->
name|poly
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|group
operator|->
name|poly
index|[
literal|5
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy a GF(2^m)-based EC_GROUP structure.  * Note that all other members are handled by EC_GROUP_copy.  */
end_comment

begin_function
name|int
name|ec_GF2m_simple_group_copy
parameter_list|(
name|EC_GROUP
modifier|*
name|dest
parameter_list|,
specifier|const
name|EC_GROUP
modifier|*
name|src
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|dest
operator|->
name|field
argument_list|,
operator|&
name|src
operator|->
name|field
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|dest
operator|->
name|a
argument_list|,
operator|&
name|src
operator|->
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|dest
operator|->
name|b
argument_list|,
operator|&
name|src
operator|->
name|b
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|->
name|poly
index|[
literal|0
index|]
operator|=
name|src
operator|->
name|poly
index|[
literal|0
index|]
expr_stmt|;
name|dest
operator|->
name|poly
index|[
literal|1
index|]
operator|=
name|src
operator|->
name|poly
index|[
literal|1
index|]
expr_stmt|;
name|dest
operator|->
name|poly
index|[
literal|2
index|]
operator|=
name|src
operator|->
name|poly
index|[
literal|2
index|]
expr_stmt|;
name|dest
operator|->
name|poly
index|[
literal|3
index|]
operator|=
name|src
operator|->
name|poly
index|[
literal|3
index|]
expr_stmt|;
name|dest
operator|->
name|poly
index|[
literal|4
index|]
operator|=
name|src
operator|->
name|poly
index|[
literal|4
index|]
expr_stmt|;
name|dest
operator|->
name|poly
index|[
literal|5
index|]
operator|=
name|src
operator|->
name|poly
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|bn_wexpand
argument_list|(
operator|&
name|dest
operator|->
name|a
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dest
operator|->
name|poly
index|[
literal|0
index|]
operator|+
name|BN_BITS2
operator|-
literal|1
argument_list|)
operator|/
name|BN_BITS2
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bn_wexpand
argument_list|(
operator|&
name|dest
operator|->
name|b
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dest
operator|->
name|poly
index|[
literal|0
index|]
operator|+
name|BN_BITS2
operator|-
literal|1
argument_list|)
operator|/
name|BN_BITS2
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|dest
operator|->
name|a
operator|.
name|top
init|;
name|i
operator|<
name|dest
operator|->
name|a
operator|.
name|dmax
condition|;
name|i
operator|++
control|)
name|dest
operator|->
name|a
operator|.
name|d
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dest
operator|->
name|b
operator|.
name|top
init|;
name|i
operator|<
name|dest
operator|->
name|b
operator|.
name|dmax
condition|;
name|i
operator|++
control|)
name|dest
operator|->
name|b
operator|.
name|d
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Set the curve parameters of an EC_GROUP structure. */
end_comment

begin_function
name|int
name|ec_GF2m_simple_group_set_curve
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
comment|/* group->field */
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|group
operator|->
name|field
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|i
operator|=
name|BN_GF2m_poly2arr
argument_list|(
operator|&
name|group
operator|->
name|field
argument_list|,
name|group
operator|->
name|poly
argument_list|,
literal|6
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|!=
literal|5
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|3
operator|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GF2M_SIMPLE_GROUP_SET_CURVE
argument_list|,
name|EC_R_UNSUPPORTED_FIELD
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* group->a */
if|if
condition|(
operator|!
name|BN_GF2m_mod_arr
argument_list|(
operator|&
name|group
operator|->
name|a
argument_list|,
name|a
argument_list|,
name|group
operator|->
name|poly
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|bn_wexpand
argument_list|(
operator|&
name|group
operator|->
name|a
argument_list|,
call|(
name|int
call|)
argument_list|(
name|group
operator|->
name|poly
index|[
literal|0
index|]
operator|+
name|BN_BITS2
operator|-
literal|1
argument_list|)
operator|/
name|BN_BITS2
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|i
operator|=
name|group
operator|->
name|a
operator|.
name|top
init|;
name|i
operator|<
name|group
operator|->
name|a
operator|.
name|dmax
condition|;
name|i
operator|++
control|)
name|group
operator|->
name|a
operator|.
name|d
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* group->b */
if|if
condition|(
operator|!
name|BN_GF2m_mod_arr
argument_list|(
operator|&
name|group
operator|->
name|b
argument_list|,
name|b
argument_list|,
name|group
operator|->
name|poly
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|bn_wexpand
argument_list|(
operator|&
name|group
operator|->
name|b
argument_list|,
call|(
name|int
call|)
argument_list|(
name|group
operator|->
name|poly
index|[
literal|0
index|]
operator|+
name|BN_BITS2
operator|-
literal|1
argument_list|)
operator|/
name|BN_BITS2
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|i
operator|=
name|group
operator|->
name|b
operator|.
name|top
init|;
name|i
operator|<
name|group
operator|->
name|b
operator|.
name|dmax
condition|;
name|i
operator|++
control|)
name|group
operator|->
name|b
operator|.
name|d
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Get the curve parameters of an EC_GROUP structure.  * If p, a, or b are NULL then there values will not be set but the method will return with success.  */
end_comment

begin_function
name|int
name|ec_GF2m_simple_group_get_curve
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|BIGNUM
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|p
argument_list|,
operator|&
name|group
operator|->
name|field
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|a
argument_list|,
operator|&
name|group
operator|->
name|a
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|b
argument_list|,
operator|&
name|group
operator|->
name|b
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Gets the degree of the field.  For a curve over GF(2^m) this is the value m. */
end_comment

begin_function
name|int
name|ec_GF2m_simple_group_get_degree
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
return|return
name|BN_num_bits
argument_list|(
operator|&
name|group
operator|->
name|field
argument_list|)
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Checks the discriminant of the curve.  * y^2 + x*y = x^3 + a*x^2 + b is an elliptic curve<=> b != 0 (mod p)   */
end_comment

begin_function
name|int
name|ec_GF2m_simple_group_check_discriminant
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|BIGNUM
modifier|*
name|b
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GF2M_SIMPLE_GROUP_CHECK_DISCRIMINANT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|b
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_GF2m_mod_arr
argument_list|(
name|b
argument_list|,
operator|&
name|group
operator|->
name|b
argument_list|,
name|group
operator|->
name|poly
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* check the discriminant: 	 * y^2 + x*y = x^3 + a*x^2 + b is an elliptic curve<=> b != 0 (mod p)  	 */
if|if
condition|(
name|BN_is_zero
argument_list|(
name|b
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Initializes an EC_POINT. */
end_comment

begin_function
name|int
name|ec_GF2m_simple_point_init
parameter_list|(
name|EC_POINT
modifier|*
name|point
parameter_list|)
block|{
name|BN_init
argument_list|(
operator|&
name|point
operator|->
name|X
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|point
operator|->
name|Y
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Frees an EC_POINT. */
end_comment

begin_function
name|void
name|ec_GF2m_simple_point_finish
parameter_list|(
name|EC_POINT
modifier|*
name|point
parameter_list|)
block|{
name|BN_free
argument_list|(
operator|&
name|point
operator|->
name|X
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|point
operator|->
name|Y
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clears and frees an EC_POINT. */
end_comment

begin_function
name|void
name|ec_GF2m_simple_point_clear_finish
parameter_list|(
name|EC_POINT
modifier|*
name|point
parameter_list|)
block|{
name|BN_clear_free
argument_list|(
operator|&
name|point
operator|->
name|X
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
operator|&
name|point
operator|->
name|Y
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|)
expr_stmt|;
name|point
operator|->
name|Z_is_one
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the contents of one EC_POINT into another.  Assumes dest is initialized. */
end_comment

begin_function
name|int
name|ec_GF2m_simple_point_copy
parameter_list|(
name|EC_POINT
modifier|*
name|dest
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|src
parameter_list|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|dest
operator|->
name|X
argument_list|,
operator|&
name|src
operator|->
name|X
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|dest
operator|->
name|Y
argument_list|,
operator|&
name|src
operator|->
name|Y
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|dest
operator|->
name|Z
argument_list|,
operator|&
name|src
operator|->
name|Z
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|->
name|Z_is_one
operator|=
name|src
operator|->
name|Z_is_one
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Set an EC_POINT to the point at infinity.    * A point at infinity is represented by having Z=0.  */
end_comment

begin_function
name|int
name|ec_GF2m_simple_point_set_to_infinity
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|point
parameter_list|)
block|{
name|point
operator|->
name|Z_is_one
operator|=
literal|0
expr_stmt|;
name|BN_zero
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Set the coordinates of an EC_POINT using affine coordinates.   * Note that the simple implementation only uses affine coordinates.  */
end_comment

begin_function
name|int
name|ec_GF2m_simple_point_set_affine_coordinates
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|point
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|x
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|y
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
operator|||
name|y
operator|==
name|NULL
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GF2M_SIMPLE_POINT_SET_AFFINE_COORDINATES
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|point
operator|->
name|X
argument_list|,
name|x
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|BN_set_negative
argument_list|(
operator|&
name|point
operator|->
name|X
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|point
operator|->
name|Y
argument_list|,
name|y
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|BN_set_negative
argument_list|(
operator|&
name|point
operator|->
name|Y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|BN_set_negative
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|point
operator|->
name|Z_is_one
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Gets the affine coordinates of an EC_POINT.   * Note that the simple implementation only uses affine coordinates.  */
end_comment

begin_function
name|int
name|ec_GF2m_simple_point_get_affine_coordinates
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|point
parameter_list|,
name|BIGNUM
modifier|*
name|x
parameter_list|,
name|BIGNUM
modifier|*
name|y
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|point
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES
argument_list|,
name|EC_R_POINT_AT_INFINITY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|BN_cmp
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES
argument_list|,
name|ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|x
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|BN_set_negative
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|y
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|BN_set_negative
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Computes a + b and stores the result in r.  r could be a or b, a could be b.  * Uses algorithm A.10.2 of IEEE P1363.  */
end_comment

begin_function
name|int
name|ec_GF2m_simple_add
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|a
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|x0
decl_stmt|,
modifier|*
name|y0
decl_stmt|,
modifier|*
name|x1
decl_stmt|,
modifier|*
name|y1
decl_stmt|,
modifier|*
name|x2
decl_stmt|,
modifier|*
name|y2
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_copy
argument_list|(
name|r
argument_list|,
name|b
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_copy
argument_list|(
name|r
argument_list|,
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|x0
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|y0
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|x1
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|y1
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|x2
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|s
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|t
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|a
operator|->
name|Z_is_one
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|x0
argument_list|,
operator|&
name|a
operator|->
name|X
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|y0
argument_list|,
operator|&
name|a
operator|->
name|Y
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|EC_POINT_get_affine_coordinates_GF2m
argument_list|(
name|group
argument_list|,
name|a
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|b
operator|->
name|Z_is_one
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|x1
argument_list|,
operator|&
name|b
operator|->
name|X
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|y1
argument_list|,
operator|&
name|b
operator|->
name|Y
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|EC_POINT_get_affine_coordinates_GF2m
argument_list|(
name|group
argument_list|,
name|b
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|BN_GF2m_cmp
argument_list|(
name|x0
argument_list|,
name|x1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|BN_GF2m_add
argument_list|(
name|t
argument_list|,
name|x0
argument_list|,
name|x1
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_GF2m_add
argument_list|(
name|s
argument_list|,
name|y0
argument_list|,
name|y1
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_div
argument_list|(
name|group
argument_list|,
name|s
argument_list|,
name|s
argument_list|,
name|t
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_sqr
argument_list|(
name|group
argument_list|,
name|x2
argument_list|,
name|s
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_GF2m_add
argument_list|(
name|x2
argument_list|,
name|x2
argument_list|,
operator|&
name|group
operator|->
name|a
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_GF2m_add
argument_list|(
name|x2
argument_list|,
name|x2
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_GF2m_add
argument_list|(
name|x2
argument_list|,
name|x2
argument_list|,
name|t
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
if|if
condition|(
name|BN_GF2m_cmp
argument_list|(
name|y0
argument_list|,
name|y1
argument_list|)
operator|||
name|BN_is_zero
argument_list|(
name|x1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|EC_POINT_set_to_infinity
argument_list|(
name|group
argument_list|,
name|r
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_div
argument_list|(
name|group
argument_list|,
name|s
argument_list|,
name|y1
argument_list|,
name|x1
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_GF2m_add
argument_list|(
name|s
argument_list|,
name|s
argument_list|,
name|x1
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_sqr
argument_list|(
name|group
argument_list|,
name|x2
argument_list|,
name|s
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_GF2m_add
argument_list|(
name|x2
argument_list|,
name|x2
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_GF2m_add
argument_list|(
name|x2
argument_list|,
name|x2
argument_list|,
operator|&
name|group
operator|->
name|a
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|BN_GF2m_add
argument_list|(
name|y2
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|field_mul
argument_list|(
name|group
argument_list|,
name|y2
argument_list|,
name|y2
argument_list|,
name|s
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_GF2m_add
argument_list|(
name|y2
argument_list|,
name|y2
argument_list|,
name|x2
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_GF2m_add
argument_list|(
name|y2
argument_list|,
name|y2
argument_list|,
name|y1
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|EC_POINT_set_affine_coordinates_GF2m
argument_list|(
name|group
argument_list|,
name|r
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Computes 2 * a and stores the result in r.  r could be a.  * Uses algorithm A.10.2 of IEEE P1363.  */
end_comment

begin_function
name|int
name|ec_GF2m_simple_dbl
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|a
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|ec_GF2m_simple_add
argument_list|(
name|group
argument_list|,
name|r
argument_list|,
name|a
argument_list|,
name|a
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ec_GF2m_simple_invert
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|point
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|point
argument_list|)
operator|||
name|BN_is_zero
argument_list|(
operator|&
name|point
operator|->
name|Y
argument_list|)
condition|)
comment|/* point is its own inverse */
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|EC_POINT_make_affine
argument_list|(
name|group
argument_list|,
name|point
argument_list|,
name|ctx
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|BN_GF2m_add
argument_list|(
operator|&
name|point
operator|->
name|Y
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Indicates whether the given point is the point at infinity. */
end_comment

begin_function
name|int
name|ec_GF2m_simple_is_at_infinity
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|point
parameter_list|)
block|{
return|return
name|BN_is_zero
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determines whether the given EC_POINT is an actual point on the curve defined  * in the EC_GROUP.  A point is valid if it satisfies the Weierstrass equation:  *      y^2 + x*y = x^3 + a*x^2 + b.  */
end_comment

begin_function
name|int
name|ec_GF2m_simple_is_on_curve
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|point
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|lh
decl_stmt|,
modifier|*
name|y2
decl_stmt|;
name|int
function_decl|(
modifier|*
name|field_mul
function_decl|)
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
parameter_list|,
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
name|BN_CTX
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|field_sqr
function_decl|)
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
parameter_list|,
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
name|BN_CTX
modifier|*
parameter_list|)
function_decl|;
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|point
argument_list|)
condition|)
return|return
literal|1
return|;
name|field_mul
operator|=
name|group
operator|->
name|meth
operator|->
name|field_mul
expr_stmt|;
name|field_sqr
operator|=
name|group
operator|->
name|meth
operator|->
name|field_sqr
expr_stmt|;
comment|/* only support affine coordinates */
if|if
condition|(
operator|!
name|point
operator|->
name|Z_is_one
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|y2
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|lh
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|lh
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* We have a curve defined by a Weierstrass equation 	 *      y^2 + x*y = x^3 + a*x^2 + b. 	 *<=> x^3 + a*x^2 + x*y + b + y^2 = 0 	 *<=> ((x + a) * x + y ) * x + b + y^2 = 0 	 */
if|if
condition|(
operator|!
name|BN_GF2m_add
argument_list|(
name|lh
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|,
operator|&
name|group
operator|->
name|a
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|lh
argument_list|,
name|lh
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_GF2m_add
argument_list|(
name|lh
argument_list|,
name|lh
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|field_mul
argument_list|(
name|group
argument_list|,
name|lh
argument_list|,
name|lh
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_GF2m_add
argument_list|(
name|lh
argument_list|,
name|lh
argument_list|,
operator|&
name|group
operator|->
name|b
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|field_sqr
argument_list|(
name|group
argument_list|,
name|y2
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_GF2m_add
argument_list|(
name|lh
argument_list|,
name|lh
argument_list|,
name|y2
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|BN_is_zero
argument_list|(
name|lh
argument_list|)
expr_stmt|;
name|err
label|:
if|if
condition|(
name|ctx
condition|)
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Indicates whether two points are equal.  * Return values:  *  -1   error  *   0   equal (in affine coordinates)  *   1   not equal  */
end_comment

begin_function
name|int
name|ec_GF2m_simple_cmp
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|a
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|aX
decl_stmt|,
modifier|*
name|aY
decl_stmt|,
modifier|*
name|bX
decl_stmt|,
modifier|*
name|bY
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|a
argument_list|)
condition|)
block|{
return|return
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|b
argument_list|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|Z_is_one
operator|&&
name|b
operator|->
name|Z_is_one
condition|)
block|{
return|return
operator|(
operator|(
name|BN_cmp
argument_list|(
operator|&
name|a
operator|->
name|X
argument_list|,
operator|&
name|b
operator|->
name|X
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|BN_cmp
argument_list|(
operator|&
name|a
operator|->
name|Y
argument_list|,
operator|&
name|b
operator|->
name|Y
argument_list|)
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|aX
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|aY
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|bX
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|bY
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bY
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|EC_POINT_get_affine_coordinates_GF2m
argument_list|(
name|group
argument_list|,
name|a
argument_list|,
name|aX
argument_list|,
name|aY
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|EC_POINT_get_affine_coordinates_GF2m
argument_list|(
name|group
argument_list|,
name|b
argument_list|,
name|bX
argument_list|,
name|bY
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
operator|(
operator|(
name|BN_cmp
argument_list|(
name|aX
argument_list|,
name|bX
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|BN_cmp
argument_list|(
name|aY
argument_list|,
name|bY
argument_list|)
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|ctx
condition|)
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Forces the given EC_POINT to internally use affine coordinates. */
end_comment

begin_function
name|int
name|ec_GF2m_simple_make_affine
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|point
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|point
operator|->
name|Z_is_one
operator|||
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|point
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|x
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|y
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|EC_POINT_get_affine_coordinates_GF2m
argument_list|(
name|group
argument_list|,
name|point
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|point
operator|->
name|X
argument_list|,
name|x
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
operator|&
name|point
operator|->
name|Y
argument_list|,
name|y
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_one
argument_list|(
operator|&
name|point
operator|->
name|Z
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|ctx
condition|)
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Forces each of the EC_POINTs in the given array to use affine coordinates. */
end_comment

begin_function
name|int
name|ec_GF2m_simple_points_make_affine
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|size_t
name|num
parameter_list|,
name|EC_POINT
modifier|*
name|points
index|[]
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|group
operator|->
name|meth
operator|->
name|make_affine
argument_list|(
name|group
argument_list|,
name|points
index|[
name|i
index|]
argument_list|,
name|ctx
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Wrapper to simple binary polynomial field multiplication implementation. */
end_comment

begin_function
name|int
name|ec_GF2m_simple_field_mul
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|BN_GF2m_mod_mul_arr
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|group
operator|->
name|poly
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Wrapper to simple binary polynomial field squaring implementation. */
end_comment

begin_function
name|int
name|ec_GF2m_simple_field_sqr
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|BN_GF2m_mod_sqr_arr
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|group
operator|->
name|poly
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Wrapper to simple binary polynomial field division implementation. */
end_comment

begin_function
name|int
name|ec_GF2m_simple_field_div
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|BN_GF2m_mod_div
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|group
operator|->
name|field
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

