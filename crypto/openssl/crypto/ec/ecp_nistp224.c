begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/ec/ecp_nistp224.c */
end_comment

begin_comment
comment|/*  * Written by Emilia Kasper (Google) for the OpenSSL project.  */
end_comment

begin_comment
comment|/* Copyright 2011 Google Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  *  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_comment
comment|/*  * A 64-bit implementation of the NIST P-224 elliptic curve point multiplication  *  * Inspired by Daniel J. Bernstein's public domain nistp224 implementation  * and Adam Langley's public domain 64-bit C implementation of curve25519  */
end_comment

begin_include
include|#
directive|include
file|<openssl/opensslconf.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC_NISTP_64_GCC_128
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_SYS_VMS
end_ifndef

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|"ec_lcl.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>
literal|3
operator|||
operator|(
name|__GNUC__
operator|==
literal|3
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|1
operator|)
operator|)
end_if

begin_comment
comment|/* even with gcc, the typedef won't work for 32-bit platforms */
end_comment

begin_typedef
typedef|typedef
name|__uint128_t
name|uint128_t
typedef|;
end_typedef

begin_comment
comment|/* nonstandard; implemented by gcc on 64-bit                                  * platforms */
end_comment

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"Need GCC 3.1 or later to define type uint128_t"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|uint8_t
name|u8
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint64_t
name|u64
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int64_t
name|s64
typedef|;
end_typedef

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*-  * INTERNAL REPRESENTATION OF FIELD ELEMENTS  *  * Field elements are represented as a_0 + 2^56*a_1 + 2^112*a_2 + 2^168*a_3  * using 64-bit coefficients called 'limbs',  * and sometimes (for multiplication results) as  * b_0 + 2^56*b_1 + 2^112*b_2 + 2^168*b_3 + 2^224*b_4 + 2^280*b_5 + 2^336*b_6  * using 128-bit coefficients called 'widelimbs'.  * A 4-limb representation is an 'felem';  * a 7-widelimb representation is a 'widefelem'.  * Even within felems, bits of adjacent limbs overlap, and we don't always  * reduce the representations: we ensure that inputs to each felem  * multiplication satisfy a_i< 2^60, so outputs satisfy b_i< 4*2^60*2^60,  * and fit into a 128-bit word without overflow. The coefficients are then  * again partially reduced to obtain an felem satisfying a_i< 2^57.  * We only reduce to the unique minimal representation at the end of the  * computation.  */
end_comment

begin_typedef
typedef|typedef
name|uint64_t
name|limb
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint128_t
name|widelimb
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|limb
name|felem
index|[
literal|4
index|]
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|widelimb
name|widefelem
index|[
literal|7
index|]
typedef|;
end_typedef

begin_comment
comment|/*  * Field element represented as a byte arrary. 28*8 = 224 bits is also the  * group order size for the elliptic curve, and we also use this type for  * scalars for point multiplication.  */
end_comment

begin_typedef
typedef|typedef
name|u8
name|felem_bytearray
index|[
literal|28
index|]
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|felem_bytearray
name|nistp224_curve_params
index|[
literal|5
index|]
init|=
block|{
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
comment|/* p */
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|}
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
comment|/* a */
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFE
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFE
block|}
block|,
block|{
literal|0xB4
block|,
literal|0x05
block|,
literal|0x0A
block|,
literal|0x85
block|,
literal|0x0C
block|,
literal|0x04
block|,
literal|0xB3
block|,
literal|0xAB
block|,
literal|0xF5
block|,
literal|0x41
block|,
comment|/* b */
literal|0x32
block|,
literal|0x56
block|,
literal|0x50
block|,
literal|0x44
block|,
literal|0xB0
block|,
literal|0xB7
block|,
literal|0xD7
block|,
literal|0xBF
block|,
literal|0xD8
block|,
literal|0xBA
block|,
literal|0x27
block|,
literal|0x0B
block|,
literal|0x39
block|,
literal|0x43
block|,
literal|0x23
block|,
literal|0x55
block|,
literal|0xFF
block|,
literal|0xB4
block|}
block|,
block|{
literal|0xB7
block|,
literal|0x0E
block|,
literal|0x0C
block|,
literal|0xBD
block|,
literal|0x6B
block|,
literal|0xB4
block|,
literal|0xBF
block|,
literal|0x7F
block|,
literal|0x32
block|,
literal|0x13
block|,
comment|/* x */
literal|0x90
block|,
literal|0xB9
block|,
literal|0x4A
block|,
literal|0x03
block|,
literal|0xC1
block|,
literal|0xD3
block|,
literal|0x56
block|,
literal|0xC2
block|,
literal|0x11
block|,
literal|0x22
block|,
literal|0x34
block|,
literal|0x32
block|,
literal|0x80
block|,
literal|0xD6
block|,
literal|0x11
block|,
literal|0x5C
block|,
literal|0x1D
block|,
literal|0x21
block|}
block|,
block|{
literal|0xbd
block|,
literal|0x37
block|,
literal|0x63
block|,
literal|0x88
block|,
literal|0xb5
block|,
literal|0xf7
block|,
literal|0x23
block|,
literal|0xfb
block|,
literal|0x4c
block|,
literal|0x22
block|,
comment|/* y */
literal|0xdf
block|,
literal|0xe6
block|,
literal|0xcd
block|,
literal|0x43
block|,
literal|0x75
block|,
literal|0xa0
block|,
literal|0x5a
block|,
literal|0x07
block|,
literal|0x47
block|,
literal|0x64
block|,
literal|0x44
block|,
literal|0xd5
block|,
literal|0x81
block|,
literal|0x99
block|,
literal|0x85
block|,
literal|0x00
block|,
literal|0x7e
block|,
literal|0x34
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-  * Precomputed multiples of the standard generator  * Points are given in coordinates (X, Y, Z) where Z normally is 1  * (0 for the point at infinity).  * For each field element, slice a_0 is word 0, etc.  *  * The table has 2 * 16 elements, starting with the following:  * index | bits    | point  * ------+---------+------------------------------  *     0 | 0 0 0 0 | 0G  *     1 | 0 0 0 1 | 1G  *     2 | 0 0 1 0 | 2^56G  *     3 | 0 0 1 1 | (2^56 + 1)G  *     4 | 0 1 0 0 | 2^112G  *     5 | 0 1 0 1 | (2^112 + 1)G  *     6 | 0 1 1 0 | (2^112 + 2^56)G  *     7 | 0 1 1 1 | (2^112 + 2^56 + 1)G  *     8 | 1 0 0 0 | 2^168G  *     9 | 1 0 0 1 | (2^168 + 1)G  *    10 | 1 0 1 0 | (2^168 + 2^56)G  *    11 | 1 0 1 1 | (2^168 + 2^56 + 1)G  *    12 | 1 1 0 0 | (2^168 + 2^112)G  *    13 | 1 1 0 1 | (2^168 + 2^112 + 1)G  *    14 | 1 1 1 0 | (2^168 + 2^112 + 2^56)G  *    15 | 1 1 1 1 | (2^168 + 2^112 + 2^56 + 1)G  * followed by a copy of this with each element multiplied by 2^28.  *  * The reason for this is so that we can clock bits into four different  * locations when doing simple scalar multiplies against the base point,  * and then another four locations using the second 16 elements.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|felem
name|gmul
index|[
literal|2
index|]
index|[
literal|16
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x3280d6115c1d21
block|,
literal|0xc1d356c2112234
block|,
literal|0x7f321390b94a03
block|,
literal|0xb70e0cbd6bb4bf
block|}
block|,
block|{
literal|0xd5819985007e34
block|,
literal|0x75a05a07476444
block|,
literal|0xfb4c22dfe6cd43
block|,
literal|0xbd376388b5f723
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xfd9675666ebbe9
block|,
literal|0xbca7664d40ce5e
block|,
literal|0x2242df8d8a2a43
block|,
literal|0x1f49bbb0f99bc5
block|}
block|,
block|{
literal|0x29e0b892dc9c43
block|,
literal|0xece8608436e662
block|,
literal|0xdc858f185310d0
block|,
literal|0x9812dd4eb8d321
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x6d3e678d5d8eb8
block|,
literal|0x559eed1cb362f1
block|,
literal|0x16e9a3bbce8a3f
block|,
literal|0xeedcccd8c2a748
block|}
block|,
block|{
literal|0xf19f90ed50266d
block|,
literal|0xabf2b4bf65f9df
block|,
literal|0x313865468fafec
block|,
literal|0x5cb379ba910a17
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x0641966cab26e3
block|,
literal|0x91fb2991fab0a0
block|,
literal|0xefec27a4e13a0b
block|,
literal|0x0499aa8a5f8ebe
block|}
block|,
block|{
literal|0x7510407766af5d
block|,
literal|0x84d929610d5450
block|,
literal|0x81d77aae82f706
block|,
literal|0x6916f6d4338c5b
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xea95ac3b1f15c6
block|,
literal|0x086000905e82d4
block|,
literal|0xdd323ae4d1c8b1
block|,
literal|0x932b56be7685a3
block|}
block|,
block|{
literal|0x9ef93dea25dbbf
block|,
literal|0x41665960f390f0
block|,
literal|0xfdec76dbe2a8a7
block|,
literal|0x523e80f019062a
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x822fdd26732c73
block|,
literal|0xa01c83531b5d0f
block|,
literal|0x363f37347c1ba4
block|,
literal|0xc391b45c84725c
block|}
block|,
block|{
literal|0xbbd5e1b2d6ad24
block|,
literal|0xddfbcde19dfaec
block|,
literal|0xc393da7e222a7f
block|,
literal|0x1efb7890ede244
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x4c9e90ca217da1
block|,
literal|0xd11beca79159bb
block|,
literal|0xff8d33c2c98b7c
block|,
literal|0x2610b39409f849
block|}
block|,
block|{
literal|0x44d1352ac64da0
block|,
literal|0xcdbb7b2c46b4fb
block|,
literal|0x966c079b753c89
block|,
literal|0xfe67e4e820b112
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xe28cae2df5312d
block|,
literal|0xc71b61d16f5c6e
block|,
literal|0x79b7619a3e7c4c
block|,
literal|0x05c73240899b47
block|}
block|,
block|{
literal|0x9f7f6382c73e3a
block|,
literal|0x18615165c56bda
block|,
literal|0x641fab2116fd56
block|,
literal|0x72855882b08394
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x0469182f161c09
block|,
literal|0x74a98ca8d00fb5
block|,
literal|0xb89da93489a3e0
block|,
literal|0x41c98768fb0c1d
block|}
block|,
block|{
literal|0xe5ea05fb32da81
block|,
literal|0x3dce9ffbca6855
block|,
literal|0x1cfe2d3fbf59e6
block|,
literal|0x0e5e03408738a7
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xdab22b2333e87f
block|,
literal|0x4430137a5dd2f6
block|,
literal|0xe03ab9f738beb8
block|,
literal|0xcb0c5d0dc34f24
block|}
block|,
block|{
literal|0x764a7df0c8fda5
block|,
literal|0x185ba5c3fa2044
block|,
literal|0x9281d688bcbe50
block|,
literal|0xc40331df893881
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xb89530796f0f60
block|,
literal|0xade92bd26909a3
block|,
literal|0x1a0c83fb4884da
block|,
literal|0x1765bf22a5a984
block|}
block|,
block|{
literal|0x772a9ee75db09e
block|,
literal|0x23bc6c67cec16f
block|,
literal|0x4c1edba8b14e2f
block|,
literal|0xe2a215d9611369
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x571e509fb5efb3
block|,
literal|0xade88696410552
block|,
literal|0xc8ae85fada74fe
block|,
literal|0x6c7e4be83bbde3
block|}
block|,
block|{
literal|0xff9f51160f4652
block|,
literal|0xb47ce2495a6539
block|,
literal|0xa2946c53b582f4
block|,
literal|0x286d2db3ee9a60
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x40bbd5081a44af
block|,
literal|0x0995183b13926c
block|,
literal|0xbcefba6f47f6d0
block|,
literal|0x215619e9cc0057
block|}
block|,
block|{
literal|0x8bc94d3b0df45e
block|,
literal|0xf11c54a3694f6f
block|,
literal|0x8631b93cdfe8b5
block|,
literal|0xe7e3f4b0982db9
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xb17048ab3e1c7b
block|,
literal|0xac38f36ff8a1d8
block|,
literal|0x1c29819435d2c6
block|,
literal|0xc813132f4c07e9
block|}
block|,
block|{
literal|0x2891425503b11f
block|,
literal|0x08781030579fea
block|,
literal|0xf5426ba5cc9674
block|,
literal|0x1e28ebf18562bc
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x9f31997cc864eb
block|,
literal|0x06cd91d28b5e4c
block|,
literal|0xff17036691a973
block|,
literal|0xf1aef351497c58
block|}
block|,
block|{
literal|0xdd1f2d600564ff
block|,
literal|0xdead073b1402db
block|,
literal|0x74a684435bd693
block|,
literal|0xeea7471f962558
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x9665266dddf554
block|,
literal|0x9613d78b60ef2d
block|,
literal|0xce27a34cdba417
block|,
literal|0xd35ab74d6afc31
block|}
block|,
block|{
literal|0x85ccdd22deb15e
block|,
literal|0x2137e5783a6aab
block|,
literal|0xa141cffd8c93c6
block|,
literal|0x355a1830e90f2d
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x1a494eadaade65
block|,
literal|0xd6da4da77fe53c
block|,
literal|0xe7992996abec86
block|,
literal|0x65c3553c6090e3
block|}
block|,
block|{
literal|0xfa610b1fb09346
block|,
literal|0xf1c6540b8a4aaf
block|,
literal|0xc51a13ccd3cbab
block|,
literal|0x02995b1b18c28a
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x7874568e7295ef
block|,
literal|0x86b419fbe38d04
block|,
literal|0xdc0690a7550d9a
block|,
literal|0xd3966a44beac33
block|}
block|,
block|{
literal|0x2b7280ec29132f
block|,
literal|0xbeaa3b6a032df3
block|,
literal|0xdc7dd88ae41200
block|,
literal|0xd25e2513e3a100
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x924857eb2efafd
block|,
literal|0xac2bce41223190
block|,
literal|0x8edaa1445553fc
block|,
literal|0x825800fd3562d5
block|}
block|,
block|{
literal|0x8d79148ea96621
block|,
literal|0x23a01c3dd9ed8d
block|,
literal|0xaf8b219f9416b5
block|,
literal|0xd8db0cc277daea
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x76a9c3b1a700f0
block|,
literal|0xe9acd29bc7e691
block|,
literal|0x69212d1a6b0327
block|,
literal|0x6322e97fe154be
block|}
block|,
block|{
literal|0x469fc5465d62aa
block|,
literal|0x8d41ed18883b05
block|,
literal|0x1f8eae66c52b88
block|,
literal|0xe4fcbe9325be51
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x825fdf583cac16
block|,
literal|0x020b857c7b023a
block|,
literal|0x683c17744b0165
block|,
literal|0x14ffd0a2daf2f1
block|}
block|,
block|{
literal|0x323b36184218f9
block|,
literal|0x4944ec4e3b47d4
block|,
literal|0xc15b3080841acf
block|,
literal|0x0bced4b01a28bb
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x92ac22230df5c4
block|,
literal|0x52f33b4063eda8
block|,
literal|0xcb3f19870c0c93
block|,
literal|0x40064f2ba65233
block|}
block|,
block|{
literal|0xfe16f0924f8992
block|,
literal|0x012da25af5b517
block|,
literal|0x1a57bb24f723a6
block|,
literal|0x06f8bc76760def
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x4a7084f7817cb9
block|,
literal|0xbcab0738ee9a78
block|,
literal|0x3ec11e11d9c326
block|,
literal|0xdc0fe90e0f1aae
block|}
block|,
block|{
literal|0xcf639ea5f98390
block|,
literal|0x5c350aa22ffb74
block|,
literal|0x9afae98a4047b7
block|,
literal|0x956ec2d617fc45
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x4306d648c1be6a
block|,
literal|0x9247cd8bc9a462
block|,
literal|0xf5595e377d2f2e
block|,
literal|0xbd1c3caff1a52e
block|}
block|,
block|{
literal|0x045e14472409d0
block|,
literal|0x29f3e17078f773
block|,
literal|0x745a602b2d4f7d
block|,
literal|0x191837685cdfbb
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x5b6ee254a8cb79
block|,
literal|0x4953433f5e7026
block|,
literal|0xe21faeb1d1def4
block|,
literal|0xc4c225785c09de
block|}
block|,
block|{
literal|0x307ce7bba1e518
block|,
literal|0x31b125b1036db8
block|,
literal|0x47e91868839e8f
block|,
literal|0xc765866e33b9f3
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x3bfece24f96906
block|,
literal|0x4794da641e5093
block|,
literal|0xde5df64f95db26
block|,
literal|0x297ecd89714b05
block|}
block|,
block|{
literal|0x701bd3ebb2c3aa
block|,
literal|0x7073b4f53cb1d5
block|,
literal|0x13c5665658af16
block|,
literal|0x9895089d66fe58
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0x0fef05f78c4790
block|,
literal|0x2d773633b05d2e
block|,
literal|0x94229c3a951c94
block|,
literal|0xbbbd70df4911bb
block|}
block|,
block|{
literal|0xb2c6963d2c1168
block|,
literal|0x105f47a72b0d73
block|,
literal|0x9fdf6111614080
block|,
literal|0x7b7e94b39e67b0
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xad1a7d6efbe2b3
block|,
literal|0xf012482c0da69d
block|,
literal|0x6b3bdf12438345
block|,
literal|0x40d7558d7aa4d9
block|}
block|,
block|{
literal|0x8a09fffb5c6d3d
block|,
literal|0x9a356e5d9ffd38
block|,
literal|0x5973f15f4f9b1c
block|,
literal|0xdcd5f59f63c3ea
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xacf39f4c5ca7ab
block|,
literal|0x4c8071cc5fd737
block|,
literal|0xc64e3602cd1184
block|,
literal|0x0acd4644c9abba
block|}
block|,
block|{
literal|0x6c011a36d8bf6e
block|,
literal|0xfecd87ba24e32a
block|,
literal|0x19f6f56574fad8
block|,
literal|0x050b204ced9405
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
block|{
literal|0xed4f1cae7d9a96
block|,
literal|0x5ceef7ad94c40a
block|,
literal|0x778e4a3bf3ef9b
block|,
literal|0x7405783dc3b55e
block|}
block|,
block|{
literal|0x32477c61b6e8c6
block|,
literal|0xb46a97570f018b
block|,
literal|0x91176d0a7e95d1
block|,
literal|0x3df90fbc4c7d0e
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Precomputation for the group generator. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|felem
name|g_pre_comp
index|[
literal|2
index|]
index|[
literal|16
index|]
index|[
literal|3
index|]
decl_stmt|;
name|int
name|references
decl_stmt|;
block|}
name|NISTP224_PRE_COMP
typedef|;
end_typedef

begin_function
specifier|const
name|EC_METHOD
modifier|*
name|EC_GFp_nistp224_method
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|EC_METHOD
name|ret
init|=
block|{
name|EC_FLAGS_DEFAULT_OCT
block|,
name|NID_X9_62_prime_field
block|,
name|ec_GFp_nistp224_group_init
block|,
name|ec_GFp_simple_group_finish
block|,
name|ec_GFp_simple_group_clear_finish
block|,
name|ec_GFp_nist_group_copy
block|,
name|ec_GFp_nistp224_group_set_curve
block|,
name|ec_GFp_simple_group_get_curve
block|,
name|ec_GFp_simple_group_get_degree
block|,
name|ec_GFp_simple_group_check_discriminant
block|,
name|ec_GFp_simple_point_init
block|,
name|ec_GFp_simple_point_finish
block|,
name|ec_GFp_simple_point_clear_finish
block|,
name|ec_GFp_simple_point_copy
block|,
name|ec_GFp_simple_point_set_to_infinity
block|,
name|ec_GFp_simple_set_Jprojective_coordinates_GFp
block|,
name|ec_GFp_simple_get_Jprojective_coordinates_GFp
block|,
name|ec_GFp_simple_point_set_affine_coordinates
block|,
name|ec_GFp_nistp224_point_get_affine_coordinates
block|,
literal|0
comment|/* point_set_compressed_coordinates */
block|,
literal|0
comment|/* point2oct */
block|,
literal|0
comment|/* oct2point */
block|,
name|ec_GFp_simple_add
block|,
name|ec_GFp_simple_dbl
block|,
name|ec_GFp_simple_invert
block|,
name|ec_GFp_simple_is_at_infinity
block|,
name|ec_GFp_simple_is_on_curve
block|,
name|ec_GFp_simple_cmp
block|,
name|ec_GFp_simple_make_affine
block|,
name|ec_GFp_simple_points_make_affine
block|,
name|ec_GFp_nistp224_points_mul
block|,
name|ec_GFp_nistp224_precompute_mult
block|,
name|ec_GFp_nistp224_have_precompute_mult
block|,
name|ec_GFp_nist_field_mul
block|,
name|ec_GFp_nist_field_sqr
block|,
literal|0
comment|/* field_div */
block|,
literal|0
comment|/* field_encode */
block|,
literal|0
comment|/* field_decode */
block|,
literal|0
comment|/* field_set_to_one */
block|}
decl_stmt|;
return|return
operator|&
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Helper functions to convert field elements to/from internal representation  */
end_comment

begin_function
specifier|static
name|void
name|bin28_to_felem
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|u8
name|in
index|[
literal|28
index|]
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|=
operator|*
operator|(
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
operator|(
name|in
operator|)
operator|)
operator|&
literal|0x00ffffffffffffff
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
operator|(
operator|*
operator|(
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
operator|(
name|in
operator|+
literal|7
operator|)
operator|)
operator|)
operator|&
literal|0x00ffffffffffffff
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
operator|(
operator|*
operator|(
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
operator|(
name|in
operator|+
literal|14
operator|)
operator|)
operator|)
operator|&
literal|0x00ffffffffffffff
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
operator|(
operator|*
operator|(
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
operator|(
name|in
operator|+
literal|20
operator|)
operator|)
operator|)
operator|>>
literal|8
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|felem_to_bin28
parameter_list|(
name|u8
name|out
index|[
literal|28
index|]
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
operator|++
name|i
control|)
block|{
name|out
index|[
name|i
index|]
operator|=
name|in
index|[
literal|0
index|]
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
name|out
index|[
name|i
operator|+
literal|7
index|]
operator|=
name|in
index|[
literal|1
index|]
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
name|out
index|[
name|i
operator|+
literal|14
index|]
operator|=
name|in
index|[
literal|2
index|]
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
name|out
index|[
name|i
operator|+
literal|21
index|]
operator|=
name|in
index|[
literal|3
index|]
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* To preserve endianness when using BN_bn2bin and BN_bin2bn */
end_comment

begin_function
specifier|static
name|void
name|flip_endian
parameter_list|(
name|u8
modifier|*
name|out
parameter_list|,
specifier|const
name|u8
modifier|*
name|in
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|out
index|[
name|i
index|]
operator|=
name|in
index|[
name|len
operator|-
literal|1
operator|-
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* From OpenSSL BIGNUM to internal representation */
end_comment

begin_function
specifier|static
name|int
name|BN_to_felem
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|bn
parameter_list|)
block|{
name|felem_bytearray
name|b_in
decl_stmt|;
name|felem_bytearray
name|b_out
decl_stmt|;
name|unsigned
name|num_bytes
decl_stmt|;
comment|/* BN_bn2bin eats leading zeroes */
name|memset
argument_list|(
name|b_out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|b_out
argument_list|)
expr_stmt|;
name|num_bytes
operator|=
name|BN_num_bytes
argument_list|(
name|bn
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_bytes
operator|>
sizeof|sizeof
name|b_out
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_BN_TO_FELEM
argument_list|,
name|EC_R_BIGNUM_OUT_OF_RANGE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|BN_is_negative
argument_list|(
name|bn
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_BN_TO_FELEM
argument_list|,
name|EC_R_BIGNUM_OUT_OF_RANGE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|num_bytes
operator|=
name|BN_bn2bin
argument_list|(
name|bn
argument_list|,
name|b_in
argument_list|)
expr_stmt|;
name|flip_endian
argument_list|(
name|b_out
argument_list|,
name|b_in
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
name|bin28_to_felem
argument_list|(
name|out
argument_list|,
name|b_out
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* From internal representation to OpenSSL BIGNUM */
end_comment

begin_function
specifier|static
name|BIGNUM
modifier|*
name|felem_to_BN
parameter_list|(
name|BIGNUM
modifier|*
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
name|felem_bytearray
name|b_in
decl_stmt|,
name|b_out
decl_stmt|;
name|felem_to_bin28
argument_list|(
name|b_in
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|flip_endian
argument_list|(
name|b_out
argument_list|,
name|b_in
argument_list|,
sizeof|sizeof
name|b_out
argument_list|)
expr_stmt|;
return|return
name|BN_bin2bn
argument_list|(
name|b_out
argument_list|,
sizeof|sizeof
name|b_out
argument_list|,
name|out
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*-  *                              FIELD OPERATIONS  *  * Field operations, using the internal representation of field elements.  * NB! These operations are specific to our point multiplication and cannot be  * expected to be correct in general - e.g., multiplication with a large scalar  * will cause an overflow.  *  */
end_comment

begin_function
specifier|static
name|void
name|felem_one
parameter_list|(
name|felem
name|out
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|felem_assign
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|in
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sum two field elements: out += in */
end_comment

begin_function
specifier|static
name|void
name|felem_sum
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|+=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|+=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|in
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get negative value: out = -in */
end_comment

begin_comment
comment|/* Assumes in[i]< 2^57 */
end_comment

begin_function
specifier|static
name|void
name|felem_neg
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
specifier|static
specifier|const
name|limb
name|two58p2
init|=
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|58
operator|)
operator|+
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|2
operator|)
decl_stmt|;
specifier|static
specifier|const
name|limb
name|two58m2
init|=
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|58
operator|)
operator|-
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|2
operator|)
decl_stmt|;
specifier|static
specifier|const
name|limb
name|two58m42m2
init|=
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|58
operator|)
operator|-
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|42
operator|)
operator|-
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|2
operator|)
decl_stmt|;
comment|/* Set to 0 mod 2^224-2^96+1 to ensure out> in */
name|out
index|[
literal|0
index|]
operator|=
name|two58p2
operator|-
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|two58m42m2
operator|-
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|two58m2
operator|-
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|two58m2
operator|-
name|in
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subtract field elements: out -= in */
end_comment

begin_comment
comment|/* Assumes in[i]< 2^57 */
end_comment

begin_function
specifier|static
name|void
name|felem_diff
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
specifier|static
specifier|const
name|limb
name|two58p2
init|=
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|58
operator|)
operator|+
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|2
operator|)
decl_stmt|;
specifier|static
specifier|const
name|limb
name|two58m2
init|=
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|58
operator|)
operator|-
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|2
operator|)
decl_stmt|;
specifier|static
specifier|const
name|limb
name|two58m42m2
init|=
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|58
operator|)
operator|-
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|42
operator|)
operator|-
operator|(
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|2
operator|)
decl_stmt|;
comment|/* Add 0 mod 2^224-2^96+1 to ensure out> in */
name|out
index|[
literal|0
index|]
operator|+=
name|two58p2
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|+=
name|two58m42m2
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
name|two58m2
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|two58m2
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|-=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|-=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|-=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|-=
name|in
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subtract in unreduced 128-bit mode: out -= in */
end_comment

begin_comment
comment|/* Assumes in[i]< 2^119 */
end_comment

begin_function
specifier|static
name|void
name|widefelem_diff
parameter_list|(
name|widefelem
name|out
parameter_list|,
specifier|const
name|widefelem
name|in
parameter_list|)
block|{
specifier|static
specifier|const
name|widelimb
name|two120
init|=
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|120
decl_stmt|;
specifier|static
specifier|const
name|widelimb
name|two120m64
init|=
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|120
operator|)
operator|-
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|64
operator|)
decl_stmt|;
specifier|static
specifier|const
name|widelimb
name|two120m104m64
init|=
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|120
operator|)
operator|-
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|104
operator|)
operator|-
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|64
operator|)
decl_stmt|;
comment|/* Add 0 mod 2^224-2^96+1 to ensure out> in */
name|out
index|[
literal|0
index|]
operator|+=
name|two120
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|+=
name|two120m64
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
name|two120m64
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|two120
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|+=
name|two120m104m64
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|+=
name|two120m64
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|+=
name|two120m64
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|-=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|-=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|-=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|-=
name|in
index|[
literal|3
index|]
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|-=
name|in
index|[
literal|4
index|]
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|-=
name|in
index|[
literal|5
index|]
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|-=
name|in
index|[
literal|6
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subtract in mixed mode: out128 -= in64 */
end_comment

begin_comment
comment|/* in[i]< 2^63 */
end_comment

begin_function
specifier|static
name|void
name|felem_diff_128_64
parameter_list|(
name|widefelem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
specifier|static
specifier|const
name|widelimb
name|two64p8
init|=
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|64
operator|)
operator|+
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|8
operator|)
decl_stmt|;
specifier|static
specifier|const
name|widelimb
name|two64m8
init|=
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|64
operator|)
operator|-
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|8
operator|)
decl_stmt|;
specifier|static
specifier|const
name|widelimb
name|two64m48m8
init|=
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|64
operator|)
operator|-
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|48
operator|)
operator|-
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|8
operator|)
decl_stmt|;
comment|/* Add 0 mod 2^224-2^96+1 to ensure out> in */
name|out
index|[
literal|0
index|]
operator|+=
name|two64p8
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|+=
name|two64m48m8
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|+=
name|two64m8
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|+=
name|two64m8
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|-=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|-=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|-=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|-=
name|in
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Multiply a field element by a scalar: out = out * scalar The scalars we  * actually use are small, so results fit without overflow  */
end_comment

begin_function
specifier|static
name|void
name|felem_scalar
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|limb
name|scalar
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|*=
name|scalar
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Multiply an unreduced field element by a scalar: out = out * scalar The  * scalars we actually use are small, so results fit without overflow  */
end_comment

begin_function
specifier|static
name|void
name|widefelem_scalar
parameter_list|(
name|widefelem
name|out
parameter_list|,
specifier|const
name|widelimb
name|scalar
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|*=
name|scalar
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|*=
name|scalar
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Square a field element: out = in^2 */
end_comment

begin_function
specifier|static
name|void
name|felem_square
parameter_list|(
name|widefelem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
name|limb
name|tmp0
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|tmp0
operator|=
literal|2
operator|*
name|in
index|[
literal|0
index|]
expr_stmt|;
name|tmp1
operator|=
literal|2
operator|*
name|in
index|[
literal|1
index|]
expr_stmt|;
name|tmp2
operator|=
literal|2
operator|*
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|widelimb
operator|)
name|in
index|[
literal|0
index|]
operator|)
operator|*
name|in
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|widelimb
operator|)
name|in
index|[
literal|0
index|]
operator|)
operator|*
name|tmp1
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|widelimb
operator|)
name|in
index|[
literal|0
index|]
operator|)
operator|*
name|tmp2
operator|+
operator|(
operator|(
name|widelimb
operator|)
name|in
index|[
literal|1
index|]
operator|)
operator|*
name|in
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|widelimb
operator|)
name|in
index|[
literal|3
index|]
operator|)
operator|*
name|tmp0
operator|+
operator|(
operator|(
name|widelimb
operator|)
name|in
index|[
literal|1
index|]
operator|)
operator|*
name|tmp2
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|=
operator|(
operator|(
name|widelimb
operator|)
name|in
index|[
literal|3
index|]
operator|)
operator|*
name|tmp1
operator|+
operator|(
operator|(
name|widelimb
operator|)
name|in
index|[
literal|2
index|]
operator|)
operator|*
name|in
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|=
operator|(
operator|(
name|widelimb
operator|)
name|in
index|[
literal|3
index|]
operator|)
operator|*
name|tmp2
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|=
operator|(
operator|(
name|widelimb
operator|)
name|in
index|[
literal|3
index|]
operator|)
operator|*
name|in
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Multiply two field elements: out = in1 * in2 */
end_comment

begin_function
specifier|static
name|void
name|felem_mul
parameter_list|(
name|widefelem
name|out
parameter_list|,
specifier|const
name|felem
name|in1
parameter_list|,
specifier|const
name|felem
name|in2
parameter_list|)
block|{
name|out
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|0
index|]
operator|)
operator|*
name|in2
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|0
index|]
operator|)
operator|*
name|in2
index|[
literal|1
index|]
operator|+
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|1
index|]
operator|)
operator|*
name|in2
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|0
index|]
operator|)
operator|*
name|in2
index|[
literal|2
index|]
operator|+
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|1
index|]
operator|)
operator|*
name|in2
index|[
literal|1
index|]
operator|+
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|2
index|]
operator|)
operator|*
name|in2
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|0
index|]
operator|)
operator|*
name|in2
index|[
literal|3
index|]
operator|+
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|1
index|]
operator|)
operator|*
name|in2
index|[
literal|2
index|]
operator|+
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|2
index|]
operator|)
operator|*
name|in2
index|[
literal|1
index|]
operator|+
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|3
index|]
operator|)
operator|*
name|in2
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|=
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|1
index|]
operator|)
operator|*
name|in2
index|[
literal|3
index|]
operator|+
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|2
index|]
operator|)
operator|*
name|in2
index|[
literal|2
index|]
operator|+
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|3
index|]
operator|)
operator|*
name|in2
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|=
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|2
index|]
operator|)
operator|*
name|in2
index|[
literal|3
index|]
operator|+
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|3
index|]
operator|)
operator|*
name|in2
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|=
operator|(
operator|(
name|widelimb
operator|)
name|in1
index|[
literal|3
index|]
operator|)
operator|*
name|in2
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Reduce seven 128-bit coefficients to four 64-bit coefficients.  * Requires in[i]< 2^126,  * ensures out[0]< 2^56, out[1]< 2^56, out[2]< 2^56, out[3]<= 2^56 + 2^16 */
end_comment

begin_function
specifier|static
name|void
name|felem_reduce
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|widefelem
name|in
parameter_list|)
block|{
specifier|static
specifier|const
name|widelimb
name|two127p15
init|=
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|127
operator|)
operator|+
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|15
operator|)
decl_stmt|;
specifier|static
specifier|const
name|widelimb
name|two127m71
init|=
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|127
operator|)
operator|-
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|71
operator|)
decl_stmt|;
specifier|static
specifier|const
name|widelimb
name|two127m71m55
init|=
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|127
operator|)
operator|-
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|71
operator|)
operator|-
operator|(
operator|(
operator|(
name|widelimb
operator|)
literal|1
operator|)
operator|<<
literal|55
operator|)
decl_stmt|;
name|widelimb
name|output
index|[
literal|5
index|]
decl_stmt|;
comment|/* Add 0 mod 2^224-2^96+1 to ensure all differences are positive */
name|output
index|[
literal|0
index|]
operator|=
name|in
index|[
literal|0
index|]
operator|+
name|two127p15
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
name|in
index|[
literal|1
index|]
operator|+
name|two127m71m55
expr_stmt|;
name|output
index|[
literal|2
index|]
operator|=
name|in
index|[
literal|2
index|]
operator|+
name|two127m71
expr_stmt|;
name|output
index|[
literal|3
index|]
operator|=
name|in
index|[
literal|3
index|]
expr_stmt|;
name|output
index|[
literal|4
index|]
operator|=
name|in
index|[
literal|4
index|]
expr_stmt|;
comment|/* Eliminate in[4], in[5], in[6] */
name|output
index|[
literal|4
index|]
operator|+=
name|in
index|[
literal|6
index|]
operator|>>
literal|16
expr_stmt|;
name|output
index|[
literal|3
index|]
operator|+=
operator|(
name|in
index|[
literal|6
index|]
operator|&
literal|0xffff
operator|)
operator|<<
literal|40
expr_stmt|;
name|output
index|[
literal|2
index|]
operator|-=
name|in
index|[
literal|6
index|]
expr_stmt|;
name|output
index|[
literal|3
index|]
operator|+=
name|in
index|[
literal|5
index|]
operator|>>
literal|16
expr_stmt|;
name|output
index|[
literal|2
index|]
operator|+=
operator|(
name|in
index|[
literal|5
index|]
operator|&
literal|0xffff
operator|)
operator|<<
literal|40
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|-=
name|in
index|[
literal|5
index|]
expr_stmt|;
name|output
index|[
literal|2
index|]
operator|+=
name|output
index|[
literal|4
index|]
operator|>>
literal|16
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|+=
operator|(
name|output
index|[
literal|4
index|]
operator|&
literal|0xffff
operator|)
operator|<<
literal|40
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|-=
name|output
index|[
literal|4
index|]
expr_stmt|;
comment|/* Carry 2 -> 3 -> 4 */
name|output
index|[
literal|3
index|]
operator|+=
name|output
index|[
literal|2
index|]
operator|>>
literal|56
expr_stmt|;
name|output
index|[
literal|2
index|]
operator|&=
literal|0x00ffffffffffffff
expr_stmt|;
name|output
index|[
literal|4
index|]
operator|=
name|output
index|[
literal|3
index|]
operator|>>
literal|56
expr_stmt|;
name|output
index|[
literal|3
index|]
operator|&=
literal|0x00ffffffffffffff
expr_stmt|;
comment|/* Now output[2]< 2^56, output[3]< 2^56, output[4]< 2^72 */
comment|/* Eliminate output[4] */
name|output
index|[
literal|2
index|]
operator|+=
name|output
index|[
literal|4
index|]
operator|>>
literal|16
expr_stmt|;
comment|/* output[2]< 2^56 + 2^56 = 2^57 */
name|output
index|[
literal|1
index|]
operator|+=
operator|(
name|output
index|[
literal|4
index|]
operator|&
literal|0xffff
operator|)
operator|<<
literal|40
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|-=
name|output
index|[
literal|4
index|]
expr_stmt|;
comment|/* Carry 0 -> 1 -> 2 -> 3 */
name|output
index|[
literal|1
index|]
operator|+=
name|output
index|[
literal|0
index|]
operator|>>
literal|56
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
name|output
index|[
literal|0
index|]
operator|&
literal|0x00ffffffffffffff
expr_stmt|;
name|output
index|[
literal|2
index|]
operator|+=
name|output
index|[
literal|1
index|]
operator|>>
literal|56
expr_stmt|;
comment|/* output[2]< 2^57 + 2^72 */
name|out
index|[
literal|1
index|]
operator|=
name|output
index|[
literal|1
index|]
operator|&
literal|0x00ffffffffffffff
expr_stmt|;
name|output
index|[
literal|3
index|]
operator|+=
name|output
index|[
literal|2
index|]
operator|>>
literal|56
expr_stmt|;
comment|/* output[3]<= 2^56 + 2^16 */
name|out
index|[
literal|2
index|]
operator|=
name|output
index|[
literal|2
index|]
operator|&
literal|0x00ffffffffffffff
expr_stmt|;
comment|/*-      * out[0]< 2^56, out[1]< 2^56, out[2]< 2^56,      * out[3]<= 2^56 + 2^16 (due to final carry),      * so out< 2*p      */
name|out
index|[
literal|3
index|]
operator|=
name|output
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|felem_square_reduce
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
name|widefelem
name|tmp
decl_stmt|;
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|felem_mul_reduce
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|felem
name|in1
parameter_list|,
specifier|const
name|felem
name|in2
parameter_list|)
block|{
name|widefelem
name|tmp
decl_stmt|;
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|in1
argument_list|,
name|in2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reduce to unique minimal representation. Requires 0<= in< 2*p (always  * call felem_reduce first)  */
end_comment

begin_function
specifier|static
name|void
name|felem_contract
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
specifier|static
specifier|const
name|int64_t
name|two56
init|=
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
operator|<<
literal|56
decl_stmt|;
comment|/* 0<= in< 2*p, p = 2^224 - 2^96 + 1 */
comment|/* if in> p , reduce in = in - 2^224 + 2^96 - 1 */
name|int64_t
name|tmp
index|[
literal|4
index|]
decl_stmt|,
name|a
decl_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|tmp
index|[
literal|2
index|]
operator|=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|tmp
index|[
literal|3
index|]
operator|=
name|in
index|[
literal|3
index|]
expr_stmt|;
comment|/* Case 1: a = 1 iff in>= 2^224 */
name|a
operator|=
operator|(
name|in
index|[
literal|3
index|]
operator|>>
literal|56
operator|)
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator|-=
name|a
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|+=
name|a
operator|<<
literal|40
expr_stmt|;
name|tmp
index|[
literal|3
index|]
operator|&=
literal|0x00ffffffffffffff
expr_stmt|;
comment|/*      * Case 2: a = 0 iff p<= in< 2^224, i.e., the high 128 bits are all 1      * and the lower part is non-zero      */
name|a
operator|=
operator|(
operator|(
name|in
index|[
literal|3
index|]
operator|&
name|in
index|[
literal|2
index|]
operator|&
operator|(
name|in
index|[
literal|1
index|]
operator||
literal|0x000000ffffffffff
operator|)
operator|)
operator|+
literal|1
operator|)
operator||
operator|(
operator|(
call|(
name|int64_t
call|)
argument_list|(
name|in
index|[
literal|0
index|]
operator|+
operator|(
name|in
index|[
literal|1
index|]
operator|&
literal|0x000000ffffffffff
operator|)
argument_list|)
operator|-
literal|1
operator|)
operator|>>
literal|63
operator|)
expr_stmt|;
name|a
operator|&=
literal|0x00ffffffffffffff
expr_stmt|;
comment|/* turn a into an all-one mask (if a = 0) or an all-zero mask */
name|a
operator|=
operator|(
name|a
operator|-
literal|1
operator|)
operator|>>
literal|63
expr_stmt|;
comment|/* subtract 2^224 - 2^96 + 1 if a is all-one */
name|tmp
index|[
literal|3
index|]
operator|&=
name|a
operator|^
literal|0xffffffffffffffff
expr_stmt|;
name|tmp
index|[
literal|2
index|]
operator|&=
name|a
operator|^
literal|0xffffffffffffffff
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|&=
operator|(
name|a
operator|^
literal|0xffffffffffffffff
operator|)
operator||
literal|0x000000ffffffffff
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator|-=
literal|1
operator|&
name|a
expr_stmt|;
comment|/*      * eliminate negative coefficients: if tmp[0] is negative, tmp[1] must be      * non-zero, so we only need one step      */
name|a
operator|=
name|tmp
index|[
literal|0
index|]
operator|>>
literal|63
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator|+=
name|two56
operator|&
name|a
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|-=
literal|1
operator|&
name|a
expr_stmt|;
comment|/* carry 1 -> 2 -> 3 */
name|tmp
index|[
literal|2
index|]
operator|+=
name|tmp
index|[
literal|1
index|]
operator|>>
literal|56
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|&=
literal|0x00ffffffffffffff
expr_stmt|;
name|tmp
index|[
literal|3
index|]
operator|+=
name|tmp
index|[
literal|2
index|]
operator|>>
literal|56
expr_stmt|;
name|tmp
index|[
literal|2
index|]
operator|&=
literal|0x00ffffffffffffff
expr_stmt|;
comment|/* Now 0<= out< p */
name|out
index|[
literal|0
index|]
operator|=
name|tmp
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|tmp
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|tmp
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|tmp
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Zero-check: returns 1 if input is 0, and 0 otherwise. We know that field  * elements are reduced to in< 2^225, so we only need to check three cases:  * 0, 2^224 - 2^96 + 1, and 2^225 - 2^97 + 2  */
end_comment

begin_function
specifier|static
name|limb
name|felem_is_zero
parameter_list|(
specifier|const
name|felem
name|in
parameter_list|)
block|{
name|limb
name|zero
decl_stmt|,
name|two224m96p1
decl_stmt|,
name|two225m97p2
decl_stmt|;
name|zero
operator|=
name|in
index|[
literal|0
index|]
operator||
name|in
index|[
literal|1
index|]
operator||
name|in
index|[
literal|2
index|]
operator||
name|in
index|[
literal|3
index|]
expr_stmt|;
name|zero
operator|=
operator|(
operator|(
call|(
name|int64_t
call|)
argument_list|(
name|zero
argument_list|)
operator|-
literal|1
operator|)
operator|>>
literal|63
operator|)
operator|&
literal|1
expr_stmt|;
name|two224m96p1
operator|=
operator|(
name|in
index|[
literal|0
index|]
operator|^
literal|1
operator|)
operator||
operator|(
name|in
index|[
literal|1
index|]
operator|^
literal|0x00ffff0000000000
operator|)
operator||
operator|(
name|in
index|[
literal|2
index|]
operator|^
literal|0x00ffffffffffffff
operator|)
operator||
operator|(
name|in
index|[
literal|3
index|]
operator|^
literal|0x00ffffffffffffff
operator|)
expr_stmt|;
name|two224m96p1
operator|=
operator|(
operator|(
call|(
name|int64_t
call|)
argument_list|(
name|two224m96p1
argument_list|)
operator|-
literal|1
operator|)
operator|>>
literal|63
operator|)
operator|&
literal|1
expr_stmt|;
name|two225m97p2
operator|=
operator|(
name|in
index|[
literal|0
index|]
operator|^
literal|2
operator|)
operator||
operator|(
name|in
index|[
literal|1
index|]
operator|^
literal|0x00fffe0000000000
operator|)
operator||
operator|(
name|in
index|[
literal|2
index|]
operator|^
literal|0x00ffffffffffffff
operator|)
operator||
operator|(
name|in
index|[
literal|3
index|]
operator|^
literal|0x01ffffffffffffff
operator|)
expr_stmt|;
name|two225m97p2
operator|=
operator|(
operator|(
call|(
name|int64_t
call|)
argument_list|(
name|two225m97p2
argument_list|)
operator|-
literal|1
operator|)
operator|>>
literal|63
operator|)
operator|&
literal|1
expr_stmt|;
return|return
operator|(
name|zero
operator||
name|two224m96p1
operator||
name|two225m97p2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|limb
name|felem_is_zero_int
parameter_list|(
specifier|const
name|felem
name|in
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|felem_is_zero
argument_list|(
name|in
argument_list|)
operator|&
operator|(
operator|(
name|limb
operator|)
literal|1
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Invert a field element */
end_comment

begin_comment
comment|/* Computation chain copied from djb's code */
end_comment

begin_function
specifier|static
name|void
name|felem_inv
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|)
block|{
name|felem
name|ftmp
decl_stmt|,
name|ftmp2
decl_stmt|,
name|ftmp3
decl_stmt|,
name|ftmp4
decl_stmt|;
name|widefelem
name|tmp
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|in
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^2 - 1 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^3 - 2 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|in
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^3 - 1 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^4 - 2 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^5 - 4 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^6 - 8 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^6 - 1 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^7 - 2 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
operator|++
name|i
control|)
block|{
comment|/* 2^12 - 2^6 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^12 - 1 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp3
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^13 - 2 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|11
condition|;
operator|++
name|i
control|)
block|{
comment|/* 2^24 - 2^12 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp3
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp3
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp3
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^24 - 1 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp3
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^25 - 2 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|23
condition|;
operator|++
name|i
control|)
block|{
comment|/* 2^48 - 2^24 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp3
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp3
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp3
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp3
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^48 - 1 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp3
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp4
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^49 - 2 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|47
condition|;
operator|++
name|i
control|)
block|{
comment|/* 2^96 - 2^48 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp4
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp4
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp3
argument_list|,
name|ftmp4
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp3
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^96 - 1 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp3
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp4
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^97 - 2 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|23
condition|;
operator|++
name|i
control|)
block|{
comment|/* 2^120 - 2^24 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp4
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp4
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|,
name|ftmp4
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^120 - 1 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
operator|++
name|i
control|)
block|{
comment|/* 2^126 - 2^6 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^126 - 1 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^127 - 2 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^127 - 1 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|97
condition|;
operator|++
name|i
control|)
block|{
comment|/* 2^224 - 2^97 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|,
name|ftmp3
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 2^224 - 2^96 - 1 */
block|}
end_function

begin_comment
comment|/*  * Copy in constant time: if icopy == 1, copy in to out, if icopy == 0, copy  * out to itself.  */
end_comment

begin_function
specifier|static
name|void
name|copy_conditional
parameter_list|(
name|felem
name|out
parameter_list|,
specifier|const
name|felem
name|in
parameter_list|,
name|limb
name|icopy
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/*      * icopy is a (64-bit) 0 or 1, so copy is either all-zero or all-one      */
specifier|const
name|limb
name|copy
init|=
operator|-
name|icopy
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|limb
name|tmp
init|=
name|copy
operator|&
operator|(
name|in
index|[
name|i
index|]
operator|^
name|out
index|[
name|i
index|]
operator|)
decl_stmt|;
name|out
index|[
name|i
index|]
operator|^=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*-  *                       ELLIPTIC CURVE POINT OPERATIONS  *  * Points are represented in Jacobian projective coordinates:  * (X, Y, Z) corresponds to the affine point (X/Z^2, Y/Z^3),  * or to the point at infinity if Z == 0.  *  */
end_comment

begin_comment
comment|/*-  * Double an elliptic curve point:  * (X', Y', Z') = 2 * (X, Y, Z), where  * X' = (3 * (X - Z^2) * (X + Z^2))^2 - 8 * X * Y^2  * Y' = 3 * (X - Z^2) * (X + Z^2) * (4 * X * Y^2 - X') - 8 * Y^2  * Z' = (Y + Z)^2 - Y^2 - Z^2 = 2 * Y * Z  * Outputs can equal corresponding inputs, i.e., x_out == x_in is allowed,  * while x_out == y_in is not (maybe this works, but it's not tested).  */
end_comment

begin_function
specifier|static
name|void
name|point_double
parameter_list|(
name|felem
name|x_out
parameter_list|,
name|felem
name|y_out
parameter_list|,
name|felem
name|z_out
parameter_list|,
specifier|const
name|felem
name|x_in
parameter_list|,
specifier|const
name|felem
name|y_in
parameter_list|,
specifier|const
name|felem
name|z_in
parameter_list|)
block|{
name|widefelem
name|tmp
decl_stmt|,
name|tmp2
decl_stmt|;
name|felem
name|delta
decl_stmt|,
name|gamma
decl_stmt|,
name|beta
decl_stmt|,
name|alpha
decl_stmt|,
name|ftmp
decl_stmt|,
name|ftmp2
decl_stmt|;
name|felem_assign
argument_list|(
name|ftmp
argument_list|,
name|x_in
argument_list|)
expr_stmt|;
name|felem_assign
argument_list|(
name|ftmp2
argument_list|,
name|x_in
argument_list|)
expr_stmt|;
comment|/* delta = z^2 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|z_in
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|delta
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* gamma = y^2 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|y_in
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|gamma
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* beta = x*gamma */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|x_in
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|beta
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* alpha = 3*(x-delta)*(x+delta) */
name|felem_diff
argument_list|(
name|ftmp
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* ftmp[i]< 2^57 + 2^58 + 2< 2^59 */
name|felem_sum
argument_list|(
name|ftmp2
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* ftmp2[i]< 2^57 + 2^57 = 2^58 */
name|felem_scalar
argument_list|(
name|ftmp2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* ftmp2[i]< 3 * 2^58< 2^60 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
comment|/* tmp[i]< 2^60 * 2^59 * 4 = 2^121 */
name|felem_reduce
argument_list|(
name|alpha
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* x' = alpha^2 - 8*beta */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
comment|/* tmp[i]< 4 * 2^57 * 2^57 = 2^116 */
name|felem_assign
argument_list|(
name|ftmp
argument_list|,
name|beta
argument_list|)
expr_stmt|;
name|felem_scalar
argument_list|(
name|ftmp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* ftmp[i]< 8 * 2^57 = 2^60 */
name|felem_diff_128_64
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
comment|/* tmp[i]< 2^116 + 2^64 + 8< 2^117 */
name|felem_reduce
argument_list|(
name|x_out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* z' = (y + z)^2 - gamma - delta */
name|felem_sum
argument_list|(
name|delta
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
comment|/* delta[i]< 2^57 + 2^57 = 2^58 */
name|felem_assign
argument_list|(
name|ftmp
argument_list|,
name|y_in
argument_list|)
expr_stmt|;
name|felem_sum
argument_list|(
name|ftmp
argument_list|,
name|z_in
argument_list|)
expr_stmt|;
comment|/* ftmp[i]< 2^57 + 2^57 = 2^58 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
comment|/* tmp[i]< 4 * 2^58 * 2^58 = 2^118 */
name|felem_diff_128_64
argument_list|(
name|tmp
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* tmp[i]< 2^118 + 2^64 + 8< 2^119 */
name|felem_reduce
argument_list|(
name|z_out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* y' = alpha*(4*beta - x') - 8*gamma^2 */
name|felem_scalar
argument_list|(
name|beta
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* beta[i]< 4 * 2^57 = 2^59 */
name|felem_diff
argument_list|(
name|beta
argument_list|,
name|x_out
argument_list|)
expr_stmt|;
comment|/* beta[i]< 2^59 + 2^58 + 2< 2^60 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|alpha
argument_list|,
name|beta
argument_list|)
expr_stmt|;
comment|/* tmp[i]< 4 * 2^57 * 2^60 = 2^119 */
name|felem_square
argument_list|(
name|tmp2
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
comment|/* tmp2[i]< 4 * 2^57 * 2^57 = 2^116 */
name|widefelem_scalar
argument_list|(
name|tmp2
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* tmp2[i]< 8 * 2^116 = 2^119 */
name|widefelem_diff
argument_list|(
name|tmp
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
comment|/* tmp[i]< 2^119 + 2^120< 2^121 */
name|felem_reduce
argument_list|(
name|y_out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Add two elliptic curve points:  * (X_1, Y_1, Z_1) + (X_2, Y_2, Z_2) = (X_3, Y_3, Z_3), where  * X_3 = (Z_1^3 * Y_2 - Z_2^3 * Y_1)^2 - (Z_1^2 * X_2 - Z_2^2 * X_1)^3 -  * 2 * Z_2^2 * X_1 * (Z_1^2 * X_2 - Z_2^2 * X_1)^2  * Y_3 = (Z_1^3 * Y_2 - Z_2^3 * Y_1) * (Z_2^2 * X_1 * (Z_1^2 * X_2 - Z_2^2 * X_1)^2 - X_3) -  *        Z_2^3 * Y_1 * (Z_1^2 * X_2 - Z_2^2 * X_1)^3  * Z_3 = (Z_1^2 * X_2 - Z_2^2 * X_1) * (Z_1 * Z_2)  *  * This runs faster if 'mixed' is set, which requires Z_2 = 1 or Z_2 = 0.  */
end_comment

begin_comment
comment|/*  * This function is not entirely constant-time: it includes a branch for  * checking whether the two input points are equal, (while not equal to the  * point at infinity). This case never happens during single point  * multiplication, so there is no timing leak for ECDH or ECDSA signing.  */
end_comment

begin_function
specifier|static
name|void
name|point_add
parameter_list|(
name|felem
name|x3
parameter_list|,
name|felem
name|y3
parameter_list|,
name|felem
name|z3
parameter_list|,
specifier|const
name|felem
name|x1
parameter_list|,
specifier|const
name|felem
name|y1
parameter_list|,
specifier|const
name|felem
name|z1
parameter_list|,
specifier|const
name|int
name|mixed
parameter_list|,
specifier|const
name|felem
name|x2
parameter_list|,
specifier|const
name|felem
name|y2
parameter_list|,
specifier|const
name|felem
name|z2
parameter_list|)
block|{
name|felem
name|ftmp
decl_stmt|,
name|ftmp2
decl_stmt|,
name|ftmp3
decl_stmt|,
name|ftmp4
decl_stmt|,
name|ftmp5
decl_stmt|,
name|x_out
decl_stmt|,
name|y_out
decl_stmt|,
name|z_out
decl_stmt|;
name|widefelem
name|tmp
decl_stmt|,
name|tmp2
decl_stmt|;
name|limb
name|z1_is_zero
decl_stmt|,
name|z2_is_zero
decl_stmt|,
name|x_equal
decl_stmt|,
name|y_equal
decl_stmt|;
if|if
condition|(
operator|!
name|mixed
condition|)
block|{
comment|/* ftmp2 = z2^2 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* ftmp4 = z2^3 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp4
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* ftmp4 = z2^3*y1 */
name|felem_mul
argument_list|(
name|tmp2
argument_list|,
name|ftmp4
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp4
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
comment|/* ftmp2 = z2^2*x1 */
name|felem_mul
argument_list|(
name|tmp2
argument_list|,
name|ftmp2
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*          * We'll assume z2 = 1 (special case z2 = 0 is handled later)          */
comment|/* ftmp4 = z2^3*y1 */
name|felem_assign
argument_list|(
name|ftmp4
argument_list|,
name|y1
argument_list|)
expr_stmt|;
comment|/* ftmp2 = z2^2*x1 */
name|felem_assign
argument_list|(
name|ftmp2
argument_list|,
name|x1
argument_list|)
expr_stmt|;
block|}
comment|/* ftmp = z1^2 */
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|z1
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* ftmp3 = z1^3 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|,
name|z1
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp3
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* tmp = z1^3*y2 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp3
argument_list|,
name|y2
argument_list|)
expr_stmt|;
comment|/* tmp[i]< 4 * 2^57 * 2^57 = 2^116 */
comment|/* ftmp3 = z1^3*y2 - z2^3*y1 */
name|felem_diff_128_64
argument_list|(
name|tmp
argument_list|,
name|ftmp4
argument_list|)
expr_stmt|;
comment|/* tmp[i]< 2^116 + 2^64 + 8< 2^117 */
name|felem_reduce
argument_list|(
name|ftmp3
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* tmp = z1^2*x2 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|,
name|x2
argument_list|)
expr_stmt|;
comment|/* tmp[i]< 4 * 2^57 * 2^57 = 2^116 */
comment|/* ftmp = z1^2*x2 - z2^2*x1 */
name|felem_diff_128_64
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
comment|/* tmp[i]< 2^116 + 2^64 + 8< 2^117 */
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/*      * the formulae are incorrect if the points are equal so we check for      * this and do doubling if this happens      */
name|x_equal
operator|=
name|felem_is_zero
argument_list|(
name|ftmp
argument_list|)
expr_stmt|;
name|y_equal
operator|=
name|felem_is_zero
argument_list|(
name|ftmp3
argument_list|)
expr_stmt|;
name|z1_is_zero
operator|=
name|felem_is_zero
argument_list|(
name|z1
argument_list|)
expr_stmt|;
name|z2_is_zero
operator|=
name|felem_is_zero
argument_list|(
name|z2
argument_list|)
expr_stmt|;
comment|/* In affine coordinates, (X_1, Y_1) == (X_2, Y_2) */
if|if
condition|(
name|x_equal
operator|&&
name|y_equal
operator|&&
operator|!
name|z1_is_zero
operator|&&
operator|!
name|z2_is_zero
condition|)
block|{
name|point_double
argument_list|(
name|x3
argument_list|,
name|y3
argument_list|,
name|z3
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|z1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ftmp5 = z1*z2 */
if|if
condition|(
operator|!
name|mixed
condition|)
block|{
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|z1
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp5
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* special case z2 = 0 is handled later */
name|felem_assign
argument_list|(
name|ftmp5
argument_list|,
name|z1
argument_list|)
expr_stmt|;
block|}
comment|/* z_out = (z1^2*x2 - z2^2*x1)*(z1*z2) */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|,
name|ftmp5
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|z_out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* ftmp = (z1^2*x2 - z2^2*x1)^2 */
name|felem_assign
argument_list|(
name|ftmp5
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* ftmp5 = (z1^2*x2 - z2^2*x1)^3 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp
argument_list|,
name|ftmp5
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp5
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp2
argument_list|,
name|ftmp
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|ftmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* tmp = z2^3*y1*(z1^2*x2 - z2^2*x1)^3 */
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|ftmp4
argument_list|,
name|ftmp5
argument_list|)
expr_stmt|;
comment|/* tmp[i]< 4 * 2^57 * 2^57 = 2^116 */
comment|/* tmp2 = (z1^3*y2 - z2^3*y1)^2 */
name|felem_square
argument_list|(
name|tmp2
argument_list|,
name|ftmp3
argument_list|)
expr_stmt|;
comment|/* tmp2[i]< 4 * 2^57 * 2^57< 2^116 */
comment|/* tmp2 = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 */
name|felem_diff_128_64
argument_list|(
name|tmp2
argument_list|,
name|ftmp5
argument_list|)
expr_stmt|;
comment|/* tmp2[i]< 2^116 + 2^64 + 8< 2^117 */
comment|/* ftmp5 = 2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */
name|felem_assign
argument_list|(
name|ftmp5
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
name|felem_scalar
argument_list|(
name|ftmp5
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* ftmp5[i]< 2 * 2^57 = 2^58 */
comment|/*-      * x_out = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 -      *  2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2      */
name|felem_diff_128_64
argument_list|(
name|tmp2
argument_list|,
name|ftmp5
argument_list|)
expr_stmt|;
comment|/* tmp2[i]< 2^117 + 2^64 + 8< 2^118 */
name|felem_reduce
argument_list|(
name|x_out
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
comment|/* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out */
name|felem_diff
argument_list|(
name|ftmp2
argument_list|,
name|x_out
argument_list|)
expr_stmt|;
comment|/* ftmp2[i]< 2^57 + 2^58 + 2< 2^59 */
comment|/*      * tmp2 = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out)      */
name|felem_mul
argument_list|(
name|tmp2
argument_list|,
name|ftmp3
argument_list|,
name|ftmp2
argument_list|)
expr_stmt|;
comment|/* tmp2[i]< 4 * 2^57 * 2^59 = 2^118 */
comment|/*-      * y_out = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out) -      *  z2^3*y1*(z1^2*x2 - z2^2*x1)^3      */
name|widefelem_diff
argument_list|(
name|tmp2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* tmp2[i]< 2^118 + 2^120< 2^121 */
name|felem_reduce
argument_list|(
name|y_out
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
comment|/*      * the result (x_out, y_out, z_out) is incorrect if one of the inputs is      * the point at infinity, so we need to check for this separately      */
comment|/*      * if point 1 is at infinity, copy point 2 to output, and vice versa      */
name|copy_conditional
argument_list|(
name|x_out
argument_list|,
name|x2
argument_list|,
name|z1_is_zero
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|x_out
argument_list|,
name|x1
argument_list|,
name|z2_is_zero
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|y_out
argument_list|,
name|y2
argument_list|,
name|z1_is_zero
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|y_out
argument_list|,
name|y1
argument_list|,
name|z2_is_zero
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|z_out
argument_list|,
name|z2
argument_list|,
name|z1_is_zero
argument_list|)
expr_stmt|;
name|copy_conditional
argument_list|(
name|z_out
argument_list|,
name|z1
argument_list|,
name|z2_is_zero
argument_list|)
expr_stmt|;
name|felem_assign
argument_list|(
name|x3
argument_list|,
name|x_out
argument_list|)
expr_stmt|;
name|felem_assign
argument_list|(
name|y3
argument_list|,
name|y_out
argument_list|)
expr_stmt|;
name|felem_assign
argument_list|(
name|z3
argument_list|,
name|z_out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * select_point selects the |idx|th point from a precomputation table and  * copies it to out.  * The pre_comp array argument should be size of |size| argument  */
end_comment

begin_function
specifier|static
name|void
name|select_point
parameter_list|(
specifier|const
name|u64
name|idx
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
specifier|const
name|felem
name|pre_comp
index|[]
index|[
literal|3
index|]
parameter_list|,
name|felem
name|out
index|[
literal|3
index|]
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|;
name|limb
modifier|*
name|outlimbs
init|=
operator|&
name|out
index|[
literal|0
index|]
index|[
literal|0
index|]
decl_stmt|;
name|memset
argument_list|(
name|outlimbs
argument_list|,
literal|0
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|felem
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|limb
modifier|*
name|inlimbs
init|=
operator|&
name|pre_comp
index|[
name|i
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
decl_stmt|;
name|u64
name|mask
init|=
name|i
operator|^
name|idx
decl_stmt|;
name|mask
operator||=
name|mask
operator|>>
literal|4
expr_stmt|;
name|mask
operator||=
name|mask
operator|>>
literal|2
expr_stmt|;
name|mask
operator||=
name|mask
operator|>>
literal|1
expr_stmt|;
name|mask
operator|&=
literal|1
expr_stmt|;
name|mask
operator|--
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
operator|*
literal|3
condition|;
name|j
operator|++
control|)
name|outlimbs
index|[
name|j
index|]
operator||=
name|inlimbs
index|[
name|j
index|]
operator|&
name|mask
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* get_bit returns the |i|th bit in |in| */
end_comment

begin_function
specifier|static
name|char
name|get_bit
parameter_list|(
specifier|const
name|felem_bytearray
name|in
parameter_list|,
name|unsigned
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|>=
literal|224
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|in
index|[
name|i
operator|>>
literal|3
index|]
operator|>>
operator|(
name|i
operator|&
literal|7
operator|)
operator|)
operator|&
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Interleaved point multiplication using precomputed point multiples: The  * small point multiples 0*P, 1*P, ..., 16*P are in pre_comp[], the scalars  * in scalars[]. If g_scalar is non-NULL, we also add this multiple of the  * generator, using certain (large) precomputed multiples in g_pre_comp.  * Output point (X, Y, Z) is stored in x_out, y_out, z_out  */
end_comment

begin_function
specifier|static
name|void
name|batch_mul
parameter_list|(
name|felem
name|x_out
parameter_list|,
name|felem
name|y_out
parameter_list|,
name|felem
name|z_out
parameter_list|,
specifier|const
name|felem_bytearray
name|scalars
index|[]
parameter_list|,
specifier|const
name|unsigned
name|num_points
parameter_list|,
specifier|const
name|u8
modifier|*
name|g_scalar
parameter_list|,
specifier|const
name|int
name|mixed
parameter_list|,
specifier|const
name|felem
name|pre_comp
index|[]
index|[
literal|17
index|]
index|[
literal|3
index|]
parameter_list|,
specifier|const
name|felem
name|g_pre_comp
index|[
literal|2
index|]
index|[
literal|16
index|]
index|[
literal|3
index|]
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|skip
decl_stmt|;
name|unsigned
name|num
decl_stmt|;
name|unsigned
name|gen_mul
init|=
operator|(
name|g_scalar
operator|!=
name|NULL
operator|)
decl_stmt|;
name|felem
name|nq
index|[
literal|3
index|]
decl_stmt|,
name|tmp
index|[
literal|4
index|]
decl_stmt|;
name|u64
name|bits
decl_stmt|;
name|u8
name|sign
decl_stmt|,
name|digit
decl_stmt|;
comment|/* set nq to the point at infinity */
name|memset
argument_list|(
name|nq
argument_list|,
literal|0
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|felem
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Loop over all scalars msb-to-lsb, interleaving additions of multiples      * of the generator (two in each of the last 28 rounds) and additions of      * other points multiples (every 5th round).      */
name|skip
operator|=
literal|1
expr_stmt|;
comment|/* save two point operations in the first                                  * round */
for|for
control|(
name|i
operator|=
operator|(
name|num_points
condition|?
literal|220
else|:
literal|27
operator|)
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
comment|/* double */
if|if
condition|(
operator|!
name|skip
condition|)
name|point_double
argument_list|(
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|,
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* add multiples of the generator */
if|if
condition|(
name|gen_mul
operator|&&
operator|(
name|i
operator|<=
literal|27
operator|)
condition|)
block|{
comment|/* first, look 28 bits upwards */
name|bits
operator|=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
operator|+
literal|196
argument_list|)
operator|<<
literal|3
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
operator|+
literal|140
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
operator|+
literal|84
argument_list|)
operator|<<
literal|1
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
operator|+
literal|28
argument_list|)
expr_stmt|;
comment|/* select the point to add, in constant time */
name|select_point
argument_list|(
name|bits
argument_list|,
literal|16
argument_list|,
name|g_pre_comp
index|[
literal|1
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
block|{
comment|/* value 1 below is argument for "mixed" */
name|point_add
argument_list|(
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|,
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|,
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|tmp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|nq
argument_list|,
name|tmp
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|felem
argument_list|)
argument_list|)
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
block|}
comment|/* second, look at the current position */
name|bits
operator|=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
operator|+
literal|168
argument_list|)
operator|<<
literal|3
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
operator|+
literal|112
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
operator|+
literal|56
argument_list|)
operator|<<
literal|1
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|g_scalar
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* select the point to add, in constant time */
name|select_point
argument_list|(
name|bits
argument_list|,
literal|16
argument_list|,
name|g_pre_comp
index|[
literal|0
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|point_add
argument_list|(
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|,
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|,
literal|1
comment|/* mixed */
argument_list|,
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|tmp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* do other additions every 5 doublings */
if|if
condition|(
name|num_points
operator|&&
operator|(
name|i
operator|%
literal|5
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* loop over all scalars */
for|for
control|(
name|num
operator|=
literal|0
init|;
name|num
operator|<
name|num_points
condition|;
operator|++
name|num
control|)
block|{
name|bits
operator|=
name|get_bit
argument_list|(
name|scalars
index|[
name|num
index|]
argument_list|,
name|i
operator|+
literal|4
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|scalars
index|[
name|num
index|]
argument_list|,
name|i
operator|+
literal|3
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|scalars
index|[
name|num
index|]
argument_list|,
name|i
operator|+
literal|2
argument_list|)
operator|<<
literal|3
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|scalars
index|[
name|num
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|scalars
index|[
name|num
index|]
argument_list|,
name|i
argument_list|)
operator|<<
literal|1
expr_stmt|;
name|bits
operator||=
name|get_bit
argument_list|(
name|scalars
index|[
name|num
index|]
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ec_GFp_nistp_recode_scalar_bits
argument_list|(
operator|&
name|sign
argument_list|,
operator|&
name|digit
argument_list|,
name|bits
argument_list|)
expr_stmt|;
comment|/* select the point to add or subtract */
name|select_point
argument_list|(
name|digit
argument_list|,
literal|17
argument_list|,
name|pre_comp
index|[
name|num
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|felem_neg
argument_list|(
name|tmp
index|[
literal|3
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* (X, -Y, Z) is the negative                                             * point */
name|copy_conditional
argument_list|(
name|tmp
index|[
literal|1
index|]
argument_list|,
name|tmp
index|[
literal|3
index|]
argument_list|,
name|sign
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
block|{
name|point_add
argument_list|(
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|,
name|nq
index|[
literal|0
index|]
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|,
name|mixed
argument_list|,
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|tmp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|nq
argument_list|,
name|tmp
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|felem
argument_list|)
argument_list|)
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
name|felem_assign
argument_list|(
name|x_out
argument_list|,
name|nq
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|felem_assign
argument_list|(
name|y_out
argument_list|,
name|nq
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|felem_assign
argument_list|(
name|z_out
argument_list|,
name|nq
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * FUNCTIONS TO MANAGE PRECOMPUTATION  */
end_comment

begin_function
specifier|static
name|NISTP224_PRE_COMP
modifier|*
name|nistp224_pre_comp_new
parameter_list|()
block|{
name|NISTP224_PRE_COMP
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|ret
operator|=
operator|(
name|NISTP224_PRE_COMP
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_NISTP224_PRE_COMP_NEW
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|memset
argument_list|(
name|ret
operator|->
name|g_pre_comp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
operator|->
name|g_pre_comp
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|references
operator|=
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|nistp224_pre_comp_dup
parameter_list|(
name|void
modifier|*
name|src_
parameter_list|)
block|{
name|NISTP224_PRE_COMP
modifier|*
name|src
init|=
name|src_
decl_stmt|;
comment|/* no need to actually copy, these objects never change! */
name|CRYPTO_add
argument_list|(
operator|&
name|src
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_EC_PRE_COMP
argument_list|)
expr_stmt|;
return|return
name|src_
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nistp224_pre_comp_free
parameter_list|(
name|void
modifier|*
name|pre_
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|NISTP224_PRE_COMP
modifier|*
name|pre
init|=
name|pre_
decl_stmt|;
if|if
condition|(
operator|!
name|pre
condition|)
return|return;
name|i
operator|=
name|CRYPTO_add
argument_list|(
operator|&
name|pre
operator|->
name|references
argument_list|,
operator|-
literal|1
argument_list|,
name|CRYPTO_LOCK_EC_PRE_COMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return;
name|OPENSSL_free
argument_list|(
name|pre
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nistp224_pre_comp_clear_free
parameter_list|(
name|void
modifier|*
name|pre_
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|NISTP224_PRE_COMP
modifier|*
name|pre
init|=
name|pre_
decl_stmt|;
if|if
condition|(
operator|!
name|pre
condition|)
return|return;
name|i
operator|=
name|CRYPTO_add
argument_list|(
operator|&
name|pre
operator|->
name|references
argument_list|,
operator|-
literal|1
argument_list|,
name|CRYPTO_LOCK_EC_PRE_COMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return;
name|OPENSSL_cleanse
argument_list|(
name|pre
argument_list|,
sizeof|sizeof
expr|*
name|pre
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|pre
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * OPENSSL EC_METHOD FUNCTIONS  */
end_comment

begin_function
name|int
name|ec_GFp_nistp224_group_init
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|ec_GFp_simple_group_init
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|group
operator|->
name|a_is_minus3
operator|=
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_nistp224_group_set_curve
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|curve_p
decl_stmt|,
modifier|*
name|curve_a
decl_stmt|,
modifier|*
name|curve_b
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|curve_p
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|curve_a
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|curve_b
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|err
goto|;
name|BN_bin2bn
argument_list|(
name|nistp224_curve_params
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|felem_bytearray
argument_list|)
argument_list|,
name|curve_p
argument_list|)
expr_stmt|;
name|BN_bin2bn
argument_list|(
name|nistp224_curve_params
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|felem_bytearray
argument_list|)
argument_list|,
name|curve_a
argument_list|)
expr_stmt|;
name|BN_bin2bn
argument_list|(
name|nistp224_curve_params
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|felem_bytearray
argument_list|)
argument_list|,
name|curve_b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BN_cmp
argument_list|(
name|curve_p
argument_list|,
name|p
argument_list|)
operator|)
operator|||
operator|(
name|BN_cmp
argument_list|(
name|curve_a
argument_list|,
name|a
argument_list|)
operator|)
operator|||
operator|(
name|BN_cmp
argument_list|(
name|curve_b
argument_list|,
name|b
argument_list|)
operator|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP224_GROUP_SET_CURVE
argument_list|,
name|EC_R_WRONG_CURVE_PARAMETERS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|group
operator|->
name|field_mod_func
operator|=
name|BN_nist_mod_224
expr_stmt|;
name|ret
operator|=
name|ec_GFp_simple_group_set_curve
argument_list|(
name|group
argument_list|,
name|p
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Takes the Jacobian coordinates (X, Y, Z) of a point and returns (X', Y') =  * (X/Z^2, Y/Z^3)  */
end_comment

begin_function
name|int
name|ec_GFp_nistp224_point_get_affine_coordinates
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|point
parameter_list|,
name|BIGNUM
modifier|*
name|x
parameter_list|,
name|BIGNUM
modifier|*
name|y
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|felem
name|z1
decl_stmt|,
name|z2
decl_stmt|,
name|x_in
decl_stmt|,
name|y_in
decl_stmt|,
name|x_out
decl_stmt|,
name|y_out
decl_stmt|;
name|widefelem
name|tmp
decl_stmt|;
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|point
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES
argument_list|,
name|EC_R_POINT_AT_INFINITY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|x_in
argument_list|,
operator|&
name|point
operator|->
name|X
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|y_in
argument_list|,
operator|&
name|point
operator|->
name|Y
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|z1
argument_list|,
operator|&
name|point
operator|->
name|Z
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|felem_inv
argument_list|(
name|z2
argument_list|,
name|z1
argument_list|)
expr_stmt|;
name|felem_square
argument_list|(
name|tmp
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|z1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|x_in
argument_list|,
name|z1
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|x_in
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|felem_contract
argument_list|(
name|x_out
argument_list|,
name|x_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|felem_to_BN
argument_list|(
name|x
argument_list|,
name|x_out
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|z1
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|z1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|felem_mul
argument_list|(
name|tmp
argument_list|,
name|y_in
argument_list|,
name|z1
argument_list|)
expr_stmt|;
name|felem_reduce
argument_list|(
name|y_in
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|felem_contract
argument_list|(
name|y_out
argument_list|,
name|y_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|felem_to_BN
argument_list|(
name|y
argument_list|,
name|y_out
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_points_affine
parameter_list|(
name|size_t
name|num
parameter_list|,
name|felem
name|points
index|[
comment|/* num */
index|]
index|[
literal|3
index|]
parameter_list|,
name|felem
name|tmp_felems
index|[
comment|/* num+1 */
index|]
parameter_list|)
block|{
comment|/*      * Runs in constant time, unless an input is the point at infinity (which      * normally shouldn't happen).      */
name|ec_GFp_nistp_points_make_affine_internal
argument_list|(
name|num
argument_list|,
name|points
argument_list|,
sizeof|sizeof
argument_list|(
name|felem
argument_list|)
argument_list|,
name|tmp_felems
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|felem_one
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|felem_is_zero_int
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|felem_assign
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|felem_square_reduce
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|felem_mul_reduce
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|felem_inv
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|felem_contract
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Computes scalar*generator + \sum scalars[i]*points[i], ignoring NULL  * values Result is stored in r (r can equal one of the inputs).  */
end_comment

begin_function
name|int
name|ec_GFp_nistp224_points_mul
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|EC_POINT
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|scalar
parameter_list|,
name|size_t
name|num
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|points
index|[]
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|scalars
index|[]
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|mixed
init|=
literal|0
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|,
modifier|*
name|tmp_scalar
decl_stmt|;
name|felem_bytearray
name|g_secret
decl_stmt|;
name|felem_bytearray
modifier|*
name|secrets
init|=
name|NULL
decl_stmt|;
name|felem
argument_list|(
operator|*
name|pre_comp
argument_list|)
index|[
literal|17
index|]
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|felem
modifier|*
name|tmp_felems
init|=
name|NULL
decl_stmt|;
name|felem_bytearray
name|tmp
decl_stmt|;
name|unsigned
name|num_bytes
decl_stmt|;
name|int
name|have_pre_comp
init|=
literal|0
decl_stmt|;
name|size_t
name|num_points
init|=
name|num
decl_stmt|;
name|felem
name|x_in
decl_stmt|,
name|y_in
decl_stmt|,
name|z_in
decl_stmt|,
name|x_out
decl_stmt|,
name|y_out
decl_stmt|,
name|z_out
decl_stmt|;
name|NISTP224_PRE_COMP
modifier|*
name|pre
init|=
name|NULL
decl_stmt|;
specifier|const
name|felem
argument_list|(
operator|*
name|g_pre_comp
argument_list|)
index|[
literal|16
index|]
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|EC_POINT
modifier|*
name|generator
init|=
name|NULL
decl_stmt|;
specifier|const
name|EC_POINT
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
specifier|const
name|BIGNUM
modifier|*
name|p_scalar
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|x
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|y
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|z
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|tmp_scalar
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|scalar
operator|!=
name|NULL
condition|)
block|{
name|pre
operator|=
name|EC_EX_DATA_get_data
argument_list|(
name|group
operator|->
name|extra_data
argument_list|,
name|nistp224_pre_comp_dup
argument_list|,
name|nistp224_pre_comp_free
argument_list|,
name|nistp224_pre_comp_clear_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre
condition|)
comment|/* we have precomputation, try to use it */
name|g_pre_comp
operator|=
operator|(
specifier|const
name|felem
argument_list|(
operator|*
argument_list|)
index|[
literal|16
index|]
index|[
literal|3
index|]
operator|)
name|pre
operator|->
name|g_pre_comp
expr_stmt|;
else|else
comment|/* try to use the standard precomputation */
name|g_pre_comp
operator|=
operator|&
name|gmul
index|[
literal|0
index|]
expr_stmt|;
name|generator
operator|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|generator
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* get the generator from precomputation */
if|if
condition|(
operator|!
name|felem_to_BN
argument_list|(
name|x
argument_list|,
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|felem_to_BN
argument_list|(
name|y
argument_list|,
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|felem_to_BN
argument_list|(
name|z
argument_list|,
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP224_POINTS_MUL
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|EC_POINT_set_Jprojective_coordinates_GFp
argument_list|(
name|group
argument_list|,
name|generator
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
literal|0
operator|==
name|EC_POINT_cmp
argument_list|(
name|group
argument_list|,
name|generator
argument_list|,
name|group
operator|->
name|generator
argument_list|,
name|ctx
argument_list|)
condition|)
comment|/* precomputation matches generator */
name|have_pre_comp
operator|=
literal|1
expr_stmt|;
else|else
comment|/*              * we don't have valid precomputation: treat the generator as a              * random point              */
name|num_points
operator|=
name|num_points
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|num_points
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|num_points
operator|>=
literal|3
condition|)
block|{
comment|/*              * unless we precompute multiples for just one or two points,              * converting those into affine form is time well spent              */
name|mixed
operator|=
literal|1
expr_stmt|;
block|}
name|secrets
operator|=
name|OPENSSL_malloc
argument_list|(
name|num_points
operator|*
sizeof|sizeof
argument_list|(
name|felem_bytearray
argument_list|)
argument_list|)
expr_stmt|;
name|pre_comp
operator|=
name|OPENSSL_malloc
argument_list|(
name|num_points
operator|*
literal|17
operator|*
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|felem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mixed
condition|)
name|tmp_felems
operator|=
name|OPENSSL_malloc
argument_list|(
operator|(
name|num_points
operator|*
literal|17
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|felem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|secrets
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pre_comp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mixed
operator|&&
operator|(
name|tmp_felems
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP224_POINTS_MUL
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/*          * we treat NULL scalars as 0, and NULL points as points at infinity,          * i.e., they contribute nothing to the linear combination          */
name|memset
argument_list|(
name|secrets
argument_list|,
literal|0
argument_list|,
name|num_points
operator|*
sizeof|sizeof
argument_list|(
name|felem_bytearray
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pre_comp
argument_list|,
literal|0
argument_list|,
name|num_points
operator|*
literal|17
operator|*
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|felem
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_points
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
name|num
condition|)
comment|/* the generator */
block|{
name|p
operator|=
name|EC_GROUP_get0_generator
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|p_scalar
operator|=
name|scalar
expr_stmt|;
block|}
else|else
comment|/* the i^th point */
block|{
name|p
operator|=
name|points
index|[
name|i
index|]
expr_stmt|;
name|p_scalar
operator|=
name|scalars
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_scalar
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|p
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* reduce scalar to 0<= scalar< 2^224 */
if|if
condition|(
operator|(
name|BN_num_bits
argument_list|(
name|p_scalar
argument_list|)
operator|>
literal|224
operator|)
operator|||
operator|(
name|BN_is_negative
argument_list|(
name|p_scalar
argument_list|)
operator|)
condition|)
block|{
comment|/*                      * this is an unusual input, and we don't guarantee                      * constant-timeness                      */
if|if
condition|(
operator|!
name|BN_nnmod
argument_list|(
name|tmp_scalar
argument_list|,
name|p_scalar
argument_list|,
operator|&
name|group
operator|->
name|order
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP224_POINTS_MUL
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|num_bytes
operator|=
name|BN_bn2bin
argument_list|(
name|tmp_scalar
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|num_bytes
operator|=
name|BN_bn2bin
argument_list|(
name|p_scalar
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|flip_endian
argument_list|(
name|secrets
index|[
name|i
index|]
argument_list|,
name|tmp
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
comment|/* precompute multiples */
if|if
condition|(
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|x_out
argument_list|,
operator|&
name|p
operator|->
name|X
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|y_out
argument_list|,
operator|&
name|p
operator|->
name|Y
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|z_out
argument_list|,
operator|&
name|p
operator|->
name|Z
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
name|felem_assign
argument_list|(
name|pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|x_out
argument_list|)
expr_stmt|;
name|felem_assign
argument_list|(
name|pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|y_out
argument_list|)
expr_stmt|;
name|felem_assign
argument_list|(
name|pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
name|z_out
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<=
literal|16
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|j
operator|&
literal|1
condition|)
block|{
name|point_add
argument_list|(
name|pre_comp
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|0
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|2
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|point_double
argument_list|(
name|pre_comp
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|0
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|1
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|2
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
operator|/
literal|2
index|]
index|[
literal|0
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
operator|/
literal|2
index|]
index|[
literal|1
index|]
argument_list|,
name|pre_comp
index|[
name|i
index|]
index|[
name|j
operator|/
literal|2
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|mixed
condition|)
name|make_points_affine
argument_list|(
name|num_points
operator|*
literal|17
argument_list|,
name|pre_comp
index|[
literal|0
index|]
argument_list|,
name|tmp_felems
argument_list|)
expr_stmt|;
block|}
comment|/* the scalar for the generator */
if|if
condition|(
operator|(
name|scalar
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|have_pre_comp
operator|)
condition|)
block|{
name|memset
argument_list|(
name|g_secret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|g_secret
argument_list|)
expr_stmt|;
comment|/* reduce scalar to 0<= scalar< 2^224 */
if|if
condition|(
operator|(
name|BN_num_bits
argument_list|(
name|scalar
argument_list|)
operator|>
literal|224
operator|)
operator|||
operator|(
name|BN_is_negative
argument_list|(
name|scalar
argument_list|)
operator|)
condition|)
block|{
comment|/*              * this is an unusual input, and we don't guarantee              * constant-timeness              */
if|if
condition|(
operator|!
name|BN_nnmod
argument_list|(
name|tmp_scalar
argument_list|,
name|scalar
argument_list|,
operator|&
name|group
operator|->
name|order
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP224_POINTS_MUL
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|num_bytes
operator|=
name|BN_bn2bin
argument_list|(
name|tmp_scalar
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|num_bytes
operator|=
name|BN_bn2bin
argument_list|(
name|scalar
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|flip_endian
argument_list|(
name|g_secret
argument_list|,
name|tmp
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
comment|/* do the multiplication with generator precomputation */
name|batch_mul
argument_list|(
name|x_out
argument_list|,
name|y_out
argument_list|,
name|z_out
argument_list|,
operator|(
specifier|const
name|felem_bytearray
argument_list|(
operator|*
argument_list|)
operator|)
name|secrets
argument_list|,
name|num_points
argument_list|,
name|g_secret
argument_list|,
name|mixed
argument_list|,
operator|(
specifier|const
name|felem
argument_list|(
operator|*
argument_list|)
index|[
literal|17
index|]
index|[
literal|3
index|]
operator|)
name|pre_comp
argument_list|,
name|g_pre_comp
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* do the multiplication without generator precomputation */
name|batch_mul
argument_list|(
name|x_out
argument_list|,
name|y_out
argument_list|,
name|z_out
argument_list|,
operator|(
specifier|const
name|felem_bytearray
argument_list|(
operator|*
argument_list|)
operator|)
name|secrets
argument_list|,
name|num_points
argument_list|,
name|NULL
argument_list|,
name|mixed
argument_list|,
operator|(
specifier|const
name|felem
argument_list|(
operator|*
argument_list|)
index|[
literal|17
index|]
index|[
literal|3
index|]
operator|)
name|pre_comp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* reduce the output to its unique minimal representation */
name|felem_contract
argument_list|(
name|x_in
argument_list|,
name|x_out
argument_list|)
expr_stmt|;
name|felem_contract
argument_list|(
name|y_in
argument_list|,
name|y_out
argument_list|)
expr_stmt|;
name|felem_contract
argument_list|(
name|z_in
argument_list|,
name|z_out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|felem_to_BN
argument_list|(
name|x
argument_list|,
name|x_in
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|felem_to_BN
argument_list|(
name|y
argument_list|,
name|y_in
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|felem_to_BN
argument_list|(
name|z
argument_list|,
name|z_in
argument_list|)
operator|)
condition|)
block|{
name|ECerr
argument_list|(
name|EC_F_EC_GFP_NISTP224_POINTS_MUL
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
name|EC_POINT_set_Jprojective_coordinates_GFp
argument_list|(
name|group
argument_list|,
name|r
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|generator
operator|!=
name|NULL
condition|)
name|EC_POINT_free
argument_list|(
name|generator
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|secrets
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|secrets
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_comp
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|pre_comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_felems
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|tmp_felems
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_nistp224_precompute_mult
parameter_list|(
name|EC_GROUP
modifier|*
name|group
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|NISTP224_PRE_COMP
modifier|*
name|pre
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|BN_CTX
modifier|*
name|new_ctx
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|EC_POINT
modifier|*
name|generator
init|=
name|NULL
decl_stmt|;
name|felem
name|tmp_felems
index|[
literal|32
index|]
decl_stmt|;
comment|/* throw away old precomputation */
name|EC_EX_DATA_free_data
argument_list|(
operator|&
name|group
operator|->
name|extra_data
argument_list|,
name|nistp224_pre_comp_dup
argument_list|,
name|nistp224_pre_comp_free
argument_list|,
name|nistp224_pre_comp_clear_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|ctx
operator|=
name|new_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|x
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|y
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|err
goto|;
comment|/* get the generator */
if|if
condition|(
name|group
operator|->
name|generator
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|generator
operator|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|generator
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|BN_bin2bn
argument_list|(
name|nistp224_curve_params
index|[
literal|3
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|felem_bytearray
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|BN_bin2bn
argument_list|(
name|nistp224_curve_params
index|[
literal|4
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|felem_bytearray
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EC_POINT_set_affine_coordinates_GFp
argument_list|(
name|group
argument_list|,
name|generator
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|(
name|pre
operator|=
name|nistp224_pre_comp_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/*      * if the generator is the standard one, use built-in precomputation      */
if|if
condition|(
literal|0
operator|==
name|EC_POINT_cmp
argument_list|(
name|group
argument_list|,
name|generator
argument_list|,
name|group
operator|->
name|generator
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|pre
operator|->
name|g_pre_comp
argument_list|,
name|gmul
argument_list|,
sizeof|sizeof
argument_list|(
name|pre
operator|->
name|g_pre_comp
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
operator|&
name|group
operator|->
name|generator
operator|->
name|X
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
operator|&
name|group
operator|->
name|generator
operator|->
name|Y
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|BN_to_felem
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
operator|&
name|group
operator|->
name|generator
operator|->
name|Z
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
comment|/*      * compute 2^56*G, 2^112*G, 2^168*G for the first table, 2^28*G, 2^84*G,      * 2^140*G, 2^196*G for the second one      */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|8
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
name|point_double
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|27
condition|;
operator|++
name|j
control|)
block|{
name|point_double
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|8
condition|)
break|break;
name|point_double
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|1
index|]
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|27
condition|;
operator|++
name|j
control|)
block|{
name|point_double
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|2
operator|*
name|i
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|/* g_pre_comp[i][0] is the point at infinity */
name|memset
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the remaining multiples */
comment|/* 2^56*G + 2^112*G resp. 2^84*G + 2^140*G */
name|point_add
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|6
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|6
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|6
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|4
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|4
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|4
index|]
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 2^56*G + 2^168*G resp. 2^84*G + 2^196*G */
name|point_add
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|10
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|10
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|10
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|8
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|8
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|8
index|]
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 2^112*G + 2^168*G resp. 2^140*G + 2^196*G */
name|point_add
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|12
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|12
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|12
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|8
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|8
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|8
index|]
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|4
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|4
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|4
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/*          * 2^56*G + 2^112*G + 2^168*G resp. 2^84*G + 2^140*G + 2^196*G          */
name|point_add
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|14
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|14
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|14
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|12
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|12
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|12
index|]
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|8
condition|;
operator|++
name|j
control|)
block|{
comment|/* odd multiples: add G resp. 2^28*G */
name|point_add
argument_list|(
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
operator|*
name|j
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
operator|*
name|j
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|2
operator|*
name|j
index|]
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|pre
operator|->
name|g_pre_comp
index|[
name|i
index|]
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|make_points_affine
argument_list|(
literal|31
argument_list|,
operator|&
operator|(
name|pre
operator|->
name|g_pre_comp
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|)
argument_list|,
name|tmp_felems
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|!
name|EC_EX_DATA_set_data
argument_list|(
operator|&
name|group
operator|->
name|extra_data
argument_list|,
name|pre
argument_list|,
name|nistp224_pre_comp_dup
argument_list|,
name|nistp224_pre_comp_free
argument_list|,
name|nistp224_pre_comp_clear_free
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
literal|1
expr_stmt|;
name|pre
operator|=
name|NULL
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|generator
operator|!=
name|NULL
condition|)
name|EC_POINT_free
argument_list|(
name|generator
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ctx
operator|!=
name|NULL
condition|)
name|BN_CTX_free
argument_list|(
name|new_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre
condition|)
name|nistp224_pre_comp_free
argument_list|(
name|pre
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ec_GFp_nistp224_have_precompute_mult
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|)
block|{
if|if
condition|(
name|EC_EX_DATA_get_data
argument_list|(
name|group
operator|->
name|extra_data
argument_list|,
name|nistp224_pre_comp_dup
argument_list|,
name|nistp224_pre_comp_free
argument_list|,
name|nistp224_pre_comp_clear_free
argument_list|)
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|void
modifier|*
name|dummy
init|=
operator|&
name|dummy
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

