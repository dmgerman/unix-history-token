begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/ex_data.c */
end_comment

begin_comment
comment|/*  * Overhaul notes;  *  * This code is now *mostly* thread-safe. It is now easier to understand in what  * ways it is safe and in what ways it is not, which is an improvement. Firstly,  * all per-class stacks and index-counters for ex_data are stored in the same  * global LHASH table (keyed by class). This hash table uses locking for all  * access with the exception of CRYPTO_cleanup_all_ex_data(), which must only be  * called when no other threads can possibly race against it (even if it was  * locked, the race would mean it's possible the hash table might have been  * recreated after the cleanup). As classes can only be added to the hash table,  * and within each class, the stack of methods can only be incremented, the  * locking mechanics are simpler than they would otherwise be. For example, the  * new/dup/free ex_data functions will lock the hash table, copy the method  * pointers it needs from the relevant class, then unlock the hash table before  * actually applying those method pointers to the task of the new/dup/free  * operations. As they can't be removed from the method-stack, only  * supplemented, there's no race conditions associated with using them outside  * the lock. The get/set_ex_data functions are not locked because they do not  * involve this global state at all - they operate directly with a previously  * obtained per-class method index and a particular "ex_data" variable. These  * variables are usually instantiated per-context (eg. each RSA structure has  * one) so locking on read/write access to that variable can be locked locally  * if required (eg. using the "RSA" lock to synchronise access to a  * per-RSA-structure ex_data variable if required).  * [Geoff]  */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *  * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *  * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from  *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/lhash.h>
end_include

begin_comment
comment|/* What an "implementation of ex_data functionality" looks like */
end_comment

begin_struct
struct|struct
name|st_CRYPTO_EX_DATA_IMPL
block|{
comment|/*********************/
comment|/* GLOBAL OPERATIONS */
comment|/* Return a new class index */
name|int
function_decl|(
modifier|*
name|cb_new_class
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Cleanup all state used by the implementation */
name|void
function_decl|(
modifier|*
name|cb_cleanup
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/************************/
comment|/* PER-CLASS OPERATIONS */
comment|/* Get a new method index within a class */
name|int
function_decl|(
modifier|*
name|cb_get_new_index
function_decl|)
parameter_list|(
name|int
name|class_index
parameter_list|,
name|long
name|argl
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|,
name|CRYPTO_EX_new
modifier|*
name|new_func
parameter_list|,
name|CRYPTO_EX_dup
modifier|*
name|dup_func
parameter_list|,
name|CRYPTO_EX_free
modifier|*
name|free_func
parameter_list|)
function_decl|;
comment|/* Initialise a new CRYPTO_EX_DATA of a given class */
name|int
function_decl|(
modifier|*
name|cb_new_ex_data
function_decl|)
parameter_list|(
name|int
name|class_index
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|)
function_decl|;
comment|/* Duplicate a CRYPTO_EX_DATA of a given class onto a copy */
name|int
function_decl|(
modifier|*
name|cb_dup_ex_data
function_decl|)
parameter_list|(
name|int
name|class_index
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|to
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|from
parameter_list|)
function_decl|;
comment|/* Cleanup a CRYPTO_EX_DATA of a given class */
name|void
function_decl|(
modifier|*
name|cb_free_ex_data
function_decl|)
parameter_list|(
name|int
name|class_index
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* The implementation we use at run-time */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|CRYPTO_EX_DATA_IMPL
modifier|*
name|impl
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * To call "impl" functions, use this macro rather than referring to 'impl'  * directly, eg. EX_IMPL(get_new_index)(...);  */
end_comment

begin_define
define|#
directive|define
name|EX_IMPL
parameter_list|(
name|a
parameter_list|)
value|impl->cb_##a
end_define

begin_comment
comment|/* Predeclare the "default" ex_data implementation */
end_comment

begin_function_decl
specifier|static
name|int
name|int_new_class
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|int_cleanup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|int_get_new_index
parameter_list|(
name|int
name|class_index
parameter_list|,
name|long
name|argl
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|,
name|CRYPTO_EX_new
modifier|*
name|new_func
parameter_list|,
name|CRYPTO_EX_dup
modifier|*
name|dup_func
parameter_list|,
name|CRYPTO_EX_free
modifier|*
name|free_func
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|int_new_ex_data
parameter_list|(
name|int
name|class_index
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|int_dup_ex_data
parameter_list|(
name|int
name|class_index
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|to
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|from
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|int_free_ex_data
parameter_list|(
name|int
name|class_index
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|CRYPTO_EX_DATA_IMPL
name|impl_default
init|=
block|{
name|int_new_class
block|,
name|int_cleanup
block|,
name|int_get_new_index
block|,
name|int_new_ex_data
block|,
name|int_dup_ex_data
block|,
name|int_free_ex_data
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internal function that checks whether "impl" is set and if not, sets it to  * the default.  */
end_comment

begin_function
specifier|static
name|void
name|impl_check
parameter_list|(
name|void
parameter_list|)
block|{
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|impl
condition|)
name|impl
operator|=
operator|&
name|impl_default
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A macro wrapper for impl_check that first uses a non-locked test before  * invoking the function (which checks again inside a lock).  */
end_comment

begin_define
define|#
directive|define
name|IMPL_CHECK
value|if(!impl) impl_check();
end_define

begin_comment
comment|/* API functions to get/set the "ex_data" implementation */
end_comment

begin_function
specifier|const
name|CRYPTO_EX_DATA_IMPL
modifier|*
name|CRYPTO_get_ex_data_implementation
parameter_list|(
name|void
parameter_list|)
block|{
name|IMPL_CHECK
return|return
name|impl
return|;
block|}
end_function

begin_function
name|int
name|CRYPTO_set_ex_data_implementation
parameter_list|(
specifier|const
name|CRYPTO_EX_DATA_IMPL
modifier|*
name|i
parameter_list|)
block|{
name|int
name|toret
init|=
literal|0
decl_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|impl
condition|)
block|{
name|impl
operator|=
name|i
expr_stmt|;
name|toret
operator|=
literal|1
expr_stmt|;
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
return|return
name|toret
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*  * Interal (default) implementation of "ex_data" support. API functions are  * further down.  */
end_comment

begin_comment
comment|/*  * The type that represents what each "class" used to implement locally. A  * STACK of CRYPTO_EX_DATA_FUNCS plus a index-counter. The 'class_index' is  * the global value representing the class that is used to distinguish these  * items.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|st_ex_class_item
block|{
name|int
name|class_index
decl_stmt|;
name|STACK_OF
argument_list|(
name|CRYPTO_EX_DATA_FUNCS
argument_list|)
operator|*
name|meth
expr_stmt|;
name|int
name|meth_num
decl_stmt|;
block|}
name|EX_CLASS_ITEM
typedef|;
end_typedef

begin_comment
comment|/* When assigning new class indexes, this is our counter */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ex_class
init|=
name|CRYPTO_EX_INDEX_USER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The global hash table of EX_CLASS_ITEM items */
end_comment

begin_expr_stmt
name|DECLARE_LHASH_OF
argument_list|(
name|EX_CLASS_ITEM
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|LHASH_OF
argument_list|(
name|EX_CLASS_ITEM
argument_list|)
operator|*
name|ex_data
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The callbacks required in the "ex_data" hash table */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|ex_class_item_hash
parameter_list|(
specifier|const
name|EX_CLASS_ITEM
modifier|*
name|a
parameter_list|)
block|{
return|return
name|a
operator|->
name|class_index
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|IMPLEMENT_LHASH_HASH_FN
argument_list|(
argument|ex_class_item
argument_list|,
argument|EX_CLASS_ITEM
argument_list|)
specifier|static
name|int
name|ex_class_item_cmp
argument_list|(
argument|const EX_CLASS_ITEM *a
argument_list|,
argument|const EX_CLASS_ITEM *b
argument_list|)
block|{
return|return
name|a
operator|->
name|class_index
operator|-
name|b
operator|->
name|class_index
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|static
name|IMPLEMENT_LHASH_COMP_FN
argument_list|(
argument|ex_class_item
argument_list|,
argument|EX_CLASS_ITEM
argument_list|)
comment|/*  * Internal functions used by the "impl_default" implementation to access the  * state  */
specifier|static
name|int
name|ex_data_check
argument_list|(
argument|void
argument_list|)
block|{
name|int
name|toret
operator|=
literal|1
block|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
block|;
if|if
condition|(
operator|!
name|ex_data
operator|&&
operator|(
name|ex_data
operator|=
name|lh_EX_CLASS_ITEM_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|toret
operator|=
literal|0
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|toret
return|;
end_return

begin_comment
unit|}
comment|/*  * This macros helps reduce the locking from repeated checks because the  * ex_data_check() function checks ex_data again inside a lock.  */
end_comment

begin_define
define|#
directive|define
name|EX_DATA_CHECK
parameter_list|(
name|iffail
parameter_list|)
value|if(!ex_data&& !ex_data_check()) {iffail}
end_define

begin_comment
comment|/* This "inner" callback is used by the callback function that follows it */
end_comment

begin_function
unit|static
name|void
name|def_cleanup_util_cb
parameter_list|(
name|CRYPTO_EX_DATA_FUNCS
modifier|*
name|funcs
parameter_list|)
block|{
name|OPENSSL_free
argument_list|(
name|funcs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This callback is used in lh_doall to destroy all EX_CLASS_ITEM values from  * "ex_data" prior to the ex_data hash table being itself destroyed. Doesn't  * do any locking.  */
end_comment

begin_function
specifier|static
name|void
name|def_cleanup_cb
parameter_list|(
name|void
modifier|*
name|a_void
parameter_list|)
block|{
name|EX_CLASS_ITEM
modifier|*
name|item
init|=
operator|(
name|EX_CLASS_ITEM
operator|*
operator|)
name|a_void
decl_stmt|;
name|sk_CRYPTO_EX_DATA_FUNCS_pop_free
argument_list|(
name|item
operator|->
name|meth
argument_list|,
name|def_cleanup_util_cb
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the EX_CLASS_ITEM from the "ex_data" hash table that corresponds to  * a given class. Handles locking.  */
end_comment

begin_function
specifier|static
name|EX_CLASS_ITEM
modifier|*
name|def_get_class
parameter_list|(
name|int
name|class_index
parameter_list|)
block|{
name|EX_CLASS_ITEM
name|d
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|gen
decl_stmt|;
name|EX_DATA_CHECK
argument_list|(
argument|return NULL;
argument_list|)
name|d
operator|.
name|class_index
operator|=
name|class_index
expr_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
name|p
operator|=
name|lh_EX_CLASS_ITEM_retrieve
argument_list|(
name|ex_data
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|gen
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EX_CLASS_ITEM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
condition|)
block|{
name|gen
operator|->
name|class_index
operator|=
name|class_index
expr_stmt|;
name|gen
operator|->
name|meth_num
operator|=
literal|0
expr_stmt|;
name|gen
operator|->
name|meth
operator|=
name|sk_CRYPTO_EX_DATA_FUNCS_new_null
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gen
operator|->
name|meth
condition|)
name|OPENSSL_free
argument_list|(
name|gen
argument_list|)
expr_stmt|;
else|else
block|{
comment|/*                  * Because we're inside the ex_data lock, the return value                  * from the insert will be NULL                  */
operator|(
name|void
operator|)
name|lh_EX_CLASS_ITEM_insert
argument_list|(
name|ex_data
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|p
operator|=
name|lh_EX_CLASS_ITEM_retrieve
argument_list|(
name|ex_data
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|gen
condition|)
block|{
name|sk_CRYPTO_EX_DATA_FUNCS_free
argument_list|(
name|gen
operator|->
name|meth
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|gen
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|CRYPTOerr
argument_list|(
name|CRYPTO_F_DEF_GET_CLASS
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Add a new method to the given EX_CLASS_ITEM and return the corresponding  * index (or -1 for error). Handles locking.  */
end_comment

begin_function
specifier|static
name|int
name|def_add_index
parameter_list|(
name|EX_CLASS_ITEM
modifier|*
name|item
parameter_list|,
name|long
name|argl
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|,
name|CRYPTO_EX_new
modifier|*
name|new_func
parameter_list|,
name|CRYPTO_EX_dup
modifier|*
name|dup_func
parameter_list|,
name|CRYPTO_EX_free
modifier|*
name|free_func
parameter_list|)
block|{
name|int
name|toret
init|=
operator|-
literal|1
decl_stmt|;
name|CRYPTO_EX_DATA_FUNCS
modifier|*
name|a
init|=
operator|(
name|CRYPTO_EX_DATA_FUNCS
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CRYPTO_EX_DATA_FUNCS
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
block|{
name|CRYPTOerr
argument_list|(
name|CRYPTO_F_DEF_ADD_INDEX
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|a
operator|->
name|argl
operator|=
name|argl
expr_stmt|;
name|a
operator|->
name|argp
operator|=
name|argp
expr_stmt|;
name|a
operator|->
name|new_func
operator|=
name|new_func
expr_stmt|;
name|a
operator|->
name|dup_func
operator|=
name|dup_func
expr_stmt|;
name|a
operator|->
name|free_func
operator|=
name|free_func
expr_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
while|while
condition|(
name|sk_CRYPTO_EX_DATA_FUNCS_num
argument_list|(
name|item
operator|->
name|meth
argument_list|)
operator|<=
name|item
operator|->
name|meth_num
condition|)
block|{
if|if
condition|(
operator|!
name|sk_CRYPTO_EX_DATA_FUNCS_push
argument_list|(
name|item
operator|->
name|meth
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|CRYPTOerr
argument_list|(
name|CRYPTO_F_DEF_ADD_INDEX
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|toret
operator|=
name|item
operator|->
name|meth_num
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sk_CRYPTO_EX_DATA_FUNCS_set
argument_list|(
name|item
operator|->
name|meth
argument_list|,
name|toret
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|err
label|:
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
return|return
name|toret
return|;
block|}
end_function

begin_comment
comment|/**************************************************************/
end_comment

begin_comment
comment|/* The functions in the default CRYPTO_EX_DATA_IMPL structure */
end_comment

begin_function
specifier|static
name|int
name|int_new_class
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|toret
decl_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
name|toret
operator|=
name|ex_class
operator|++
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
return|return
name|toret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|int_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|EX_DATA_CHECK
argument_list|(
argument|return;
argument_list|)
name|lh_EX_CLASS_ITEM_doall
argument_list|(
name|ex_data
argument_list|,
name|def_cleanup_cb
argument_list|)
expr_stmt|;
name|lh_EX_CLASS_ITEM_free
argument_list|(
name|ex_data
argument_list|)
expr_stmt|;
name|ex_data
operator|=
name|NULL
expr_stmt|;
name|impl
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|int_get_new_index
parameter_list|(
name|int
name|class_index
parameter_list|,
name|long
name|argl
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|,
name|CRYPTO_EX_new
modifier|*
name|new_func
parameter_list|,
name|CRYPTO_EX_dup
modifier|*
name|dup_func
parameter_list|,
name|CRYPTO_EX_free
modifier|*
name|free_func
parameter_list|)
block|{
name|EX_CLASS_ITEM
modifier|*
name|item
init|=
name|def_get_class
argument_list|(
name|class_index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|def_add_index
argument_list|(
name|item
argument_list|,
name|argl
argument_list|,
name|argp
argument_list|,
name|new_func
argument_list|,
name|dup_func
argument_list|,
name|free_func
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Thread-safe by copying a class's array of "CRYPTO_EX_DATA_FUNCS" entries  * in the lock, then using them outside the lock. NB: Thread-safety only  * applies to the global "ex_data" state (ie. class definitions), not  * thread-safe on 'ad' itself.  */
end_comment

begin_function
specifier|static
name|int
name|int_new_ex_data
parameter_list|(
name|int
name|class_index
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|)
block|{
name|int
name|mx
decl_stmt|,
name|i
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|CRYPTO_EX_DATA_FUNCS
modifier|*
modifier|*
name|storage
init|=
name|NULL
decl_stmt|;
name|EX_CLASS_ITEM
modifier|*
name|item
init|=
name|def_get_class
argument_list|(
name|class_index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
comment|/* error is already set */
return|return
literal|0
return|;
name|ad
operator|->
name|sk
operator|=
name|NULL
expr_stmt|;
name|CRYPTO_r_lock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
name|mx
operator|=
name|sk_CRYPTO_EX_DATA_FUNCS_num
argument_list|(
name|item
operator|->
name|meth
argument_list|)
expr_stmt|;
if|if
condition|(
name|mx
operator|>
literal|0
condition|)
block|{
name|storage
operator|=
name|OPENSSL_malloc
argument_list|(
name|mx
operator|*
sizeof|sizeof
argument_list|(
name|CRYPTO_EX_DATA_FUNCS
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|storage
condition|)
goto|goto
name|skip
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mx
condition|;
name|i
operator|++
control|)
name|storage
index|[
name|i
index|]
operator|=
name|sk_CRYPTO_EX_DATA_FUNCS_value
argument_list|(
name|item
operator|->
name|meth
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|skip
label|:
name|CRYPTO_r_unlock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mx
operator|>
literal|0
operator|)
operator|&&
operator|!
name|storage
condition|)
block|{
name|CRYPTOerr
argument_list|(
name|CRYPTO_F_INT_NEW_EX_DATA
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mx
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|storage
index|[
name|i
index|]
operator|&&
name|storage
index|[
name|i
index|]
operator|->
name|new_func
condition|)
block|{
name|ptr
operator|=
name|CRYPTO_get_ex_data
argument_list|(
name|ad
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|storage
index|[
name|i
index|]
operator|->
name|new_func
argument_list|(
name|obj
argument_list|,
name|ptr
argument_list|,
name|ad
argument_list|,
name|i
argument_list|,
name|storage
index|[
name|i
index|]
operator|->
name|argl
argument_list|,
name|storage
index|[
name|i
index|]
operator|->
name|argp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|storage
condition|)
name|OPENSSL_free
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Same thread-safety notes as for "int_new_ex_data" */
end_comment

begin_function
specifier|static
name|int
name|int_dup_ex_data
parameter_list|(
name|int
name|class_index
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|to
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|from
parameter_list|)
block|{
name|int
name|mx
decl_stmt|,
name|j
decl_stmt|,
name|i
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|CRYPTO_EX_DATA_FUNCS
modifier|*
modifier|*
name|storage
init|=
name|NULL
decl_stmt|;
name|EX_CLASS_ITEM
modifier|*
name|item
decl_stmt|;
if|if
condition|(
operator|!
name|from
operator|->
name|sk
condition|)
comment|/* 'to' should be "blank" which *is* just like 'from' */
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|item
operator|=
name|def_get_class
argument_list|(
name|class_index
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|CRYPTO_r_lock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
name|mx
operator|=
name|sk_CRYPTO_EX_DATA_FUNCS_num
argument_list|(
name|item
operator|->
name|meth
argument_list|)
expr_stmt|;
name|j
operator|=
name|sk_void_num
argument_list|(
name|from
operator|->
name|sk
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|mx
condition|)
name|mx
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|mx
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|CRYPTO_set_ex_data
argument_list|(
name|to
argument_list|,
name|mx
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|skip
goto|;
name|storage
operator|=
name|OPENSSL_malloc
argument_list|(
name|mx
operator|*
sizeof|sizeof
argument_list|(
name|CRYPTO_EX_DATA_FUNCS
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|storage
condition|)
goto|goto
name|skip
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mx
condition|;
name|i
operator|++
control|)
name|storage
index|[
name|i
index|]
operator|=
name|sk_CRYPTO_EX_DATA_FUNCS_value
argument_list|(
name|item
operator|->
name|meth
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|skip
label|:
name|CRYPTO_r_unlock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mx
operator|>
literal|0
operator|)
operator|&&
operator|!
name|storage
condition|)
block|{
name|CRYPTOerr
argument_list|(
name|CRYPTO_F_INT_DUP_EX_DATA
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mx
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|=
name|CRYPTO_get_ex_data
argument_list|(
name|from
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
index|[
name|i
index|]
operator|&&
name|storage
index|[
name|i
index|]
operator|->
name|dup_func
condition|)
name|storage
index|[
name|i
index|]
operator|->
name|dup_func
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
operator|&
name|ptr
argument_list|,
name|i
argument_list|,
name|storage
index|[
name|i
index|]
operator|->
name|argl
argument_list|,
name|storage
index|[
name|i
index|]
operator|->
name|argp
argument_list|)
expr_stmt|;
name|CRYPTO_set_ex_data
argument_list|(
name|to
argument_list|,
name|i
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|storage
condition|)
name|OPENSSL_free
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Same thread-safety notes as for "int_new_ex_data" */
end_comment

begin_function
specifier|static
name|void
name|int_free_ex_data
parameter_list|(
name|int
name|class_index
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|)
block|{
name|int
name|mx
decl_stmt|,
name|i
decl_stmt|;
name|EX_CLASS_ITEM
modifier|*
name|item
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|CRYPTO_EX_DATA_FUNCS
modifier|*
name|f
decl_stmt|;
name|CRYPTO_EX_DATA_FUNCS
modifier|*
modifier|*
name|storage
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ex_data
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|(
name|item
operator|=
name|def_get_class
argument_list|(
name|class_index
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|CRYPTO_r_lock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
name|mx
operator|=
name|sk_CRYPTO_EX_DATA_FUNCS_num
argument_list|(
name|item
operator|->
name|meth
argument_list|)
expr_stmt|;
if|if
condition|(
name|mx
operator|>
literal|0
condition|)
block|{
name|storage
operator|=
name|OPENSSL_malloc
argument_list|(
name|mx
operator|*
sizeof|sizeof
argument_list|(
name|CRYPTO_EX_DATA_FUNCS
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|storage
condition|)
goto|goto
name|skip
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mx
condition|;
name|i
operator|++
control|)
name|storage
index|[
name|i
index|]
operator|=
name|sk_CRYPTO_EX_DATA_FUNCS_value
argument_list|(
name|item
operator|->
name|meth
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|skip
label|:
name|CRYPTO_r_unlock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mx
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|storage
operator|!=
name|NULL
condition|)
name|f
operator|=
name|storage
index|[
name|i
index|]
expr_stmt|;
else|else
block|{
name|CRYPTO_r_lock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
name|f
operator|=
name|sk_CRYPTO_EX_DATA_FUNCS_value
argument_list|(
name|item
operator|->
name|meth
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CRYPTO_r_unlock
argument_list|(
name|CRYPTO_LOCK_EX_DATA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|f
operator|->
name|free_func
operator|!=
name|NULL
condition|)
block|{
name|ptr
operator|=
name|CRYPTO_get_ex_data
argument_list|(
name|ad
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|f
operator|->
name|free_func
argument_list|(
name|obj
argument_list|,
name|ptr
argument_list|,
name|ad
argument_list|,
name|i
argument_list|,
name|f
operator|->
name|argl
argument_list|,
name|f
operator|->
name|argp
argument_list|)
expr_stmt|;
block|}
block|}
name|OPENSSL_free
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|err
label|:
name|sk_void_free
argument_list|(
name|ad
operator|->
name|sk
argument_list|)
expr_stmt|;
name|ad
operator|->
name|sk
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************/
end_comment

begin_comment
comment|/*  * API functions that defer all "state" operations to the "ex_data"  * implementation we have set.  */
end_comment

begin_comment
comment|/*  * Obtain an index for a new class (not the same as getting a new index  * within an existing class - this is actually getting a new *class*)  */
end_comment

begin_function
name|int
name|CRYPTO_ex_data_new_class
parameter_list|(
name|void
parameter_list|)
block|{
name|IMPL_CHECK
return|return
name|EX_IMPL
argument_list|(
name|new_class
argument_list|)
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/*  * Release all "ex_data" state to prevent memory leaks. This can't be made  * thread-safe without overhauling a lot of stuff, and shouldn't really be  * called under potential race-conditions anyway (it's for program shutdown  * after all).  */
end_comment

begin_function
name|void
name|CRYPTO_cleanup_all_ex_data
parameter_list|(
name|void
parameter_list|)
block|{
name|IMPL_CHECK
name|EX_IMPL
argument_list|(
name|cleanup
argument_list|)
argument_list|()
decl_stmt|;
block|}
end_function

begin_comment
comment|/* Inside an existing class, get/register a new index. */
end_comment

begin_function
name|int
name|CRYPTO_get_ex_new_index
parameter_list|(
name|int
name|class_index
parameter_list|,
name|long
name|argl
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|,
name|CRYPTO_EX_new
modifier|*
name|new_func
parameter_list|,
name|CRYPTO_EX_dup
modifier|*
name|dup_func
parameter_list|,
name|CRYPTO_EX_free
modifier|*
name|free_func
parameter_list|)
block|{
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|IMPL_CHECK
name|ret
init|=
name|EX_IMPL
argument_list|(
name|get_new_index
argument_list|)
argument_list|(
name|class_index
argument_list|,
name|argl
argument_list|,
name|argp
argument_list|,
name|new_func
argument_list|,
name|dup_func
argument_list|,
name|free_func
argument_list|)
decl_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Initialise a new CRYPTO_EX_DATA for use in a particular class - including  * calling new() callbacks for each index in the class used by this variable  */
end_comment

begin_function
name|int
name|CRYPTO_new_ex_data
parameter_list|(
name|int
name|class_index
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|)
block|{
name|IMPL_CHECK
return|return
name|EX_IMPL
argument_list|(
name|new_ex_data
argument_list|)
argument_list|(
name|class_index
argument_list|,
name|obj
argument_list|,
name|ad
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Duplicate a CRYPTO_EX_DATA variable - including calling dup() callbacks  * for each index in the class used by this variable  */
end_comment

begin_function
name|int
name|CRYPTO_dup_ex_data
parameter_list|(
name|int
name|class_index
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|to
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|from
parameter_list|)
block|{
name|IMPL_CHECK
return|return
name|EX_IMPL
argument_list|(
name|dup_ex_data
argument_list|)
argument_list|(
name|class_index
argument_list|,
name|to
argument_list|,
name|from
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cleanup a CRYPTO_EX_DATA variable - including calling free() callbacks for  * each index in the class used by this variable  */
end_comment

begin_function
name|void
name|CRYPTO_free_ex_data
parameter_list|(
name|int
name|class_index
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|)
block|{
name|IMPL_CHECK
name|EX_IMPL
argument_list|(
name|free_ex_data
argument_list|)
argument_list|(
name|class_index
argument_list|,
name|obj
argument_list|,
name|ad
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/*  * For a given CRYPTO_EX_DATA variable, set the value corresponding to a  * particular index in the class used by this variable  */
end_comment

begin_function
name|int
name|CRYPTO_set_ex_data
parameter_list|(
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|,
name|int
name|idx
parameter_list|,
name|void
modifier|*
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ad
operator|->
name|sk
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ad
operator|->
name|sk
operator|=
name|sk_void_new_null
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|CRYPTOerr
argument_list|(
name|CRYPTO_F_CRYPTO_SET_EX_DATA
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|i
operator|=
name|sk_void_num
argument_list|(
name|ad
operator|->
name|sk
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|idx
condition|)
block|{
if|if
condition|(
operator|!
name|sk_void_push
argument_list|(
name|ad
operator|->
name|sk
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|CRYPTOerr
argument_list|(
name|CRYPTO_F_CRYPTO_SET_EX_DATA
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|sk_void_set
argument_list|(
name|ad
operator|->
name|sk
argument_list|,
name|idx
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For a given CRYPTO_EX_DATA_ variable, get the value corresponding to a  * particular index in the class used by this variable  */
end_comment

begin_function
name|void
modifier|*
name|CRYPTO_get_ex_data
parameter_list|(
specifier|const
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|ad
operator|->
name|sk
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|idx
operator|>=
name|sk_void_num
argument_list|(
name|ad
operator|->
name|sk
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|sk_void_value
argument_list|(
name|ad
operator|->
name|sk
argument_list|,
name|idx
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|IMPLEMENT_STACK_OF
argument_list|(
argument|CRYPTO_EX_DATA_FUNCS
argument_list|)
end_macro

end_unit

