begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* a_strex.c */
end_comment

begin_comment
comment|/* Written by Dr Stephen N Henson (shenson@bigfoot.com) for the OpenSSL  * project 2000.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509.h>
end_include

begin_include
include|#
directive|include
file|<openssl/asn1.h>
end_include

begin_include
include|#
directive|include
file|"charmap.h"
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_comment
comment|/* ASN1_STRING_print_ex() and X509_NAME_print_ex().  * Enhanced string and name printing routines handling  * multibyte characters, RFC2253 and a host of other  * options.  */
end_comment

begin_define
define|#
directive|define
name|CHARTYPE_BS_ESC
value|(ASN1_STRFLGS_ESC_2253 | CHARTYPE_FIRST_ESC_2253 | CHARTYPE_LAST_ESC_2253)
end_define

begin_comment
comment|/* Three IO functions for sending data to memory, a BIO and  * and a FILE pointer.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* never used */
end_comment

begin_endif
unit|static int send_mem_chars(void *arg, const void *buf, int len) { 	unsigned char **out = arg; 	if(!out) return 1; 	memcpy(*out, buf, len); 	*out += len; 	return 1; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|send_bio_chars
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arg
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|BIO_write
argument_list|(
name|arg
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_fp_chars
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arg
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|arg
argument_list|)
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|len
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|int
name|char_io
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* This function handles display of  * strings, one character at a time.  * It is passed an unsigned long for each  * character because it could come from 2 or even  * 4 byte forms.  */
end_comment

begin_function
specifier|static
name|int
name|do_esc_char
parameter_list|(
name|unsigned
name|long
name|c
parameter_list|,
name|unsigned
name|char
name|flags
parameter_list|,
name|char
modifier|*
name|do_quotes
parameter_list|,
name|char_io
modifier|*
name|io_ch
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|char
name|chflgs
decl_stmt|,
name|chtmp
decl_stmt|;
name|char
name|tmphex
index|[
name|HEX_SIZE
argument_list|(
name|long
argument_list|)
operator|+
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|>
literal|0xffffffffL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|c
operator|>
literal|0xffff
condition|)
block|{
name|BIO_snprintf
argument_list|(
name|tmphex
argument_list|,
sizeof|sizeof
name|tmphex
argument_list|,
literal|"\\W%08lX"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
name|tmphex
argument_list|,
literal|10
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|10
return|;
block|}
if|if
condition|(
name|c
operator|>
literal|0xff
condition|)
block|{
name|BIO_snprintf
argument_list|(
name|tmphex
argument_list|,
sizeof|sizeof
name|tmphex
argument_list|,
literal|"\\U%04lX"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
name|tmphex
argument_list|,
literal|6
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|6
return|;
block|}
name|chtmp
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|chtmp
operator|>
literal|0x7f
condition|)
name|chflgs
operator|=
name|flags
operator|&
name|ASN1_STRFLGS_ESC_MSB
expr_stmt|;
else|else
name|chflgs
operator|=
name|char_type
index|[
name|chtmp
index|]
operator|&
name|flags
expr_stmt|;
if|if
condition|(
name|chflgs
operator|&
name|CHARTYPE_BS_ESC
condition|)
block|{
comment|/* If we don't escape with quotes, signal we need quotes */
if|if
condition|(
name|chflgs
operator|&
name|ASN1_STRFLGS_ESC_QUOTE
condition|)
block|{
if|if
condition|(
name|do_quotes
condition|)
operator|*
name|do_quotes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
operator|&
name|chtmp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
literal|"\\"
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
operator|&
name|chtmp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|chflgs
operator|&
operator|(
name|ASN1_STRFLGS_ESC_CTRL
operator||
name|ASN1_STRFLGS_ESC_MSB
operator|)
condition|)
block|{
name|BIO_snprintf
argument_list|(
name|tmphex
argument_list|,
literal|11
argument_list|,
literal|"\\%02X"
argument_list|,
name|chtmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
name|tmphex
argument_list|,
literal|3
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|3
return|;
block|}
if|if
condition|(
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
operator|&
name|chtmp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BUF_TYPE_WIDTH_MASK
value|0x7
end_define

begin_define
define|#
directive|define
name|BUF_TYPE_CONVUTF8
value|0x8
end_define

begin_comment
comment|/* This function sends each character in a buffer to  * do_esc_char(). It interprets the content formats  * and converts to or from UTF8 as appropriate.  */
end_comment

begin_function
specifier|static
name|int
name|do_buf
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|,
name|int
name|type
parameter_list|,
name|unsigned
name|char
name|flags
parameter_list|,
name|char
modifier|*
name|quotes
parameter_list|,
name|char_io
modifier|*
name|io_ch
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|outlen
decl_stmt|,
name|len
decl_stmt|;
name|unsigned
name|char
name|orflags
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|long
name|c
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|q
operator|=
name|buf
operator|+
name|buflen
expr_stmt|;
name|outlen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|q
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|buf
condition|)
name|orflags
operator|=
name|CHARTYPE_FIRST_ESC_2253
expr_stmt|;
else|else
name|orflags
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
operator|&
name|BUF_TYPE_WIDTH_MASK
condition|)
block|{
case|case
literal|4
case|:
name|c
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
operator|*
name|p
operator|++
operator|)
operator|<<
literal|24
expr_stmt|;
name|c
operator||=
operator|(
operator|(
name|unsigned
name|long
operator|)
operator|*
name|p
operator|++
operator|)
operator|<<
literal|16
expr_stmt|;
name|c
operator||=
operator|(
operator|(
name|unsigned
name|long
operator|)
operator|*
name|p
operator|++
operator|)
operator|<<
literal|8
expr_stmt|;
name|c
operator||=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|c
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
operator|*
name|p
operator|++
operator|)
operator|<<
literal|8
expr_stmt|;
name|c
operator||=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|i
operator|=
name|UTF8_getc
argument_list|(
name|p
argument_list|,
name|buflen
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Invalid UTF8String */
name|p
operator|+=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|==
name|q
condition|)
name|orflags
operator|=
name|CHARTYPE_LAST_ESC_2253
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|BUF_TYPE_CONVUTF8
condition|)
block|{
name|unsigned
name|char
name|utfbuf
index|[
literal|6
index|]
decl_stmt|;
name|int
name|utflen
decl_stmt|;
name|utflen
operator|=
name|UTF8_putc
argument_list|(
name|utfbuf
argument_list|,
sizeof|sizeof
name|utfbuf
argument_list|,
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|utflen
condition|;
name|i
operator|++
control|)
block|{
comment|/* We don't need to worry about setting orflags correctly 				 * because if utflen==1 its value will be correct anyway  				 * otherwise each character will be> 0x7f and so the  				 * character will never be escaped on first and last. 				 */
name|len
operator|=
name|do_esc_char
argument_list|(
name|utfbuf
index|[
name|i
index|]
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|flags
operator||
name|orflags
argument_list|)
argument_list|,
name|quotes
argument_list|,
name|io_ch
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|outlen
operator|+=
name|len
expr_stmt|;
block|}
block|}
else|else
block|{
name|len
operator|=
name|do_esc_char
argument_list|(
name|c
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|flags
operator||
name|orflags
argument_list|)
argument_list|,
name|quotes
argument_list|,
name|io_ch
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|outlen
operator|+=
name|len
expr_stmt|;
block|}
block|}
return|return
name|outlen
return|;
block|}
end_function

begin_comment
comment|/* This function hex dumps a buffer of characters */
end_comment

begin_function
specifier|static
name|int
name|do_hex_dump
parameter_list|(
name|char_io
modifier|*
name|io_ch
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
specifier|const
specifier|static
name|char
name|hexdig
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|hextmp
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
name|p
operator|=
name|buf
expr_stmt|;
name|q
operator|=
name|buf
operator|+
name|buflen
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|q
condition|)
block|{
name|hextmp
index|[
literal|0
index|]
operator|=
name|hexdig
index|[
operator|*
name|p
operator|>>
literal|4
index|]
expr_stmt|;
name|hextmp
index|[
literal|1
index|]
operator|=
name|hexdig
index|[
operator|*
name|p
operator|&
literal|0xf
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
name|hextmp
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|p
operator|++
expr_stmt|;
block|}
block|}
return|return
name|buflen
operator|<<
literal|1
return|;
block|}
end_function

begin_comment
comment|/* "dump" a string. This is done when the type is unknown,  * or the flags request it. We can either dump the content  * octets or the entire DER encoding. This uses the RFC2253  * #01234 format.  */
end_comment

begin_function
specifier|static
name|int
name|do_dump
parameter_list|(
name|unsigned
name|long
name|lflags
parameter_list|,
name|char_io
modifier|*
name|io_ch
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|ASN1_STRING
modifier|*
name|str
parameter_list|)
block|{
comment|/* Placing the ASN1_STRING in a temp ASN1_TYPE allows 	 * the DER encoding to readily obtained 	 */
name|ASN1_TYPE
name|t
decl_stmt|;
name|unsigned
name|char
modifier|*
name|der_buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|outlen
decl_stmt|,
name|der_len
decl_stmt|;
if|if
condition|(
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
literal|"#"
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If we don't dump DER encoding just dump content octets */
if|if
condition|(
operator|!
operator|(
name|lflags
operator|&
name|ASN1_STRFLGS_DUMP_DER
operator|)
condition|)
block|{
name|outlen
operator|=
name|do_hex_dump
argument_list|(
name|io_ch
argument_list|,
name|arg
argument_list|,
name|str
operator|->
name|data
argument_list|,
name|str
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|outlen
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|outlen
operator|+
literal|1
return|;
block|}
name|t
operator|.
name|type
operator|=
name|str
operator|->
name|type
expr_stmt|;
name|t
operator|.
name|value
operator|.
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|str
expr_stmt|;
name|der_len
operator|=
name|i2d_ASN1_TYPE
argument_list|(
operator|&
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|der_buf
operator|=
name|OPENSSL_malloc
argument_list|(
name|der_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|der_buf
condition|)
return|return
operator|-
literal|1
return|;
name|p
operator|=
name|der_buf
expr_stmt|;
name|i2d_ASN1_TYPE
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|outlen
operator|=
name|do_hex_dump
argument_list|(
name|io_ch
argument_list|,
name|arg
argument_list|,
name|der_buf
argument_list|,
name|der_len
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|der_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|outlen
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|outlen
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Lookup table to convert tags to character widths,  * 0 = UTF8 encoded, -1 is used for non string types  * otherwise it is the number of bytes per character  */
end_comment

begin_decl_stmt
specifier|const
specifier|static
name|signed
name|char
name|tag2nbyte
index|[]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 0-4 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 5-9 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
comment|/* 10-13 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 15-17 */
operator|-
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 18-20 */
operator|-
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 21-24 */
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 25-27 */
literal|4
block|,
operator|-
literal|1
block|,
literal|2
comment|/* 28-30 */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ESC_FLAGS
value|(ASN1_STRFLGS_ESC_2253 | \ 		  ASN1_STRFLGS_ESC_QUOTE | \ 		  ASN1_STRFLGS_ESC_CTRL | \ 		  ASN1_STRFLGS_ESC_MSB)
end_define

begin_comment
comment|/* This is the main function, print out an  * ASN1_STRING taking note of various escape  * and display options. Returns number of  * characters written or -1 if an error  * occurred.  */
end_comment

begin_function
specifier|static
name|int
name|do_print_ex
parameter_list|(
name|char_io
modifier|*
name|io_ch
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|unsigned
name|long
name|lflags
parameter_list|,
name|ASN1_STRING
modifier|*
name|str
parameter_list|)
block|{
name|int
name|outlen
decl_stmt|,
name|len
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
name|quotes
decl_stmt|;
name|unsigned
name|char
name|flags
decl_stmt|;
name|quotes
operator|=
literal|0
expr_stmt|;
comment|/* Keep a copy of escape flags */
name|flags
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|lflags
operator|&
name|ESC_FLAGS
argument_list|)
expr_stmt|;
name|type
operator|=
name|str
operator|->
name|type
expr_stmt|;
name|outlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lflags
operator|&
name|ASN1_STRFLGS_SHOW_TYPE
condition|)
block|{
specifier|const
name|char
modifier|*
name|tagname
decl_stmt|;
name|tagname
operator|=
name|ASN1_tag2str
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|outlen
operator|+=
name|strlen
argument_list|(
name|tagname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
name|tagname
argument_list|,
name|outlen
argument_list|)
operator|||
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|outlen
operator|++
expr_stmt|;
block|}
comment|/* Decide what to do with type, either dump content or display it */
comment|/* Dump everything */
if|if
condition|(
name|lflags
operator|&
name|ASN1_STRFLGS_DUMP_ALL
condition|)
name|type
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Ignore the string type */
elseif|else
if|if
condition|(
name|lflags
operator|&
name|ASN1_STRFLGS_IGNORE_TYPE
condition|)
name|type
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* Else determine width based on type */
if|if
condition|(
operator|(
name|type
operator|>
literal|0
operator|)
operator|&&
operator|(
name|type
operator|<
literal|31
operator|)
condition|)
name|type
operator|=
name|tag2nbyte
index|[
name|type
index|]
expr_stmt|;
else|else
name|type
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|!
operator|(
name|lflags
operator|&
name|ASN1_STRFLGS_DUMP_UNKNOWN
operator|)
condition|)
name|type
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
block|{
name|len
operator|=
name|do_dump
argument_list|(
name|lflags
argument_list|,
name|io_ch
argument_list|,
name|arg
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|outlen
operator|+=
name|len
expr_stmt|;
return|return
name|outlen
return|;
block|}
if|if
condition|(
name|lflags
operator|&
name|ASN1_STRFLGS_UTF8_CONVERT
condition|)
block|{
comment|/* Note: if string is UTF8 and we want 		 * to convert to UTF8 then we just interpret 		 * it as 1 byte per character to avoid converting 		 * twice. 		 */
if|if
condition|(
operator|!
name|type
condition|)
name|type
operator|=
literal|1
expr_stmt|;
else|else
name|type
operator||=
name|BUF_TYPE_CONVUTF8
expr_stmt|;
block|}
name|len
operator|=
name|do_buf
argument_list|(
name|str
operator|->
name|data
argument_list|,
name|str
operator|->
name|length
argument_list|,
name|type
argument_list|,
name|flags
argument_list|,
operator|&
name|quotes
argument_list|,
name|io_ch
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|outlen
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|outlen
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|quotes
condition|)
name|outlen
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
return|return
name|outlen
return|;
if|if
condition|(
name|quotes
operator|&&
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|do_buf
argument_list|(
name|str
operator|->
name|data
argument_list|,
name|str
operator|->
name|length
argument_list|,
name|type
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|io_ch
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|quotes
operator|&&
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|outlen
return|;
block|}
end_function

begin_comment
comment|/* Used for line indenting: print 'indent' spaces */
end_comment

begin_function
specifier|static
name|int
name|do_indent
parameter_list|(
name|char_io
modifier|*
name|io_ch
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FN_WIDTH_LN
value|25
end_define

begin_define
define|#
directive|define
name|FN_WIDTH_SN
value|10
end_define

begin_function
specifier|static
name|int
name|do_name_ex
parameter_list|(
name|char_io
modifier|*
name|io_ch
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|X509_NAME
modifier|*
name|n
parameter_list|,
name|int
name|indent
parameter_list|,
name|unsigned
name|long
name|flags
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|prev
init|=
operator|-
literal|1
decl_stmt|,
name|orflags
decl_stmt|,
name|cnt
decl_stmt|;
name|int
name|fn_opt
decl_stmt|,
name|fn_nid
decl_stmt|;
name|ASN1_OBJECT
modifier|*
name|fn
decl_stmt|;
name|ASN1_STRING
modifier|*
name|val
decl_stmt|;
name|X509_NAME_ENTRY
modifier|*
name|ent
decl_stmt|;
name|char
name|objtmp
index|[
literal|80
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|objbuf
decl_stmt|;
name|int
name|outlen
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|sep_dn
decl_stmt|,
modifier|*
name|sep_mv
decl_stmt|,
modifier|*
name|sep_eq
decl_stmt|;
name|int
name|sep_dn_len
decl_stmt|,
name|sep_mv_len
decl_stmt|,
name|sep_eq_len
decl_stmt|;
if|if
condition|(
name|indent
operator|<
literal|0
condition|)
name|indent
operator|=
literal|0
expr_stmt|;
name|outlen
operator|=
name|indent
expr_stmt|;
if|if
condition|(
operator|!
name|do_indent
argument_list|(
name|io_ch
argument_list|,
name|arg
argument_list|,
name|indent
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|flags
operator|&
name|XN_FLAG_SEP_MASK
condition|)
block|{
case|case
name|XN_FLAG_SEP_MULTILINE
case|:
name|sep_dn
operator|=
literal|"\n"
expr_stmt|;
name|sep_dn_len
operator|=
literal|1
expr_stmt|;
name|sep_mv
operator|=
literal|" + "
expr_stmt|;
name|sep_mv_len
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|XN_FLAG_SEP_COMMA_PLUS
case|:
name|sep_dn
operator|=
literal|","
expr_stmt|;
name|sep_dn_len
operator|=
literal|1
expr_stmt|;
name|sep_mv
operator|=
literal|"+"
expr_stmt|;
name|sep_mv_len
operator|=
literal|1
expr_stmt|;
name|indent
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XN_FLAG_SEP_CPLUS_SPC
case|:
name|sep_dn
operator|=
literal|", "
expr_stmt|;
name|sep_dn_len
operator|=
literal|2
expr_stmt|;
name|sep_mv
operator|=
literal|" + "
expr_stmt|;
name|sep_mv_len
operator|=
literal|3
expr_stmt|;
name|indent
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XN_FLAG_SEP_SPLUS_SPC
case|:
name|sep_dn
operator|=
literal|"; "
expr_stmt|;
name|sep_dn_len
operator|=
literal|2
expr_stmt|;
name|sep_mv
operator|=
literal|" + "
expr_stmt|;
name|sep_mv_len
operator|=
literal|3
expr_stmt|;
name|indent
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|XN_FLAG_SPC_EQ
condition|)
block|{
name|sep_eq
operator|=
literal|" = "
expr_stmt|;
name|sep_eq_len
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|sep_eq
operator|=
literal|"="
expr_stmt|;
name|sep_eq_len
operator|=
literal|1
expr_stmt|;
block|}
name|fn_opt
operator|=
name|flags
operator|&
name|XN_FLAG_FN_MASK
expr_stmt|;
name|cnt
operator|=
name|X509_NAME_entry_count
argument_list|(
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|flags
operator|&
name|XN_FLAG_DN_REV
condition|)
name|ent
operator|=
name|X509_NAME_get_entry
argument_list|(
name|n
argument_list|,
name|cnt
operator|-
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|ent
operator|=
name|X509_NAME_get_entry
argument_list|(
name|n
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|prev
operator|==
name|ent
operator|->
name|set
condition|)
block|{
if|if
condition|(
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
name|sep_mv
argument_list|,
name|sep_mv_len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|outlen
operator|+=
name|sep_mv_len
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
name|sep_dn
argument_list|,
name|sep_dn_len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|outlen
operator|+=
name|sep_dn_len
expr_stmt|;
if|if
condition|(
operator|!
name|do_indent
argument_list|(
name|io_ch
argument_list|,
name|arg
argument_list|,
name|indent
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|outlen
operator|+=
name|indent
expr_stmt|;
block|}
block|}
name|prev
operator|=
name|ent
operator|->
name|set
expr_stmt|;
name|fn
operator|=
name|X509_NAME_ENTRY_get_object
argument_list|(
name|ent
argument_list|)
expr_stmt|;
name|val
operator|=
name|X509_NAME_ENTRY_get_data
argument_list|(
name|ent
argument_list|)
expr_stmt|;
name|fn_nid
operator|=
name|OBJ_obj2nid
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn_opt
operator|!=
name|XN_FLAG_FN_NONE
condition|)
block|{
name|int
name|objlen
decl_stmt|,
name|fld_len
decl_stmt|;
if|if
condition|(
operator|(
name|fn_opt
operator|==
name|XN_FLAG_FN_OID
operator|)
operator|||
operator|(
name|fn_nid
operator|==
name|NID_undef
operator|)
condition|)
block|{
name|OBJ_obj2txt
argument_list|(
name|objtmp
argument_list|,
sizeof|sizeof
name|objtmp
argument_list|,
name|fn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fld_len
operator|=
literal|0
expr_stmt|;
comment|/* XXX: what should this be? */
name|objbuf
operator|=
name|objtmp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fn_opt
operator|==
name|XN_FLAG_FN_SN
condition|)
block|{
name|fld_len
operator|=
name|FN_WIDTH_SN
expr_stmt|;
name|objbuf
operator|=
name|OBJ_nid2sn
argument_list|(
name|fn_nid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn_opt
operator|==
name|XN_FLAG_FN_LN
condition|)
block|{
name|fld_len
operator|=
name|FN_WIDTH_LN
expr_stmt|;
name|objbuf
operator|=
name|OBJ_nid2ln
argument_list|(
name|fn_nid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fld_len
operator|=
literal|0
expr_stmt|;
comment|/* XXX: what should this be? */
name|objbuf
operator|=
literal|""
expr_stmt|;
block|}
block|}
name|objlen
operator|=
name|strlen
argument_list|(
name|objbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
name|objbuf
argument_list|,
name|objlen
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|objlen
operator|<
name|fld_len
operator|)
operator|&&
operator|(
name|flags
operator|&
name|XN_FLAG_FN_ALIGN
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|do_indent
argument_list|(
name|io_ch
argument_list|,
name|arg
argument_list|,
name|fld_len
operator|-
name|objlen
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|outlen
operator|+=
name|fld_len
operator|-
name|objlen
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|io_ch
argument_list|(
name|arg
argument_list|,
name|sep_eq
argument_list|,
name|sep_eq_len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|outlen
operator|+=
name|objlen
operator|+
name|sep_eq_len
expr_stmt|;
block|}
comment|/* If the field name is unknown then fix up the DER dump 		 * flag. We might want to limit this further so it will  		 * DER dump on anything other than a few 'standard' fields. 		 */
if|if
condition|(
operator|(
name|fn_nid
operator|==
name|NID_undef
operator|)
operator|&&
operator|(
name|flags
operator|&
name|XN_FLAG_DUMP_UNKNOWN_FIELDS
operator|)
condition|)
name|orflags
operator|=
name|ASN1_STRFLGS_DUMP_ALL
expr_stmt|;
else|else
name|orflags
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|do_print_ex
argument_list|(
name|io_ch
argument_list|,
name|arg
argument_list|,
name|flags
operator||
name|orflags
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|outlen
operator|+=
name|len
expr_stmt|;
block|}
return|return
name|outlen
return|;
block|}
end_function

begin_comment
comment|/* Wrappers round the main functions */
end_comment

begin_function
name|int
name|X509_NAME_print_ex
parameter_list|(
name|BIO
modifier|*
name|out
parameter_list|,
name|X509_NAME
modifier|*
name|nm
parameter_list|,
name|int
name|indent
parameter_list|,
name|unsigned
name|long
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|==
name|XN_FLAG_COMPAT
condition|)
return|return
name|X509_NAME_print
argument_list|(
name|out
argument_list|,
name|nm
argument_list|,
name|indent
argument_list|)
return|;
return|return
name|do_name_ex
argument_list|(
name|send_bio_chars
argument_list|,
name|out
argument_list|,
name|nm
argument_list|,
name|indent
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|X509_NAME_print_ex_fp
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|X509_NAME
modifier|*
name|nm
parameter_list|,
name|int
name|indent
parameter_list|,
name|unsigned
name|long
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|==
name|XN_FLAG_COMPAT
condition|)
block|{
name|BIO
modifier|*
name|btmp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|btmp
operator|=
name|BIO_new_fp
argument_list|(
name|fp
argument_list|,
name|BIO_NOCLOSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|btmp
condition|)
return|return
operator|-
literal|1
return|;
name|ret
operator|=
name|X509_NAME_print
argument_list|(
name|btmp
argument_list|,
name|nm
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|btmp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
name|do_name_ex
argument_list|(
name|send_fp_chars
argument_list|,
name|fp
argument_list|,
name|nm
argument_list|,
name|indent
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ASN1_STRING_print_ex
parameter_list|(
name|BIO
modifier|*
name|out
parameter_list|,
name|ASN1_STRING
modifier|*
name|str
parameter_list|,
name|unsigned
name|long
name|flags
parameter_list|)
block|{
return|return
name|do_print_ex
argument_list|(
name|send_bio_chars
argument_list|,
name|out
argument_list|,
name|flags
argument_list|,
name|str
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ASN1_STRING_print_ex_fp
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|ASN1_STRING
modifier|*
name|str
parameter_list|,
name|unsigned
name|long
name|flags
parameter_list|)
block|{
return|return
name|do_print_ex
argument_list|(
name|send_fp_chars
argument_list|,
name|fp
argument_list|,
name|flags
argument_list|,
name|str
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Utility function: convert any string type to UTF8, returns number of bytes  * in output string or a negative error code  */
end_comment

begin_function
name|int
name|ASN1_STRING_to_UTF8
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|out
parameter_list|,
name|ASN1_STRING
modifier|*
name|in
parameter_list|)
block|{
name|ASN1_STRING
name|stmp
decl_stmt|,
modifier|*
name|str
init|=
operator|&
name|stmp
decl_stmt|;
name|int
name|mbflag
decl_stmt|,
name|type
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
return|return
operator|-
literal|1
return|;
name|type
operator|=
name|in
operator|->
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|<
literal|0
operator|)
operator|||
operator|(
name|type
operator|>
literal|30
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|mbflag
operator|=
name|tag2nbyte
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|mbflag
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|mbflag
operator||=
name|MBSTRING_FLAG
expr_stmt|;
name|stmp
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|ASN1_mbstring_copy
argument_list|(
operator|&
name|str
argument_list|,
name|in
operator|->
name|data
argument_list|,
name|in
operator|->
name|length
argument_list|,
name|mbflag
argument_list|,
name|B_ASN1_UTF8STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
operator|*
name|out
operator|=
name|stmp
operator|.
name|data
expr_stmt|;
return|return
name|stmp
operator|.
name|length
return|;
block|}
end_function

end_unit

