begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tasn_dec.c */
end_comment

begin_comment
comment|/*  * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project  * 2000.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/asn1.h>
end_include

begin_include
include|#
directive|include
file|<openssl/asn1t.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/buffer.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_function_decl
specifier|static
name|int
name|asn1_check_eoc
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asn1_find_end
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
name|char
name|inf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asn1_collect
parameter_list|(
name|BUF_MEM
modifier|*
name|buf
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
name|char
name|inf
parameter_list|,
name|int
name|tag
parameter_list|,
name|int
name|aclass
parameter_list|,
name|int
name|depth
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|collect_data
parameter_list|(
name|BUF_MEM
modifier|*
name|buf
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|long
name|plen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asn1_check_tlen
parameter_list|(
name|long
modifier|*
name|olen
parameter_list|,
name|int
modifier|*
name|otag
parameter_list|,
name|unsigned
name|char
modifier|*
name|oclass
parameter_list|,
name|char
modifier|*
name|inf
parameter_list|,
name|char
modifier|*
name|cst
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
name|int
name|exptag
parameter_list|,
name|int
name|expclass
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asn1_template_ex_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asn1_template_noexp_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|val
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asn1_d2i_ex_primitive
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|,
name|int
name|tag
parameter_list|,
name|int
name|aclass
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Table to convert tags to bit values, used for MSTRING type */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|long
name|tag2bit
index|[
literal|32
index|]
init|=
block|{
comment|/* tags  0 -  3 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|B_ASN1_BIT_STRING
block|,
comment|/* tags  4- 7 */
name|B_ASN1_OCTET_STRING
block|,
literal|0
block|,
literal|0
block|,
name|B_ASN1_UNKNOWN
block|,
comment|/* tags  8-11 */
name|B_ASN1_UNKNOWN
block|,
name|B_ASN1_UNKNOWN
block|,
name|B_ASN1_UNKNOWN
block|,
name|B_ASN1_UNKNOWN
block|,
comment|/* tags 12-15 */
name|B_ASN1_UTF8STRING
block|,
name|B_ASN1_UNKNOWN
block|,
name|B_ASN1_UNKNOWN
block|,
name|B_ASN1_UNKNOWN
block|,
comment|/* tags 16-19 */
name|B_ASN1_SEQUENCE
block|,
literal|0
block|,
name|B_ASN1_NUMERICSTRING
block|,
name|B_ASN1_PRINTABLESTRING
block|,
comment|/* tags 20-22 */
name|B_ASN1_T61STRING
block|,
name|B_ASN1_VIDEOTEXSTRING
block|,
name|B_ASN1_IA5STRING
block|,
comment|/* tags 23-24 */
name|B_ASN1_UTCTIME
block|,
name|B_ASN1_GENERALIZEDTIME
block|,
comment|/* tags 25-27 */
name|B_ASN1_GRAPHICSTRING
block|,
name|B_ASN1_ISO64STRING
block|,
name|B_ASN1_GENERALSTRING
block|,
comment|/* tags 28-31 */
name|B_ASN1_UNIVERSALSTRING
block|,
name|B_ASN1_UNKNOWN
block|,
name|B_ASN1_BMPSTRING
block|,
name|B_ASN1_UNKNOWN
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|unsigned
name|long
name|ASN1_tag2bit
parameter_list|(
name|int
name|tag
parameter_list|)
block|{
if|if
condition|(
operator|(
name|tag
operator|<
literal|0
operator|)
operator|||
operator|(
name|tag
operator|>
literal|30
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|tag2bit
index|[
name|tag
index|]
return|;
block|}
end_function

begin_comment
comment|/* Macro to initialize and invalidate the cache */
end_comment

begin_define
define|#
directive|define
name|asn1_tlc_clear
parameter_list|(
name|c
parameter_list|)
value|if (c) (c)->valid = 0
end_define

begin_comment
comment|/* Version to avoid compiler warning about 'c' always non-NULL */
end_comment

begin_define
define|#
directive|define
name|asn1_tlc_clear_nc
parameter_list|(
name|c
parameter_list|)
value|(c)->valid = 0
end_define

begin_comment
comment|/*  * Decode an ASN1 item, this currently behaves just like a standard 'd2i'  * function. 'in' points to a buffer to read the data from, in future we  * will have more advanced versions that can input data a piece at a time and  * this will simply be a special case.  */
end_comment

begin_function
name|ASN1_VALUE
modifier|*
name|ASN1_item_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
block|{
name|ASN1_TLC
name|c
decl_stmt|;
name|ASN1_VALUE
modifier|*
name|ptmpval
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|pval
condition|)
name|pval
operator|=
operator|&
name|ptmpval
expr_stmt|;
name|asn1_tlc_clear_nc
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASN1_item_ex_d2i
argument_list|(
name|pval
argument_list|,
name|in
argument_list|,
name|len
argument_list|,
name|it
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|c
argument_list|)
operator|>
literal|0
condition|)
return|return
operator|*
name|pval
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|ASN1_template_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|)
block|{
name|ASN1_TLC
name|c
decl_stmt|;
name|asn1_tlc_clear_nc
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
return|return
name|asn1_template_ex_d2i
argument_list|(
name|pval
argument_list|,
name|in
argument_list|,
name|len
argument_list|,
name|tt
argument_list|,
literal|0
argument_list|,
operator|&
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decode an item, taking care of IMPLICIT tagging, if any. If 'opt' set and  * tag mismatch return -1 to handle OPTIONAL  */
end_comment

begin_function
name|int
name|ASN1_item_ex_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|,
name|int
name|tag
parameter_list|,
name|int
name|aclass
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
decl_stmt|,
modifier|*
name|errtt
init|=
name|NULL
decl_stmt|;
specifier|const
name|ASN1_COMPAT_FUNCS
modifier|*
name|cf
decl_stmt|;
specifier|const
name|ASN1_EXTERN_FUNCS
modifier|*
name|ef
decl_stmt|;
specifier|const
name|ASN1_AUX
modifier|*
name|aux
init|=
name|it
operator|->
name|funcs
decl_stmt|;
name|ASN1_aux_cb
modifier|*
name|asn1_cb
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|char
modifier|*
name|wp
init|=
name|NULL
decl_stmt|;
comment|/* BIG FAT WARNING! BREAKS CONST WHERE USED */
name|unsigned
name|char
name|imphack
init|=
literal|0
decl_stmt|,
name|oclass
decl_stmt|;
name|char
name|seq_eoc
decl_stmt|,
name|seq_nolen
decl_stmt|,
name|cst
decl_stmt|,
name|isopt
decl_stmt|;
name|long
name|tmplen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|otag
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|ASN1_VALUE
modifier|*
modifier|*
name|pchptr
decl_stmt|,
modifier|*
name|ptmpval
decl_stmt|;
name|int
name|combine
init|=
name|aclass
operator|&
name|ASN1_TFLG_COMBINE
decl_stmt|;
name|aclass
operator|&=
operator|~
name|ASN1_TFLG_COMBINE
expr_stmt|;
if|if
condition|(
operator|!
name|pval
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|aux
operator|&&
name|aux
operator|->
name|asn1_cb
condition|)
name|asn1_cb
operator|=
name|aux
operator|->
name|asn1_cb
expr_stmt|;
else|else
name|asn1_cb
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|it
operator|->
name|itype
condition|)
block|{
case|case
name|ASN1_ITYPE_PRIMITIVE
case|:
if|if
condition|(
name|it
operator|->
name|templates
condition|)
block|{
comment|/*              * tagging or OPTIONAL is currently illegal on an item template              * because the flags can't get passed down. In practice this              * isn't a problem: we include the relevant flags from the item              * template in the template itself.              */
if|if
condition|(
operator|(
name|tag
operator|!=
operator|-
literal|1
operator|)
operator|||
name|opt
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
name|asn1_template_ex_d2i
argument_list|(
name|pval
argument_list|,
name|in
argument_list|,
name|len
argument_list|,
name|it
operator|->
name|templates
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
return|;
block|}
return|return
name|asn1_d2i_ex_primitive
argument_list|(
name|pval
argument_list|,
name|in
argument_list|,
name|len
argument_list|,
name|it
argument_list|,
name|tag
argument_list|,
name|aclass
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
return|;
break|break;
case|case
name|ASN1_ITYPE_MSTRING
case|:
name|p
operator|=
operator|*
name|in
expr_stmt|;
comment|/* Just read in tag and class */
name|ret
operator|=
name|asn1_check_tlen
argument_list|(
name|NULL
argument_list|,
operator|&
name|otag
argument_list|,
operator|&
name|oclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Must be UNIVERSAL class */
if|if
condition|(
name|oclass
operator|!=
name|V_ASN1_UNIVERSAL
condition|)
block|{
comment|/* If OPTIONAL, assume this is OK */
if|if
condition|(
name|opt
condition|)
return|return
operator|-
literal|1
return|;
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_MSTRING_NOT_UNIVERSAL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Check tag matches bit map */
if|if
condition|(
operator|!
operator|(
name|ASN1_tag2bit
argument_list|(
name|otag
argument_list|)
operator|&
name|it
operator|->
name|utype
operator|)
condition|)
block|{
comment|/* If OPTIONAL, assume this is OK */
if|if
condition|(
name|opt
condition|)
return|return
operator|-
literal|1
return|;
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_MSTRING_WRONG_TAG
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
name|asn1_d2i_ex_primitive
argument_list|(
name|pval
argument_list|,
name|in
argument_list|,
name|len
argument_list|,
name|it
argument_list|,
name|otag
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ctx
argument_list|)
return|;
case|case
name|ASN1_ITYPE_EXTERN
case|:
comment|/* Use new style d2i */
name|ef
operator|=
name|it
operator|->
name|funcs
expr_stmt|;
return|return
name|ef
operator|->
name|asn1_ex_d2i
argument_list|(
name|pval
argument_list|,
name|in
argument_list|,
name|len
argument_list|,
name|it
argument_list|,
name|tag
argument_list|,
name|aclass
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
return|;
case|case
name|ASN1_ITYPE_COMPAT
case|:
comment|/* we must resort to old style evil hackery */
name|cf
operator|=
name|it
operator|->
name|funcs
expr_stmt|;
comment|/* If OPTIONAL see if it is there */
if|if
condition|(
name|opt
condition|)
block|{
name|int
name|exptag
decl_stmt|;
name|p
operator|=
operator|*
name|in
expr_stmt|;
if|if
condition|(
name|tag
operator|==
operator|-
literal|1
condition|)
name|exptag
operator|=
name|it
operator|->
name|utype
expr_stmt|;
else|else
name|exptag
operator|=
name|tag
expr_stmt|;
comment|/*              * Don't care about anything other than presence of expected tag              */
name|ret
operator|=
name|asn1_check_tlen
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|exptag
argument_list|,
name|aclass
argument_list|,
literal|1
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/*          * This is the old style evil hack IMPLICIT handling: since the          * underlying code is expecting a tag and class other than the one          * present we change the buffer temporarily then change it back          * afterwards. This doesn't and never did work for tags> 30. Yes          * this is *horrible* but it is only needed for old style d2i which          * will hopefully not be around for much longer. FIXME: should copy          * the buffer then modify it so the input buffer can be const: we          * should *always* copy because the old style d2i might modify the          * buffer.          */
if|if
condition|(
name|tag
operator|!=
operator|-
literal|1
condition|)
block|{
name|wp
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|in
expr_stmt|;
name|imphack
operator|=
operator|*
name|wp
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|*
name|wp
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
operator|*
name|p
operator|&
name|V_ASN1_CONSTRUCTED
operator|)
operator||
name|it
operator|->
name|utype
argument_list|)
expr_stmt|;
block|}
name|ptmpval
operator|=
name|cf
operator|->
name|asn1_d2i
argument_list|(
name|pval
argument_list|,
name|in
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
operator|-
literal|1
condition|)
operator|*
name|wp
operator|=
name|imphack
expr_stmt|;
if|if
condition|(
name|ptmpval
condition|)
return|return
literal|1
return|;
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
case|case
name|ASN1_ITYPE_CHOICE
case|:
if|if
condition|(
name|asn1_cb
operator|&&
operator|!
name|asn1_cb
argument_list|(
name|ASN1_OP_D2I_PRE
argument_list|,
name|pval
argument_list|,
name|it
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|auxerr
goto|;
if|if
condition|(
operator|*
name|pval
condition|)
block|{
comment|/* Free up and zero CHOICE value if initialised */
name|i
operator|=
name|asn1_get_choice_selector
argument_list|(
name|pval
argument_list|,
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<
name|it
operator|->
name|tcount
operator|)
condition|)
block|{
name|tt
operator|=
name|it
operator|->
name|templates
operator|+
name|i
expr_stmt|;
name|pchptr
operator|=
name|asn1_get_field_ptr
argument_list|(
name|pval
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|ASN1_template_free
argument_list|(
name|pchptr
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|asn1_set_choice_selector
argument_list|(
name|pval
argument_list|,
operator|-
literal|1
argument_list|,
name|it
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ASN1_item_ex_new
argument_list|(
name|pval
argument_list|,
name|it
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* CHOICE type, try each possibility in turn */
name|p
operator|=
operator|*
name|in
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tt
operator|=
name|it
operator|->
name|templates
init|;
name|i
operator|<
name|it
operator|->
name|tcount
condition|;
name|i
operator|++
operator|,
name|tt
operator|++
control|)
block|{
name|pchptr
operator|=
name|asn1_get_field_ptr
argument_list|(
name|pval
argument_list|,
name|tt
argument_list|)
expr_stmt|;
comment|/*              * We mark field as OPTIONAL so its absence can be recognised.              */
name|ret
operator|=
name|asn1_template_ex_d2i
argument_list|(
name|pchptr
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|tt
argument_list|,
literal|1
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* If field not present, try the next one */
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* If positive return, read OK, break loop */
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
break|break;
comment|/* Otherwise must be an ASN1 parsing error */
name|errtt
operator|=
name|tt
expr_stmt|;
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Did we fall off the end without reading anything? */
if|if
condition|(
name|i
operator|==
name|it
operator|->
name|tcount
condition|)
block|{
comment|/* If OPTIONAL, this is OK */
if|if
condition|(
name|opt
condition|)
block|{
comment|/* Free and zero it */
name|ASN1_item_ex_free
argument_list|(
name|pval
argument_list|,
name|it
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_NO_MATCHING_CHOICE_TYPE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|asn1_set_choice_selector
argument_list|(
name|pval
argument_list|,
name|i
argument_list|,
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|asn1_cb
operator|&&
operator|!
name|asn1_cb
argument_list|(
name|ASN1_OP_D2I_POST
argument_list|,
name|pval
argument_list|,
name|it
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|auxerr
goto|;
operator|*
name|in
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
case|case
name|ASN1_ITYPE_NDEF_SEQUENCE
case|:
case|case
name|ASN1_ITYPE_SEQUENCE
case|:
name|p
operator|=
operator|*
name|in
expr_stmt|;
name|tmplen
operator|=
name|len
expr_stmt|;
comment|/* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */
if|if
condition|(
name|tag
operator|==
operator|-
literal|1
condition|)
block|{
name|tag
operator|=
name|V_ASN1_SEQUENCE
expr_stmt|;
name|aclass
operator|=
name|V_ASN1_UNIVERSAL
expr_stmt|;
block|}
comment|/* Get SEQUENCE length and update len, p */
name|ret
operator|=
name|asn1_check_tlen
argument_list|(
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|seq_eoc
argument_list|,
operator|&
name|cst
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|tag
argument_list|,
name|aclass
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|aux
operator|&&
operator|(
name|aux
operator|->
name|flags
operator|&
name|ASN1_AFLG_BROKEN
operator|)
condition|)
block|{
name|len
operator|=
name|tmplen
operator|-
operator|(
name|p
operator|-
operator|*
name|in
operator|)
expr_stmt|;
name|seq_nolen
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If indefinite we don't do a length check */
else|else
name|seq_nolen
operator|=
name|seq_eoc
expr_stmt|;
if|if
condition|(
operator|!
name|cst
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_SEQUENCE_NOT_CONSTRUCTED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
operator|*
name|pval
operator|&&
operator|!
name|ASN1_item_ex_new
argument_list|(
name|pval
argument_list|,
name|it
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|asn1_cb
operator|&&
operator|!
name|asn1_cb
argument_list|(
name|ASN1_OP_D2I_PRE
argument_list|,
name|pval
argument_list|,
name|it
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|auxerr
goto|;
comment|/* Free up and zero any ADB found */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tt
operator|=
name|it
operator|->
name|templates
init|;
name|i
operator|<
name|it
operator|->
name|tcount
condition|;
name|i
operator|++
operator|,
name|tt
operator|++
control|)
block|{
if|if
condition|(
name|tt
operator|->
name|flags
operator|&
name|ASN1_TFLG_ADB_MASK
condition|)
block|{
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|seqtt
decl_stmt|;
name|ASN1_VALUE
modifier|*
modifier|*
name|pseqval
decl_stmt|;
name|seqtt
operator|=
name|asn1_do_adb
argument_list|(
name|pval
argument_list|,
name|tt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pseqval
operator|=
name|asn1_get_field_ptr
argument_list|(
name|pval
argument_list|,
name|seqtt
argument_list|)
expr_stmt|;
name|ASN1_template_free
argument_list|(
name|pseqval
argument_list|,
name|seqtt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get each field entry */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tt
operator|=
name|it
operator|->
name|templates
init|;
name|i
operator|<
name|it
operator|->
name|tcount
condition|;
name|i
operator|++
operator|,
name|tt
operator|++
control|)
block|{
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|seqtt
decl_stmt|;
name|ASN1_VALUE
modifier|*
modifier|*
name|pseqval
decl_stmt|;
name|seqtt
operator|=
name|asn1_do_adb
argument_list|(
name|pval
argument_list|,
name|tt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seqtt
condition|)
goto|goto
name|err
goto|;
name|pseqval
operator|=
name|asn1_get_field_ptr
argument_list|(
name|pval
argument_list|,
name|seqtt
argument_list|)
expr_stmt|;
comment|/* Have we ran out of data? */
if|if
condition|(
operator|!
name|len
condition|)
break|break;
name|q
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|asn1_check_eoc
argument_list|(
operator|&
name|p
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|seq_eoc
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_UNEXPECTED_EOC
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|len
operator|-=
name|p
operator|-
name|q
expr_stmt|;
name|seq_eoc
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
break|break;
block|}
comment|/*              * This determines the OPTIONAL flag value. The field cannot be              * omitted if it is the last of a SEQUENCE and there is still              * data to be read. This isn't strictly necessary but it              * increases efficiency in some cases.              */
if|if
condition|(
name|i
operator|==
operator|(
name|it
operator|->
name|tcount
operator|-
literal|1
operator|)
condition|)
name|isopt
operator|=
literal|0
expr_stmt|;
else|else
name|isopt
operator|=
call|(
name|char
call|)
argument_list|(
name|seqtt
operator|->
name|flags
operator|&
name|ASN1_TFLG_OPTIONAL
argument_list|)
expr_stmt|;
comment|/*              * attempt to read in field, allowing each to be OPTIONAL              */
name|ret
operator|=
name|asn1_template_ex_d2i
argument_list|(
name|pseqval
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|seqtt
argument_list|,
name|isopt
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|errtt
operator|=
name|seqtt
expr_stmt|;
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
comment|/*                  * OPTIONAL component absent. Free and zero the field.                  */
name|ASN1_template_free
argument_list|(
name|pseqval
argument_list|,
name|seqtt
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Update length */
name|len
operator|-=
name|p
operator|-
name|q
expr_stmt|;
block|}
comment|/* Check for EOC if expecting one */
if|if
condition|(
name|seq_eoc
operator|&&
operator|!
name|asn1_check_eoc
argument_list|(
operator|&
name|p
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_MISSING_EOC
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Check all data read */
if|if
condition|(
operator|!
name|seq_nolen
operator|&&
name|len
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_SEQUENCE_LENGTH_MISMATCH
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/*          * If we get here we've got no more data in the SEQUENCE, however we          * may not have read all fields so check all remaining are OPTIONAL          * and clear any that are.          */
for|for
control|(
init|;
name|i
operator|<
name|it
operator|->
name|tcount
condition|;
name|tt
operator|++
operator|,
name|i
operator|++
control|)
block|{
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|seqtt
decl_stmt|;
name|seqtt
operator|=
name|asn1_do_adb
argument_list|(
name|pval
argument_list|,
name|tt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seqtt
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|seqtt
operator|->
name|flags
operator|&
name|ASN1_TFLG_OPTIONAL
condition|)
block|{
name|ASN1_VALUE
modifier|*
modifier|*
name|pseqval
decl_stmt|;
name|pseqval
operator|=
name|asn1_get_field_ptr
argument_list|(
name|pval
argument_list|,
name|seqtt
argument_list|)
expr_stmt|;
name|ASN1_template_free
argument_list|(
name|pseqval
argument_list|,
name|seqtt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errtt
operator|=
name|seqtt
expr_stmt|;
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_FIELD_MISSING
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
comment|/* Save encoding */
if|if
condition|(
operator|!
name|asn1_enc_save
argument_list|(
name|pval
argument_list|,
operator|*
name|in
argument_list|,
name|p
operator|-
operator|*
name|in
argument_list|,
name|it
argument_list|)
condition|)
goto|goto
name|auxerr
goto|;
if|if
condition|(
name|asn1_cb
operator|&&
operator|!
name|asn1_cb
argument_list|(
name|ASN1_OP_D2I_POST
argument_list|,
name|pval
argument_list|,
name|it
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|auxerr
goto|;
operator|*
name|in
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
name|auxerr
label|:
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_AUX_ERROR
argument_list|)
expr_stmt|;
name|err
label|:
if|if
condition|(
name|combine
operator|==
literal|0
condition|)
name|ASN1_item_ex_free
argument_list|(
name|pval
argument_list|,
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|errtt
condition|)
name|ERR_add_error_data
argument_list|(
literal|4
argument_list|,
literal|"Field="
argument_list|,
name|errtt
operator|->
name|field_name
argument_list|,
literal|", Type="
argument_list|,
name|it
operator|->
name|sname
argument_list|)
expr_stmt|;
else|else
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"Type="
argument_list|,
name|it
operator|->
name|sname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Templates are handled with two separate functions. One handles any  * EXPLICIT tag and the other handles the rest.  */
end_comment

begin_function
specifier|static
name|int
name|asn1_template_ex_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|val
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|inlen
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|flags
decl_stmt|,
name|aclass
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|long
name|len
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|exp_eoc
decl_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
return|return
literal|0
return|;
name|flags
operator|=
name|tt
operator|->
name|flags
expr_stmt|;
name|aclass
operator|=
name|flags
operator|&
name|ASN1_TFLG_TAG_CLASS
expr_stmt|;
name|p
operator|=
operator|*
name|in
expr_stmt|;
comment|/* Check if EXPLICIT tag expected */
if|if
condition|(
name|flags
operator|&
name|ASN1_TFLG_EXPTAG
condition|)
block|{
name|char
name|cst
decl_stmt|;
comment|/*          * Need to work out amount of data available to the inner content and          * where it starts: so read in EXPLICIT header to get the info.          */
name|ret
operator|=
name|asn1_check_tlen
argument_list|(
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|exp_eoc
argument_list|,
operator|&
name|cst
argument_list|,
operator|&
name|p
argument_list|,
name|inlen
argument_list|,
name|tt
operator|->
name|tag
argument_list|,
name|aclass
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|cst
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_EX_D2I
argument_list|,
name|ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We've found the field so it can't be OPTIONAL now */
name|ret
operator|=
name|asn1_template_noexp_d2i
argument_list|(
name|val
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|tt
argument_list|,
literal|0
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We read the field in OK so update length */
name|len
operator|-=
name|p
operator|-
name|q
expr_stmt|;
if|if
condition|(
name|exp_eoc
condition|)
block|{
comment|/* If NDEF we must have an EOC here */
if|if
condition|(
operator|!
name|asn1_check_eoc
argument_list|(
operator|&
name|p
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_EX_D2I
argument_list|,
name|ASN1_R_MISSING_EOC
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
else|else
block|{
comment|/*              * Otherwise we must hit the EXPLICIT tag end or its an error              */
if|if
condition|(
name|len
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_EX_D2I
argument_list|,
name|ASN1_R_EXPLICIT_LENGTH_MISMATCH
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
block|}
else|else
return|return
name|asn1_template_noexp_d2i
argument_list|(
name|val
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|,
name|tt
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
return|;
operator|*
name|in
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
name|err
label|:
name|ASN1_template_free
argument_list|(
name|val
argument_list|,
name|tt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|asn1_template_noexp_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|val
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|flags
decl_stmt|,
name|aclass
decl_stmt|;
name|int
name|ret
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
return|return
literal|0
return|;
name|flags
operator|=
name|tt
operator|->
name|flags
expr_stmt|;
name|aclass
operator|=
name|flags
operator|&
name|ASN1_TFLG_TAG_CLASS
expr_stmt|;
name|p
operator|=
operator|*
name|in
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ASN1_TFLG_SK_MASK
condition|)
block|{
comment|/* SET OF, SEQUENCE OF */
name|int
name|sktag
decl_stmt|,
name|skaclass
decl_stmt|;
name|char
name|sk_eoc
decl_stmt|;
comment|/* First work out expected inner tag value */
if|if
condition|(
name|flags
operator|&
name|ASN1_TFLG_IMPTAG
condition|)
block|{
name|sktag
operator|=
name|tt
operator|->
name|tag
expr_stmt|;
name|skaclass
operator|=
name|aclass
expr_stmt|;
block|}
else|else
block|{
name|skaclass
operator|=
name|V_ASN1_UNIVERSAL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ASN1_TFLG_SET_OF
condition|)
name|sktag
operator|=
name|V_ASN1_SET
expr_stmt|;
else|else
name|sktag
operator|=
name|V_ASN1_SEQUENCE
expr_stmt|;
block|}
comment|/* Get the tag */
name|ret
operator|=
name|asn1_check_tlen
argument_list|(
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sk_eoc
argument_list|,
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|sktag
argument_list|,
name|skaclass
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|*
name|val
condition|)
operator|*
name|val
operator|=
operator|(
name|ASN1_VALUE
operator|*
operator|)
name|sk_new_null
argument_list|()
expr_stmt|;
else|else
block|{
comment|/*              * We've got a valid STACK: free up any items present              */
name|STACK_OF
argument_list|(
name|ASN1_VALUE
argument_list|)
operator|*
name|sktmp
operator|=
operator|(
name|STACK_OF
argument_list|(
name|ASN1_VALUE
argument_list|)
operator|*
operator|)
operator|*
name|val
expr_stmt|;
name|ASN1_VALUE
modifier|*
name|vtmp
decl_stmt|;
while|while
condition|(
name|sk_ASN1_VALUE_num
argument_list|(
name|sktmp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|vtmp
operator|=
name|sk_ASN1_VALUE_pop
argument_list|(
name|sktmp
argument_list|)
expr_stmt|;
name|ASN1_item_ex_free
argument_list|(
operator|&
name|vtmp
argument_list|,
name|ASN1_ITEM_ptr
argument_list|(
name|tt
operator|->
name|item
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|val
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Read as many items as we can */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|ASN1_VALUE
modifier|*
name|skfield
decl_stmt|;
name|q
operator|=
name|p
expr_stmt|;
comment|/* See if EOC found */
if|if
condition|(
name|asn1_check_eoc
argument_list|(
operator|&
name|p
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|sk_eoc
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ASN1_R_UNEXPECTED_EOC
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|len
operator|-=
name|p
operator|-
name|q
expr_stmt|;
name|sk_eoc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|skfield
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ASN1_item_ex_d2i
argument_list|(
operator|&
name|skfield
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|ASN1_ITEM_ptr
argument_list|(
name|tt
operator|->
name|item
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|len
operator|-=
name|p
operator|-
name|q
expr_stmt|;
if|if
condition|(
operator|!
name|sk_ASN1_VALUE_push
argument_list|(
operator|(
name|STACK_OF
argument_list|(
name|ASN1_VALUE
argument_list|)
operator|*
operator|)
operator|*
name|val
argument_list|,
name|skfield
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|sk_eoc
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ASN1_R_MISSING_EOC
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|ASN1_TFLG_IMPTAG
condition|)
block|{
comment|/* IMPLICIT tagging */
name|ret
operator|=
name|ASN1_item_ex_d2i
argument_list|(
name|val
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|ASN1_ITEM_ptr
argument_list|(
name|tt
operator|->
name|item
argument_list|)
argument_list|,
name|tt
operator|->
name|tag
argument_list|,
name|aclass
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|/* Nothing special */
name|ret
operator|=
name|ASN1_item_ex_d2i
argument_list|(
name|val
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|ASN1_ITEM_ptr
argument_list|(
name|tt
operator|->
name|item
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|tt
operator|->
name|flags
operator|&
name|ASN1_TFLG_COMBINE
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|in
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
name|err
label|:
name|ASN1_template_free
argument_list|(
name|val
argument_list|,
name|tt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|asn1_d2i_ex_primitive
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|inlen
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|,
name|int
name|tag
parameter_list|,
name|int
name|aclass
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|utype
decl_stmt|;
name|long
name|plen
decl_stmt|;
name|char
name|cst
decl_stmt|,
name|inf
decl_stmt|,
name|free_cont
init|=
literal|0
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|BUF_MEM
name|buf
init|=
block|{
literal|0
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|cont
init|=
name|NULL
decl_stmt|;
name|long
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|pval
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_D2I_EX_PRIMITIVE
argument_list|,
name|ASN1_R_ILLEGAL_NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Should never happen */
block|}
if|if
condition|(
name|it
operator|->
name|itype
operator|==
name|ASN1_ITYPE_MSTRING
condition|)
block|{
name|utype
operator|=
name|tag
expr_stmt|;
name|tag
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|utype
operator|=
name|it
operator|->
name|utype
expr_stmt|;
if|if
condition|(
name|utype
operator|==
name|V_ASN1_ANY
condition|)
block|{
comment|/* If type is ANY need to figure out type from tag */
name|unsigned
name|char
name|oclass
decl_stmt|;
if|if
condition|(
name|tag
operator|>=
literal|0
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_D2I_EX_PRIMITIVE
argument_list|,
name|ASN1_R_ILLEGAL_TAGGED_ANY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|opt
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_D2I_EX_PRIMITIVE
argument_list|,
name|ASN1_R_ILLEGAL_OPTIONAL_ANY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|=
operator|*
name|in
expr_stmt|;
name|ret
operator|=
name|asn1_check_tlen
argument_list|(
name|NULL
argument_list|,
operator|&
name|utype
argument_list|,
operator|&
name|oclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|inlen
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_D2I_EX_PRIMITIVE
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|oclass
operator|!=
name|V_ASN1_UNIVERSAL
condition|)
name|utype
operator|=
name|V_ASN1_OTHER
expr_stmt|;
block|}
if|if
condition|(
name|tag
operator|==
operator|-
literal|1
condition|)
block|{
name|tag
operator|=
name|utype
expr_stmt|;
name|aclass
operator|=
name|V_ASN1_UNIVERSAL
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|in
expr_stmt|;
comment|/* Check header */
name|ret
operator|=
name|asn1_check_tlen
argument_list|(
operator|&
name|plen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|inf
argument_list|,
operator|&
name|cst
argument_list|,
operator|&
name|p
argument_list|,
name|inlen
argument_list|,
name|tag
argument_list|,
name|aclass
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_D2I_EX_PRIMITIVE
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* SEQUENCE, SET and "OTHER" are left in encoded form */
if|if
condition|(
operator|(
name|utype
operator|==
name|V_ASN1_SEQUENCE
operator|)
operator|||
operator|(
name|utype
operator|==
name|V_ASN1_SET
operator|)
operator|||
operator|(
name|utype
operator|==
name|V_ASN1_OTHER
operator|)
condition|)
block|{
comment|/*          * Clear context cache for type OTHER because the auto clear when we          * have a exact match wont work          */
if|if
condition|(
name|utype
operator|==
name|V_ASN1_OTHER
condition|)
block|{
name|asn1_tlc_clear
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/* SEQUENCE and SET must be constructed */
elseif|else
if|if
condition|(
operator|!
name|cst
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_D2I_EX_PRIMITIVE
argument_list|,
name|ASN1_R_TYPE_NOT_CONSTRUCTED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cont
operator|=
operator|*
name|in
expr_stmt|;
comment|/* If indefinite length constructed find the real end */
if|if
condition|(
name|inf
condition|)
block|{
if|if
condition|(
operator|!
name|asn1_find_end
argument_list|(
operator|&
name|p
argument_list|,
name|plen
argument_list|,
name|inf
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|len
operator|=
name|p
operator|-
name|cont
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|p
operator|-
name|cont
operator|+
name|plen
expr_stmt|;
name|p
operator|+=
name|plen
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cst
condition|)
block|{
if|if
condition|(
name|utype
operator|==
name|V_ASN1_NULL
operator|||
name|utype
operator|==
name|V_ASN1_BOOLEAN
operator|||
name|utype
operator|==
name|V_ASN1_OBJECT
operator|||
name|utype
operator|==
name|V_ASN1_INTEGER
operator|||
name|utype
operator|==
name|V_ASN1_ENUMERATED
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_D2I_EX_PRIMITIVE
argument_list|,
name|ASN1_R_TYPE_NOT_PRIMITIVE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Free any returned 'buf' content */
name|free_cont
operator|=
literal|1
expr_stmt|;
comment|/*          * Should really check the internal tags are correct but some things          * may get this wrong. The relevant specs say that constructed string          * types should be OCTET STRINGs internally irrespective of the type.          * So instead just check for UNIVERSAL class and ignore the tag.          */
if|if
condition|(
operator|!
name|asn1_collect
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|p
argument_list|,
name|plen
argument_list|,
name|inf
argument_list|,
operator|-
literal|1
argument_list|,
name|V_ASN1_UNIVERSAL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
goto|goto
name|err
goto|;
block|}
name|len
operator|=
name|buf
operator|.
name|length
expr_stmt|;
comment|/* Append a final null to string */
if|if
condition|(
operator|!
name|BUF_MEM_grow_clean
argument_list|(
operator|&
name|buf
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_D2I_EX_PRIMITIVE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|buf
operator|.
name|data
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|cont
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|.
name|data
expr_stmt|;
block|}
else|else
block|{
name|cont
operator|=
name|p
expr_stmt|;
name|len
operator|=
name|plen
expr_stmt|;
name|p
operator|+=
name|plen
expr_stmt|;
block|}
comment|/* We now have content length and type: translate into a structure */
comment|/* asn1_ex_c2i may reuse allocated buffer, and so sets free_cont to 0 */
if|if
condition|(
operator|!
name|asn1_ex_c2i
argument_list|(
name|pval
argument_list|,
name|cont
argument_list|,
name|len
argument_list|,
name|utype
argument_list|,
operator|&
name|free_cont
argument_list|,
name|it
argument_list|)
condition|)
goto|goto
name|err
goto|;
operator|*
name|in
operator|=
name|p
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|free_cont
operator|&&
name|buf
operator|.
name|data
condition|)
name|OPENSSL_free
argument_list|(
name|buf
operator|.
name|data
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Translate ASN1 content octets into a structure */
end_comment

begin_function
name|int
name|asn1_ex_c2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|cont
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|utype
parameter_list|,
name|char
modifier|*
name|free_cont
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
block|{
name|ASN1_VALUE
modifier|*
modifier|*
name|opval
init|=
name|NULL
decl_stmt|;
name|ASN1_STRING
modifier|*
name|stmp
decl_stmt|;
name|ASN1_TYPE
modifier|*
name|typ
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|ASN1_PRIMITIVE_FUNCS
modifier|*
name|pf
decl_stmt|;
name|ASN1_INTEGER
modifier|*
modifier|*
name|tint
decl_stmt|;
name|pf
operator|=
name|it
operator|->
name|funcs
expr_stmt|;
if|if
condition|(
name|pf
operator|&&
name|pf
operator|->
name|prim_c2i
condition|)
return|return
name|pf
operator|->
name|prim_c2i
argument_list|(
name|pval
argument_list|,
name|cont
argument_list|,
name|len
argument_list|,
name|utype
argument_list|,
name|free_cont
argument_list|,
name|it
argument_list|)
return|;
comment|/* If ANY type clear type and set pointer to internal value */
if|if
condition|(
name|it
operator|->
name|utype
operator|==
name|V_ASN1_ANY
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|pval
condition|)
block|{
name|typ
operator|=
name|ASN1_TYPE_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|typ
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
operator|*
name|pval
operator|=
operator|(
name|ASN1_VALUE
operator|*
operator|)
name|typ
expr_stmt|;
block|}
else|else
name|typ
operator|=
operator|(
name|ASN1_TYPE
operator|*
operator|)
operator|*
name|pval
expr_stmt|;
if|if
condition|(
name|utype
operator|!=
name|typ
operator|->
name|type
condition|)
name|ASN1_TYPE_set
argument_list|(
name|typ
argument_list|,
name|utype
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|opval
operator|=
name|pval
expr_stmt|;
name|pval
operator|=
operator|&
name|typ
operator|->
name|value
operator|.
name|asn1_value
expr_stmt|;
block|}
switch|switch
condition|(
name|utype
condition|)
block|{
case|case
name|V_ASN1_OBJECT
case|:
if|if
condition|(
operator|!
name|c2i_ASN1_OBJECT
argument_list|(
operator|(
name|ASN1_OBJECT
operator|*
operator|*
operator|)
name|pval
argument_list|,
operator|&
name|cont
argument_list|,
name|len
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|V_ASN1_NULL
case|:
if|if
condition|(
name|len
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_EX_C2I
argument_list|,
name|ASN1_R_NULL_IS_WRONG_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|*
name|pval
operator|=
operator|(
name|ASN1_VALUE
operator|*
operator|)
literal|1
expr_stmt|;
break|break;
case|case
name|V_ASN1_BOOLEAN
case|:
if|if
condition|(
name|len
operator|!=
literal|1
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_EX_C2I
argument_list|,
name|ASN1_R_BOOLEAN_IS_WRONG_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|ASN1_BOOLEAN
modifier|*
name|tbool
decl_stmt|;
name|tbool
operator|=
operator|(
name|ASN1_BOOLEAN
operator|*
operator|)
name|pval
expr_stmt|;
operator|*
name|tbool
operator|=
operator|*
name|cont
expr_stmt|;
block|}
break|break;
case|case
name|V_ASN1_BIT_STRING
case|:
if|if
condition|(
operator|!
name|c2i_ASN1_BIT_STRING
argument_list|(
operator|(
name|ASN1_BIT_STRING
operator|*
operator|*
operator|)
name|pval
argument_list|,
operator|&
name|cont
argument_list|,
name|len
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|V_ASN1_INTEGER
case|:
case|case
name|V_ASN1_ENUMERATED
case|:
name|tint
operator|=
operator|(
name|ASN1_INTEGER
operator|*
operator|*
operator|)
name|pval
expr_stmt|;
if|if
condition|(
operator|!
name|c2i_ASN1_INTEGER
argument_list|(
name|tint
argument_list|,
operator|&
name|cont
argument_list|,
name|len
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Fixup type to match the expected form */
operator|(
operator|*
name|tint
operator|)
operator|->
name|type
operator|=
name|utype
operator||
operator|(
operator|(
operator|*
name|tint
operator|)
operator|->
name|type
operator|&
name|V_ASN1_NEG
operator|)
expr_stmt|;
break|break;
case|case
name|V_ASN1_OCTET_STRING
case|:
case|case
name|V_ASN1_NUMERICSTRING
case|:
case|case
name|V_ASN1_PRINTABLESTRING
case|:
case|case
name|V_ASN1_T61STRING
case|:
case|case
name|V_ASN1_VIDEOTEXSTRING
case|:
case|case
name|V_ASN1_IA5STRING
case|:
case|case
name|V_ASN1_UTCTIME
case|:
case|case
name|V_ASN1_GENERALIZEDTIME
case|:
case|case
name|V_ASN1_GRAPHICSTRING
case|:
case|case
name|V_ASN1_VISIBLESTRING
case|:
case|case
name|V_ASN1_GENERALSTRING
case|:
case|case
name|V_ASN1_UNIVERSALSTRING
case|:
case|case
name|V_ASN1_BMPSTRING
case|:
case|case
name|V_ASN1_UTF8STRING
case|:
case|case
name|V_ASN1_OTHER
case|:
case|case
name|V_ASN1_SET
case|:
case|case
name|V_ASN1_SEQUENCE
case|:
default|default:
if|if
condition|(
name|utype
operator|==
name|V_ASN1_BMPSTRING
operator|&&
operator|(
name|len
operator|&
literal|1
operator|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_EX_C2I
argument_list|,
name|ASN1_R_BMPSTRING_IS_WRONG_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|utype
operator|==
name|V_ASN1_UNIVERSALSTRING
operator|&&
operator|(
name|len
operator|&
literal|3
operator|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_EX_C2I
argument_list|,
name|ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* All based on ASN1_STRING and handled the same */
if|if
condition|(
operator|!
operator|*
name|pval
condition|)
block|{
name|stmp
operator|=
name|ASN1_STRING_type_new
argument_list|(
name|utype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stmp
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_EX_C2I
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|*
name|pval
operator|=
operator|(
name|ASN1_VALUE
operator|*
operator|)
name|stmp
expr_stmt|;
block|}
else|else
block|{
name|stmp
operator|=
operator|(
name|ASN1_STRING
operator|*
operator|)
operator|*
name|pval
expr_stmt|;
name|stmp
operator|->
name|type
operator|=
name|utype
expr_stmt|;
block|}
comment|/* If we've already allocated a buffer use it */
if|if
condition|(
operator|*
name|free_cont
condition|)
block|{
if|if
condition|(
name|stmp
operator|->
name|data
condition|)
name|OPENSSL_free
argument_list|(
name|stmp
operator|->
name|data
argument_list|)
expr_stmt|;
name|stmp
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|cont
expr_stmt|;
comment|/* UGLY CAST! RL */
name|stmp
operator|->
name|length
operator|=
name|len
expr_stmt|;
operator|*
name|free_cont
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ASN1_STRING_set
argument_list|(
name|stmp
argument_list|,
name|cont
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_EX_C2I
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
name|ASN1_STRING_free
argument_list|(
name|stmp
argument_list|)
expr_stmt|;
operator|*
name|pval
operator|=
name|NULL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
break|break;
block|}
comment|/* If ASN1_ANY and NULL type fix up value */
if|if
condition|(
name|typ
operator|&&
operator|(
name|utype
operator|==
name|V_ASN1_NULL
operator|)
condition|)
name|typ
operator|->
name|value
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1_TYPE_free
argument_list|(
name|typ
argument_list|)
expr_stmt|;
if|if
condition|(
name|opval
condition|)
operator|*
name|opval
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * This function finds the end of an ASN1 structure when passed its maximum  * length, whether it is indefinite length and a pointer to the content. This  * is more efficient than calling asn1_collect because it does not recurse on  * each indefinite length header.  */
end_comment

begin_function
specifier|static
name|int
name|asn1_find_end
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
name|char
name|inf
parameter_list|)
block|{
name|int
name|expected_eoc
decl_stmt|;
name|long
name|plen
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|*
name|in
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* If not indefinite length constructed just add length */
if|if
condition|(
name|inf
operator|==
literal|0
condition|)
block|{
operator|*
name|in
operator|+=
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
name|expected_eoc
operator|=
literal|1
expr_stmt|;
comment|/*      * Indefinite length constructed form. Find the end when enough EOCs are      * found. If more indefinite length constructed headers are encountered      * increment the expected eoc count otherwise just skip to the end of the      * data.      */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|asn1_check_eoc
argument_list|(
operator|&
name|p
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|expected_eoc
operator|--
expr_stmt|;
if|if
condition|(
name|expected_eoc
operator|==
literal|0
condition|)
break|break;
name|len
operator|-=
literal|2
expr_stmt|;
continue|continue;
block|}
name|q
operator|=
name|p
expr_stmt|;
comment|/* Just read in a header: only care about the length */
if|if
condition|(
operator|!
name|asn1_check_tlen
argument_list|(
operator|&
name|plen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|inf
argument_list|,
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_FIND_END
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|inf
condition|)
name|expected_eoc
operator|++
expr_stmt|;
else|else
name|p
operator|+=
name|plen
expr_stmt|;
name|len
operator|-=
name|p
operator|-
name|q
expr_stmt|;
block|}
if|if
condition|(
name|expected_eoc
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_FIND_END
argument_list|,
name|ASN1_R_MISSING_EOC
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|in
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * This function collects the asn1 data from a constructred string type into  * a buffer. The values of 'in' and 'len' should refer to the contents of the  * constructed type and 'inf' should be set if it is indefinite length.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASN1_MAX_STRING_NEST
end_ifndef

begin_comment
comment|/*  * This determines how many levels of recursion are permitted in ASN1 string  * types. If it is not limited stack overflows can occur. If set to zero no  * recursion is allowed at all. Although zero should be adequate examples  * exist that require a value of 1. So 5 should be more than enough.  */
end_comment

begin_define
define|#
directive|define
name|ASN1_MAX_STRING_NEST
value|5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|asn1_collect
parameter_list|(
name|BUF_MEM
modifier|*
name|buf
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
name|char
name|inf
parameter_list|,
name|int
name|tag
parameter_list|,
name|int
name|aclass
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|long
name|plen
decl_stmt|;
name|char
name|cst
decl_stmt|,
name|ininf
decl_stmt|;
name|p
operator|=
operator|*
name|in
expr_stmt|;
name|inf
operator|&=
literal|1
expr_stmt|;
comment|/*      * If no buffer and not indefinite length constructed just pass over the      * encoded data      */
if|if
condition|(
operator|!
name|buf
operator|&&
operator|!
name|inf
condition|)
block|{
operator|*
name|in
operator|+=
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
comment|/* Check for EOC */
if|if
condition|(
name|asn1_check_eoc
argument_list|(
operator|&
name|p
argument_list|,
name|len
argument_list|)
condition|)
block|{
comment|/*              * EOC is illegal outside indefinite length constructed form              */
if|if
condition|(
operator|!
name|inf
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_COLLECT
argument_list|,
name|ASN1_R_UNEXPECTED_EOC
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|inf
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|asn1_check_tlen
argument_list|(
operator|&
name|plen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ininf
argument_list|,
operator|&
name|cst
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|tag
argument_list|,
name|aclass
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_COLLECT
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If indefinite length constructed update max length */
if|if
condition|(
name|cst
condition|)
block|{
if|if
condition|(
name|depth
operator|>=
name|ASN1_MAX_STRING_NEST
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_COLLECT
argument_list|,
name|ASN1_R_NESTED_ASN1_STRING
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|asn1_collect
argument_list|(
name|buf
argument_list|,
operator|&
name|p
argument_list|,
name|plen
argument_list|,
name|ininf
argument_list|,
name|tag
argument_list|,
name|aclass
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|plen
operator|&&
operator|!
name|collect_data
argument_list|(
name|buf
argument_list|,
operator|&
name|p
argument_list|,
name|plen
argument_list|)
condition|)
return|return
literal|0
return|;
name|len
operator|-=
name|p
operator|-
name|q
expr_stmt|;
block|}
if|if
condition|(
name|inf
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_COLLECT
argument_list|,
name|ASN1_R_MISSING_EOC
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|in
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|collect_data
parameter_list|(
name|BUF_MEM
modifier|*
name|buf
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|long
name|plen
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
name|len
operator|=
name|buf
operator|->
name|length
expr_stmt|;
if|if
condition|(
operator|!
name|BUF_MEM_grow_clean
argument_list|(
name|buf
argument_list|,
name|len
operator|+
name|plen
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_COLLECT_DATA
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|buf
operator|->
name|data
operator|+
name|len
argument_list|,
operator|*
name|p
argument_list|,
name|plen
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|+=
name|plen
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check for ASN1 EOC and swallow it if found */
end_comment

begin_function
specifier|static
name|int
name|asn1_check_eoc
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|p
operator|=
operator|*
name|in
expr_stmt|;
if|if
condition|(
operator|!
name|p
index|[
literal|0
index|]
operator|&&
operator|!
name|p
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|in
operator|+=
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Check an ASN1 tag and length: a bit like ASN1_get_object but it sets the  * length for indefinite length constructed form, we don't know the exact  * length but we can set an upper bound to the amount of data available minus  * the header length just read.  */
end_comment

begin_function
specifier|static
name|int
name|asn1_check_tlen
parameter_list|(
name|long
modifier|*
name|olen
parameter_list|,
name|int
modifier|*
name|otag
parameter_list|,
name|unsigned
name|char
modifier|*
name|oclass
parameter_list|,
name|char
modifier|*
name|inf
parameter_list|,
name|char
modifier|*
name|cst
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
name|int
name|exptag
parameter_list|,
name|int
name|expclass
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ptag
decl_stmt|,
name|pclass
decl_stmt|;
name|long
name|plen
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
operator|*
name|in
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|ctx
operator|&&
name|ctx
operator|->
name|valid
condition|)
block|{
name|i
operator|=
name|ctx
operator|->
name|ret
expr_stmt|;
name|plen
operator|=
name|ctx
operator|->
name|plen
expr_stmt|;
name|pclass
operator|=
name|ctx
operator|->
name|pclass
expr_stmt|;
name|ptag
operator|=
name|ctx
operator|->
name|ptag
expr_stmt|;
name|p
operator|+=
name|ctx
operator|->
name|hdrlen
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|ASN1_get_object
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|plen
argument_list|,
operator|&
name|ptag
argument_list|,
operator|&
name|pclass
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
condition|)
block|{
name|ctx
operator|->
name|ret
operator|=
name|i
expr_stmt|;
name|ctx
operator|->
name|plen
operator|=
name|plen
expr_stmt|;
name|ctx
operator|->
name|pclass
operator|=
name|pclass
expr_stmt|;
name|ctx
operator|->
name|ptag
operator|=
name|ptag
expr_stmt|;
name|ctx
operator|->
name|hdrlen
operator|=
name|p
operator|-
name|q
expr_stmt|;
name|ctx
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
comment|/*              * If definite length, and no error, length + header can't exceed              * total amount of data available.              */
if|if
condition|(
operator|!
operator|(
name|i
operator|&
literal|0x81
operator|)
operator|&&
operator|(
operator|(
name|plen
operator|+
name|ctx
operator|->
name|hdrlen
operator|)
operator|>
name|len
operator|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_CHECK_TLEN
argument_list|,
name|ASN1_R_TOO_LONG
argument_list|)
expr_stmt|;
name|asn1_tlc_clear
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|&
literal|0x80
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_CHECK_TLEN
argument_list|,
name|ASN1_R_BAD_OBJECT_HEADER
argument_list|)
expr_stmt|;
name|asn1_tlc_clear
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|exptag
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|exptag
operator|!=
name|ptag
operator|)
operator|||
operator|(
name|expclass
operator|!=
name|pclass
operator|)
condition|)
block|{
comment|/*              * If type is OPTIONAL, not an error: indicate missing type.              */
if|if
condition|(
name|opt
condition|)
return|return
operator|-
literal|1
return|;
name|asn1_tlc_clear
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_CHECK_TLEN
argument_list|,
name|ASN1_R_WRONG_TAG
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*          * We have a tag and class match: assume we are going to do something          * with it          */
name|asn1_tlc_clear
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|plen
operator|=
name|len
operator|-
operator|(
name|p
operator|-
name|q
operator|)
expr_stmt|;
if|if
condition|(
name|inf
condition|)
operator|*
name|inf
operator|=
name|i
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|cst
condition|)
operator|*
name|cst
operator|=
name|i
operator|&
name|V_ASN1_CONSTRUCTED
expr_stmt|;
if|if
condition|(
name|olen
condition|)
operator|*
name|olen
operator|=
name|plen
expr_stmt|;
if|if
condition|(
name|oclass
condition|)
operator|*
name|oclass
operator|=
name|pclass
expr_stmt|;
if|if
condition|(
name|otag
condition|)
operator|*
name|otag
operator|=
name|ptag
expr_stmt|;
operator|*
name|in
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

