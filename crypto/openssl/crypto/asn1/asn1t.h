begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* asn1t.h */
end_comment

begin_comment
comment|/* Written by Dr Stephen N Henson (shenson@bigfoot.com) for the OpenSSL  * project 2000.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HEADER_ASN1T_H
end_ifndef

begin_define
define|#
directive|define
name|HEADER_ASN1T_H
end_define

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<openssl/e_os2.h>
end_include

begin_include
include|#
directive|include
file|<openssl/asn1.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_BUILD_SHLIBCRYPTO
end_ifdef

begin_undef
undef|#
directive|undef
name|OPENSSL_EXTERN
end_undef

begin_define
define|#
directive|define
name|OPENSSL_EXTERN
value|OPENSSL_EXPORT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ASN1 template defines, structures and functions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_EXPORT_VAR_AS_FUNCTION
comment|/* Macro to obtain ASN1_ADB pointer from a type (only used internally) */
define|#
directive|define
name|ASN1_ADB_ptr
parameter_list|(
name|iptr
parameter_list|)
value|((const ASN1_ADB *)(iptr))
comment|/* Macros for start and end of ASN1_ITEM definition */
define|#
directive|define
name|ASN1_ITEM_start
parameter_list|(
name|itname
parameter_list|)
define|\
value|OPENSSL_GLOBAL const ASN1_ITEM itname##_it = {
define|#
directive|define
name|ASN1_ITEM_end
parameter_list|(
name|itname
parameter_list|)
define|\
value|};
else|#
directive|else
comment|/* Macro to obtain ASN1_ADB pointer from a type (only used internally) */
define|#
directive|define
name|ASN1_ADB_ptr
parameter_list|(
name|iptr
parameter_list|)
value|((const ASN1_ADB *)(iptr()))
comment|/* Macros for start and end of ASN1_ITEM definition */
define|#
directive|define
name|ASN1_ITEM_start
parameter_list|(
name|itname
parameter_list|)
define|\
value|const ASN1_ITEM * itname##_it(void) \ 	{ \ 		static const ASN1_ITEM local_it = {
define|#
directive|define
name|ASN1_ITEM_end
parameter_list|(
name|itname
parameter_list|)
define|\
value|}; \ 	return&local_it; \ 	}
endif|#
directive|endif
comment|/* Macros to aid ASN1 template writing */
define|#
directive|define
name|ASN1_ITEM_TEMPLATE
parameter_list|(
name|tname
parameter_list|)
define|\
value|static const ASN1_TEMPLATE tname##_item_tt
define|#
directive|define
name|ASN1_ITEM_TEMPLATE_END
parameter_list|(
name|tname
parameter_list|)
define|\
value|;\ 	ASN1_ITEM_start(tname) \ 		ASN1_ITYPE_PRIMITIVE,\ 		-1,\&tname##_item_tt,\ 		0,\ 		NULL,\ 		0,\ 		#tname \ 	ASN1_ITEM_end(tname)
comment|/* This is a ASN1 type which just embeds a template */
comment|/* This pair helps declare a SEQUENCE. We can do:  *  * 	ASN1_SEQUENCE(stname) = {  * 		... SEQUENCE components ...  * 	} ASN1_SEQUENCE_END(stname)  *  * 	This will produce an ASN1_ITEM called stname_it  *	for a structure called stname.  *  * 	If you want the same structure but a different  *	name then use:  *  * 	ASN1_SEQUENCE(itname) = {  * 		... SEQUENCE components ...  * 	} ASN1_SEQUENCE_END_name(stname, itname)  *  *	This will create an item called itname_it using  *	a structure called stname.  */
define|#
directive|define
name|ASN1_SEQUENCE
parameter_list|(
name|tname
parameter_list|)
define|\
value|static const ASN1_TEMPLATE tname##_seq_tt[]
define|#
directive|define
name|ASN1_SEQUENCE_END
parameter_list|(
name|stname
parameter_list|)
value|ASN1_SEQUENCE_END_name(stname, stname)
define|#
directive|define
name|ASN1_SEQUENCE_END_name
parameter_list|(
name|stname
parameter_list|,
name|tname
parameter_list|)
define|\
value|;\ 	ASN1_ITEM_start(tname) \ 		ASN1_ITYPE_SEQUENCE,\ 		V_ASN1_SEQUENCE,\ 		tname##_seq_tt,\ 		sizeof(tname##_seq_tt) / sizeof(ASN1_TEMPLATE),\ 		NULL,\ 		sizeof(stname),\ 		#stname \ 	ASN1_ITEM_end(tname)
define|#
directive|define
name|ASN1_NDEF_SEQUENCE
parameter_list|(
name|tname
parameter_list|)
define|\
value|ASN1_SEQUENCE(tname)
define|#
directive|define
name|ASN1_SEQUENCE_cb
parameter_list|(
name|tname
parameter_list|,
name|cb
parameter_list|)
define|\
value|static const ASN1_AUX tname##_aux = {NULL, 0, 0, 0, cb, 0}; \ 	ASN1_SEQUENCE(tname)
define|#
directive|define
name|ASN1_BROKEN_SEQUENCE
parameter_list|(
name|tname
parameter_list|)
define|\
value|static const ASN1_AUX tname##_aux = {NULL, ASN1_AFLG_BROKEN, 0, 0, 0, 0}; \ 	ASN1_SEQUENCE(tname)
define|#
directive|define
name|ASN1_SEQUENCE_ref
parameter_list|(
name|tname
parameter_list|,
name|cb
parameter_list|,
name|lck
parameter_list|)
define|\
value|static const ASN1_AUX tname##_aux = {NULL, ASN1_AFLG_REFCOUNT, offsetof(tname, references), lck, cb, 0}; \ 	ASN1_SEQUENCE(tname)
define|#
directive|define
name|ASN1_SEQUENCE_enc
parameter_list|(
name|tname
parameter_list|,
name|enc
parameter_list|,
name|cb
parameter_list|)
define|\
value|static const ASN1_AUX tname##_aux = {NULL, ASN1_AFLG_ENCODING, 0, 0, cb, offsetof(tname, enc)}; \ 	ASN1_SEQUENCE(tname)
define|#
directive|define
name|ASN1_NDEF_SEQUENCE_END
parameter_list|(
name|tname
parameter_list|)
define|\
value|;\ 	ASN1_ITEM_start(tname) \ 		ASN1_ITYPE_NDEF_SEQUENCE,\ 		V_ASN1_SEQUENCE,\ 		tname##_seq_tt,\ 		sizeof(tname##_seq_tt) / sizeof(ASN1_TEMPLATE),\ 		NULL,\ 		sizeof(tname),\ 		#tname \ 	ASN1_ITEM_end(tname)
define|#
directive|define
name|ASN1_BROKEN_SEQUENCE_END
parameter_list|(
name|stname
parameter_list|)
value|ASN1_SEQUENCE_END_ref(stname, stname)
define|#
directive|define
name|ASN1_SEQUENCE_END_enc
parameter_list|(
name|stname
parameter_list|,
name|tname
parameter_list|)
value|ASN1_SEQUENCE_END_ref(stname, tname)
define|#
directive|define
name|ASN1_SEQUENCE_END_cb
parameter_list|(
name|stname
parameter_list|,
name|tname
parameter_list|)
value|ASN1_SEQUENCE_END_ref(stname, tname)
define|#
directive|define
name|ASN1_SEQUENCE_END_ref
parameter_list|(
name|stname
parameter_list|,
name|tname
parameter_list|)
define|\
value|;\ 	ASN1_ITEM_start(tname) \ 		ASN1_ITYPE_SEQUENCE,\ 		V_ASN1_SEQUENCE,\ 		tname##_seq_tt,\ 		sizeof(tname##_seq_tt) / sizeof(ASN1_TEMPLATE),\&tname##_aux,\ 		sizeof(stname),\ 		#stname \ 	ASN1_ITEM_end(tname)
comment|/* This pair helps declare a CHOICE type. We can do:  *  * 	ASN1_CHOICE(chname) = {  * 		... CHOICE options ...  * 	ASN1_CHOICE_END(chname)  *  * 	This will produce an ASN1_ITEM called chname_it  *	for a structure called chname. The structure  *	definition must look like this:  *	typedef struct {  *		int type;  *		union {  *			ASN1_SOMETHING *opt1;  *			ASN1_SOMEOTHER *opt2;  *		} value;  *	} chname;  *	  *	the name of the selector must be 'type'.  * 	to use an alternative selector name use the  *      ASN1_CHOICE_END_selector() version.  */
define|#
directive|define
name|ASN1_CHOICE
parameter_list|(
name|tname
parameter_list|)
define|\
value|static const ASN1_TEMPLATE tname##_ch_tt[]
define|#
directive|define
name|ASN1_CHOICE_cb
parameter_list|(
name|tname
parameter_list|,
name|cb
parameter_list|)
define|\
value|static const ASN1_AUX tname##_aux = {NULL, 0, 0, 0, cb, 0}; \ 	ASN1_CHOICE(tname)
define|#
directive|define
name|ASN1_CHOICE_END
parameter_list|(
name|stname
parameter_list|)
value|ASN1_CHOICE_END_name(stname, stname)
define|#
directive|define
name|ASN1_CHOICE_END_name
parameter_list|(
name|stname
parameter_list|,
name|tname
parameter_list|)
value|ASN1_CHOICE_END_selector(stname, tname, type)
define|#
directive|define
name|ASN1_CHOICE_END_selector
parameter_list|(
name|stname
parameter_list|,
name|tname
parameter_list|,
name|selname
parameter_list|)
define|\
value|;\ 	ASN1_ITEM_start(tname) \ 		ASN1_ITYPE_CHOICE,\ 		offsetof(stname,selname) ,\ 		tname##_ch_tt,\ 		sizeof(tname##_ch_tt) / sizeof(ASN1_TEMPLATE),\ 		NULL,\ 		sizeof(stname),\ 		#stname \ 	ASN1_ITEM_end(tname)
define|#
directive|define
name|ASN1_CHOICE_END_cb
parameter_list|(
name|stname
parameter_list|,
name|tname
parameter_list|,
name|selname
parameter_list|)
define|\
value|;\ 	ASN1_ITEM_start(tname) \ 		ASN1_ITYPE_CHOICE,\ 		offsetof(stname,selname) ,\ 		tname##_ch_tt,\ 		sizeof(tname##_ch_tt) / sizeof(ASN1_TEMPLATE),\&tname##_aux,\ 		sizeof(stname),\ 		#stname \ 	ASN1_ITEM_end(tname)
comment|/* This helps with the template wrapper form of ASN1_ITEM */
define|#
directive|define
name|ASN1_EX_TEMPLATE_TYPE
parameter_list|(
name|flags
parameter_list|,
name|tag
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
value|{ \ 	(flags), (tag), 0,\ 	#name, ASN1_ITEM_ref(type) }
comment|/* These help with SEQUENCE or CHOICE components */
comment|/* used to declare other types */
define|#
directive|define
name|ASN1_EX_TYPE
parameter_list|(
name|flags
parameter_list|,
name|tag
parameter_list|,
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|)
value|{ \ 	(flags), (tag), offsetof(stname, field),\ 	#field, ASN1_ITEM_ref(type) }
comment|/* used when the structure is combined with the parent */
define|#
directive|define
name|ASN1_EX_COMBINE
parameter_list|(
name|flags
parameter_list|,
name|tag
parameter_list|,
name|type
parameter_list|)
value|{ \ 	(flags)|ASN1_TFLG_COMBINE, (tag), 0, NULL, ASN1_ITEM_ref(type) }
comment|/* implicit and explicit helper macros */
define|#
directive|define
name|ASN1_IMP_EX
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|,
name|ex
parameter_list|)
define|\
value|ASN1_EX_TYPE(ASN1_TFLG_IMPLICIT | ex, tag, stname, field, type)
define|#
directive|define
name|ASN1_EXP_EX
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|,
name|ex
parameter_list|)
define|\
value|ASN1_EX_TYPE(ASN1_TFLG_EXPLICIT | ex, tag, stname, field, type)
comment|/* Any defined by macros: the field used is in the table itself */
ifndef|#
directive|ifndef
name|OPENSSL_EXPORT_VAR_AS_FUNCTION
define|#
directive|define
name|ASN1_ADB_OBJECT
parameter_list|(
name|tblname
parameter_list|)
value|{ ASN1_TFLG_ADB_OID, -1, 0, #tblname, (const ASN1_ITEM *)&(tblname##_adb) }
define|#
directive|define
name|ASN1_ADB_INTEGER
parameter_list|(
name|tblname
parameter_list|)
value|{ ASN1_TFLG_ADB_INT, -1, 0, #tblname, (const ASN1_ITEM *)&(tblname##_adb) }
else|#
directive|else
define|#
directive|define
name|ASN1_ADB_OBJECT
parameter_list|(
name|tblname
parameter_list|)
value|{ ASN1_TFLG_ADB_OID, -1, 0, #tblname, tblname##_adb }
define|#
directive|define
name|ASN1_ADB_INTEGER
parameter_list|(
name|tblname
parameter_list|)
value|{ ASN1_TFLG_ADB_INT, -1, 0, #tblname, tblname##_adb }
endif|#
directive|endif
comment|/* Plain simple type */
define|#
directive|define
name|ASN1_SIMPLE
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|)
value|ASN1_EX_TYPE(0,0, stname, field, type)
comment|/* OPTIONAL simple type */
define|#
directive|define
name|ASN1_OPT
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|)
value|ASN1_EX_TYPE(ASN1_TFLG_OPTIONAL, 0, stname, field, type)
comment|/* IMPLICIT tagged simple type */
define|#
directive|define
name|ASN1_IMP
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|)
value|ASN1_IMP_EX(stname, field, type, tag, 0)
comment|/* IMPLICIT tagged OPTIONAL simple type */
define|#
directive|define
name|ASN1_IMP_OPT
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|)
value|ASN1_IMP_EX(stname, field, type, tag, ASN1_TFLG_OPTIONAL)
comment|/* Same as above but EXPLICIT */
define|#
directive|define
name|ASN1_EXP
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|)
value|ASN1_EXP_EX(stname, field, type, tag, 0)
define|#
directive|define
name|ASN1_EXP_OPT
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|)
value|ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_OPTIONAL)
comment|/* SEQUENCE OF type */
define|#
directive|define
name|ASN1_SEQUENCE_OF
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|)
define|\
value|ASN1_EX_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, stname, field, type)
comment|/* OPTIONAL SEQUENCE OF */
define|#
directive|define
name|ASN1_SEQUENCE_OF_OPT
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|)
define|\
value|ASN1_EX_TYPE(ASN1_TFLG_SEQUENCE_OF|ASN1_TFLG_OPTIONAL, 0, stname, field, type)
comment|/* Same as above but for SET OF */
define|#
directive|define
name|ASN1_SET_OF
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|)
define|\
value|ASN1_EX_TYPE(ASN1_TFLG_SET_OF, 0, stname, field, type)
define|#
directive|define
name|ASN1_SET_OF_OPT
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|)
define|\
value|ASN1_EX_TYPE(ASN1_TFLG_SET_OF|ASN1_TFLG_OPTIONAL, 0, stname, field, type)
comment|/* Finally compound types of SEQUENCE, SET, IMPLICIT, EXPLICIT and OPTIONAL */
define|#
directive|define
name|ASN1_IMP_SET_OF
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|)
define|\
value|ASN1_IMP_EX(stname, field, type, tag, ASN1_TFLG_SET_OF)
define|#
directive|define
name|ASN1_EXP_SET_OF
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|)
define|\
value|ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_SET_OF)
define|#
directive|define
name|ASN1_IMP_SET_OF_OPT
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|)
define|\
value|ASN1_IMP_EX(stname, field, type, tag, ASN1_TFLG_SET_OF|ASN1_TFLG_OPTIONAL)
define|#
directive|define
name|ASN1_EXP_SET_OF_OPT
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|)
define|\
value|ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_SET_OF|ASN1_TFLG_OPTIONAL)
define|#
directive|define
name|ASN1_IMP_SEQUENCE_OF
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|)
define|\
value|ASN1_IMP_EX(stname, field, type, tag, ASN1_TFLG_SEQUENCE_OF)
define|#
directive|define
name|ASN1_IMP_SEQUENCE_OF_OPT
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|)
define|\
value|ASN1_IMP_EX(stname, field, type, tag, ASN1_TFLG_SEQUENCE_OF|ASN1_TFLG_OPTIONAL)
define|#
directive|define
name|ASN1_EXP_SEQUENCE_OF
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|)
define|\
value|ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_SEQUENCE_OF)
define|#
directive|define
name|ASN1_EXP_SEQUENCE_OF_OPT
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|)
define|\
value|ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_SEQUENCE_OF|ASN1_TFLG_OPTIONAL)
comment|/* EXPLICIT OPTIONAL using indefinite length constructed form */
define|#
directive|define
name|ASN1_NDEF_EXP_OPT
parameter_list|(
name|stname
parameter_list|,
name|field
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|)
define|\
value|ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_OPTIONAL|ASN1_TFLG_NDEF)
comment|/* Macros for the ASN1_ADB structure */
define|#
directive|define
name|ASN1_ADB
parameter_list|(
name|name
parameter_list|)
define|\
value|static const ASN1_ADB_TABLE name##_adbtbl[]
ifndef|#
directive|ifndef
name|OPENSSL_EXPORT_VAR_AS_FUNCTION
define|#
directive|define
name|ASN1_ADB_END
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|,
name|field
parameter_list|,
name|app_table
parameter_list|,
name|def
parameter_list|,
name|none
parameter_list|)
define|\
value|;\ 	static const ASN1_ADB name##_adb = {\ 		flags,\ 		offsetof(name, field),\ 		app_table,\ 		name##_adbtbl,\ 		sizeof(name##_adbtbl) / sizeof(ASN1_ADB_TABLE),\ 		def,\ 		none\ 	}
else|#
directive|else
define|#
directive|define
name|ASN1_ADB_END
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|,
name|field
parameter_list|,
name|app_table
parameter_list|,
name|def
parameter_list|,
name|none
parameter_list|)
define|\
value|;\ 	static const ASN1_ITEM *name##_adb(void) \ 	{ \ 	static const ASN1_ADB internal_adb = \ 		{\ 		flags,\ 		offsetof(name, field),\ 		app_table,\ 		name##_adbtbl,\ 		sizeof(name##_adbtbl) / sizeof(ASN1_ADB_TABLE),\ 		def,\ 		none\ 		}; \ 		return (const ASN1_ITEM *)&internal_adb; \ 	} \ 	void dummy_function(void)
endif|#
directive|endif
define|#
directive|define
name|ADB_ENTRY
parameter_list|(
name|val
parameter_list|,
name|template
parameter_list|)
value|{val, template}
define|#
directive|define
name|ASN1_ADB_TEMPLATE
parameter_list|(
name|name
parameter_list|)
define|\
value|static const ASN1_TEMPLATE name##_tt
comment|/* This is the ASN1 template structure that defines  * a wrapper round the actual type. It determines the  * actual position of the field in the value structure,  * various flags such as OPTIONAL and the field name.  */
struct|struct
name|ASN1_TEMPLATE_st
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
comment|/* Various flags */
name|long
name|tag
decl_stmt|;
comment|/* tag, not used if no tagging */
name|unsigned
name|long
name|offset
decl_stmt|;
comment|/* Offset of this field in structure */
ifndef|#
directive|ifndef
name|NO_ASN1_FIELD_NAMES
specifier|const
name|char
modifier|*
name|field_name
decl_stmt|;
comment|/* Field name */
endif|#
directive|endif
name|ASN1_ITEM_EXP
modifier|*
name|item
decl_stmt|;
comment|/* Relevant ASN1_ITEM or ASN1_ADB */
block|}
struct|;
comment|/* Macro to extract ASN1_ITEM and ASN1_ADB pointer from ASN1_TEMPLATE */
define|#
directive|define
name|ASN1_TEMPLATE_item
parameter_list|(
name|t
parameter_list|)
value|(t->item_ptr)
define|#
directive|define
name|ASN1_TEMPLATE_adb
parameter_list|(
name|t
parameter_list|)
value|(t->item_ptr)
typedef|typedef
name|struct
name|ASN1_ADB_TABLE_st
name|ASN1_ADB_TABLE
typedef|;
typedef|typedef
name|struct
name|ASN1_ADB_st
name|ASN1_ADB
typedef|;
struct|struct
name|ASN1_ADB_st
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
comment|/* Various flags */
name|unsigned
name|long
name|offset
decl_stmt|;
comment|/* Offset of selector field */
name|STACK_OF
argument_list|(
name|ASN1_ADB_TABLE
argument_list|)
operator|*
operator|*
name|app_items
expr_stmt|;
comment|/* Application defined items */
specifier|const
name|ASN1_ADB_TABLE
modifier|*
name|tbl
decl_stmt|;
comment|/* Table of possible types */
name|long
name|tblcount
decl_stmt|;
comment|/* Number of entries in tbl */
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|default_tt
decl_stmt|;
comment|/* Type to use if no match */
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|null_tt
decl_stmt|;
comment|/* Type to use if selector is NULL */
block|}
struct|;
struct|struct
name|ASN1_ADB_TABLE_st
block|{
name|long
name|value
decl_stmt|;
comment|/* NID for an object or value for an int */
specifier|const
name|ASN1_TEMPLATE
name|tt
decl_stmt|;
comment|/* item for this value */
block|}
struct|;
comment|/* template flags */
comment|/* Field is optional */
define|#
directive|define
name|ASN1_TFLG_OPTIONAL
value|(0x1)
comment|/* Field is a SET OF */
define|#
directive|define
name|ASN1_TFLG_SET_OF
value|(0x1<< 1)
comment|/* Field is a SEQUENCE OF */
define|#
directive|define
name|ASN1_TFLG_SEQUENCE_OF
value|(0x2<< 1)
comment|/* Special case: this refers to a SET OF that  * will be sorted into DER order when encoded *and*  * the corresponding STACK will be modified to match  * the new order.  */
define|#
directive|define
name|ASN1_TFLG_SET_ORDER
value|(0x3<< 1)
comment|/* Mask for SET OF or SEQUENCE OF */
define|#
directive|define
name|ASN1_TFLG_SK_MASK
value|(0x3<< 1)
comment|/* These flags mean the tag should be taken from the  * tag field. If EXPLICIT then the underlying type  * is used for the inner tag.  */
comment|/* IMPLICIT tagging */
define|#
directive|define
name|ASN1_TFLG_IMPTAG
value|(0x1<< 3)
comment|/* EXPLICIT tagging, inner tag from underlying type */
define|#
directive|define
name|ASN1_TFLG_EXPTAG
value|(0x2<< 3)
define|#
directive|define
name|ASN1_TFLG_TAG_MASK
value|(0x3<< 3)
comment|/* context specific IMPLICIT */
define|#
directive|define
name|ASN1_TFLG_IMPLICIT
value|ASN1_TFLG_IMPTAG|ASN1_TFLG_CONTEXT
comment|/* context specific EXPLICIT */
define|#
directive|define
name|ASN1_TFLG_EXPLICIT
value|ASN1_TFLG_EXPTAG|ASN1_TFLG_CONTEXT
comment|/* If tagging is in force these determine the  * type of tag to use. Otherwise the tag is  * determined by the underlying type. These   * values reflect the actual octet format.  */
comment|/* Universal tag */
define|#
directive|define
name|ASN1_TFLG_UNIVERSAL
value|(0x0<<6)
comment|/* Application tag */
define|#
directive|define
name|ASN1_TFLG_APPLICATION
value|(0x1<<6)
comment|/* Context specific tag */
define|#
directive|define
name|ASN1_TFLG_CONTEXT
value|(0x2<<6)
comment|/* Private tag */
define|#
directive|define
name|ASN1_TFLG_PRIVATE
value|(0x3<<6)
define|#
directive|define
name|ASN1_TFLG_TAG_CLASS
value|(0x3<<6)
comment|/* These are for ANY DEFINED BY type. In this case  * the 'item' field points to an ASN1_ADB structure  * which contains a table of values to decode the  * relevant type  */
define|#
directive|define
name|ASN1_TFLG_ADB_MASK
value|(0x3<<8)
define|#
directive|define
name|ASN1_TFLG_ADB_OID
value|(0x1<<8)
define|#
directive|define
name|ASN1_TFLG_ADB_INT
value|(0x1<<9)
comment|/* This flag means a parent structure is passed  * instead of the field: this is useful is a  * SEQUENCE is being combined with a CHOICE for  * example. Since this means the structure and  * item name will differ we need to use the  * ASN1_CHOICE_END_name() macro for example.  */
define|#
directive|define
name|ASN1_TFLG_COMBINE
value|(0x1<<10)
comment|/* This flag when present in a SEQUENCE OF, SET OF  * or EXPLICIT causes indefinite length constructed  * encoding to be used if required.  */
define|#
directive|define
name|ASN1_TFLG_NDEF
value|(0x1<<11)
comment|/* This is the actual ASN1 item itself */
struct|struct
name|ASN1_ITEM_st
block|{
name|char
name|itype
decl_stmt|;
comment|/* The item type, primitive, SEQUENCE, CHOICE or extern */
name|long
name|utype
decl_stmt|;
comment|/* underlying type */
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|templates
decl_stmt|;
comment|/* If SEQUENCE or CHOICE this contains the contents */
name|long
name|tcount
decl_stmt|;
comment|/* Number of templates if SEQUENCE or CHOICE */
specifier|const
name|void
modifier|*
name|funcs
decl_stmt|;
comment|/* functions that handle this type */
name|long
name|size
decl_stmt|;
comment|/* Structure size (usually)*/
ifndef|#
directive|ifndef
name|NO_ASN1_FIELD_NAMES
specifier|const
name|char
modifier|*
name|sname
decl_stmt|;
comment|/* Structure name */
endif|#
directive|endif
block|}
struct|;
comment|/* These are values for the itype field and  * determine how the type is interpreted.  *  * For PRIMITIVE types the underlying type  * determines the behaviour if items is NULL.  *  * Otherwise templates must contain a single   * template and the type is treated in the  * same way as the type specified in the template.  *  * For SEQUENCE types the templates field points  * to the members, the size field is the  * structure size.  *  * For CHOICE types the templates field points  * to each possible member (typically a union)  * and the 'size' field is the offset of the  * selector.  *  * The 'funcs' field is used for application  * specific functions.   *  * For COMPAT types the funcs field gives a  * set of functions that handle this type, this  * supports the old d2i, i2d convention.  *  * The EXTERN type uses a new style d2i/i2d.  * The new style should be used where possible  * because it avoids things like the d2i IMPLICIT  * hack.  *  * MSTRING is a multiple string type, it is used  * for a CHOICE of character strings where the  * actual strings all occupy an ASN1_STRING  * structure. In this case the 'utype' field  * has a special meaning, it is used as a mask  * of acceptable types using the B_ASN1 constants.  *  * NDEF_SEQUENCE is the same as SEQUENCE except  * that it will use indefinite length constructed  * encoding if requested.  *  */
define|#
directive|define
name|ASN1_ITYPE_PRIMITIVE
value|0x0
define|#
directive|define
name|ASN1_ITYPE_SEQUENCE
value|0x1
define|#
directive|define
name|ASN1_ITYPE_CHOICE
value|0x2
define|#
directive|define
name|ASN1_ITYPE_COMPAT
value|0x3
define|#
directive|define
name|ASN1_ITYPE_EXTERN
value|0x4
define|#
directive|define
name|ASN1_ITYPE_MSTRING
value|0x5
define|#
directive|define
name|ASN1_ITYPE_NDEF_SEQUENCE
value|0x6
comment|/* Cache for ASN1 tag and length, so we  * don't keep re-reading it for things  * like CHOICE  */
struct|struct
name|ASN1_TLC_st
block|{
name|char
name|valid
decl_stmt|;
comment|/* Values below are valid */
name|int
name|ret
decl_stmt|;
comment|/* return value */
name|long
name|plen
decl_stmt|;
comment|/* length */
name|int
name|ptag
decl_stmt|;
comment|/* class value */
name|int
name|pclass
decl_stmt|;
comment|/* class value */
name|int
name|hdrlen
decl_stmt|;
comment|/* header length */
block|}
struct|;
comment|/* Typedefs for ASN1 function pointers */
typedef|typedef
name|ASN1_VALUE
modifier|*
name|ASN1_new_func
parameter_list|(
name|void
parameter_list|)
function_decl|;
typedef|typedef
name|void
name|ASN1_free_func
parameter_list|(
name|ASN1_VALUE
modifier|*
name|a
parameter_list|)
function_decl|;
typedef|typedef
name|ASN1_VALUE
modifier|*
name|ASN1_d2i_func
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|a
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|length
parameter_list|)
function_decl|;
typedef|typedef
name|int
name|ASN1_i2d_func
parameter_list|(
name|ASN1_VALUE
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|)
function_decl|;
typedef|typedef
name|int
name|ASN1_ex_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|,
name|int
name|tag
parameter_list|,
name|int
name|aclass
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
function_decl|;
typedef|typedef
name|int
name|ASN1_ex_i2d
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|,
name|int
name|tag
parameter_list|,
name|int
name|aclass
parameter_list|)
function_decl|;
typedef|typedef
name|int
name|ASN1_ex_new_func
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
typedef|typedef
name|void
name|ASN1_ex_free_func
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
typedef|typedef
name|int
name|ASN1_primitive_i2c
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
name|unsigned
name|char
modifier|*
name|cont
parameter_list|,
name|int
modifier|*
name|putype
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
typedef|typedef
name|int
name|ASN1_primitive_c2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|cont
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|utype
parameter_list|,
name|char
modifier|*
name|free_cont
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|ASN1_COMPAT_FUNCS_st
block|{
name|ASN1_new_func
modifier|*
name|asn1_new
decl_stmt|;
name|ASN1_free_func
modifier|*
name|asn1_free
decl_stmt|;
name|ASN1_d2i_func
modifier|*
name|asn1_d2i
decl_stmt|;
name|ASN1_i2d_func
modifier|*
name|asn1_i2d
decl_stmt|;
block|}
name|ASN1_COMPAT_FUNCS
typedef|;
typedef|typedef
struct|struct
name|ASN1_EXTERN_FUNCS_st
block|{
name|void
modifier|*
name|app_data
decl_stmt|;
name|ASN1_ex_new_func
modifier|*
name|asn1_ex_new
decl_stmt|;
name|ASN1_ex_free_func
modifier|*
name|asn1_ex_free
decl_stmt|;
name|ASN1_ex_free_func
modifier|*
name|asn1_ex_clear
decl_stmt|;
name|ASN1_ex_d2i
modifier|*
name|asn1_ex_d2i
decl_stmt|;
name|ASN1_ex_i2d
modifier|*
name|asn1_ex_i2d
decl_stmt|;
block|}
name|ASN1_EXTERN_FUNCS
typedef|;
typedef|typedef
struct|struct
name|ASN1_PRIMITIVE_FUNCS_st
block|{
name|void
modifier|*
name|app_data
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|ASN1_ex_new_func
modifier|*
name|prim_new
decl_stmt|;
name|ASN1_ex_free_func
modifier|*
name|prim_free
decl_stmt|;
name|ASN1_ex_free_func
modifier|*
name|prim_clear
decl_stmt|;
name|ASN1_primitive_c2i
modifier|*
name|prim_c2i
decl_stmt|;
name|ASN1_primitive_i2c
modifier|*
name|prim_i2c
decl_stmt|;
block|}
name|ASN1_PRIMITIVE_FUNCS
typedef|;
comment|/* This is the ASN1_AUX structure: it handles various  * miscellaneous requirements. For example the use of  * reference counts and an informational callback.  *  * The "informational callback" is called at various  * points during the ASN1 encoding and decoding. It can  * be used to provide minor customisation of the structures  * used. This is most useful where the supplied routines  * *almost* do the right thing but need some extra help  * at a few points. If the callback returns zero then  * it is assumed a fatal error has occurred and the   * main operation should be abandoned.  *  * If major changes in the default behaviour are required  * then an external type is more appropriate.  */
typedef|typedef
name|int
name|ASN1_aux_cb
parameter_list|(
name|int
name|operation
parameter_list|,
name|ASN1_VALUE
modifier|*
modifier|*
name|in
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|ASN1_AUX_st
block|{
name|void
modifier|*
name|app_data
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|ref_offset
decl_stmt|;
comment|/* Offset of reference value */
name|int
name|ref_lock
decl_stmt|;
comment|/* Lock type to use */
name|ASN1_aux_cb
modifier|*
name|asn1_cb
decl_stmt|;
name|int
name|enc_offset
decl_stmt|;
comment|/* Offset of ASN1_ENCODING structure */
block|}
name|ASN1_AUX
typedef|;
comment|/* Flags in ASN1_AUX */
comment|/* Use a reference count */
define|#
directive|define
name|ASN1_AFLG_REFCOUNT
value|1
comment|/* Save the encoding of structure (useful for signatures) */
define|#
directive|define
name|ASN1_AFLG_ENCODING
value|2
comment|/* The Sequence length is invalid */
define|#
directive|define
name|ASN1_AFLG_BROKEN
value|4
comment|/* operation values for asn1_cb */
define|#
directive|define
name|ASN1_OP_NEW_PRE
value|0
define|#
directive|define
name|ASN1_OP_NEW_POST
value|1
define|#
directive|define
name|ASN1_OP_FREE_PRE
value|2
define|#
directive|define
name|ASN1_OP_FREE_POST
value|3
define|#
directive|define
name|ASN1_OP_D2I_PRE
value|4
define|#
directive|define
name|ASN1_OP_D2I_POST
value|5
define|#
directive|define
name|ASN1_OP_I2D_PRE
value|6
define|#
directive|define
name|ASN1_OP_I2D_POST
value|7
comment|/* Macro to implement a primitive type */
define|#
directive|define
name|IMPLEMENT_ASN1_TYPE
parameter_list|(
name|stname
parameter_list|)
value|IMPLEMENT_ASN1_TYPE_ex(stname, stname, 0)
define|#
directive|define
name|IMPLEMENT_ASN1_TYPE_ex
parameter_list|(
name|itname
parameter_list|,
name|vname
parameter_list|,
name|ex
parameter_list|)
define|\
value|ASN1_ITEM_start(itname) \ 					ASN1_ITYPE_PRIMITIVE, V_##vname, NULL, 0, NULL, ex, #itname \ 				ASN1_ITEM_end(itname)
comment|/* Macro to implement a multi string type */
define|#
directive|define
name|IMPLEMENT_ASN1_MSTRING
parameter_list|(
name|itname
parameter_list|,
name|mask
parameter_list|)
define|\
value|ASN1_ITEM_start(itname) \ 					ASN1_ITYPE_MSTRING, mask, NULL, 0, NULL, sizeof(ASN1_STRING), #itname \ 				ASN1_ITEM_end(itname)
comment|/* Macro to implement an ASN1_ITEM in terms of old style funcs */
define|#
directive|define
name|IMPLEMENT_COMPAT_ASN1
parameter_list|(
name|sname
parameter_list|)
value|IMPLEMENT_COMPAT_ASN1_type(sname, V_ASN1_SEQUENCE)
define|#
directive|define
name|IMPLEMENT_COMPAT_ASN1_type
parameter_list|(
name|sname
parameter_list|,
name|tag
parameter_list|)
define|\
value|static const ASN1_COMPAT_FUNCS sname##_ff = { \ 		(ASN1_new_func *)sname##_new, \ 		(ASN1_free_func *)sname##_free, \ 		(ASN1_d2i_func *)d2i_##sname, \ 		(ASN1_i2d_func *)i2d_##sname, \ 	}; \ 	ASN1_ITEM_start(sname) \ 		ASN1_ITYPE_COMPAT, \ 		tag, \ 		NULL, \ 		0, \&sname##_ff, \ 		0, \ 		#sname \ 	ASN1_ITEM_end(sname)
define|#
directive|define
name|IMPLEMENT_EXTERN_ASN1
parameter_list|(
name|sname
parameter_list|,
name|tag
parameter_list|,
name|fptrs
parameter_list|)
define|\
value|ASN1_ITEM_start(sname) \ 		ASN1_ITYPE_EXTERN, \ 		tag, \ 		NULL, \ 		0, \&fptrs, \ 		0, \ 		#sname \ 	ASN1_ITEM_end(sname)
comment|/* Macro to implement standard functions in terms of ASN1_ITEM structures */
define|#
directive|define
name|IMPLEMENT_ASN1_FUNCTIONS
parameter_list|(
name|stname
parameter_list|)
value|IMPLEMENT_ASN1_FUNCTIONS_fname(stname, stname, stname)
define|#
directive|define
name|IMPLEMENT_ASN1_FUNCTIONS_name
parameter_list|(
name|stname
parameter_list|,
name|itname
parameter_list|)
value|IMPLEMENT_ASN1_FUNCTIONS_fname(stname, itname, itname)
define|#
directive|define
name|IMPLEMENT_ASN1_FUNCTIONS_ENCODE_name
parameter_list|(
name|stname
parameter_list|,
name|itname
parameter_list|)
define|\
value|IMPLEMENT_ASN1_FUNCTIONS_ENCODE_fname(stname, itname, itname)
define|#
directive|define
name|IMPLEMENT_ASN1_ALLOC_FUNCTIONS
parameter_list|(
name|stname
parameter_list|)
define|\
value|IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, stname, stname)
define|#
directive|define
name|IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname
parameter_list|(
name|stname
parameter_list|,
name|itname
parameter_list|,
name|fname
parameter_list|)
define|\
value|stname *fname##_new(void) \ 	{ \ 		return (stname *)ASN1_item_new(ASN1_ITEM_rptr(itname)); \ 	} \ 	void fname##_free(stname *a) \ 	{ \ 		ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \ 	}
define|#
directive|define
name|IMPLEMENT_ASN1_FUNCTIONS_fname
parameter_list|(
name|stname
parameter_list|,
name|itname
parameter_list|,
name|fname
parameter_list|)
define|\
value|IMPLEMENT_ASN1_ENCODE_FUNCTIONS_fname(stname, itname, fname) \ 	IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, itname, fname)
define|#
directive|define
name|IMPLEMENT_ASN1_ENCODE_FUNCTIONS_fname
parameter_list|(
name|stname
parameter_list|,
name|itname
parameter_list|,
name|fname
parameter_list|)
define|\
value|stname *d2i_##fname(stname **a, const unsigned char **in, long len) \ 	{ \ 		return (stname *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, ASN1_ITEM_rptr(itname));\ 	} \ 	int i2d_##fname(stname *a, unsigned char **out) \ 	{ \ 		return ASN1_item_i2d((ASN1_VALUE *)a, out, ASN1_ITEM_rptr(itname));\ 	}
define|#
directive|define
name|IMPLEMENT_ASN1_NDEF_FUNCTION
parameter_list|(
name|stname
parameter_list|)
define|\
value|int i2d_##stname##_NDEF(stname *a, unsigned char **out) \ 	{ \ 		return ASN1_item_ndef_i2d((ASN1_VALUE *)a, out, ASN1_ITEM_rptr(stname));\ 	}
comment|/* This includes evil casts to remove const: they will go away when full  * ASN1 constification is done.  */
define|#
directive|define
name|IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname
parameter_list|(
name|stname
parameter_list|,
name|itname
parameter_list|,
name|fname
parameter_list|)
define|\
value|stname *d2i_##fname(stname **a, const unsigned char **in, long len) \ 	{ \ 		return (stname *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, ASN1_ITEM_rptr(itname));\ 	} \ 	int i2d_##fname(const stname *a, unsigned char **out) \ 	{ \ 		return ASN1_item_i2d((ASN1_VALUE *)a, out, ASN1_ITEM_rptr(itname));\ 	}
define|#
directive|define
name|IMPLEMENT_ASN1_DUP_FUNCTION
parameter_list|(
name|stname
parameter_list|)
define|\
value|stname * stname##_dup(stname *x) \         { \         return ASN1_item_dup(ASN1_ITEM_rptr(stname), x); \         }
define|#
directive|define
name|IMPLEMENT_ASN1_FUNCTIONS_const
parameter_list|(
name|name
parameter_list|)
define|\
value|IMPLEMENT_ASN1_FUNCTIONS_const_fname(name, name, name)
define|#
directive|define
name|IMPLEMENT_ASN1_FUNCTIONS_const_fname
parameter_list|(
name|stname
parameter_list|,
name|itname
parameter_list|,
name|fname
parameter_list|)
define|\
value|IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(stname, itname, fname) \ 	IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, itname, fname)
comment|/* external definitions for primitive types */
name|DECLARE_ASN1_ITEM
argument_list|(
argument|ASN1_BOOLEAN
argument_list|)
name|DECLARE_ASN1_ITEM
argument_list|(
argument|ASN1_TBOOLEAN
argument_list|)
name|DECLARE_ASN1_ITEM
argument_list|(
argument|ASN1_FBOOLEAN
argument_list|)
name|DECLARE_ASN1_ITEM
argument_list|(
argument|ASN1_SEQUENCE
argument_list|)
name|DECLARE_ASN1_ITEM
argument_list|(
argument|CBIGNUM
argument_list|)
name|DECLARE_ASN1_ITEM
argument_list|(
argument|BIGNUM
argument_list|)
name|DECLARE_ASN1_ITEM
argument_list|(
argument|LONG
argument_list|)
name|DECLARE_ASN1_ITEM
argument_list|(
argument|ZLONG
argument_list|)
name|DECLARE_STACK_OF
argument_list|(
argument|ASN1_VALUE
argument_list|)
comment|/* Functions used internally by the ASN1 code */
name|int
name|ASN1_item_ex_new
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
name|void
name|ASN1_item_ex_free
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
name|int
name|ASN1_template_new
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|)
function_decl|;
name|int
name|ASN1_primitive_new
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
name|void
name|ASN1_template_free
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|)
function_decl|;
name|int
name|ASN1_template_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|)
function_decl|;
name|int
name|ASN1_item_ex_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|,
name|int
name|tag
parameter_list|,
name|int
name|aclass
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|ASN1_item_ex_i2d
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|,
name|int
name|tag
parameter_list|,
name|int
name|aclass
parameter_list|)
function_decl|;
name|int
name|ASN1_template_i2d
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|)
function_decl|;
name|void
name|ASN1_primitive_free
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
name|int
name|asn1_ex_i2c
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
name|unsigned
name|char
modifier|*
name|cont
parameter_list|,
name|int
modifier|*
name|putype
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
name|int
name|asn1_ex_c2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|cont
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|utype
parameter_list|,
name|char
modifier|*
name|free_cont
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
name|int
name|asn1_get_choice_selector
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
name|int
name|asn1_set_choice_selector
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
name|int
name|value
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
name|ASN1_VALUE
modifier|*
modifier|*
name|asn1_get_field_ptr
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|)
function_decl|;
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|asn1_do_adb
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|,
name|int
name|nullerr
parameter_list|)
function_decl|;
name|int
name|asn1_do_lock
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
name|int
name|op
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
name|void
name|asn1_enc_init
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
name|void
name|asn1_enc_free
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
name|int
name|asn1_enc_restore
parameter_list|(
name|int
modifier|*
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|out
parameter_list|,
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
name|int
name|asn1_enc_save
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|int
name|inlen
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

