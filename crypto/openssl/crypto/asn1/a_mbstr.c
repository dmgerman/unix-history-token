begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* a_mbstr.c */
end_comment

begin_comment
comment|/* Written by Dr Stephen N Henson (shenson@bigfoot.com) for the OpenSSL  * project 1999.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/asn1.h>
end_include

begin_function_decl
specifier|static
name|int
name|traverse_string
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|inform
parameter_list|,
name|int
function_decl|(
modifier|*
name|rfunc
function_decl|)
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|in
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|in_utf8
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|out_utf8
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|type_str
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cpy_asc
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cpy_bmp
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cpy_univ
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cpy_utf8
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_printable
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* These functions take a string in UTF8, ASCII or multibyte form and  * a mask of permissible ASN1 string types. It then works out the minimal  * type (using the order Printable< IA5< T61< BMP< Universal< UTF8)  * and creates a string of the correct type with the supplied data.  * Yes this is horrible: it has to be :-(  * The 'ncopy' form checks minimum and maximum size limits too.  */
end_comment

begin_function
name|int
name|ASN1_mbstring_copy
parameter_list|(
name|ASN1_STRING
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|inform
parameter_list|,
name|unsigned
name|long
name|mask
parameter_list|)
block|{
return|return
name|ASN1_mbstring_ncopy
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
name|len
argument_list|,
name|inform
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ASN1_mbstring_ncopy
parameter_list|(
name|ASN1_STRING
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|inform
parameter_list|,
name|unsigned
name|long
name|mask
parameter_list|,
name|long
name|minsize
parameter_list|,
name|long
name|maxsize
parameter_list|)
block|{
name|int
name|str_type
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|free_out
decl_stmt|;
name|int
name|outform
decl_stmt|,
name|outlen
decl_stmt|;
name|ASN1_STRING
modifier|*
name|dest
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|nchar
decl_stmt|;
name|char
name|strbuf
index|[
literal|32
index|]
decl_stmt|;
name|int
function_decl|(
modifier|*
name|cpyfunc
function_decl|)
parameter_list|(
name|unsigned
name|long
parameter_list|,
name|void
modifier|*
parameter_list|)
init|=
name|NULL
function_decl|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
name|len
operator|=
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
name|mask
operator|=
name|DIRSTRING_TYPE
expr_stmt|;
comment|/* First do a string check and work out the number of characters */
switch|switch
condition|(
name|inform
condition|)
block|{
case|case
name|MBSTRING_BMP
case|:
if|if
condition|(
name|len
operator|&
literal|1
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_MBSTRING_COPY
argument_list|,
name|ASN1_R_INVALID_BMPSTRING_LENGTH
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|nchar
operator|=
name|len
operator|>>
literal|1
expr_stmt|;
break|break;
case|case
name|MBSTRING_UNIV
case|:
if|if
condition|(
name|len
operator|&
literal|3
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_MBSTRING_COPY
argument_list|,
name|ASN1_R_INVALID_UNIVERSALSTRING_LENGTH
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|nchar
operator|=
name|len
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
name|MBSTRING_UTF8
case|:
name|nchar
operator|=
literal|0
expr_stmt|;
comment|/* This counts the characters and does utf8 syntax checking */
name|ret
operator|=
name|traverse_string
argument_list|(
name|in
argument_list|,
name|len
argument_list|,
name|MBSTRING_UTF8
argument_list|,
name|in_utf8
argument_list|,
operator|&
name|nchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_MBSTRING_COPY
argument_list|,
name|ASN1_R_INVALID_UTF8STRING
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|MBSTRING_ASC
case|:
name|nchar
operator|=
name|len
expr_stmt|;
break|break;
default|default:
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_MBSTRING_COPY
argument_list|,
name|ASN1_R_UNKNOWN_FORMAT
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|minsize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|nchar
operator|<
name|minsize
operator|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_MBSTRING_COPY
argument_list|,
name|ASN1_R_STRING_TOO_SHORT
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|strbuf
argument_list|,
literal|"%ld"
argument_list|,
name|minsize
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"minsize="
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|maxsize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|nchar
operator|>
name|maxsize
operator|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_MBSTRING_COPY
argument_list|,
name|ASN1_R_STRING_TOO_LONG
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|strbuf
argument_list|,
literal|"%ld"
argument_list|,
name|maxsize
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"maxsize="
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Now work out minimal type (if any) */
if|if
condition|(
name|traverse_string
argument_list|(
name|in
argument_list|,
name|len
argument_list|,
name|inform
argument_list|,
name|type_str
argument_list|,
operator|&
name|mask
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_MBSTRING_COPY
argument_list|,
name|ASN1_R_ILLEGAL_CHARACTERS
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Now work out output format and string type */
name|outform
operator|=
name|MBSTRING_ASC
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|B_ASN1_PRINTABLESTRING
condition|)
name|str_type
operator|=
name|V_ASN1_PRINTABLESTRING
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
name|B_ASN1_IA5STRING
condition|)
name|str_type
operator|=
name|V_ASN1_IA5STRING
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
name|B_ASN1_T61STRING
condition|)
name|str_type
operator|=
name|V_ASN1_T61STRING
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
name|B_ASN1_BMPSTRING
condition|)
block|{
name|str_type
operator|=
name|V_ASN1_BMPSTRING
expr_stmt|;
name|outform
operator|=
name|MBSTRING_BMP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|B_ASN1_UNIVERSALSTRING
condition|)
block|{
name|str_type
operator|=
name|V_ASN1_UNIVERSALSTRING
expr_stmt|;
name|outform
operator|=
name|MBSTRING_UNIV
expr_stmt|;
block|}
else|else
block|{
name|str_type
operator|=
name|V_ASN1_UTF8STRING
expr_stmt|;
name|outform
operator|=
name|MBSTRING_UTF8
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|out
condition|)
return|return
name|str_type
return|;
if|if
condition|(
operator|*
name|out
condition|)
block|{
name|free_out
operator|=
literal|0
expr_stmt|;
name|dest
operator|=
operator|*
name|out
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|data
condition|)
block|{
name|dest
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|dest
operator|->
name|data
argument_list|)
expr_stmt|;
name|dest
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|dest
operator|->
name|type
operator|=
name|str_type
expr_stmt|;
block|}
else|else
block|{
name|free_out
operator|=
literal|1
expr_stmt|;
name|dest
operator|=
name|ASN1_STRING_type_new
argument_list|(
name|str_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dest
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_MBSTRING_COPY
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|out
operator|=
name|dest
expr_stmt|;
block|}
comment|/* If both the same type just copy across */
if|if
condition|(
name|inform
operator|==
name|outform
condition|)
block|{
if|if
condition|(
operator|!
name|ASN1_STRING_set
argument_list|(
name|dest
argument_list|,
name|in
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_MBSTRING_COPY
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|str_type
return|;
block|}
comment|/* Work out how much space the destination will need */
switch|switch
condition|(
name|outform
condition|)
block|{
case|case
name|MBSTRING_ASC
case|:
name|outlen
operator|=
name|nchar
expr_stmt|;
name|cpyfunc
operator|=
name|cpy_asc
expr_stmt|;
break|break;
case|case
name|MBSTRING_BMP
case|:
name|outlen
operator|=
name|nchar
operator|<<
literal|1
expr_stmt|;
name|cpyfunc
operator|=
name|cpy_bmp
expr_stmt|;
break|break;
case|case
name|MBSTRING_UNIV
case|:
name|outlen
operator|=
name|nchar
operator|<<
literal|2
expr_stmt|;
name|cpyfunc
operator|=
name|cpy_univ
expr_stmt|;
break|break;
case|case
name|MBSTRING_UTF8
case|:
name|outlen
operator|=
literal|0
expr_stmt|;
name|traverse_string
argument_list|(
name|in
argument_list|,
name|len
argument_list|,
name|inform
argument_list|,
name|out_utf8
argument_list|,
operator|&
name|outlen
argument_list|)
expr_stmt|;
name|cpyfunc
operator|=
name|cpy_utf8
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|OPENSSL_malloc
argument_list|(
name|outlen
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|free_out
condition|)
name|ASN1_STRING_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_MBSTRING_COPY
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dest
operator|->
name|length
operator|=
name|outlen
expr_stmt|;
name|dest
operator|->
name|data
operator|=
name|p
expr_stmt|;
name|p
index|[
name|outlen
index|]
operator|=
literal|0
expr_stmt|;
name|traverse_string
argument_list|(
name|in
argument_list|,
name|len
argument_list|,
name|inform
argument_list|,
name|cpyfunc
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
return|return
name|str_type
return|;
block|}
end_function

begin_comment
comment|/* This function traverses a string and passes the value of each character  * to an optional function along with a void * argument.  */
end_comment

begin_function
specifier|static
name|int
name|traverse_string
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|inform
parameter_list|,
name|int
function_decl|(
modifier|*
name|rfunc
function_decl|)
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|in
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|long
name|value
decl_stmt|;
name|int
name|ret
decl_stmt|;
while|while
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|inform
operator|==
name|MBSTRING_ASC
condition|)
block|{
name|value
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inform
operator|==
name|MBSTRING_BMP
condition|)
block|{
name|value
operator|=
operator|*
name|p
operator|++
operator|<<
literal|8
expr_stmt|;
name|value
operator||=
operator|*
name|p
operator|++
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inform
operator|==
name|MBSTRING_UNIV
condition|)
block|{
name|value
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
operator|*
name|p
operator|++
operator|)
operator|<<
literal|24
expr_stmt|;
name|value
operator||=
operator|(
operator|(
name|unsigned
name|long
operator|)
operator|*
name|p
operator|++
operator|)
operator|<<
literal|16
expr_stmt|;
name|value
operator||=
operator|*
name|p
operator|++
operator|<<
literal|8
expr_stmt|;
name|value
operator||=
operator|*
name|p
operator|++
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|UTF8_getc
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|len
operator|-=
name|ret
expr_stmt|;
name|p
operator|+=
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|rfunc
condition|)
block|{
name|ret
operator|=
name|rfunc
argument_list|(
name|value
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
return|return
name|ret
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Various utility functions for traverse_string */
end_comment

begin_comment
comment|/* Just count number of characters */
end_comment

begin_function
specifier|static
name|int
name|in_utf8
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
modifier|*
name|nchar
decl_stmt|;
name|nchar
operator|=
name|arg
expr_stmt|;
operator|(
operator|*
name|nchar
operator|)
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Determine size of output as a UTF8 String */
end_comment

begin_function
specifier|static
name|int
name|out_utf8
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
modifier|*
name|outlen
decl_stmt|;
name|outlen
operator|=
name|arg
expr_stmt|;
operator|*
name|outlen
operator|+=
name|UTF8_putc
argument_list|(
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Determine the "type" of a string: check each character against a  * supplied "mask".  */
end_comment

begin_function
specifier|static
name|int
name|type_str
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|long
name|types
decl_stmt|;
name|types
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|types
operator|&
name|B_ASN1_PRINTABLESTRING
operator|)
operator|&&
operator|!
name|is_printable
argument_list|(
name|value
argument_list|)
condition|)
name|types
operator|&=
operator|~
name|B_ASN1_PRINTABLESTRING
expr_stmt|;
if|if
condition|(
operator|(
name|types
operator|&
name|B_ASN1_IA5STRING
operator|)
operator|&&
operator|(
name|value
operator|>
literal|127
operator|)
condition|)
name|types
operator|&=
operator|~
name|B_ASN1_IA5STRING
expr_stmt|;
if|if
condition|(
operator|(
name|types
operator|&
name|B_ASN1_T61STRING
operator|)
operator|&&
operator|(
name|value
operator|>
literal|0xff
operator|)
condition|)
name|types
operator|&=
operator|~
name|B_ASN1_T61STRING
expr_stmt|;
if|if
condition|(
operator|(
name|types
operator|&
name|B_ASN1_BMPSTRING
operator|)
operator|&&
operator|(
name|value
operator|>
literal|0xffff
operator|)
condition|)
name|types
operator|&=
operator|~
name|B_ASN1_BMPSTRING
expr_stmt|;
if|if
condition|(
operator|!
name|types
condition|)
return|return
operator|-
literal|1
return|;
operator|*
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|)
operator|=
name|types
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Copy one byte per character ASCII like strings */
end_comment

begin_function
specifier|static
name|int
name|cpy_asc
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
name|q
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|q
operator|=
operator|(
name|unsigned
name|char
operator|)
name|value
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Copy two byte per character BMPStrings */
end_comment

begin_function
specifier|static
name|int
name|cpy_bmp
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
name|q
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|q
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|p
operator|+=
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Copy four byte per character UniversalStrings */
end_comment

begin_function
specifier|static
name|int
name|cpy_univ
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
name|q
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|q
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|p
operator|+=
literal|4
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Copy to a UTF8String */
end_comment

begin_function
specifier|static
name|int
name|cpy_utf8
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
comment|/* We already know there is enough room so pass 0xff as the length */
name|ret
operator|=
name|UTF8_putc
argument_list|(
operator|*
name|p
argument_list|,
literal|0xff
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|*
name|p
operator|+=
name|ret
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the character is permitted in a PrintableString */
end_comment

begin_function
specifier|static
name|int
name|is_printable
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|value
operator|>
literal|0x7f
condition|)
return|return
literal|0
return|;
name|ch
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
comment|/* Note: we can't use 'isalnum' because certain accented  	 * characters may count as alphanumeric in some environments. 	 */
ifndef|#
directive|ifndef
name|CHARSET_EBCDIC
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'z'
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'Z'
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ch
operator|==
literal|' '
operator|)
operator|||
name|strchr
argument_list|(
literal|"'()+,-./:=?"
argument_list|,
name|ch
argument_list|)
condition|)
return|return
literal|1
return|;
else|#
directive|else
comment|/*CHARSET_EBCDIC*/
if|if
condition|(
operator|(
name|ch
operator|>=
name|os_toascii
index|[
literal|'a'
index|]
operator|)
operator|&&
operator|(
name|ch
operator|<=
name|os_toascii
index|[
literal|'z'
index|]
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
name|os_toascii
index|[
literal|'A'
index|]
operator|)
operator|&&
operator|(
name|ch
operator|<=
name|os_toascii
index|[
literal|'Z'
index|]
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
name|os_toascii
index|[
literal|'0'
index|]
operator|)
operator|&&
operator|(
name|ch
operator|<=
name|os_toascii
index|[
literal|'9'
index|]
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ch
operator|==
name|os_toascii
index|[
literal|' '
index|]
operator|)
operator|||
name|strchr
argument_list|(
literal|"'()+,-./:=?"
argument_list|,
name|os_toebcdic
index|[
name|ch
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/*CHARSET_EBCDIC*/
return|return
literal|0
return|;
block|}
end_function

end_unit

