begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/bn/bn.h */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *   * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *   * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from   *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *   * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.  *  * Portions of the attached software ("Contribution") are developed by   * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.  *  * The Contribution is licensed pursuant to the Eric Young open source  * license provided above.  *  * The binary polynomial arithmetic software is originally written by   * Sheueling Chang Shantz and Douglas Stebila of Sun Microsystems Laboratories.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HEADER_BN_H
end_ifndef

begin_define
define|#
directive|define
name|HEADER_BN_H
end_define

begin_include
include|#
directive|include
file|<openssl/e_os2.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_FP_API
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* FILE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/ossl_typ.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* These preprocessor symbols control various aspects of the bignum headers and  * library code. They're not defined by any "normal" configuration, as they are  * intended for development and testing purposes. NB: defining all three can be  * useful for debugging application code as well as openssl itself.  *  * BN_DEBUG - turn on various debugging alterations to the bignum code  * BN_DEBUG_RAND - uses random poisoning of unused words to trip up  * mismanagement of bignum internals. You must also define BN_DEBUG.  */
comment|/* #define BN_DEBUG */
comment|/* #define BN_DEBUG_RAND */
ifndef|#
directive|ifndef
name|OPENSSL_SMALL_FOOTPRINT
define|#
directive|define
name|BN_MUL_COMBA
define|#
directive|define
name|BN_SQR_COMBA
define|#
directive|define
name|BN_RECURSION
endif|#
directive|endif
comment|/* This next option uses the C libraries (2 word)/(1 word) function.  * If it is not defined, I use my C version (which is slower).  * The reason for this flag is that when the particular C compiler  * library routine is used, and the library is linked with a different  * compiler, the library is missing.  This mostly happens when the  * library is built with gcc and then linked using normal cc.  This would  * be a common occurrence because gcc normally produces code that is  * 2 times faster than system compilers for the big number stuff.  * For machines with only one compiler (or shared libraries), this should  * be on.  Again this in only really a problem on machines  * using "long long's", are 32bit, and are not using my assembler code. */
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_SYS_MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|OPENSSL_SYS_WINDOWS
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|OPENSSL_SYS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|linux
argument_list|)
ifndef|#
directive|ifndef
name|BN_DIV2W
define|#
directive|define
name|BN_DIV2W
endif|#
directive|endif
endif|#
directive|endif
comment|/* assuming long is 64bit - this is the DEC Alpha  * unsigned long long is only 64 bits :-(, don't define  * BN_LLONG for the DEC Alpha */
ifdef|#
directive|ifdef
name|SIXTY_FOUR_BIT_LONG
define|#
directive|define
name|BN_ULLONG
value|unsigned long long
define|#
directive|define
name|BN_ULONG
value|unsigned long
define|#
directive|define
name|BN_LONG
value|long
define|#
directive|define
name|BN_BITS
value|128
define|#
directive|define
name|BN_BYTES
value|8
define|#
directive|define
name|BN_BITS2
value|64
define|#
directive|define
name|BN_BITS4
value|32
define|#
directive|define
name|BN_MASK
value|(0xffffffffffffffffffffffffffffffffLL)
define|#
directive|define
name|BN_MASK2
value|(0xffffffffffffffffL)
define|#
directive|define
name|BN_MASK2l
value|(0xffffffffL)
define|#
directive|define
name|BN_MASK2h
value|(0xffffffff00000000L)
define|#
directive|define
name|BN_MASK2h1
value|(0xffffffff80000000L)
define|#
directive|define
name|BN_TBIT
value|(0x8000000000000000L)
define|#
directive|define
name|BN_DEC_CONV
value|(10000000000000000000UL)
define|#
directive|define
name|BN_DEC_FMT1
value|"%lu"
define|#
directive|define
name|BN_DEC_FMT2
value|"%019lu"
define|#
directive|define
name|BN_DEC_NUM
value|19
define|#
directive|define
name|BN_HEX_FMT1
value|"%lX"
define|#
directive|define
name|BN_HEX_FMT2
value|"%016lX"
endif|#
directive|endif
comment|/* This is where the long long data type is 64 bits, but long is 32.  * For machines where there are 64bit registers, this is the mode to use.  * IRIX, on R4000 and above should use this mode, along with the relevant  * assembler code :-).  Do NOT define BN_LLONG.  */
ifdef|#
directive|ifdef
name|SIXTY_FOUR_BIT
undef|#
directive|undef
name|BN_LLONG
undef|#
directive|undef
name|BN_ULLONG
define|#
directive|define
name|BN_ULONG
value|unsigned long long
define|#
directive|define
name|BN_LONG
value|long long
define|#
directive|define
name|BN_BITS
value|128
define|#
directive|define
name|BN_BYTES
value|8
define|#
directive|define
name|BN_BITS2
value|64
define|#
directive|define
name|BN_BITS4
value|32
define|#
directive|define
name|BN_MASK2
value|(0xffffffffffffffffLL)
define|#
directive|define
name|BN_MASK2l
value|(0xffffffffL)
define|#
directive|define
name|BN_MASK2h
value|(0xffffffff00000000LL)
define|#
directive|define
name|BN_MASK2h1
value|(0xffffffff80000000LL)
define|#
directive|define
name|BN_TBIT
value|(0x8000000000000000LL)
define|#
directive|define
name|BN_DEC_CONV
value|(10000000000000000000ULL)
define|#
directive|define
name|BN_DEC_FMT1
value|"%llu"
define|#
directive|define
name|BN_DEC_FMT2
value|"%019llu"
define|#
directive|define
name|BN_DEC_NUM
value|19
define|#
directive|define
name|BN_HEX_FMT1
value|"%llX"
define|#
directive|define
name|BN_HEX_FMT2
value|"%016llX"
endif|#
directive|endif
ifdef|#
directive|ifdef
name|THIRTY_TWO_BIT
ifdef|#
directive|ifdef
name|BN_LLONG
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
define|#
directive|define
name|BN_ULLONG
value|unsigned __int64
define|#
directive|define
name|BN_MASK
value|(0xffffffffffffffffI64)
else|#
directive|else
define|#
directive|define
name|BN_ULLONG
value|unsigned long long
define|#
directive|define
name|BN_MASK
value|(0xffffffffffffffffLL)
endif|#
directive|endif
endif|#
directive|endif
define|#
directive|define
name|BN_ULONG
value|unsigned int
define|#
directive|define
name|BN_LONG
value|int
define|#
directive|define
name|BN_BITS
value|64
define|#
directive|define
name|BN_BYTES
value|4
define|#
directive|define
name|BN_BITS2
value|32
define|#
directive|define
name|BN_BITS4
value|16
define|#
directive|define
name|BN_MASK2
value|(0xffffffffL)
define|#
directive|define
name|BN_MASK2l
value|(0xffff)
define|#
directive|define
name|BN_MASK2h1
value|(0xffff8000L)
define|#
directive|define
name|BN_MASK2h
value|(0xffff0000L)
define|#
directive|define
name|BN_TBIT
value|(0x80000000L)
define|#
directive|define
name|BN_DEC_CONV
value|(1000000000L)
define|#
directive|define
name|BN_DEC_FMT1
value|"%u"
define|#
directive|define
name|BN_DEC_FMT2
value|"%09u"
define|#
directive|define
name|BN_DEC_NUM
value|9
define|#
directive|define
name|BN_HEX_FMT1
value|"%X"
define|#
directive|define
name|BN_HEX_FMT2
value|"%08X"
endif|#
directive|endif
comment|/* 2011-02-22 SMS.  * In various places, a size_t variable or a type cast to size_t was  * used to perform integer-only operations on pointers.  This failed on  * VMS with 64-bit pointers (CC /POINTER_SIZE = 64) because size_t is  * still only 32 bits.  What's needed in these cases is an integer type  * with the same size as a pointer, which size_t is not certain to be.   * The only fix here is VMS-specific.  */
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_SYS_VMS
argument_list|)
if|#
directive|if
name|__INITIAL_POINTER_SIZE
operator|==
literal|64
define|#
directive|define
name|PTR_SIZE_INT
value|long long
else|#
directive|else
comment|/* __INITIAL_POINTER_SIZE == 64 */
define|#
directive|define
name|PTR_SIZE_INT
value|int
endif|#
directive|endif
comment|/* __INITIAL_POINTER_SIZE == 64 [else] */
else|#
directive|else
comment|/* defined(OPENSSL_SYS_VMS) */
define|#
directive|define
name|PTR_SIZE_INT
value|size_t
endif|#
directive|endif
comment|/* defined(OPENSSL_SYS_VMS) [else] */
define|#
directive|define
name|BN_DEFAULT_BITS
value|1280
define|#
directive|define
name|BN_FLG_MALLOCED
value|0x01
define|#
directive|define
name|BN_FLG_STATIC_DATA
value|0x02
define|#
directive|define
name|BN_FLG_CONSTTIME
value|0x04
comment|/* avoid leaking exponent information through timing,                                       * BN_mod_exp_mont() will call BN_mod_exp_mont_consttime,                                       * BN_div() will call BN_div_no_branch,                                       * BN_mod_inverse() will call BN_mod_inverse_no_branch.                                       */
ifndef|#
directive|ifndef
name|OPENSSL_NO_DEPRECATED
define|#
directive|define
name|BN_FLG_EXP_CONSTTIME
value|BN_FLG_CONSTTIME
comment|/* deprecated name for the flag */
comment|/* avoid leaking exponent information through timings                                       * (BN_mod_exp_mont() will call BN_mod_exp_mont_consttime) */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DEPRECATED
define|#
directive|define
name|BN_FLG_FREE
value|0x8000
comment|/* used for debuging */
endif|#
directive|endif
define|#
directive|define
name|BN_set_flags
parameter_list|(
name|b
parameter_list|,
name|n
parameter_list|)
value|((b)->flags|=(n))
define|#
directive|define
name|BN_get_flags
parameter_list|(
name|b
parameter_list|,
name|n
parameter_list|)
value|((b)->flags&(n))
comment|/* get a clone of a BIGNUM with changed flags, for *temporary* use only  * (the two BIGNUMs cannot not be used in parallel!) */
define|#
directive|define
name|BN_with_flags
parameter_list|(
name|dest
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
value|((dest)->d=(b)->d, \                                   (dest)->top=(b)->top, \                                   (dest)->dmax=(b)->dmax, \                                   (dest)->neg=(b)->neg, \                                   (dest)->flags=(((dest)->flags& BN_FLG_MALLOCED) \                                                  |  ((b)->flags& ~BN_FLG_MALLOCED) \                                                  |  BN_FLG_STATIC_DATA \                                                  |  (n)))
comment|/* Already declared in ossl_typ.h */
if|#
directive|if
literal|0
block|typedef struct bignum_st BIGNUM;
comment|/* Used for temp variables (declaration hidden in bn_lcl.h) */
block|typedef struct bignum_ctx BN_CTX; typedef struct bn_blinding_st BN_BLINDING; typedef struct bn_mont_ctx_st BN_MONT_CTX; typedef struct bn_recp_ctx_st BN_RECP_CTX; typedef struct bn_gencb_st BN_GENCB;
endif|#
directive|endif
struct|struct
name|bignum_st
block|{
name|BN_ULONG
modifier|*
name|d
decl_stmt|;
comment|/* Pointer to an array of 'BN_BITS2' bit chunks. */
name|int
name|top
decl_stmt|;
comment|/* Index of last used d +1. */
comment|/* The next are internal book keeping for bn_expand. */
name|int
name|dmax
decl_stmt|;
comment|/* Size of the d array. */
name|int
name|neg
decl_stmt|;
comment|/* one if the number is negative */
name|int
name|flags
decl_stmt|;
block|}
struct|;
comment|/* Used for montgomery multiplication */
struct|struct
name|bn_mont_ctx_st
block|{
name|int
name|ri
decl_stmt|;
comment|/* number of bits in R */
name|BIGNUM
name|RR
decl_stmt|;
comment|/* used to convert to montgomery form */
name|BIGNUM
name|N
decl_stmt|;
comment|/* The modulus */
name|BIGNUM
name|Ni
decl_stmt|;
comment|/* R*(1/R mod N) - N*Ni = 1 	                * (Ni is only stored for bignum algorithm) */
name|BN_ULONG
name|n0
index|[
literal|2
index|]
decl_stmt|;
comment|/* least significant word(s) of Ni; 	                  (type changed with 0.9.9, was "BN_ULONG n0;" before) */
name|int
name|flags
decl_stmt|;
block|}
struct|;
comment|/* Used for reciprocal division/mod functions  * It cannot be shared between threads  */
struct|struct
name|bn_recp_ctx_st
block|{
name|BIGNUM
name|N
decl_stmt|;
comment|/* the divisor */
name|BIGNUM
name|Nr
decl_stmt|;
comment|/* the reciprocal */
name|int
name|num_bits
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
comment|/* Used for slow "generation" functions. */
struct|struct
name|bn_gencb_st
block|{
name|unsigned
name|int
name|ver
decl_stmt|;
comment|/* To handle binary (in)compatibility */
name|void
modifier|*
name|arg
decl_stmt|;
comment|/* callback-specific data */
union|union
block|{
comment|/* if(ver==1) - handles old style callbacks */
name|void
function_decl|(
modifier|*
name|cb_1
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* if(ver==2) - new callback style */
name|int
function_decl|(
modifier|*
name|cb_2
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|BN_GENCB
modifier|*
parameter_list|)
function_decl|;
block|}
name|cb
union|;
block|}
struct|;
comment|/* Wrapper function to make using BN_GENCB easier,  */
name|int
name|BN_GENCB_call
parameter_list|(
name|BN_GENCB
modifier|*
name|cb
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
comment|/* Macro to populate a BN_GENCB structure with an "old"-style callback */
define|#
directive|define
name|BN_GENCB_set_old
parameter_list|(
name|gencb
parameter_list|,
name|callback
parameter_list|,
name|cb_arg
parameter_list|)
value|{ \ 		BN_GENCB *tmp_gencb = (gencb); \ 		tmp_gencb->ver = 1; \ 		tmp_gencb->arg = (cb_arg); \ 		tmp_gencb->cb.cb_1 = (callback); }
comment|/* Macro to populate a BN_GENCB structure with a "new"-style callback */
define|#
directive|define
name|BN_GENCB_set
parameter_list|(
name|gencb
parameter_list|,
name|callback
parameter_list|,
name|cb_arg
parameter_list|)
value|{ \ 		BN_GENCB *tmp_gencb = (gencb); \ 		tmp_gencb->ver = 2; \ 		tmp_gencb->arg = (cb_arg); \ 		tmp_gencb->cb.cb_2 = (callback); }
define|#
directive|define
name|BN_prime_checks
value|0
comment|/* default: select number of iterations 			     based on the size of the number */
comment|/* number of Miller-Rabin iterations for an error rate  of less than 2^-80  * for random 'b'-bit input, b>= 100 (taken from table 4.4 in the Handbook  * of Applied Cryptography [Menezes, van Oorschot, Vanstone; CRC Press 1996];  * original paper: Damgaard, Landrock, Pomerance: Average case error estimates  * for the strong probable prime test. -- Math. Comp. 61 (1993) 177-194) */
define|#
directive|define
name|BN_prime_checks_for_size
parameter_list|(
name|b
parameter_list|)
value|((b)>= 1300 ?  2 : \                                 (b)>=  850 ?  3 : \                                 (b)>=  650 ?  4 : \                                 (b)>=  550 ?  5 : \                                 (b)>=  450 ?  6 : \                                 (b)>=  400 ?  7 : \                                 (b)>=  350 ?  8 : \                                 (b)>=  300 ?  9 : \                                 (b)>=  250 ? 12 : \                                 (b)>=  200 ? 15 : \                                 (b)>=  150 ? 18 : \
comment|/* b>= 100 */
value|27)
define|#
directive|define
name|BN_num_bytes
parameter_list|(
name|a
parameter_list|)
value|((BN_num_bits(a)+7)/8)
comment|/* Note that BN_abs_is_word didn't work reliably for w == 0 until 0.9.8 */
define|#
directive|define
name|BN_abs_is_word
parameter_list|(
name|a
parameter_list|,
name|w
parameter_list|)
value|((((a)->top == 1)&& ((a)->d[0] == (BN_ULONG)(w))) || \ 				(((w) == 0)&& ((a)->top == 0)))
define|#
directive|define
name|BN_is_zero
parameter_list|(
name|a
parameter_list|)
value|((a)->top == 0)
define|#
directive|define
name|BN_is_one
parameter_list|(
name|a
parameter_list|)
value|(BN_abs_is_word((a),1)&& !(a)->neg)
define|#
directive|define
name|BN_is_word
parameter_list|(
name|a
parameter_list|,
name|w
parameter_list|)
value|(BN_abs_is_word((a),(w))&& (!(w) || !(a)->neg))
define|#
directive|define
name|BN_is_odd
parameter_list|(
name|a
parameter_list|)
value|(((a)->top> 0)&& ((a)->d[0]& 1))
define|#
directive|define
name|BN_one
parameter_list|(
name|a
parameter_list|)
value|(BN_set_word((a),1))
define|#
directive|define
name|BN_zero_ex
parameter_list|(
name|a
parameter_list|)
define|\
value|do { \ 		BIGNUM *_tmp_bn = (a); \ 		_tmp_bn->top = 0; \ 		_tmp_bn->neg = 0; \ 	} while(0)
ifdef|#
directive|ifdef
name|OPENSSL_NO_DEPRECATED
define|#
directive|define
name|BN_zero
parameter_list|(
name|a
parameter_list|)
value|BN_zero_ex(a)
else|#
directive|else
define|#
directive|define
name|BN_zero
parameter_list|(
name|a
parameter_list|)
value|(BN_set_word((a),0))
endif|#
directive|endif
specifier|const
name|BIGNUM
modifier|*
name|BN_value_one
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|char
modifier|*
name|BN_options
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|BN_CTX
modifier|*
name|BN_CTX_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_DEPRECATED
name|void
name|BN_CTX_init
parameter_list|(
name|BN_CTX
modifier|*
name|c
parameter_list|)
function_decl|;
endif|#
directive|endif
name|void
name|BN_CTX_free
parameter_list|(
name|BN_CTX
modifier|*
name|c
parameter_list|)
function_decl|;
name|void
name|BN_CTX_start
parameter_list|(
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|BIGNUM
modifier|*
name|BN_CTX_get
parameter_list|(
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|void
name|BN_CTX_end
parameter_list|(
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_rand
parameter_list|(
name|BIGNUM
modifier|*
name|rnd
parameter_list|,
name|int
name|bits
parameter_list|,
name|int
name|top
parameter_list|,
name|int
name|bottom
parameter_list|)
function_decl|;
name|int
name|BN_pseudo_rand
parameter_list|(
name|BIGNUM
modifier|*
name|rnd
parameter_list|,
name|int
name|bits
parameter_list|,
name|int
name|top
parameter_list|,
name|int
name|bottom
parameter_list|)
function_decl|;
name|int
name|BN_rand_range
parameter_list|(
name|BIGNUM
modifier|*
name|rnd
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|range
parameter_list|)
function_decl|;
name|int
name|BN_pseudo_rand_range
parameter_list|(
name|BIGNUM
modifier|*
name|rnd
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|range
parameter_list|)
function_decl|;
name|int
name|BN_num_bits
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|)
function_decl|;
name|int
name|BN_num_bits_word
parameter_list|(
name|BN_ULONG
parameter_list|)
function_decl|;
name|BIGNUM
modifier|*
name|BN_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|BN_init
parameter_list|(
name|BIGNUM
modifier|*
parameter_list|)
function_decl|;
name|void
name|BN_clear_free
parameter_list|(
name|BIGNUM
modifier|*
name|a
parameter_list|)
function_decl|;
name|BIGNUM
modifier|*
name|BN_copy
parameter_list|(
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|)
function_decl|;
name|void
name|BN_swap
parameter_list|(
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|BIGNUM
modifier|*
name|b
parameter_list|)
function_decl|;
name|BIGNUM
modifier|*
name|BN_bin2bn
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|,
name|BIGNUM
modifier|*
name|ret
parameter_list|)
function_decl|;
name|int
name|BN_bn2bin
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|)
function_decl|;
name|BIGNUM
modifier|*
name|BN_mpi2bn
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|,
name|BIGNUM
modifier|*
name|ret
parameter_list|)
function_decl|;
name|int
name|BN_bn2mpi
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|)
function_decl|;
name|int
name|BN_sub
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|)
function_decl|;
name|int
name|BN_usub
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|)
function_decl|;
name|int
name|BN_uadd
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|)
function_decl|;
name|int
name|BN_add
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|)
function_decl|;
name|int
name|BN_mul
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_sqr
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/** BN_set_negative sets sign of a BIGNUM  * \param  b  pointer to the BIGNUM object  * \param  n  0 if the BIGNUM b should be positive and a value != 0 otherwise   */
name|void
name|BN_set_negative
parameter_list|(
name|BIGNUM
modifier|*
name|b
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
comment|/** BN_is_negative returns 1 if the BIGNUM is negative  * \param  a  pointer to the BIGNUM object  * \return 1 if a< 0 and 0 otherwise  */
define|#
directive|define
name|BN_is_negative
parameter_list|(
name|a
parameter_list|)
value|((a)->neg != 0)
name|int
name|BN_div
parameter_list|(
name|BIGNUM
modifier|*
name|dv
parameter_list|,
name|BIGNUM
modifier|*
name|rem
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|d
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
define|#
directive|define
name|BN_mod
parameter_list|(
name|rem
parameter_list|,
name|m
parameter_list|,
name|d
parameter_list|,
name|ctx
parameter_list|)
value|BN_div(NULL,(rem),(m),(d),(ctx))
name|int
name|BN_nnmod
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|d
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_mod_add
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_mod_add_quick
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|)
function_decl|;
name|int
name|BN_mod_sub
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_mod_sub_quick
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|)
function_decl|;
name|int
name|BN_mod_mul
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_mod_sqr
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_mod_lshift1
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_mod_lshift1_quick
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|)
function_decl|;
name|int
name|BN_mod_lshift
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_mod_lshift_quick
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|)
function_decl|;
name|BN_ULONG
name|BN_mod_word
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|BN_ULONG
name|w
parameter_list|)
function_decl|;
name|BN_ULONG
name|BN_div_word
parameter_list|(
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|BN_ULONG
name|w
parameter_list|)
function_decl|;
name|int
name|BN_mul_word
parameter_list|(
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|BN_ULONG
name|w
parameter_list|)
function_decl|;
name|int
name|BN_add_word
parameter_list|(
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|BN_ULONG
name|w
parameter_list|)
function_decl|;
name|int
name|BN_sub_word
parameter_list|(
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|BN_ULONG
name|w
parameter_list|)
function_decl|;
name|int
name|BN_set_word
parameter_list|(
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|BN_ULONG
name|w
parameter_list|)
function_decl|;
name|BN_ULONG
name|BN_get_word
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|)
function_decl|;
name|int
name|BN_cmp
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|)
function_decl|;
name|void
name|BN_free
parameter_list|(
name|BIGNUM
modifier|*
name|a
parameter_list|)
function_decl|;
name|int
name|BN_is_bit_set
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|int
name|BN_lshift
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|int
name|BN_lshift1
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|)
function_decl|;
name|int
name|BN_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_mod_exp_mont
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
function_decl|;
name|int
name|BN_mod_exp_mont_consttime
parameter_list|(
name|BIGNUM
modifier|*
name|rr
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|in_mont
parameter_list|)
function_decl|;
name|int
name|BN_mod_exp_mont_word
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
name|BN_ULONG
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
function_decl|;
name|int
name|BN_mod_exp2_mont
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a1
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p1
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a2
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p2
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
function_decl|;
name|int
name|BN_mod_exp_simple
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_mask_bits
parameter_list|(
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_FP_API
name|int
name|BN_print_fp
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|)
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HEADER_BIO_H
name|int
name|BN_print
parameter_list|(
name|BIO
modifier|*
name|fp
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|)
function_decl|;
else|#
directive|else
name|int
name|BN_print
parameter_list|(
name|void
modifier|*
name|fp
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|)
function_decl|;
endif|#
directive|endif
name|int
name|BN_reciprocal
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|int
name|len
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_rshift
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|int
name|BN_rshift1
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|)
function_decl|;
name|void
name|BN_clear
parameter_list|(
name|BIGNUM
modifier|*
name|a
parameter_list|)
function_decl|;
name|BIGNUM
modifier|*
name|BN_dup
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|)
function_decl|;
name|int
name|BN_ucmp
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|)
function_decl|;
name|int
name|BN_set_bit
parameter_list|(
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|int
name|BN_clear_bit
parameter_list|(
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|char
modifier|*
name|BN_bn2hex
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|)
function_decl|;
name|char
modifier|*
name|BN_bn2dec
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|)
function_decl|;
name|int
name|BN_hex2bn
parameter_list|(
name|BIGNUM
modifier|*
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
name|int
name|BN_dec2bn
parameter_list|(
name|BIGNUM
modifier|*
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
name|int
name|BN_asc2bn
parameter_list|(
name|BIGNUM
modifier|*
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
name|int
name|BN_gcd
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_kronecker
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* returns -2 for error */
name|BIGNUM
modifier|*
name|BN_mod_inverse
parameter_list|(
name|BIGNUM
modifier|*
name|ret
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|n
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|BIGNUM
modifier|*
name|BN_mod_sqrt
parameter_list|(
name|BIGNUM
modifier|*
name|ret
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|n
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|void
name|BN_consttime_swap
parameter_list|(
name|BN_ULONG
name|swap
parameter_list|,
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|BIGNUM
modifier|*
name|b
parameter_list|,
name|int
name|nwords
parameter_list|)
function_decl|;
comment|/* Deprecated versions */
ifndef|#
directive|ifndef
name|OPENSSL_NO_DEPRECATED
name|BIGNUM
modifier|*
name|BN_generate_prime
parameter_list|(
name|BIGNUM
modifier|*
name|ret
parameter_list|,
name|int
name|bits
parameter_list|,
name|int
name|safe
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|add
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|rem
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
function_decl|;
name|int
name|BN_is_prime
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|int
name|nchecks
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
function_decl|;
name|int
name|BN_is_prime_fasttest
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|int
name|nchecks
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|,
name|int
name|do_trial_division
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* !defined(OPENSSL_NO_DEPRECATED) */
comment|/* Newer versions */
name|int
name|BN_generate_prime_ex
parameter_list|(
name|BIGNUM
modifier|*
name|ret
parameter_list|,
name|int
name|bits
parameter_list|,
name|int
name|safe
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|add
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|rem
parameter_list|,
name|BN_GENCB
modifier|*
name|cb
parameter_list|)
function_decl|;
name|int
name|BN_is_prime_ex
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|int
name|nchecks
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_GENCB
modifier|*
name|cb
parameter_list|)
function_decl|;
name|int
name|BN_is_prime_fasttest_ex
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|int
name|nchecks
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|int
name|do_trial_division
parameter_list|,
name|BN_GENCB
modifier|*
name|cb
parameter_list|)
function_decl|;
name|int
name|BN_X931_generate_Xpq
parameter_list|(
name|BIGNUM
modifier|*
name|Xp
parameter_list|,
name|BIGNUM
modifier|*
name|Xq
parameter_list|,
name|int
name|nbits
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_X931_derive_prime_ex
parameter_list|(
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BIGNUM
modifier|*
name|p1
parameter_list|,
name|BIGNUM
modifier|*
name|p2
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|Xp
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|Xp1
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|Xp2
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|e
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_GENCB
modifier|*
name|cb
parameter_list|)
function_decl|;
name|int
name|BN_X931_generate_prime_ex
parameter_list|(
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BIGNUM
modifier|*
name|p1
parameter_list|,
name|BIGNUM
modifier|*
name|p2
parameter_list|,
name|BIGNUM
modifier|*
name|Xp1
parameter_list|,
name|BIGNUM
modifier|*
name|Xp2
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|Xp
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|e
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_GENCB
modifier|*
name|cb
parameter_list|)
function_decl|;
name|BN_MONT_CTX
modifier|*
name|BN_MONT_CTX_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|BN_MONT_CTX_init
parameter_list|(
name|BN_MONT_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_mod_mul_montgomery
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|mont
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
define|#
directive|define
name|BN_to_montgomery
parameter_list|(
name|r
parameter_list|,
name|a
parameter_list|,
name|mont
parameter_list|,
name|ctx
parameter_list|)
value|BN_mod_mul_montgomery(\ 	(r),(a),&((mont)->RR),(mont),(ctx))
name|int
name|BN_from_montgomery
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|mont
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|void
name|BN_MONT_CTX_free
parameter_list|(
name|BN_MONT_CTX
modifier|*
name|mont
parameter_list|)
function_decl|;
name|int
name|BN_MONT_CTX_set
parameter_list|(
name|BN_MONT_CTX
modifier|*
name|mont
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|mod
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|BN_MONT_CTX
modifier|*
name|BN_MONT_CTX_copy
parameter_list|(
name|BN_MONT_CTX
modifier|*
name|to
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|from
parameter_list|)
function_decl|;
name|BN_MONT_CTX
modifier|*
name|BN_MONT_CTX_set_locked
parameter_list|(
name|BN_MONT_CTX
modifier|*
modifier|*
name|pmont
parameter_list|,
name|int
name|lock
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|mod
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* BN_BLINDING flags */
define|#
directive|define
name|BN_BLINDING_NO_UPDATE
value|0x00000001
define|#
directive|define
name|BN_BLINDING_NO_RECREATE
value|0x00000002
name|BN_BLINDING
modifier|*
name|BN_BLINDING_new
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|A
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|Ai
parameter_list|,
name|BIGNUM
modifier|*
name|mod
parameter_list|)
function_decl|;
name|void
name|BN_BLINDING_free
parameter_list|(
name|BN_BLINDING
modifier|*
name|b
parameter_list|)
function_decl|;
name|int
name|BN_BLINDING_update
parameter_list|(
name|BN_BLINDING
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_BLINDING_convert
parameter_list|(
name|BIGNUM
modifier|*
name|n
parameter_list|,
name|BN_BLINDING
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_BLINDING_invert
parameter_list|(
name|BIGNUM
modifier|*
name|n
parameter_list|,
name|BN_BLINDING
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_BLINDING_convert_ex
parameter_list|(
name|BIGNUM
modifier|*
name|n
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
name|BN_BLINDING
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
parameter_list|)
function_decl|;
name|int
name|BN_BLINDING_invert_ex
parameter_list|(
name|BIGNUM
modifier|*
name|n
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|r
parameter_list|,
name|BN_BLINDING
modifier|*
name|b
parameter_list|,
name|BN_CTX
modifier|*
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_DEPRECATED
name|unsigned
name|long
name|BN_BLINDING_get_thread_id
parameter_list|(
specifier|const
name|BN_BLINDING
modifier|*
parameter_list|)
function_decl|;
name|void
name|BN_BLINDING_set_thread_id
parameter_list|(
name|BN_BLINDING
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
endif|#
directive|endif
name|CRYPTO_THREADID
modifier|*
name|BN_BLINDING_thread_id
parameter_list|(
name|BN_BLINDING
modifier|*
parameter_list|)
function_decl|;
name|unsigned
name|long
name|BN_BLINDING_get_flags
parameter_list|(
specifier|const
name|BN_BLINDING
modifier|*
parameter_list|)
function_decl|;
name|void
name|BN_BLINDING_set_flags
parameter_list|(
name|BN_BLINDING
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
name|BN_BLINDING
modifier|*
name|BN_BLINDING_create_param
parameter_list|(
name|BN_BLINDING
modifier|*
name|b
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|e
parameter_list|,
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|int
function_decl|(
modifier|*
name|bn_mod_exp
function_decl|)
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_DEPRECATED
name|void
name|BN_set_params
parameter_list|(
name|int
name|mul
parameter_list|,
name|int
name|high
parameter_list|,
name|int
name|low
parameter_list|,
name|int
name|mont
parameter_list|)
function_decl|;
name|int
name|BN_get_params
parameter_list|(
name|int
name|which
parameter_list|)
function_decl|;
comment|/* 0, mul, 1 high, 2 low, 3 mont */
endif|#
directive|endif
name|void
name|BN_RECP_CTX_init
parameter_list|(
name|BN_RECP_CTX
modifier|*
name|recp
parameter_list|)
function_decl|;
name|BN_RECP_CTX
modifier|*
name|BN_RECP_CTX_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|BN_RECP_CTX_free
parameter_list|(
name|BN_RECP_CTX
modifier|*
name|recp
parameter_list|)
function_decl|;
name|int
name|BN_RECP_CTX_set
parameter_list|(
name|BN_RECP_CTX
modifier|*
name|recp
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|rdiv
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_mod_mul_reciprocal
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|x
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|y
parameter_list|,
name|BN_RECP_CTX
modifier|*
name|recp
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_mod_exp_recp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_div_recp
parameter_list|(
name|BIGNUM
modifier|*
name|dv
parameter_list|,
name|BIGNUM
modifier|*
name|rem
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_RECP_CTX
modifier|*
name|recp
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC2M
comment|/* Functions for arithmetic over binary polynomials represented by BIGNUMs.   *  * The BIGNUM::neg property of BIGNUMs representing binary polynomials is  * ignored.  *  * Note that input arguments are not const so that their bit arrays can  * be expanded to the appropriate size if needed.  */
name|int
name|BN_GF2m_add
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|)
function_decl|;
comment|/*r = a + b*/
define|#
directive|define
name|BN_GF2m_sub
parameter_list|(
name|r
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|BN_GF2m_add(r, a, b)
name|int
name|BN_GF2m_mod
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|)
function_decl|;
comment|/*r=a mod p*/
name|int
name|BN_GF2m_mod_mul
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* r = (a * b) mod p */
name|int
name|BN_GF2m_mod_sqr
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* r = (a * a) mod p */
name|int
name|BN_GF2m_mod_inv
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* r = (1 / b) mod p */
name|int
name|BN_GF2m_mod_div
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* r = (a / b) mod p */
name|int
name|BN_GF2m_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* r = (a ^ b) mod p */
name|int
name|BN_GF2m_mod_sqrt
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* r = sqrt(a) mod p */
name|int
name|BN_GF2m_mod_solve_quad
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* r^2 + r = a mod p */
define|#
directive|define
name|BN_GF2m_cmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|BN_ucmp((a), (b))
comment|/* Some functions allow for representation of the irreducible polynomials  * as an unsigned int[], say p.  The irreducible f(t) is then of the form:  *     t^p[0] + t^p[1] + ... + t^p[k]  * where m = p[0]> p[1]> ...> p[k] = 0.  */
name|int
name|BN_GF2m_mod_arr
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|int
name|p
index|[]
parameter_list|)
function_decl|;
comment|/* r = a mod p */
name|int
name|BN_GF2m_mod_mul_arr
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
specifier|const
name|int
name|p
index|[]
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* r = (a * b) mod p */
name|int
name|BN_GF2m_mod_sqr_arr
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|int
name|p
index|[]
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* r = (a * a) mod p */
name|int
name|BN_GF2m_mod_inv_arr
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
specifier|const
name|int
name|p
index|[]
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* r = (1 / b) mod p */
name|int
name|BN_GF2m_mod_div_arr
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
specifier|const
name|int
name|p
index|[]
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* r = (a / b) mod p */
name|int
name|BN_GF2m_mod_exp_arr
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|b
parameter_list|,
specifier|const
name|int
name|p
index|[]
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* r = (a ^ b) mod p */
name|int
name|BN_GF2m_mod_sqrt_arr
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|int
name|p
index|[]
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* r = sqrt(a) mod p */
name|int
name|BN_GF2m_mod_solve_quad_arr
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|int
name|p
index|[]
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/* r^2 + r = a mod p */
name|int
name|BN_GF2m_poly2arr
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|int
name|p
index|[]
parameter_list|,
name|int
name|max
parameter_list|)
function_decl|;
name|int
name|BN_GF2m_arr2poly
parameter_list|(
specifier|const
name|int
name|p
index|[]
parameter_list|,
name|BIGNUM
modifier|*
name|a
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* faster mod functions for the 'NIST primes'   * 0<= a< p^2 */
name|int
name|BN_nist_mod_192
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_nist_mod_224
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_nist_mod_256
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_nist_mod_384
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
name|int
name|BN_nist_mod_521
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
specifier|const
name|BIGNUM
modifier|*
name|BN_get0_nist_prime_192
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|const
name|BIGNUM
modifier|*
name|BN_get0_nist_prime_224
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|const
name|BIGNUM
modifier|*
name|BN_get0_nist_prime_256
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|const
name|BIGNUM
modifier|*
name|BN_get0_nist_prime_384
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|const
name|BIGNUM
modifier|*
name|BN_get0_nist_prime_521
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* library internal functions */
define|#
directive|define
name|bn_expand
parameter_list|(
name|a
parameter_list|,
name|bits
parameter_list|)
value|((((((bits+BN_BITS2-1))/BN_BITS2))<= (a)->dmax)?\ 	(a):bn_expand2((a),(bits+BN_BITS2-1)/BN_BITS2))
define|#
directive|define
name|bn_wexpand
parameter_list|(
name|a
parameter_list|,
name|words
parameter_list|)
value|(((words)<= (a)->dmax)?(a):bn_expand2((a),(words)))
name|BIGNUM
modifier|*
name|bn_expand2
parameter_list|(
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|int
name|words
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_DEPRECATED
name|BIGNUM
modifier|*
name|bn_dup_expand
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
name|int
name|words
parameter_list|)
function_decl|;
comment|/* unused */
endif|#
directive|endif
comment|/* Bignum consistency macros  * There is one "API" macro, bn_fix_top(), for stripping leading zeroes from  * bignum data after direct manipulations on the data. There is also an  * "internal" macro, bn_check_top(), for verifying that there are no leading  * zeroes. Unfortunately, some auditing is required due to the fact that  * bn_fix_top() has become an overabused duct-tape because bignum data is  * occasionally passed around in an inconsistent state. So the following  * changes have been made to sort this out;  * - bn_fix_top()s implementation has been moved to bn_correct_top()  * - if BN_DEBUG isn't defined, bn_fix_top() maps to bn_correct_top(), and  *   bn_check_top() is as before.  * - if BN_DEBUG *is* defined;  *   - bn_check_top() tries to pollute unused words even if the bignum 'top' is  *     consistent. (ed: only if BN_DEBUG_RAND is defined)  *   - bn_fix_top() maps to bn_check_top() rather than "fixing" anything.  * The idea is to have debug builds flag up inconsistent bignums when they  * occur. If that occurs in a bn_fix_top(), we examine the code in question; if  * the use of bn_fix_top() was appropriate (ie. it follows directly after code  * that manipulates the bignum) it is converted to bn_correct_top(), and if it  * was not appropriate, we convert it permanently to bn_check_top() and track  * down the cause of the bug. Eventually, no internal code should be using the  * bn_fix_top() macro. External applications and libraries should try this with  * their own code too, both in terms of building against the openssl headers  * with BN_DEBUG defined *and* linking with a version of OpenSSL built with it  * defined. This not only improves external code, it provides more test  * coverage for openssl's own code.  */
ifdef|#
directive|ifdef
name|BN_DEBUG
comment|/* We only need assert() when debugging */
include|#
directive|include
file|<assert.h>
ifdef|#
directive|ifdef
name|BN_DEBUG_RAND
comment|/* To avoid "make update" cvs wars due to BN_DEBUG, use some tricks */
ifndef|#
directive|ifndef
name|RAND_pseudo_bytes
name|int
name|RAND_pseudo_bytes
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
define|#
directive|define
name|BN_DEBUG_TRIX
endif|#
directive|endif
define|#
directive|define
name|bn_pollute
parameter_list|(
name|a
parameter_list|)
define|\
value|do { \ 		const BIGNUM *_bnum1 = (a); \ 		if(_bnum1->top< _bnum1->dmax) { \ 			unsigned char _tmp_char; \
comment|/* We cast away const without the compiler knowing, any \ 			 * *genuinely* constant variables that aren't mutable \ 			 * wouldn't be constructed with top!=dmax. */
value|\ 			BN_ULONG *_not_const; \ 			memcpy(&_not_const,&_bnum1->d, sizeof(BN_ULONG*)); \ 			RAND_pseudo_bytes(&_tmp_char, 1); \ 			memset((unsigned char *)(_not_const + _bnum1->top), _tmp_char, \ 				(_bnum1->dmax - _bnum1->top) * sizeof(BN_ULONG)); \ 		} \ 	} while(0)
ifdef|#
directive|ifdef
name|BN_DEBUG_TRIX
undef|#
directive|undef
name|RAND_pseudo_bytes
endif|#
directive|endif
else|#
directive|else
define|#
directive|define
name|bn_pollute
parameter_list|(
name|a
parameter_list|)
endif|#
directive|endif
define|#
directive|define
name|bn_check_top
parameter_list|(
name|a
parameter_list|)
define|\
value|do { \ 		const BIGNUM *_bnum2 = (a); \ 		if (_bnum2 != NULL) { \ 			assert((_bnum2->top == 0) || \ 				(_bnum2->d[_bnum2->top - 1] != 0)); \ 			bn_pollute(_bnum2); \ 		} \ 	} while(0)
define|#
directive|define
name|bn_fix_top
parameter_list|(
name|a
parameter_list|)
value|bn_check_top(a)
define|#
directive|define
name|bn_check_size
parameter_list|(
name|bn
parameter_list|,
name|bits
parameter_list|)
value|bn_wcheck_size(bn, ((bits+BN_BITS2-1))/BN_BITS2)
define|#
directive|define
name|bn_wcheck_size
parameter_list|(
name|bn
parameter_list|,
name|words
parameter_list|)
define|\
value|do { \ 		const BIGNUM *_bnum2 = (bn); \ 		assert(words<= (_bnum2)->dmax&& words>= (_bnum2)->top); \ 	} while(0)
else|#
directive|else
comment|/* !BN_DEBUG */
define|#
directive|define
name|bn_pollute
parameter_list|(
name|a
parameter_list|)
define|#
directive|define
name|bn_check_top
parameter_list|(
name|a
parameter_list|)
define|#
directive|define
name|bn_fix_top
parameter_list|(
name|a
parameter_list|)
value|bn_correct_top(a)
define|#
directive|define
name|bn_check_size
parameter_list|(
name|bn
parameter_list|,
name|bits
parameter_list|)
define|#
directive|define
name|bn_wcheck_size
parameter_list|(
name|bn
parameter_list|,
name|words
parameter_list|)
endif|#
directive|endif
define|#
directive|define
name|bn_correct_top
parameter_list|(
name|a
parameter_list|)
define|\
value|{ \         BN_ULONG *ftl; \ 	int tmp_top = (a)->top; \ 	if (tmp_top> 0) \ 		{ \ 		for (ftl=&((a)->d[tmp_top-1]); tmp_top> 0; tmp_top--) \ 			if (*(ftl--)) break; \ 		(a)->top = tmp_top; \ 		} \ 	bn_pollute(a); \ 	}
name|BN_ULONG
name|bn_mul_add_words
parameter_list|(
name|BN_ULONG
modifier|*
name|rp
parameter_list|,
specifier|const
name|BN_ULONG
modifier|*
name|ap
parameter_list|,
name|int
name|num
parameter_list|,
name|BN_ULONG
name|w
parameter_list|)
function_decl|;
name|BN_ULONG
name|bn_mul_words
parameter_list|(
name|BN_ULONG
modifier|*
name|rp
parameter_list|,
specifier|const
name|BN_ULONG
modifier|*
name|ap
parameter_list|,
name|int
name|num
parameter_list|,
name|BN_ULONG
name|w
parameter_list|)
function_decl|;
name|void
name|bn_sqr_words
parameter_list|(
name|BN_ULONG
modifier|*
name|rp
parameter_list|,
specifier|const
name|BN_ULONG
modifier|*
name|ap
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
name|BN_ULONG
name|bn_div_words
parameter_list|(
name|BN_ULONG
name|h
parameter_list|,
name|BN_ULONG
name|l
parameter_list|,
name|BN_ULONG
name|d
parameter_list|)
function_decl|;
name|BN_ULONG
name|bn_add_words
parameter_list|(
name|BN_ULONG
modifier|*
name|rp
parameter_list|,
specifier|const
name|BN_ULONG
modifier|*
name|ap
parameter_list|,
specifier|const
name|BN_ULONG
modifier|*
name|bp
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
name|BN_ULONG
name|bn_sub_words
parameter_list|(
name|BN_ULONG
modifier|*
name|rp
parameter_list|,
specifier|const
name|BN_ULONG
modifier|*
name|ap
parameter_list|,
specifier|const
name|BN_ULONG
modifier|*
name|bp
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
comment|/* Primes from RFC 2409 */
name|BIGNUM
modifier|*
name|get_rfc2409_prime_768
parameter_list|(
name|BIGNUM
modifier|*
name|bn
parameter_list|)
function_decl|;
name|BIGNUM
modifier|*
name|get_rfc2409_prime_1024
parameter_list|(
name|BIGNUM
modifier|*
name|bn
parameter_list|)
function_decl|;
comment|/* Primes from RFC 3526 */
name|BIGNUM
modifier|*
name|get_rfc3526_prime_1536
parameter_list|(
name|BIGNUM
modifier|*
name|bn
parameter_list|)
function_decl|;
name|BIGNUM
modifier|*
name|get_rfc3526_prime_2048
parameter_list|(
name|BIGNUM
modifier|*
name|bn
parameter_list|)
function_decl|;
name|BIGNUM
modifier|*
name|get_rfc3526_prime_3072
parameter_list|(
name|BIGNUM
modifier|*
name|bn
parameter_list|)
function_decl|;
name|BIGNUM
modifier|*
name|get_rfc3526_prime_4096
parameter_list|(
name|BIGNUM
modifier|*
name|bn
parameter_list|)
function_decl|;
name|BIGNUM
modifier|*
name|get_rfc3526_prime_6144
parameter_list|(
name|BIGNUM
modifier|*
name|bn
parameter_list|)
function_decl|;
name|BIGNUM
modifier|*
name|get_rfc3526_prime_8192
parameter_list|(
name|BIGNUM
modifier|*
name|bn
parameter_list|)
function_decl|;
name|int
name|BN_bntest_rand
parameter_list|(
name|BIGNUM
modifier|*
name|rnd
parameter_list|,
name|int
name|bits
parameter_list|,
name|int
name|top
parameter_list|,
name|int
name|bottom
parameter_list|)
function_decl|;
comment|/* BEGIN ERROR CODES */
comment|/* The following lines are auto generated by the script mkerr.pl. Any changes  * made after this point may be overwritten when the script is next run.  */
name|void
name|ERR_load_BN_strings
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Error codes for the BN functions. */
comment|/* Function codes. */
define|#
directive|define
name|BN_F_BNRAND
value|127
define|#
directive|define
name|BN_F_BN_BLINDING_CONVERT_EX
value|100
define|#
directive|define
name|BN_F_BN_BLINDING_CREATE_PARAM
value|128
define|#
directive|define
name|BN_F_BN_BLINDING_INVERT_EX
value|101
define|#
directive|define
name|BN_F_BN_BLINDING_NEW
value|102
define|#
directive|define
name|BN_F_BN_BLINDING_UPDATE
value|103
define|#
directive|define
name|BN_F_BN_BN2DEC
value|104
define|#
directive|define
name|BN_F_BN_BN2HEX
value|105
define|#
directive|define
name|BN_F_BN_CTX_GET
value|116
define|#
directive|define
name|BN_F_BN_CTX_NEW
value|106
define|#
directive|define
name|BN_F_BN_CTX_START
value|129
define|#
directive|define
name|BN_F_BN_DIV
value|107
define|#
directive|define
name|BN_F_BN_DIV_NO_BRANCH
value|138
define|#
directive|define
name|BN_F_BN_DIV_RECP
value|130
define|#
directive|define
name|BN_F_BN_EXP
value|123
define|#
directive|define
name|BN_F_BN_EXPAND2
value|108
define|#
directive|define
name|BN_F_BN_EXPAND_INTERNAL
value|120
define|#
directive|define
name|BN_F_BN_GF2M_MOD
value|131
define|#
directive|define
name|BN_F_BN_GF2M_MOD_EXP
value|132
define|#
directive|define
name|BN_F_BN_GF2M_MOD_MUL
value|133
define|#
directive|define
name|BN_F_BN_GF2M_MOD_SOLVE_QUAD
value|134
define|#
directive|define
name|BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR
value|135
define|#
directive|define
name|BN_F_BN_GF2M_MOD_SQR
value|136
define|#
directive|define
name|BN_F_BN_GF2M_MOD_SQRT
value|137
define|#
directive|define
name|BN_F_BN_MOD_EXP2_MONT
value|118
define|#
directive|define
name|BN_F_BN_MOD_EXP_MONT
value|109
define|#
directive|define
name|BN_F_BN_MOD_EXP_MONT_CONSTTIME
value|124
define|#
directive|define
name|BN_F_BN_MOD_EXP_MONT_WORD
value|117
define|#
directive|define
name|BN_F_BN_MOD_EXP_RECP
value|125
define|#
directive|define
name|BN_F_BN_MOD_EXP_SIMPLE
value|126
define|#
directive|define
name|BN_F_BN_MOD_INVERSE
value|110
define|#
directive|define
name|BN_F_BN_MOD_INVERSE_NO_BRANCH
value|139
define|#
directive|define
name|BN_F_BN_MOD_LSHIFT_QUICK
value|119
define|#
directive|define
name|BN_F_BN_MOD_MUL_RECIPROCAL
value|111
define|#
directive|define
name|BN_F_BN_MOD_SQRT
value|121
define|#
directive|define
name|BN_F_BN_MPI2BN
value|112
define|#
directive|define
name|BN_F_BN_NEW
value|113
define|#
directive|define
name|BN_F_BN_RAND
value|114
define|#
directive|define
name|BN_F_BN_RAND_RANGE
value|122
define|#
directive|define
name|BN_F_BN_USUB
value|115
comment|/* Reason codes. */
define|#
directive|define
name|BN_R_ARG2_LT_ARG3
value|100
define|#
directive|define
name|BN_R_BAD_RECIPROCAL
value|101
define|#
directive|define
name|BN_R_BIGNUM_TOO_LONG
value|114
define|#
directive|define
name|BN_R_CALLED_WITH_EVEN_MODULUS
value|102
define|#
directive|define
name|BN_R_DIV_BY_ZERO
value|103
define|#
directive|define
name|BN_R_ENCODING_ERROR
value|104
define|#
directive|define
name|BN_R_EXPAND_ON_STATIC_BIGNUM_DATA
value|105
define|#
directive|define
name|BN_R_INPUT_NOT_REDUCED
value|110
define|#
directive|define
name|BN_R_INVALID_LENGTH
value|106
define|#
directive|define
name|BN_R_INVALID_RANGE
value|115
define|#
directive|define
name|BN_R_NOT_A_SQUARE
value|111
define|#
directive|define
name|BN_R_NOT_INITIALIZED
value|107
define|#
directive|define
name|BN_R_NO_INVERSE
value|108
define|#
directive|define
name|BN_R_NO_SOLUTION
value|116
define|#
directive|define
name|BN_R_P_IS_NOT_PRIME
value|112
define|#
directive|define
name|BN_R_TOO_MANY_ITERATIONS
value|113
define|#
directive|define
name|BN_R_TOO_MANY_TEMPORARY_VARIABLES
value|109
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

