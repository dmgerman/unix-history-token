begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/bn/bn_mod.c */
end_comment

begin_comment
comment|/* Written by Lenka Fibikova<fibikova@exp-math.uni-essen.de>  * and Bodo Moeller for the OpenSSL project. */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|"bn_lcl.h"
end_include

begin_function
name|BIGNUM
modifier|*
name|BN_mod_sqrt
parameter_list|(
name|BIGNUM
modifier|*
name|in
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
comment|/* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, "A Course  * in Algebraic Computational Number Theory", algorithm 1.5.1).  * 'p' must be prime!  * If 'a' is not a square, this is not necessarily detected by  * the algorithms; a bogus result must be expected in this case.  */
block|{
name|BIGNUM
modifier|*
name|ret
init|=
name|in
decl_stmt|;
name|int
name|err
init|=
literal|1
decl_stmt|;
name|int
name|r
decl_stmt|;
name|BIGNUM
modifier|*
name|b
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|int
name|e
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|BN_is_odd
argument_list|(
name|p
argument_list|)
operator|||
name|BN_abs_is_word
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|BN_abs_is_word
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_set_word
argument_list|(
name|ret
argument_list|,
name|BN_is_bit_set
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|BN_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
name|BNerr
argument_list|(
name|BN_F_BN_MOD_SQRT
argument_list|,
name|BN_R_P_IS_NOT_PRIME
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|BN_is_zero
argument_list|(
name|a
argument_list|)
operator|||
name|BN_is_one
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_set_word
argument_list|(
name|ret
argument_list|,
name|BN_is_one
argument_list|(
name|a
argument_list|)
argument_list|)
condition|)
block|{
name|BN_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
if|#
directive|if
literal|0
comment|/* if BN_mod_sqrt is used with correct input, this just wastes time */
block|r = BN_kronecker(a, p, ctx); 	if (r< -1) return NULL; 	if (r == -1) 		{ 		BNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); 		return(NULL); 		}
endif|#
directive|endif
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|b
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|q
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|t
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|x
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|y
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
comment|/* now write  |p| - 1  as  2^e*q  where  q  is odd */
name|e
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|BN_is_bit_set
argument_list|(
name|p
argument_list|,
name|e
argument_list|)
condition|)
name|e
operator|++
expr_stmt|;
comment|/* we'll set  q  later (if needed) */
if|if
condition|(
name|e
operator|==
literal|1
condition|)
block|{
comment|/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse 		 * modulo  (|p|-1)/2,  and square roots can be computed 		 * directly by modular exponentiation. 		 * We have 		 *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), 		 * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. 		 */
if|if
condition|(
operator|!
name|BN_rshift
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|q
operator|->
name|neg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|BN_add_word
argument_list|(
name|q
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_mod_exp
argument_list|(
name|ret
argument_list|,
name|a
argument_list|,
name|q
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|e
operator|==
literal|2
condition|)
block|{
comment|/* |p| == 5  (mod 8) 		 * 		 * In this case  2  is always a non-square since 		 * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. 		 * So if  a  really is a square, then  2*a  is a non-square. 		 * Thus for 		 *      b := (2*a)^((|p|-5)/8), 		 *      i := (2*a)*b^2 		 * we have 		 *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) 		 *         = (2*a)^((p-1)/2) 		 *         = -1; 		 * so if we set 		 *      x := a*b*(i-1), 		 * then 		 *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) 		 *         = a^2 * b^2 * (-2*i) 		 *         = a*(-i)*(2*a*b^2) 		 *         = a*(-i)*i 		 *         = a. 		 * 		 * (This is due to A.O.L. Atkin,  		 *<URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, 		 * November 1992.) 		 */
comment|/* make sure that  a  is reduced modulo p */
if|if
condition|(
name|a
operator|->
name|neg
operator|||
name|BN_ucmp
argument_list|(
name|a
argument_list|,
name|p
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|BN_nnmod
argument_list|(
name|x
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|a
operator|=
name|x
expr_stmt|;
comment|/* use x as temporary variable */
block|}
comment|/* t := 2*a */
if|if
condition|(
operator|!
name|BN_mod_lshift1_quick
argument_list|(
name|t
argument_list|,
name|a
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* b := (2*a)^((|p|-5)/8) */
if|if
condition|(
operator|!
name|BN_rshift
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|q
operator|->
name|neg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|BN_mod_exp
argument_list|(
name|b
argument_list|,
name|t
argument_list|,
name|q
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* y := b^2 */
if|if
condition|(
operator|!
name|BN_mod_sqr
argument_list|(
name|y
argument_list|,
name|b
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* t := (2*a)*b^2 - 1*/
if|if
condition|(
operator|!
name|BN_mod_mul
argument_list|(
name|t
argument_list|,
name|t
argument_list|,
name|y
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_sub_word
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* x = a*b*t */
if|if
condition|(
operator|!
name|BN_mod_mul
argument_list|(
name|x
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_mod_mul
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|t
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|ret
argument_list|,
name|x
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* e> 2, so we really have to use the Tonelli/Shanks algorithm. 	 * First, find some  y  that is not a square. */
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* use 'q' as temp */
name|q
operator|->
name|neg
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|2
expr_stmt|;
do|do
block|{
comment|/* For efficiency, try small numbers first; 		 * if this fails, try random numbers. 		 */
if|if
condition|(
name|i
operator|<
literal|22
condition|)
block|{
if|if
condition|(
operator|!
name|BN_set_word
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
goto|goto
name|end
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|BN_pseudo_rand
argument_list|(
name|y
argument_list|,
name|BN_num_bits
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|BN_ucmp
argument_list|(
name|y
argument_list|,
name|p
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|neg
condition|?
name|BN_add
else|:
name|BN_sub
operator|)
operator|(
name|y
operator|,
name|y
operator|,
name|p
operator|)
condition|)
goto|goto
name|end
goto|;
block|}
comment|/* now 0<= y< |p| */
if|if
condition|(
name|BN_is_zero
argument_list|(
name|y
argument_list|)
condition|)
if|if
condition|(
operator|!
name|BN_set_word
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
goto|goto
name|end
goto|;
block|}
name|r
operator|=
name|BN_kronecker
argument_list|(
name|y
argument_list|,
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* here 'q' is |p| */
if|if
condition|(
name|r
operator|<
operator|-
literal|1
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
comment|/* m divides p */
name|BNerr
argument_list|(
name|BN_F_BN_MOD_SQRT
argument_list|,
name|BN_R_P_IS_NOT_PRIME
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
do|while
condition|(
name|r
operator|==
literal|1
operator|&&
operator|++
name|i
operator|<
literal|82
condition|)
do|;
if|if
condition|(
name|r
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Many rounds and still no non-square -- this is more likely 		 * a bug than just bad luck. 		 * Even if  p  is not prime, we should have found some  y 		 * such that r == -1. 		 */
name|BNerr
argument_list|(
name|BN_F_BN_MOD_SQRT
argument_list|,
name|BN_R_TOO_MANY_ITERATIONS
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* Here's our actual 'q': */
if|if
condition|(
operator|!
name|BN_rshift
argument_list|(
name|q
argument_list|,
name|q
argument_list|,
name|e
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* Now that we have some non-square, we can find an element 	 * of order  2^e  by computing its q'th power. */
if|if
condition|(
operator|!
name|BN_mod_exp
argument_list|(
name|y
argument_list|,
name|y
argument_list|,
name|q
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|BN_is_one
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|BNerr
argument_list|(
name|BN_F_BN_MOD_SQRT
argument_list|,
name|BN_R_P_IS_NOT_PRIME
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* Now we know that (if  p  is indeed prime) there is an integer 	 * k,  0<= k< 2^e,  such that 	 * 	 *      a^q * y^k == 1   (mod p). 	 * 	 * As  a^q  is a square and  y  is not,  k  must be even. 	 * q+1  is even, too, so there is an element 	 * 	 *     X := a^((q+1)/2) * y^(k/2), 	 * 	 * and it satisfies 	 * 	 *     X^2 = a^q * a     * y^k 	 *         = a, 	 * 	 * so it is the square root that we are looking for. 	 */
comment|/* t := (q-1)/2  (note that  q  is odd) */
if|if
condition|(
operator|!
name|BN_rshift1
argument_list|(
name|t
argument_list|,
name|q
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* x := a^((q-1)/2) */
if|if
condition|(
name|BN_is_zero
argument_list|(
name|t
argument_list|)
condition|)
comment|/* special case: p = 2^e + 1 */
block|{
if|if
condition|(
operator|!
name|BN_nnmod
argument_list|(
name|t
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|BN_is_zero
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* special case: a == 0  (mod p) */
if|if
condition|(
operator|!
name|BN_zero
argument_list|(
name|ret
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|end
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|BN_one
argument_list|(
name|x
argument_list|)
condition|)
goto|goto
name|end
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|BN_mod_exp
argument_list|(
name|x
argument_list|,
name|a
argument_list|,
name|t
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|BN_is_zero
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* special case: a == 0  (mod p) */
if|if
condition|(
operator|!
name|BN_zero
argument_list|(
name|ret
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
comment|/* b := a*x^2  (= a^q) */
if|if
condition|(
operator|!
name|BN_mod_sqr
argument_list|(
name|b
argument_list|,
name|x
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_mod_mul
argument_list|(
name|b
argument_list|,
name|b
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* x := a*x    (= a^((q+1)/2)) */
if|if
condition|(
operator|!
name|BN_mod_mul
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Now  b  is  a^q * y^k  for some even  k  (0<= k< 2^E 		 * where  E  refers to the original value of  e,  which we 		 * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). 		 * 		 * We have  a*b = x^2, 		 *    y^2^(e-1) = -1, 		 *    b^2^(e-1) = 1. 		 */
if|if
condition|(
name|BN_is_one
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|ret
argument_list|,
name|x
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* find smallest  i  such that  b^(2^i) = 1 */
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|BN_mod_sqr
argument_list|(
name|t
argument_list|,
name|b
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
while|while
condition|(
operator|!
name|BN_is_one
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|e
condition|)
block|{
name|BNerr
argument_list|(
name|BN_F_BN_MOD_SQRT
argument_list|,
name|BN_R_NOT_A_SQUARE
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|!
name|BN_mod_mul
argument_list|(
name|t
argument_list|,
name|t
argument_list|,
name|t
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
block|}
comment|/* t := y^2^(e - i - 1) */
if|if
condition|(
operator|!
name|BN_copy
argument_list|(
name|t
argument_list|,
name|y
argument_list|)
condition|)
goto|goto
name|end
goto|;
for|for
control|(
name|j
operator|=
name|e
operator|-
name|i
operator|-
literal|1
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|BN_mod_sqr
argument_list|(
name|t
argument_list|,
name|t
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|!
name|BN_mod_mul
argument_list|(
name|y
argument_list|,
name|t
argument_list|,
name|t
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_mod_mul
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|t
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|BN_mod_mul
argument_list|(
name|b
argument_list|,
name|b
argument_list|,
name|y
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|e
operator|=
name|i
expr_stmt|;
block|}
name|end
label|:
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|ret
operator|!=
name|NULL
operator|&&
name|ret
operator|!=
name|in
condition|)
block|{
name|BN_clear_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|NULL
expr_stmt|;
block|}
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

