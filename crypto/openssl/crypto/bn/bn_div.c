begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/bn/bn_div.c */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *   * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *   * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from   *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *   * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|"bn_lcl.h"
end_include

begin_comment
comment|/* The old slow way */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, const BIGNUM *d, 	   BN_CTX *ctx) 	{ 	int i,nm,nd; 	int ret = 0; 	BIGNUM *D;  	bn_check_top(m); 	bn_check_top(d); 	if (BN_is_zero(d)) 		{ 		BNerr(BN_F_BN_DIV,BN_R_DIV_BY_ZERO); 		return(0); 		}  	if (BN_ucmp(m,d)< 0) 		{ 		if (rem != NULL) 			{ if (BN_copy(rem,m) == NULL) return(0); } 		if (dv != NULL) BN_zero(dv); 		return(1); 		}  	BN_CTX_start(ctx); 	D = BN_CTX_get(ctx); 	if (dv == NULL) dv = BN_CTX_get(ctx); 	if (rem == NULL) rem = BN_CTX_get(ctx); 	if (D == NULL || dv == NULL || rem == NULL) 		goto end;  	nd=BN_num_bits(d); 	nm=BN_num_bits(m); 	if (BN_copy(D,d) == NULL) goto end; 	if (BN_copy(rem,m) == NULL) goto end;
comment|/* The next 2 are needed so we can do a dv->d[0]|=1 later 	 * since BN_lshift1 will only work once there is a value :-) */
end_comment

begin_comment
unit|BN_zero(dv); 	if(bn_wexpand(dv,1) == NULL) goto end; 	dv->top=1;  	if (!BN_lshift(D,D,nm-nd)) goto end; 	for (i=nm-nd; i>=0; i--) 		{ 		if (!BN_lshift1(dv,dv)) goto end; 		if (BN_ucmp(rem,D)>= 0) 			{ 			dv->d[0]|=1; 			if (!BN_usub(rem,rem,D)) goto end; 			}
comment|/* CAN IMPROVE (and have now :=) */
end_comment

begin_else
unit|if (!BN_rshift1(D,D)) goto end; 		} 	rem->neg=BN_is_zero(rem)?0:m->neg; 	dv->neg=m->neg^d->neg; 	ret = 1;  end: 	BN_CTX_end(ctx); 	return(ret); 	}
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_ASM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_INLINE_ASM
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|PEDANTIC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BN_DIV3W
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|2
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_comment
comment|/*     * There were two reasons for implementing this template:     * - GNU C generates a call to a function (__udivdi3 to be exact)     *   in reply to ((((BN_ULLONG)n0)<<BN_BITS2)|n1)/d0 (I fail to     *   understand why...);     * - divl doesn't only calculate quotient, but also leaves     *   remainder in %edx which we can definitely use here:-)     *     *<appro@fy.chalmers.se>     */
end_comment

begin_undef
undef|#
directive|undef
name|bn_div_words
end_undef

begin_define
define|#
directive|define
name|bn_div_words
parameter_list|(
name|n0
parameter_list|,
name|n1
parameter_list|,
name|d0
parameter_list|)
define|\
value|({  asm volatile (			\ 		"divl	%4"			\ 		: "=a"(q), "=d"(rem)		\ 		: "a"(n1), "d"(n0), "g"(d0)	\ 		: "cc");			\ 	    q;					\ 	})
end_define

begin_define
define|#
directive|define
name|REMAINDER_IS_ALREADY_CALCULATED
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__x86_64
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIXTY_FOUR_BIT_LONG
argument_list|)
end_elif

begin_comment
comment|/*     * Same story here, but it's 128-bit by 64-bit division. Wow!     *<appro@fy.chalmers.se>     */
end_comment

begin_undef
undef|#
directive|undef
name|bn_div_words
end_undef

begin_define
define|#
directive|define
name|bn_div_words
parameter_list|(
name|n0
parameter_list|,
name|n1
parameter_list|,
name|d0
parameter_list|)
define|\
value|({  asm volatile (			\ 		"divq	%4"			\ 		: "=a"(q), "=d"(rem)		\ 		: "a"(n1), "d"(n0), "g"(d0)	\ 		: "cc");			\ 	    q;					\ 	})
end_define

begin_define
define|#
directive|define
name|REMAINDER_IS_ALREADY_CALCULATED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __<cpu> */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GNUC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL_NO_ASM */
end_comment

begin_comment
comment|/* BN_div computes  dv := num / divisor,  rounding towards  * zero, and sets up rm  such that  dv*divisor + rm = num  holds.  * Thus:  *     dv->neg == num->neg ^ divisor->neg  (unless the result is zero)  *     rm->neg == num->neg                 (unless the remainder is zero)  * If 'dv' or 'rm' is NULL, the respective value is not returned.  */
end_comment

begin_function
name|int
name|BN_div
parameter_list|(
name|BIGNUM
modifier|*
name|dv
parameter_list|,
name|BIGNUM
modifier|*
name|rm
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|num
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|divisor
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|norm_shift
decl_stmt|,
name|i
decl_stmt|,
name|loop
decl_stmt|;
name|BIGNUM
modifier|*
name|tmp
decl_stmt|,
name|wnum
decl_stmt|,
modifier|*
name|snum
decl_stmt|,
modifier|*
name|sdiv
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|BN_ULONG
modifier|*
name|resp
decl_stmt|,
modifier|*
name|wnump
decl_stmt|;
name|BN_ULONG
name|d0
decl_stmt|,
name|d1
decl_stmt|;
name|int
name|num_n
decl_stmt|,
name|div_n
decl_stmt|;
name|int
name|no_branch
init|=
literal|0
decl_stmt|;
comment|/* Invalid zero-padding would have particularly bad consequences 	 * in the case of 'num', so don't just rely on bn_check_top() for this one 	 * (bn_check_top() works only for BN_DEBUG builds) */
if|if
condition|(
name|num
operator|->
name|top
operator|>
literal|0
operator|&&
name|num
operator|->
name|d
index|[
name|num
operator|->
name|top
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|BNerr
argument_list|(
name|BN_F_BN_DIV
argument_list|,
name|BN_R_NOT_INITIALIZED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bn_check_top
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BN_get_flags
argument_list|(
name|num
argument_list|,
name|BN_FLG_CONSTTIME
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|BN_get_flags
argument_list|(
name|divisor
argument_list|,
name|BN_FLG_CONSTTIME
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|no_branch
operator|=
literal|1
expr_stmt|;
block|}
name|bn_check_top
argument_list|(
name|dv
argument_list|)
expr_stmt|;
name|bn_check_top
argument_list|(
name|rm
argument_list|)
expr_stmt|;
comment|/* bn_check_top(num); */
comment|/* 'num' has been checked already */
name|bn_check_top
argument_list|(
name|divisor
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_zero
argument_list|(
name|divisor
argument_list|)
condition|)
block|{
name|BNerr
argument_list|(
name|BN_F_BN_DIV
argument_list|,
name|BN_R_DIV_BY_ZERO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|no_branch
operator|&&
name|BN_ucmp
argument_list|(
name|num
argument_list|,
name|divisor
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|rm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|BN_copy
argument_list|(
name|rm
argument_list|,
name|num
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|dv
operator|!=
name|NULL
condition|)
name|BN_zero
argument_list|(
name|dv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|snum
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|sdiv
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dv
operator|==
name|NULL
condition|)
name|res
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|dv
expr_stmt|;
if|if
condition|(
name|sdiv
operator|==
name|NULL
operator|||
name|res
operator|==
name|NULL
operator|||
name|tmp
operator|==
name|NULL
operator|||
name|snum
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* First we normalise the numbers */
name|norm_shift
operator|=
name|BN_BITS2
operator|-
operator|(
operator|(
name|BN_num_bits
argument_list|(
name|divisor
argument_list|)
operator|)
operator|%
name|BN_BITS2
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|BN_lshift
argument_list|(
name|sdiv
argument_list|,
name|divisor
argument_list|,
name|norm_shift
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
name|sdiv
operator|->
name|neg
operator|=
literal|0
expr_stmt|;
name|norm_shift
operator|+=
name|BN_BITS2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|BN_lshift
argument_list|(
name|snum
argument_list|,
name|num
argument_list|,
name|norm_shift
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
name|snum
operator|->
name|neg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|no_branch
condition|)
block|{
comment|/* Since we don't know whether snum is larger than sdiv, 		 * we pad snum with enough zeroes without changing its 		 * value.  		 */
if|if
condition|(
name|snum
operator|->
name|top
operator|<=
name|sdiv
operator|->
name|top
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|bn_wexpand
argument_list|(
name|snum
argument_list|,
name|sdiv
operator|->
name|top
operator|+
literal|2
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|i
operator|=
name|snum
operator|->
name|top
init|;
name|i
operator|<
name|sdiv
operator|->
name|top
operator|+
literal|2
condition|;
name|i
operator|++
control|)
name|snum
operator|->
name|d
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|snum
operator|->
name|top
operator|=
name|sdiv
operator|->
name|top
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bn_wexpand
argument_list|(
name|snum
argument_list|,
name|snum
operator|->
name|top
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|snum
operator|->
name|d
index|[
name|snum
operator|->
name|top
index|]
operator|=
literal|0
expr_stmt|;
name|snum
operator|->
name|top
operator|++
expr_stmt|;
block|}
block|}
name|div_n
operator|=
name|sdiv
operator|->
name|top
expr_stmt|;
name|num_n
operator|=
name|snum
operator|->
name|top
expr_stmt|;
name|loop
operator|=
name|num_n
operator|-
name|div_n
expr_stmt|;
comment|/* Lets setup a 'window' into snum 	 * This is the part that corresponds to the current 	 * 'area' being divided */
name|wnum
operator|.
name|neg
operator|=
literal|0
expr_stmt|;
name|wnum
operator|.
name|d
operator|=
operator|&
operator|(
name|snum
operator|->
name|d
index|[
name|loop
index|]
operator|)
expr_stmt|;
name|wnum
operator|.
name|top
operator|=
name|div_n
expr_stmt|;
comment|/* only needed when BN_ucmp messes up the values between top and max */
name|wnum
operator|.
name|dmax
operator|=
name|snum
operator|->
name|dmax
operator|-
name|loop
expr_stmt|;
comment|/* so we don't step out of bounds */
comment|/* Get the top 2 words of sdiv */
comment|/* div_n=sdiv->top; */
name|d0
operator|=
name|sdiv
operator|->
name|d
index|[
name|div_n
operator|-
literal|1
index|]
expr_stmt|;
name|d1
operator|=
operator|(
name|div_n
operator|==
literal|1
operator|)
condition|?
literal|0
else|:
name|sdiv
operator|->
name|d
index|[
name|div_n
operator|-
literal|2
index|]
expr_stmt|;
comment|/* pointer to the 'top' of snum */
name|wnump
operator|=
operator|&
operator|(
name|snum
operator|->
name|d
index|[
name|num_n
operator|-
literal|1
index|]
operator|)
expr_stmt|;
comment|/* Setup to 'res' */
name|res
operator|->
name|neg
operator|=
operator|(
name|num
operator|->
name|neg
operator|^
name|divisor
operator|->
name|neg
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bn_wexpand
argument_list|(
name|res
argument_list|,
operator|(
name|loop
operator|+
literal|1
operator|)
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|res
operator|->
name|top
operator|=
name|loop
operator|-
name|no_branch
expr_stmt|;
name|resp
operator|=
operator|&
operator|(
name|res
operator|->
name|d
index|[
name|loop
operator|-
literal|1
index|]
operator|)
expr_stmt|;
comment|/* space for temp */
if|if
condition|(
operator|!
name|bn_wexpand
argument_list|(
name|tmp
argument_list|,
operator|(
name|div_n
operator|+
literal|1
operator|)
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|no_branch
condition|)
block|{
if|if
condition|(
name|BN_ucmp
argument_list|(
operator|&
name|wnum
argument_list|,
name|sdiv
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* If BN_DEBUG_RAND is defined BN_ucmp changes (via 			 * bn_pollute) the const bignum arguments => 			 * clean the values between top and max again */
name|bn_clear_top2max
argument_list|(
operator|&
name|wnum
argument_list|)
expr_stmt|;
name|bn_sub_words
argument_list|(
name|wnum
operator|.
name|d
argument_list|,
name|wnum
operator|.
name|d
argument_list|,
name|sdiv
operator|->
name|d
argument_list|,
name|div_n
argument_list|)
expr_stmt|;
operator|*
name|resp
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|res
operator|->
name|top
operator|--
expr_stmt|;
block|}
comment|/* if res->top == 0 then clear the neg value otherwise decrease 	 * the resp pointer */
if|if
condition|(
name|res
operator|->
name|top
operator|==
literal|0
condition|)
name|res
operator|->
name|neg
operator|=
literal|0
expr_stmt|;
else|else
name|resp
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|-
literal|1
condition|;
name|i
operator|++
operator|,
name|wnump
operator|--
operator|,
name|resp
operator|--
control|)
block|{
name|BN_ULONG
name|q
decl_stmt|,
name|l0
decl_stmt|;
comment|/* the first part of the loop uses the top two words of 		 * snum and sdiv to calculate a BN_ULONG q such that 		 * | wnum - sdiv * q |< sdiv */
if|#
directive|if
name|defined
argument_list|(
name|BN_DIV3W
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_ASM
argument_list|)
name|BN_ULONG
name|bn_div_3_words
argument_list|(
name|BN_ULONG
operator|*
argument_list|,
name|BN_ULONG
argument_list|,
name|BN_ULONG
argument_list|)
decl_stmt|;
name|q
operator|=
name|bn_div_3_words
argument_list|(
name|wnump
argument_list|,
name|d1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
else|#
directive|else
name|BN_ULONG
name|n0
decl_stmt|,
name|n1
decl_stmt|,
name|rem
init|=
literal|0
decl_stmt|;
name|n0
operator|=
name|wnump
index|[
literal|0
index|]
expr_stmt|;
name|n1
operator|=
name|wnump
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|n0
operator|==
name|d0
condition|)
name|q
operator|=
name|BN_MASK2
expr_stmt|;
else|else
comment|/* n0< d0 */
block|{
ifdef|#
directive|ifdef
name|BN_LLONG
name|BN_ULLONG
name|t2
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BN_LLONG
argument_list|)
operator|&&
name|defined
argument_list|(
name|BN_DIV2W
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|bn_div_words
argument_list|)
name|q
operator|=
call|(
name|BN_ULONG
call|)
argument_list|(
operator|(
operator|(
operator|(
operator|(
name|BN_ULLONG
operator|)
name|n0
operator|)
operator|<<
name|BN_BITS2
operator|)
operator||
name|n1
operator|)
operator|/
name|d0
argument_list|)
expr_stmt|;
else|#
directive|else
name|q
operator|=
name|bn_div_words
argument_list|(
name|n0
argument_list|,
name|n1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BN_DEBUG_LEVITTE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\ X) -> 0x%08X\n"
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|d0
argument_list|,
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|REMAINDER_IS_ALREADY_CALCULATED
comment|/* 			 * rem doesn't have to be BN_ULLONG. The least we 			 * know it's less that d0, isn't it? 			 */
name|rem
operator|=
operator|(
name|n1
operator|-
name|q
operator|*
name|d0
operator|)
operator|&
name|BN_MASK2
expr_stmt|;
endif|#
directive|endif
name|t2
operator|=
operator|(
name|BN_ULLONG
operator|)
name|d1
operator|*
name|q
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|t2
operator|<=
operator|(
operator|(
operator|(
operator|(
name|BN_ULLONG
operator|)
name|rem
operator|)
operator|<<
name|BN_BITS2
operator|)
operator||
name|wnump
index|[
operator|-
literal|2
index|]
operator|)
condition|)
break|break;
name|q
operator|--
expr_stmt|;
name|rem
operator|+=
name|d0
expr_stmt|;
if|if
condition|(
name|rem
operator|<
name|d0
condition|)
break|break;
comment|/* don't let rem overflow */
name|t2
operator|-=
name|d1
expr_stmt|;
block|}
else|#
directive|else
comment|/* !BN_LLONG */
name|BN_ULONG
name|t2l
decl_stmt|,
name|t2h
decl_stmt|;
name|q
operator|=
name|bn_div_words
argument_list|(
name|n0
argument_list|,
name|n1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BN_DEBUG_LEVITTE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\ X) -> 0x%08X\n"
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|d0
argument_list|,
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|REMAINDER_IS_ALREADY_CALCULATED
name|rem
operator|=
operator|(
name|n1
operator|-
name|q
operator|*
name|d0
operator|)
operator|&
name|BN_MASK2
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|BN_UMULT_LOHI
argument_list|)
name|BN_UMULT_LOHI
argument_list|(
name|t2l
argument_list|,
name|t2h
argument_list|,
name|d1
argument_list|,
name|q
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|BN_UMULT_HIGH
argument_list|)
name|t2l
operator|=
name|d1
operator|*
name|q
expr_stmt|;
name|t2h
operator|=
name|BN_UMULT_HIGH
argument_list|(
name|d1
argument_list|,
name|q
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|BN_ULONG
name|ql
decl_stmt|,
name|qh
decl_stmt|;
name|t2l
operator|=
name|LBITS
argument_list|(
name|d1
argument_list|)
expr_stmt|;
name|t2h
operator|=
name|HBITS
argument_list|(
name|d1
argument_list|)
expr_stmt|;
name|ql
operator|=
name|LBITS
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|qh
operator|=
name|HBITS
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|mul64
argument_list|(
name|t2l
argument_list|,
name|t2h
argument_list|,
name|ql
argument_list|,
name|qh
argument_list|)
expr_stmt|;
comment|/* t2=(BN_ULLONG)d1*q; */
block|}
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|t2h
operator|<
name|rem
operator|)
operator|||
operator|(
operator|(
name|t2h
operator|==
name|rem
operator|)
operator|&&
operator|(
name|t2l
operator|<=
name|wnump
index|[
operator|-
literal|2
index|]
operator|)
operator|)
condition|)
break|break;
name|q
operator|--
expr_stmt|;
name|rem
operator|+=
name|d0
expr_stmt|;
if|if
condition|(
name|rem
operator|<
name|d0
condition|)
break|break;
comment|/* don't let rem overflow */
if|if
condition|(
name|t2l
operator|<
name|d1
condition|)
name|t2h
operator|--
expr_stmt|;
name|t2l
operator|-=
name|d1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !BN_LLONG */
block|}
endif|#
directive|endif
comment|/* !BN_DIV3W */
name|l0
operator|=
name|bn_mul_words
argument_list|(
name|tmp
operator|->
name|d
argument_list|,
name|sdiv
operator|->
name|d
argument_list|,
name|div_n
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|d
index|[
name|div_n
index|]
operator|=
name|l0
expr_stmt|;
name|wnum
operator|.
name|d
operator|--
expr_stmt|;
comment|/* ingore top values of the bignums just sub the two  		 * BN_ULONG arrays with bn_sub_words */
if|if
condition|(
name|bn_sub_words
argument_list|(
name|wnum
operator|.
name|d
argument_list|,
name|wnum
operator|.
name|d
argument_list|,
name|tmp
operator|->
name|d
argument_list|,
name|div_n
operator|+
literal|1
argument_list|)
condition|)
block|{
comment|/* Note: As we have considered only the leading 			 * two BN_ULONGs in the calculation of q, sdiv * q 			 * might be greater than wnum (but then (q-1) * sdiv 			 * is less or equal than wnum) 			 */
name|q
operator|--
expr_stmt|;
if|if
condition|(
name|bn_add_words
argument_list|(
name|wnum
operator|.
name|d
argument_list|,
name|wnum
operator|.
name|d
argument_list|,
name|sdiv
operator|->
name|d
argument_list|,
name|div_n
argument_list|)
condition|)
comment|/* we can't have an overflow here (assuming 				 * that q != 0, but if q == 0 then tmp is 				 * zero anyway) */
operator|(
operator|*
name|wnump
operator|)
operator|++
expr_stmt|;
block|}
comment|/* store part of the result */
operator|*
name|resp
operator|=
name|q
expr_stmt|;
block|}
name|bn_correct_top
argument_list|(
name|snum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|!=
name|NULL
condition|)
block|{
comment|/* Keep a copy of the neg flag in num because if rm==num 		 * BN_rshift() will overwrite it. 		 */
name|int
name|neg
init|=
name|num
operator|->
name|neg
decl_stmt|;
name|BN_rshift
argument_list|(
name|rm
argument_list|,
name|snum
argument_list|,
name|norm_shift
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BN_is_zero
argument_list|(
name|rm
argument_list|)
condition|)
name|rm
operator|->
name|neg
operator|=
name|neg
expr_stmt|;
name|bn_check_top
argument_list|(
name|rm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|no_branch
condition|)
name|bn_correct_top
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|err
label|:
name|bn_check_top
argument_list|(
name|rm
argument_list|)
expr_stmt|;
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

