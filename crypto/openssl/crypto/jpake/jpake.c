begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"jpake.h"
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/sha.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_comment
comment|/*  * In the definition, (xa, xb, xc, xd) are Alice's (x1, x2, x3, x4) or  * Bob's (x3, x4, x1, x2). If you see what I mean.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Must be unique */
name|char
modifier|*
name|peer_name
decl_stmt|;
name|BIGNUM
modifier|*
name|p
decl_stmt|;
name|BIGNUM
modifier|*
name|g
decl_stmt|;
name|BIGNUM
modifier|*
name|q
decl_stmt|;
name|BIGNUM
modifier|*
name|gxc
decl_stmt|;
comment|/* Alice's g^{x3} or Bob's g^{x1} */
name|BIGNUM
modifier|*
name|gxd
decl_stmt|;
comment|/* Alice's g^{x4} or Bob's g^{x2} */
block|}
name|JPAKE_CTX_PUBLIC
typedef|;
end_typedef

begin_struct
struct|struct
name|JPAKE_CTX
block|{
name|JPAKE_CTX_PUBLIC
name|p
decl_stmt|;
name|BIGNUM
modifier|*
name|secret
decl_stmt|;
comment|/* The shared secret */
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
name|BIGNUM
modifier|*
name|xa
decl_stmt|;
comment|/* Alice's x1 or Bob's x3 */
name|BIGNUM
modifier|*
name|xb
decl_stmt|;
comment|/* Alice's x2 or Bob's x4 */
name|BIGNUM
modifier|*
name|key
decl_stmt|;
comment|/* The calculated (shared) key */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|JPAKE_ZKP_init
parameter_list|(
name|JPAKE_ZKP
modifier|*
name|zkp
parameter_list|)
block|{
name|zkp
operator|->
name|gr
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|zkp
operator|->
name|b
operator|=
name|BN_new
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|JPAKE_ZKP_release
parameter_list|(
name|JPAKE_ZKP
modifier|*
name|zkp
parameter_list|)
block|{
name|BN_free
argument_list|(
name|zkp
operator|->
name|b
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|zkp
operator|->
name|gr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Two birds with one stone - make the global name as expected */
end_comment

begin_define
define|#
directive|define
name|JPAKE_STEP_PART_init
value|JPAKE_STEP2_init
end_define

begin_define
define|#
directive|define
name|JPAKE_STEP_PART_release
value|JPAKE_STEP2_release
end_define

begin_function
name|void
name|JPAKE_STEP_PART_init
parameter_list|(
name|JPAKE_STEP_PART
modifier|*
name|p
parameter_list|)
block|{
name|p
operator|->
name|gx
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|JPAKE_ZKP_init
argument_list|(
operator|&
name|p
operator|->
name|zkpx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|JPAKE_STEP_PART_release
parameter_list|(
name|JPAKE_STEP_PART
modifier|*
name|p
parameter_list|)
block|{
name|JPAKE_ZKP_release
argument_list|(
operator|&
name|p
operator|->
name|zkpx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|p
operator|->
name|gx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|JPAKE_STEP1_init
parameter_list|(
name|JPAKE_STEP1
modifier|*
name|s1
parameter_list|)
block|{
name|JPAKE_STEP_PART_init
argument_list|(
operator|&
name|s1
operator|->
name|p1
argument_list|)
expr_stmt|;
name|JPAKE_STEP_PART_init
argument_list|(
operator|&
name|s1
operator|->
name|p2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|JPAKE_STEP1_release
parameter_list|(
name|JPAKE_STEP1
modifier|*
name|s1
parameter_list|)
block|{
name|JPAKE_STEP_PART_release
argument_list|(
operator|&
name|s1
operator|->
name|p2
argument_list|)
expr_stmt|;
name|JPAKE_STEP_PART_release
argument_list|(
operator|&
name|s1
operator|->
name|p1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|JPAKE_CTX_init
parameter_list|(
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|peer_name
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|q
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|secret
parameter_list|)
block|{
name|ctx
operator|->
name|p
operator|.
name|name
operator|=
name|OPENSSL_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|p
operator|.
name|peer_name
operator|=
name|OPENSSL_strdup
argument_list|(
name|peer_name
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|p
operator|.
name|p
operator|=
name|BN_dup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|p
operator|.
name|g
operator|=
name|BN_dup
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|p
operator|.
name|q
operator|=
name|BN_dup
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|secret
operator|=
name|BN_dup
argument_list|(
name|secret
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|p
operator|.
name|gxc
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|ctx
operator|->
name|p
operator|.
name|gxd
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|ctx
operator|->
name|xa
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|ctx
operator|->
name|xb
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|ctx
operator|->
name|key
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|ctx
operator|->
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|JPAKE_CTX_release
parameter_list|(
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BN_CTX_free
argument_list|(
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|ctx
operator|->
name|key
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|ctx
operator|->
name|xb
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|ctx
operator|->
name|xa
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|ctx
operator|->
name|p
operator|.
name|gxd
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|ctx
operator|->
name|p
operator|.
name|gxc
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|ctx
operator|->
name|secret
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|ctx
operator|->
name|p
operator|.
name|q
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|ctx
operator|->
name|p
operator|.
name|g
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|ctx
operator|->
name|p
operator|.
name|peer_name
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|ctx
operator|->
name|p
operator|.
name|name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ctx
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
expr|*
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JPAKE_CTX
modifier|*
name|JPAKE_CTX_new
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|peer_name
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|q
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|secret
parameter_list|)
block|{
name|JPAKE_CTX
modifier|*
name|ctx
init|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
expr|*
name|ctx
argument_list|)
decl_stmt|;
name|JPAKE_CTX_init
argument_list|(
name|ctx
argument_list|,
name|name
argument_list|,
name|peer_name
argument_list|,
name|p
argument_list|,
name|g
argument_list|,
name|q
argument_list|,
name|secret
argument_list|)
expr_stmt|;
return|return
name|ctx
return|;
block|}
end_function

begin_function
name|void
name|JPAKE_CTX_free
parameter_list|(
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|JPAKE_CTX_release
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hashlength
parameter_list|(
name|SHA_CTX
modifier|*
name|sha
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
name|unsigned
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
name|OPENSSL_assert
argument_list|(
name|l
operator|<=
literal|0xffff
argument_list|)
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|l
operator|>>
literal|8
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
name|l
operator|&
literal|0xff
expr_stmt|;
name|SHA1_Update
argument_list|(
name|sha
argument_list|,
name|b
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hashstring
parameter_list|(
name|SHA_CTX
modifier|*
name|sha
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|hashlength
argument_list|(
name|sha
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|SHA1_Update
argument_list|(
name|sha
argument_list|,
name|string
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hashbn
parameter_list|(
name|SHA_CTX
modifier|*
name|sha
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|bn
parameter_list|)
block|{
name|size_t
name|l
init|=
name|BN_num_bytes
argument_list|(
name|bn
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bin
init|=
name|OPENSSL_malloc
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|hashlength
argument_list|(
name|sha
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|bn
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|SHA1_Update
argument_list|(
name|sha
argument_list|,
name|bin
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|bin
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* h=hash(g, g^r, g^x, name) */
end_comment

begin_function
specifier|static
name|void
name|zkp_hash
parameter_list|(
name|BIGNUM
modifier|*
name|h
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|zkpg
parameter_list|,
specifier|const
name|JPAKE_STEP_PART
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|proof_name
parameter_list|)
block|{
name|unsigned
name|char
name|md
index|[
name|SHA_DIGEST_LENGTH
index|]
decl_stmt|;
name|SHA_CTX
name|sha
decl_stmt|;
comment|/*     * XXX: hash should not allow moving of the boundaries - Java code     * is flawed in this respect. Length encoding seems simplest.     */
name|SHA1_Init
argument_list|(
operator|&
name|sha
argument_list|)
expr_stmt|;
name|hashbn
argument_list|(
operator|&
name|sha
argument_list|,
name|zkpg
argument_list|)
expr_stmt|;
name|OPENSSL_assert
argument_list|(
operator|!
name|BN_is_zero
argument_list|(
name|p
operator|->
name|zkpx
operator|.
name|gr
argument_list|)
argument_list|)
expr_stmt|;
name|hashbn
argument_list|(
operator|&
name|sha
argument_list|,
name|p
operator|->
name|zkpx
operator|.
name|gr
argument_list|)
expr_stmt|;
name|hashbn
argument_list|(
operator|&
name|sha
argument_list|,
name|p
operator|->
name|gx
argument_list|)
expr_stmt|;
name|hashstring
argument_list|(
operator|&
name|sha
argument_list|,
name|proof_name
argument_list|)
expr_stmt|;
name|SHA1_Final
argument_list|(
name|md
argument_list|,
operator|&
name|sha
argument_list|)
expr_stmt|;
name|BN_bin2bn
argument_list|(
name|md
argument_list|,
name|SHA_DIGEST_LENGTH
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prove knowledge of x  * Note that p->gx has already been calculated  */
end_comment

begin_function
specifier|static
name|void
name|generate_zkp
parameter_list|(
name|JPAKE_STEP_PART
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|x
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|zkpg
parameter_list|,
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|r
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|h
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t
init|=
name|BN_new
argument_list|()
decl_stmt|;
comment|/*     * r in [0,q)     * XXX: Java chooses r in [0, 2^160) - i.e. distribution not uniform     */
name|BN_rand_range
argument_list|(
name|r
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|q
argument_list|)
expr_stmt|;
comment|/* g^r */
name|BN_mod_exp
argument_list|(
name|p
operator|->
name|zkpx
operator|.
name|gr
argument_list|,
name|zkpg
argument_list|,
name|r
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|/* h=hash... */
name|zkp_hash
argument_list|(
name|h
argument_list|,
name|zkpg
argument_list|,
name|p
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* b = r - x*h */
name|BN_mod_mul
argument_list|(
name|t
argument_list|,
name|x
argument_list|,
name|h
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|q
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_sub
argument_list|(
name|p
operator|->
name|zkpx
operator|.
name|b
argument_list|,
name|r
argument_list|,
name|t
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|q
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|/* cleanup */
name|BN_free
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|verify_zkp
parameter_list|(
specifier|const
name|JPAKE_STEP_PART
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|zkpg
parameter_list|,
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|h
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t1
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t2
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t3
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|zkp_hash
argument_list|(
name|h
argument_list|,
name|zkpg
argument_list|,
name|p
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|peer_name
argument_list|)
expr_stmt|;
comment|/* t1 = g^b */
name|BN_mod_exp
argument_list|(
name|t1
argument_list|,
name|zkpg
argument_list|,
name|p
operator|->
name|zkpx
operator|.
name|b
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|/* t2 = (g^x)^h = g^{hx} */
name|BN_mod_exp
argument_list|(
name|t2
argument_list|,
name|p
operator|->
name|gx
argument_list|,
name|h
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|/* t3 = t1 * t2 = g^{hx} * g^b = g^{hx+b} = g^r (allegedly) */
name|BN_mod_mul
argument_list|(
name|t3
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|/* verify t3 == g^r */
if|if
condition|(
name|BN_cmp
argument_list|(
name|t3
argument_list|,
name|p
operator|->
name|zkpx
operator|.
name|gr
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
else|else
name|JPAKEerr
argument_list|(
name|JPAKE_F_VERIFY_ZKP
argument_list|,
name|JPAKE_R_ZKP_VERIFY_FAILED
argument_list|)
expr_stmt|;
comment|/* cleanup */
name|BN_free
argument_list|(
name|t3
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_step_part
parameter_list|(
name|JPAKE_STEP_PART
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|x
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g
parameter_list|,
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BN_mod_exp
argument_list|(
name|p
operator|->
name|gx
argument_list|,
name|g
argument_list|,
name|x
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|generate_zkp
argument_list|(
name|p
argument_list|,
name|x
argument_list|,
name|g
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate each party's random numbers. xa is in [0, q), xb is in [1, q). */
end_comment

begin_function
specifier|static
name|void
name|genrand
parameter_list|(
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|qm1
decl_stmt|;
comment|/* xa in [0, q) */
name|BN_rand_range
argument_list|(
name|ctx
operator|->
name|xa
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|q
argument_list|)
expr_stmt|;
comment|/* q-1 */
name|qm1
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_copy
argument_list|(
name|qm1
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|q
argument_list|)
expr_stmt|;
name|BN_sub_word
argument_list|(
name|qm1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ... and xb in [0, q-1) */
name|BN_rand_range
argument_list|(
name|ctx
operator|->
name|xb
argument_list|,
name|qm1
argument_list|)
expr_stmt|;
comment|/* [1, q) */
name|BN_add_word
argument_list|(
name|ctx
operator|->
name|xb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* cleanup */
name|BN_free
argument_list|(
name|qm1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|JPAKE_STEP1_generate
parameter_list|(
name|JPAKE_STEP1
modifier|*
name|send
parameter_list|,
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|genrand
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|generate_step_part
argument_list|(
operator|&
name|send
operator|->
name|p1
argument_list|,
name|ctx
operator|->
name|xa
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|g
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|generate_step_part
argument_list|(
operator|&
name|send
operator|->
name|p2
argument_list|,
name|ctx
operator|->
name|xb
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|g
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* g^x is a legal value */
end_comment

begin_function
specifier|static
name|int
name|is_legal
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|gx
parameter_list|,
specifier|const
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|t
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|BN_is_negative
argument_list|(
name|gx
argument_list|)
operator|||
name|BN_is_zero
argument_list|(
name|gx
argument_list|)
operator|||
name|BN_cmp
argument_list|(
name|gx
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|)
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
name|t
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|t
argument_list|,
name|gx
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|q
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|res
operator|=
name|BN_is_one
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|int
name|JPAKE_STEP1_process
parameter_list|(
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|JPAKE_STEP1
modifier|*
name|received
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_legal
argument_list|(
name|received
operator|->
name|p1
operator|.
name|gx
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|JPAKEerr
argument_list|(
name|JPAKE_F_JPAKE_STEP1_PROCESS
argument_list|,
name|JPAKE_R_G_TO_THE_X3_IS_NOT_LEGAL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|is_legal
argument_list|(
name|received
operator|->
name|p2
operator|.
name|gx
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|JPAKEerr
argument_list|(
name|JPAKE_F_JPAKE_STEP1_PROCESS
argument_list|,
name|JPAKE_R_G_TO_THE_X4_IS_NOT_LEGAL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* verify their ZKP(xc) */
if|if
condition|(
operator|!
name|verify_zkp
argument_list|(
operator|&
name|received
operator|->
name|p1
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|g
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|JPAKEerr
argument_list|(
name|JPAKE_F_JPAKE_STEP1_PROCESS
argument_list|,
name|JPAKE_R_VERIFY_X3_FAILED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* verify their ZKP(xd) */
if|if
condition|(
operator|!
name|verify_zkp
argument_list|(
operator|&
name|received
operator|->
name|p2
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|g
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|JPAKEerr
argument_list|(
name|JPAKE_F_JPAKE_STEP1_PROCESS
argument_list|,
name|JPAKE_R_VERIFY_X4_FAILED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* g^xd != 1 */
if|if
condition|(
name|BN_is_one
argument_list|(
name|received
operator|->
name|p2
operator|.
name|gx
argument_list|)
condition|)
block|{
name|JPAKEerr
argument_list|(
name|JPAKE_F_JPAKE_STEP1_PROCESS
argument_list|,
name|JPAKE_R_G_TO_THE_X4_IS_ONE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Save the bits we need for later */
name|BN_copy
argument_list|(
name|ctx
operator|->
name|p
operator|.
name|gxc
argument_list|,
name|received
operator|->
name|p1
operator|.
name|gx
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|ctx
operator|->
name|p
operator|.
name|gxd
argument_list|,
name|received
operator|->
name|p2
operator|.
name|gx
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|JPAKE_STEP2_generate
parameter_list|(
name|JPAKE_STEP2
modifier|*
name|send
parameter_list|,
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|t1
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t2
init|=
name|BN_new
argument_list|()
decl_stmt|;
comment|/*     * X = g^{(xa + xc + xd) * xb * s}     * t1 = g^xa     */
name|BN_mod_exp
argument_list|(
name|t1
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|g
argument_list|,
name|ctx
operator|->
name|xa
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|/* t2 = t1 * g^{xc} = g^{xa} * g^{xc} = g^{xa + xc} */
name|BN_mod_mul
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|gxc
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|/* t1 = t2 * g^{xd} = g^{xa + xc + xd} */
name|BN_mod_mul
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|gxd
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|/* t2 = xb * s */
name|BN_mod_mul
argument_list|(
name|t2
argument_list|,
name|ctx
operator|->
name|xb
argument_list|,
name|ctx
operator|->
name|secret
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|q
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|/*     * ZKP(xb * s)     * XXX: this is kinda funky, because we're using     *     * g' = g^{xa + xc + xd}     *     * as the generator, which means X is g'^{xb * s}     * X = t1^{t2} = t1^{xb * s} = g^{(xa + xc + xd) * xb * s}     */
name|generate_step_part
argument_list|(
name|send
argument_list|,
name|t2
argument_list|,
name|t1
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* cleanup */
name|BN_free
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|t2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* gx = g^{xc + xa + xb} * xd * s */
end_comment

begin_function
specifier|static
name|int
name|compute_key
parameter_list|(
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|gx
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|t1
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t2
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t3
init|=
name|BN_new
argument_list|()
decl_stmt|;
comment|/*     * K = (gx/g^{xb * xd * s})^{xb}     *   = (g^{(xc + xa + xb) * xd * s - xb * xd *s})^{xb}     *   = (g^{(xa + xc) * xd * s})^{xb}     *   = g^{(xa + xc) * xb * xd * s}     * [which is the same regardless of who calculates it]     */
comment|/* t1 = (g^{xd})^{xb} = g^{xb * xd} */
name|BN_mod_exp
argument_list|(
name|t1
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|gxd
argument_list|,
name|ctx
operator|->
name|xb
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|/* t2 = -s = q-s */
name|BN_sub
argument_list|(
name|t2
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|q
argument_list|,
name|ctx
operator|->
name|secret
argument_list|)
expr_stmt|;
comment|/* t3 = t1^t2 = g^{-xb * xd * s} */
name|BN_mod_exp
argument_list|(
name|t3
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|/* t1 = gx * t3 = X/g^{xb * xd * s} */
name|BN_mod_mul
argument_list|(
name|t1
argument_list|,
name|gx
argument_list|,
name|t3
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|/* K = t1^{xb} */
name|BN_mod_exp
argument_list|(
name|ctx
operator|->
name|key
argument_list|,
name|t1
argument_list|,
name|ctx
operator|->
name|xb
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|/* cleanup */
name|BN_free
argument_list|(
name|t3
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|JPAKE_STEP2_process
parameter_list|(
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|JPAKE_STEP2
modifier|*
name|received
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|t1
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t2
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/*     * g' = g^{xc + xa + xb} [from our POV]     * t1 = xa + xb     */
name|BN_mod_add
argument_list|(
name|t1
argument_list|,
name|ctx
operator|->
name|xa
argument_list|,
name|ctx
operator|->
name|xb
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|q
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|/* t2 = g^{t1} = g^{xa+xb} */
name|BN_mod_exp
argument_list|(
name|t2
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|g
argument_list|,
name|t1
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|/* t1 = g^{xc} * t2 = g^{xc + xa + xb} */
name|BN_mod_mul
argument_list|(
name|t1
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|gxc
argument_list|,
name|t2
argument_list|,
name|ctx
operator|->
name|p
operator|.
name|p
argument_list|,
name|ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify_zkp
argument_list|(
name|received
argument_list|,
name|t1
argument_list|,
name|ctx
argument_list|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
else|else
name|JPAKEerr
argument_list|(
name|JPAKE_F_JPAKE_STEP2_PROCESS
argument_list|,
name|JPAKE_R_VERIFY_B_FAILED
argument_list|)
expr_stmt|;
name|compute_key
argument_list|(
name|ctx
argument_list|,
name|received
operator|->
name|gx
argument_list|)
expr_stmt|;
comment|/* cleanup */
name|BN_free
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|quickhashbn
parameter_list|(
name|unsigned
name|char
modifier|*
name|md
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|bn
parameter_list|)
block|{
name|SHA_CTX
name|sha
decl_stmt|;
name|SHA1_Init
argument_list|(
operator|&
name|sha
argument_list|)
expr_stmt|;
name|hashbn
argument_list|(
operator|&
name|sha
argument_list|,
name|bn
argument_list|)
expr_stmt|;
name|SHA1_Final
argument_list|(
name|md
argument_list|,
operator|&
name|sha
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|JPAKE_STEP3A_init
parameter_list|(
name|JPAKE_STEP3A
modifier|*
name|s3a
parameter_list|)
block|{}
end_function

begin_function
name|int
name|JPAKE_STEP3A_generate
parameter_list|(
name|JPAKE_STEP3A
modifier|*
name|send
parameter_list|,
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|quickhashbn
argument_list|(
name|send
operator|->
name|hhk
argument_list|,
name|ctx
operator|->
name|key
argument_list|)
expr_stmt|;
name|SHA1
argument_list|(
name|send
operator|->
name|hhk
argument_list|,
sizeof|sizeof
name|send
operator|->
name|hhk
argument_list|,
name|send
operator|->
name|hhk
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|JPAKE_STEP3A_process
parameter_list|(
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|JPAKE_STEP3A
modifier|*
name|received
parameter_list|)
block|{
name|unsigned
name|char
name|hhk
index|[
name|SHA_DIGEST_LENGTH
index|]
decl_stmt|;
name|quickhashbn
argument_list|(
name|hhk
argument_list|,
name|ctx
operator|->
name|key
argument_list|)
expr_stmt|;
name|SHA1
argument_list|(
name|hhk
argument_list|,
sizeof|sizeof
name|hhk
argument_list|,
name|hhk
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|hhk
argument_list|,
name|received
operator|->
name|hhk
argument_list|,
sizeof|sizeof
name|hhk
argument_list|)
condition|)
block|{
name|JPAKEerr
argument_list|(
name|JPAKE_F_JPAKE_STEP3A_PROCESS
argument_list|,
name|JPAKE_R_HASH_OF_HASH_OF_KEY_MISMATCH
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|JPAKE_STEP3A_release
parameter_list|(
name|JPAKE_STEP3A
modifier|*
name|s3a
parameter_list|)
block|{}
end_function

begin_function
name|void
name|JPAKE_STEP3B_init
parameter_list|(
name|JPAKE_STEP3B
modifier|*
name|s3b
parameter_list|)
block|{}
end_function

begin_function
name|int
name|JPAKE_STEP3B_generate
parameter_list|(
name|JPAKE_STEP3B
modifier|*
name|send
parameter_list|,
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|quickhashbn
argument_list|(
name|send
operator|->
name|hk
argument_list|,
name|ctx
operator|->
name|key
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|JPAKE_STEP3B_process
parameter_list|(
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|JPAKE_STEP3B
modifier|*
name|received
parameter_list|)
block|{
name|unsigned
name|char
name|hk
index|[
name|SHA_DIGEST_LENGTH
index|]
decl_stmt|;
name|quickhashbn
argument_list|(
name|hk
argument_list|,
name|ctx
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|hk
argument_list|,
name|received
operator|->
name|hk
argument_list|,
sizeof|sizeof
name|hk
argument_list|)
condition|)
block|{
name|JPAKEerr
argument_list|(
name|JPAKE_F_JPAKE_STEP3B_PROCESS
argument_list|,
name|JPAKE_R_HASH_OF_KEY_MISMATCH
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|JPAKE_STEP3B_release
parameter_list|(
name|JPAKE_STEP3B
modifier|*
name|s3b
parameter_list|)
block|{}
end_function

begin_function
specifier|const
name|BIGNUM
modifier|*
name|JPAKE_get_shared_key
parameter_list|(
name|JPAKE_CTX
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|ctx
operator|->
name|key
return|;
block|}
end_function

end_unit

