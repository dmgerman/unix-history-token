begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/bio/b_sock.c */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *   * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *   * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from   *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *   * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|USE_SOCKETS
end_define

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/bio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_SYS_NETWARE
argument_list|)
operator|&&
name|defined
argument_list|(
name|NETWARE_BSDSOCK
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NETWARE_CLIB
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_decl_stmt
name|NETDB_DEFINE_CONTEXT
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SOCK
include|#
directive|include
file|<openssl/dso.h>
define|#
directive|define
name|SOCKET_PROTOCOL
value|IPPROTO_TCP
ifdef|#
directive|ifdef
name|SO_MAXCONN
define|#
directive|define
name|MAX_LISTEN
value|SO_MAXCONN
elif|#
directive|elif
name|defined
argument_list|(
name|SOMAXCONN
argument_list|)
define|#
directive|define
name|MAX_LISTEN
value|SOMAXCONN
else|#
directive|else
define|#
directive|define
name|MAX_LISTEN
value|32
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_SYS_WINDOWS
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|OPENSSL_SYS_NETWARE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NETWARE_BSDSOCK
argument_list|)
operator|)
specifier|static
name|int
name|wsa_init_done
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * WSAAPI specifier is required to make indirect calls to run-time  * linked WinSock 2 functions used in this module, to be specific  * [get|free]addrinfo and getnameinfo. This is because WinSock uses  * uses non-C calling convention, __stdcall vs. __cdecl, on x86  * Windows. On non-WinSock platforms WSAAPI needs to be void.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WSAAPI
end_ifndef

begin_define
define|#
directive|define
name|WSAAPI
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_define
unit|static unsigned long BIO_ghbn_hits=0L; static unsigned long BIO_ghbn_miss=0L;
define|#
directive|define
name|GHBN_NUM
value|4
end_define

begin_endif
unit|static struct ghbn_cache_st 	{ 	char name[129]; 	struct hostent *ent; 	unsigned long order; 	} ghbn_cache[GHBN_NUM];
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|get_ip
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|unsigned
name|char
modifier|*
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void ghbn_free(struct hostent *a); static struct hostent *ghbn_dup(struct hostent *a);
endif|#
directive|endif
end_endif

begin_function
name|int
name|BIO_get_host_ip
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|unsigned
name|char
modifier|*
name|ip
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|1
decl_stmt|;
name|int
name|locked
init|=
literal|0
decl_stmt|;
name|struct
name|hostent
modifier|*
name|he
decl_stmt|;
name|i
operator|=
name|get_ip
argument_list|(
name|str
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_GET_HOST_IP
argument_list|,
name|BIO_R_INVALID_IP_ADDRESS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* At this point, we have something that is most probably correct 	   in some way, so let's init the socket. */
if|if
condition|(
name|BIO_sock_init
argument_list|()
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* don't generate another error code here */
comment|/* If the string actually contained an IP address, we need not do 	   anything more */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* do a gethostbyname */
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_GETHOSTBYNAME
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|1
expr_stmt|;
name|he
operator|=
name|BIO_gethostbyname
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|he
operator|==
name|NULL
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_GET_HOST_IP
argument_list|,
name|BIO_R_BAD_HOSTNAME_LOOKUP
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* cast to short because of win16 winsock definition */
if|if
condition|(
operator|(
name|short
operator|)
name|he
operator|->
name|h_addrtype
operator|!=
name|AF_INET
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_GET_HOST_IP
argument_list|,
name|BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|ip
index|[
name|i
index|]
operator|=
name|he
operator|->
name|h_addr_list
index|[
literal|0
index|]
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|err
label|:
if|if
condition|(
name|locked
condition|)
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_GETHOSTBYNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"host="
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|BIO_get_port
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|unsigned
name|short
modifier|*
name|port_ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|servent
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_GET_PORT
argument_list|,
name|BIO_R_NO_PORT_DEFINED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|i
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
operator|*
name|port_ptr
operator|=
operator|(
name|unsigned
name|short
operator|)
name|i
expr_stmt|;
else|else
block|{
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_GETSERVBYNAME
argument_list|)
expr_stmt|;
comment|/* Note: under VMS with SOCKETSHR, it seems like the first 		 * parameter is 'char *', instead of 'const char *' 		 */
ifndef|#
directive|ifndef
name|CONST_STRICT
name|s
operator|=
name|getservbyname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|str
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|getservbyname
argument_list|(
name|str
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
operator|*
name|port_ptr
operator|=
name|ntohs
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|s
operator|->
name|s_port
argument_list|)
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_GETSERVBYNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"http"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|port_ptr
operator|=
literal|80
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"telnet"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|port_ptr
operator|=
literal|23
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"socks"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|port_ptr
operator|=
literal|1080
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"https"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|port_ptr
operator|=
literal|443
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"ssl"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|port_ptr
operator|=
literal|443
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"ftp"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|port_ptr
operator|=
literal|21
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"gopher"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|port_ptr
operator|=
literal|70
expr_stmt|;
if|#
directive|if
literal|0
if|else if (strcmp(str,"wais") == 0) 				*port_ptr=21;
endif|#
directive|endif
else|else
block|{
name|SYSerr
argument_list|(
name|SYS_F_GETSERVBYNAME
argument_list|,
name|get_last_socket_error
argument_list|()
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|3
argument_list|,
literal|"service='"
argument_list|,
name|str
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|BIO_sock_error
parameter_list|(
name|int
name|sock
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|i
decl_stmt|;
name|int
name|size
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_SYS_BEOS_R5
argument_list|)
return|return
literal|0
return|;
endif|#
directive|endif
name|size
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* Note: under Windows the third parameter is of type (char *) 	 * whereas under other systems it is (void *) if you don't have 	 * a cast it will choke the compiler: if you do have a cast then 	 * you can either go for (char *) or (void *). 	 */
name|i
operator|=
name|getsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|j
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|j
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|long BIO_ghbn_ctrl(int cmd, int iarg, char *parg) 	{ 	int i; 	char **p;  	switch (cmd) 		{ 	case BIO_GHBN_CTRL_HITS: 		return(BIO_ghbn_hits);
comment|/* break; */
end_comment

begin_comment
unit|case BIO_GHBN_CTRL_MISSES: 		return(BIO_ghbn_miss);
comment|/* break; */
end_comment

begin_comment
unit|case BIO_GHBN_CTRL_CACHE_SIZE: 		return(GHBN_NUM);
comment|/* break; */
end_comment

begin_comment
unit|case BIO_GHBN_CTRL_GET_ENTRY: 		if ((iarg>= 0)&& (iarg<GHBN_NUM)&& 			(ghbn_cache[iarg].order> 0)) 			{ 			p=(char **)parg; 			if (p == NULL) return(0); 			*p=ghbn_cache[iarg].name; 			ghbn_cache[iarg].name[128]='\0'; 			return(1); 			} 		return(0);
comment|/* break; */
end_comment

begin_endif
unit|case BIO_GHBN_CTRL_FLUSH: 		for (i=0; i<GHBN_NUM; i++) 			ghbn_cache[i].order=0; 		break; 	default: 		return(0); 		} 	return(1); 	}
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct hostent *ghbn_dup(struct hostent *a) 	{ 	struct hostent *ret; 	int i,j;  	MemCheck_off(); 	ret=(struct hostent *)OPENSSL_malloc(sizeof(struct hostent)); 	if (ret == NULL) return(NULL); 	memset(ret,0,sizeof(struct hostent));  	for (i=0; a->h_aliases[i] != NULL; i++) 		; 	i++; 	ret->h_aliases = (char **)OPENSSL_malloc(i*sizeof(char *)); 	if (ret->h_aliases == NULL) 		goto err; 	memset(ret->h_aliases, 0, i*sizeof(char *));  	for (i=0; a->h_addr_list[i] != NULL; i++) 		; 	i++; 	ret->h_addr_list=(char **)OPENSSL_malloc(i*sizeof(char *)); 	if (ret->h_addr_list == NULL) 		goto err; 	memset(ret->h_addr_list, 0, i*sizeof(char *));  	j=strlen(a->h_name)+1; 	if ((ret->h_name=OPENSSL_malloc(j)) == NULL) goto err; 	memcpy((char *)ret->h_name,a->h_name,j); 	for (i=0; a->h_aliases[i] != NULL; i++) 		{ 		j=strlen(a->h_aliases[i])+1; 		if ((ret->h_aliases[i]=OPENSSL_malloc(j)) == NULL) goto err; 		memcpy(ret->h_aliases[i],a->h_aliases[i],j); 		} 	ret->h_length=a->h_length; 	ret->h_addrtype=a->h_addrtype; 	for (i=0; a->h_addr_list[i] != NULL; i++) 		{ 		if ((ret->h_addr_list[i]=OPENSSL_malloc(a->h_length)) == NULL) 			goto err; 		memcpy(ret->h_addr_list[i],a->h_addr_list[i],a->h_length); 		} 	if (0) 		{ err:	 		if (ret != NULL) 			ghbn_free(ret); 		ret=NULL; 		} 	MemCheck_on(); 	return(ret); 	}  static void ghbn_free(struct hostent *a) 	{ 	int i;  	if(a == NULL) 	    return;  	if (a->h_aliases != NULL) 		{ 		for (i=0; a->h_aliases[i] != NULL; i++) 			OPENSSL_free(a->h_aliases[i]); 		OPENSSL_free(a->h_aliases); 		} 	if (a->h_addr_list != NULL) 		{ 		for (i=0; a->h_addr_list[i] != NULL; i++) 			OPENSSL_free(a->h_addr_list[i]); 		OPENSSL_free(a->h_addr_list); 		} 	if (a->h_name != NULL) OPENSSL_free(a->h_name); 	OPENSSL_free(a); 	}
endif|#
directive|endif
end_endif

begin_function
name|struct
name|hostent
modifier|*
name|BIO_gethostbyname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|#
directive|if
literal|1
comment|/* Caching gethostbyname() results forever is wrong, 	 * so we have to let the true gethostbyname() worry about this */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|NETWARE_BSDSOCK
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__NOVELL_LIBC__
argument_list|)
operator|)
return|return
name|gethostbyname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
return|;
else|#
directive|else
return|return
name|gethostbyname
argument_list|(
name|name
argument_list|)
return|;
endif|#
directive|endif
else|#
directive|else
name|struct
name|hostent
modifier|*
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lowi
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|long
name|low
init|=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
decl_stmt|;
if|#
directive|if
literal|0
comment|/* It doesn't make sense to use locking here: The function interface 	 * is not thread-safe, because threads can never be sure when 	 * some other thread destroys the data they were given a pointer to. 	 */
block|CRYPTO_w_lock(CRYPTO_LOCK_GETHOSTBYNAME);
endif|#
directive|endif
name|j
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|128
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GHBN_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|low
operator|>
name|ghbn_cache
index|[
name|i
index|]
operator|.
name|order
condition|)
block|{
name|low
operator|=
name|ghbn_cache
index|[
name|i
index|]
operator|.
name|order
expr_stmt|;
name|lowi
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|ghbn_cache
index|[
name|i
index|]
operator|.
name|order
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|ghbn_cache
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|128
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
block|}
else|else
name|i
operator|=
name|GHBN_NUM
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|GHBN_NUM
condition|)
comment|/* no hit*/
block|{
name|BIO_ghbn_miss
operator|++
expr_stmt|;
comment|/* Note: under VMS with SOCKETSHR, it seems like the first 		 * parameter is 'char *', instead of 'const char *' 		 */
ifndef|#
directive|ifndef
name|CONST_STRICT
name|ret
operator|=
name|gethostbyname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|j
operator|>
literal|128
condition|)
comment|/* too big to cache */
block|{
if|#
directive|if
literal|0
comment|/* If we were trying to make this function thread-safe (which 			 * is bound to fail), we'd have to give up in this case 			 * (or allocate more memory). */
block|ret = NULL;
endif|#
directive|endif
goto|goto
name|end
goto|;
block|}
comment|/* else add to cache */
if|if
condition|(
name|ghbn_cache
index|[
name|lowi
index|]
operator|.
name|ent
operator|!=
name|NULL
condition|)
name|ghbn_free
argument_list|(
name|ghbn_cache
index|[
name|lowi
index|]
operator|.
name|ent
argument_list|)
expr_stmt|;
comment|/* XXX not thread-safe */
name|ghbn_cache
index|[
name|lowi
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|ghbn_cache
index|[
name|lowi
index|]
operator|.
name|ent
operator|=
name|ghbn_dup
argument_list|(
name|ret
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_GETHOSTBYNAME
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|strncpy
argument_list|(
name|ghbn_cache
index|[
name|lowi
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|ghbn_cache
index|[
name|lowi
index|]
operator|.
name|order
operator|=
name|BIO_ghbn_miss
operator|+
name|BIO_ghbn_hits
expr_stmt|;
block|}
else|else
block|{
name|BIO_ghbn_hits
operator|++
expr_stmt|;
name|ret
operator|=
name|ghbn_cache
index|[
name|i
index|]
operator|.
name|ent
expr_stmt|;
name|ghbn_cache
index|[
name|i
index|]
operator|.
name|order
operator|=
name|BIO_ghbn_miss
operator|+
name|BIO_ghbn_hits
expr_stmt|;
block|}
name|end
label|:
if|#
directive|if
literal|0
block|CRYPTO_w_unlock(CRYPTO_LOCK_GETHOSTBYNAME);
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|BIO_sock_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OPENSSL_SYS_WINDOWS
specifier|static
name|struct
name|WSAData
name|wsa_state
decl_stmt|;
if|if
condition|(
operator|!
name|wsa_init_done
condition|)
block|{
name|int
name|err
decl_stmt|;
name|wsa_init_done
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|wsa_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|wsa_state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Not making wsa_state available to the rest of the 		 * code is formally wrong. But the structures we use 		 * are [beleived to be] invariable among Winsock DLLs, 		 * while API availability is [expected to be] probed 		 * at run-time with DSO_global_lookup. */
if|if
condition|(
name|WSAStartup
argument_list|(
literal|0x0202
argument_list|,
operator|&
name|wsa_state
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
name|SYSerr
argument_list|(
name|SYS_F_WSASTARTUP
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|BIOerr
argument_list|(
name|BIO_F_BIO_SOCK_INIT
argument_list|,
name|BIO_R_WSASTARTUP
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* OPENSSL_SYS_WINDOWS */
ifdef|#
directive|ifdef
name|WATT32
specifier|extern
name|int
name|_watt_do_exit
decl_stmt|;
name|_watt_do_exit
operator|=
literal|0
expr_stmt|;
comment|/* don't make sock_init() call exit() */
if|if
condition|(
name|sock_init
argument_list|()
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_SYS_NETWARE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NETWARE_BSDSOCK
argument_list|)
name|WORD
name|wVerReq
decl_stmt|;
name|WSADATA
name|wsaData
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|wsa_init_done
condition|)
block|{
name|wsa_init_done
operator|=
literal|1
expr_stmt|;
name|wVerReq
operator|=
name|MAKEWORD
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|WSAStartup
argument_list|(
name|wVerReq
argument_list|,
operator|&
name|wsaData
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|SYSerr
argument_list|(
name|SYS_F_WSASTARTUP
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|BIOerr
argument_list|(
name|BIO_F_BIO_SOCK_INIT
argument_list|,
name|BIO_R_WSASTARTUP
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|BIO_sock_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OPENSSL_SYS_WINDOWS
if|if
condition|(
name|wsa_init_done
condition|)
block|{
name|wsa_init_done
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* this call is claimed to be non-present in Winsock2 */
block|WSACancelBlockingCall();
endif|#
directive|endif
name|WSACleanup
argument_list|()
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|OPENSSL_SYS_NETWARE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NETWARE_BSDSOCK
argument_list|)
if|if
condition|(
name|wsa_init_done
condition|)
block|{
name|wsa_init_done
operator|=
literal|0
expr_stmt|;
name|WSACleanup
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OPENSSL_SYS_VMS
argument_list|)
operator|||
name|__VMS_VER
operator|>=
literal|70000000
end_if

begin_function
name|int
name|BIO_socket_ioctl
parameter_list|(
name|int
name|fd
parameter_list|,
name|long
name|type
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|__DJGPP__
name|i
operator|=
name|ioctlsocket
argument_list|(
name|fd
argument_list|,
name|type
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_SYS_VMS
argument_list|)
comment|/* 2011-02-18 SMS. 	 * VMS ioctl() can't tolerate a 64-bit "void *arg", but we 	 * observe that all the consumers pass in an "unsigned long *", 	 * so we arrange a local copy with a short pointer, and use 	 * that, instead. 	 */
if|#
directive|if
name|__INITIAL_POINTER_SIZE
operator|==
literal|64
define|#
directive|define
name|ARG
value|arg_32p
pragma|#
directive|pragma
name|pointer_size
name|save
pragma|#
directive|pragma
name|pointer_size
name|32
name|unsigned
name|long
name|arg_32
decl_stmt|;
name|unsigned
name|long
modifier|*
name|arg_32p
decl_stmt|;
pragma|#
directive|pragma
name|pointer_size
name|restore
name|arg_32p
operator|=
operator|&
name|arg_32
expr_stmt|;
name|arg_32
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|)
expr_stmt|;
else|#
directive|else
comment|/* __INITIAL_POINTER_SIZE == 64 */
define|#
directive|define
name|ARG
value|arg
endif|#
directive|endif
comment|/* __INITIAL_POINTER_SIZE == 64 [else] */
else|#
directive|else
comment|/* defined(OPENSSL_SYS_VMS) */
define|#
directive|define
name|ARG
value|arg
endif|#
directive|endif
comment|/* defined(OPENSSL_SYS_VMS) [else] */
name|i
operator|=
name|ioctlsocket
argument_list|(
name|fd
argument_list|,
name|type
argument_list|,
name|ARG
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __DJGPP__ */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|SYSerr
argument_list|(
name|SYS_F_IOCTLSOCKET
argument_list|,
name|get_last_socket_error
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __VMS_VER */
end_comment

begin_comment
comment|/* The reason I have implemented this instead of using sscanf is because  * Visual C 1.52c gives an unresolved external when linking a DLL :-( */
end_comment

begin_function
specifier|static
name|int
name|get_ip
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|unsigned
name|char
name|ip
index|[
literal|4
index|]
parameter_list|)
block|{
name|unsigned
name|int
name|tmp
index|[
literal|4
index|]
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|,
name|c
decl_stmt|,
name|ok
init|=
literal|0
decl_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
name|tmp
index|[
literal|1
index|]
operator|=
name|tmp
index|[
literal|2
index|]
operator|=
name|tmp
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
operator|(
name|str
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|ok
operator|=
literal|1
expr_stmt|;
name|tmp
index|[
name|num
index|]
operator|=
name|tmp
index|[
name|num
index|]
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|tmp
index|[
name|num
index|]
operator|>
literal|255
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
name|ok
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|num
operator|==
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|num
operator|++
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|&&
operator|(
name|num
operator|==
literal|3
operator|)
operator|&&
name|ok
condition|)
break|break;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ip
index|[
literal|0
index|]
operator|=
name|tmp
index|[
literal|0
index|]
expr_stmt|;
name|ip
index|[
literal|1
index|]
operator|=
name|tmp
index|[
literal|1
index|]
expr_stmt|;
name|ip
index|[
literal|2
index|]
operator|=
name|tmp
index|[
literal|2
index|]
expr_stmt|;
name|ip
index|[
literal|3
index|]
operator|=
name|tmp
index|[
literal|3
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|BIO_get_accept_socket
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|int
name|bind_mode
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
union|union
block|{
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|struct
name|sockaddr_in
name|sa_in
decl_stmt|;
if|#
directive|if
name|OPENSSL_USE_IPV6
name|struct
name|sockaddr_in6
name|sa_in6
decl_stmt|;
endif|#
directive|endif
block|}
name|server
union|,
name|client
union|;
name|int
name|s
init|=
name|INVALID_SOCKET
decl_stmt|,
name|cs
decl_stmt|,
name|addrlen
decl_stmt|;
name|unsigned
name|char
name|ip
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|short
name|port
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|NULL
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|h
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|l
decl_stmt|;
name|int
name|err_num
decl_stmt|;
if|if
condition|(
name|BIO_sock_init
argument_list|()
operator|!=
literal|1
condition|)
return|return
operator|(
name|INVALID_SOCKET
operator|)
return|;
if|if
condition|(
operator|(
name|str
operator|=
name|BUF_strdup
argument_list|(
name|host
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|INVALID_SOCKET
operator|)
return|;
name|h
operator|=
name|p
operator|=
name|NULL
expr_stmt|;
name|h
operator|=
name|str
expr_stmt|;
for|for
control|(
name|e
operator|=
name|str
init|;
operator|*
name|e
condition|;
name|e
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|e
operator|==
literal|':'
condition|)
block|{
name|p
operator|=
name|e
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|e
operator|==
literal|'/'
condition|)
block|{
operator|*
name|e
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* points at last ':', '::port' is special [see below] */
else|else
name|p
operator|=
name|h
operator|,
name|h
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|EAI_FAMILY
do|do
block|{
specifier|static
union|union
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|int
function_decl|(
name|WSAAPI
modifier|*
name|f
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|)
function_decl|;
block|}
name|p_getaddrinfo
init|=
block|{
name|NULL
block|}
union|;
specifier|static
union|union
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|void
function_decl|(
name|WSAAPI
modifier|*
name|f
function_decl|)
parameter_list|(
name|struct
name|addrinfo
modifier|*
parameter_list|)
function_decl|;
block|}
name|p_freeaddrinfo
init|=
block|{
name|NULL
block|}
union|;
name|struct
name|addrinfo
modifier|*
name|res
decl_stmt|,
name|hint
decl_stmt|;
if|if
condition|(
name|p_getaddrinfo
operator|.
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p_getaddrinfo
operator|.
name|p
operator|=
name|DSO_global_lookup
argument_list|(
literal|"getaddrinfo"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|p_freeaddrinfo
operator|.
name|p
operator|=
name|DSO_global_lookup
argument_list|(
literal|"freeaddrinfo"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p_getaddrinfo
operator|.
name|p
operator|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p_getaddrinfo
operator|.
name|p
operator|==
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
break|break;
comment|/* '::port' enforces IPv6 wildcard listener. Some OSes, 	 * e.g. Solaris, default to IPv6 without any hint. Also 	 * note that commonly IPv6 wildchard socket can service 	 * IPv4 connections just as well...  */
name|memset
argument_list|(
operator|&
name|hint
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hint
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|.
name|ai_flags
operator|=
name|AI_PASSIVE
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|h
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
if|if
condition|(
name|h
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|OPENSSL_USE_IPV6
name|hint
operator|.
name|ai_family
operator|=
name|AF_INET6
expr_stmt|;
else|#
directive|else
name|h
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|h
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|h
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|hint
operator|.
name|ai_family
operator|=
name|AF_INET
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
call|(
modifier|*
name|p_getaddrinfo
operator|.
name|f
call|)
argument_list|(
name|h
argument_list|,
name|p
argument_list|,
operator|&
name|hint
argument_list|,
operator|&
name|res
argument_list|)
condition|)
break|break;
name|addrlen
operator|=
name|res
operator|->
name|ai_addrlen
operator|<=
sizeof|sizeof
argument_list|(
name|server
argument_list|)
condition|?
name|res
operator|->
name|ai_addrlen
else|:
sizeof|sizeof
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|server
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
call|(
modifier|*
name|p_freeaddrinfo
operator|.
name|f
call|)
argument_list|(
name|res
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|BIO_get_port
argument_list|(
name|p
argument_list|,
operator|&
name|port
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|server
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|server
argument_list|)
argument_list|)
expr_stmt|;
name|server
operator|.
name|sa_in
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|server
operator|.
name|sa_in
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|server
operator|.
name|sa_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|h
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
name|server
operator|.
name|sa_in
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|BIO_get_host_ip
argument_list|(
name|h
argument_list|,
operator|&
operator|(
name|ip
index|[
literal|0
index|]
operator|)
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|l
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ip
index|[
literal|0
index|]
operator|<<
literal|24L
argument_list|)
operator||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|ip
index|[
literal|1
index|]
operator|<<
literal|16L
operator|)
operator||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|ip
index|[
literal|2
index|]
operator|<<
literal|8L
operator|)
operator||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|ip
index|[
literal|3
index|]
operator|)
expr_stmt|;
name|server
operator|.
name|sa_in
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
name|again
label|:
name|s
operator|=
name|socket
argument_list|(
name|server
operator|.
name|sa
operator|.
name|sa_family
argument_list|,
name|SOCK_STREAM
argument_list|,
name|SOCKET_PROTOCOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|SYSerr
argument_list|(
name|SYS_F_SOCKET
argument_list|,
name|get_last_socket_error
argument_list|()
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|3
argument_list|,
literal|"port='"
argument_list|,
name|host
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|BIOerr
argument_list|(
name|BIO_F_BIO_GET_ACCEPT_SOCKET
argument_list|,
name|BIO_R_UNABLE_TO_CREATE_SOCKET
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
ifdef|#
directive|ifdef
name|SO_REUSEADDR
if|if
condition|(
name|bind_mode
operator|==
name|BIO_BIND_REUSEADDR
condition|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
name|ret
operator|=
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|bind_mode
operator|=
name|BIO_BIND_NORMAL
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|&
name|server
operator|.
name|sa
argument_list|,
name|addrlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|SO_REUSEADDR
name|err_num
operator|=
name|get_last_socket_error
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|bind_mode
operator|==
name|BIO_BIND_REUSEADDR_IF_UNUSED
operator|)
operator|&&
ifdef|#
directive|ifdef
name|OPENSSL_SYS_WINDOWS
comment|/* Some versions of Windows define EADDRINUSE to 			 * a dummy value. 			 */
operator|(
name|err_num
operator|==
name|WSAEADDRINUSE
operator|)
condition|)
else|#
directive|else
operator|(
name|err_num
operator|==
name|EADDRINUSE
operator|)
block|)
endif|#
directive|endif
block|{
name|client
operator|=
name|server
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|h
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|OPENSSL_USE_IPV6
if|if
condition|(
name|client
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|memset
argument_list|(
operator|&
name|client
operator|.
name|sa_in6
operator|.
name|sin6_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|client
operator|.
name|sa_in6
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|client
operator|.
name|sa_in6
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
literal|15
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|client
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|client
operator|.
name|sa_in
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0x7F000001
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|err
goto|;
block|}
name|cs
operator|=
name|socket
argument_list|(
name|client
operator|.
name|sa
operator|.
name|sa_family
argument_list|,
name|SOCK_STREAM
argument_list|,
name|SOCKET_PROTOCOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|int
name|ii
decl_stmt|;
name|ii
operator|=
name|connect
argument_list|(
name|cs
argument_list|,
operator|&
name|client
operator|.
name|sa
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|bind_mode
operator|=
name|BIO_BIND_REUSEADDR
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* else error */
block|}
comment|/* else error */
block|}
endif|#
directive|endif
name|SYSerr
argument_list|(
name|SYS_F_BIND
argument_list|,
name|err_num
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|3
argument_list|,
literal|"port='"
argument_list|,
name|host
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|BIOerr
argument_list|(
name|BIO_F_BIO_GET_ACCEPT_SOCKET
argument_list|,
name|BIO_R_UNABLE_TO_BIND_SOCKET
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
end_function

begin_if
if|if
condition|(
name|listen
argument_list|(
name|s
argument_list|,
name|MAX_LISTEN
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|SYSerr
argument_list|(
name|SYS_F_BIND
argument_list|,
name|get_last_socket_error
argument_list|()
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|3
argument_list|,
literal|"port='"
argument_list|,
name|host
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|BIOerr
argument_list|(
name|BIO_F_BIO_GET_ACCEPT_SOCKET
argument_list|,
name|BIO_R_UNABLE_TO_LISTEN_SOCKET
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
end_if

begin_expr_stmt
name|ret
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_label
name|err
label|:
end_label

begin_if
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|&&
operator|(
name|s
operator|!=
name|INVALID_SOCKET
operator|)
condition|)
block|{
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|INVALID_SOCKET
expr_stmt|;
block|}
end_if

begin_return
return|return
operator|(
name|s
operator|)
return|;
end_return

begin_macro
unit|}  int
name|BIO_accept
argument_list|(
argument|int sock
argument_list|,
argument|char **addr
argument_list|)
end_macro

begin_block
block|{
name|int
name|ret
init|=
name|INVALID_SOCKET
decl_stmt|;
name|unsigned
name|long
name|l
decl_stmt|;
name|unsigned
name|short
name|port
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
struct|struct
block|{
comment|/* 	 * As for following union. Trouble is that there are platforms 	 * that have socklen_t and there are platforms that don't, on 	 * some platforms socklen_t is int and on some size_t. So what 	 * one can do? One can cook #ifdef spaghetti, which is nothing 	 * but masochistic. Or one can do union between int and size_t. 	 * One naturally does it primarily for 64-bit platforms where 	 * sizeof(int) != sizeof(size_t). But would it work? Note that 	 * if size_t member is initialized to 0, then later int member 	 * assignment naturally does the job on little-endian platforms 	 * regardless accept's expectations! What about big-endians? 	 * If accept expects int*, then it works, and if size_t*, then 	 * length value would appear as unreasonably large. But this 	 * won't prevent it from filling in the address structure. The 	 * trouble of course would be if accept returns more data than 	 * actual buffer can accomodate and overwrite stack... That's 	 * where early OPENSSL_assert comes into picture. Besides, the 	 * only 64-bit big-endian platform found so far that expects 	 * size_t* is HP-UX, where stack grows towards higher address. 	 *<appro> 	 */
union|union
block|{
name|size_t
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
block|}
name|len
union|;
union|union
block|{
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|struct
name|sockaddr_in
name|sa_in
decl_stmt|;
if|#
directive|if
name|OPENSSL_USE_IPV6
name|struct
name|sockaddr_in6
name|sa_in6
decl_stmt|;
endif|#
directive|endif
block|}
name|from
union|;
block|}
name|sa
struct|;
name|sa
operator|.
name|len
operator|.
name|s
operator|=
literal|0
expr_stmt|;
name|sa
operator|.
name|len
operator|.
name|i
operator|=
sizeof|sizeof
argument_list|(
name|sa
operator|.
name|from
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sa
operator|.
name|from
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
operator|.
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|accept
argument_list|(
name|sock
argument_list|,
operator|&
name|sa
operator|.
name|from
operator|.
name|sa
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sa
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|sa
operator|.
name|len
operator|.
name|i
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|sa
operator|.
name|len
operator|.
name|s
argument_list|)
operator|&&
name|sa
operator|.
name|len
operator|.
name|i
operator|==
literal|0
condition|)
block|{
name|OPENSSL_assert
argument_list|(
name|sa
operator|.
name|len
operator|.
name|s
operator|<=
sizeof|sizeof
argument_list|(
name|sa
operator|.
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|.
name|len
operator|.
name|i
operator|=
operator|(
name|int
operator|)
name|sa
operator|.
name|len
operator|.
name|s
expr_stmt|;
comment|/* use sa.len.i from this point */
block|}
if|if
condition|(
name|ret
operator|==
name|INVALID_SOCKET
condition|)
block|{
if|if
condition|(
name|BIO_sock_should_retry
argument_list|(
name|ret
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
name|SYSerr
argument_list|(
name|SYS_F_ACCEPT
argument_list|,
name|get_last_socket_error
argument_list|()
argument_list|)
expr_stmt|;
name|BIOerr
argument_list|(
name|BIO_F_BIO_ACCEPT
argument_list|,
name|BIO_R_ACCEPT_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
ifdef|#
directive|ifdef
name|EAI_FAMILY
do|do
block|{
name|char
name|h
index|[
name|NI_MAXHOST
index|]
decl_stmt|,
name|s
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|size_t
name|nl
decl_stmt|;
specifier|static
union|union
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|int
function_decl|(
name|WSAAPI
modifier|*
name|f
function_decl|)
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|size_t
comment|/*socklen_t*/
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
block|}
name|p_getnameinfo
init|=
block|{
name|NULL
block|}
union|;
comment|/* 2nd argument to getnameinfo is specified to 			 * be socklen_t. Unfortunately there is a number 			 * of environments where socklen_t is not defined. 			 * As it's passed by value, it's safe to pass it 			 * as size_t...<appro> */
if|if
condition|(
name|p_getnameinfo
operator|.
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p_getnameinfo
operator|.
name|p
operator|=
name|DSO_global_lookup
argument_list|(
literal|"getnameinfo"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p_getnameinfo
operator|.
name|p
operator|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p_getnameinfo
operator|.
name|p
operator|==
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
call|(
modifier|*
name|p_getnameinfo
operator|.
name|f
call|)
argument_list|(
operator|&
name|sa
operator|.
name|from
operator|.
name|sa
argument_list|,
name|sa
operator|.
name|len
operator|.
name|i
argument_list|,
name|h
argument_list|,
sizeof|sizeof
argument_list|(
name|h
argument_list|)
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
name|NI_NUMERICHOST
operator||
name|NI_NUMERICSERV
argument_list|)
condition|)
break|break;
name|nl
operator|=
name|strlen
argument_list|(
name|h
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
expr_stmt|;
name|p
operator|=
operator|*
name|addr
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|OPENSSL_realloc
argument_list|(
name|p
argument_list|,
name|nl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|OPENSSL_malloc
argument_list|(
name|nl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_ACCEPT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
operator|*
name|addr
operator|=
name|p
expr_stmt|;
name|BIO_snprintf
argument_list|(
operator|*
name|addr
argument_list|,
name|nl
argument_list|,
literal|"%s:%s"
argument_list|,
name|h
argument_list|,
name|s
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
endif|#
directive|endif
if|if
condition|(
name|sa
operator|.
name|from
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
goto|goto
name|end
goto|;
name|l
operator|=
name|ntohl
argument_list|(
name|sa
operator|.
name|from
operator|.
name|sa_in
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|port
operator|=
name|ntohs
argument_list|(
name|sa
operator|.
name|from
operator|.
name|sa_in
operator|.
name|sin_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|addr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|OPENSSL_malloc
argument_list|(
literal|24
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_ACCEPT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
operator|*
name|addr
operator|=
name|p
expr_stmt|;
block|}
name|BIO_snprintf
argument_list|(
operator|*
name|addr
argument_list|,
literal|24
argument_list|,
literal|"%d.%d.%d.%d:%d"
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|l
operator|>>
literal|24L
argument_list|)
operator|&
literal|0xff
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|l
operator|>>
literal|16L
argument_list|)
operator|&
literal|0xff
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|l
operator|>>
literal|8L
argument_list|)
operator|&
literal|0xff
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|l
argument_list|)
operator|&
literal|0xff
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|end
label|:
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_block

begin_function
name|int
name|BIO_set_tcp_ndelay
parameter_list|(
name|int
name|s
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TCP_NODELAY
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|IPPROTO_TCP
argument_list|)
operator|||
name|defined
argument_list|(
name|SOL_TCP
argument_list|)
operator|)
name|int
name|opt
decl_stmt|;
ifdef|#
directive|ifdef
name|SOL_TCP
name|opt
operator|=
name|SOL_TCP
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|IPPROTO_TCP
name|opt
operator|=
name|IPPROTO_TCP
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|ret
operator|=
name|setsockopt
argument_list|(
name|s
argument_list|,
name|opt
argument_list|,
name|TCP_NODELAY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ret
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|BIO_socket_nbio
parameter_list|(
name|int
name|s
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|l
decl_stmt|;
name|l
operator|=
name|mode
expr_stmt|;
ifdef|#
directive|ifdef
name|FIONBIO
name|ret
operator|=
name|BIO_socket_ioctl
argument_list|(
name|s
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ret
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

