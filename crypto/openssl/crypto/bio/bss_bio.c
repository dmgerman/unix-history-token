begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/bio/bss_bio.c  -*- Mode: C; c-file-style: "eay" -*- */
end_comment

begin_comment
comment|/* Special method for a BIO where the other endpoint is also a BIO  * of this kind, handled by the same thread (i.e. the "peer" is actually  * ourselves, wearing a different hat).  * Such "BIO pairs" are mainly for using the SSL library with I/O interfaces  * for which no specific BIO method is available.  * See ssl/ssltest.c for some hints on how this can be used. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BIO_PAIR_DEBUG
end_ifndef

begin_undef
undef|#
directive|undef
name|NDEBUG
end_undef

begin_comment
comment|/* avoid conflicting definitions */
end_comment

begin_define
define|#
directive|define
name|NDEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|"openssl/e_os.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SSIZE_MAX
end_ifndef

begin_define
define|#
directive|define
name|SSIZE_MAX
value|INT_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|bio_new
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bio_free
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bio_read
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bio_write
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|bio_ctrl
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|num
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bio_puts
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bio_make_pair
parameter_list|(
name|BIO
modifier|*
name|bio1
parameter_list|,
name|BIO
modifier|*
name|bio2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bio_destroy_pair
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|BIO_METHOD
name|methods_biop
init|=
block|{
name|BIO_TYPE_BIO
block|,
literal|"BIO pair"
block|,
name|bio_write
block|,
name|bio_read
block|,
name|bio_puts
block|,
name|NULL
comment|/* no bio_gets */
block|,
name|bio_ctrl
block|,
name|bio_new
block|,
name|bio_free
block|,
name|NULL
comment|/* no bio_callback_ctrl */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|BIO_METHOD
modifier|*
name|BIO_s_bio
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|methods_biop
return|;
block|}
end_function

begin_struct
struct|struct
name|bio_bio_st
block|{
name|BIO
modifier|*
name|peer
decl_stmt|;
comment|/* NULL if buf == NULL. 	                * If peer != NULL, then peer->ptr is also a bio_bio_st, 	                * and its "peer" member points back to us. 	                * peer != NULL iff init != 0 in the BIO. */
comment|/* This is for what we write (i.e. reading uses peer's struct): */
name|int
name|closed
decl_stmt|;
comment|/* valid iff peer != NULL */
name|size_t
name|len
decl_stmt|;
comment|/* valid iff buf != NULL; 0 if peer == NULL */
name|size_t
name|offset
decl_stmt|;
comment|/* valid iff buf != NULL; 0 if len == 0 */
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* "size" elements (if != NULL) */
name|size_t
name|request
decl_stmt|;
comment|/* valid iff peer != NULL; 0 if len != 0, 	                 * otherwise set by peer to number of bytes 	                 * it (unsuccessfully) tried to read, 	                 * never more than buffer space (size-len) warrants. */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|bio_new
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|)
block|{
name|struct
name|bio_bio_st
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
expr|*
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|b
operator|->
name|peer
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|size
operator|=
literal|17
operator|*
literal|1024
expr_stmt|;
comment|/* enough for one TLS record (just a default) */
name|b
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|bio
operator|->
name|ptr
operator|=
name|b
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bio_free
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|)
block|{
name|struct
name|bio_bio_st
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|bio
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|b
operator|=
name|bio
operator|->
name|ptr
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|peer
condition|)
name|bio_destroy_pair
argument_list|(
name|bio
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|b
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
name|OPENSSL_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bio_read
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size_
parameter_list|)
block|{
name|size_t
name|size
init|=
name|size_
decl_stmt|;
name|size_t
name|rest
decl_stmt|;
name|struct
name|bio_bio_st
modifier|*
name|b
decl_stmt|,
modifier|*
name|peer_b
decl_stmt|;
name|BIO_clear_retry_flags
argument_list|(
name|bio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bio
operator|->
name|init
condition|)
return|return
literal|0
return|;
name|b
operator|=
name|bio
operator|->
name|ptr
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|->
name|peer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|peer_b
operator|=
name|b
operator|->
name|peer
operator|->
name|ptr
expr_stmt|;
name|assert
argument_list|(
name|peer_b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|peer_b
operator|->
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|peer_b
operator|->
name|request
operator|=
literal|0
expr_stmt|;
comment|/* will be set in "retry_read" situation */
if|if
condition|(
name|buf
operator|==
name|NULL
operator|||
name|size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|peer_b
operator|->
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|peer_b
operator|->
name|closed
condition|)
return|return
literal|0
return|;
comment|/* writer has closed, and no data is left */
else|else
block|{
name|BIO_set_retry_read
argument_list|(
name|bio
argument_list|)
expr_stmt|;
comment|/* buffer is empty */
if|if
condition|(
name|size
operator|<=
name|peer_b
operator|->
name|size
condition|)
name|peer_b
operator|->
name|request
operator|=
name|size
expr_stmt|;
else|else
comment|/* don't ask for more than the peer can 				 * deliver in one write */
name|peer_b
operator|->
name|request
operator|=
name|peer_b
operator|->
name|size
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* we can read */
if|if
condition|(
name|peer_b
operator|->
name|len
operator|<
name|size
condition|)
name|size
operator|=
name|peer_b
operator|->
name|len
expr_stmt|;
comment|/* now read "size" bytes */
name|rest
operator|=
name|size
expr_stmt|;
name|assert
argument_list|(
name|rest
operator|>
literal|0
argument_list|)
expr_stmt|;
do|do
comment|/* one or two iterations */
block|{
name|size_t
name|chunk
decl_stmt|;
name|assert
argument_list|(
name|rest
operator|<=
name|peer_b
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer_b
operator|->
name|offset
operator|+
name|rest
operator|<=
name|peer_b
operator|->
name|size
condition|)
name|chunk
operator|=
name|rest
expr_stmt|;
else|else
comment|/* wrap around ring buffer */
name|chunk
operator|=
name|peer_b
operator|->
name|size
operator|-
name|peer_b
operator|->
name|offset
expr_stmt|;
name|assert
argument_list|(
name|peer_b
operator|->
name|offset
operator|+
name|chunk
operator|<=
name|peer_b
operator|->
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|peer_b
operator|->
name|buf
operator|+
name|peer_b
operator|->
name|offset
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|peer_b
operator|->
name|len
operator|-=
name|chunk
expr_stmt|;
if|if
condition|(
name|peer_b
operator|->
name|len
condition|)
block|{
name|peer_b
operator|->
name|offset
operator|+=
name|chunk
expr_stmt|;
name|assert
argument_list|(
name|peer_b
operator|->
name|offset
operator|<=
name|peer_b
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer_b
operator|->
name|offset
operator|==
name|peer_b
operator|->
name|size
condition|)
name|peer_b
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|buf
operator|+=
name|chunk
expr_stmt|;
block|}
else|else
block|{
comment|/* buffer now empty, no need to advance "buf" */
name|assert
argument_list|(
name|chunk
operator|==
name|rest
argument_list|)
expr_stmt|;
name|peer_b
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|rest
operator|-=
name|chunk
expr_stmt|;
block|}
do|while
condition|(
name|rest
condition|)
do|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* non-copying interface: provide pointer to available data in buffer  *    bio_nread0:  return number of available bytes  *    bio_nread:   also advance index  * (example usage:  bio_nread0(), read from buffer, bio_nread()  *  or just         bio_nread(), read from buffer)  */
end_comment

begin_comment
comment|/* WARNING: The non-copying interface is largely untested as of yet  * and may contain bugs. */
end_comment

begin_function
specifier|static
name|ssize_t
name|bio_nread0
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|bio_bio_st
modifier|*
name|b
decl_stmt|,
modifier|*
name|peer_b
decl_stmt|;
name|ssize_t
name|num
decl_stmt|;
name|BIO_clear_retry_flags
argument_list|(
name|bio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bio
operator|->
name|init
condition|)
return|return
literal|0
return|;
name|b
operator|=
name|bio
operator|->
name|ptr
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|->
name|peer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|peer_b
operator|=
name|b
operator|->
name|peer
operator|->
name|ptr
expr_stmt|;
name|assert
argument_list|(
name|peer_b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|peer_b
operator|->
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|peer_b
operator|->
name|request
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|peer_b
operator|->
name|len
operator|==
literal|0
condition|)
block|{
name|char
name|dummy
decl_stmt|;
comment|/* avoid code duplication -- nothing available for reading */
return|return
name|bio_read
argument_list|(
name|bio
argument_list|,
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
return|;
comment|/* returns 0 or -1 */
block|}
name|num
operator|=
name|peer_b
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|peer_b
operator|->
name|size
operator|<
name|peer_b
operator|->
name|offset
operator|+
name|num
condition|)
comment|/* no ring buffer wrap-around for non-copying interface */
name|num
operator|=
name|peer_b
operator|->
name|size
operator|-
name|peer_b
operator|->
name|offset
expr_stmt|;
name|assert
argument_list|(
name|num
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
operator|*
name|buf
operator|=
name|peer_b
operator|->
name|buf
operator|+
name|peer_b
operator|->
name|offset
expr_stmt|;
return|return
name|num
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|bio_nread
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|size_t
name|num_
parameter_list|)
block|{
name|struct
name|bio_bio_st
modifier|*
name|b
decl_stmt|,
modifier|*
name|peer_b
decl_stmt|;
name|ssize_t
name|num
decl_stmt|,
name|available
decl_stmt|;
if|if
condition|(
name|num_
operator|>
name|SSIZE_MAX
condition|)
name|num
operator|=
name|SSIZE_MAX
expr_stmt|;
else|else
name|num
operator|=
operator|(
name|ssize_t
operator|)
name|num_
expr_stmt|;
name|available
operator|=
name|bio_nread0
argument_list|(
name|bio
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|>
name|available
condition|)
name|num
operator|=
name|available
expr_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
return|return
name|num
return|;
name|b
operator|=
name|bio
operator|->
name|ptr
expr_stmt|;
name|peer_b
operator|=
name|b
operator|->
name|peer
operator|->
name|ptr
expr_stmt|;
name|peer_b
operator|->
name|len
operator|-=
name|num
expr_stmt|;
if|if
condition|(
name|peer_b
operator|->
name|len
condition|)
block|{
name|peer_b
operator|->
name|offset
operator|+=
name|num
expr_stmt|;
name|assert
argument_list|(
name|peer_b
operator|->
name|offset
operator|<=
name|peer_b
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer_b
operator|->
name|offset
operator|==
name|peer_b
operator|->
name|size
condition|)
name|peer_b
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|peer_b
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
return|return
name|num
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bio_write
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num_
parameter_list|)
block|{
name|size_t
name|num
init|=
name|num_
decl_stmt|;
name|size_t
name|rest
decl_stmt|;
name|struct
name|bio_bio_st
modifier|*
name|b
decl_stmt|;
name|BIO_clear_retry_flags
argument_list|(
name|bio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bio
operator|->
name|init
operator|||
name|buf
operator|==
name|NULL
operator|||
name|num
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|b
operator|=
name|bio
operator|->
name|ptr
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|->
name|peer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|->
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|b
operator|->
name|request
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|closed
condition|)
block|{
comment|/* we already closed */
name|BIOerr
argument_list|(
name|BIO_F_BIO_WRITE
argument_list|,
name|BIO_R_BROKEN_PIPE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|assert
argument_list|(
name|b
operator|->
name|len
operator|<=
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|len
operator|==
name|b
operator|->
name|size
condition|)
block|{
name|BIO_set_retry_write
argument_list|(
name|bio
argument_list|)
expr_stmt|;
comment|/* buffer is full */
return|return
operator|-
literal|1
return|;
block|}
comment|/* we can write */
if|if
condition|(
name|num
operator|>
name|b
operator|->
name|size
operator|-
name|b
operator|->
name|len
condition|)
name|num
operator|=
name|b
operator|->
name|size
operator|-
name|b
operator|->
name|len
expr_stmt|;
comment|/* now write "num" bytes */
name|rest
operator|=
name|num
expr_stmt|;
name|assert
argument_list|(
name|rest
operator|>
literal|0
argument_list|)
expr_stmt|;
do|do
comment|/* one or two iterations */
block|{
name|size_t
name|write_offset
decl_stmt|;
name|size_t
name|chunk
decl_stmt|;
name|assert
argument_list|(
name|b
operator|->
name|len
operator|+
name|rest
operator|<=
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
name|write_offset
operator|=
name|b
operator|->
name|offset
operator|+
name|b
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|write_offset
operator|>=
name|b
operator|->
name|size
condition|)
name|write_offset
operator|-=
name|b
operator|->
name|size
expr_stmt|;
comment|/* b->buf[write_offset] is the first byte we can write to. */
if|if
condition|(
name|write_offset
operator|+
name|rest
operator|<=
name|b
operator|->
name|size
condition|)
name|chunk
operator|=
name|rest
expr_stmt|;
else|else
comment|/* wrap around ring buffer */
name|chunk
operator|=
name|b
operator|->
name|size
operator|-
name|write_offset
expr_stmt|;
name|memcpy
argument_list|(
name|b
operator|->
name|buf
operator|+
name|write_offset
argument_list|,
name|buf
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|b
operator|->
name|len
operator|+=
name|chunk
expr_stmt|;
name|assert
argument_list|(
name|b
operator|->
name|len
operator|<=
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
name|rest
operator|-=
name|chunk
expr_stmt|;
name|buf
operator|+=
name|chunk
expr_stmt|;
block|}
do|while
condition|(
name|rest
condition|)
do|;
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/* non-copying interface: provide pointer to region to write to  *   bio_nwrite0:  check how much space is available  *   bio_nwrite:   also increase length  * (example usage:  bio_nwrite0(), write to buffer, bio_nwrite()  *  or just         bio_nwrite(), write to buffer)  */
end_comment

begin_function
specifier|static
name|ssize_t
name|bio_nwrite0
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|bio_bio_st
modifier|*
name|b
decl_stmt|;
name|size_t
name|num
decl_stmt|;
name|size_t
name|write_offset
decl_stmt|;
name|BIO_clear_retry_flags
argument_list|(
name|bio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bio
operator|->
name|init
condition|)
return|return
literal|0
return|;
name|b
operator|=
name|bio
operator|->
name|ptr
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|->
name|peer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|->
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|b
operator|->
name|request
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|closed
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_NWRITE0
argument_list|,
name|BIO_R_BROKEN_PIPE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|assert
argument_list|(
name|b
operator|->
name|len
operator|<=
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|len
operator|==
name|b
operator|->
name|size
condition|)
block|{
name|BIO_set_retry_write
argument_list|(
name|bio
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|num
operator|=
name|b
operator|->
name|size
operator|-
name|b
operator|->
name|len
expr_stmt|;
name|write_offset
operator|=
name|b
operator|->
name|offset
operator|+
name|b
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|write_offset
operator|>=
name|b
operator|->
name|size
condition|)
name|write_offset
operator|-=
name|b
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|write_offset
operator|+
name|num
operator|>
name|b
operator|->
name|size
condition|)
comment|/* no ring buffer wrap-around for non-copying interface 		 * (to fulfil the promise by BIO_ctrl_get_write_guarantee, 		 * BIO_nwrite may have to be called twice) */
name|num
operator|=
name|b
operator|->
name|size
operator|-
name|write_offset
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
operator|*
name|buf
operator|=
name|b
operator|->
name|buf
operator|+
name|write_offset
expr_stmt|;
name|assert
argument_list|(
name|write_offset
operator|+
name|num
operator|<=
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|num
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|bio_nwrite
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|size_t
name|num_
parameter_list|)
block|{
name|struct
name|bio_bio_st
modifier|*
name|b
decl_stmt|;
name|ssize_t
name|num
decl_stmt|,
name|space
decl_stmt|;
if|if
condition|(
name|num_
operator|>
name|SSIZE_MAX
condition|)
name|num
operator|=
name|SSIZE_MAX
expr_stmt|;
else|else
name|num
operator|=
operator|(
name|ssize_t
operator|)
name|num_
expr_stmt|;
name|space
operator|=
name|bio_nwrite0
argument_list|(
name|bio
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|>
name|space
condition|)
name|num
operator|=
name|space
expr_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
return|return
name|num
return|;
name|b
operator|=
name|bio
operator|->
name|ptr
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|b
operator|->
name|len
operator|+=
name|num
expr_stmt|;
name|assert
argument_list|(
name|b
operator|->
name|len
operator|<=
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|num
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|bio_ctrl
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|num
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|long
name|ret
decl_stmt|;
name|struct
name|bio_bio_st
modifier|*
name|b
init|=
name|bio
operator|->
name|ptr
decl_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* specific CTRL codes */
case|case
name|BIO_C_SET_WRITE_BUF_SIZE
case|:
if|if
condition|(
name|b
operator|->
name|peer
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_CTRL
argument_list|,
name|BIO_R_IN_USE
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_CTRL
argument_list|,
name|BIO_R_INVALID_ARGUMENT
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|new_size
init|=
name|num
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|size
operator|!=
name|new_size
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|buf
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|b
operator|->
name|buf
argument_list|)
expr_stmt|;
name|b
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
name|b
operator|->
name|size
operator|=
name|new_size
expr_stmt|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BIO_C_GET_WRITE_BUF_SIZE
case|:
name|num
operator|=
operator|(
name|long
operator|)
name|b
operator|->
name|size
expr_stmt|;
case|case
name|BIO_C_MAKE_BIO_PAIR
case|:
block|{
name|BIO
modifier|*
name|other_bio
init|=
name|ptr
decl_stmt|;
if|if
condition|(
name|bio_make_pair
argument_list|(
name|bio
argument_list|,
name|other_bio
argument_list|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
else|else
name|ret
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|BIO_C_DESTROY_BIO_PAIR
case|:
comment|/* Effects both BIOs in the pair -- call just once! 		 * Or let BIO_free(bio1); BIO_free(bio2); do the job. */
name|bio_destroy_pair
argument_list|(
name|bio
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BIO_C_GET_WRITE_GUARANTEE
case|:
comment|/* How many bytes can the caller feed to the next write 		 * without having to keep any? */
if|if
condition|(
name|b
operator|->
name|peer
operator|==
name|NULL
operator|||
name|b
operator|->
name|closed
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
name|ret
operator|=
operator|(
name|long
operator|)
name|b
operator|->
name|size
operator|-
name|b
operator|->
name|len
expr_stmt|;
break|break;
case|case
name|BIO_C_GET_READ_REQUEST
case|:
comment|/* If the peer unsuccessfully tried to read, how many bytes 		 * were requested?  (As with BIO_CTRL_PENDING, that number 		 * can usually be treated as boolean.) */
name|ret
operator|=
operator|(
name|long
operator|)
name|b
operator|->
name|request
expr_stmt|;
break|break;
case|case
name|BIO_C_RESET_READ_REQUEST
case|:
comment|/* Reset request.  (Can be useful after read attempts 		 * at the other side that are meant to be non-blocking, 		 * e.g. when probing SSL_read to see if any data is 		 * available.) */
name|b
operator|->
name|request
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BIO_C_SHUTDOWN_WR
case|:
comment|/* similar to shutdown(..., SHUT_WR) */
name|b
operator|->
name|closed
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BIO_C_NREAD0
case|:
comment|/* prepare for non-copying read */
name|ret
operator|=
operator|(
name|long
operator|)
name|bio_nread0
argument_list|(
name|bio
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_C_NREAD
case|:
comment|/* non-copying read */
name|ret
operator|=
operator|(
name|long
operator|)
name|bio_nread
argument_list|(
name|bio
argument_list|,
name|ptr
argument_list|,
operator|(
name|size_t
operator|)
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_C_NWRITE0
case|:
comment|/* prepare for non-copying write */
name|ret
operator|=
operator|(
name|long
operator|)
name|bio_nwrite0
argument_list|(
name|bio
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_C_NWRITE
case|:
comment|/* non-copying write */
name|ret
operator|=
operator|(
name|long
operator|)
name|bio_nwrite
argument_list|(
name|bio
argument_list|,
name|ptr
argument_list|,
operator|(
name|size_t
operator|)
name|num
argument_list|)
expr_stmt|;
break|break;
comment|/* standard CTRL codes follow */
case|case
name|BIO_CTRL_RESET
case|:
if|if
condition|(
name|b
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|b
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BIO_CTRL_GET_CLOSE
case|:
name|ret
operator|=
name|bio
operator|->
name|shutdown
expr_stmt|;
break|break;
case|case
name|BIO_CTRL_SET_CLOSE
case|:
name|bio
operator|->
name|shutdown
operator|=
operator|(
name|int
operator|)
name|num
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BIO_CTRL_PENDING
case|:
if|if
condition|(
name|b
operator|->
name|peer
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bio_bio_st
modifier|*
name|peer_b
init|=
name|b
operator|->
name|peer
operator|->
name|ptr
decl_stmt|;
name|ret
operator|=
operator|(
name|long
operator|)
name|peer_b
operator|->
name|len
expr_stmt|;
block|}
else|else
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BIO_CTRL_WPENDING
case|:
if|if
condition|(
name|b
operator|->
name|buf
operator|!=
name|NULL
condition|)
name|ret
operator|=
operator|(
name|long
operator|)
name|b
operator|->
name|len
expr_stmt|;
else|else
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BIO_CTRL_DUP
case|:
comment|/* See BIO_dup_chain for circumstances we have to expect. */
block|{
name|BIO
modifier|*
name|other_bio
init|=
name|ptr
decl_stmt|;
name|struct
name|bio_bio_st
modifier|*
name|other_b
decl_stmt|;
name|assert
argument_list|(
name|other_bio
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|other_b
operator|=
name|other_bio
operator|->
name|ptr
expr_stmt|;
name|assert
argument_list|(
name|other_b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|other_b
operator|->
name|buf
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* other_bio is always fresh */
name|other_b
operator|->
name|size
operator|=
name|b
operator|->
name|size
expr_stmt|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BIO_CTRL_FLUSH
case|:
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BIO_CTRL_EOF
case|:
block|{
name|BIO
modifier|*
name|other_bio
init|=
name|ptr
decl_stmt|;
if|if
condition|(
name|other_bio
condition|)
block|{
name|struct
name|bio_bio_st
modifier|*
name|other_b
init|=
name|other_bio
operator|->
name|ptr
decl_stmt|;
name|assert
argument_list|(
name|other_b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|other_b
operator|->
name|len
operator|==
literal|0
operator|&&
name|other_b
operator|->
name|closed
expr_stmt|;
block|}
else|else
name|ret
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|ret
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bio_puts
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|bio_write
argument_list|(
name|bio
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bio_make_pair
parameter_list|(
name|BIO
modifier|*
name|bio1
parameter_list|,
name|BIO
modifier|*
name|bio2
parameter_list|)
block|{
name|struct
name|bio_bio_st
modifier|*
name|b1
decl_stmt|,
modifier|*
name|b2
decl_stmt|;
name|assert
argument_list|(
name|bio1
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|bio2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|b1
operator|=
name|bio1
operator|->
name|ptr
expr_stmt|;
name|b2
operator|=
name|bio2
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|b1
operator|->
name|peer
operator|!=
name|NULL
operator|||
name|b2
operator|->
name|peer
operator|!=
name|NULL
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_MAKE_PAIR
argument_list|,
name|BIO_R_IN_USE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|b1
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|b1
operator|->
name|buf
operator|=
name|OPENSSL_malloc
argument_list|(
name|b1
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_MAKE_PAIR
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|b1
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|b1
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|b2
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|b2
operator|->
name|buf
operator|=
name|OPENSSL_malloc
argument_list|(
name|b2
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_MAKE_PAIR
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|b2
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|b2
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|b1
operator|->
name|peer
operator|=
name|bio2
expr_stmt|;
name|b1
operator|->
name|closed
operator|=
literal|0
expr_stmt|;
name|b1
operator|->
name|request
operator|=
literal|0
expr_stmt|;
name|b2
operator|->
name|peer
operator|=
name|bio1
expr_stmt|;
name|b2
operator|->
name|closed
operator|=
literal|0
expr_stmt|;
name|b2
operator|->
name|request
operator|=
literal|0
expr_stmt|;
name|bio1
operator|->
name|init
operator|=
literal|1
expr_stmt|;
name|bio2
operator|->
name|init
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bio_destroy_pair
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|)
block|{
name|struct
name|bio_bio_st
modifier|*
name|b
init|=
name|bio
operator|->
name|ptr
decl_stmt|;
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
block|{
name|BIO
modifier|*
name|peer_bio
init|=
name|b
operator|->
name|peer
decl_stmt|;
if|if
condition|(
name|peer_bio
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bio_bio_st
modifier|*
name|peer_b
init|=
name|peer_bio
operator|->
name|ptr
decl_stmt|;
name|assert
argument_list|(
name|peer_b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|peer_b
operator|->
name|peer
operator|==
name|bio
argument_list|)
expr_stmt|;
name|peer_b
operator|->
name|peer
operator|=
name|NULL
expr_stmt|;
name|peer_bio
operator|->
name|init
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|peer_b
operator|->
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|peer_b
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|peer_b
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|peer
operator|=
name|NULL
expr_stmt|;
name|bio
operator|->
name|init
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|b
operator|->
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|b
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Exported convenience functions */
end_comment

begin_function
name|int
name|BIO_new_bio_pair
parameter_list|(
name|BIO
modifier|*
modifier|*
name|bio1_p
parameter_list|,
name|size_t
name|writebuf1
parameter_list|,
name|BIO
modifier|*
modifier|*
name|bio2_p
parameter_list|,
name|size_t
name|writebuf2
parameter_list|)
block|{
name|BIO
modifier|*
name|bio1
init|=
name|NULL
decl_stmt|,
modifier|*
name|bio2
init|=
name|NULL
decl_stmt|;
name|long
name|r
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|bio1
operator|=
name|BIO_new
argument_list|(
name|BIO_s_bio
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|bio1
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|bio2
operator|=
name|BIO_new
argument_list|(
name|BIO_s_bio
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|bio2
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|writebuf1
condition|)
block|{
name|r
operator|=
name|BIO_set_write_buf_size
argument_list|(
name|bio1
argument_list|,
name|writebuf1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|writebuf2
condition|)
block|{
name|r
operator|=
name|BIO_set_write_buf_size
argument_list|(
name|bio2
argument_list|,
name|writebuf2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
goto|goto
name|err
goto|;
block|}
name|r
operator|=
name|BIO_make_bio_pair
argument_list|(
name|bio1
argument_list|,
name|bio2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bio1
condition|)
block|{
name|BIO_free
argument_list|(
name|bio1
argument_list|)
expr_stmt|;
name|bio1
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bio2
condition|)
block|{
name|BIO_free
argument_list|(
name|bio2
argument_list|)
expr_stmt|;
name|bio2
operator|=
name|NULL
expr_stmt|;
block|}
block|}
operator|*
name|bio1_p
operator|=
name|bio1
expr_stmt|;
operator|*
name|bio2_p
operator|=
name|bio2
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|size_t
name|BIO_ctrl_get_write_guarantee
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|)
block|{
return|return
name|BIO_ctrl
argument_list|(
name|bio
argument_list|,
name|BIO_C_GET_WRITE_GUARANTEE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|BIO_ctrl_get_read_request
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|)
block|{
return|return
name|BIO_ctrl
argument_list|(
name|bio
argument_list|,
name|BIO_C_GET_READ_REQUEST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|BIO_ctrl_reset_read_request
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|)
block|{
return|return
operator|(
name|BIO_ctrl
argument_list|(
name|bio
argument_list|,
name|BIO_C_RESET_READ_REQUEST
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* BIO_nread0/nread/nwrite0/nwrite are available only for BIO pairs for now  * (conceivably some other BIOs could allow non-copying reads and writes too.)  */
end_comment

begin_function
name|int
name|BIO_nread0
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
name|long
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|bio
operator|->
name|init
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_NREAD0
argument_list|,
name|BIO_R_UNINITIALIZED
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|ret
operator|=
name|BIO_ctrl
argument_list|(
name|bio
argument_list|,
name|BIO_C_NREAD0
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
name|INT_MAX
condition|)
return|return
name|INT_MAX
return|;
else|else
return|return
operator|(
name|int
operator|)
name|ret
return|;
block|}
end_function

begin_function
name|int
name|BIO_nread
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|bio
operator|->
name|init
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_NREAD
argument_list|,
name|BIO_R_UNINITIALIZED
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|ret
operator|=
operator|(
name|int
operator|)
name|BIO_ctrl
argument_list|(
name|bio
argument_list|,
name|BIO_C_NREAD
argument_list|,
name|num
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
name|bio
operator|->
name|num_read
operator|+=
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|BIO_nwrite0
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
name|long
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|bio
operator|->
name|init
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_NWRITE0
argument_list|,
name|BIO_R_UNINITIALIZED
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|ret
operator|=
name|BIO_ctrl
argument_list|(
name|bio
argument_list|,
name|BIO_C_NWRITE0
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
name|INT_MAX
condition|)
return|return
name|INT_MAX
return|;
else|else
return|return
operator|(
name|int
operator|)
name|ret
return|;
block|}
end_function

begin_function
name|int
name|BIO_nwrite
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|bio
operator|->
name|init
condition|)
block|{
name|BIOerr
argument_list|(
name|BIO_F_BIO_NWRITE
argument_list|,
name|BIO_R_UNINITIALIZED
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|ret
operator|=
name|BIO_ctrl
argument_list|(
name|bio
argument_list|,
name|BIO_C_NWRITE
argument_list|,
name|num
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
name|bio
operator|->
name|num_read
operator|+=
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

