begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/ecdsa/ecdsatest.c */
end_comment

begin_comment
comment|/*  * Written by Nils Larsch for the OpenSSL project.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.  *  * Portions of the attached software ("Contribution") are developed by  * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.  *  * The Contribution is licensed pursuant to the OpenSSL open source  * license provided above.  *  * The elliptic curve binary polynomial software is originally written by  * Sheueling Chang Shantz and Douglas Stebila of Sun Microsystems Laboratories.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/opensslconf.h>
end_include

begin_comment
comment|/* To see if OPENSSL_NO_ECDSA is defined */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_NO_ECDSA
end_ifdef

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|puts
argument_list|(
literal|"Elliptic curves are disabled."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ecdsa.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_ENGINE
end_ifndef

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rnd_seed
index|[]
init|=
literal|"string to make the random number generator "
literal|"think it has entropy"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* declaration of the test functions */
end_comment

begin_function_decl
name|int
name|x9_62_tests
parameter_list|(
name|BIO
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|x9_62_test_internal
parameter_list|(
name|BIO
modifier|*
name|out
parameter_list|,
name|int
name|nid
parameter_list|,
specifier|const
name|char
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|test_builtin
parameter_list|(
name|BIO
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* functions to change the RAND_METHOD */
end_comment

begin_function_decl
name|int
name|change_rand
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|restore_rand
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|fbytes
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|RAND_METHOD
name|fake_rand
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|RAND_METHOD
modifier|*
name|old_rand
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|change_rand
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* save old rand method */
if|if
condition|(
operator|(
name|old_rand
operator|=
name|RAND_get_rand_method
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|fake_rand
operator|.
name|seed
operator|=
name|old_rand
operator|->
name|seed
expr_stmt|;
name|fake_rand
operator|.
name|cleanup
operator|=
name|old_rand
operator|->
name|cleanup
expr_stmt|;
name|fake_rand
operator|.
name|add
operator|=
name|old_rand
operator|->
name|add
expr_stmt|;
name|fake_rand
operator|.
name|status
operator|=
name|old_rand
operator|->
name|status
expr_stmt|;
comment|/* use own random function */
name|fake_rand
operator|.
name|bytes
operator|=
name|fbytes
expr_stmt|;
name|fake_rand
operator|.
name|pseudorand
operator|=
name|old_rand
operator|->
name|bytes
expr_stmt|;
comment|/* set new RAND_METHOD */
if|if
condition|(
operator|!
name|RAND_set_rand_method
argument_list|(
operator|&
name|fake_rand
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|restore_rand
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|RAND_set_rand_method
argument_list|(
name|old_rand
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|fbytes_counter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|numbers
index|[
literal|8
index|]
init|=
block|{
literal|"651056770906015076056810763456358567190100156695615665659"
block|,
literal|"6140507067065001063065065565667405560006161556565665656654"
block|,
literal|"8763001015071075675010661307616710783570106710677817767166"
literal|"71676178726717"
block|,
literal|"7000000175690566466555057817571571075705015757757057795755"
literal|"55657156756655"
block|,
literal|"1275552191113212300012030439187146164646146646466749494799"
block|,
literal|"1542725565216523985789236956265265265235675811949404040041"
block|,
literal|"1456427555219115346513212300075341203043918714616464614664"
literal|"64667494947990"
block|,
literal|"1712787255652165239672857892369562652652652356758119494040"
literal|"40041670216363"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|fbytes
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|BIGNUM
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|fbytes_counter
operator|>=
literal|8
condition|)
return|return
literal|0
return|;
name|tmp
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|BN_dec2bn
argument_list|(
operator|&
name|tmp
argument_list|,
name|numbers
index|[
name|fbytes_counter
index|]
argument_list|)
condition|)
block|{
name|BN_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fbytes_counter
operator|++
expr_stmt|;
if|if
condition|(
name|num
operator|!=
name|BN_num_bytes
argument_list|(
name|tmp
argument_list|)
operator|||
operator|!
name|BN_bn2bin
argument_list|(
name|tmp
argument_list|,
name|buf
argument_list|)
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|BN_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* some tests from the X9.62 draft */
end_comment

begin_function
name|int
name|x9_62_test_internal
parameter_list|(
name|BIO
modifier|*
name|out
parameter_list|,
name|int
name|nid
parameter_list|,
specifier|const
name|char
modifier|*
name|r_in
parameter_list|,
specifier|const
name|char
modifier|*
name|s_in
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|char
name|message
index|[]
init|=
literal|"abc"
decl_stmt|;
name|unsigned
name|char
name|digest
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|int
name|dgst_len
init|=
literal|0
decl_stmt|;
name|EVP_MD_CTX
name|md_ctx
decl_stmt|;
name|EC_KEY
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|ECDSA_SIG
modifier|*
name|signature
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|r
init|=
name|NULL
decl_stmt|,
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|EVP_MD_CTX_init
argument_list|(
operator|&
name|md_ctx
argument_list|)
expr_stmt|;
comment|/* get the message digest */
name|EVP_DigestInit
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|EVP_ecdsa
argument_list|()
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md_ctx
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|message
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|EVP_DigestFinal
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|digest
argument_list|,
operator|&
name|dgst_len
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"testing %s: "
argument_list|,
name|OBJ_nid2sn
argument_list|(
name|nid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create the key */
if|if
condition|(
operator|(
name|key
operator|=
name|EC_KEY_new_by_curve_name
argument_list|(
name|nid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|x962_int_err
goto|;
if|if
condition|(
operator|!
name|EC_KEY_generate_key
argument_list|(
name|key
argument_list|)
condition|)
goto|goto
name|x962_int_err
goto|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_flush
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|/* create the signature */
name|signature
operator|=
name|ECDSA_do_sign
argument_list|(
name|digest
argument_list|,
literal|20
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|signature
operator|==
name|NULL
condition|)
goto|goto
name|x962_int_err
goto|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_flush
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|/* compare the created signature with the expected signature */
if|if
condition|(
operator|(
name|r
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|s
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|x962_int_err
goto|;
if|if
condition|(
operator|!
name|BN_dec2bn
argument_list|(
operator|&
name|r
argument_list|,
name|r_in
argument_list|)
operator|||
operator|!
name|BN_dec2bn
argument_list|(
operator|&
name|s
argument_list|,
name|s_in
argument_list|)
condition|)
goto|goto
name|x962_int_err
goto|;
if|if
condition|(
name|BN_cmp
argument_list|(
name|signature
operator|->
name|r
argument_list|,
name|r
argument_list|)
operator|||
name|BN_cmp
argument_list|(
name|signature
operator|->
name|s
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|x962_int_err
goto|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_flush
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|/* verify the signature */
if|if
condition|(
name|ECDSA_do_verify
argument_list|(
name|digest
argument_list|,
literal|20
argument_list|,
name|signature
argument_list|,
name|key
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|x962_int_err
goto|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_flush
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|" ok\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|x962_int_err
label|:
if|if
condition|(
operator|!
name|ret
condition|)
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|" failed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
condition|)
name|EC_KEY_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|signature
condition|)
name|ECDSA_SIG_free
argument_list|(
name|signature
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|BN_free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|md_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|x9_62_tests
parameter_list|(
name|BIO
modifier|*
name|out
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"some tests from X9.62:\n"
argument_list|)
expr_stmt|;
comment|/* set own rand method */
if|if
condition|(
operator|!
name|change_rand
argument_list|()
condition|)
goto|goto
name|x962_err
goto|;
if|if
condition|(
operator|!
name|x9_62_test_internal
argument_list|(
name|out
argument_list|,
name|NID_X9_62_prime192v1
argument_list|,
literal|"3342403536405981729393488334694600415596881826869351677613"
argument_list|,
literal|"5735822328888155254683894997897571951568553642892029982342"
argument_list|)
condition|)
goto|goto
name|x962_err
goto|;
if|if
condition|(
operator|!
name|x9_62_test_internal
argument_list|(
name|out
argument_list|,
name|NID_X9_62_prime239v1
argument_list|,
literal|"3086361431751678114926225473006680188549593787585317781474"
literal|"62058306432176"
argument_list|,
literal|"3238135532097973577080787768312505059318910517550078427819"
literal|"78505179448783"
argument_list|)
condition|)
goto|goto
name|x962_err
goto|;
if|if
condition|(
operator|!
name|x9_62_test_internal
argument_list|(
name|out
argument_list|,
name|NID_X9_62_c2tnb191v1
argument_list|,
literal|"87194383164871543355722284926904419997237591535066528048"
argument_list|,
literal|"308992691965804947361541664549085895292153777025772063598"
argument_list|)
condition|)
goto|goto
name|x962_err
goto|;
if|if
condition|(
operator|!
name|x9_62_test_internal
argument_list|(
name|out
argument_list|,
name|NID_X9_62_c2tnb239v1
argument_list|,
literal|"2159633321041961198501834003903461262881815148684178964245"
literal|"5876922391552"
argument_list|,
literal|"1970303740007316867383349976549972270528498040721988191026"
literal|"49413465737174"
argument_list|)
condition|)
goto|goto
name|x962_err
goto|;
name|ret
operator|=
literal|1
expr_stmt|;
name|x962_err
label|:
if|if
condition|(
operator|!
name|restore_rand
argument_list|()
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|test_builtin
parameter_list|(
name|BIO
modifier|*
name|out
parameter_list|)
block|{
name|EC_builtin_curve
modifier|*
name|curves
init|=
name|NULL
decl_stmt|;
name|size_t
name|crv_len
init|=
literal|0
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|EC_KEY
modifier|*
name|eckey
init|=
name|NULL
decl_stmt|,
modifier|*
name|wrong_eckey
init|=
name|NULL
decl_stmt|;
name|EC_GROUP
modifier|*
name|group
decl_stmt|;
name|ECDSA_SIG
modifier|*
name|ecdsa_sig
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|digest
index|[
literal|20
index|]
decl_stmt|,
name|wrong_digest
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|signature
init|=
name|NULL
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|sig_ptr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|sig_ptr2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|raw_buf
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|sig_len
decl_stmt|,
name|degree
decl_stmt|,
name|r_len
decl_stmt|,
name|s_len
decl_stmt|,
name|bn_len
decl_stmt|,
name|buf_len
decl_stmt|;
name|int
name|nid
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
comment|/* fill digest values with some random data */
if|if
condition|(
operator|!
name|RAND_pseudo_bytes
argument_list|(
name|digest
argument_list|,
literal|20
argument_list|)
operator|||
operator|!
name|RAND_pseudo_bytes
argument_list|(
name|wrong_digest
argument_list|,
literal|20
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"ERROR: unable to get random data\n"
argument_list|)
expr_stmt|;
goto|goto
name|builtin_err
goto|;
block|}
comment|/*      * create and verify a ecdsa signature with every availble curve (with )      */
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\ntesting ECDSA_sign() and ECDSA_verify() "
literal|"with some internal curves:\n"
argument_list|)
expr_stmt|;
comment|/* get a list of all internal curves */
name|crv_len
operator|=
name|EC_get_builtin_curves
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curves
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EC_builtin_curve
argument_list|)
operator|*
name|crv_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|curves
operator|==
name|NULL
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"malloc error\n"
argument_list|)
expr_stmt|;
goto|goto
name|builtin_err
goto|;
block|}
if|if
condition|(
operator|!
name|EC_get_builtin_curves
argument_list|(
name|curves
argument_list|,
name|crv_len
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"unable to get internal curves\n"
argument_list|)
expr_stmt|;
goto|goto
name|builtin_err
goto|;
block|}
comment|/* now create and verify a signature for every curve */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|crv_len
condition|;
name|n
operator|++
control|)
block|{
name|unsigned
name|char
name|dirt
decl_stmt|,
name|offset
decl_stmt|;
name|nid
operator|=
name|curves
index|[
name|n
index|]
operator|.
name|nid
expr_stmt|;
if|if
condition|(
name|nid
operator|==
name|NID_ipsec4
condition|)
continue|continue;
comment|/* create new ecdsa key (== EC_KEY) */
if|if
condition|(
operator|(
name|eckey
operator|=
name|EC_KEY_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|builtin_err
goto|;
name|group
operator|=
name|EC_GROUP_new_by_curve_name
argument_list|(
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|==
name|NULL
condition|)
goto|goto
name|builtin_err
goto|;
if|if
condition|(
name|EC_KEY_set_group
argument_list|(
name|eckey
argument_list|,
name|group
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|builtin_err
goto|;
name|EC_GROUP_free
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|degree
operator|=
name|EC_GROUP_get_degree
argument_list|(
name|EC_KEY_get0_group
argument_list|(
name|eckey
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|degree
operator|<
literal|160
condition|)
comment|/* drop the curve */
block|{
name|EC_KEY_free
argument_list|(
name|eckey
argument_list|)
expr_stmt|;
name|eckey
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"%s: "
argument_list|,
name|OBJ_nid2sn
argument_list|(
name|nid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create key */
if|if
condition|(
operator|!
name|EC_KEY_generate_key
argument_list|(
name|eckey
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|" failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|builtin_err
goto|;
block|}
comment|/* create second key */
if|if
condition|(
operator|(
name|wrong_eckey
operator|=
name|EC_KEY_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|builtin_err
goto|;
name|group
operator|=
name|EC_GROUP_new_by_curve_name
argument_list|(
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|==
name|NULL
condition|)
goto|goto
name|builtin_err
goto|;
if|if
condition|(
name|EC_KEY_set_group
argument_list|(
name|wrong_eckey
argument_list|,
name|group
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|builtin_err
goto|;
name|EC_GROUP_free
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EC_KEY_generate_key
argument_list|(
name|wrong_eckey
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|" failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|builtin_err
goto|;
block|}
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_flush
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|/* check key */
if|if
condition|(
operator|!
name|EC_KEY_check_key
argument_list|(
name|eckey
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|" failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|builtin_err
goto|;
block|}
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_flush
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|/* create signature */
name|sig_len
operator|=
name|ECDSA_size
argument_list|(
name|eckey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|signature
operator|=
name|OPENSSL_malloc
argument_list|(
name|sig_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|builtin_err
goto|;
if|if
condition|(
operator|!
name|ECDSA_sign
argument_list|(
literal|0
argument_list|,
name|digest
argument_list|,
literal|20
argument_list|,
name|signature
argument_list|,
operator|&
name|sig_len
argument_list|,
name|eckey
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|" failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|builtin_err
goto|;
block|}
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_flush
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|/* verify signature */
if|if
condition|(
name|ECDSA_verify
argument_list|(
literal|0
argument_list|,
name|digest
argument_list|,
literal|20
argument_list|,
name|signature
argument_list|,
name|sig_len
argument_list|,
name|eckey
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|" failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|builtin_err
goto|;
block|}
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_flush
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|/* verify signature with the wrong key */
if|if
condition|(
name|ECDSA_verify
argument_list|(
literal|0
argument_list|,
name|digest
argument_list|,
literal|20
argument_list|,
name|signature
argument_list|,
name|sig_len
argument_list|,
name|wrong_eckey
argument_list|)
operator|==
literal|1
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|" failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|builtin_err
goto|;
block|}
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_flush
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|/* wrong digest */
if|if
condition|(
name|ECDSA_verify
argument_list|(
literal|0
argument_list|,
name|wrong_digest
argument_list|,
literal|20
argument_list|,
name|signature
argument_list|,
name|sig_len
argument_list|,
name|eckey
argument_list|)
operator|==
literal|1
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|" failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|builtin_err
goto|;
block|}
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_flush
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|/* wrong length */
if|if
condition|(
name|ECDSA_verify
argument_list|(
literal|0
argument_list|,
name|digest
argument_list|,
literal|20
argument_list|,
name|signature
argument_list|,
name|sig_len
operator|-
literal|1
argument_list|,
name|eckey
argument_list|)
operator|==
literal|1
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|" failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|builtin_err
goto|;
block|}
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_flush
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|/*          * Modify a single byte of the signature: to ensure we don't garble          * the ASN1 structure, we read the raw signature and modify a byte in          * one of the bignums directly.          */
name|sig_ptr
operator|=
name|signature
expr_stmt|;
if|if
condition|(
operator|(
name|ecdsa_sig
operator|=
name|d2i_ECDSA_SIG
argument_list|(
name|NULL
argument_list|,
operator|&
name|sig_ptr
argument_list|,
name|sig_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|" failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|builtin_err
goto|;
block|}
comment|/* Store the two BIGNUMs in raw_buf. */
name|r_len
operator|=
name|BN_num_bytes
argument_list|(
name|ecdsa_sig
operator|->
name|r
argument_list|)
expr_stmt|;
name|s_len
operator|=
name|BN_num_bytes
argument_list|(
name|ecdsa_sig
operator|->
name|s
argument_list|)
expr_stmt|;
name|bn_len
operator|=
operator|(
name|degree
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|r_len
operator|>
name|bn_len
operator|)
operator|||
operator|(
name|s_len
operator|>
name|bn_len
operator|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|" failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|builtin_err
goto|;
block|}
name|buf_len
operator|=
literal|2
operator|*
name|bn_len
expr_stmt|;
if|if
condition|(
operator|(
name|raw_buf
operator|=
name|OPENSSL_malloc
argument_list|(
name|buf_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|builtin_err
goto|;
comment|/* Pad the bignums with leading zeroes. */
name|memset
argument_list|(
name|raw_buf
argument_list|,
literal|0
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|ecdsa_sig
operator|->
name|r
argument_list|,
name|raw_buf
operator|+
name|bn_len
operator|-
name|r_len
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|ecdsa_sig
operator|->
name|s
argument_list|,
name|raw_buf
operator|+
name|buf_len
operator|-
name|s_len
argument_list|)
expr_stmt|;
comment|/* Modify a single byte in the buffer. */
name|offset
operator|=
name|raw_buf
index|[
literal|10
index|]
operator|%
name|buf_len
expr_stmt|;
name|dirt
operator|=
name|raw_buf
index|[
literal|11
index|]
condition|?
name|raw_buf
index|[
literal|11
index|]
else|:
literal|1
expr_stmt|;
name|raw_buf
index|[
name|offset
index|]
operator|^=
name|dirt
expr_stmt|;
comment|/* Now read the BIGNUMs back in from raw_buf. */
if|if
condition|(
operator|(
name|BN_bin2bn
argument_list|(
name|raw_buf
argument_list|,
name|bn_len
argument_list|,
name|ecdsa_sig
operator|->
name|r
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|BN_bin2bn
argument_list|(
name|raw_buf
operator|+
name|bn_len
argument_list|,
name|bn_len
argument_list|,
name|ecdsa_sig
operator|->
name|s
argument_list|)
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|builtin_err
goto|;
name|sig_ptr2
operator|=
name|signature
expr_stmt|;
name|sig_len
operator|=
name|i2d_ECDSA_SIG
argument_list|(
name|ecdsa_sig
argument_list|,
operator|&
name|sig_ptr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ECDSA_verify
argument_list|(
literal|0
argument_list|,
name|digest
argument_list|,
literal|20
argument_list|,
name|signature
argument_list|,
name|sig_len
argument_list|,
name|eckey
argument_list|)
operator|==
literal|1
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|" failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|builtin_err
goto|;
block|}
comment|/*          * Sanity check: undo the modification and verify signature.          */
name|raw_buf
index|[
name|offset
index|]
operator|^=
name|dirt
expr_stmt|;
if|if
condition|(
operator|(
name|BN_bin2bn
argument_list|(
name|raw_buf
argument_list|,
name|bn_len
argument_list|,
name|ecdsa_sig
operator|->
name|r
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|BN_bin2bn
argument_list|(
name|raw_buf
operator|+
name|bn_len
argument_list|,
name|bn_len
argument_list|,
name|ecdsa_sig
operator|->
name|s
argument_list|)
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|builtin_err
goto|;
name|sig_ptr2
operator|=
name|signature
expr_stmt|;
name|sig_len
operator|=
name|i2d_ECDSA_SIG
argument_list|(
name|ecdsa_sig
argument_list|,
operator|&
name|sig_ptr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ECDSA_verify
argument_list|(
literal|0
argument_list|,
name|digest
argument_list|,
literal|20
argument_list|,
name|signature
argument_list|,
name|sig_len
argument_list|,
name|eckey
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|" failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|builtin_err
goto|;
block|}
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_flush
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|" ok\n"
argument_list|)
expr_stmt|;
comment|/* cleanup */
comment|/* clean bogus errors */
name|ERR_clear_error
argument_list|()
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|signature
argument_list|)
expr_stmt|;
name|signature
operator|=
name|NULL
expr_stmt|;
name|EC_KEY_free
argument_list|(
name|eckey
argument_list|)
expr_stmt|;
name|eckey
operator|=
name|NULL
expr_stmt|;
name|EC_KEY_free
argument_list|(
name|wrong_eckey
argument_list|)
expr_stmt|;
name|wrong_eckey
operator|=
name|NULL
expr_stmt|;
name|ECDSA_SIG_free
argument_list|(
name|ecdsa_sig
argument_list|)
expr_stmt|;
name|ecdsa_sig
operator|=
name|NULL
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|raw_buf
argument_list|)
expr_stmt|;
name|raw_buf
operator|=
name|NULL
expr_stmt|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|builtin_err
label|:
if|if
condition|(
name|eckey
condition|)
name|EC_KEY_free
argument_list|(
name|eckey
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrong_eckey
condition|)
name|EC_KEY_free
argument_list|(
name|wrong_eckey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecdsa_sig
condition|)
name|ECDSA_SIG_free
argument_list|(
name|ecdsa_sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|signature
condition|)
name|OPENSSL_free
argument_list|(
name|signature
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_buf
condition|)
name|OPENSSL_free
argument_list|(
name|raw_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|curves
condition|)
name|OPENSSL_free
argument_list|(
name|curves
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|BIO
modifier|*
name|out
decl_stmt|;
name|out
operator|=
name|BIO_new_fp
argument_list|(
name|stdout
argument_list|,
name|BIO_NOCLOSE
argument_list|)
expr_stmt|;
comment|/* enable memory leak checking unless explicitly disabled */
if|if
condition|(
operator|!
operator|(
operator|(
name|getenv
argument_list|(
literal|"OPENSSL_DEBUG_MEMORY"
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
literal|0
operator|==
name|strcmp
argument_list|(
name|getenv
argument_list|(
literal|"OPENSSL_DEBUG_MEMORY"
argument_list|)
argument_list|,
literal|"off"
argument_list|)
operator|)
operator|)
condition|)
block|{
name|CRYPTO_malloc_debug_init
argument_list|()
expr_stmt|;
name|CRYPTO_set_mem_debug_options
argument_list|(
name|V_CRYPTO_MDEBUG_ALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* OPENSSL_DEBUG_MEMORY=off */
name|CRYPTO_set_mem_debug_functions
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|CRYPTO_mem_ctrl
argument_list|(
name|CRYPTO_MEM_CHECK_ON
argument_list|)
expr_stmt|;
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
comment|/* initialize the prng */
name|RAND_seed
argument_list|(
name|rnd_seed
argument_list|,
sizeof|sizeof
argument_list|(
name|rnd_seed
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the tests */
if|if
condition|(
operator|!
name|x9_62_tests
argument_list|(
name|out
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|test_builtin
argument_list|(
name|out
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
literal|0
expr_stmt|;
name|err
label|:
if|if
condition|(
name|ret
condition|)
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\nECDSA test failed\n"
argument_list|)
expr_stmt|;
else|else
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\nECDSA test passed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|ERR_print_errors
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|CRYPTO_cleanup_all_ex_data
argument_list|()
expr_stmt|;
name|ERR_remove_state
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ERR_free_strings
argument_list|()
expr_stmt|;
name|CRYPTO_mem_leaks
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|NULL
condition|)
name|BIO_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

