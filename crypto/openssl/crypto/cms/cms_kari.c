begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/cms/cms_kari.c */
end_comment

begin_comment
comment|/*  * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL  * project.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2013 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/asn1t.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509v3.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/cms.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/aes.h>
end_include

begin_include
include|#
directive|include
file|"cms_lcl.h"
end_include

begin_include
include|#
directive|include
file|"asn1_locl.h"
end_include

begin_macro
name|DECLARE_ASN1_ITEM
argument_list|(
argument|CMS_KeyAgreeRecipientInfo
argument_list|)
end_macro

begin_macro
name|DECLARE_ASN1_ITEM
argument_list|(
argument|CMS_RecipientEncryptedKey
argument_list|)
end_macro

begin_macro
name|DECLARE_ASN1_ITEM
argument_list|(
argument|CMS_OriginatorPublicKey
argument_list|)
end_macro

begin_macro
name|DECLARE_ASN1_ITEM
argument_list|(
argument|CMS_RecipientKeyIdentifier
argument_list|)
end_macro

begin_comment
comment|/* Key Agreement Recipient Info (KARI) routines */
end_comment

begin_function
name|int
name|CMS_RecipientInfo_kari_get0_alg
parameter_list|(
name|CMS_RecipientInfo
modifier|*
name|ri
parameter_list|,
name|X509_ALGOR
modifier|*
modifier|*
name|palg
parameter_list|,
name|ASN1_OCTET_STRING
modifier|*
modifier|*
name|pukm
parameter_list|)
block|{
if|if
condition|(
name|ri
operator|->
name|type
operator|!=
name|CMS_RECIPINFO_AGREE
condition|)
block|{
name|CMSerr
argument_list|(
name|CMS_F_CMS_RECIPIENTINFO_KARI_GET0_ALG
argument_list|,
name|CMS_R_NOT_KEY_AGREEMENT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|palg
condition|)
operator|*
name|palg
operator|=
name|ri
operator|->
name|d
operator|.
name|kari
operator|->
name|keyEncryptionAlgorithm
expr_stmt|;
if|if
condition|(
name|pukm
condition|)
operator|*
name|pukm
operator|=
name|ri
operator|->
name|d
operator|.
name|kari
operator|->
name|ukm
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Retrieve recipient encrypted keys from a kari */
end_comment

begin_expr_stmt
name|STACK_OF
argument_list|(
name|CMS_RecipientEncryptedKey
argument_list|)
operator|*
name|CMS_RecipientInfo_kari_get0_reks
argument_list|(
argument|CMS_RecipientInfo *ri
argument_list|)
block|{
if|if
condition|(
name|ri
operator|->
name|type
operator|!=
name|CMS_RECIPINFO_AGREE
condition|)
block|{
name|CMSerr
argument_list|(
name|CMS_F_CMS_RECIPIENTINFO_KARI_GET0_REKS
argument_list|,
name|CMS_R_NOT_KEY_AGREEMENT
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_expr_stmt

begin_return
return|return
name|ri
operator|->
name|d
operator|.
name|kari
operator|->
name|recipientEncryptedKeys
return|;
end_return

begin_macro
unit|}  int
name|CMS_RecipientInfo_kari_get0_orig_id
argument_list|(
argument|CMS_RecipientInfo *ri
argument_list|,
argument|X509_ALGOR **pubalg
argument_list|,
argument|ASN1_BIT_STRING **pubkey
argument_list|,
argument|ASN1_OCTET_STRING **keyid
argument_list|,
argument|X509_NAME **issuer
argument_list|,
argument|ASN1_INTEGER **sno
argument_list|)
end_macro

begin_block
block|{
name|CMS_OriginatorIdentifierOrKey
modifier|*
name|oik
decl_stmt|;
if|if
condition|(
name|ri
operator|->
name|type
operator|!=
name|CMS_RECIPINFO_AGREE
condition|)
block|{
name|CMSerr
argument_list|(
name|CMS_F_CMS_RECIPIENTINFO_KARI_GET0_ORIG_ID
argument_list|,
name|CMS_R_NOT_KEY_AGREEMENT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|oik
operator|=
name|ri
operator|->
name|d
operator|.
name|kari
operator|->
name|originator
expr_stmt|;
if|if
condition|(
name|issuer
condition|)
operator|*
name|issuer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sno
condition|)
operator|*
name|sno
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|keyid
condition|)
operator|*
name|keyid
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pubalg
condition|)
operator|*
name|pubalg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pubkey
condition|)
operator|*
name|pubkey
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|oik
operator|->
name|type
operator|==
name|CMS_OIK_ISSUER_SERIAL
condition|)
block|{
if|if
condition|(
name|issuer
condition|)
operator|*
name|issuer
operator|=
name|oik
operator|->
name|d
operator|.
name|issuerAndSerialNumber
operator|->
name|issuer
expr_stmt|;
if|if
condition|(
name|sno
condition|)
operator|*
name|sno
operator|=
name|oik
operator|->
name|d
operator|.
name|issuerAndSerialNumber
operator|->
name|serialNumber
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oik
operator|->
name|type
operator|==
name|CMS_OIK_KEYIDENTIFIER
condition|)
block|{
if|if
condition|(
name|keyid
condition|)
operator|*
name|keyid
operator|=
name|oik
operator|->
name|d
operator|.
name|subjectKeyIdentifier
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oik
operator|->
name|type
operator|==
name|CMS_OIK_PUBKEY
condition|)
block|{
if|if
condition|(
name|pubalg
condition|)
operator|*
name|pubalg
operator|=
name|oik
operator|->
name|d
operator|.
name|originatorKey
operator|->
name|algorithm
expr_stmt|;
if|if
condition|(
name|pubkey
condition|)
operator|*
name|pubkey
operator|=
name|oik
operator|->
name|d
operator|.
name|originatorKey
operator|->
name|publicKey
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_function
name|int
name|CMS_RecipientInfo_kari_orig_id_cmp
parameter_list|(
name|CMS_RecipientInfo
modifier|*
name|ri
parameter_list|,
name|X509
modifier|*
name|cert
parameter_list|)
block|{
name|CMS_OriginatorIdentifierOrKey
modifier|*
name|oik
decl_stmt|;
if|if
condition|(
name|ri
operator|->
name|type
operator|!=
name|CMS_RECIPINFO_AGREE
condition|)
block|{
name|CMSerr
argument_list|(
name|CMS_F_CMS_RECIPIENTINFO_KARI_ORIG_ID_CMP
argument_list|,
name|CMS_R_NOT_KEY_AGREEMENT
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|oik
operator|=
name|ri
operator|->
name|d
operator|.
name|kari
operator|->
name|originator
expr_stmt|;
if|if
condition|(
name|oik
operator|->
name|type
operator|==
name|CMS_OIK_ISSUER_SERIAL
condition|)
return|return
name|cms_ias_cert_cmp
argument_list|(
name|oik
operator|->
name|d
operator|.
name|issuerAndSerialNumber
argument_list|,
name|cert
argument_list|)
return|;
elseif|else
if|if
condition|(
name|oik
operator|->
name|type
operator|==
name|CMS_OIK_KEYIDENTIFIER
condition|)
return|return
name|cms_keyid_cert_cmp
argument_list|(
name|oik
operator|->
name|d
operator|.
name|subjectKeyIdentifier
argument_list|,
name|cert
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|CMS_RecipientEncryptedKey_get0_id
parameter_list|(
name|CMS_RecipientEncryptedKey
modifier|*
name|rek
parameter_list|,
name|ASN1_OCTET_STRING
modifier|*
modifier|*
name|keyid
parameter_list|,
name|ASN1_GENERALIZEDTIME
modifier|*
modifier|*
name|tm
parameter_list|,
name|CMS_OtherKeyAttribute
modifier|*
modifier|*
name|other
parameter_list|,
name|X509_NAME
modifier|*
modifier|*
name|issuer
parameter_list|,
name|ASN1_INTEGER
modifier|*
modifier|*
name|sno
parameter_list|)
block|{
name|CMS_KeyAgreeRecipientIdentifier
modifier|*
name|rid
init|=
name|rek
operator|->
name|rid
decl_stmt|;
if|if
condition|(
name|rid
operator|->
name|type
operator|==
name|CMS_REK_ISSUER_SERIAL
condition|)
block|{
if|if
condition|(
name|issuer
condition|)
operator|*
name|issuer
operator|=
name|rid
operator|->
name|d
operator|.
name|issuerAndSerialNumber
operator|->
name|issuer
expr_stmt|;
if|if
condition|(
name|sno
condition|)
operator|*
name|sno
operator|=
name|rid
operator|->
name|d
operator|.
name|issuerAndSerialNumber
operator|->
name|serialNumber
expr_stmt|;
if|if
condition|(
name|keyid
condition|)
operator|*
name|keyid
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tm
condition|)
operator|*
name|tm
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|other
condition|)
operator|*
name|other
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rid
operator|->
name|type
operator|==
name|CMS_REK_KEYIDENTIFIER
condition|)
block|{
if|if
condition|(
name|keyid
condition|)
operator|*
name|keyid
operator|=
name|rid
operator|->
name|d
operator|.
name|rKeyId
operator|->
name|subjectKeyIdentifier
expr_stmt|;
if|if
condition|(
name|tm
condition|)
operator|*
name|tm
operator|=
name|rid
operator|->
name|d
operator|.
name|rKeyId
operator|->
name|date
expr_stmt|;
if|if
condition|(
name|other
condition|)
operator|*
name|other
operator|=
name|rid
operator|->
name|d
operator|.
name|rKeyId
operator|->
name|other
expr_stmt|;
if|if
condition|(
name|issuer
condition|)
operator|*
name|issuer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sno
condition|)
operator|*
name|sno
operator|=
name|NULL
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|CMS_RecipientEncryptedKey_cert_cmp
parameter_list|(
name|CMS_RecipientEncryptedKey
modifier|*
name|rek
parameter_list|,
name|X509
modifier|*
name|cert
parameter_list|)
block|{
name|CMS_KeyAgreeRecipientIdentifier
modifier|*
name|rid
init|=
name|rek
operator|->
name|rid
decl_stmt|;
if|if
condition|(
name|rid
operator|->
name|type
operator|==
name|CMS_REK_ISSUER_SERIAL
condition|)
return|return
name|cms_ias_cert_cmp
argument_list|(
name|rid
operator|->
name|d
operator|.
name|issuerAndSerialNumber
argument_list|,
name|cert
argument_list|)
return|;
elseif|else
if|if
condition|(
name|rid
operator|->
name|type
operator|==
name|CMS_REK_KEYIDENTIFIER
condition|)
return|return
name|cms_keyid_cert_cmp
argument_list|(
name|rid
operator|->
name|d
operator|.
name|rKeyId
operator|->
name|subjectKeyIdentifier
argument_list|,
name|cert
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|CMS_RecipientInfo_kari_set0_pkey
parameter_list|(
name|CMS_RecipientInfo
modifier|*
name|ri
parameter_list|,
name|EVP_PKEY
modifier|*
name|pk
parameter_list|)
block|{
name|EVP_PKEY_CTX
modifier|*
name|pctx
decl_stmt|;
name|CMS_KeyAgreeRecipientInfo
modifier|*
name|kari
init|=
name|ri
operator|->
name|d
operator|.
name|kari
decl_stmt|;
if|if
condition|(
name|kari
operator|->
name|pctx
condition|)
block|{
name|EVP_PKEY_CTX_free
argument_list|(
name|kari
operator|->
name|pctx
argument_list|)
expr_stmt|;
name|kari
operator|->
name|pctx
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pk
condition|)
return|return
literal|1
return|;
name|pctx
operator|=
name|EVP_PKEY_CTX_new
argument_list|(
name|pk
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pctx
operator|||
operator|!
name|EVP_PKEY_derive_init
argument_list|(
name|pctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|kari
operator|->
name|pctx
operator|=
name|pctx
expr_stmt|;
return|return
literal|1
return|;
name|err
label|:
if|if
condition|(
name|pctx
condition|)
name|EVP_PKEY_CTX_free
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|EVP_CIPHER_CTX
modifier|*
name|CMS_RecipientInfo_kari_get0_ctx
parameter_list|(
name|CMS_RecipientInfo
modifier|*
name|ri
parameter_list|)
block|{
if|if
condition|(
name|ri
operator|->
name|type
operator|==
name|CMS_RECIPINFO_AGREE
condition|)
return|return
operator|&
name|ri
operator|->
name|d
operator|.
name|kari
operator|->
name|ctx
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Derive KEK and decrypt/encrypt with it to produce either the original CEK  * or the encrypted CEK.  */
end_comment

begin_function
specifier|static
name|int
name|cms_kek_cipher
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|pout
parameter_list|,
name|size_t
modifier|*
name|poutlen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|inlen
parameter_list|,
name|CMS_KeyAgreeRecipientInfo
modifier|*
name|kari
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
comment|/* Key encryption key */
name|unsigned
name|char
name|kek
index|[
name|EVP_MAX_KEY_LENGTH
index|]
decl_stmt|;
name|size_t
name|keklen
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|out
init|=
name|NULL
decl_stmt|;
name|int
name|outlen
decl_stmt|;
name|keklen
operator|=
name|EVP_CIPHER_CTX_key_length
argument_list|(
operator|&
name|kari
operator|->
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|keklen
operator|>
name|EVP_MAX_KEY_LENGTH
condition|)
return|return
literal|0
return|;
comment|/* Derive KEK */
if|if
condition|(
name|EVP_PKEY_derive
argument_list|(
name|kari
operator|->
name|pctx
argument_list|,
name|kek
argument_list|,
operator|&
name|keklen
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* Set KEK in context */
if|if
condition|(
operator|!
name|EVP_CipherInit_ex
argument_list|(
operator|&
name|kari
operator|->
name|ctx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|kek
argument_list|,
name|NULL
argument_list|,
name|enc
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* obtain output length of ciphered key */
if|if
condition|(
operator|!
name|EVP_CipherUpdate
argument_list|(
operator|&
name|kari
operator|->
name|ctx
argument_list|,
name|NULL
argument_list|,
operator|&
name|outlen
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|out
operator|=
name|OPENSSL_malloc
argument_list|(
name|outlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|EVP_CipherUpdate
argument_list|(
operator|&
name|kari
operator|->
name|ctx
argument_list|,
name|out
argument_list|,
operator|&
name|outlen
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|)
condition|)
goto|goto
name|err
goto|;
operator|*
name|pout
operator|=
name|out
expr_stmt|;
operator|*
name|poutlen
operator|=
operator|(
name|size_t
operator|)
name|outlen
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|OPENSSL_cleanse
argument_list|(
name|kek
argument_list|,
name|keklen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rv
operator|&&
name|out
condition|)
name|OPENSSL_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|kari
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|EVP_PKEY_CTX_free
argument_list|(
name|kari
operator|->
name|pctx
argument_list|)
expr_stmt|;
name|kari
operator|->
name|pctx
operator|=
name|NULL
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|int
name|CMS_RecipientInfo_kari_decrypt
parameter_list|(
name|CMS_ContentInfo
modifier|*
name|cms
parameter_list|,
name|CMS_RecipientInfo
modifier|*
name|ri
parameter_list|,
name|CMS_RecipientEncryptedKey
modifier|*
name|rek
parameter_list|)
block|{
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|enckey
init|=
name|NULL
decl_stmt|,
modifier|*
name|cek
init|=
name|NULL
decl_stmt|;
name|size_t
name|enckeylen
decl_stmt|;
name|size_t
name|ceklen
decl_stmt|;
name|CMS_EncryptedContentInfo
modifier|*
name|ec
decl_stmt|;
name|enckeylen
operator|=
name|rek
operator|->
name|encryptedKey
operator|->
name|length
expr_stmt|;
name|enckey
operator|=
name|rek
operator|->
name|encryptedKey
operator|->
name|data
expr_stmt|;
comment|/* Setup all parameters to derive KEK */
if|if
condition|(
operator|!
name|cms_env_asn1_ctrl
argument_list|(
name|ri
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Attempt to decrypt CEK */
if|if
condition|(
operator|!
name|cms_kek_cipher
argument_list|(
operator|&
name|cek
argument_list|,
operator|&
name|ceklen
argument_list|,
name|enckey
argument_list|,
name|enckeylen
argument_list|,
name|ri
operator|->
name|d
operator|.
name|kari
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ec
operator|=
name|cms
operator|->
name|d
operator|.
name|envelopedData
operator|->
name|encryptedContentInfo
expr_stmt|;
if|if
condition|(
name|ec
operator|->
name|key
condition|)
block|{
name|OPENSSL_cleanse
argument_list|(
name|ec
operator|->
name|key
argument_list|,
name|ec
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|ec
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
name|ec
operator|->
name|key
operator|=
name|cek
expr_stmt|;
name|ec
operator|->
name|keylen
operator|=
name|ceklen
expr_stmt|;
name|cek
operator|=
name|NULL
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|cek
condition|)
name|OPENSSL_free
argument_list|(
name|cek
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* Create ephemeral key and initialise context based on it */
end_comment

begin_function
specifier|static
name|int
name|cms_kari_create_ephemeral_key
parameter_list|(
name|CMS_KeyAgreeRecipientInfo
modifier|*
name|kari
parameter_list|,
name|EVP_PKEY
modifier|*
name|pk
parameter_list|)
block|{
name|EVP_PKEY_CTX
modifier|*
name|pctx
init|=
name|NULL
decl_stmt|;
name|EVP_PKEY
modifier|*
name|ekey
init|=
name|NULL
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|pctx
operator|=
name|EVP_PKEY_CTX_new
argument_list|(
name|pk
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pctx
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|EVP_PKEY_keygen_init
argument_list|(
name|pctx
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|EVP_PKEY_keygen
argument_list|(
name|pctx
argument_list|,
operator|&
name|ekey
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
name|EVP_PKEY_CTX_free
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|pctx
operator|=
name|EVP_PKEY_CTX_new
argument_list|(
name|ekey
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pctx
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|EVP_PKEY_derive_init
argument_list|(
name|pctx
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
name|kari
operator|->
name|pctx
operator|=
name|pctx
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
operator|!
name|rv
operator|&&
name|pctx
condition|)
name|EVP_PKEY_CTX_free
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ekey
condition|)
name|EVP_PKEY_free
argument_list|(
name|ekey
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* Initialise a ktri based on passed certificate and key */
end_comment

begin_function
name|int
name|cms_RecipientInfo_kari_init
parameter_list|(
name|CMS_RecipientInfo
modifier|*
name|ri
parameter_list|,
name|X509
modifier|*
name|recip
parameter_list|,
name|EVP_PKEY
modifier|*
name|pk
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|CMS_KeyAgreeRecipientInfo
modifier|*
name|kari
decl_stmt|;
name|CMS_RecipientEncryptedKey
modifier|*
name|rek
init|=
name|NULL
decl_stmt|;
name|ri
operator|->
name|d
operator|.
name|kari
operator|=
name|M_ASN1_new_of
argument_list|(
name|CMS_KeyAgreeRecipientInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ri
operator|->
name|d
operator|.
name|kari
condition|)
return|return
literal|0
return|;
name|ri
operator|->
name|type
operator|=
name|CMS_RECIPINFO_AGREE
expr_stmt|;
name|kari
operator|=
name|ri
operator|->
name|d
operator|.
name|kari
expr_stmt|;
name|kari
operator|->
name|version
operator|=
literal|3
expr_stmt|;
name|rek
operator|=
name|M_ASN1_new_of
argument_list|(
name|CMS_RecipientEncryptedKey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sk_CMS_RecipientEncryptedKey_push
argument_list|(
name|kari
operator|->
name|recipientEncryptedKeys
argument_list|,
name|rek
argument_list|)
condition|)
block|{
name|M_ASN1_free_of
argument_list|(
name|rek
argument_list|,
name|CMS_RecipientEncryptedKey
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|CMS_USE_KEYID
condition|)
block|{
name|rek
operator|->
name|rid
operator|->
name|type
operator|=
name|CMS_REK_KEYIDENTIFIER
expr_stmt|;
name|rek
operator|->
name|rid
operator|->
name|d
operator|.
name|rKeyId
operator|=
name|M_ASN1_new_of
argument_list|(
name|CMS_RecipientKeyIdentifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|rek
operator|->
name|rid
operator|->
name|d
operator|.
name|rKeyId
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|cms_set1_keyid
argument_list|(
operator|&
name|rek
operator|->
name|rid
operator|->
name|d
operator|.
name|rKeyId
operator|->
name|subjectKeyIdentifier
argument_list|,
name|recip
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|rek
operator|->
name|rid
operator|->
name|type
operator|=
name|CMS_REK_ISSUER_SERIAL
expr_stmt|;
if|if
condition|(
operator|!
name|cms_set1_ias
argument_list|(
operator|&
name|rek
operator|->
name|rid
operator|->
name|d
operator|.
name|issuerAndSerialNumber
argument_list|,
name|recip
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Create ephemeral key */
if|if
condition|(
operator|!
name|cms_kari_create_ephemeral_key
argument_list|(
name|kari
argument_list|,
name|pk
argument_list|)
condition|)
return|return
literal|0
return|;
name|CRYPTO_add
argument_list|(
operator|&
name|pk
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_EVP_PKEY
argument_list|)
expr_stmt|;
name|rek
operator|->
name|pkey
operator|=
name|pk
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cms_wrap_init
parameter_list|(
name|CMS_KeyAgreeRecipientInfo
modifier|*
name|kari
parameter_list|,
specifier|const
name|EVP_CIPHER
modifier|*
name|cipher
parameter_list|)
block|{
name|EVP_CIPHER_CTX
modifier|*
name|ctx
init|=
operator|&
name|kari
operator|->
name|ctx
decl_stmt|;
specifier|const
name|EVP_CIPHER
modifier|*
name|kekcipher
decl_stmt|;
name|int
name|keylen
init|=
name|EVP_CIPHER_key_length
argument_list|(
name|cipher
argument_list|)
decl_stmt|;
comment|/* If a suitable wrap algorithm is already set nothing to do */
name|kekcipher
operator|=
name|EVP_CIPHER_CTX_cipher
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|kekcipher
condition|)
block|{
if|if
condition|(
name|EVP_CIPHER_CTX_mode
argument_list|(
name|ctx
argument_list|)
operator|!=
name|EVP_CIPH_WRAP_MODE
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
comment|/*      * Pick a cipher based on content encryption cipher. If it is DES3 use      * DES3 wrap otherwise use AES wrap similar to key size.      */
ifndef|#
directive|ifndef
name|OPENSSL_NO_DES
if|if
condition|(
name|EVP_CIPHER_type
argument_list|(
name|cipher
argument_list|)
operator|==
name|NID_des_ede3_cbc
condition|)
name|kekcipher
operator|=
name|EVP_des_ede3_wrap
argument_list|()
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|keylen
operator|<=
literal|16
condition|)
name|kekcipher
operator|=
name|EVP_aes_128_wrap
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|keylen
operator|<=
literal|24
condition|)
name|kekcipher
operator|=
name|EVP_aes_192_wrap
argument_list|()
expr_stmt|;
else|else
name|kekcipher
operator|=
name|EVP_aes_256_wrap
argument_list|()
expr_stmt|;
return|return
name|EVP_EncryptInit_ex
argument_list|(
name|ctx
argument_list|,
name|kekcipher
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Encrypt content key in key agreement recipient info */
end_comment

begin_function
name|int
name|cms_RecipientInfo_kari_encrypt
parameter_list|(
name|CMS_ContentInfo
modifier|*
name|cms
parameter_list|,
name|CMS_RecipientInfo
modifier|*
name|ri
parameter_list|)
block|{
name|CMS_KeyAgreeRecipientInfo
modifier|*
name|kari
decl_stmt|;
name|CMS_EncryptedContentInfo
modifier|*
name|ec
decl_stmt|;
name|CMS_RecipientEncryptedKey
modifier|*
name|rek
decl_stmt|;
name|STACK_OF
argument_list|(
name|CMS_RecipientEncryptedKey
argument_list|)
operator|*
name|reks
expr_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ri
operator|->
name|type
operator|!=
name|CMS_RECIPINFO_AGREE
condition|)
block|{
name|CMSerr
argument_list|(
name|CMS_F_CMS_RECIPIENTINFO_KARI_ENCRYPT
argument_list|,
name|CMS_R_NOT_KEY_AGREEMENT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|kari
operator|=
name|ri
operator|->
name|d
operator|.
name|kari
expr_stmt|;
name|reks
operator|=
name|kari
operator|->
name|recipientEncryptedKeys
expr_stmt|;
name|ec
operator|=
name|cms
operator|->
name|d
operator|.
name|envelopedData
operator|->
name|encryptedContentInfo
expr_stmt|;
comment|/* Initialise wrap algorithm parameters */
if|if
condition|(
operator|!
name|cms_wrap_init
argument_list|(
name|kari
argument_list|,
name|ec
operator|->
name|cipher
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/*      * If no orignator key set up initialise for ephemeral key the public key      * ASN1 structure will set the actual public key value.      */
if|if
condition|(
name|kari
operator|->
name|originator
operator|->
name|type
operator|==
operator|-
literal|1
condition|)
block|{
name|CMS_OriginatorIdentifierOrKey
modifier|*
name|oik
init|=
name|kari
operator|->
name|originator
decl_stmt|;
name|oik
operator|->
name|type
operator|=
name|CMS_OIK_PUBKEY
expr_stmt|;
name|oik
operator|->
name|d
operator|.
name|originatorKey
operator|=
name|M_ASN1_new_of
argument_list|(
name|CMS_OriginatorPublicKey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oik
operator|->
name|d
operator|.
name|originatorKey
condition|)
return|return
literal|0
return|;
block|}
comment|/* Initialise KDF algorithm */
if|if
condition|(
operator|!
name|cms_env_asn1_ctrl
argument_list|(
name|ri
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* For each rek, derive KEK, encrypt CEK */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_CMS_RecipientEncryptedKey_num
argument_list|(
name|reks
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|enckey
decl_stmt|;
name|size_t
name|enckeylen
decl_stmt|;
name|rek
operator|=
name|sk_CMS_RecipientEncryptedKey_value
argument_list|(
name|reks
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_PKEY_derive_set_peer
argument_list|(
name|kari
operator|->
name|pctx
argument_list|,
name|rek
operator|->
name|pkey
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|cms_kek_cipher
argument_list|(
operator|&
name|enckey
argument_list|,
operator|&
name|enckeylen
argument_list|,
name|ec
operator|->
name|key
argument_list|,
name|ec
operator|->
name|keylen
argument_list|,
name|kari
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
name|ASN1_STRING_set0
argument_list|(
name|rek
operator|->
name|encryptedKey
argument_list|,
name|enckey
argument_list|,
name|enckeylen
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

