begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/lhash.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/safestack.h>
end_include

begin_comment
comment|/* I use the ex_data stuff to manage the identifiers for the obj_name_types  * that applications may define.  I only really use the free function field.  */
end_comment

begin_decl_stmt
specifier|static
name|LHASH
modifier|*
name|names_lh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|names_type_num
init|=
name|OBJ_NAME_TYPE_NUM
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|name_funcs_st
block|{
name|unsigned
name|long
function_decl|(
modifier|*
name|hash_func
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|cmp_func
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|free_func
function_decl|)
parameter_list|()
function_decl|;
block|}
name|NAME_FUNCS
typedef|;
end_typedef

begin_macro
name|DECLARE_STACK_OF
argument_list|(
argument|NAME_FUNCS
argument_list|)
end_macro

begin_macro
name|IMPLEMENT_STACK_OF
argument_list|(
argument|NAME_FUNCS
argument_list|)
end_macro

begin_expr_stmt
specifier|static
name|STACK_OF
argument_list|(
name|NAME_FUNCS
argument_list|)
operator|*
name|name_funcs_stack
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|unsigned
name|long
name|obj_name_hash
parameter_list|(
name|OBJ_NAME
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|obj_name_cmp
parameter_list|(
name|OBJ_NAME
modifier|*
name|a
parameter_list|,
name|OBJ_NAME
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|OBJ_NAME_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|names_lh
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|MemCheck_off
argument_list|()
expr_stmt|;
name|names_lh
operator|=
name|lh_new
argument_list|(
name|obj_name_hash
argument_list|,
name|obj_name_cmp
argument_list|)
expr_stmt|;
name|MemCheck_on
argument_list|()
expr_stmt|;
return|return
operator|(
name|names_lh
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|OBJ_NAME_new_index
argument_list|(
name|unsigned
name|long
argument_list|(
operator|*
name|hash_func
argument_list|)
argument_list|()
argument_list|,
name|int
argument_list|(
operator|*
name|cmp_func
argument_list|)
argument_list|()
argument_list|,
name|void
argument_list|(
operator|*
name|free_func
argument_list|)
argument_list|()
argument_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|NAME_FUNCS
modifier|*
name|name_funcs
decl_stmt|;
if|if
condition|(
name|name_funcs_stack
operator|==
name|NULL
condition|)
block|{
name|MemCheck_off
argument_list|()
expr_stmt|;
name|name_funcs_stack
operator|=
name|sk_NAME_FUNCS_new_null
argument_list|()
expr_stmt|;
name|MemCheck_on
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|name_funcs_stack
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* ERROR */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ret
operator|=
name|names_type_num
expr_stmt|;
name|names_type_num
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sk_NAME_FUNCS_num
argument_list|(
name|name_funcs_stack
argument_list|)
init|;
name|i
operator|<
name|names_type_num
condition|;
name|i
operator|++
control|)
block|{
name|MemCheck_off
argument_list|()
expr_stmt|;
name|name_funcs
operator|=
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NAME_FUNCS
argument_list|)
argument_list|)
expr_stmt|;
name|name_funcs
operator|->
name|hash_func
operator|=
name|lh_strhash
expr_stmt|;
name|name_funcs
operator|->
name|cmp_func
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|strcmp
expr_stmt|;
name|name_funcs
operator|->
name|free_func
operator|=
literal|0
expr_stmt|;
comment|/* NULL is often declared to 					    * ((void *)0), which according 					    * to Compaq C is not really 					    * compatible with a function 					    * pointer.  -- Richard Levitte*/
name|sk_NAME_FUNCS_push
argument_list|(
name|name_funcs_stack
argument_list|,
name|name_funcs
argument_list|)
expr_stmt|;
name|MemCheck_on
argument_list|()
expr_stmt|;
block|}
name|name_funcs
operator|=
name|sk_NAME_FUNCS_value
argument_list|(
name|name_funcs_stack
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_func
operator|!=
name|NULL
condition|)
name|name_funcs
operator|->
name|hash_func
operator|=
name|hash_func
expr_stmt|;
if|if
condition|(
name|cmp_func
operator|!=
name|NULL
condition|)
name|name_funcs
operator|->
name|cmp_func
operator|=
name|cmp_func
expr_stmt|;
if|if
condition|(
name|free_func
operator|!=
name|NULL
condition|)
name|name_funcs
operator|->
name|free_func
operator|=
name|free_func
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|obj_name_cmp
parameter_list|(
name|OBJ_NAME
modifier|*
name|a
parameter_list|,
name|OBJ_NAME
modifier|*
name|b
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|a
operator|->
name|type
operator|-
name|b
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|name_funcs_stack
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sk_NAME_FUNCS_num
argument_list|(
name|name_funcs_stack
argument_list|)
operator|>
name|a
operator|->
name|type
operator|)
condition|)
block|{
name|ret
operator|=
name|sk_NAME_FUNCS_value
argument_list|(
name|name_funcs_stack
argument_list|,
name|a
operator|->
name|type
argument_list|)
operator|->
name|cmp_func
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|obj_name_hash
parameter_list|(
name|OBJ_NAME
modifier|*
name|a
parameter_list|)
block|{
name|unsigned
name|long
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|name_funcs_stack
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sk_NAME_FUNCS_num
argument_list|(
name|name_funcs_stack
argument_list|)
operator|>
name|a
operator|->
name|type
operator|)
condition|)
block|{
name|ret
operator|=
name|sk_NAME_FUNCS_value
argument_list|(
name|name_funcs_stack
argument_list|,
name|a
operator|->
name|type
argument_list|)
operator|->
name|hash_func
argument_list|(
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|lh_strhash
argument_list|(
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|ret
operator|^=
name|a
operator|->
name|type
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|OBJ_NAME_get
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|OBJ_NAME
name|on
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|,
name|alias
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|names_lh
operator|==
name|NULL
operator|)
operator|&&
operator|!
name|OBJ_NAME_init
argument_list|()
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|alias
operator|=
name|type
operator|&
name|OBJ_NAME_ALIAS
expr_stmt|;
name|type
operator|&=
operator|~
name|OBJ_NAME_ALIAS
expr_stmt|;
name|on
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|on
operator|.
name|type
operator|=
name|type
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ret
operator|=
operator|(
name|OBJ_NAME
operator|*
operator|)
name|lh_retrieve
argument_list|(
name|names_lh
argument_list|,
operator|&
name|on
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|ret
operator|->
name|alias
operator|)
operator|&&
operator|!
name|alias
condition|)
block|{
if|if
condition|(
operator|++
name|num
operator|>
literal|10
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|on
operator|.
name|name
operator|=
name|ret
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|ret
operator|->
name|data
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|OBJ_NAME_add
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|OBJ_NAME
modifier|*
name|onp
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|int
name|alias
decl_stmt|;
if|if
condition|(
operator|(
name|names_lh
operator|==
name|NULL
operator|)
operator|&&
operator|!
name|OBJ_NAME_init
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|alias
operator|=
name|type
operator|&
name|OBJ_NAME_ALIAS
expr_stmt|;
name|type
operator|&=
operator|~
name|OBJ_NAME_ALIAS
expr_stmt|;
name|onp
operator|=
operator|(
name|OBJ_NAME
operator|*
operator|)
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|OBJ_NAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|onp
operator|==
name|NULL
condition|)
block|{
comment|/* ERROR */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|onp
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|onp
operator|->
name|alias
operator|=
name|alias
expr_stmt|;
name|onp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|onp
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|ret
operator|=
operator|(
name|OBJ_NAME
operator|*
operator|)
name|lh_insert
argument_list|(
name|names_lh
argument_list|,
name|onp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
comment|/* free things */
if|if
condition|(
operator|(
name|name_funcs_stack
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sk_NAME_FUNCS_num
argument_list|(
name|name_funcs_stack
argument_list|)
operator|>
name|ret
operator|->
name|type
operator|)
condition|)
block|{
comment|/* XXX: I'm not sure I understand why the free 			 * function should get three arguments... 			 * -- Richard Levitte 			 */
name|sk_NAME_FUNCS_value
argument_list|(
name|name_funcs_stack
argument_list|,
name|ret
operator|->
name|type
argument_list|)
operator|->
name|free_func
argument_list|(
name|ret
operator|->
name|name
argument_list|,
name|ret
operator|->
name|type
argument_list|,
name|ret
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|Free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lh_error
argument_list|(
name|names_lh
argument_list|)
condition|)
block|{
comment|/* ERROR */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|OBJ_NAME_remove
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|OBJ_NAME
name|on
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|names_lh
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|type
operator|&=
operator|~
name|OBJ_NAME_ALIAS
expr_stmt|;
name|on
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|on
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|ret
operator|=
operator|(
name|OBJ_NAME
operator|*
operator|)
name|lh_delete
argument_list|(
name|names_lh
argument_list|,
operator|&
name|on
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
comment|/* free things */
if|if
condition|(
operator|(
name|name_funcs_stack
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sk_NAME_FUNCS_num
argument_list|(
name|name_funcs_stack
argument_list|)
operator|>
name|ret
operator|->
name|type
operator|)
condition|)
block|{
comment|/* XXX: I'm not sure I understand why the free 			 * function should get three arguments... 			 * -- Richard Levitte 			 */
name|sk_NAME_FUNCS_value
argument_list|(
name|name_funcs_stack
argument_list|,
name|ret
operator|->
name|type
argument_list|)
operator|->
name|free_func
argument_list|(
name|ret
operator|->
name|name
argument_list|,
name|ret
operator|->
name|type
argument_list|,
name|ret
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|Free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|free_type
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|names_lh_free
parameter_list|(
name|OBJ_NAME
modifier|*
name|onp
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|onp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|free_type
operator|<
literal|0
operator|)
operator|||
operator|(
name|free_type
operator|==
name|onp
operator|->
name|type
operator|)
condition|)
block|{
name|OBJ_NAME_remove
argument_list|(
name|onp
operator|->
name|name
argument_list|,
name|onp
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|name_funcs_free
parameter_list|(
name|NAME_FUNCS
modifier|*
name|ptr
parameter_list|)
block|{
name|Free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|OBJ_NAME_cleanup
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|unsigned
name|long
name|down_load
decl_stmt|;
if|if
condition|(
name|names_lh
operator|==
name|NULL
condition|)
return|return;
name|free_type
operator|=
name|type
expr_stmt|;
name|down_load
operator|=
name|names_lh
operator|->
name|down_load
expr_stmt|;
name|names_lh
operator|->
name|down_load
operator|=
literal|0
expr_stmt|;
name|lh_doall
argument_list|(
name|names_lh
argument_list|,
name|names_lh_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
condition|)
block|{
name|lh_free
argument_list|(
name|names_lh
argument_list|)
expr_stmt|;
name|sk_NAME_FUNCS_pop_free
argument_list|(
name|name_funcs_stack
argument_list|,
name|name_funcs_free
argument_list|)
expr_stmt|;
name|names_lh
operator|=
name|NULL
expr_stmt|;
name|name_funcs_stack
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|names_lh
operator|->
name|down_load
operator|=
name|down_load
expr_stmt|;
block|}
end_function

end_unit

