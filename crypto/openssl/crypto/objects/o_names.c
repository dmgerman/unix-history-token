begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/lhash.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/safestack.h>
end_include

begin_include
include|#
directive|include
file|<openssl/e_os2.h>
end_include

begin_comment
comment|/* Later versions of DEC C has started to add lnkage information to certain  * functions, which makes it tricky to use them as values to regular function  * pointers.  One way is to define a macro that takes care of casting them  * correctly.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_SYS_VMS_DECC
end_ifdef

begin_define
define|#
directive|define
name|OPENSSL_strcmp
value|(int (*)(const char *,const char *))strcmp
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OPENSSL_strcmp
value|strcmp
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I use the ex_data stuff to manage the identifiers for the obj_name_types  * that applications may define.  I only really use the free function field.  */
end_comment

begin_decl_stmt
specifier|static
name|LHASH
modifier|*
name|names_lh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|names_type_num
init|=
name|OBJ_NAME_TYPE_NUM
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|name_funcs_st
block|{
name|unsigned
name|long
function_decl|(
modifier|*
name|hash_func
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|cmp_func
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|b
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|free_func
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
block|}
name|NAME_FUNCS
typedef|;
end_typedef

begin_macro
name|DECLARE_STACK_OF
argument_list|(
argument|NAME_FUNCS
argument_list|)
end_macro

begin_macro
name|IMPLEMENT_STACK_OF
argument_list|(
argument|NAME_FUNCS
argument_list|)
end_macro

begin_expr_stmt
specifier|static
name|STACK_OF
argument_list|(
name|NAME_FUNCS
argument_list|)
operator|*
name|name_funcs_stack
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The LHASH callbacks now use the raw "void *" prototypes and do per-variable  * casting in the functions. This prevents function pointer casting without the  * need for macro-generated wrapper functions. */
end_comment

begin_comment
comment|/* static unsigned long obj_name_hash(OBJ_NAME *a); */
end_comment

begin_function_decl
specifier|static
name|unsigned
name|long
name|obj_name_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|a_void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* static int obj_name_cmp(OBJ_NAME *a,OBJ_NAME *b); */
end_comment

begin_function_decl
specifier|static
name|int
name|obj_name_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a_void
parameter_list|,
specifier|const
name|void
modifier|*
name|b_void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|OBJ_NAME_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|names_lh
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|MemCheck_off
argument_list|()
expr_stmt|;
name|names_lh
operator|=
name|lh_new
argument_list|(
name|obj_name_hash
argument_list|,
name|obj_name_cmp
argument_list|)
expr_stmt|;
name|MemCheck_on
argument_list|()
expr_stmt|;
return|return
operator|(
name|names_lh
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|OBJ_NAME_new_index
argument_list|(
name|unsigned
name|long
argument_list|(
operator|*
name|hash_func
argument_list|)
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|int
argument_list|(
operator|*
name|cmp_func
argument_list|)
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|void
argument_list|(
operator|*
name|free_func
argument_list|)
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|int
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|NAME_FUNCS
modifier|*
name|name_funcs
decl_stmt|;
if|if
condition|(
name|name_funcs_stack
operator|==
name|NULL
condition|)
block|{
name|MemCheck_off
argument_list|()
expr_stmt|;
name|name_funcs_stack
operator|=
name|sk_NAME_FUNCS_new_null
argument_list|()
expr_stmt|;
name|MemCheck_on
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|name_funcs_stack
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* ERROR */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ret
operator|=
name|names_type_num
expr_stmt|;
name|names_type_num
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sk_NAME_FUNCS_num
argument_list|(
name|name_funcs_stack
argument_list|)
init|;
name|i
operator|<
name|names_type_num
condition|;
name|i
operator|++
control|)
block|{
name|MemCheck_off
argument_list|()
expr_stmt|;
name|name_funcs
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NAME_FUNCS
argument_list|)
argument_list|)
expr_stmt|;
name|MemCheck_on
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|name_funcs
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|name_funcs
operator|->
name|hash_func
operator|=
name|lh_strhash
expr_stmt|;
name|name_funcs
operator|->
name|cmp_func
operator|=
name|OPENSSL_strcmp
expr_stmt|;
name|name_funcs
operator|->
name|free_func
operator|=
literal|0
expr_stmt|;
comment|/* NULL is often declared to 						* ((void *)0), which according 						* to Compaq C is not really 						* compatible with a function 						* pointer.	-- Richard Levitte*/
name|MemCheck_off
argument_list|()
expr_stmt|;
name|sk_NAME_FUNCS_push
argument_list|(
name|name_funcs_stack
argument_list|,
name|name_funcs
argument_list|)
expr_stmt|;
name|MemCheck_on
argument_list|()
expr_stmt|;
block|}
name|name_funcs
operator|=
name|sk_NAME_FUNCS_value
argument_list|(
name|name_funcs_stack
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_func
operator|!=
name|NULL
condition|)
name|name_funcs
operator|->
name|hash_func
operator|=
name|hash_func
expr_stmt|;
if|if
condition|(
name|cmp_func
operator|!=
name|NULL
condition|)
name|name_funcs
operator|->
name|cmp_func
operator|=
name|cmp_func
expr_stmt|;
if|if
condition|(
name|free_func
operator|!=
name|NULL
condition|)
name|name_funcs
operator|->
name|free_func
operator|=
name|free_func
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* static int obj_name_cmp(OBJ_NAME *a, OBJ_NAME *b) */
end_comment

begin_function
specifier|static
name|int
name|obj_name_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a_void
parameter_list|,
specifier|const
name|void
modifier|*
name|b_void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|OBJ_NAME
modifier|*
name|a
init|=
operator|(
name|OBJ_NAME
operator|*
operator|)
name|a_void
decl_stmt|;
name|OBJ_NAME
modifier|*
name|b
init|=
operator|(
name|OBJ_NAME
operator|*
operator|)
name|b_void
decl_stmt|;
name|ret
operator|=
name|a
operator|->
name|type
operator|-
name|b
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|name_funcs_stack
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sk_NAME_FUNCS_num
argument_list|(
name|name_funcs_stack
argument_list|)
operator|>
name|a
operator|->
name|type
operator|)
condition|)
block|{
name|ret
operator|=
name|sk_NAME_FUNCS_value
argument_list|(
name|name_funcs_stack
argument_list|,
name|a
operator|->
name|type
argument_list|)
operator|->
name|cmp_func
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* static unsigned long obj_name_hash(OBJ_NAME *a) */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|obj_name_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|a_void
parameter_list|)
block|{
name|unsigned
name|long
name|ret
decl_stmt|;
name|OBJ_NAME
modifier|*
name|a
init|=
operator|(
name|OBJ_NAME
operator|*
operator|)
name|a_void
decl_stmt|;
if|if
condition|(
operator|(
name|name_funcs_stack
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sk_NAME_FUNCS_num
argument_list|(
name|name_funcs_stack
argument_list|)
operator|>
name|a
operator|->
name|type
operator|)
condition|)
block|{
name|ret
operator|=
name|sk_NAME_FUNCS_value
argument_list|(
name|name_funcs_stack
argument_list|,
name|a
operator|->
name|type
argument_list|)
operator|->
name|hash_func
argument_list|(
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|lh_strhash
argument_list|(
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|ret
operator|^=
name|a
operator|->
name|type
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|OBJ_NAME_get
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|OBJ_NAME
name|on
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|,
name|alias
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|names_lh
operator|==
name|NULL
operator|)
operator|&&
operator|!
name|OBJ_NAME_init
argument_list|()
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|alias
operator|=
name|type
operator|&
name|OBJ_NAME_ALIAS
expr_stmt|;
name|type
operator|&=
operator|~
name|OBJ_NAME_ALIAS
expr_stmt|;
name|on
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|on
operator|.
name|type
operator|=
name|type
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ret
operator|=
operator|(
name|OBJ_NAME
operator|*
operator|)
name|lh_retrieve
argument_list|(
name|names_lh
argument_list|,
operator|&
name|on
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|ret
operator|->
name|alias
operator|)
operator|&&
operator|!
name|alias
condition|)
block|{
if|if
condition|(
operator|++
name|num
operator|>
literal|10
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|on
operator|.
name|name
operator|=
name|ret
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|ret
operator|->
name|data
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|OBJ_NAME_add
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|OBJ_NAME
modifier|*
name|onp
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|int
name|alias
decl_stmt|;
if|if
condition|(
operator|(
name|names_lh
operator|==
name|NULL
operator|)
operator|&&
operator|!
name|OBJ_NAME_init
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|alias
operator|=
name|type
operator|&
name|OBJ_NAME_ALIAS
expr_stmt|;
name|type
operator|&=
operator|~
name|OBJ_NAME_ALIAS
expr_stmt|;
name|onp
operator|=
operator|(
name|OBJ_NAME
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|OBJ_NAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|onp
operator|==
name|NULL
condition|)
block|{
comment|/* ERROR */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|onp
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|onp
operator|->
name|alias
operator|=
name|alias
expr_stmt|;
name|onp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|onp
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|ret
operator|=
operator|(
name|OBJ_NAME
operator|*
operator|)
name|lh_insert
argument_list|(
name|names_lh
argument_list|,
name|onp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
comment|/* free things */
if|if
condition|(
operator|(
name|name_funcs_stack
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sk_NAME_FUNCS_num
argument_list|(
name|name_funcs_stack
argument_list|)
operator|>
name|ret
operator|->
name|type
operator|)
condition|)
block|{
comment|/* XXX: I'm not sure I understand why the free 			 * function should get three arguments... 			 * -- Richard Levitte 			 */
name|sk_NAME_FUNCS_value
argument_list|(
name|name_funcs_stack
argument_list|,
name|ret
operator|->
name|type
argument_list|)
operator|->
name|free_func
argument_list|(
name|ret
operator|->
name|name
argument_list|,
name|ret
operator|->
name|type
argument_list|,
name|ret
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|OPENSSL_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lh_error
argument_list|(
name|names_lh
argument_list|)
condition|)
block|{
comment|/* ERROR */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|OBJ_NAME_remove
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|OBJ_NAME
name|on
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|names_lh
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|type
operator|&=
operator|~
name|OBJ_NAME_ALIAS
expr_stmt|;
name|on
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|on
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|ret
operator|=
operator|(
name|OBJ_NAME
operator|*
operator|)
name|lh_delete
argument_list|(
name|names_lh
argument_list|,
operator|&
name|on
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
comment|/* free things */
if|if
condition|(
operator|(
name|name_funcs_stack
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sk_NAME_FUNCS_num
argument_list|(
name|name_funcs_stack
argument_list|)
operator|>
name|ret
operator|->
name|type
operator|)
condition|)
block|{
comment|/* XXX: I'm not sure I understand why the free 			 * function should get three arguments... 			 * -- Richard Levitte 			 */
name|sk_NAME_FUNCS_value
argument_list|(
name|name_funcs_stack
argument_list|,
name|ret
operator|->
name|type
argument_list|)
operator|->
name|free_func
argument_list|(
name|ret
operator|->
name|name
argument_list|,
name|ret
operator|->
name|type
argument_list|,
name|ret
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|OPENSSL_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|doall
block|{
name|int
name|type
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
specifier|const
name|OBJ_NAME
modifier|*
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|do_all_fn
parameter_list|(
specifier|const
name|OBJ_NAME
modifier|*
name|name
parameter_list|,
name|struct
name|doall
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|name
operator|->
name|type
operator|==
name|d
operator|->
name|type
condition|)
name|d
operator|->
name|fn
argument_list|(
name|name
argument_list|,
name|d
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|IMPLEMENT_LHASH_DOALL_ARG_FN
argument_list|(
argument|do_all_fn
argument_list|,
argument|const OBJ_NAME *
argument_list|,
argument|struct doall *
argument_list|)
name|void
name|OBJ_NAME_do_all
argument_list|(
argument|int type
argument_list|,
argument|void (*fn)(const OBJ_NAME *,void *arg)
argument_list|,
argument|void *arg
argument_list|)
block|{ 	struct
name|doall
name|d
block|;
name|d
operator|.
name|type
operator|=
name|type
block|;
name|d
operator|.
name|fn
operator|=
name|fn
block|;
name|d
operator|.
name|arg
operator|=
name|arg
block|;
name|lh_doall_arg
argument_list|(
name|names_lh
argument_list|,
name|LHASH_DOALL_ARG_FN
argument_list|(
name|do_all_fn
argument_list|)
argument_list|,
operator|&
name|d
argument_list|)
block|; 	}
expr|struct
name|doall_sorted
block|{
name|int
name|type
block|;
name|int
name|n
block|;
specifier|const
name|OBJ_NAME
operator|*
operator|*
name|names
block|; 	}
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|do_all_sorted_fn
parameter_list|(
specifier|const
name|OBJ_NAME
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|d_
parameter_list|)
block|{
name|struct
name|doall_sorted
modifier|*
name|d
init|=
name|d_
decl_stmt|;
if|if
condition|(
name|name
operator|->
name|type
operator|!=
name|d
operator|->
name|type
condition|)
return|return;
name|d
operator|->
name|names
index|[
name|d
operator|->
name|n
operator|++
index|]
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_all_sorted_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|n1_
parameter_list|,
specifier|const
name|void
modifier|*
name|n2_
parameter_list|)
block|{
specifier|const
name|OBJ_NAME
modifier|*
specifier|const
modifier|*
name|n1
init|=
name|n1_
decl_stmt|;
specifier|const
name|OBJ_NAME
modifier|*
specifier|const
modifier|*
name|n2
init|=
name|n2_
decl_stmt|;
return|return
name|strcmp
argument_list|(
operator|(
operator|*
name|n1
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|*
name|n2
operator|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|OBJ_NAME_do_all_sorted
parameter_list|(
name|int
name|type
parameter_list|,
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
specifier|const
name|OBJ_NAME
modifier|*
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|doall_sorted
name|d
decl_stmt|;
name|int
name|n
decl_stmt|;
name|d
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|d
operator|.
name|names
operator|=
name|OPENSSL_malloc
argument_list|(
name|lh_num_items
argument_list|(
name|names_lh
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|d
operator|.
name|names
argument_list|)
expr_stmt|;
name|d
operator|.
name|n
operator|=
literal|0
expr_stmt|;
name|OBJ_NAME_do_all
argument_list|(
name|type
argument_list|,
name|do_all_sorted_fn
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|void
operator|*
operator|)
name|d
operator|.
name|names
argument_list|,
name|d
operator|.
name|n
argument_list|,
sizeof|sizeof
expr|*
name|d
operator|.
name|names
argument_list|,
name|do_all_sorted_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|d
operator|.
name|n
condition|;
operator|++
name|n
control|)
name|fn
argument_list|(
name|d
operator|.
name|names
index|[
name|n
index|]
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|d
operator|.
name|names
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|free_type
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|names_lh_free
parameter_list|(
name|OBJ_NAME
modifier|*
name|onp
parameter_list|)
block|{
if|if
condition|(
name|onp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|free_type
operator|<
literal|0
operator|)
operator|||
operator|(
name|free_type
operator|==
name|onp
operator|->
name|type
operator|)
condition|)
block|{
name|OBJ_NAME_remove
argument_list|(
name|onp
operator|->
name|name
argument_list|,
name|onp
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|IMPLEMENT_LHASH_DOALL_FN
argument_list|(
argument|names_lh_free
argument_list|,
argument|OBJ_NAME *
argument_list|)
specifier|static
name|void
name|name_funcs_free
argument_list|(
argument|NAME_FUNCS *ptr
argument_list|)
block|{
name|OPENSSL_free
argument_list|(
name|ptr
argument_list|)
block|; 	}
name|void
name|OBJ_NAME_cleanup
argument_list|(
argument|int type
argument_list|)
block|{
name|unsigned
name|long
name|down_load
block|;
if|if
condition|(
name|names_lh
operator|==
name|NULL
condition|)
return|return;
name|free_type
operator|=
name|type
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|down_load
operator|=
name|names_lh
operator|->
name|down_load
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|names_lh
operator|->
name|down_load
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|lh_doall
argument_list|(
name|names_lh
argument_list|,
name|LHASH_DOALL_FN
argument_list|(
name|names_lh_free
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|type
operator|<
literal|0
condition|)
block|{
name|lh_free
argument_list|(
name|names_lh
argument_list|)
expr_stmt|;
name|sk_NAME_FUNCS_pop_free
argument_list|(
name|name_funcs_stack
argument_list|,
name|name_funcs_free
argument_list|)
expr_stmt|;
name|names_lh
operator|=
name|NULL
expr_stmt|;
name|name_funcs_stack
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|names_lh
operator|->
name|down_load
operator|=
name|down_load
expr_stmt|;
end_if

unit|}
end_unit

