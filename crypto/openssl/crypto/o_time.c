begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/o_time.c -*- mode:C; c-file-style: "eay" -*- */
end_comment

begin_comment
comment|/*  * Written by Richard Levitte (richard@levitte.org) for the OpenSSL project  * 2001.  */
end_comment

begin_comment
comment|/*  * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project  * 2008.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2001 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<openssl/e_os2.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"o_time.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_SYS_VMS
end_ifdef

begin_if
if|#
directive|if
name|__CRTL_VER
operator|>=
literal|70000000
operator|&&
expr|\
operator|(
name|defined
name|_POSIX_C_SOURCE
operator|||
operator|!
name|defined
name|_ANSI_C_SOURCE
operator|)
end_if

begin_define
define|#
directive|define
name|VMS_GMTIME_OK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|VMS_GMTIME_OK
end_ifndef

begin_include
include|#
directive|include
file|<libdtdef.h>
end_include

begin_include
include|#
directive|include
file|<lib$routines.h>
end_include

begin_include
include|#
directive|include
file|<lnmdef.h>
end_include

begin_include
include|#
directive|include
file|<starlet.h>
end_include

begin_include
include|#
directive|include
file|<descrip.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ndef VMS_GMTIME_OK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|tm
modifier|*
name|OPENSSL_gmtime
parameter_list|(
specifier|const
name|time_t
modifier|*
name|timer
parameter_list|,
name|struct
name|tm
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|tm
modifier|*
name|ts
init|=
name|NULL
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_THREADS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_SYS_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_SYS_OS2
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|OPENSSL_SYS_VMS
argument_list|)
operator|||
name|defined
argument_list|(
name|gmtime_r
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_SYS_MACOSX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_SYS_SUNOS
argument_list|)
comment|/*      * should return&data, but doesn't on some systems, so we don't even      * look at the return value      */
name|gmtime_r
argument_list|(
name|timer
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|ts
operator|=
name|result
expr_stmt|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|OPENSSL_SYS_VMS
argument_list|)
operator|||
name|defined
argument_list|(
name|VMS_GMTIME_OK
argument_list|)
name|ts
operator|=
name|gmtime
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|ts
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|=
name|result
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_SYS_VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS_GMTIME_OK
argument_list|)
if|if
condition|(
name|ts
operator|==
name|NULL
condition|)
block|{
specifier|static
name|$DESCRIPTOR
argument_list|(
name|tabnam
argument_list|,
literal|"LNM$DCL_LOGICAL"
argument_list|)
expr_stmt|;
specifier|static
name|$DESCRIPTOR
argument_list|(
name|lognam
argument_list|,
literal|"SYS$TIMEZONE_DIFFERENTIAL"
argument_list|)
expr_stmt|;
name|char
name|logvalue
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|int
name|reslen
init|=
literal|0
decl_stmt|;
struct|struct
block|{
name|short
name|buflen
decl_stmt|;
name|short
name|code
decl_stmt|;
name|void
modifier|*
name|bufaddr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|reslen
decl_stmt|;
block|}
name|itemlist
index|[]
init|=
block|{
block|{
literal|0
block|,
name|LNM$_STRING
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,         }
struct|;
name|int
name|status
decl_stmt|;
name|time_t
name|t
decl_stmt|;
comment|/* Get the value for SYS$TIMEZONE_DIFFERENTIAL */
name|itemlist
index|[
literal|0
index|]
operator|.
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|logvalue
argument_list|)
expr_stmt|;
name|itemlist
index|[
literal|0
index|]
operator|.
name|bufaddr
operator|=
name|logvalue
expr_stmt|;
name|itemlist
index|[
literal|0
index|]
operator|.
name|reslen
operator|=
operator|&
name|reslen
expr_stmt|;
name|status
operator|=
name|sys$trnlnm
argument_list|(
literal|0
argument_list|,
operator|&
name|tabnam
argument_list|,
operator|&
name|lognam
argument_list|,
literal|0
argument_list|,
name|itemlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
return|return
name|NULL
return|;
name|logvalue
index|[
name|reslen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|t
operator|=
operator|*
name|timer
expr_stmt|;
comment|/* The following is extracted from the DEC C header time.h */
comment|/*          **  Beginning in OpenVMS Version 7.0 mktime, time, ctime, strftime          **  have two implementations.  One implementation is provided          **  for compatibility and deals with time in terms of local time,          **  the other __utc_* deals with time in terms of UTC.          */
comment|/*          * We use the same conditions as in said time.h to check if we should          * assume that t contains local time (and should therefore be          * adjusted) or UTC (and should therefore be left untouched).          */
if|#
directive|if
name|__CRTL_VER
operator|<
literal|70000000
operator|||
name|defined
name|_VMS_V6_SOURCE
comment|/* Get the numerical value of the equivalence string */
name|status
operator|=
name|atoi
argument_list|(
name|logvalue
argument_list|)
expr_stmt|;
comment|/* and use it to move time to GMT */
name|t
operator|-=
name|status
expr_stmt|;
endif|#
directive|endif
comment|/* then convert the result to the time structure */
comment|/*          * Since there was no gmtime_r() to do this stuff for us, we have to          * do it the hard way.          */
block|{
comment|/*-              * The VMS epoch is the astronomical Smithsonian date,                if I remember correctly, which is November 17, 1858.                Furthermore, time is measure in thenths of microseconds                and stored in quadwords (64 bit integers).  unix_epoch                below is January 1st 1970 expressed as a VMS time.  The                following code was used to get this number:                 #include<stdio.h>                #include<stdlib.h>                #include<lib$routines.h>                #include<starlet.h>                 main()                {                  unsigned long systime[2];                  unsigned short epoch_values[7] =                    { 1970, 1, 1, 0, 0, 0, 0 };                   lib$cvt_vectim(epoch_values, systime);                   printf("%u %u", systime[0], systime[1]);                }             */
name|unsigned
name|long
name|unix_epoch
index|[
literal|2
index|]
init|=
block|{
literal|1273708544
block|,
literal|8164711
block|}
decl_stmt|;
name|unsigned
name|long
name|deltatime
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|long
name|systime
index|[
literal|2
index|]
decl_stmt|;
struct|struct
name|vms_vectime
block|{
name|short
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|,
name|centi_second
decl_stmt|;
block|}
name|time_values
struct|;
name|long
name|operation
decl_stmt|;
comment|/*              * Turn the number of seconds since January 1st 1970 to an              * internal delta time. Note that lib$cvt_to_internal_time() will              * assume that t is signed, and will therefore break on 32-bit              * systems some time in 2038.              */
name|operation
operator|=
name|LIB$K_DELTA_SECONDS
expr_stmt|;
name|status
operator|=
name|lib$cvt_to_internal_time
argument_list|(
operator|&
name|operation
argument_list|,
operator|&
name|t
argument_list|,
name|deltatime
argument_list|)
expr_stmt|;
comment|/*              * Add the delta time with the Unix epoch and we have the current              * UTC time in internal format              */
name|status
operator|=
name|lib$add_times
argument_list|(
name|unix_epoch
argument_list|,
name|deltatime
argument_list|,
name|systime
argument_list|)
expr_stmt|;
comment|/* Turn the internal time into a time vector */
name|status
operator|=
name|sys$numtim
argument_list|(
operator|&
name|time_values
argument_list|,
name|systime
argument_list|)
expr_stmt|;
comment|/* Fill in the struct tm with the result */
name|result
operator|->
name|tm_sec
operator|=
name|time_values
operator|.
name|second
expr_stmt|;
name|result
operator|->
name|tm_min
operator|=
name|time_values
operator|.
name|minute
expr_stmt|;
name|result
operator|->
name|tm_hour
operator|=
name|time_values
operator|.
name|hour
expr_stmt|;
name|result
operator|->
name|tm_mday
operator|=
name|time_values
operator|.
name|day
expr_stmt|;
name|result
operator|->
name|tm_mon
operator|=
name|time_values
operator|.
name|month
operator|-
literal|1
expr_stmt|;
name|result
operator|->
name|tm_year
operator|=
name|time_values
operator|.
name|year
operator|-
literal|1900
expr_stmt|;
name|operation
operator|=
name|LIB$K_DAY_OF_WEEK
expr_stmt|;
name|status
operator|=
name|lib$cvt_from_internal_time
argument_list|(
operator|&
name|operation
argument_list|,
operator|&
name|result
operator|->
name|tm_wday
argument_list|,
name|systime
argument_list|)
expr_stmt|;
name|result
operator|->
name|tm_wday
operator|%=
literal|7
expr_stmt|;
name|operation
operator|=
name|LIB$K_DAY_OF_YEAR
expr_stmt|;
name|status
operator|=
name|lib$cvt_from_internal_time
argument_list|(
operator|&
name|operation
argument_list|,
operator|&
name|result
operator|->
name|tm_yday
argument_list|,
name|systime
argument_list|)
expr_stmt|;
name|result
operator|->
name|tm_yday
operator|--
expr_stmt|;
name|result
operator|->
name|tm_isdst
operator|=
literal|0
expr_stmt|;
comment|/* There's no way to know... */
name|ts
operator|=
name|result
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|ts
return|;
block|}
end_function

begin_comment
comment|/*  * Take a tm structure and add an offset to it. This avoids any OS issues  * with restricted date types and overflows which cause the year 2038  * problem.  */
end_comment

begin_define
define|#
directive|define
name|SECS_PER_DAY
value|(24 * 60 * 60)
end_define

begin_function_decl
specifier|static
name|long
name|date_to_julian
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|julian_to_date
parameter_list|(
name|long
name|jd
parameter_list|,
name|int
modifier|*
name|y
parameter_list|,
name|int
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|OPENSSL_gmtime_adj
parameter_list|(
name|struct
name|tm
modifier|*
name|tm
parameter_list|,
name|int
name|off_day
parameter_list|,
name|long
name|offset_sec
parameter_list|)
block|{
name|int
name|offset_hms
decl_stmt|,
name|offset_day
decl_stmt|;
name|long
name|time_jd
decl_stmt|;
name|int
name|time_year
decl_stmt|,
name|time_month
decl_stmt|,
name|time_day
decl_stmt|;
comment|/* split offset into days and day seconds */
name|offset_day
operator|=
name|offset_sec
operator|/
name|SECS_PER_DAY
expr_stmt|;
comment|/* Avoid sign issues with % operator */
name|offset_hms
operator|=
name|offset_sec
operator|-
operator|(
name|offset_day
operator|*
name|SECS_PER_DAY
operator|)
expr_stmt|;
name|offset_day
operator|+=
name|off_day
expr_stmt|;
comment|/* Add current time seconds to offset */
name|offset_hms
operator|+=
name|tm
operator|->
name|tm_hour
operator|*
literal|3600
operator|+
name|tm
operator|->
name|tm_min
operator|*
literal|60
operator|+
name|tm
operator|->
name|tm_sec
expr_stmt|;
comment|/* Adjust day seconds if overflow */
if|if
condition|(
name|offset_hms
operator|>=
name|SECS_PER_DAY
condition|)
block|{
name|offset_day
operator|++
expr_stmt|;
name|offset_hms
operator|-=
name|SECS_PER_DAY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset_hms
operator|<
literal|0
condition|)
block|{
name|offset_day
operator|--
expr_stmt|;
name|offset_hms
operator|+=
name|SECS_PER_DAY
expr_stmt|;
block|}
comment|/*      * Convert date of time structure into a Julian day number.      */
name|time_year
operator|=
name|tm
operator|->
name|tm_year
operator|+
literal|1900
expr_stmt|;
name|time_month
operator|=
name|tm
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|time_day
operator|=
name|tm
operator|->
name|tm_mday
expr_stmt|;
name|time_jd
operator|=
name|date_to_julian
argument_list|(
name|time_year
argument_list|,
name|time_month
argument_list|,
name|time_day
argument_list|)
expr_stmt|;
comment|/* Work out Julian day of new date */
name|time_jd
operator|+=
name|offset_day
expr_stmt|;
if|if
condition|(
name|time_jd
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Convert Julian day back to date */
name|julian_to_date
argument_list|(
name|time_jd
argument_list|,
operator|&
name|time_year
argument_list|,
operator|&
name|time_month
argument_list|,
operator|&
name|time_day
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_year
operator|<
literal|1900
operator|||
name|time_year
operator|>
literal|9999
condition|)
return|return
literal|0
return|;
comment|/* Update tm structure */
name|tm
operator|->
name|tm_year
operator|=
name|time_year
operator|-
literal|1900
expr_stmt|;
name|tm
operator|->
name|tm_mon
operator|=
name|time_month
operator|-
literal|1
expr_stmt|;
name|tm
operator|->
name|tm_mday
operator|=
name|time_day
expr_stmt|;
name|tm
operator|->
name|tm_hour
operator|=
name|offset_hms
operator|/
literal|3600
expr_stmt|;
name|tm
operator|->
name|tm_min
operator|=
operator|(
name|offset_hms
operator|/
literal|60
operator|)
operator|%
literal|60
expr_stmt|;
name|tm
operator|->
name|tm_sec
operator|=
name|offset_hms
operator|%
literal|60
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Convert date to and from julian day Uses Fliegel& Van Flandern algorithm  */
end_comment

begin_function
specifier|static
name|long
name|date_to_julian
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|d
parameter_list|)
block|{
return|return
operator|(
literal|1461
operator|*
operator|(
name|y
operator|+
literal|4800
operator|+
operator|(
name|m
operator|-
literal|14
operator|)
operator|/
literal|12
operator|)
operator|)
operator|/
literal|4
operator|+
operator|(
literal|367
operator|*
operator|(
name|m
operator|-
literal|2
operator|-
literal|12
operator|*
operator|(
operator|(
name|m
operator|-
literal|14
operator|)
operator|/
literal|12
operator|)
operator|)
operator|)
operator|/
literal|12
operator|-
operator|(
literal|3
operator|*
operator|(
operator|(
name|y
operator|+
literal|4900
operator|+
operator|(
name|m
operator|-
literal|14
operator|)
operator|/
literal|12
operator|)
operator|/
literal|100
operator|)
operator|)
operator|/
literal|4
operator|+
name|d
operator|-
literal|32075
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|julian_to_date
parameter_list|(
name|long
name|jd
parameter_list|,
name|int
modifier|*
name|y
parameter_list|,
name|int
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|d
parameter_list|)
block|{
name|long
name|L
init|=
name|jd
operator|+
literal|68569
decl_stmt|;
name|long
name|n
init|=
operator|(
literal|4
operator|*
name|L
operator|)
operator|/
literal|146097
decl_stmt|;
name|long
name|i
decl_stmt|,
name|j
decl_stmt|;
name|L
operator|=
name|L
operator|-
operator|(
literal|146097
operator|*
name|n
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|i
operator|=
operator|(
literal|4000
operator|*
operator|(
name|L
operator|+
literal|1
operator|)
operator|)
operator|/
literal|1461001
expr_stmt|;
name|L
operator|=
name|L
operator|-
operator|(
literal|1461
operator|*
name|i
operator|)
operator|/
literal|4
operator|+
literal|31
expr_stmt|;
name|j
operator|=
operator|(
literal|80
operator|*
name|L
operator|)
operator|/
literal|2447
expr_stmt|;
operator|*
name|d
operator|=
name|L
operator|-
operator|(
literal|2447
operator|*
name|j
operator|)
operator|/
literal|80
expr_stmt|;
name|L
operator|=
name|j
operator|/
literal|11
expr_stmt|;
operator|*
name|m
operator|=
name|j
operator|+
literal|2
operator|-
operator|(
literal|12
operator|*
name|L
operator|)
expr_stmt|;
operator|*
name|y
operator|=
literal|100
operator|*
operator|(
name|n
operator|-
literal|49
operator|)
operator|+
name|i
operator|+
name|L
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_TIME_TEST
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/*  * Time checking test code. Check times are identical for a wide range of  * offsets. This should be run on a machine with 64 bit time_t or it will  * trigger the very errors the routines fix.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|long
name|offset
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
literal|1000000
condition|;
name|offset
operator|++
control|)
block|{
name|check_time
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|check_time
argument_list|(
operator|-
name|offset
argument_list|)
expr_stmt|;
name|check_time
argument_list|(
name|offset
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|check_time
argument_list|(
operator|-
name|offset
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|check_time
parameter_list|(
name|long
name|offset
parameter_list|)
block|{
name|struct
name|tm
name|tm1
decl_stmt|,
name|tm2
decl_stmt|;
name|time_t
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|time
argument_list|(
operator|&
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|t1
operator|+
name|offset
expr_stmt|;
name|OPENSSL_gmtime
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|tm2
argument_list|)
expr_stmt|;
name|OPENSSL_gmtime
argument_list|(
operator|&
name|t1
argument_list|,
operator|&
name|tm1
argument_list|)
expr_stmt|;
name|OPENSSL_gmtime_adj
argument_list|(
operator|&
name|tm1
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tm1
operator|.
name|tm_year
operator|==
name|tm2
operator|.
name|tm_year
operator|)
operator|&&
operator|(
name|tm1
operator|.
name|tm_mon
operator|==
name|tm2
operator|.
name|tm_mon
operator|)
operator|&&
operator|(
name|tm1
operator|.
name|tm_mday
operator|==
name|tm2
operator|.
name|tm_mday
operator|)
operator|&&
operator|(
name|tm1
operator|.
name|tm_hour
operator|==
name|tm2
operator|.
name|tm_hour
operator|)
operator|&&
operator|(
name|tm1
operator|.
name|tm_min
operator|==
name|tm2
operator|.
name|tm_min
operator|)
operator|&&
operator|(
name|tm1
operator|.
name|tm_sec
operator|==
name|tm2
operator|.
name|tm_sec
operator|)
condition|)
return|return
literal|1
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TIME ERROR!!\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Time1: %d/%d/%d, %d:%02d:%02d\n"
argument_list|,
name|tm2
operator|.
name|tm_mday
argument_list|,
name|tm2
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm2
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|tm2
operator|.
name|tm_hour
argument_list|,
name|tm2
operator|.
name|tm_min
argument_list|,
name|tm2
operator|.
name|tm_sec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Time2: %d/%d/%d, %d:%02d:%02d\n"
argument_list|,
name|tm1
operator|.
name|tm_mday
argument_list|,
name|tm1
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm1
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|tm1
operator|.
name|tm_hour
argument_list|,
name|tm1
operator|.
name|tm_min
argument_list|,
name|tm1
operator|.
name|tm_sec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

