begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/pem/pem_lib.c */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *  * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *  * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from  *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/buffer.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pkcs12.h>
end_include

begin_include
include|#
directive|include
file|"asn1_locl.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DES
end_ifndef

begin_include
include|#
directive|include
file|<openssl/des.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_ENGINE
end_ifndef

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
name|PEM_version
index|[]
init|=
literal|"PEM"
name|OPENSSL_VERSION_PTEXT
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MIN_LENGTH
value|4
end_define

begin_function_decl
specifier|static
name|int
name|load_iv
parameter_list|(
name|char
modifier|*
modifier|*
name|fromp
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_pem
parameter_list|(
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pem_check_suffix
parameter_list|(
specifier|const
name|char
modifier|*
name|pem_str
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|PEM_def_callback
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|w
parameter_list|,
name|void
modifier|*
name|key
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OPENSSL_NO_FP_API
comment|/*      * We should not ever call the default callback routine from windows.      */
name|PEMerr
argument_list|(
name|PEM_F_PEM_DEF_CALLBACK
argument_list|,
name|ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|#
directive|else
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|prompt
decl_stmt|;
if|if
condition|(
name|key
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|>
name|num
operator|)
condition|?
name|num
else|:
name|i
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|key
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|prompt
operator|=
name|EVP_get_pw_prompt
argument_list|()
expr_stmt|;
if|if
condition|(
name|prompt
operator|==
name|NULL
condition|)
name|prompt
operator|=
literal|"Enter PEM pass phrase:"
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|EVP_read_pw_string_min
argument_list|(
name|buf
argument_list|,
name|MIN_LENGTH
argument_list|,
name|num
argument_list|,
name|prompt
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_DEF_CALLBACK
argument_list|,
name|PEM_R_PROBLEMS_GETTING_PASSWORD
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|num
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|j
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|MIN_LENGTH
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"phrase is too short, needs to be at least %d chars\n"
argument_list|,
name|MIN_LENGTH
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
operator|(
name|j
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|PEM_proc_type
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|PEM_TYPE_ENCRYPTED
condition|)
name|str
operator|=
literal|"ENCRYPTED"
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|PEM_TYPE_MIC_CLEAR
condition|)
name|str
operator|=
literal|"MIC-CLEAR"
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|PEM_TYPE_MIC_ONLY
condition|)
name|str
operator|=
literal|"MIC-ONLY"
expr_stmt|;
else|else
name|str
operator|=
literal|"BAD-TYPE"
expr_stmt|;
name|BUF_strlcat
argument_list|(
name|buf
argument_list|,
literal|"Proc-Type: 4,"
argument_list|,
name|PEM_BUFSIZE
argument_list|)
expr_stmt|;
name|BUF_strlcat
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|PEM_BUFSIZE
argument_list|)
expr_stmt|;
name|BUF_strlcat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|,
name|PEM_BUFSIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|PEM_dek_info
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|map
index|[
literal|17
index|]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
name|long
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|BUF_strlcat
argument_list|(
name|buf
argument_list|,
literal|"DEK-Info: "
argument_list|,
name|PEM_BUFSIZE
argument_list|)
expr_stmt|;
name|BUF_strlcat
argument_list|(
name|buf
argument_list|,
name|type
argument_list|,
name|PEM_BUFSIZE
argument_list|)
expr_stmt|;
name|BUF_strlcat
argument_list|(
name|buf
argument_list|,
literal|","
argument_list|,
name|PEM_BUFSIZE
argument_list|)
expr_stmt|;
name|j
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|+
operator|(
name|len
operator|*
literal|2
operator|)
operator|+
literal|1
operator|>
name|PEM_BUFSIZE
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
name|j
operator|+
name|i
operator|*
literal|2
index|]
operator|=
name|map
index|[
operator|(
name|str
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
index|]
expr_stmt|;
name|buf
index|[
name|j
operator|+
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|map
index|[
operator|(
name|str
index|[
name|i
index|]
operator|)
operator|&
literal|0x0f
index|]
expr_stmt|;
block|}
name|buf
index|[
name|j
operator|+
name|i
operator|*
literal|2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buf
index|[
name|j
operator|+
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_FP_API
end_ifndef

begin_function
name|void
modifier|*
name|PEM_ASN1_read
parameter_list|(
name|d2i_of_void
modifier|*
name|d2i
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|void
modifier|*
modifier|*
name|x
parameter_list|,
name|pem_password_cb
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|u
parameter_list|)
block|{
name|BIO
modifier|*
name|b
decl_stmt|;
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|BIO_new
argument_list|(
name|BIO_s_file
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_ASN1_READ
argument_list|,
name|ERR_R_BUF_LIB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|BIO_set_fp
argument_list|(
name|b
argument_list|,
name|fp
argument_list|,
name|BIO_NOCLOSE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|PEM_ASN1_read_bio
argument_list|(
name|d2i
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
name|x
argument_list|,
name|cb
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|check_pem
parameter_list|(
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* Normal matching nm and name */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nm
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Make PEM_STRING_EVP_PKEY match any private key */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|PEM_STRING_EVP_PKEY
argument_list|)
condition|)
block|{
name|int
name|slen
decl_stmt|;
specifier|const
name|EVP_PKEY_ASN1_METHOD
modifier|*
name|ameth
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nm
argument_list|,
name|PEM_STRING_PKCS8
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nm
argument_list|,
name|PEM_STRING_PKCS8INF
argument_list|)
condition|)
return|return
literal|1
return|;
name|slen
operator|=
name|pem_check_suffix
argument_list|(
name|nm
argument_list|,
literal|"PRIVATE KEY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|>
literal|0
condition|)
block|{
comment|/*              * NB: ENGINE implementations wont contain a deprecated old              * private key decode function so don't look for them.              */
name|ameth
operator|=
name|EVP_PKEY_asn1_find_str
argument_list|(
name|NULL
argument_list|,
name|nm
argument_list|,
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ameth
operator|&&
name|ameth
operator|->
name|old_priv_decode
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|PEM_STRING_PARAMETERS
argument_list|)
condition|)
block|{
name|int
name|slen
decl_stmt|;
specifier|const
name|EVP_PKEY_ASN1_METHOD
modifier|*
name|ameth
decl_stmt|;
name|slen
operator|=
name|pem_check_suffix
argument_list|(
name|nm
argument_list|,
literal|"PARAMETERS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|>
literal|0
condition|)
block|{
name|ENGINE
modifier|*
name|e
decl_stmt|;
name|ameth
operator|=
name|EVP_PKEY_asn1_find_str
argument_list|(
operator|&
name|e
argument_list|,
name|nm
argument_list|,
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ameth
condition|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|ameth
operator|->
name|param_decode
condition|)
name|r
operator|=
literal|1
expr_stmt|;
else|else
name|r
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_ENGINE
if|if
condition|(
name|e
condition|)
name|ENGINE_finish
argument_list|(
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|r
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
comment|/* Permit older strings */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nm
argument_list|,
name|PEM_STRING_X509_OLD
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|PEM_STRING_X509
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nm
argument_list|,
name|PEM_STRING_X509_REQ_OLD
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|PEM_STRING_X509_REQ
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Allow normal certs to be read as trusted certs */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nm
argument_list|,
name|PEM_STRING_X509
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|PEM_STRING_X509_TRUSTED
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nm
argument_list|,
name|PEM_STRING_X509_OLD
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|PEM_STRING_X509_TRUSTED
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Some CAs use PKCS#7 with CERTIFICATE headers */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nm
argument_list|,
name|PEM_STRING_X509
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|PEM_STRING_PKCS7
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nm
argument_list|,
name|PEM_STRING_PKCS7_SIGNED
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|PEM_STRING_PKCS7
argument_list|)
condition|)
return|return
literal|1
return|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_CMS
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nm
argument_list|,
name|PEM_STRING_X509
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|PEM_STRING_CMS
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Allow CMS to be read from PKCS#7 headers */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nm
argument_list|,
name|PEM_STRING_PKCS7
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|PEM_STRING_CMS
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|PEM_bytes_read_bio
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|pdata
parameter_list|,
name|long
modifier|*
name|plen
parameter_list|,
name|char
modifier|*
modifier|*
name|pnm
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|BIO
modifier|*
name|bp
parameter_list|,
name|pem_password_cb
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|u
parameter_list|)
block|{
name|EVP_CIPHER_INFO
name|cipher
decl_stmt|;
name|char
modifier|*
name|nm
init|=
name|NULL
decl_stmt|,
modifier|*
name|header
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|long
name|len
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|PEM_read_bio
argument_list|(
name|bp
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|header
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|ERR_GET_REASON
argument_list|(
name|ERR_peek_error
argument_list|()
argument_list|)
operator|==
name|PEM_R_NO_START_LINE
condition|)
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"Expecting: "
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|check_pem
argument_list|(
name|nm
argument_list|,
name|name
argument_list|)
condition|)
break|break;
name|OPENSSL_free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|PEM_get_EVP_CIPHER_INFO
argument_list|(
name|header
argument_list|,
operator|&
name|cipher
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|PEM_do_header
argument_list|(
operator|&
name|cipher
argument_list|,
name|data
argument_list|,
operator|&
name|len
argument_list|,
name|cb
argument_list|,
name|u
argument_list|)
condition|)
goto|goto
name|err
goto|;
operator|*
name|pdata
operator|=
name|data
expr_stmt|;
operator|*
name|plen
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|pnm
condition|)
operator|*
name|pnm
operator|=
name|nm
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
operator|!
name|ret
operator|||
operator|!
name|pnm
condition|)
name|OPENSSL_free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|OPENSSL_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_FP_API
end_ifndef

begin_function
name|int
name|PEM_ASN1_write
parameter_list|(
name|i2d_of_void
modifier|*
name|i2d
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|EVP_CIPHER
modifier|*
name|enc
parameter_list|,
name|unsigned
name|char
modifier|*
name|kstr
parameter_list|,
name|int
name|klen
parameter_list|,
name|pem_password_cb
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|u
parameter_list|)
block|{
name|BIO
modifier|*
name|b
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|BIO_new
argument_list|(
name|BIO_s_file
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_ASN1_WRITE
argument_list|,
name|ERR_R_BUF_LIB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|BIO_set_fp
argument_list|(
name|b
argument_list|,
name|fp
argument_list|,
name|BIO_NOCLOSE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|PEM_ASN1_write_bio
argument_list|(
name|i2d
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
name|x
argument_list|,
name|enc
argument_list|,
name|kstr
argument_list|,
name|klen
argument_list|,
name|callback
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|PEM_ASN1_write_bio
parameter_list|(
name|i2d_of_void
modifier|*
name|i2d
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|BIO
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|EVP_CIPHER
modifier|*
name|enc
parameter_list|,
name|unsigned
name|char
modifier|*
name|kstr
parameter_list|,
name|int
name|klen
parameter_list|,
name|pem_password_cb
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|u
parameter_list|)
block|{
name|EVP_CIPHER_CTX
name|ctx
decl_stmt|;
name|int
name|dsize
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|objstr
init|=
name|NULL
decl_stmt|;
name|char
name|buf
index|[
name|PEM_BUFSIZE
index|]
decl_stmt|;
name|unsigned
name|char
name|key
index|[
name|EVP_MAX_KEY_LENGTH
index|]
decl_stmt|;
name|unsigned
name|char
name|iv
index|[
name|EVP_MAX_IV_LENGTH
index|]
decl_stmt|;
if|if
condition|(
name|enc
operator|!=
name|NULL
condition|)
block|{
name|objstr
operator|=
name|OBJ_nid2sn
argument_list|(
name|EVP_CIPHER_nid
argument_list|(
name|enc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|objstr
operator|==
name|NULL
operator|||
name|EVP_CIPHER_iv_length
argument_list|(
name|enc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_ASN1_WRITE_BIO
argument_list|,
name|PEM_R_UNSUPPORTED_CIPHER
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|dsize
operator|=
name|i2d
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_ASN1_WRITE_BIO
argument_list|,
name|ERR_R_ASN1_LIB
argument_list|)
expr_stmt|;
name|dsize
operator|=
literal|0
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* dzise + 8 bytes are needed */
comment|/* actually it needs the cipher block size extra... */
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|dsize
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_ASN1_WRITE_BIO
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|=
name|data
expr_stmt|;
name|i
operator|=
name|i2d
argument_list|(
name|x
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|kstr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|callback
operator|==
name|NULL
condition|)
name|klen
operator|=
name|PEM_def_callback
argument_list|(
name|buf
argument_list|,
name|PEM_BUFSIZE
argument_list|,
literal|1
argument_list|,
name|u
argument_list|)
expr_stmt|;
else|else
name|klen
operator|=
call|(
modifier|*
name|callback
call|)
argument_list|(
name|buf
argument_list|,
name|PEM_BUFSIZE
argument_list|,
literal|1
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|klen
operator|<=
literal|0
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_ASN1_WRITE_BIO
argument_list|,
name|PEM_R_READ_KEY
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
ifdef|#
directive|ifdef
name|CHARSET_EBCDIC
comment|/* Convert the pass phrase from EBCDIC */
name|ebcdic2ascii
argument_list|(
name|buf
argument_list|,
name|buf
argument_list|,
name|klen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kstr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
expr_stmt|;
block|}
name|RAND_add
argument_list|(
name|data
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* put in the RSA key. */
name|OPENSSL_assert
argument_list|(
name|enc
operator|->
name|iv_len
operator|<=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|iv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RAND_pseudo_bytes
argument_list|(
name|iv
argument_list|,
name|enc
operator|->
name|iv_len
argument_list|)
operator|<
literal|0
condition|)
comment|/* Generate a salt */
goto|goto
name|err
goto|;
comment|/*          * The 'iv' is used as the iv and as a salt.  It is NOT taken from          * the BytesToKey function          */
if|if
condition|(
operator|!
name|EVP_BytesToKey
argument_list|(
name|enc
argument_list|,
name|EVP_md5
argument_list|()
argument_list|,
name|iv
argument_list|,
name|kstr
argument_list|,
name|klen
argument_list|,
literal|1
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|kstr
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
condition|)
name|OPENSSL_cleanse
argument_list|(
name|buf
argument_list|,
name|PEM_BUFSIZE
argument_list|)
expr_stmt|;
name|OPENSSL_assert
argument_list|(
name|strlen
argument_list|(
name|objstr
argument_list|)
operator|+
literal|23
operator|+
literal|2
operator|*
name|enc
operator|->
name|iv_len
operator|+
literal|13
operator|<=
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|PEM_proc_type
argument_list|(
name|buf
argument_list|,
name|PEM_TYPE_ENCRYPTED
argument_list|)
expr_stmt|;
name|PEM_dek_info
argument_list|(
name|buf
argument_list|,
name|objstr
argument_list|,
name|enc
operator|->
name|iv_len
argument_list|,
operator|(
name|char
operator|*
operator|)
name|iv
argument_list|)
expr_stmt|;
comment|/* k=strlen(buf); */
name|EVP_CIPHER_CTX_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|EVP_EncryptInit_ex
argument_list|(
operator|&
name|ctx
argument_list|,
name|enc
argument_list|,
name|NULL
argument_list|,
name|key
argument_list|,
name|iv
argument_list|)
operator|||
operator|!
name|EVP_EncryptUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|data
argument_list|,
operator|&
name|j
argument_list|,
name|data
argument_list|,
name|i
argument_list|)
operator|||
operator|!
name|EVP_EncryptFinal_ex
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
operator|(
name|data
index|[
name|j
index|]
operator|)
argument_list|,
operator|&
name|i
argument_list|)
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
name|i
operator|+=
name|j
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|1
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|i
operator|=
name|PEM_write_bio
argument_list|(
name|bp
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
name|err
label|:
name|OPENSSL_cleanse
argument_list|(
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|OPENSSL_cleanse
argument_list|(
name|iv
argument_list|,
sizeof|sizeof
argument_list|(
name|iv
argument_list|)
argument_list|)
expr_stmt|;
name|OPENSSL_cleanse
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ctx
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|OPENSSL_cleanse
argument_list|(
name|buf
argument_list|,
name|PEM_BUFSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
name|OPENSSL_cleanse
argument_list|(
name|data
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dsize
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|PEM_do_header
parameter_list|(
name|EVP_CIPHER_INFO
modifier|*
name|cipher
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|long
modifier|*
name|plen
parameter_list|,
name|pem_password_cb
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|u
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|,
name|o
decl_stmt|,
name|klen
decl_stmt|;
name|long
name|len
decl_stmt|;
name|EVP_CIPHER_CTX
name|ctx
decl_stmt|;
name|unsigned
name|char
name|key
index|[
name|EVP_MAX_KEY_LENGTH
index|]
decl_stmt|;
name|char
name|buf
index|[
name|PEM_BUFSIZE
index|]
decl_stmt|;
name|len
operator|=
operator|*
name|plen
expr_stmt|;
if|if
condition|(
name|cipher
operator|->
name|cipher
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|callback
operator|==
name|NULL
condition|)
name|klen
operator|=
name|PEM_def_callback
argument_list|(
name|buf
argument_list|,
name|PEM_BUFSIZE
argument_list|,
literal|0
argument_list|,
name|u
argument_list|)
expr_stmt|;
else|else
name|klen
operator|=
name|callback
argument_list|(
name|buf
argument_list|,
name|PEM_BUFSIZE
argument_list|,
literal|0
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|klen
operator|<=
literal|0
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_DO_HEADER
argument_list|,
name|PEM_R_BAD_PASSWORD_READ
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|CHARSET_EBCDIC
comment|/* Convert the pass phrase from EBCDIC */
name|ebcdic2ascii
argument_list|(
name|buf
argument_list|,
name|buf
argument_list|,
name|klen
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|EVP_BytesToKey
argument_list|(
name|cipher
operator|->
name|cipher
argument_list|,
name|EVP_md5
argument_list|()
argument_list|,
operator|&
operator|(
name|cipher
operator|->
name|iv
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
name|klen
argument_list|,
literal|1
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
name|j
operator|=
operator|(
name|int
operator|)
name|len
expr_stmt|;
name|EVP_CIPHER_CTX_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|o
operator|=
name|EVP_DecryptInit_ex
argument_list|(
operator|&
name|ctx
argument_list|,
name|cipher
operator|->
name|cipher
argument_list|,
name|NULL
argument_list|,
name|key
argument_list|,
operator|&
operator|(
name|cipher
operator|->
name|iv
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
condition|)
name|o
operator|=
name|EVP_DecryptUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|data
argument_list|,
operator|&
name|i
argument_list|,
name|data
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
condition|)
name|o
operator|=
name|EVP_DecryptFinal_ex
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
operator|(
name|data
index|[
name|i
index|]
operator|)
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|OPENSSL_cleanse
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|OPENSSL_cleanse
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_DO_HEADER
argument_list|,
name|PEM_R_BAD_DECRYPT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|plen
operator|=
name|j
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|PEM_get_EVP_CIPHER_INFO
parameter_list|(
name|char
modifier|*
name|header
parameter_list|,
name|EVP_CIPHER_INFO
modifier|*
name|cipher
parameter_list|)
block|{
specifier|const
name|EVP_CIPHER
modifier|*
name|enc
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
modifier|*
name|header_pp
init|=
operator|&
name|header
decl_stmt|;
name|cipher
operator|->
name|cipher
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|header
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|header
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|header
operator|==
literal|'\n'
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|header
argument_list|,
literal|"Proc-Type: "
argument_list|,
literal|11
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_GET_EVP_CIPHER_INFO
argument_list|,
name|PEM_R_NOT_PROC_TYPE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|header
operator|+=
literal|11
expr_stmt|;
if|if
condition|(
operator|*
name|header
operator|!=
literal|'4'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|header
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|header
operator|!=
literal|','
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|header
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|header
argument_list|,
literal|"ENCRYPTED"
argument_list|,
literal|9
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_GET_EVP_CIPHER_INFO
argument_list|,
name|PEM_R_NOT_ENCRYPTED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
init|;
operator|(
operator|*
name|header
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
operator|*
name|header
operator|!=
literal|'\0'
operator|)
condition|;
name|header
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|header
operator|==
literal|'\0'
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_GET_EVP_CIPHER_INFO
argument_list|,
name|PEM_R_SHORT_HEADER
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|header
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|header
argument_list|,
literal|"DEK-Info: "
argument_list|,
literal|10
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_GET_EVP_CIPHER_INFO
argument_list|,
name|PEM_R_NOT_DEK_INFO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|header
operator|+=
literal|10
expr_stmt|;
name|p
operator|=
name|header
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|header
expr_stmt|;
ifndef|#
directive|ifndef
name|CHARSET_EBCDIC
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|c
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'Z'
operator|)
operator|)
operator|||
operator|(
name|c
operator|==
literal|'-'
operator|)
operator|||
operator|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
operator|)
operator|)
condition|)
break|break;
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|isupper
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|c
operator|==
literal|'-'
operator|)
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
operator|)
condition|)
break|break;
endif|#
directive|endif
name|header
operator|++
expr_stmt|;
block|}
operator|*
name|header
operator|=
literal|'\0'
expr_stmt|;
name|cipher
operator|->
name|cipher
operator|=
name|enc
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|header
operator|=
name|c
expr_stmt|;
name|header
operator|++
expr_stmt|;
if|if
condition|(
name|enc
operator|==
name|NULL
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_GET_EVP_CIPHER_INFO
argument_list|,
name|PEM_R_UNSUPPORTED_ENCRYPTION
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|load_iv
argument_list|(
name|header_pp
argument_list|,
operator|&
operator|(
name|cipher
operator|->
name|iv
index|[
literal|0
index|]
operator|)
argument_list|,
name|enc
operator|->
name|iv_len
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|load_iv
parameter_list|(
name|char
modifier|*
modifier|*
name|fromp
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|v
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|from
operator|=
operator|*
name|fromp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|to
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|num
operator|*=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|from
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|from
operator|<=
literal|'9'
operator|)
condition|)
name|v
operator|=
operator|*
name|from
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|from
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
operator|*
name|from
operator|<=
literal|'F'
operator|)
condition|)
name|v
operator|=
operator|*
name|from
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|from
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
operator|*
name|from
operator|<=
literal|'f'
operator|)
condition|)
name|v
operator|=
operator|*
name|from
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
else|else
block|{
name|PEMerr
argument_list|(
name|PEM_F_LOAD_IV
argument_list|,
name|PEM_R_BAD_IV_CHARS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|from
operator|++
expr_stmt|;
name|to
index|[
name|i
operator|/
literal|2
index|]
operator||=
name|v
operator|<<
call|(
name|long
call|)
argument_list|(
operator|(
operator|!
operator|(
name|i
operator|&
literal|1
operator|)
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
operator|*
name|fromp
operator|=
name|from
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_FP_API
end_ifndef

begin_function
name|int
name|PEM_write
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|header
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|long
name|len
parameter_list|)
block|{
name|BIO
modifier|*
name|b
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|BIO_new
argument_list|(
name|BIO_s_file
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_WRITE
argument_list|,
name|ERR_R_BUF_LIB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|BIO_set_fp
argument_list|(
name|b
argument_list|,
name|fp
argument_list|,
name|BIO_NOCLOSE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|PEM_write_bio
argument_list|(
name|b
argument_list|,
name|name
argument_list|,
name|header
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|PEM_write_bio
parameter_list|(
name|BIO
modifier|*
name|bp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|header
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|long
name|len
parameter_list|)
block|{
name|int
name|nlen
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|outl
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|EVP_ENCODE_CTX
name|ctx
decl_stmt|;
name|int
name|reason
init|=
name|ERR_R_BUF_LIB
decl_stmt|;
name|EVP_EncodeInit
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|nlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BIO_write
argument_list|(
name|bp
argument_list|,
literal|"-----BEGIN "
argument_list|,
literal|11
argument_list|)
operator|!=
literal|11
operator|)
operator|||
operator|(
name|BIO_write
argument_list|(
name|bp
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
operator|!=
name|nlen
operator|)
operator|||
operator|(
name|BIO_write
argument_list|(
name|bp
argument_list|,
literal|"-----\n"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|6
operator|)
condition|)
goto|goto
name|err
goto|;
name|i
operator|=
name|strlen
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|BIO_write
argument_list|(
name|bp
argument_list|,
name|header
argument_list|,
name|i
argument_list|)
operator|!=
name|i
operator|)
operator|||
operator|(
name|BIO_write
argument_list|(
name|bp
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|)
condition|)
goto|goto
name|err
goto|;
block|}
name|buf
operator|=
name|OPENSSL_malloc
argument_list|(
name|PEM_BUFSIZE
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|reason
operator|=
name|ERR_R_MALLOC_FAILURE
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|n
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|len
operator|>
operator|(
name|PEM_BUFSIZE
operator|*
literal|5
operator|)
operator|)
condition|?
operator|(
name|PEM_BUFSIZE
operator|*
literal|5
operator|)
else|:
name|len
argument_list|)
expr_stmt|;
name|EVP_EncodeUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf
argument_list|,
operator|&
name|outl
argument_list|,
operator|&
operator|(
name|data
index|[
name|j
index|]
operator|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|outl
operator|)
operator|&&
operator|(
name|BIO_write
argument_list|(
name|bp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|outl
argument_list|)
operator|!=
name|outl
operator|)
condition|)
goto|goto
name|err
goto|;
name|i
operator|+=
name|outl
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
name|j
operator|+=
name|n
expr_stmt|;
block|}
name|EVP_EncodeFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf
argument_list|,
operator|&
name|outl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|outl
operator|>
literal|0
operator|)
operator|&&
operator|(
name|BIO_write
argument_list|(
name|bp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|outl
argument_list|)
operator|!=
name|outl
operator|)
condition|)
goto|goto
name|err
goto|;
name|OPENSSL_cleanse
argument_list|(
name|buf
argument_list|,
name|PEM_BUFSIZE
operator|*
literal|8
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|BIO_write
argument_list|(
name|bp
argument_list|,
literal|"-----END "
argument_list|,
literal|9
argument_list|)
operator|!=
literal|9
operator|)
operator|||
operator|(
name|BIO_write
argument_list|(
name|bp
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
operator|!=
name|nlen
operator|)
operator|||
operator|(
name|BIO_write
argument_list|(
name|bp
argument_list|,
literal|"-----\n"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|6
operator|)
condition|)
goto|goto
name|err
goto|;
return|return
operator|(
name|i
operator|+
name|outl
operator|)
return|;
name|err
label|:
if|if
condition|(
name|buf
condition|)
block|{
name|OPENSSL_cleanse
argument_list|(
name|buf
argument_list|,
name|PEM_BUFSIZE
operator|*
literal|8
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|PEMerr
argument_list|(
name|PEM_F_PEM_WRITE_BIO
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_FP_API
end_ifndef

begin_function
name|int
name|PEM_read
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|header
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|long
modifier|*
name|len
parameter_list|)
block|{
name|BIO
modifier|*
name|b
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|BIO_new
argument_list|(
name|BIO_s_file
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_READ
argument_list|,
name|ERR_R_BUF_LIB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|BIO_set_fp
argument_list|(
name|b
argument_list|,
name|fp
argument_list|,
name|BIO_NOCLOSE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|PEM_read_bio
argument_list|(
name|b
argument_list|,
name|name
argument_list|,
name|header
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|PEM_read_bio
parameter_list|(
name|BIO
modifier|*
name|bp
parameter_list|,
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|header
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|long
modifier|*
name|len
parameter_list|)
block|{
name|EVP_ENCODE_CTX
name|ctx
decl_stmt|;
name|int
name|end
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|k
decl_stmt|,
name|bl
init|=
literal|0
decl_stmt|,
name|hl
init|=
literal|0
decl_stmt|,
name|nohead
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|BUF_MEM
modifier|*
name|nameB
decl_stmt|;
name|BUF_MEM
modifier|*
name|headerB
decl_stmt|;
name|BUF_MEM
modifier|*
name|dataB
decl_stmt|,
modifier|*
name|tmpB
decl_stmt|;
name|nameB
operator|=
name|BUF_MEM_new
argument_list|()
expr_stmt|;
name|headerB
operator|=
name|BUF_MEM_new
argument_list|()
expr_stmt|;
name|dataB
operator|=
name|BUF_MEM_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|nameB
operator|==
name|NULL
operator|)
operator|||
operator|(
name|headerB
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dataB
operator|==
name|NULL
operator|)
condition|)
block|{
name|BUF_MEM_free
argument_list|(
name|nameB
argument_list|)
expr_stmt|;
name|BUF_MEM_free
argument_list|(
name|headerB
argument_list|)
expr_stmt|;
name|BUF_MEM_free
argument_list|(
name|dataB
argument_list|)
expr_stmt|;
name|PEMerr
argument_list|(
name|PEM_F_PEM_READ_BIO
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|buf
index|[
literal|254
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|BIO_gets
argument_list|(
name|bp
argument_list|,
name|buf
argument_list|,
literal|254
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_READ_BIO
argument_list|,
name|PEM_R_NO_START_LINE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
while|while
condition|(
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|buf
index|[
name|i
index|]
operator|<=
literal|' '
operator|)
condition|)
name|i
operator|--
expr_stmt|;
name|buf
index|[
operator|++
name|i
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buf
index|[
operator|++
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"-----BEGIN "
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
operator|&
operator|(
name|buf
index|[
literal|11
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|&
operator|(
name|buf
index|[
literal|11
operator|+
name|i
operator|-
literal|6
index|]
operator|)
argument_list|,
literal|"-----\n"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|BUF_MEM_grow
argument_list|(
name|nameB
argument_list|,
name|i
operator|+
literal|9
argument_list|)
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_READ_BIO
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|memcpy
argument_list|(
name|nameB
operator|->
name|data
argument_list|,
operator|&
operator|(
name|buf
index|[
literal|11
index|]
operator|)
argument_list|,
name|i
operator|-
literal|6
argument_list|)
expr_stmt|;
name|nameB
operator|->
name|data
index|[
name|i
operator|-
literal|6
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
name|hl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|BUF_MEM_grow
argument_list|(
name|headerB
argument_list|,
literal|256
argument_list|)
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_READ_BIO
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|headerB
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|BIO_gets
argument_list|(
name|bp
argument_list|,
name|buf
argument_list|,
literal|254
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
while|while
condition|(
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|buf
index|[
name|i
index|]
operator|<=
literal|' '
operator|)
condition|)
name|i
operator|--
expr_stmt|;
name|buf
index|[
operator|++
name|i
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buf
index|[
operator|++
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
operator|!
name|BUF_MEM_grow
argument_list|(
name|headerB
argument_list|,
name|hl
operator|+
name|i
operator|+
literal|9
argument_list|)
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_READ_BIO
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"-----END "
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nohead
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
operator|&
operator|(
name|headerB
operator|->
name|data
index|[
name|hl
index|]
operator|)
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|headerB
operator|->
name|data
index|[
name|hl
operator|+
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hl
operator|+=
name|i
expr_stmt|;
block|}
name|bl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|BUF_MEM_grow
argument_list|(
name|dataB
argument_list|,
literal|1024
argument_list|)
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_READ_BIO
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|dataB
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|nohead
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|BIO_gets
argument_list|(
name|bp
argument_list|,
name|buf
argument_list|,
literal|254
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
while|while
condition|(
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|buf
index|[
name|i
index|]
operator|<=
literal|' '
operator|)
condition|)
name|i
operator|--
expr_stmt|;
name|buf
index|[
operator|++
name|i
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buf
index|[
operator|++
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|65
condition|)
name|end
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"-----END "
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>
literal|65
condition|)
break|break;
if|if
condition|(
operator|!
name|BUF_MEM_grow_clean
argument_list|(
name|dataB
argument_list|,
name|i
operator|+
name|bl
operator|+
literal|9
argument_list|)
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_READ_BIO
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|memcpy
argument_list|(
operator|&
operator|(
name|dataB
operator|->
name|data
index|[
name|bl
index|]
operator|)
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dataB
operator|->
name|data
index|[
name|bl
operator|+
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bl
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|BIO_gets
argument_list|(
name|bp
argument_list|,
name|buf
argument_list|,
literal|254
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
while|while
condition|(
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|buf
index|[
name|i
index|]
operator|<=
literal|' '
operator|)
condition|)
name|i
operator|--
expr_stmt|;
name|buf
index|[
operator|++
name|i
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buf
index|[
operator|++
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|tmpB
operator|=
name|headerB
expr_stmt|;
name|headerB
operator|=
name|dataB
expr_stmt|;
name|dataB
operator|=
name|tmpB
expr_stmt|;
name|bl
operator|=
name|hl
expr_stmt|;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|nameB
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"-----END "
argument_list|,
literal|9
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|nameB
operator|->
name|data
argument_list|,
operator|&
operator|(
name|buf
index|[
literal|9
index|]
operator|)
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
operator|&
operator|(
name|buf
index|[
literal|9
operator|+
name|i
index|]
operator|)
argument_list|,
literal|"-----\n"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_READ_BIO
argument_list|,
name|PEM_R_BAD_END_LINE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|EVP_DecodeInit
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|i
operator|=
name|EVP_DecodeUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dataB
operator|->
name|data
argument_list|,
operator|&
name|bl
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dataB
operator|->
name|data
argument_list|,
name|bl
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_READ_BIO
argument_list|,
name|PEM_R_BAD_BASE64_DECODE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|i
operator|=
name|EVP_DecodeFinal
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
name|dataB
operator|->
name|data
index|[
name|bl
index|]
operator|)
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|PEMerr
argument_list|(
name|PEM_F_PEM_READ_BIO
argument_list|,
name|PEM_R_BAD_BASE64_DECODE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|bl
operator|+=
name|k
expr_stmt|;
if|if
condition|(
name|bl
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
operator|*
name|name
operator|=
name|nameB
operator|->
name|data
expr_stmt|;
operator|*
name|header
operator|=
name|headerB
operator|->
name|data
expr_stmt|;
operator|*
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dataB
operator|->
name|data
expr_stmt|;
operator|*
name|len
operator|=
name|bl
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|nameB
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|headerB
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|dataB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|err
label|:
name|BUF_MEM_free
argument_list|(
name|nameB
argument_list|)
expr_stmt|;
name|BUF_MEM_free
argument_list|(
name|headerB
argument_list|)
expr_stmt|;
name|BUF_MEM_free
argument_list|(
name|dataB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check pem string and return prefix length. If for example the pem_str ==  * "RSA PRIVATE KEY" and suffix = "PRIVATE KEY" the return value is 3 for the  * string "RSA".  */
end_comment

begin_function
name|int
name|pem_check_suffix
parameter_list|(
specifier|const
name|char
modifier|*
name|pem_str
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|)
block|{
name|int
name|pem_len
init|=
name|strlen
argument_list|(
name|pem_str
argument_list|)
decl_stmt|;
name|int
name|suffix_len
init|=
name|strlen
argument_list|(
name|suffix
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|suffix_len
operator|+
literal|1
operator|>=
name|pem_len
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|pem_str
operator|+
name|pem_len
operator|-
name|suffix_len
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|suffix
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
return|return
literal|0
return|;
return|return
name|p
operator|-
name|pem_str
return|;
block|}
end_function

end_unit

