begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* openssl/engine.h */
end_comment

begin_comment
comment|/*  * Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL project  * 2000.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1999-2004 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.  * ECDH support in OpenSSL originally developed by  * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HEADER_ENGINE_H
end_ifndef

begin_define
define|#
directive|define
name|HEADER_ENGINE_H
end_define

begin_include
include|#
directive|include
file|<openssl/opensslconf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_NO_ENGINE
end_ifdef

begin_error
error|#
directive|error
error|ENGINE is disabled.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DEPRECATED
end_ifndef

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_include
include|#
directive|include
file|<openssl/rsa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
end_ifndef

begin_include
include|#
directive|include
file|<openssl/dsa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_include
include|#
directive|include
file|<openssl/dh.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDH
end_ifndef

begin_include
include|#
directive|include
file|<openssl/ecdh.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDSA
end_ifndef

begin_include
include|#
directive|include
file|<openssl/ecdsa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ui.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/ossl_typ.h>
end_include

begin_include
include|#
directive|include
file|<openssl/symhacks.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*  * These flags are used to control combinations of algorithm (methods) by  * bitwise "OR"ing.  */
define|#
directive|define
name|ENGINE_METHOD_RSA
value|(unsigned int)0x0001
define|#
directive|define
name|ENGINE_METHOD_DSA
value|(unsigned int)0x0002
define|#
directive|define
name|ENGINE_METHOD_DH
value|(unsigned int)0x0004
define|#
directive|define
name|ENGINE_METHOD_RAND
value|(unsigned int)0x0008
define|#
directive|define
name|ENGINE_METHOD_ECDH
value|(unsigned int)0x0010
define|#
directive|define
name|ENGINE_METHOD_ECDSA
value|(unsigned int)0x0020
define|#
directive|define
name|ENGINE_METHOD_CIPHERS
value|(unsigned int)0x0040
define|#
directive|define
name|ENGINE_METHOD_DIGESTS
value|(unsigned int)0x0080
define|#
directive|define
name|ENGINE_METHOD_STORE
value|(unsigned int)0x0100
define|#
directive|define
name|ENGINE_METHOD_PKEY_METHS
value|(unsigned int)0x0200
define|#
directive|define
name|ENGINE_METHOD_PKEY_ASN1_METHS
value|(unsigned int)0x0400
comment|/* Obvious all-or-nothing cases. */
define|#
directive|define
name|ENGINE_METHOD_ALL
value|(unsigned int)0xFFFF
define|#
directive|define
name|ENGINE_METHOD_NONE
value|(unsigned int)0x0000
comment|/*  * This(ese) flag(s) controls behaviour of the ENGINE_TABLE mechanism used  * internally to control registration of ENGINE implementations, and can be  * set by ENGINE_set_table_flags(). The "NOINIT" flag prevents attempts to  * initialise registered ENGINEs if they are not already initialised.  */
define|#
directive|define
name|ENGINE_TABLE_FLAG_NOINIT
value|(unsigned int)0x0001
comment|/* ENGINE flags that can be set by ENGINE_set_flags(). */
comment|/* Not used */
comment|/* #define ENGINE_FLAGS_MALLOCED        0x0001 */
comment|/*  * This flag is for ENGINEs that wish to handle the various 'CMD'-related  * control commands on their own. Without this flag, ENGINE_ctrl() handles  * these control commands on behalf of the ENGINE using their "cmd_defns"  * data.  */
define|#
directive|define
name|ENGINE_FLAGS_MANUAL_CMD_CTRL
value|(int)0x0002
comment|/*  * This flag is for ENGINEs who return new duplicate structures when found  * via "ENGINE_by_id()". When an ENGINE must store state (eg. if  * ENGINE_ctrl() commands are called in sequence as part of some stateful  * process like key-generation setup and execution), it can set this flag -  * then each attempt to obtain the ENGINE will result in it being copied into  * a new structure. Normally, ENGINEs don't declare this flag so  * ENGINE_by_id() just increments the existing ENGINE's structural reference  * count.  */
define|#
directive|define
name|ENGINE_FLAGS_BY_ID_COPY
value|(int)0x0004
comment|/*  * This flag if for an ENGINE that does not want its methods registered as  * part of ENGINE_register_all_complete() for example if the methods are not  * usable as default methods.  */
define|#
directive|define
name|ENGINE_FLAGS_NO_REGISTER_ALL
value|(int)0x0008
comment|/*  * ENGINEs can support their own command types, and these flags are used in  * ENGINE_CTRL_GET_CMD_FLAGS to indicate to the caller what kind of input  * each command expects. Currently only numeric and string input is  * supported. If a control command supports none of the _NUMERIC, _STRING, or  * _NO_INPUT options, then it is regarded as an "internal" control command -  * and not for use in config setting situations. As such, they're not  * available to the ENGINE_ctrl_cmd_string() function, only raw ENGINE_ctrl()  * access. Changes to this list of 'command types' should be reflected  * carefully in ENGINE_cmd_is_executable() and ENGINE_ctrl_cmd_string().  */
comment|/* accepts a 'long' input value (3rd parameter to ENGINE_ctrl) */
define|#
directive|define
name|ENGINE_CMD_FLAG_NUMERIC
value|(unsigned int)0x0001
comment|/*  * accepts string input (cast from 'void*' to 'const char *', 4th parameter  * to ENGINE_ctrl)  */
define|#
directive|define
name|ENGINE_CMD_FLAG_STRING
value|(unsigned int)0x0002
comment|/*  * Indicates that the control command takes *no* input. Ie. the control  * command is unparameterised.  */
define|#
directive|define
name|ENGINE_CMD_FLAG_NO_INPUT
value|(unsigned int)0x0004
comment|/*  * Indicates that the control command is internal. This control command won't  * be shown in any output, and is only usable through the ENGINE_ctrl_cmd()  * function.  */
define|#
directive|define
name|ENGINE_CMD_FLAG_INTERNAL
value|(unsigned int)0x0008
comment|/*  * NB: These 3 control commands are deprecated and should not be used.  * ENGINEs relying on these commands should compile conditional support for  * compatibility (eg. if these symbols are defined) but should also migrate  * the same functionality to their own ENGINE-specific control functions that  * can be "discovered" by calling applications. The fact these control  * commands wouldn't be "executable" (ie. usable by text-based config)  * doesn't change the fact that application code can find and use them  * without requiring per-ENGINE hacking.  */
comment|/*  * These flags are used to tell the ctrl function what should be done. All  * command numbers are shared between all engines, even if some don't make  * sense to some engines.  In such a case, they do nothing but return the  * error ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED.  */
define|#
directive|define
name|ENGINE_CTRL_SET_LOGSTREAM
value|1
define|#
directive|define
name|ENGINE_CTRL_SET_PASSWORD_CALLBACK
value|2
define|#
directive|define
name|ENGINE_CTRL_HUP
value|3
comment|/* Close and reinitialise                                                    * any handles/connections                                                    * etc. */
define|#
directive|define
name|ENGINE_CTRL_SET_USER_INTERFACE
value|4
comment|/* Alternative to callback */
define|#
directive|define
name|ENGINE_CTRL_SET_CALLBACK_DATA
value|5
comment|/* User-specific data, used                                                    * when calling the password                                                    * callback and the user                                                    * interface */
define|#
directive|define
name|ENGINE_CTRL_LOAD_CONFIGURATION
value|6
comment|/* Load a configuration,                                                    * given a string that                                                    * represents a file name                                                    * or so */
define|#
directive|define
name|ENGINE_CTRL_LOAD_SECTION
value|7
comment|/* Load data from a given                                                    * section in the already                                                    * loaded configuration */
comment|/*  * These control commands allow an application to deal with an arbitrary  * engine in a dynamic way. Warn: Negative return values indicate errors FOR  * THESE COMMANDS because zero is used to indicate 'end-of-list'. Other  * commands, including ENGINE-specific command types, return zero for an  * error. An ENGINE can choose to implement these ctrl functions, and can  * internally manage things however it chooses - it does so by setting the  * ENGINE_FLAGS_MANUAL_CMD_CTRL flag (using ENGINE_set_flags()). Otherwise  * the ENGINE_ctrl() code handles this on the ENGINE's behalf using the  * cmd_defns data (set using ENGINE_set_cmd_defns()). This means an ENGINE's  * ctrl() handler need only implement its own commands - the above "meta"  * commands will be taken care of.  */
comment|/*  * Returns non-zero if the supplied ENGINE has a ctrl() handler. If "not",  * then all the remaining control commands will return failure, so it is  * worth checking this first if the caller is trying to "discover" the  * engine's capabilities and doesn't want errors generated unnecessarily.  */
define|#
directive|define
name|ENGINE_CTRL_HAS_CTRL_FUNCTION
value|10
comment|/*  * Returns a positive command number for the first command supported by the  * engine. Returns zero if no ctrl commands are supported.  */
define|#
directive|define
name|ENGINE_CTRL_GET_FIRST_CMD_TYPE
value|11
comment|/*  * The 'long' argument specifies a command implemented by the engine, and the  * return value is the next command supported, or zero if there are no more.  */
define|#
directive|define
name|ENGINE_CTRL_GET_NEXT_CMD_TYPE
value|12
comment|/*  * The 'void*' argument is a command name (cast from 'const char *'), and the  * return value is the command that corresponds to it.  */
define|#
directive|define
name|ENGINE_CTRL_GET_CMD_FROM_NAME
value|13
comment|/*  * The next two allow a command to be converted into its corresponding string  * form. In each case, the 'long' argument supplies the command. In the  * NAME_LEN case, the return value is the length of the command name (not  * counting a trailing EOL). In the NAME case, the 'void*' argument must be a  * string buffer large enough, and it will be populated with the name of the  * command (WITH a trailing EOL).  */
define|#
directive|define
name|ENGINE_CTRL_GET_NAME_LEN_FROM_CMD
value|14
define|#
directive|define
name|ENGINE_CTRL_GET_NAME_FROM_CMD
value|15
comment|/* The next two are similar but give a "short description" of a command. */
define|#
directive|define
name|ENGINE_CTRL_GET_DESC_LEN_FROM_CMD
value|16
define|#
directive|define
name|ENGINE_CTRL_GET_DESC_FROM_CMD
value|17
comment|/*  * With this command, the return value is the OR'd combination of  * ENGINE_CMD_FLAG_*** values that indicate what kind of input a given  * engine-specific ctrl command expects.  */
define|#
directive|define
name|ENGINE_CTRL_GET_CMD_FLAGS
value|18
comment|/*  * ENGINE implementations should start the numbering of their own control  * commands from this value. (ie. ENGINE_CMD_BASE, ENGINE_CMD_BASE + 1, etc).  */
define|#
directive|define
name|ENGINE_CMD_BASE
value|200
comment|/*  * NB: These 2 nCipher "chil" control commands are deprecated, and their  * functionality is now available through ENGINE-specific control commands  * (exposed through the above-mentioned 'CMD'-handling). Code using these 2  * commands should be migrated to the more general command handling before  * these are removed.  */
comment|/* Flags specific to the nCipher "chil" engine */
define|#
directive|define
name|ENGINE_CTRL_CHIL_SET_FORKCHECK
value|100
comment|/*          * Depending on the value of the (long)i argument, this sets or          * unsets the SimpleForkCheck flag in the CHIL API to enable or          * disable checking and workarounds for applications that fork().          */
define|#
directive|define
name|ENGINE_CTRL_CHIL_NO_LOCKING
value|101
comment|/*          * This prevents the initialisation function from providing mutex          * callbacks to the nCipher library.          */
comment|/*  * If an ENGINE supports its own specific control commands and wishes the  * framework to handle the above 'ENGINE_CMD_***'-manipulation commands on  * its behalf, it should supply a null-terminated array of ENGINE_CMD_DEFN  * entries to ENGINE_set_cmd_defns(). It should also implement a ctrl()  * handler that supports the stated commands (ie. the "cmd_num" entries as  * described by the array). NB: The array must be ordered in increasing order  * of cmd_num. "null-terminated" means that the last ENGINE_CMD_DEFN element  * has cmd_num set to zero and/or cmd_name set to NULL.  */
typedef|typedef
struct|struct
name|ENGINE_CMD_DEFN_st
block|{
name|unsigned
name|int
name|cmd_num
decl_stmt|;
comment|/* The command number */
specifier|const
name|char
modifier|*
name|cmd_name
decl_stmt|;
comment|/* The command name itself */
specifier|const
name|char
modifier|*
name|cmd_desc
decl_stmt|;
comment|/* A short description of the command */
name|unsigned
name|int
name|cmd_flags
decl_stmt|;
comment|/* The input the command expects */
block|}
name|ENGINE_CMD_DEFN
typedef|;
comment|/* Generic function pointer */
typedef|typedef
name|int
function_decl|(
modifier|*
name|ENGINE_GEN_FUNC_PTR
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Generic function pointer taking no arguments */
typedef|typedef
name|int
function_decl|(
modifier|*
name|ENGINE_GEN_INT_FUNC_PTR
function_decl|)
parameter_list|(
name|ENGINE
modifier|*
parameter_list|)
function_decl|;
comment|/* Specific control function pointer */
typedef|typedef
name|int
function_decl|(
modifier|*
name|ENGINE_CTRL_FUNC_PTR
function_decl|)
parameter_list|(
name|ENGINE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|long
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
function_decl|;
comment|/* Generic load_key function pointer */
typedef|typedef
name|EVP_PKEY
modifier|*
function_decl|(
modifier|*
name|ENGINE_LOAD_KEY_PTR
function_decl|)
parameter_list|(
name|ENGINE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
function_decl|;
typedef|typedef
name|int
argument_list|(
operator|*
name|ENGINE_SSL_CLIENT_CERT_PTR
argument_list|)
argument_list|(
name|ENGINE
operator|*
argument_list|,
name|SSL
operator|*
name|ssl
argument_list|,
name|STACK_OF
argument_list|(
name|X509_NAME
argument_list|)
operator|*
name|ca_dn
argument_list|,
name|X509
operator|*
operator|*
name|pcert
argument_list|,
name|EVP_PKEY
operator|*
operator|*
name|pkey
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
operator|*
name|pother
argument_list|,
name|UI_METHOD
operator|*
name|ui_method
argument_list|,
name|void
operator|*
name|callback_data
argument_list|)
expr_stmt|;
comment|/*-  * These callback types are for an ENGINE's handler for cipher and digest logic.  * These handlers have these prototypes;  *   int foo(ENGINE *e, const EVP_CIPHER **cipher, const int **nids, int nid);  *   int foo(ENGINE *e, const EVP_MD **digest, const int **nids, int nid);  * Looking at how to implement these handlers in the case of cipher support, if  * the framework wants the EVP_CIPHER for 'nid', it will call;  *   foo(e,&p_evp_cipher, NULL, nid);    (return zero for failure)  * If the framework wants a list of supported 'nid's, it will call;  *   foo(e, NULL,&p_nids, 0); (returns number of 'nids' or -1 for error)  */
comment|/*  * Returns to a pointer to the array of supported cipher 'nid's. If the  * second parameter is non-NULL it is set to the size of the returned array.  */
typedef|typedef
name|int
function_decl|(
modifier|*
name|ENGINE_CIPHERS_PTR
function_decl|)
parameter_list|(
name|ENGINE
modifier|*
parameter_list|,
specifier|const
name|EVP_CIPHER
modifier|*
modifier|*
parameter_list|,
specifier|const
name|int
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|ENGINE_DIGESTS_PTR
function_decl|)
parameter_list|(
name|ENGINE
modifier|*
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
modifier|*
parameter_list|,
specifier|const
name|int
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|ENGINE_PKEY_METHS_PTR
function_decl|)
parameter_list|(
name|ENGINE
modifier|*
parameter_list|,
name|EVP_PKEY_METHOD
modifier|*
modifier|*
parameter_list|,
specifier|const
name|int
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|ENGINE_PKEY_ASN1_METHS_PTR
function_decl|)
parameter_list|(
name|ENGINE
modifier|*
parameter_list|,
name|EVP_PKEY_ASN1_METHOD
modifier|*
modifier|*
parameter_list|,
specifier|const
name|int
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/*  * STRUCTURE functions ... all of these functions deal with pointers to  * ENGINE structures where the pointers have a "structural reference". This  * means that their reference is to allowed access to the structure but it  * does not imply that the structure is functional. To simply increment or  * decrement the structural reference count, use ENGINE_by_id and  * ENGINE_free. NB: This is not required when iterating using ENGINE_get_next  * as it will automatically decrement the structural reference count of the  * "current" ENGINE and increment the structural reference count of the  * ENGINE it returns (unless it is NULL).  */
comment|/* Get the first/last "ENGINE" type available. */
name|ENGINE
modifier|*
name|ENGINE_get_first
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_last
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Iterate to the next/previous "ENGINE" type (NULL = end of the list). */
name|ENGINE
modifier|*
name|ENGINE_get_next
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_prev
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
comment|/* Add another "ENGINE" type into the array. */
name|int
name|ENGINE_add
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
comment|/* Remove an existing "ENGINE" type from the array. */
name|int
name|ENGINE_remove
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
comment|/* Retrieve an engine from the list by its unique "id" value. */
name|ENGINE
modifier|*
name|ENGINE_by_id
parameter_list|(
specifier|const
name|char
modifier|*
name|id
parameter_list|)
function_decl|;
comment|/* Add all the built-in engines. */
name|void
name|ENGINE_load_openssl
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_dynamic
parameter_list|(
name|void
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_STATIC_ENGINE
name|void
name|ENGINE_load_4758cca
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_aep
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_atalla
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_chil
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_cswift
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_nuron
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_sureware
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_ubsec
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_padlock
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_capi
parameter_list|(
name|void
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_GMP
name|void
name|ENGINE_load_gmp
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_GOST
name|void
name|ENGINE_load_gost
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
endif|#
directive|endif
name|void
name|ENGINE_load_cryptodev
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_rdrand
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_builtin_engines
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*  * Get and set global flags (ENGINE_TABLE_FLAG_***) for the implementation  * "registry" handling.  */
name|unsigned
name|int
name|ENGINE_get_table_flags
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_set_table_flags
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|)
function_decl|;
comment|/*- Manage registration of ENGINEs per "table". For each type, there are 3  * functions;  *   ENGINE_register_***(e) - registers the implementation from 'e' (if it has one)  *   ENGINE_unregister_***(e) - unregister the implementation from 'e'  *   ENGINE_register_all_***() - call ENGINE_register_***() for each 'e' in the list  * Cleanup is automatically registered from each table when required, so  * ENGINE_cleanup() will reverse any "register" operations.  */
name|int
name|ENGINE_register_RSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_RSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_RSA
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_DSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_DSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_DSA
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_ECDH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_ECDH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_ECDH
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_ECDSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_ECDSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_ECDSA
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_DH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_DH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_DH
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_RAND
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_RAND
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_RAND
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_STORE
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_STORE
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_STORE
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_ciphers
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_ciphers
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_ciphers
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_digests
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_digests
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_digests
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_pkey_meths
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_pkey_meths
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_pkey_meths
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_pkey_asn1_meths
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_pkey_asn1_meths
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_pkey_asn1_meths
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*  * These functions register all support from the above categories. Note, use  * of these functions can result in static linkage of code your application  * may not need. If you only need a subset of functionality, consider using  * more selective initialisation.  */
name|int
name|ENGINE_register_complete
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_all_complete
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*  * Send parametrised control commands to the engine. The possibilities to  * send down an integer, a pointer to data or a function pointer are  * provided. Any of the parameters may or may not be NULL, depending on the  * command number. In actuality, this function only requires a structural  * (rather than functional) reference to an engine, but many control commands  * may require the engine be functional. The caller should be aware of trying  * commands that require an operational ENGINE, and only use functional  * references in such situations.  */
name|int
name|ENGINE_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
function_decl|;
comment|/*  * This function tests if an ENGINE-specific command is usable as a  * "setting". Eg. in an application's config file that gets processed through  * ENGINE_ctrl_cmd_string(). If this returns zero, it is not available to  * ENGINE_ctrl_cmd_string(), only ENGINE_ctrl().  */
name|int
name|ENGINE_cmd_is_executable
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|)
function_decl|;
comment|/*  * This function works like ENGINE_ctrl() with the exception of taking a  * command name instead of a command number, and can handle optional  * commands. See the comment on ENGINE_ctrl_cmd_string() for an explanation  * on how to use the cmd_name and cmd_optional.  */
name|int
name|ENGINE_ctrl_cmd
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd_name
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|,
name|int
name|cmd_optional
parameter_list|)
function_decl|;
comment|/*  * This function passes a command-name and argument to an ENGINE. The  * cmd_name is converted to a command number and the control command is  * called using 'arg' as an argument (unless the ENGINE doesn't support such  * a command, in which case no control command is called). The command is  * checked for input flags, and if necessary the argument will be converted  * to a numeric value. If cmd_optional is non-zero, then if the ENGINE  * doesn't support the given cmd_name the return value will be success  * anyway. This function is intended for applications to use so that users  * (or config files) can supply engine-specific config data to the ENGINE at  * run-time to control behaviour of specific engines. As such, it shouldn't  * be used for calling ENGINE_ctrl() functions that return data, deal with  * binary data, or that are otherwise supposed to be used directly through  * ENGINE_ctrl() in application code. Any "return" data from an ENGINE_ctrl()  * operation in this function will be lost - the return value is interpreted  * as failure if the return value is zero, success otherwise, and this  * function returns a boolean value as a result. In other words, vendors of  * 'ENGINE'-enabled devices should write ENGINE implementations with  * parameterisations that work in this scheme, so that compliant ENGINE-based  * applications can work consistently with the same configuration for the  * same ENGINE-enabled devices, across applications.  */
name|int
name|ENGINE_ctrl_cmd_string
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd_name
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|cmd_optional
parameter_list|)
function_decl|;
comment|/*  * These functions are useful for manufacturing new ENGINE structures. They  * don't address reference counting at all - one uses them to populate an  * ENGINE structure with personalised implementations of things prior to  * using it directly or adding it to the builtin ENGINE list in OpenSSL.  * These are also here so that the ENGINE structure doesn't have to be  * exposed and break binary compatibility!  */
name|ENGINE
modifier|*
name|ENGINE_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_free
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_up_ref
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_id
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_name
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_RSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|RSA_METHOD
modifier|*
name|rsa_meth
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_DSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|DSA_METHOD
modifier|*
name|dsa_meth
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_ECDH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|ECDH_METHOD
modifier|*
name|ecdh_meth
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_ECDSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|ECDSA_METHOD
modifier|*
name|ecdsa_meth
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_DH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|DH_METHOD
modifier|*
name|dh_meth
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_RAND
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|RAND_METHOD
modifier|*
name|rand_meth
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_STORE
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|STORE_METHOD
modifier|*
name|store_meth
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_destroy_function
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_GEN_INT_FUNC_PTR
name|destroy_f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_init_function
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_GEN_INT_FUNC_PTR
name|init_f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_finish_function
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_GEN_INT_FUNC_PTR
name|finish_f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_ctrl_function
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_CTRL_FUNC_PTR
name|ctrl_f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_load_privkey_function
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_LOAD_KEY_PTR
name|loadpriv_f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_load_pubkey_function
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_LOAD_KEY_PTR
name|loadpub_f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_load_ssl_client_cert_function
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_SSL_CLIENT_CERT_PTR
name|loadssl_f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_ciphers
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_CIPHERS_PTR
name|f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_digests
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_DIGESTS_PTR
name|f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_pkey_meths
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_PKEY_METHS_PTR
name|f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_pkey_asn1_meths
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_PKEY_ASN1_METHS_PTR
name|f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_flags
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_cmd_defns
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|ENGINE_CMD_DEFN
modifier|*
name|defns
parameter_list|)
function_decl|;
comment|/* These functions allow control over any per-structure ENGINE data. */
name|int
name|ENGINE_get_ex_new_index
parameter_list|(
name|long
name|argl
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|,
name|CRYPTO_EX_new
modifier|*
name|new_func
parameter_list|,
name|CRYPTO_EX_dup
modifier|*
name|dup_func
parameter_list|,
name|CRYPTO_EX_free
modifier|*
name|free_func
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_ex_data
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|idx
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
name|void
modifier|*
name|ENGINE_get_ex_data
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|idx
parameter_list|)
function_decl|;
comment|/*  * This function cleans up anything that needs it. Eg. the ENGINE_add()  * function automatically ensures the list cleanup function is registered to  * be called from ENGINE_cleanup(). Similarly, all ENGINE_register_***  * functions ensure ENGINE_cleanup() will clean up after them.  */
name|void
name|ENGINE_cleanup
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*  * These return values from within the ENGINE structure. These can be useful  * with functional references as well as structural references - it depends  * which you obtained. Using the result for functional purposes if you only  * obtained a structural reference may be problematic!  */
specifier|const
name|char
modifier|*
name|ENGINE_get_id
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|ENGINE_get_name
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|RSA_METHOD
modifier|*
name|ENGINE_get_RSA
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|DSA_METHOD
modifier|*
name|ENGINE_get_DSA
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|ECDH_METHOD
modifier|*
name|ENGINE_get_ECDH
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|ECDSA_METHOD
modifier|*
name|ENGINE_get_ECDSA
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|DH_METHOD
modifier|*
name|ENGINE_get_DH
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|RAND_METHOD
modifier|*
name|ENGINE_get_RAND
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|STORE_METHOD
modifier|*
name|ENGINE_get_STORE
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_GEN_INT_FUNC_PTR
name|ENGINE_get_destroy_function
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_GEN_INT_FUNC_PTR
name|ENGINE_get_init_function
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_GEN_INT_FUNC_PTR
name|ENGINE_get_finish_function
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_CTRL_FUNC_PTR
name|ENGINE_get_ctrl_function
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_LOAD_KEY_PTR
name|ENGINE_get_load_privkey_function
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_LOAD_KEY_PTR
name|ENGINE_get_load_pubkey_function
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_SSL_CLIENT_CERT_PTR
name|ENGINE_get_ssl_client_cert_function
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_CIPHERS_PTR
name|ENGINE_get_ciphers
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_DIGESTS_PTR
name|ENGINE_get_digests
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_PKEY_METHS_PTR
name|ENGINE_get_pkey_meths
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_PKEY_ASN1_METHS_PTR
name|ENGINE_get_pkey_asn1_meths
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|EVP_CIPHER
modifier|*
name|ENGINE_get_cipher
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|nid
parameter_list|)
function_decl|;
specifier|const
name|EVP_MD
modifier|*
name|ENGINE_get_digest
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|nid
parameter_list|)
function_decl|;
specifier|const
name|EVP_PKEY_METHOD
modifier|*
name|ENGINE_get_pkey_meth
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|nid
parameter_list|)
function_decl|;
specifier|const
name|EVP_PKEY_ASN1_METHOD
modifier|*
name|ENGINE_get_pkey_asn1_meth
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|nid
parameter_list|)
function_decl|;
specifier|const
name|EVP_PKEY_ASN1_METHOD
modifier|*
name|ENGINE_get_pkey_asn1_meth_str
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
specifier|const
name|EVP_PKEY_ASN1_METHOD
modifier|*
name|ENGINE_pkey_asn1_find_str
parameter_list|(
name|ENGINE
modifier|*
modifier|*
name|pe
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
specifier|const
name|ENGINE_CMD_DEFN
modifier|*
name|ENGINE_get_cmd_defns
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_get_flags
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
comment|/*  * FUNCTIONAL functions. These functions deal with ENGINE structures that  * have (or will) be initialised for use. Broadly speaking, the structural  * functions are useful for iterating the list of available engine types,  * creating new engine types, and other "list" operations. These functions  * actually deal with ENGINEs that are to be used. As such these functions  * can fail (if applicable) when particular engines are unavailable - eg. if  * a hardware accelerator is not attached or not functioning correctly. Each  * ENGINE has 2 reference counts; structural and functional. Every time a  * functional reference is obtained or released, a corresponding structural  * reference is automatically obtained or released too.  */
comment|/*  * Initialise a engine type for use (or up its reference count if it's  * already in use). This will fail if the engine is not currently operational  * and cannot initialise.  */
name|int
name|ENGINE_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
comment|/*  * Free a functional reference to a engine type. This does not require a  * corresponding call to ENGINE_free as it also releases a structural  * reference.  */
name|int
name|ENGINE_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
comment|/*  * The following functions handle keys that are stored in some secondary  * location, handled by the engine.  The storage may be on a card or  * whatever.  */
name|EVP_PKEY
modifier|*
name|ENGINE_load_private_key
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
function_decl|;
name|EVP_PKEY
modifier|*
name|ENGINE_load_public_key
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
function_decl|;
name|int
name|ENGINE_load_ssl_client_cert
argument_list|(
name|ENGINE
operator|*
name|e
argument_list|,
name|SSL
operator|*
name|s
argument_list|,
name|STACK_OF
argument_list|(
name|X509_NAME
argument_list|)
operator|*
name|ca_dn
argument_list|,
name|X509
operator|*
operator|*
name|pcert
argument_list|,
name|EVP_PKEY
operator|*
operator|*
name|ppkey
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
operator|*
name|pother
argument_list|,
name|UI_METHOD
operator|*
name|ui_method
argument_list|,
name|void
operator|*
name|callback_data
argument_list|)
decl_stmt|;
comment|/*  * This returns a pointer for the current ENGINE structure that is (by  * default) performing any RSA operations. The value returned is an  * incremented reference, so it should be free'd (ENGINE_finish) before it is  * discarded.  */
name|ENGINE
modifier|*
name|ENGINE_get_default_RSA
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Same for the other "methods" */
name|ENGINE
modifier|*
name|ENGINE_get_default_DSA
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_default_ECDH
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_default_ECDSA
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_default_DH
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_default_RAND
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*  * These functions can be used to get a functional reference to perform  * ciphering or digesting corresponding to "nid".  */
name|ENGINE
modifier|*
name|ENGINE_get_cipher_engine
parameter_list|(
name|int
name|nid
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_digest_engine
parameter_list|(
name|int
name|nid
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_pkey_meth_engine
parameter_list|(
name|int
name|nid
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_pkey_asn1_meth_engine
parameter_list|(
name|int
name|nid
parameter_list|)
function_decl|;
comment|/*  * This sets a new default ENGINE structure for performing RSA operations. If  * the result is non-zero (success) then the ENGINE structure will have had  * its reference count up'd so the caller should still free their own  * reference 'e'.  */
name|int
name|ENGINE_set_default_RSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_string
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|def_list
parameter_list|)
function_decl|;
comment|/* Same for the other "methods" */
name|int
name|ENGINE_set_default_DSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_ECDH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_ECDSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_DH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_RAND
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_ciphers
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_digests
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_pkey_meths
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_pkey_asn1_meths
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
comment|/*  * The combination "set" - the flags are bitwise "OR"d from the  * ENGINE_METHOD_*** defines above. As with the "ENGINE_register_complete()"  * function, this function can result in unnecessary static linkage. If your  * application requires only specific functionality, consider using more  * selective functions.  */
name|int
name|ENGINE_set_default
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
function_decl|;
name|void
name|ENGINE_add_conf_module
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Deprecated functions ... */
comment|/* int ENGINE_clear_defaults(void); */
comment|/**************************/
comment|/* DYNAMIC ENGINE SUPPORT */
comment|/**************************/
comment|/* Binary/behaviour compatibility levels */
define|#
directive|define
name|OSSL_DYNAMIC_VERSION
value|(unsigned long)0x00020000
comment|/*  * Binary versions older than this are too old for us (whether we're a loader  * or a loadee)  */
define|#
directive|define
name|OSSL_DYNAMIC_OLDEST
value|(unsigned long)0x00020000
comment|/*  * When compiling an ENGINE entirely as an external shared library, loadable  * by the "dynamic" ENGINE, these types are needed. The 'dynamic_fns'  * structure type provides the calling application's (or library's) error  * functionality and memory management function pointers to the loaded  * library. These should be used/set in the loaded library code so that the  * loading application's 'state' will be used/changed in all operations. The  * 'static_state' pointer allows the loaded library to know if it shares the  * same static data as the calling application (or library), and thus whether  * these callbacks need to be set or not.  */
typedef|typedef
name|void
modifier|*
function_decl|(
modifier|*
name|dyn_MEM_malloc_cb
function_decl|)
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
typedef|typedef
name|void
modifier|*
function_decl|(
modifier|*
name|dyn_MEM_realloc_cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|dyn_MEM_free_cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|st_dynamic_MEM_fns
block|{
name|dyn_MEM_malloc_cb
name|malloc_cb
decl_stmt|;
name|dyn_MEM_realloc_cb
name|realloc_cb
decl_stmt|;
name|dyn_MEM_free_cb
name|free_cb
decl_stmt|;
block|}
name|dynamic_MEM_fns
typedef|;
comment|/*  * FIXME: Perhaps the memory and locking code (crypto.h) should declare and  * use these types so we (and any other dependant code) can simplify a bit??  */
typedef|typedef
name|void
function_decl|(
modifier|*
name|dyn_lock_locking_cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|dyn_lock_add_lock_cb
function_decl|)
parameter_list|(
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|struct
name|CRYPTO_dynlock_value
modifier|*
function_decl|(
modifier|*
name|dyn_dynlock_create_cb
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|dyn_dynlock_lock_cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|struct
name|CRYPTO_dynlock_value
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|dyn_dynlock_destroy_cb
function_decl|)
parameter_list|(
name|struct
name|CRYPTO_dynlock_value
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|st_dynamic_LOCK_fns
block|{
name|dyn_lock_locking_cb
name|lock_locking_cb
decl_stmt|;
name|dyn_lock_add_lock_cb
name|lock_add_lock_cb
decl_stmt|;
name|dyn_dynlock_create_cb
name|dynlock_create_cb
decl_stmt|;
name|dyn_dynlock_lock_cb
name|dynlock_lock_cb
decl_stmt|;
name|dyn_dynlock_destroy_cb
name|dynlock_destroy_cb
decl_stmt|;
block|}
name|dynamic_LOCK_fns
typedef|;
comment|/* The top-level structure */
typedef|typedef
struct|struct
name|st_dynamic_fns
block|{
name|void
modifier|*
name|static_state
decl_stmt|;
specifier|const
name|ERR_FNS
modifier|*
name|err_fns
decl_stmt|;
specifier|const
name|CRYPTO_EX_DATA_IMPL
modifier|*
name|ex_data_fns
decl_stmt|;
name|dynamic_MEM_fns
name|mem_fns
decl_stmt|;
name|dynamic_LOCK_fns
name|lock_fns
decl_stmt|;
block|}
name|dynamic_fns
typedef|;
comment|/*  * The version checking function should be of this prototype. NB: The  * ossl_version value passed in is the OSSL_DYNAMIC_VERSION of the loading  * code. If this function returns zero, it indicates a (potential) version  * incompatibility and the loaded library doesn't believe it can proceed.  * Otherwise, the returned value is the (latest) version supported by the  * loading library. The loader may still decide that the loaded code's  * version is unsatisfactory and could veto the load. The function is  * expected to be implemented with the symbol name "v_check", and a default  * implementation can be fully instantiated with  * IMPLEMENT_DYNAMIC_CHECK_FN().  */
typedef|typedef
name|unsigned
name|long
function_decl|(
modifier|*
name|dynamic_v_check_fn
function_decl|)
parameter_list|(
name|unsigned
name|long
name|ossl_version
parameter_list|)
function_decl|;
define|#
directive|define
name|IMPLEMENT_DYNAMIC_CHECK_FN
parameter_list|()
define|\
value|OPENSSL_EXPORT unsigned long v_check(unsigned long v); \         OPENSSL_EXPORT unsigned long v_check(unsigned long v) { \                 if(v>= OSSL_DYNAMIC_OLDEST) return OSSL_DYNAMIC_VERSION; \                 return 0; }
comment|/*  * This function is passed the ENGINE structure to initialise with its own  * function and command settings. It should not adjust the structural or  * functional reference counts. If this function returns zero, (a) the load  * will be aborted, (b) the previous ENGINE state will be memcpy'd back onto  * the structure, and (c) the shared library will be unloaded. So  * implementations should do their own internal cleanup in failure  * circumstances otherwise they could leak. The 'id' parameter, if non-NULL,  * represents the ENGINE id that the loader is looking for. If this is NULL,  * the shared library can choose to return failure or to initialise a  * 'default' ENGINE. If non-NULL, the shared library must initialise only an  * ENGINE matching the passed 'id'. The function is expected to be  * implemented with the symbol name "bind_engine". A standard implementation  * can be instantiated with IMPLEMENT_DYNAMIC_BIND_FN(fn) where the parameter  * 'fn' is a callback function that populates the ENGINE structure and  * returns an int value (zero for failure). 'fn' should have prototype;  * [static] int fn(ENGINE *e, const char *id);  */
typedef|typedef
name|int
function_decl|(
modifier|*
name|dynamic_bind_engine
function_decl|)
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|,
specifier|const
name|dynamic_fns
modifier|*
name|fns
parameter_list|)
function_decl|;
define|#
directive|define
name|IMPLEMENT_DYNAMIC_BIND_FN
parameter_list|(
name|fn
parameter_list|)
define|\
value|OPENSSL_EXPORT \         int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns); \         OPENSSL_EXPORT \         int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns) { \                 if(ENGINE_get_static_state() == fns->static_state) goto skip_cbs; \                 if(!CRYPTO_set_mem_functions(fns->mem_fns.malloc_cb, \                         fns->mem_fns.realloc_cb, fns->mem_fns.free_cb)) \                         return 0; \                 CRYPTO_set_locking_callback(fns->lock_fns.lock_locking_cb); \                 CRYPTO_set_add_lock_callback(fns->lock_fns.lock_add_lock_cb); \                 CRYPTO_set_dynlock_create_callback(fns->lock_fns.dynlock_create_cb); \                 CRYPTO_set_dynlock_lock_callback(fns->lock_fns.dynlock_lock_cb); \                 CRYPTO_set_dynlock_destroy_callback(fns->lock_fns.dynlock_destroy_cb); \                 if(!CRYPTO_set_ex_data_implementation(fns->ex_data_fns)) \                         return 0; \                 if(!ERR_set_implementation(fns->err_fns)) return 0; \         skip_cbs: \                 if(!fn(e,id)) return 0; \                 return 1; }
comment|/*  * If the loading application (or library) and the loaded ENGINE library  * share the same static data (eg. they're both dynamically linked to the  * same libcrypto.so) we need a way to avoid trying to set system callbacks -  * this would fail, and for the same reason that it's unnecessary to try. If  * the loaded ENGINE has (or gets from through the loader) its own copy of  * the libcrypto static data, we will need to set the callbacks. The easiest  * way to detect this is to have a function that returns a pointer to some  * static data and let the loading application and loaded ENGINE compare  * their respective values.  */
name|void
modifier|*
name|ENGINE_get_static_state
parameter_list|(
name|void
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_CRYPTODEV
argument_list|)
name|void
name|ENGINE_setup_bsd_cryptodev
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* BEGIN ERROR CODES */
comment|/*  * The following lines are auto generated by the script mkerr.pl. Any changes  * made after this point may be overwritten when the script is next run.  */
name|void
name|ERR_load_ENGINE_strings
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Error codes for the ENGINE functions. */
comment|/* Function codes. */
define|#
directive|define
name|ENGINE_F_DYNAMIC_CTRL
value|180
define|#
directive|define
name|ENGINE_F_DYNAMIC_GET_DATA_CTX
value|181
define|#
directive|define
name|ENGINE_F_DYNAMIC_LOAD
value|182
define|#
directive|define
name|ENGINE_F_DYNAMIC_SET_DATA_CTX
value|183
define|#
directive|define
name|ENGINE_F_ENGINE_ADD
value|105
define|#
directive|define
name|ENGINE_F_ENGINE_BY_ID
value|106
define|#
directive|define
name|ENGINE_F_ENGINE_CMD_IS_EXECUTABLE
value|170
define|#
directive|define
name|ENGINE_F_ENGINE_CTRL
value|142
define|#
directive|define
name|ENGINE_F_ENGINE_CTRL_CMD
value|178
define|#
directive|define
name|ENGINE_F_ENGINE_CTRL_CMD_STRING
value|171
define|#
directive|define
name|ENGINE_F_ENGINE_FINISH
value|107
define|#
directive|define
name|ENGINE_F_ENGINE_FREE_UTIL
value|108
define|#
directive|define
name|ENGINE_F_ENGINE_GET_CIPHER
value|185
define|#
directive|define
name|ENGINE_F_ENGINE_GET_DEFAULT_TYPE
value|177
define|#
directive|define
name|ENGINE_F_ENGINE_GET_DIGEST
value|186
define|#
directive|define
name|ENGINE_F_ENGINE_GET_NEXT
value|115
define|#
directive|define
name|ENGINE_F_ENGINE_GET_PKEY_ASN1_METH
value|193
define|#
directive|define
name|ENGINE_F_ENGINE_GET_PKEY_METH
value|192
define|#
directive|define
name|ENGINE_F_ENGINE_GET_PREV
value|116
define|#
directive|define
name|ENGINE_F_ENGINE_INIT
value|119
define|#
directive|define
name|ENGINE_F_ENGINE_LIST_ADD
value|120
define|#
directive|define
name|ENGINE_F_ENGINE_LIST_REMOVE
value|121
define|#
directive|define
name|ENGINE_F_ENGINE_LOAD_PRIVATE_KEY
value|150
define|#
directive|define
name|ENGINE_F_ENGINE_LOAD_PUBLIC_KEY
value|151
define|#
directive|define
name|ENGINE_F_ENGINE_LOAD_SSL_CLIENT_CERT
value|194
define|#
directive|define
name|ENGINE_F_ENGINE_NEW
value|122
define|#
directive|define
name|ENGINE_F_ENGINE_REMOVE
value|123
define|#
directive|define
name|ENGINE_F_ENGINE_SET_DEFAULT_STRING
value|189
define|#
directive|define
name|ENGINE_F_ENGINE_SET_DEFAULT_TYPE
value|126
define|#
directive|define
name|ENGINE_F_ENGINE_SET_ID
value|129
define|#
directive|define
name|ENGINE_F_ENGINE_SET_NAME
value|130
define|#
directive|define
name|ENGINE_F_ENGINE_TABLE_REGISTER
value|184
define|#
directive|define
name|ENGINE_F_ENGINE_UNLOAD_KEY
value|152
define|#
directive|define
name|ENGINE_F_ENGINE_UNLOCKED_FINISH
value|191
define|#
directive|define
name|ENGINE_F_ENGINE_UP_REF
value|190
define|#
directive|define
name|ENGINE_F_INT_CTRL_HELPER
value|172
define|#
directive|define
name|ENGINE_F_INT_ENGINE_CONFIGURE
value|188
define|#
directive|define
name|ENGINE_F_INT_ENGINE_MODULE_INIT
value|187
define|#
directive|define
name|ENGINE_F_LOG_MESSAGE
value|141
comment|/* Reason codes. */
define|#
directive|define
name|ENGINE_R_ALREADY_LOADED
value|100
define|#
directive|define
name|ENGINE_R_ARGUMENT_IS_NOT_A_NUMBER
value|133
define|#
directive|define
name|ENGINE_R_CMD_NOT_EXECUTABLE
value|134
define|#
directive|define
name|ENGINE_R_COMMAND_TAKES_INPUT
value|135
define|#
directive|define
name|ENGINE_R_COMMAND_TAKES_NO_INPUT
value|136
define|#
directive|define
name|ENGINE_R_CONFLICTING_ENGINE_ID
value|103
define|#
directive|define
name|ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED
value|119
define|#
directive|define
name|ENGINE_R_DH_NOT_IMPLEMENTED
value|139
define|#
directive|define
name|ENGINE_R_DSA_NOT_IMPLEMENTED
value|140
define|#
directive|define
name|ENGINE_R_DSO_FAILURE
value|104
define|#
directive|define
name|ENGINE_R_DSO_NOT_FOUND
value|132
define|#
directive|define
name|ENGINE_R_ENGINES_SECTION_ERROR
value|148
define|#
directive|define
name|ENGINE_R_ENGINE_CONFIGURATION_ERROR
value|102
define|#
directive|define
name|ENGINE_R_ENGINE_IS_NOT_IN_LIST
value|105
define|#
directive|define
name|ENGINE_R_ENGINE_SECTION_ERROR
value|149
define|#
directive|define
name|ENGINE_R_FAILED_LOADING_PRIVATE_KEY
value|128
define|#
directive|define
name|ENGINE_R_FAILED_LOADING_PUBLIC_KEY
value|129
define|#
directive|define
name|ENGINE_R_FINISH_FAILED
value|106
define|#
directive|define
name|ENGINE_R_GET_HANDLE_FAILED
value|107
define|#
directive|define
name|ENGINE_R_ID_OR_NAME_MISSING
value|108
define|#
directive|define
name|ENGINE_R_INIT_FAILED
value|109
define|#
directive|define
name|ENGINE_R_INTERNAL_LIST_ERROR
value|110
define|#
directive|define
name|ENGINE_R_INVALID_ARGUMENT
value|143
define|#
directive|define
name|ENGINE_R_INVALID_CMD_NAME
value|137
define|#
directive|define
name|ENGINE_R_INVALID_CMD_NUMBER
value|138
define|#
directive|define
name|ENGINE_R_INVALID_INIT_VALUE
value|151
define|#
directive|define
name|ENGINE_R_INVALID_STRING
value|150
define|#
directive|define
name|ENGINE_R_NOT_INITIALISED
value|117
define|#
directive|define
name|ENGINE_R_NOT_LOADED
value|112
define|#
directive|define
name|ENGINE_R_NO_CONTROL_FUNCTION
value|120
define|#
directive|define
name|ENGINE_R_NO_INDEX
value|144
define|#
directive|define
name|ENGINE_R_NO_LOAD_FUNCTION
value|125
define|#
directive|define
name|ENGINE_R_NO_REFERENCE
value|130
define|#
directive|define
name|ENGINE_R_NO_SUCH_ENGINE
value|116
define|#
directive|define
name|ENGINE_R_NO_UNLOAD_FUNCTION
value|126
define|#
directive|define
name|ENGINE_R_PROVIDE_PARAMETERS
value|113
define|#
directive|define
name|ENGINE_R_RSA_NOT_IMPLEMENTED
value|141
define|#
directive|define
name|ENGINE_R_UNIMPLEMENTED_CIPHER
value|146
define|#
directive|define
name|ENGINE_R_UNIMPLEMENTED_DIGEST
value|147
define|#
directive|define
name|ENGINE_R_UNIMPLEMENTED_PUBLIC_KEY_METHOD
value|101
define|#
directive|define
name|ENGINE_R_VERSION_INCOMPATIBILITY
value|145
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

