begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* openssl/engine.h */
end_comment

begin_comment
comment|/* Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL  * project 2000.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1999-2004 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.  * ECDH support in OpenSSL originally developed by   * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HEADER_ENGINE_H
end_ifndef

begin_define
define|#
directive|define
name|HEADER_ENGINE_H
end_define

begin_include
include|#
directive|include
file|<openssl/opensslconf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_NO_ENGINE
end_ifdef

begin_error
error|#
directive|error
error|ENGINE is disabled.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DEPRECATED
end_ifndef

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_include
include|#
directive|include
file|<openssl/rsa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
end_ifndef

begin_include
include|#
directive|include
file|<openssl/dsa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_include
include|#
directive|include
file|<openssl/dh.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDH
end_ifndef

begin_include
include|#
directive|include
file|<openssl/ecdh.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDSA
end_ifndef

begin_include
include|#
directive|include
file|<openssl/ecdsa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/store.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ui.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/x509.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ossl_typ.h>
end_include

begin_include
include|#
directive|include
file|<openssl/symhacks.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* These flags are used to control combinations of algorithm (methods)  * by bitwise "OR"ing. */
define|#
directive|define
name|ENGINE_METHOD_RSA
value|(unsigned int)0x0001
define|#
directive|define
name|ENGINE_METHOD_DSA
value|(unsigned int)0x0002
define|#
directive|define
name|ENGINE_METHOD_DH
value|(unsigned int)0x0004
define|#
directive|define
name|ENGINE_METHOD_RAND
value|(unsigned int)0x0008
define|#
directive|define
name|ENGINE_METHOD_ECDH
value|(unsigned int)0x0010
define|#
directive|define
name|ENGINE_METHOD_ECDSA
value|(unsigned int)0x0020
define|#
directive|define
name|ENGINE_METHOD_CIPHERS
value|(unsigned int)0x0040
define|#
directive|define
name|ENGINE_METHOD_DIGESTS
value|(unsigned int)0x0080
define|#
directive|define
name|ENGINE_METHOD_STORE
value|(unsigned int)0x0100
comment|/* Obvious all-or-nothing cases. */
define|#
directive|define
name|ENGINE_METHOD_ALL
value|(unsigned int)0xFFFF
define|#
directive|define
name|ENGINE_METHOD_NONE
value|(unsigned int)0x0000
comment|/* This(ese) flag(s) controls behaviour of the ENGINE_TABLE mechanism used  * internally to control registration of ENGINE implementations, and can be set  * by ENGINE_set_table_flags(). The "NOINIT" flag prevents attempts to  * initialise registered ENGINEs if they are not already initialised. */
define|#
directive|define
name|ENGINE_TABLE_FLAG_NOINIT
value|(unsigned int)0x0001
comment|/* ENGINE flags that can be set by ENGINE_set_flags(). */
comment|/* #define ENGINE_FLAGS_MALLOCED	0x0001 */
comment|/* Not used */
comment|/* This flag is for ENGINEs that wish to handle the various 'CMD'-related  * control commands on their own. Without this flag, ENGINE_ctrl() handles these  * control commands on behalf of the ENGINE using their "cmd_defns" data. */
define|#
directive|define
name|ENGINE_FLAGS_MANUAL_CMD_CTRL
value|(int)0x0002
comment|/* This flag is for ENGINEs who return new duplicate structures when found via  * "ENGINE_by_id()". When an ENGINE must store state (eg. if ENGINE_ctrl()  * commands are called in sequence as part of some stateful process like  * key-generation setup and execution), it can set this flag - then each attempt  * to obtain the ENGINE will result in it being copied into a new structure.  * Normally, ENGINEs don't declare this flag so ENGINE_by_id() just increments  * the existing ENGINE's structural reference count. */
define|#
directive|define
name|ENGINE_FLAGS_BY_ID_COPY
value|(int)0x0004
comment|/* ENGINEs can support their own command types, and these flags are used in  * ENGINE_CTRL_GET_CMD_FLAGS to indicate to the caller what kind of input each  * command expects. Currently only numeric and string input is supported. If a  * control command supports none of the _NUMERIC, _STRING, or _NO_INPUT options,  * then it is regarded as an "internal" control command - and not for use in  * config setting situations. As such, they're not available to the  * ENGINE_ctrl_cmd_string() function, only raw ENGINE_ctrl() access. Changes to  * this list of 'command types' should be reflected carefully in  * ENGINE_cmd_is_executable() and ENGINE_ctrl_cmd_string(). */
comment|/* accepts a 'long' input value (3rd parameter to ENGINE_ctrl) */
define|#
directive|define
name|ENGINE_CMD_FLAG_NUMERIC
value|(unsigned int)0x0001
comment|/* accepts string input (cast from 'void*' to 'const char *', 4th parameter to  * ENGINE_ctrl) */
define|#
directive|define
name|ENGINE_CMD_FLAG_STRING
value|(unsigned int)0x0002
comment|/* Indicates that the control command takes *no* input. Ie. the control command  * is unparameterised. */
define|#
directive|define
name|ENGINE_CMD_FLAG_NO_INPUT
value|(unsigned int)0x0004
comment|/* Indicates that the control command is internal. This control command won't  * be shown in any output, and is only usable through the ENGINE_ctrl_cmd()  * function. */
define|#
directive|define
name|ENGINE_CMD_FLAG_INTERNAL
value|(unsigned int)0x0008
comment|/* NB: These 3 control commands are deprecated and should not be used. ENGINEs  * relying on these commands should compile conditional support for  * compatibility (eg. if these symbols are defined) but should also migrate the  * same functionality to their own ENGINE-specific control functions that can be  * "discovered" by calling applications. The fact these control commands  * wouldn't be "executable" (ie. usable by text-based config) doesn't change the  * fact that application code can find and use them without requiring per-ENGINE  * hacking. */
comment|/* These flags are used to tell the ctrl function what should be done.  * All command numbers are shared between all engines, even if some don't  * make sense to some engines.  In such a case, they do nothing but return  * the error ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED. */
define|#
directive|define
name|ENGINE_CTRL_SET_LOGSTREAM
value|1
define|#
directive|define
name|ENGINE_CTRL_SET_PASSWORD_CALLBACK
value|2
define|#
directive|define
name|ENGINE_CTRL_HUP
value|3
comment|/* Close and reinitialise any 						     handles/connections etc. */
define|#
directive|define
name|ENGINE_CTRL_SET_USER_INTERFACE
value|4
comment|/* Alternative to callback */
define|#
directive|define
name|ENGINE_CTRL_SET_CALLBACK_DATA
value|5
comment|/* User-specific data, used 						     when calling the password 						     callback and the user 						     interface */
define|#
directive|define
name|ENGINE_CTRL_LOAD_CONFIGURATION
value|6
comment|/* Load a configuration, given 						     a string that represents a 						     file name or so */
define|#
directive|define
name|ENGINE_CTRL_LOAD_SECTION
value|7
comment|/* Load data from a given 						     section in the already loaded 						     configuration */
comment|/* These control commands allow an application to deal with an arbitrary engine  * in a dynamic way. Warn: Negative return values indicate errors FOR THESE  * COMMANDS because zero is used to indicate 'end-of-list'. Other commands,  * including ENGINE-specific command types, return zero for an error.  *  * An ENGINE can choose to implement these ctrl functions, and can internally  * manage things however it chooses - it does so by setting the  * ENGINE_FLAGS_MANUAL_CMD_CTRL flag (using ENGINE_set_flags()). Otherwise the  * ENGINE_ctrl() code handles this on the ENGINE's behalf using the cmd_defns  * data (set using ENGINE_set_cmd_defns()). This means an ENGINE's ctrl()  * handler need only implement its own commands - the above "meta" commands will  * be taken care of. */
comment|/* Returns non-zero if the supplied ENGINE has a ctrl() handler. If "not", then  * all the remaining control commands will return failure, so it is worth  * checking this first if the caller is trying to "discover" the engine's  * capabilities and doesn't want errors generated unnecessarily. */
define|#
directive|define
name|ENGINE_CTRL_HAS_CTRL_FUNCTION
value|10
comment|/* Returns a positive command number for the first command supported by the  * engine. Returns zero if no ctrl commands are supported. */
define|#
directive|define
name|ENGINE_CTRL_GET_FIRST_CMD_TYPE
value|11
comment|/* The 'long' argument specifies a command implemented by the engine, and the  * return value is the next command supported, or zero if there are no more. */
define|#
directive|define
name|ENGINE_CTRL_GET_NEXT_CMD_TYPE
value|12
comment|/* The 'void*' argument is a command name (cast from 'const char *'), and the  * return value is the command that corresponds to it. */
define|#
directive|define
name|ENGINE_CTRL_GET_CMD_FROM_NAME
value|13
comment|/* The next two allow a command to be converted into its corresponding string  * form. In each case, the 'long' argument supplies the command. In the NAME_LEN  * case, the return value is the length of the command name (not counting a  * trailing EOL). In the NAME case, the 'void*' argument must be a string buffer  * large enough, and it will be populated with the name of the command (WITH a  * trailing EOL). */
define|#
directive|define
name|ENGINE_CTRL_GET_NAME_LEN_FROM_CMD
value|14
define|#
directive|define
name|ENGINE_CTRL_GET_NAME_FROM_CMD
value|15
comment|/* The next two are similar but give a "short description" of a command. */
define|#
directive|define
name|ENGINE_CTRL_GET_DESC_LEN_FROM_CMD
value|16
define|#
directive|define
name|ENGINE_CTRL_GET_DESC_FROM_CMD
value|17
comment|/* With this command, the return value is the OR'd combination of  * ENGINE_CMD_FLAG_*** values that indicate what kind of input a given  * engine-specific ctrl command expects. */
define|#
directive|define
name|ENGINE_CTRL_GET_CMD_FLAGS
value|18
comment|/* ENGINE implementations should start the numbering of their own control  * commands from this value. (ie. ENGINE_CMD_BASE, ENGINE_CMD_BASE + 1, etc). */
define|#
directive|define
name|ENGINE_CMD_BASE
value|200
comment|/* NB: These 2 nCipher "chil" control commands are deprecated, and their  * functionality is now available through ENGINE-specific control commands  * (exposed through the above-mentioned 'CMD'-handling). Code using these 2  * commands should be migrated to the more general command handling before these  * are removed. */
comment|/* Flags specific to the nCipher "chil" engine */
define|#
directive|define
name|ENGINE_CTRL_CHIL_SET_FORKCHECK
value|100
comment|/* Depending on the value of the (long)i argument, this sets or 	 * unsets the SimpleForkCheck flag in the CHIL API to enable or 	 * disable checking and workarounds for applications that fork(). 	 */
define|#
directive|define
name|ENGINE_CTRL_CHIL_NO_LOCKING
value|101
comment|/* This prevents the initialisation function from providing mutex 	 * callbacks to the nCipher library. */
comment|/* If an ENGINE supports its own specific control commands and wishes the  * framework to handle the above 'ENGINE_CMD_***'-manipulation commands on its  * behalf, it should supply a null-terminated array of ENGINE_CMD_DEFN entries  * to ENGINE_set_cmd_defns(). It should also implement a ctrl() handler that  * supports the stated commands (ie. the "cmd_num" entries as described by the  * array). NB: The array must be ordered in increasing order of cmd_num.  * "null-terminated" means that the last ENGINE_CMD_DEFN element has cmd_num set  * to zero and/or cmd_name set to NULL. */
typedef|typedef
struct|struct
name|ENGINE_CMD_DEFN_st
block|{
name|unsigned
name|int
name|cmd_num
decl_stmt|;
comment|/* The command number */
specifier|const
name|char
modifier|*
name|cmd_name
decl_stmt|;
comment|/* The command name itself */
specifier|const
name|char
modifier|*
name|cmd_desc
decl_stmt|;
comment|/* A short description of the command */
name|unsigned
name|int
name|cmd_flags
decl_stmt|;
comment|/* The input the command expects */
block|}
name|ENGINE_CMD_DEFN
typedef|;
comment|/* Generic function pointer */
typedef|typedef
name|int
function_decl|(
modifier|*
name|ENGINE_GEN_FUNC_PTR
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Generic function pointer taking no arguments */
typedef|typedef
name|int
function_decl|(
modifier|*
name|ENGINE_GEN_INT_FUNC_PTR
function_decl|)
parameter_list|(
name|ENGINE
modifier|*
parameter_list|)
function_decl|;
comment|/* Specific control function pointer */
typedef|typedef
name|int
function_decl|(
modifier|*
name|ENGINE_CTRL_FUNC_PTR
function_decl|)
parameter_list|(
name|ENGINE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|long
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
function_decl|;
comment|/* Generic load_key function pointer */
typedef|typedef
name|EVP_PKEY
modifier|*
function_decl|(
modifier|*
name|ENGINE_LOAD_KEY_PTR
function_decl|)
parameter_list|(
name|ENGINE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
function_decl|;
typedef|typedef
name|int
argument_list|(
operator|*
name|ENGINE_SSL_CLIENT_CERT_PTR
argument_list|)
argument_list|(
name|ENGINE
operator|*
argument_list|,
name|SSL
operator|*
name|ssl
argument_list|,
name|STACK_OF
argument_list|(
name|X509_NAME
argument_list|)
operator|*
name|ca_dn
argument_list|,
name|X509
operator|*
operator|*
name|pcert
argument_list|,
name|EVP_PKEY
operator|*
operator|*
name|pkey
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
operator|*
name|pother
argument_list|,
name|UI_METHOD
operator|*
name|ui_method
argument_list|,
name|void
operator|*
name|callback_data
argument_list|)
expr_stmt|;
comment|/* These callback types are for an ENGINE's handler for cipher and digest logic.  * These handlers have these prototypes;  *   int foo(ENGINE *e, const EVP_CIPHER **cipher, const int **nids, int nid);  *   int foo(ENGINE *e, const EVP_MD **digest, const int **nids, int nid);  * Looking at how to implement these handlers in the case of cipher support, if  * the framework wants the EVP_CIPHER for 'nid', it will call;  *   foo(e,&p_evp_cipher, NULL, nid);    (return zero for failure)  * If the framework wants a list of supported 'nid's, it will call;  *   foo(e, NULL,&p_nids, 0); (returns number of 'nids' or -1 for error)  */
comment|/* Returns to a pointer to the array of supported cipher 'nid's. If the second  * parameter is non-NULL it is set to the size of the returned array. */
typedef|typedef
name|int
function_decl|(
modifier|*
name|ENGINE_CIPHERS_PTR
function_decl|)
parameter_list|(
name|ENGINE
modifier|*
parameter_list|,
specifier|const
name|EVP_CIPHER
modifier|*
modifier|*
parameter_list|,
specifier|const
name|int
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|ENGINE_DIGESTS_PTR
function_decl|)
parameter_list|(
name|ENGINE
modifier|*
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
modifier|*
parameter_list|,
specifier|const
name|int
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* STRUCTURE functions ... all of these functions deal with pointers to ENGINE  * structures where the pointers have a "structural reference". This means that  * their reference is to allowed access to the structure but it does not imply  * that the structure is functional. To simply increment or decrement the  * structural reference count, use ENGINE_by_id and ENGINE_free. NB: This is not  * required when iterating using ENGINE_get_next as it will automatically  * decrement the structural reference count of the "current" ENGINE and  * increment the structural reference count of the ENGINE it returns (unless it  * is NULL). */
comment|/* Get the first/last "ENGINE" type available. */
name|ENGINE
modifier|*
name|ENGINE_get_first
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_last
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Iterate to the next/previous "ENGINE" type (NULL = end of the list). */
name|ENGINE
modifier|*
name|ENGINE_get_next
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_prev
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
comment|/* Add another "ENGINE" type into the array. */
name|int
name|ENGINE_add
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
comment|/* Remove an existing "ENGINE" type from the array. */
name|int
name|ENGINE_remove
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
comment|/* Retrieve an engine from the list by its unique "id" value. */
name|ENGINE
modifier|*
name|ENGINE_by_id
parameter_list|(
specifier|const
name|char
modifier|*
name|id
parameter_list|)
function_decl|;
comment|/* Add all the built-in engines. */
name|void
name|ENGINE_load_openssl
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_dynamic
parameter_list|(
name|void
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_STATIC_ENGINE
name|void
name|ENGINE_load_4758cca
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_aep
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_atalla
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_chil
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_cswift
parameter_list|(
name|void
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_GMP
name|void
name|ENGINE_load_gmp
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
name|void
name|ENGINE_load_nuron
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_sureware
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_ubsec
parameter_list|(
name|void
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|OPENSSL_SYS_WIN32
ifndef|#
directive|ifndef
name|OPENSSL_NO_CAPIENG
name|void
name|ENGINE_load_capi
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
name|void
name|ENGINE_load_cryptodev
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_padlock
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_load_builtin_engines
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Get and set global flags (ENGINE_TABLE_FLAG_***) for the implementation  * "registry" handling. */
name|unsigned
name|int
name|ENGINE_get_table_flags
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ENGINE_set_table_flags
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|)
function_decl|;
comment|/* Manage registration of ENGINEs per "table". For each type, there are 3  * functions;  *   ENGINE_register_***(e) - registers the implementation from 'e' (if it has one)  *   ENGINE_unregister_***(e) - unregister the implementation from 'e'  *   ENGINE_register_all_***() - call ENGINE_register_***() for each 'e' in the list  * Cleanup is automatically registered from each table when required, so  * ENGINE_cleanup() will reverse any "register" operations. */
name|int
name|ENGINE_register_RSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_RSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_RSA
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_DSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_DSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_DSA
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_ECDH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_ECDH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_ECDH
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_ECDSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_ECDSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_ECDSA
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_DH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_DH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_DH
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_RAND
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_RAND
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_RAND
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_STORE
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_STORE
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_STORE
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_ciphers
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_ciphers
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_ciphers
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_digests
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_unregister_digests
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|void
name|ENGINE_register_all_digests
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* These functions register all support from the above categories. Note, use of  * these functions can result in static linkage of code your application may not  * need. If you only need a subset of functionality, consider using more  * selective initialisation. */
name|int
name|ENGINE_register_complete
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_register_all_complete
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Send parametrised control commands to the engine. The possibilities to send  * down an integer, a pointer to data or a function pointer are provided. Any of  * the parameters may or may not be NULL, depending on the command number. In  * actuality, this function only requires a structural (rather than functional)  * reference to an engine, but many control commands may require the engine be  * functional. The caller should be aware of trying commands that require an  * operational ENGINE, and only use functional references in such situations. */
name|int
name|ENGINE_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
function_decl|;
comment|/* This function tests if an ENGINE-specific command is usable as a "setting".  * Eg. in an application's config file that gets processed through  * ENGINE_ctrl_cmd_string(). If this returns zero, it is not available to  * ENGINE_ctrl_cmd_string(), only ENGINE_ctrl(). */
name|int
name|ENGINE_cmd_is_executable
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|)
function_decl|;
comment|/* This function works like ENGINE_ctrl() with the exception of taking a  * command name instead of a command number, and can handle optional commands.  * See the comment on ENGINE_ctrl_cmd_string() for an explanation on how to  * use the cmd_name and cmd_optional. */
name|int
name|ENGINE_ctrl_cmd
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd_name
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|,
name|int
name|cmd_optional
parameter_list|)
function_decl|;
comment|/* This function passes a command-name and argument to an ENGINE. The cmd_name  * is converted to a command number and the control command is called using  * 'arg' as an argument (unless the ENGINE doesn't support such a command, in  * which case no control command is called). The command is checked for input  * flags, and if necessary the argument will be converted to a numeric value. If  * cmd_optional is non-zero, then if the ENGINE doesn't support the given  * cmd_name the return value will be success anyway. This function is intended  * for applications to use so that users (or config files) can supply  * engine-specific config data to the ENGINE at run-time to control behaviour of  * specific engines. As such, it shouldn't be used for calling ENGINE_ctrl()  * functions that return data, deal with binary data, or that are otherwise  * supposed to be used directly through ENGINE_ctrl() in application code. Any  * "return" data from an ENGINE_ctrl() operation in this function will be lost -  * the return value is interpreted as failure if the return value is zero,  * success otherwise, and this function returns a boolean value as a result. In  * other words, vendors of 'ENGINE'-enabled devices should write ENGINE  * implementations with parameterisations that work in this scheme, so that  * compliant ENGINE-based applications can work consistently with the same  * configuration for the same ENGINE-enabled devices, across applications. */
name|int
name|ENGINE_ctrl_cmd_string
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd_name
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|cmd_optional
parameter_list|)
function_decl|;
comment|/* These functions are useful for manufacturing new ENGINE structures. They  * don't address reference counting at all - one uses them to populate an ENGINE  * structure with personalised implementations of things prior to using it  * directly or adding it to the builtin ENGINE list in OpenSSL. These are also  * here so that the ENGINE structure doesn't have to be exposed and break binary  * compatibility! */
name|ENGINE
modifier|*
name|ENGINE_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ENGINE_free
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_up_ref
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_id
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_name
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_RSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|RSA_METHOD
modifier|*
name|rsa_meth
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_DSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|DSA_METHOD
modifier|*
name|dsa_meth
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_ECDH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|ECDH_METHOD
modifier|*
name|ecdh_meth
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_ECDSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|ECDSA_METHOD
modifier|*
name|ecdsa_meth
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_DH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|DH_METHOD
modifier|*
name|dh_meth
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_RAND
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|RAND_METHOD
modifier|*
name|rand_meth
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_STORE
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|STORE_METHOD
modifier|*
name|store_meth
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_destroy_function
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_GEN_INT_FUNC_PTR
name|destroy_f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_init_function
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_GEN_INT_FUNC_PTR
name|init_f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_finish_function
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_GEN_INT_FUNC_PTR
name|finish_f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_ctrl_function
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_CTRL_FUNC_PTR
name|ctrl_f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_load_privkey_function
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_LOAD_KEY_PTR
name|loadpriv_f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_load_pubkey_function
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_LOAD_KEY_PTR
name|loadpub_f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_load_ssl_client_cert_function
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_SSL_CLIENT_CERT_PTR
name|loadssl_f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_ciphers
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_CIPHERS_PTR
name|f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_digests
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|ENGINE_DIGESTS_PTR
name|f
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_flags
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_cmd_defns
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|ENGINE_CMD_DEFN
modifier|*
name|defns
parameter_list|)
function_decl|;
comment|/* These functions allow control over any per-structure ENGINE data. */
name|int
name|ENGINE_get_ex_new_index
parameter_list|(
name|long
name|argl
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|,
name|CRYPTO_EX_new
modifier|*
name|new_func
parameter_list|,
name|CRYPTO_EX_dup
modifier|*
name|dup_func
parameter_list|,
name|CRYPTO_EX_free
modifier|*
name|free_func
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_ex_data
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|idx
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
name|void
modifier|*
name|ENGINE_get_ex_data
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|idx
parameter_list|)
function_decl|;
comment|/* This function cleans up anything that needs it. Eg. the ENGINE_add() function  * automatically ensures the list cleanup function is registered to be called  * from ENGINE_cleanup(). Similarly, all ENGINE_register_*** functions ensure  * ENGINE_cleanup() will clean up after them. */
name|void
name|ENGINE_cleanup
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* These return values from within the ENGINE structure. These can be useful  * with functional references as well as structural references - it depends  * which you obtained. Using the result for functional purposes if you only  * obtained a structural reference may be problematic! */
specifier|const
name|char
modifier|*
name|ENGINE_get_id
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|ENGINE_get_name
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|RSA_METHOD
modifier|*
name|ENGINE_get_RSA
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|DSA_METHOD
modifier|*
name|ENGINE_get_DSA
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|ECDH_METHOD
modifier|*
name|ENGINE_get_ECDH
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|ECDSA_METHOD
modifier|*
name|ENGINE_get_ECDSA
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|DH_METHOD
modifier|*
name|ENGINE_get_DH
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|RAND_METHOD
modifier|*
name|ENGINE_get_RAND
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|STORE_METHOD
modifier|*
name|ENGINE_get_STORE
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_GEN_INT_FUNC_PTR
name|ENGINE_get_destroy_function
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_GEN_INT_FUNC_PTR
name|ENGINE_get_init_function
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_GEN_INT_FUNC_PTR
name|ENGINE_get_finish_function
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_CTRL_FUNC_PTR
name|ENGINE_get_ctrl_function
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_LOAD_KEY_PTR
name|ENGINE_get_load_privkey_function
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_LOAD_KEY_PTR
name|ENGINE_get_load_pubkey_function
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_SSL_CLIENT_CERT_PTR
name|ENGINE_get_ssl_client_cert_function
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_CIPHERS_PTR
name|ENGINE_get_ciphers
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|ENGINE_DIGESTS_PTR
name|ENGINE_get_digests
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
specifier|const
name|EVP_CIPHER
modifier|*
name|ENGINE_get_cipher
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|nid
parameter_list|)
function_decl|;
specifier|const
name|EVP_MD
modifier|*
name|ENGINE_get_digest
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|nid
parameter_list|)
function_decl|;
specifier|const
name|ENGINE_CMD_DEFN
modifier|*
name|ENGINE_get_cmd_defns
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_get_flags
parameter_list|(
specifier|const
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
comment|/* FUNCTIONAL functions. These functions deal with ENGINE structures  * that have (or will) be initialised for use. Broadly speaking, the  * structural functions are useful for iterating the list of available  * engine types, creating new engine types, and other "list" operations.  * These functions actually deal with ENGINEs that are to be used. As  * such these functions can fail (if applicable) when particular  * engines are unavailable - eg. if a hardware accelerator is not  * attached or not functioning correctly. Each ENGINE has 2 reference  * counts; structural and functional. Every time a functional reference  * is obtained or released, a corresponding structural reference is  * automatically obtained or released too. */
comment|/* Initialise a engine type for use (or up its reference count if it's  * already in use). This will fail if the engine is not currently  * operational and cannot initialise. */
name|int
name|ENGINE_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
comment|/* Free a functional reference to a engine type. This does not require  * a corresponding call to ENGINE_free as it also releases a structural  * reference. */
name|int
name|ENGINE_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
comment|/* The following functions handle keys that are stored in some secondary  * location, handled by the engine.  The storage may be on a card or  * whatever. */
name|EVP_PKEY
modifier|*
name|ENGINE_load_private_key
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
function_decl|;
name|EVP_PKEY
modifier|*
name|ENGINE_load_public_key
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
function_decl|;
name|int
name|ENGINE_load_ssl_client_cert
argument_list|(
name|ENGINE
operator|*
name|e
argument_list|,
name|SSL
operator|*
name|s
argument_list|,
name|STACK_OF
argument_list|(
name|X509_NAME
argument_list|)
operator|*
name|ca_dn
argument_list|,
name|X509
operator|*
operator|*
name|pcert
argument_list|,
name|EVP_PKEY
operator|*
operator|*
name|ppkey
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
operator|*
name|pother
argument_list|,
name|UI_METHOD
operator|*
name|ui_method
argument_list|,
name|void
operator|*
name|callback_data
argument_list|)
decl_stmt|;
comment|/* This returns a pointer for the current ENGINE structure that  * is (by default) performing any RSA operations. The value returned  * is an incremented reference, so it should be free'd (ENGINE_finish)  * before it is discarded. */
name|ENGINE
modifier|*
name|ENGINE_get_default_RSA
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Same for the other "methods" */
name|ENGINE
modifier|*
name|ENGINE_get_default_DSA
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_default_ECDH
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_default_ECDSA
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_default_DH
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_default_RAND
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* These functions can be used to get a functional reference to perform  * ciphering or digesting corresponding to "nid". */
name|ENGINE
modifier|*
name|ENGINE_get_cipher_engine
parameter_list|(
name|int
name|nid
parameter_list|)
function_decl|;
name|ENGINE
modifier|*
name|ENGINE_get_digest_engine
parameter_list|(
name|int
name|nid
parameter_list|)
function_decl|;
comment|/* This sets a new default ENGINE structure for performing RSA  * operations. If the result is non-zero (success) then the ENGINE  * structure will have had its reference count up'd so the caller  * should still free their own reference 'e'. */
name|int
name|ENGINE_set_default_RSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_string
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|def_list
parameter_list|)
function_decl|;
comment|/* Same for the other "methods" */
name|int
name|ENGINE_set_default_DSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_ECDH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_ECDSA
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_DH
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_RAND
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_ciphers
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
name|int
name|ENGINE_set_default_digests
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
comment|/* The combination "set" - the flags are bitwise "OR"d from the  * ENGINE_METHOD_*** defines above. As with the "ENGINE_register_complete()"  * function, this function can result in unnecessary static linkage. If your  * application requires only specific functionality, consider using more  * selective functions. */
name|int
name|ENGINE_set_default
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
function_decl|;
name|void
name|ENGINE_add_conf_module
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Deprecated functions ... */
comment|/* int ENGINE_clear_defaults(void); */
comment|/**************************/
comment|/* DYNAMIC ENGINE SUPPORT */
comment|/**************************/
comment|/* Binary/behaviour compatibility levels */
define|#
directive|define
name|OSSL_DYNAMIC_VERSION
value|(unsigned long)0x00020000
comment|/* Binary versions older than this are too old for us (whether we're a loader or  * a loadee) */
define|#
directive|define
name|OSSL_DYNAMIC_OLDEST
value|(unsigned long)0x00020000
comment|/* When compiling an ENGINE entirely as an external shared library, loadable by  * the "dynamic" ENGINE, these types are needed. The 'dynamic_fns' structure  * type provides the calling application's (or library's) error functionality  * and memory management function pointers to the loaded library. These should  * be used/set in the loaded library code so that the loading application's  * 'state' will be used/changed in all operations. The 'static_state' pointer  * allows the loaded library to know if it shares the same static data as the  * calling application (or library), and thus whether these callbacks need to be  * set or not. */
typedef|typedef
name|void
modifier|*
function_decl|(
modifier|*
name|dyn_MEM_malloc_cb
function_decl|)
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
typedef|typedef
name|void
modifier|*
function_decl|(
modifier|*
name|dyn_MEM_realloc_cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|dyn_MEM_free_cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|st_dynamic_MEM_fns
block|{
name|dyn_MEM_malloc_cb
name|malloc_cb
decl_stmt|;
name|dyn_MEM_realloc_cb
name|realloc_cb
decl_stmt|;
name|dyn_MEM_free_cb
name|free_cb
decl_stmt|;
block|}
name|dynamic_MEM_fns
typedef|;
comment|/* FIXME: Perhaps the memory and locking code (crypto.h) should declare and use  * these types so we (and any other dependant code) can simplify a bit?? */
typedef|typedef
name|void
function_decl|(
modifier|*
name|dyn_lock_locking_cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|dyn_lock_add_lock_cb
function_decl|)
parameter_list|(
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|struct
name|CRYPTO_dynlock_value
modifier|*
function_decl|(
modifier|*
name|dyn_dynlock_create_cb
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|dyn_dynlock_lock_cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|struct
name|CRYPTO_dynlock_value
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|dyn_dynlock_destroy_cb
function_decl|)
parameter_list|(
name|struct
name|CRYPTO_dynlock_value
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|st_dynamic_LOCK_fns
block|{
name|dyn_lock_locking_cb
name|lock_locking_cb
decl_stmt|;
name|dyn_lock_add_lock_cb
name|lock_add_lock_cb
decl_stmt|;
name|dyn_dynlock_create_cb
name|dynlock_create_cb
decl_stmt|;
name|dyn_dynlock_lock_cb
name|dynlock_lock_cb
decl_stmt|;
name|dyn_dynlock_destroy_cb
name|dynlock_destroy_cb
decl_stmt|;
block|}
name|dynamic_LOCK_fns
typedef|;
comment|/* The top-level structure */
typedef|typedef
struct|struct
name|st_dynamic_fns
block|{
name|void
modifier|*
name|static_state
decl_stmt|;
specifier|const
name|ERR_FNS
modifier|*
name|err_fns
decl_stmt|;
specifier|const
name|CRYPTO_EX_DATA_IMPL
modifier|*
name|ex_data_fns
decl_stmt|;
name|dynamic_MEM_fns
name|mem_fns
decl_stmt|;
name|dynamic_LOCK_fns
name|lock_fns
decl_stmt|;
block|}
name|dynamic_fns
typedef|;
comment|/* The version checking function should be of this prototype. NB: The  * ossl_version value passed in is the OSSL_DYNAMIC_VERSION of the loading code.  * If this function returns zero, it indicates a (potential) version  * incompatibility and the loaded library doesn't believe it can proceed.  * Otherwise, the returned value is the (latest) version supported by the  * loading library. The loader may still decide that the loaded code's version  * is unsatisfactory and could veto the load. The function is expected to  * be implemented with the symbol name "v_check", and a default implementation  * can be fully instantiated with IMPLEMENT_DYNAMIC_CHECK_FN(). */
typedef|typedef
name|unsigned
name|long
function_decl|(
modifier|*
name|dynamic_v_check_fn
function_decl|)
parameter_list|(
name|unsigned
name|long
name|ossl_version
parameter_list|)
function_decl|;
define|#
directive|define
name|IMPLEMENT_DYNAMIC_CHECK_FN
parameter_list|()
define|\
value|OPENSSL_EXPORT unsigned long v_check(unsigned long v) { \ 		if(v>= OSSL_DYNAMIC_OLDEST) return OSSL_DYNAMIC_VERSION; \ 		return 0; }
comment|/* This function is passed the ENGINE structure to initialise with its own  * function and command settings. It should not adjust the structural or  * functional reference counts. If this function returns zero, (a) the load will  * be aborted, (b) the previous ENGINE state will be memcpy'd back onto the  * structure, and (c) the shared library will be unloaded. So implementations  * should do their own internal cleanup in failure circumstances otherwise they  * could leak. The 'id' parameter, if non-NULL, represents the ENGINE id that  * the loader is looking for. If this is NULL, the shared library can choose to  * return failure or to initialise a 'default' ENGINE. If non-NULL, the shared  * library must initialise only an ENGINE matching the passed 'id'. The function  * is expected to be implemented with the symbol name "bind_engine". A standard  * implementation can be instantiated with IMPLEMENT_DYNAMIC_BIND_FN(fn) where  * the parameter 'fn' is a callback function that populates the ENGINE structure  * and returns an int value (zero for failure). 'fn' should have prototype;  *    [static] int fn(ENGINE *e, const char *id); */
typedef|typedef
name|int
function_decl|(
modifier|*
name|dynamic_bind_engine
function_decl|)
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|,
specifier|const
name|dynamic_fns
modifier|*
name|fns
parameter_list|)
function_decl|;
define|#
directive|define
name|IMPLEMENT_DYNAMIC_BIND_FN
parameter_list|(
name|fn
parameter_list|)
define|\
value|OPENSSL_EXPORT \ 	int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns) { \ 		if(ENGINE_get_static_state() == fns->static_state) goto skip_cbs; \ 		if(!CRYPTO_set_mem_functions(fns->mem_fns.malloc_cb, \ 			fns->mem_fns.realloc_cb, fns->mem_fns.free_cb)) \ 			return 0; \ 		CRYPTO_set_locking_callback(fns->lock_fns.lock_locking_cb); \ 		CRYPTO_set_add_lock_callback(fns->lock_fns.lock_add_lock_cb); \ 		CRYPTO_set_dynlock_create_callback(fns->lock_fns.dynlock_create_cb); \ 		CRYPTO_set_dynlock_lock_callback(fns->lock_fns.dynlock_lock_cb); \ 		CRYPTO_set_dynlock_destroy_callback(fns->lock_fns.dynlock_destroy_cb); \ 		if(!CRYPTO_set_ex_data_implementation(fns->ex_data_fns)) \ 			return 0; \ 		if(!ERR_set_implementation(fns->err_fns)) return 0; \ 	skip_cbs: \ 		if(!fn(e,id)) return 0; \ 		return 1; }
comment|/* If the loading application (or library) and the loaded ENGINE library share  * the same static data (eg. they're both dynamically linked to the same  * libcrypto.so) we need a way to avoid trying to set system callbacks - this  * would fail, and for the same reason that it's unnecessary to try. If the  * loaded ENGINE has (or gets from through the loader) its own copy of the  * libcrypto static data, we will need to set the callbacks. The easiest way to  * detect this is to have a function that returns a pointer to some static data  * and let the loading application and loaded ENGINE compare their respective  * values. */
name|void
modifier|*
name|ENGINE_get_static_state
parameter_list|(
name|void
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|void
name|ENGINE_setup_bsd_cryptodev
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* BEGIN ERROR CODES */
comment|/* The following lines are auto generated by the script mkerr.pl. Any changes  * made after this point may be overwritten when the script is next run.  */
name|void
name|ERR_load_ENGINE_strings
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Error codes for the ENGINE functions. */
comment|/* Function codes. */
define|#
directive|define
name|ENGINE_F_DYNAMIC_CTRL
value|180
define|#
directive|define
name|ENGINE_F_DYNAMIC_GET_DATA_CTX
value|181
define|#
directive|define
name|ENGINE_F_DYNAMIC_LOAD
value|182
define|#
directive|define
name|ENGINE_F_DYNAMIC_SET_DATA_CTX
value|183
define|#
directive|define
name|ENGINE_F_ENGINE_ADD
value|105
define|#
directive|define
name|ENGINE_F_ENGINE_BY_ID
value|106
define|#
directive|define
name|ENGINE_F_ENGINE_CMD_IS_EXECUTABLE
value|170
define|#
directive|define
name|ENGINE_F_ENGINE_CTRL
value|142
define|#
directive|define
name|ENGINE_F_ENGINE_CTRL_CMD
value|178
define|#
directive|define
name|ENGINE_F_ENGINE_CTRL_CMD_STRING
value|171
define|#
directive|define
name|ENGINE_F_ENGINE_FINISH
value|107
define|#
directive|define
name|ENGINE_F_ENGINE_FREE_UTIL
value|108
define|#
directive|define
name|ENGINE_F_ENGINE_GET_CIPHER
value|185
define|#
directive|define
name|ENGINE_F_ENGINE_GET_DEFAULT_TYPE
value|177
define|#
directive|define
name|ENGINE_F_ENGINE_GET_DIGEST
value|186
define|#
directive|define
name|ENGINE_F_ENGINE_GET_NEXT
value|115
define|#
directive|define
name|ENGINE_F_ENGINE_GET_PREV
value|116
define|#
directive|define
name|ENGINE_F_ENGINE_INIT
value|119
define|#
directive|define
name|ENGINE_F_ENGINE_LIST_ADD
value|120
define|#
directive|define
name|ENGINE_F_ENGINE_LIST_REMOVE
value|121
define|#
directive|define
name|ENGINE_F_ENGINE_LOAD_PRIVATE_KEY
value|150
define|#
directive|define
name|ENGINE_F_ENGINE_LOAD_PUBLIC_KEY
value|151
define|#
directive|define
name|ENGINE_F_ENGINE_LOAD_SSL_CLIENT_CERT
value|192
define|#
directive|define
name|ENGINE_F_ENGINE_NEW
value|122
define|#
directive|define
name|ENGINE_F_ENGINE_REMOVE
value|123
define|#
directive|define
name|ENGINE_F_ENGINE_SET_DEFAULT_STRING
value|189
define|#
directive|define
name|ENGINE_F_ENGINE_SET_DEFAULT_TYPE
value|126
define|#
directive|define
name|ENGINE_F_ENGINE_SET_ID
value|129
define|#
directive|define
name|ENGINE_F_ENGINE_SET_NAME
value|130
define|#
directive|define
name|ENGINE_F_ENGINE_TABLE_REGISTER
value|184
define|#
directive|define
name|ENGINE_F_ENGINE_UNLOAD_KEY
value|152
define|#
directive|define
name|ENGINE_F_ENGINE_UNLOCKED_FINISH
value|191
define|#
directive|define
name|ENGINE_F_ENGINE_UP_REF
value|190
define|#
directive|define
name|ENGINE_F_INT_CTRL_HELPER
value|172
define|#
directive|define
name|ENGINE_F_INT_ENGINE_CONFIGURE
value|188
define|#
directive|define
name|ENGINE_F_INT_ENGINE_MODULE_INIT
value|187
define|#
directive|define
name|ENGINE_F_LOG_MESSAGE
value|141
comment|/* Reason codes. */
define|#
directive|define
name|ENGINE_R_ALREADY_LOADED
value|100
define|#
directive|define
name|ENGINE_R_ARGUMENT_IS_NOT_A_NUMBER
value|133
define|#
directive|define
name|ENGINE_R_CMD_NOT_EXECUTABLE
value|134
define|#
directive|define
name|ENGINE_R_COMMAND_TAKES_INPUT
value|135
define|#
directive|define
name|ENGINE_R_COMMAND_TAKES_NO_INPUT
value|136
define|#
directive|define
name|ENGINE_R_CONFLICTING_ENGINE_ID
value|103
define|#
directive|define
name|ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED
value|119
define|#
directive|define
name|ENGINE_R_DH_NOT_IMPLEMENTED
value|139
define|#
directive|define
name|ENGINE_R_DSA_NOT_IMPLEMENTED
value|140
define|#
directive|define
name|ENGINE_R_DSO_FAILURE
value|104
define|#
directive|define
name|ENGINE_R_DSO_NOT_FOUND
value|132
define|#
directive|define
name|ENGINE_R_ENGINES_SECTION_ERROR
value|148
define|#
directive|define
name|ENGINE_R_ENGINE_CONFIGURATION_ERROR
value|101
define|#
directive|define
name|ENGINE_R_ENGINE_IS_NOT_IN_LIST
value|105
define|#
directive|define
name|ENGINE_R_ENGINE_SECTION_ERROR
value|149
define|#
directive|define
name|ENGINE_R_FAILED_LOADING_PRIVATE_KEY
value|128
define|#
directive|define
name|ENGINE_R_FAILED_LOADING_PUBLIC_KEY
value|129
define|#
directive|define
name|ENGINE_R_FINISH_FAILED
value|106
define|#
directive|define
name|ENGINE_R_GET_HANDLE_FAILED
value|107
define|#
directive|define
name|ENGINE_R_ID_OR_NAME_MISSING
value|108
define|#
directive|define
name|ENGINE_R_INIT_FAILED
value|109
define|#
directive|define
name|ENGINE_R_INTERNAL_LIST_ERROR
value|110
define|#
directive|define
name|ENGINE_R_INVALID_ARGUMENT
value|143
define|#
directive|define
name|ENGINE_R_INVALID_CMD_NAME
value|137
define|#
directive|define
name|ENGINE_R_INVALID_CMD_NUMBER
value|138
define|#
directive|define
name|ENGINE_R_INVALID_INIT_VALUE
value|151
define|#
directive|define
name|ENGINE_R_INVALID_STRING
value|150
define|#
directive|define
name|ENGINE_R_NOT_INITIALISED
value|117
define|#
directive|define
name|ENGINE_R_NOT_LOADED
value|112
define|#
directive|define
name|ENGINE_R_NO_CONTROL_FUNCTION
value|120
define|#
directive|define
name|ENGINE_R_NO_INDEX
value|144
define|#
directive|define
name|ENGINE_R_NO_LOAD_FUNCTION
value|125
define|#
directive|define
name|ENGINE_R_NO_REFERENCE
value|130
define|#
directive|define
name|ENGINE_R_NO_SUCH_ENGINE
value|116
define|#
directive|define
name|ENGINE_R_NO_UNLOAD_FUNCTION
value|126
define|#
directive|define
name|ENGINE_R_PROVIDE_PARAMETERS
value|113
define|#
directive|define
name|ENGINE_R_RSA_NOT_IMPLEMENTED
value|141
define|#
directive|define
name|ENGINE_R_UNIMPLEMENTED_CIPHER
value|146
define|#
directive|define
name|ENGINE_R_UNIMPLEMENTED_DIGEST
value|147
define|#
directive|define
name|ENGINE_R_VERSION_INCOMPATIBILITY
value|145
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

