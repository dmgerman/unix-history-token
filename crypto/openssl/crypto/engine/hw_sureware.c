begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Written by Corinne Dive-Reclus(cdive@baltimore.com) *  * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. All advertising materials mentioning features or use of this *    software must display the following acknowledgment: *    "This product includes software developed by the OpenSSL Project *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)" * * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to *    endorse or promote products derived from this software without *    prior written permission. For written permission, please contact *    licensing@OpenSSL.org. * * 5. Products derived from this software may not be called "OpenSSL" *    nor may "OpenSSL" appear in their names without prior written *    permission of the OpenSSL Project. * * 6. Redistributions of any form whatsoever must retain the following *    acknowledgment: *    "This product includes software developed by the OpenSSL Project *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)" * * Written by Corinne Dive-Reclus(cdive@baltimore.com) * * Copyright@2001 Baltimore Technologies Ltd. * All right Reserved. *																								*	 *		THIS FILE IS PROVIDED BY BALTIMORE TECHNOLOGIES ``AS IS'' AND																			* *		ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE					*  *		IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE				* *		ARE DISCLAIMED.  IN NO EVENT SHALL BALTIMORE TECHNOLOGIES BE LIABLE						* *		FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL				* *		DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS					* *		OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)					* *		HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT				* *		LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY				* *		OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF					* *		SUCH DAMAGE.																			* ====================================================================*/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_include
include|#
directive|include
file|<openssl/dso.h>
end_include

begin_include
include|#
directive|include
file|"eng_int.h"
end_include

begin_include
include|#
directive|include
file|"engine.h"
end_include

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HW
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HW_SUREWARE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|FLAT_INC
end_ifdef

begin_include
include|#
directive|include
file|"sureware.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"vendor_defns/sureware.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SUREWARE_LIB_NAME
value|"sureware engine"
end_define

begin_include
include|#
directive|include
file|"hw_sureware_err.c"
end_include

begin_function_decl
specifier|static
name|int
name|surewarehk_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|surewarehk_destroy
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|surewarehk_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|surewarehk_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|surewarehk_modexp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* RSA stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|surewarehk_rsa_priv_dec
parameter_list|(
name|int
name|flen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|from
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|int
name|padding
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|surewarehk_rsa_sign
parameter_list|(
name|int
name|flen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|from
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|int
name|padding
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* RAND stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|surewarehk_rand_bytes
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|surewarehk_rand_seed
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|surewarehk_rand_add
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|,
name|double
name|entropy
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* KM stuff */
end_comment

begin_function_decl
specifier|static
name|EVP_PKEY
modifier|*
name|surewarehk_load_privkey
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|EVP_PKEY
modifier|*
name|surewarehk_load_pubkey
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|surewarehk_ex_free
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|,
name|int
name|idx
parameter_list|,
name|long
name|argl
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void surewarehk_dh_ex_free(void *obj, void *item, CRYPTO_EX_DATA *ad, 	int idx,long argl, void *argp);
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_comment
comment|/* This function is aliased to mod_exp (with the mont stuff dropped). */
end_comment

begin_function
specifier|static
name|int
name|surewarehk_mod_exp_mont
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
block|{
return|return
name|surewarehk_modexp
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Our internal RSA_METHOD that we provide pointers to */
end_comment

begin_decl_stmt
specifier|static
name|RSA_METHOD
name|surewarehk_rsa
init|=
block|{
literal|"SureWare RSA method"
block|,
name|NULL
block|,
comment|/* pub_enc*/
name|NULL
block|,
comment|/* pub_dec*/
name|surewarehk_rsa_sign
block|,
comment|/* our rsa_sign is OpenSSL priv_enc*/
name|surewarehk_rsa_priv_dec
block|,
comment|/* priv_dec*/
name|NULL
block|,
comment|/*mod_exp*/
name|surewarehk_mod_exp_mont
block|,
comment|/*mod_exp_mongomery*/
name|NULL
block|,
comment|/* init*/
name|NULL
block|,
comment|/* finish*/
literal|0
block|,
comment|/* RSA flag*/
name|NULL
block|,
name|NULL
block|,
comment|/* OpenSSL sign*/
name|NULL
comment|/* OpenSSL verify*/
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_comment
comment|/* Our internal DH_METHOD that we provide pointers to */
end_comment

begin_comment
comment|/* This function is aliased to mod_exp (with the dh and mont dropped). */
end_comment

begin_function
specifier|static
name|int
name|surewarehk_modexp_dh
parameter_list|(
specifier|const
name|DH
modifier|*
name|dh
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
block|{
return|return
name|surewarehk_modexp
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|DH_METHOD
name|surewarehk_dh
init|=
block|{
literal|"SureWare DH method"
block|,
name|NULL
block|,
comment|/*gen_key*/
name|NULL
block|,
comment|/*agree,*/
name|surewarehk_modexp_dh
block|,
comment|/*dh mod exp*/
name|NULL
block|,
comment|/* init*/
name|NULL
block|,
comment|/* finish*/
literal|0
block|,
comment|/* flags*/
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|RAND_METHOD
name|surewarehk_rand
init|=
block|{
comment|/* "SureWare RAND method", */
name|surewarehk_rand_seed
block|,
name|surewarehk_rand_bytes
block|,
name|NULL
block|,
comment|/*cleanup*/
name|surewarehk_rand_add
block|,
name|surewarehk_rand_bytes
block|,
name|NULL
block|,
comment|/*rand_status*/
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
end_ifndef

begin_comment
comment|/* DSA stuff */
end_comment

begin_function_decl
specifier|static
name|DSA_SIG
modifier|*
name|surewarehk_dsa_do_sign
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|dgst
parameter_list|,
name|int
name|dlen
parameter_list|,
name|DSA
modifier|*
name|dsa
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|surewarehk_dsa_mod_exp
parameter_list|(
name|DSA
modifier|*
name|dsa
parameter_list|,
name|BIGNUM
modifier|*
name|rr
parameter_list|,
name|BIGNUM
modifier|*
name|a1
parameter_list|,
name|BIGNUM
modifier|*
name|p1
parameter_list|,
name|BIGNUM
modifier|*
name|a2
parameter_list|,
name|BIGNUM
modifier|*
name|p2
parameter_list|,
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|in_mont
parameter_list|)
block|{
name|BIGNUM
name|t
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
name|BN_init
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* let rr = a1 ^ p1 mod m */
if|if
condition|(
operator|!
name|surewarehk_modexp
argument_list|(
name|rr
argument_list|,
name|a1
argument_list|,
name|p1
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* let t = a2 ^ p2 mod m */
if|if
condition|(
operator|!
name|surewarehk_modexp
argument_list|(
operator|&
name|t
argument_list|,
name|a2
argument_list|,
name|p2
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* let rr = rr * t mod m */
if|if
condition|(
operator|!
name|BN_mod_mul
argument_list|(
name|rr
argument_list|,
name|rr
argument_list|,
operator|&
name|t
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|to_return
operator|=
literal|1
expr_stmt|;
name|end
label|:
name|BN_free
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|DSA_METHOD
name|surewarehk_dsa
init|=
block|{
literal|"SureWare DSA method"
block|,
name|surewarehk_dsa_do_sign
block|,
name|NULL
block|,
comment|/*sign setup*/
name|NULL
block|,
comment|/*verify,*/
name|surewarehk_dsa_mod_exp
block|,
comment|/*mod exp*/
name|NULL
block|,
comment|/*bn mod exp*/
name|NULL
block|,
comment|/*init*/
name|NULL
block|,
comment|/*finish*/
literal|0
block|,
name|NULL
block|, 	}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_sureware_id
init|=
literal|"sureware"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_sureware_name
init|=
literal|"SureWare hardware engine support"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Now, to our own code */
end_comment

begin_comment
comment|/* As this is only ever called once, there's no need for locking  * (indeed - the lock will already be held by our caller!!!) */
end_comment

begin_function
specifier|static
name|int
name|bind_sureware
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
specifier|const
name|RSA_METHOD
modifier|*
name|meth1
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
specifier|const
name|DSA_METHOD
modifier|*
name|meth2
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
specifier|const
name|DH_METHOD
modifier|*
name|meth3
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ENGINE_set_id
argument_list|(
name|e
argument_list|,
name|engine_sureware_id
argument_list|)
operator|||
operator|!
name|ENGINE_set_name
argument_list|(
name|e
argument_list|,
name|engine_sureware_name
argument_list|)
operator|||
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
operator|!
name|ENGINE_set_RSA
argument_list|(
name|e
argument_list|,
operator|&
name|surewarehk_rsa
argument_list|)
operator|||
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
operator|!
name|ENGINE_set_DSA
argument_list|(
name|e
argument_list|,
operator|&
name|surewarehk_dsa
argument_list|)
operator|||
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
operator|!
name|ENGINE_set_DH
argument_list|(
name|e
argument_list|,
operator|&
name|surewarehk_dh
argument_list|)
operator|||
endif|#
directive|endif
operator|!
name|ENGINE_set_RAND
argument_list|(
name|e
argument_list|,
operator|&
name|surewarehk_rand
argument_list|)
operator|||
operator|!
name|ENGINE_set_destroy_function
argument_list|(
name|e
argument_list|,
name|surewarehk_destroy
argument_list|)
operator|||
operator|!
name|ENGINE_set_init_function
argument_list|(
name|e
argument_list|,
name|surewarehk_init
argument_list|)
operator|||
operator|!
name|ENGINE_set_finish_function
argument_list|(
name|e
argument_list|,
name|surewarehk_finish
argument_list|)
operator|||
operator|!
name|ENGINE_set_ctrl_function
argument_list|(
name|e
argument_list|,
name|surewarehk_ctrl
argument_list|)
operator|||
operator|!
name|ENGINE_set_load_privkey_function
argument_list|(
name|e
argument_list|,
name|surewarehk_load_privkey
argument_list|)
operator|||
operator|!
name|ENGINE_set_load_pubkey_function
argument_list|(
name|e
argument_list|,
name|surewarehk_load_pubkey
argument_list|)
condition|)
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
comment|/* We know that the "PKCS1_SSLeay()" functions hook properly 	 * to the cswift-specific mod_exp and mod_exp_crt so we use 	 * those functions. NB: We don't use ENGINE_openssl() or 	 * anything "more generic" because something like the RSAref 	 * code may not hook properly, and if you own one of these 	 * cards then you have the right to do RSA operations on it 	 * anyway! */
name|meth1
operator|=
name|RSA_PKCS1_SSLeay
argument_list|()
expr_stmt|;
if|if
condition|(
name|meth1
condition|)
block|{
name|surewarehk_rsa
operator|.
name|rsa_pub_enc
operator|=
name|meth1
operator|->
name|rsa_pub_enc
expr_stmt|;
name|surewarehk_rsa
operator|.
name|rsa_pub_dec
operator|=
name|meth1
operator|->
name|rsa_pub_dec
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
comment|/* Use the DSA_OpenSSL() method and just hook the mod_exp-ish 	 * bits. */
name|meth2
operator|=
name|DSA_OpenSSL
argument_list|()
expr_stmt|;
if|if
condition|(
name|meth2
condition|)
block|{
name|surewarehk_dsa
operator|.
name|dsa_do_verify
operator|=
name|meth2
operator|->
name|dsa_do_verify
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
comment|/* Much the same for Diffie-Hellman */
name|meth3
operator|=
name|DH_OpenSSL
argument_list|()
expr_stmt|;
if|if
condition|(
name|meth3
condition|)
block|{
name|surewarehk_dh
operator|.
name|generate_key
operator|=
name|meth3
operator|->
name|generate_key
expr_stmt|;
name|surewarehk_dh
operator|.
name|compute_key
operator|=
name|meth3
operator|->
name|compute_key
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Ensure the sureware error handling is set up */
name|ERR_load_SUREWARE_strings
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENGINE_DYNAMIC_SUPPORT
end_ifdef

begin_function
specifier|static
name|int
name|bind_helper
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|&&
operator|(
name|strcmp
argument_list|(
name|id
argument_list|,
name|engine_sureware_id
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|bind_sureware
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_macro
name|IMPLEMENT_DYNAMIC_CHECK_FN
argument_list|()
end_macro

begin_macro
name|IMPLEMENT_DYNAMIC_BIND_FN
argument_list|(
argument|bind_helper
argument_list|)
end_macro

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|ENGINE
modifier|*
name|engine_sureware
parameter_list|(
name|void
parameter_list|)
block|{
name|ENGINE
modifier|*
name|ret
init|=
name|ENGINE_new
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|bind_sureware
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ENGINE_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|ENGINE_load_sureware
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Copied from eng_[openssl|dyn].c */
name|ENGINE
modifier|*
name|toadd
init|=
name|engine_sureware
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|toadd
condition|)
return|return;
name|ENGINE_add
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ENGINE_free
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is a process-global DSO handle used for loading and unloading  * the SureWareHook library. NB: This is only set (or unset) during an  * init() or finish() call (reference counts permitting) and they're  * operating with global locks, so this should be thread-safe  * implicitly. */
end_comment

begin_decl_stmt
specifier|static
name|DSO
modifier|*
name|surewarehk_dso
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|rsaHndidx
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index for KM handle.  Not really used yet. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|dsaHndidx
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index for KM handle.  Not really used yet. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These are the function pointers that are (un)set when the library has  * successfully (un)loaded. */
end_comment

begin_decl_stmt
specifier|static
name|SureWareHook_Init_t
modifier|*
name|p_surewarehk_Init
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SureWareHook_Finish_t
modifier|*
name|p_surewarehk_Finish
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SureWareHook_Rand_Bytes_t
modifier|*
name|p_surewarehk_Rand_Bytes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SureWareHook_Rand_Seed_t
modifier|*
name|p_surewarehk_Rand_Seed
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SureWareHook_Load_Privkey_t
modifier|*
name|p_surewarehk_Load_Privkey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SureWareHook_Info_Pubkey_t
modifier|*
name|p_surewarehk_Info_Pubkey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SureWareHook_Load_Rsa_Pubkey_t
modifier|*
name|p_surewarehk_Load_Rsa_Pubkey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SureWareHook_Load_Dsa_Pubkey_t
modifier|*
name|p_surewarehk_Load_Dsa_Pubkey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SureWareHook_Free_t
modifier|*
name|p_surewarehk_Free
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SureWareHook_Rsa_Priv_Dec_t
modifier|*
name|p_surewarehk_Rsa_Priv_Dec
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SureWareHook_Rsa_Sign_t
modifier|*
name|p_surewarehk_Rsa_Sign
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SureWareHook_Dsa_Sign_t
modifier|*
name|p_surewarehk_Dsa_Sign
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SureWareHook_Mod_Exp_t
modifier|*
name|p_surewarehk_Mod_Exp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used in the DSO operations. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|surewarehk_LIBNAME
init|=
literal|"SureWareHook"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_surewarehk_Init
init|=
literal|"SureWareHook_Init"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_surewarehk_Finish
init|=
literal|"SureWareHook_Finish"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_surewarehk_Rand_Bytes
init|=
literal|"SureWareHook_Rand_Bytes"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_surewarehk_Rand_Seed
init|=
literal|"SureWareHook_Rand_Seed"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_surewarehk_Load_Privkey
init|=
literal|"SureWareHook_Load_Privkey"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_surewarehk_Info_Pubkey
init|=
literal|"SureWareHook_Info_Pubkey"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_surewarehk_Load_Rsa_Pubkey
init|=
literal|"SureWareHook_Load_Rsa_Pubkey"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_surewarehk_Load_Dsa_Pubkey
init|=
literal|"SureWareHook_Load_Dsa_Pubkey"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_surewarehk_Free
init|=
literal|"SureWareHook_Free"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_surewarehk_Rsa_Priv_Dec
init|=
literal|"SureWareHook_Rsa_Priv_Dec"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_surewarehk_Rsa_Sign
init|=
literal|"SureWareHook_Rsa_Sign"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_surewarehk_Dsa_Sign
init|=
literal|"SureWareHook_Dsa_Sign"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_surewarehk_Mod_Exp
init|=
literal|"SureWareHook_Mod_Exp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BIO
modifier|*
name|logstream
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SureWareHook library functions and mechanics - these are used by the  * higher-level functions further down. NB: As and where there's no  * error checking, take a look lower down where these functions are  * called, the checking and error handling is probably down there.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|threadsafe
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|surewarehk_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
parameter_list|)
block|{
name|int
name|to_return
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ENGINE_CTRL_SET_LOGSTREAM
case|:
block|{
name|BIO
modifier|*
name|bio
init|=
operator|(
name|BIO
operator|*
operator|)
name|p
decl_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|logstream
condition|)
block|{
name|BIO_free
argument_list|(
name|logstream
argument_list|)
expr_stmt|;
name|logstream
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|CRYPTO_add
argument_list|(
operator|&
name|bio
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_BIO
argument_list|)
operator|>
literal|1
condition|)
name|logstream
operator|=
name|bio
expr_stmt|;
else|else
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_CTRL
argument_list|,
name|SUREWARE_R_BIO_WAS_FREED
argument_list|)
expr_stmt|;
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
comment|/* This will prevent the initialisation function from "installing" 	 * the mutex-handling callbacks, even if they are available from 	 * within the library (or were provided to the library from the 	 * calling application). This is to remove any baggage for 	 * applications not using multithreading. */
case|case
name|ENGINE_CTRL_CHIL_NO_LOCKING
case|:
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|threadsafe
operator|=
literal|0
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
comment|/* The command isn't understood by this engine */
default|default:
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_CTRL
argument_list|,
name|ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|to_return
return|;
block|}
end_function

begin_comment
comment|/* Destructor (complements the "ENGINE_surewarehk()" constructor) */
end_comment

begin_function
specifier|static
name|int
name|surewarehk_destroy
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|ERR_unload_SUREWARE_strings
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* (de)initialisation functions. */
end_comment

begin_function
specifier|static
name|int
name|surewarehk_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|char
name|msg
index|[
literal|64
index|]
init|=
literal|"ENGINE_init"
decl_stmt|;
name|SureWareHook_Init_t
modifier|*
name|p1
init|=
name|NULL
decl_stmt|;
name|SureWareHook_Finish_t
modifier|*
name|p2
init|=
name|NULL
decl_stmt|;
name|SureWareHook_Rand_Bytes_t
modifier|*
name|p3
init|=
name|NULL
decl_stmt|;
name|SureWareHook_Rand_Seed_t
modifier|*
name|p4
init|=
name|NULL
decl_stmt|;
name|SureWareHook_Load_Privkey_t
modifier|*
name|p5
init|=
name|NULL
decl_stmt|;
name|SureWareHook_Load_Rsa_Pubkey_t
modifier|*
name|p6
init|=
name|NULL
decl_stmt|;
name|SureWareHook_Free_t
modifier|*
name|p7
init|=
name|NULL
decl_stmt|;
name|SureWareHook_Rsa_Priv_Dec_t
modifier|*
name|p8
init|=
name|NULL
decl_stmt|;
name|SureWareHook_Rsa_Sign_t
modifier|*
name|p9
init|=
name|NULL
decl_stmt|;
name|SureWareHook_Dsa_Sign_t
modifier|*
name|p12
init|=
name|NULL
decl_stmt|;
name|SureWareHook_Info_Pubkey_t
modifier|*
name|p13
init|=
name|NULL
decl_stmt|;
name|SureWareHook_Load_Dsa_Pubkey_t
modifier|*
name|p14
init|=
name|NULL
decl_stmt|;
name|SureWareHook_Mod_Exp_t
modifier|*
name|p15
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|surewarehk_dso
operator|!=
name|NULL
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_INIT
argument_list|,
name|ENGINE_R_ALREADY_LOADED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Attempt to load libsurewarehk.so/surewarehk.dll/whatever. */
name|surewarehk_dso
operator|=
name|DSO_load
argument_list|(
name|NULL
argument_list|,
name|surewarehk_LIBNAME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|surewarehk_dso
operator|==
name|NULL
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_INIT
argument_list|,
name|ENGINE_R_DSO_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|p1
operator|=
operator|(
name|SureWareHook_Init_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|surewarehk_dso
argument_list|,
name|n_surewarehk_Init
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p2
operator|=
operator|(
name|SureWareHook_Finish_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|surewarehk_dso
argument_list|,
name|n_surewarehk_Finish
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p3
operator|=
operator|(
name|SureWareHook_Rand_Bytes_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|surewarehk_dso
argument_list|,
name|n_surewarehk_Rand_Bytes
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p4
operator|=
operator|(
name|SureWareHook_Rand_Seed_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|surewarehk_dso
argument_list|,
name|n_surewarehk_Rand_Seed
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p5
operator|=
operator|(
name|SureWareHook_Load_Privkey_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|surewarehk_dso
argument_list|,
name|n_surewarehk_Load_Privkey
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p6
operator|=
operator|(
name|SureWareHook_Load_Rsa_Pubkey_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|surewarehk_dso
argument_list|,
name|n_surewarehk_Load_Rsa_Pubkey
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p7
operator|=
operator|(
name|SureWareHook_Free_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|surewarehk_dso
argument_list|,
name|n_surewarehk_Free
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p8
operator|=
operator|(
name|SureWareHook_Rsa_Priv_Dec_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|surewarehk_dso
argument_list|,
name|n_surewarehk_Rsa_Priv_Dec
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p9
operator|=
operator|(
name|SureWareHook_Rsa_Sign_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|surewarehk_dso
argument_list|,
name|n_surewarehk_Rsa_Sign
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p12
operator|=
operator|(
name|SureWareHook_Dsa_Sign_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|surewarehk_dso
argument_list|,
name|n_surewarehk_Dsa_Sign
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p13
operator|=
operator|(
name|SureWareHook_Info_Pubkey_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|surewarehk_dso
argument_list|,
name|n_surewarehk_Info_Pubkey
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p14
operator|=
operator|(
name|SureWareHook_Load_Dsa_Pubkey_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|surewarehk_dso
argument_list|,
name|n_surewarehk_Load_Dsa_Pubkey
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p15
operator|=
operator|(
name|SureWareHook_Mod_Exp_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|surewarehk_dso
argument_list|,
name|n_surewarehk_Mod_Exp
argument_list|)
operator|)
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_INIT
argument_list|,
name|ENGINE_R_DSO_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Copy the pointers */
name|p_surewarehk_Init
operator|=
name|p1
expr_stmt|;
name|p_surewarehk_Finish
operator|=
name|p2
expr_stmt|;
name|p_surewarehk_Rand_Bytes
operator|=
name|p3
expr_stmt|;
name|p_surewarehk_Rand_Seed
operator|=
name|p4
expr_stmt|;
name|p_surewarehk_Load_Privkey
operator|=
name|p5
expr_stmt|;
name|p_surewarehk_Load_Rsa_Pubkey
operator|=
name|p6
expr_stmt|;
name|p_surewarehk_Free
operator|=
name|p7
expr_stmt|;
name|p_surewarehk_Rsa_Priv_Dec
operator|=
name|p8
expr_stmt|;
name|p_surewarehk_Rsa_Sign
operator|=
name|p9
expr_stmt|;
name|p_surewarehk_Dsa_Sign
operator|=
name|p12
expr_stmt|;
name|p_surewarehk_Info_Pubkey
operator|=
name|p13
expr_stmt|;
name|p_surewarehk_Load_Dsa_Pubkey
operator|=
name|p14
expr_stmt|;
name|p_surewarehk_Mod_Exp
operator|=
name|p15
expr_stmt|;
comment|/* Contact the hardware and initialises it. */
if|if
condition|(
name|p_surewarehk_Init
argument_list|(
name|msg
argument_list|,
name|threadsafe
argument_list|)
operator|==
name|SUREWAREHOOK_ERROR_UNIT_FAILURE
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_INIT
argument_list|,
name|SUREWARE_R_UNIT_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|p_surewarehk_Init
argument_list|(
name|msg
argument_list|,
name|threadsafe
argument_list|)
operator|==
name|SUREWAREHOOK_ERROR_UNIT_FAILURE
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_INIT
argument_list|,
name|SUREWARE_R_UNIT_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* try to load the default private key, if failed does not return a failure but            wait for an explicit ENGINE_load_privakey */
name|surewarehk_load_privkey
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Everything's fine. */
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|rsaHndidx
operator|==
operator|-
literal|1
condition|)
name|rsaHndidx
operator|=
name|RSA_get_ex_new_index
argument_list|(
literal|0
argument_list|,
literal|"SureWareHook RSA key handle"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|surewarehk_ex_free
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
if|if
condition|(
name|dsaHndidx
operator|==
operator|-
literal|1
condition|)
name|dsaHndidx
operator|=
name|DSA_get_ex_new_index
argument_list|(
literal|0
argument_list|,
literal|"SureWareHook DSA key handle"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|surewarehk_ex_free
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
name|err
label|:
if|if
condition|(
name|surewarehk_dso
condition|)
name|DSO_free
argument_list|(
name|surewarehk_dso
argument_list|)
expr_stmt|;
name|surewarehk_dso
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Init
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Finish
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Rand_Bytes
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Rand_Seed
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Load_Privkey
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Load_Rsa_Pubkey
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Free
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Rsa_Priv_Dec
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Rsa_Sign
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Dsa_Sign
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Info_Pubkey
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Load_Dsa_Pubkey
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Mod_Exp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|surewarehk_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|int
name|to_return
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|surewarehk_dso
operator|==
name|NULL
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_FINISH
argument_list|,
name|ENGINE_R_NOT_LOADED
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|0
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p_surewarehk_Finish
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|DSO_free
argument_list|(
name|surewarehk_dso
argument_list|)
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_FINISH
argument_list|,
name|ENGINE_R_DSO_FAILURE
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|0
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|err
label|:
if|if
condition|(
name|logstream
condition|)
name|BIO_free
argument_list|(
name|logstream
argument_list|)
expr_stmt|;
name|surewarehk_dso
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Init
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Finish
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Rand_Bytes
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Rand_Seed
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Load_Privkey
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Load_Rsa_Pubkey
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Free
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Rsa_Priv_Dec
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Rsa_Sign
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Dsa_Sign
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Info_Pubkey
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Load_Dsa_Pubkey
operator|=
name|NULL
expr_stmt|;
name|p_surewarehk_Mod_Exp
operator|=
name|NULL
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|surewarehk_error_handling
parameter_list|(
name|char
modifier|*
specifier|const
name|msg
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|ret
parameter_list|)
block|{
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|SUREWAREHOOK_ERROR_UNIT_FAILURE
case|:
name|ENGINEerr
argument_list|(
name|func
argument_list|,
name|SUREWARE_R_UNIT_FAILURE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUREWAREHOOK_ERROR_FALLBACK
case|:
name|ENGINEerr
argument_list|(
name|func
argument_list|,
name|SUREWARE_R_REQUEST_FALLBACK
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUREWAREHOOK_ERROR_DATA_SIZE
case|:
name|ENGINEerr
argument_list|(
name|func
argument_list|,
name|SUREWARE_R_SIZE_TOO_LARGE_OR_TOO_SMALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUREWAREHOOK_ERROR_INVALID_PAD
case|:
name|ENGINEerr
argument_list|(
name|func
argument_list|,
name|RSA_R_PADDING_CHECK_FAILED
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ENGINEerr
argument_list|(
name|func
argument_list|,
name|SUREWARE_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/*nothing*/
name|msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|msg
condition|)
block|{
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|logstream
condition|)
block|{
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_BIO
argument_list|)
expr_stmt|;
name|BIO_write
argument_list|(
name|logstream
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_BIO
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|surewarehk_rand_bytes
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|char
name|msg
index|[
literal|64
index|]
init|=
literal|"ENGINE_rand_bytes"
decl_stmt|;
if|if
condition|(
operator|!
name|p_surewarehk_Rand_Bytes
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_RAND_BYTES
argument_list|,
name|ENGINE_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|p_surewarehk_Rand_Bytes
argument_list|(
name|msg
argument_list|,
name|buf
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|surewarehk_error_handling
argument_list|(
name|msg
argument_list|,
name|SUREWARE_F_SUREWAREHK_RAND_BYTES
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|==
literal|1
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|surewarehk_rand_seed
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|char
name|msg
index|[
literal|64
index|]
init|=
literal|"ENGINE_rand_seed"
decl_stmt|;
if|if
condition|(
operator|!
name|p_surewarehk_Rand_Seed
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_RAND_SEED
argument_list|,
name|ENGINE_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|p_surewarehk_Rand_Seed
argument_list|(
name|msg
argument_list|,
name|buf
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|surewarehk_error_handling
argument_list|(
name|msg
argument_list|,
name|SUREWARE_F_SUREWAREHK_RAND_SEED
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|surewarehk_rand_add
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|,
name|double
name|entropy
parameter_list|)
block|{
name|surewarehk_rand_seed
argument_list|(
name|buf
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|EVP_PKEY
modifier|*
name|sureware_load_public
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|char
modifier|*
name|hptr
parameter_list|,
name|unsigned
name|long
name|el
parameter_list|,
name|char
name|keytype
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|RSA
modifier|*
name|rsatmp
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
name|DSA
modifier|*
name|dsatmp
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|char
name|msg
index|[
literal|64
index|]
init|=
literal|"sureware_load_public"
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|p_surewarehk_Load_Rsa_Pubkey
operator|||
operator|!
name|p_surewarehk_Load_Dsa_Pubkey
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_LOAD_PUBLIC_KEY
argument_list|,
name|ENGINE_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
switch|switch
condition|(
name|keytype
condition|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
case|case
literal|1
case|:
comment|/*RSA*/
comment|/* set private external reference */
name|rsatmp
operator|=
name|RSA_new_method
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|RSA_set_ex_data
argument_list|(
name|rsatmp
argument_list|,
name|rsaHndidx
argument_list|,
name|hptr
argument_list|)
expr_stmt|;
name|rsatmp
operator|->
name|flags
operator||=
name|RSA_FLAG_EXT_PKEY
expr_stmt|;
comment|/* set public big nums*/
name|rsatmp
operator|->
name|e
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|rsatmp
operator|->
name|n
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|bn_expand2
argument_list|(
name|rsatmp
operator|->
name|e
argument_list|,
name|el
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
expr_stmt|;
name|bn_expand2
argument_list|(
name|rsatmp
operator|->
name|n
argument_list|,
name|el
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rsatmp
operator|->
name|e
operator|||
name|rsatmp
operator|->
name|e
operator|->
name|dmax
operator|!=
call|(
name|int
call|)
argument_list|(
name|el
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
operator|||
operator|!
name|rsatmp
operator|->
name|n
operator|||
name|rsatmp
operator|->
name|n
operator|->
name|dmax
operator|!=
call|(
name|int
call|)
argument_list|(
name|el
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|p_surewarehk_Load_Rsa_Pubkey
argument_list|(
name|msg
argument_list|,
name|key_id
argument_list|,
name|el
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|rsatmp
operator|->
name|n
operator|->
name|d
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|rsatmp
operator|->
name|e
operator|->
name|d
argument_list|)
expr_stmt|;
name|surewarehk_error_handling
argument_list|(
name|msg
argument_list|,
name|SUREWARE_F_SUREWAREHK_LOAD_PUBLIC_KEY
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_LOAD_PRIVATE_KEY
argument_list|,
name|ENGINE_R_FAILED_LOADING_PUBLIC_KEY
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* normalise pub e and pub n */
name|rsatmp
operator|->
name|e
operator|->
name|top
operator|=
name|el
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|rsatmp
operator|->
name|e
argument_list|)
expr_stmt|;
name|rsatmp
operator|->
name|n
operator|->
name|top
operator|=
name|el
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|rsatmp
operator|->
name|n
argument_list|)
expr_stmt|;
comment|/* create an EVP object: engine + rsa key */
name|res
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_RSA
argument_list|(
name|res
argument_list|,
name|rsatmp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
case|case
literal|2
case|:
comment|/*DSA*/
comment|/* set private/public external reference */
name|dsatmp
operator|=
name|DSA_new_method
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|DSA_set_ex_data
argument_list|(
name|dsatmp
argument_list|,
name|dsaHndidx
argument_list|,
name|hptr
argument_list|)
expr_stmt|;
comment|/*dsatmp->flags |= DSA_FLAG_EXT_PKEY;*/
comment|/* set public key*/
name|dsatmp
operator|->
name|pub_key
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|dsatmp
operator|->
name|p
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|dsatmp
operator|->
name|q
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|dsatmp
operator|->
name|g
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|bn_expand2
argument_list|(
name|dsatmp
operator|->
name|pub_key
argument_list|,
name|el
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
expr_stmt|;
name|bn_expand2
argument_list|(
name|dsatmp
operator|->
name|p
argument_list|,
name|el
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
expr_stmt|;
name|bn_expand2
argument_list|(
name|dsatmp
operator|->
name|q
argument_list|,
literal|20
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
expr_stmt|;
name|bn_expand2
argument_list|(
name|dsatmp
operator|->
name|g
argument_list|,
name|el
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsatmp
operator|->
name|pub_key
operator|||
name|dsatmp
operator|->
name|pub_key
operator|->
name|dmax
operator|!=
call|(
name|int
call|)
argument_list|(
name|el
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
operator|||
operator|!
name|dsatmp
operator|->
name|p
operator|||
name|dsatmp
operator|->
name|p
operator|->
name|dmax
operator|!=
call|(
name|int
call|)
argument_list|(
name|el
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
operator|||
operator|!
name|dsatmp
operator|->
name|q
operator|||
name|dsatmp
operator|->
name|q
operator|->
name|dmax
operator|!=
literal|20
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
operator|||
operator|!
name|dsatmp
operator|->
name|g
operator|||
name|dsatmp
operator|->
name|g
operator|->
name|dmax
operator|!=
call|(
name|int
call|)
argument_list|(
name|el
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|p_surewarehk_Load_Dsa_Pubkey
argument_list|(
name|msg
argument_list|,
name|key_id
argument_list|,
name|el
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|dsatmp
operator|->
name|pub_key
operator|->
name|d
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|dsatmp
operator|->
name|p
operator|->
name|d
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|dsatmp
operator|->
name|q
operator|->
name|d
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|dsatmp
operator|->
name|g
operator|->
name|d
argument_list|)
expr_stmt|;
name|surewarehk_error_handling
argument_list|(
name|msg
argument_list|,
name|SUREWARE_F_SUREWAREHK_LOAD_PUBLIC_KEY
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_LOAD_PRIVATE_KEY
argument_list|,
name|ENGINE_R_FAILED_LOADING_PUBLIC_KEY
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* set parameters */
comment|/* normalise pubkey and parameters in case of */
name|dsatmp
operator|->
name|pub_key
operator|->
name|top
operator|=
name|el
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|dsatmp
operator|->
name|pub_key
argument_list|)
expr_stmt|;
name|dsatmp
operator|->
name|p
operator|->
name|top
operator|=
name|el
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|dsatmp
operator|->
name|p
argument_list|)
expr_stmt|;
name|dsatmp
operator|->
name|q
operator|->
name|top
operator|=
literal|20
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|dsatmp
operator|->
name|q
argument_list|)
expr_stmt|;
name|dsatmp
operator|->
name|g
operator|->
name|top
operator|=
name|el
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|dsatmp
operator|->
name|g
argument_list|)
expr_stmt|;
comment|/* create an EVP object: engine + rsa key */
name|res
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_DSA
argument_list|(
name|res
argument_list|,
name|dsatmp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_LOAD_PRIVATE_KEY
argument_list|,
name|ENGINE_R_FAILED_LOADING_PRIVATE_KEY
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
name|res
return|;
name|err
label|:
if|if
condition|(
name|res
condition|)
name|EVP_PKEY_free
argument_list|(
name|res
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|rsatmp
condition|)
name|RSA_free
argument_list|(
name|rsatmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
if|if
condition|(
name|dsatmp
condition|)
name|DSA_free
argument_list|(
name|dsatmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|EVP_PKEY
modifier|*
name|surewarehk_load_privkey
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|el
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|hptr
init|=
name|NULL
decl_stmt|;
name|char
name|keytype
init|=
literal|0
decl_stmt|;
name|char
name|msg
index|[
literal|64
index|]
init|=
literal|"ENGINE_load_privkey"
decl_stmt|;
if|if
condition|(
operator|!
name|p_surewarehk_Load_Privkey
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_LOAD_PRIVATE_KEY
argument_list|,
name|ENGINE_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|p_surewarehk_Load_Privkey
argument_list|(
name|msg
argument_list|,
name|key_id
argument_list|,
operator|&
name|hptr
argument_list|,
operator|&
name|el
argument_list|,
operator|&
name|keytype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_LOAD_PRIVATE_KEY
argument_list|,
name|ENGINE_R_FAILED_LOADING_PRIVATE_KEY
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
name|res
operator|=
name|sureware_load_public
argument_list|(
name|e
argument_list|,
name|key_id
argument_list|,
name|hptr
argument_list|,
name|el
argument_list|,
name|keytype
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|EVP_PKEY
modifier|*
name|surewarehk_load_pubkey
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|el
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|hptr
init|=
name|NULL
decl_stmt|;
name|char
name|keytype
init|=
literal|0
decl_stmt|;
name|char
name|msg
index|[
literal|64
index|]
init|=
literal|"ENGINE_load_pubkey"
decl_stmt|;
if|if
condition|(
operator|!
name|p_surewarehk_Info_Pubkey
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_LOAD_PUBLIC_KEY
argument_list|,
name|ENGINE_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* call once to identify if DSA or RSA */
name|ret
operator|=
name|p_surewarehk_Info_Pubkey
argument_list|(
name|msg
argument_list|,
name|key_id
argument_list|,
operator|&
name|el
argument_list|,
operator|&
name|keytype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_LOAD_PUBLIC_KEY
argument_list|,
name|ENGINE_R_FAILED_LOADING_PUBLIC_KEY
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
name|res
operator|=
name|sureware_load_public
argument_list|(
name|e
argument_list|,
name|key_id
argument_list|,
name|hptr
argument_list|,
name|el
argument_list|,
name|keytype
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* This cleans up an RSA/DSA KM key(do not destroy the key into the hardware) , called when ex_data is freed */
end_comment

begin_function
specifier|static
name|void
name|surewarehk_ex_free
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|,
name|int
name|idx
parameter_list|,
name|long
name|argl
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_surewarehk_Free
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_EX_FREE
argument_list|,
name|ENGINE_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
block|}
else|else
name|p_surewarehk_Free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|item
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This cleans up an DH KM key (destroys the key into hardware),  called when ex_data is freed */
end_comment

begin_endif
unit|static void surewarehk_dh_ex_free(void *obj, void *item, CRYPTO_EX_DATA *ad, 	int idx,long argl, void *argp) { 	if(!p_surewarehk_Free) 	{ 		SUREWAREerr(SUREWARE_F_SUREWAREHK_EX_FREE,ENGINE_R_NOT_INITIALISED); 	} 	else 		p_surewarehk_Free((char *)item,1); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* * return number of decrypted bytes */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_function
specifier|static
name|int
name|surewarehk_rsa_priv_dec
parameter_list|(
name|int
name|flen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|from
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|int
name|padding
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|tlen
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|,
modifier|*
name|hptr
init|=
name|NULL
decl_stmt|;
name|char
name|msg
index|[
literal|64
index|]
init|=
literal|"ENGINE_rsa_priv_dec"
decl_stmt|;
if|if
condition|(
operator|!
name|p_surewarehk_Rsa_Priv_Dec
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC
argument_list|,
name|ENGINE_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
block|}
comment|/* extract ref to private key */
elseif|else
if|if
condition|(
operator|!
operator|(
name|hptr
operator|=
name|RSA_get_ex_data
argument_list|(
name|rsa
argument_list|,
name|rsaHndidx
argument_list|)
operator|)
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC
argument_list|,
name|SUREWARE_R_MISSING_KEY_COMPONENTS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* analyse what padding we can do into the hardware */
if|if
condition|(
name|padding
operator|==
name|RSA_PKCS1_PADDING
condition|)
block|{
comment|/* do it one shot */
name|ret
operator|=
name|p_surewarehk_Rsa_Priv_Dec
argument_list|(
name|msg
argument_list|,
name|flen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|from
argument_list|,
operator|&
name|tlen
argument_list|,
name|to
argument_list|,
name|hptr
argument_list|,
name|SUREWARE_PKCS1_PAD
argument_list|)
expr_stmt|;
name|surewarehk_error_handling
argument_list|(
name|msg
argument_list|,
name|SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|tlen
expr_stmt|;
block|}
else|else
comment|/* do with no padding into hardware */
block|{
name|ret
operator|=
name|p_surewarehk_Rsa_Priv_Dec
argument_list|(
name|msg
argument_list|,
name|flen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|from
argument_list|,
operator|&
name|tlen
argument_list|,
name|to
argument_list|,
name|hptr
argument_list|,
name|SUREWARE_NO_PAD
argument_list|)
expr_stmt|;
name|surewarehk_error_handling
argument_list|(
name|msg
argument_list|,
name|SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
goto|goto
name|err
goto|;
comment|/* intermediate buffer for padding */
if|if
condition|(
operator|(
name|buf
operator|=
name|OPENSSL_malloc
argument_list|(
name|tlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|RSAerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
name|to
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
comment|/* transfert to into buf */
switch|switch
condition|(
name|padding
condition|)
comment|/* check padding in software */
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA
case|case
name|RSA_PKCS1_OAEP_PADDING
case|:
name|ret
operator|=
name|RSA_padding_check_PKCS1_OAEP
argument_list|(
name|to
argument_list|,
name|tlen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
name|tlen
argument_list|,
name|tlen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|RSA_SSLV23_PADDING
case|:
name|ret
operator|=
name|RSA_padding_check_SSLv23
argument_list|(
name|to
argument_list|,
name|tlen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
name|flen
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSA_NO_PADDING
case|:
name|ret
operator|=
name|RSA_padding_check_none
argument_list|(
name|to
argument_list|,
name|tlen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
name|flen
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RSAerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC
argument_list|,
name|RSA_R_UNKNOWN_PADDING_TYPE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|RSAerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC
argument_list|,
name|RSA_R_PADDING_CHECK_FAILED
argument_list|)
expr_stmt|;
block|}
name|err
label|:
if|if
condition|(
name|buf
condition|)
block|{
name|OPENSSL_cleanse
argument_list|(
name|buf
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* * Does what OpenSSL rsa_priv_enc does. */
end_comment

begin_function
specifier|static
name|int
name|surewarehk_rsa_sign
parameter_list|(
name|int
name|flen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|from
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|int
name|padding
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|tlen
decl_stmt|;
name|char
modifier|*
name|hptr
init|=
name|NULL
decl_stmt|;
name|char
name|msg
index|[
literal|64
index|]
init|=
literal|"ENGINE_rsa_sign"
decl_stmt|;
if|if
condition|(
operator|!
name|p_surewarehk_Rsa_Sign
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_RSA_PRIV_ENC
argument_list|,
name|ENGINE_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
block|}
comment|/* extract ref to private key */
elseif|else
if|if
condition|(
operator|!
operator|(
name|hptr
operator|=
name|RSA_get_ex_data
argument_list|(
name|rsa
argument_list|,
name|rsaHndidx
argument_list|)
operator|)
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_RSA_PRIV_ENC
argument_list|,
name|SUREWARE_R_MISSING_KEY_COMPONENTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|padding
condition|)
block|{
case|case
name|RSA_PKCS1_PADDING
case|:
comment|/* do it in one shot */
name|ret
operator|=
name|p_surewarehk_Rsa_Sign
argument_list|(
name|msg
argument_list|,
name|flen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|from
argument_list|,
operator|&
name|tlen
argument_list|,
name|to
argument_list|,
name|hptr
argument_list|,
name|SUREWARE_PKCS1_PAD
argument_list|)
expr_stmt|;
name|surewarehk_error_handling
argument_list|(
name|msg
argument_list|,
name|SUREWARE_F_SUREWAREHK_RSA_PRIV_ENC
argument_list|,
name|ret
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSA_NO_PADDING
case|:
default|default:
name|RSAerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_RSA_PRIV_ENC
argument_list|,
name|RSA_R_UNKNOWN_PADDING_TYPE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
operator|==
literal|1
condition|?
name|tlen
else|:
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
end_ifndef

begin_comment
comment|/* DSA sign and verify */
end_comment

begin_function
specifier|static
name|DSA_SIG
modifier|*
name|surewarehk_dsa_do_sign
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|from
parameter_list|,
name|int
name|flen
parameter_list|,
name|DSA
modifier|*
name|dsa
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|hptr
init|=
name|NULL
decl_stmt|;
name|DSA_SIG
modifier|*
name|psign
init|=
name|NULL
decl_stmt|;
name|char
name|msg
index|[
literal|64
index|]
init|=
literal|"ENGINE_dsa_do_sign"
decl_stmt|;
if|if
condition|(
operator|!
name|p_surewarehk_Dsa_Sign
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_DSA_DO_SIGN
argument_list|,
name|ENGINE_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
block|}
comment|/* extract ref to private key */
elseif|else
if|if
condition|(
operator|!
operator|(
name|hptr
operator|=
name|DSA_get_ex_data
argument_list|(
name|dsa
argument_list|,
name|dsaHndidx
argument_list|)
operator|)
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_DSA_DO_SIGN
argument_list|,
name|SUREWARE_R_MISSING_KEY_COMPONENTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|psign
operator|=
name|DSA_SIG_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_DSA_DO_SIGN
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|psign
operator|->
name|r
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|psign
operator|->
name|s
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|bn_expand2
argument_list|(
name|psign
operator|->
name|r
argument_list|,
literal|20
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
expr_stmt|;
name|bn_expand2
argument_list|(
name|psign
operator|->
name|s
argument_list|,
literal|20
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|psign
operator|->
name|r
operator|||
name|psign
operator|->
name|r
operator|->
name|dmax
operator|!=
literal|20
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
operator|||
operator|!
name|psign
operator|->
name|s
operator|||
name|psign
operator|->
name|s
operator|->
name|dmax
operator|!=
literal|20
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|p_surewarehk_Dsa_Sign
argument_list|(
name|msg
argument_list|,
name|flen
argument_list|,
name|from
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|psign
operator|->
name|r
operator|->
name|d
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|psign
operator|->
name|s
operator|->
name|d
argument_list|,
name|hptr
argument_list|)
expr_stmt|;
name|surewarehk_error_handling
argument_list|(
name|msg
argument_list|,
name|SUREWARE_F_SUREWAREHK_DSA_DO_SIGN
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
name|psign
operator|->
name|r
operator|->
name|top
operator|=
literal|20
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|psign
operator|->
name|r
argument_list|)
expr_stmt|;
name|psign
operator|->
name|s
operator|->
name|top
operator|=
literal|20
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|psign
operator|->
name|s
argument_list|)
expr_stmt|;
name|err
label|:
if|if
condition|(
name|psign
condition|)
block|{
name|DSA_SIG_free
argument_list|(
name|psign
argument_list|)
expr_stmt|;
name|psign
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|psign
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|surewarehk_modexp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|char
name|msg
index|[
literal|64
index|]
init|=
literal|"ENGINE_modexp"
decl_stmt|;
if|if
condition|(
operator|!
name|p_surewarehk_Mod_Exp
condition|)
block|{
name|SUREWAREerr
argument_list|(
name|SUREWARE_F_SUREWAREHK_MOD_EXP
argument_list|,
name|ENGINE_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bn_expand2
argument_list|(
name|r
argument_list|,
name|m
operator|->
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&&
name|r
operator|->
name|dmax
operator|==
name|m
operator|->
name|top
condition|)
block|{
comment|/* do it*/
name|ret
operator|=
name|p_surewarehk_Mod_Exp
argument_list|(
name|msg
argument_list|,
name|m
operator|->
name|top
operator|*
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|m
operator|->
name|d
argument_list|,
name|p
operator|->
name|top
operator|*
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|p
operator|->
name|d
argument_list|,
name|a
operator|->
name|top
operator|*
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|a
operator|->
name|d
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|r
operator|->
name|d
argument_list|)
expr_stmt|;
name|surewarehk_error_handling
argument_list|(
name|msg
argument_list|,
name|SUREWARE_F_SUREWAREHK_MOD_EXP
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
comment|/* normalise result */
name|r
operator|->
name|top
operator|=
name|m
operator|->
name|top
expr_stmt|;
name|bn_fix_top
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_HW_SureWare */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_HW */
end_comment

end_unit

