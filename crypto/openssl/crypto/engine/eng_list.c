begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/engine/eng_list.c */
end_comment

begin_comment
comment|/* Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL  * project 2000.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1999-2001 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|"eng_int.h"
end_include

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_comment
comment|/* The linked-list of pointers to engine types. engine_list_head  * incorporates an implicit structural reference but engine_list_tail  * does not - the latter is a computational niceity and only points  * to something that is already pointed to by its predecessor in the  * list (or engine_list_head itself). In the same way, the use of the  * "prev" pointer in each ENGINE is to save excessive list iteration,  * it doesn't correspond to an extra structural reference. Hence,  * engine_list_head, and each non-null "next" pointer account for  * the list itself assuming exactly 1 structural reference on each  * list member. */
end_comment

begin_decl_stmt
specifier|static
name|ENGINE
modifier|*
name|engine_list_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ENGINE
modifier|*
name|engine_list_tail
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This cleanup function is only needed internally. If it should be called, we  * register it with the "ENGINE_cleanup()" stack to be called during cleanup. */
end_comment

begin_function
specifier|static
name|void
name|engine_list_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|ENGINE
modifier|*
name|iterator
init|=
name|engine_list_head
decl_stmt|;
while|while
condition|(
name|iterator
operator|!=
name|NULL
condition|)
block|{
name|ENGINE_remove
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|engine_list_head
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* These static functions starting with a lower case "engine_" always  * take place when CRYPTO_LOCK_ENGINE has been locked up. */
end_comment

begin_function
specifier|static
name|int
name|engine_list_add
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|int
name|conflict
init|=
literal|0
decl_stmt|;
name|ENGINE
modifier|*
name|iterator
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_LIST_ADD
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|iterator
operator|=
name|engine_list_head
expr_stmt|;
while|while
condition|(
name|iterator
operator|&&
operator|!
name|conflict
condition|)
block|{
name|conflict
operator|=
operator|(
name|strcmp
argument_list|(
name|iterator
operator|->
name|id
argument_list|,
name|e
operator|->
name|id
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|iterator
operator|=
name|iterator
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|conflict
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_LIST_ADD
argument_list|,
name|ENGINE_R_CONFLICTING_ENGINE_ID
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|engine_list_head
operator|==
name|NULL
condition|)
block|{
comment|/* We are adding to an empty list. */
if|if
condition|(
name|engine_list_tail
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_LIST_ADD
argument_list|,
name|ENGINE_R_INTERNAL_LIST_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|engine_list_head
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* The first time the list allocates, we should register the 		 * cleanup. */
name|engine_cleanup_add_last
argument_list|(
name|engine_list_cleanup
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We are adding to the tail of an existing list. */
if|if
condition|(
operator|(
name|engine_list_tail
operator|==
name|NULL
operator|)
operator|||
operator|(
name|engine_list_tail
operator|->
name|next
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_LIST_ADD
argument_list|,
name|ENGINE_R_INTERNAL_LIST_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|engine_list_tail
operator|->
name|next
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|prev
operator|=
name|engine_list_tail
expr_stmt|;
block|}
comment|/* Having the engine in the list assumes a structural 	 * reference. */
name|e
operator|->
name|struct_ref
operator|++
expr_stmt|;
name|engine_ref_debug
argument_list|(
argument|e
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
comment|/* However it came to be, e is the last item in the list. */
name|engine_list_tail
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|engine_list_remove
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|ENGINE
modifier|*
name|iterator
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_LIST_REMOVE
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We need to check that e is in our linked list! */
name|iterator
operator|=
name|engine_list_head
expr_stmt|;
while|while
condition|(
name|iterator
operator|&&
operator|(
name|iterator
operator|!=
name|e
operator|)
condition|)
name|iterator
operator|=
name|iterator
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|iterator
operator|==
name|NULL
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_LIST_REMOVE
argument_list|,
name|ENGINE_R_ENGINE_IS_NOT_IN_LIST
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* un-link e from the chain. */
if|if
condition|(
name|e
operator|->
name|next
condition|)
name|e
operator|->
name|next
operator|->
name|prev
operator|=
name|e
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|prev
condition|)
name|e
operator|->
name|prev
operator|->
name|next
operator|=
name|e
operator|->
name|next
expr_stmt|;
comment|/* Correct our head/tail if necessary. */
if|if
condition|(
name|engine_list_head
operator|==
name|e
condition|)
name|engine_list_head
operator|=
name|e
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|engine_list_tail
operator|==
name|e
condition|)
name|engine_list_tail
operator|=
name|e
operator|->
name|prev
expr_stmt|;
name|engine_free_util
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Get the first/last "ENGINE" type available. */
end_comment

begin_function
name|ENGINE
modifier|*
name|ENGINE_get_first
parameter_list|(
name|void
parameter_list|)
block|{
name|ENGINE
modifier|*
name|ret
decl_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|engine_list_head
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ret
operator|->
name|struct_ref
operator|++
expr_stmt|;
name|engine_ref_debug
argument_list|(
argument|ret
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|ENGINE
modifier|*
name|ENGINE_get_last
parameter_list|(
name|void
parameter_list|)
block|{
name|ENGINE
modifier|*
name|ret
decl_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|engine_list_tail
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ret
operator|->
name|struct_ref
operator|++
expr_stmt|;
name|engine_ref_debug
argument_list|(
argument|ret
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Iterate to the next/previous "ENGINE" type (NULL = end of the list). */
end_comment

begin_function
name|ENGINE
modifier|*
name|ENGINE_get_next
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|ENGINE
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_GET_NEXT
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|e
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Return a valid structural refernce to the next ENGINE */
name|ret
operator|->
name|struct_ref
operator|++
expr_stmt|;
name|engine_ref_debug
argument_list|(
argument|ret
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
comment|/* Release the structural reference to the previous ENGINE */
name|ENGINE_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|ENGINE
modifier|*
name|ENGINE_get_prev
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|ENGINE
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_GET_PREV
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|e
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Return a valid structural reference to the next ENGINE */
name|ret
operator|->
name|struct_ref
operator|++
expr_stmt|;
name|engine_ref_debug
argument_list|(
argument|ret
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
comment|/* Release the structural reference to the previous ENGINE */
name|ENGINE_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Add another "ENGINE" type into the list. */
end_comment

begin_function
name|int
name|ENGINE_add
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|int
name|to_return
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_ADD
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|e
operator|->
name|id
operator|==
name|NULL
operator|)
operator|||
operator|(
name|e
operator|->
name|name
operator|==
name|NULL
operator|)
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_ADD
argument_list|,
name|ENGINE_R_ID_OR_NAME_MISSING
argument_list|)
expr_stmt|;
block|}
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|engine_list_add
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_ADD
argument_list|,
name|ENGINE_R_INTERNAL_LIST_ERROR
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|0
expr_stmt|;
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_comment
comment|/* Remove an existing "ENGINE" type from the array. */
end_comment

begin_function
name|int
name|ENGINE_remove
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|int
name|to_return
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_REMOVE
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|engine_list_remove
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_REMOVE
argument_list|,
name|ENGINE_R_INTERNAL_LIST_ERROR
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|0
expr_stmt|;
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|engine_cpy
parameter_list|(
name|ENGINE
modifier|*
name|dest
parameter_list|,
specifier|const
name|ENGINE
modifier|*
name|src
parameter_list|)
block|{
name|dest
operator|->
name|id
operator|=
name|src
operator|->
name|id
expr_stmt|;
name|dest
operator|->
name|name
operator|=
name|src
operator|->
name|name
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|dest
operator|->
name|rsa_meth
operator|=
name|src
operator|->
name|rsa_meth
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
name|dest
operator|->
name|dsa_meth
operator|=
name|src
operator|->
name|dsa_meth
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
name|dest
operator|->
name|dh_meth
operator|=
name|src
operator|->
name|dh_meth
expr_stmt|;
endif|#
directive|endif
name|dest
operator|->
name|rand_meth
operator|=
name|src
operator|->
name|rand_meth
expr_stmt|;
name|dest
operator|->
name|ciphers
operator|=
name|src
operator|->
name|ciphers
expr_stmt|;
name|dest
operator|->
name|digests
operator|=
name|src
operator|->
name|digests
expr_stmt|;
name|dest
operator|->
name|destroy
operator|=
name|src
operator|->
name|destroy
expr_stmt|;
name|dest
operator|->
name|init
operator|=
name|src
operator|->
name|init
expr_stmt|;
name|dest
operator|->
name|finish
operator|=
name|src
operator|->
name|finish
expr_stmt|;
name|dest
operator|->
name|ctrl
operator|=
name|src
operator|->
name|ctrl
expr_stmt|;
name|dest
operator|->
name|load_privkey
operator|=
name|src
operator|->
name|load_privkey
expr_stmt|;
name|dest
operator|->
name|load_pubkey
operator|=
name|src
operator|->
name|load_pubkey
expr_stmt|;
name|dest
operator|->
name|cmd_defns
operator|=
name|src
operator|->
name|cmd_defns
expr_stmt|;
name|dest
operator|->
name|flags
operator|=
name|src
operator|->
name|flags
expr_stmt|;
block|}
end_function

begin_function
name|ENGINE
modifier|*
name|ENGINE_by_id
parameter_list|(
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|ENGINE
modifier|*
name|iterator
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_BY_ID
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|engine_list_head
expr_stmt|;
while|while
condition|(
name|iterator
operator|&&
operator|(
name|strcmp
argument_list|(
name|id
argument_list|,
name|iterator
operator|->
name|id
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|iterator
operator|=
name|iterator
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|iterator
condition|)
block|{
comment|/* We need to return a structural reference. If this is an 		 * ENGINE type that returns copies, make a duplicate - otherwise 		 * increment the existing ENGINE's reference count. */
if|if
condition|(
name|iterator
operator|->
name|flags
operator|&
name|ENGINE_FLAGS_BY_ID_COPY
condition|)
block|{
name|ENGINE
modifier|*
name|cp
init|=
name|ENGINE_new
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|iterator
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|engine_cpy
argument_list|(
name|cp
argument_list|,
name|iterator
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|cp
expr_stmt|;
block|}
block|}
else|else
block|{
name|iterator
operator|->
name|struct_ref
operator|++
expr_stmt|;
name|engine_ref_debug
argument_list|(
argument|iterator
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|}
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterator
operator|==
name|NULL
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_BY_ID
argument_list|,
name|ENGINE_R_NO_SUCH_ENGINE
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"id="
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
return|return
name|iterator
return|;
block|}
end_function

begin_function
name|int
name|ENGINE_up_ref
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_ENGINE_UP_REF
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CRYPTO_add
argument_list|(
operator|&
name|e
operator|->
name|struct_ref
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

