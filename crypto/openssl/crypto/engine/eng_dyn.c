begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/engine/eng_dyn.c */
end_comment

begin_comment
comment|/* Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL  * project 2001.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1999-2001 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|"eng_int.h"
end_include

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_include
include|#
directive|include
file|<openssl/dso.h>
end_include

begin_comment
comment|/* Shared libraries implementing ENGINEs for use by the "dynamic" ENGINE loader  * should implement the hook-up functions with the following prototypes. */
end_comment

begin_comment
comment|/* Our ENGINE handlers */
end_comment

begin_function_decl
specifier|static
name|int
name|dynamic_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dynamic_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dynamic_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Predeclare our context type */
end_comment

begin_typedef
typedef|typedef
name|struct
name|st_dynamic_data_ctx
name|dynamic_data_ctx
typedef|;
end_typedef

begin_comment
comment|/* The implementation for the important control command */
end_comment

begin_function_decl
specifier|static
name|int
name|dynamic_load
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|dynamic_data_ctx
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DYNAMIC_CMD_SO_PATH
value|ENGINE_CMD_BASE
end_define

begin_define
define|#
directive|define
name|DYNAMIC_CMD_NO_VCHECK
value|(ENGINE_CMD_BASE + 1)
end_define

begin_define
define|#
directive|define
name|DYNAMIC_CMD_ID
value|(ENGINE_CMD_BASE + 2)
end_define

begin_define
define|#
directive|define
name|DYNAMIC_CMD_LIST_ADD
value|(ENGINE_CMD_BASE + 3)
end_define

begin_define
define|#
directive|define
name|DYNAMIC_CMD_LOAD
value|(ENGINE_CMD_BASE + 4)
end_define

begin_comment
comment|/* The constants used when creating the ENGINE */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_dynamic_id
init|=
literal|"dynamic"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_dynamic_name
init|=
literal|"Dynamic engine loading support"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|ENGINE_CMD_DEFN
name|dynamic_cmd_defns
index|[]
init|=
block|{
block|{
name|DYNAMIC_CMD_SO_PATH
block|,
literal|"SO_PATH"
block|,
literal|"Specifies the path to the new ENGINE shared library"
block|,
name|ENGINE_CMD_FLAG_STRING
block|}
block|,
block|{
name|DYNAMIC_CMD_NO_VCHECK
block|,
literal|"NO_VCHECK"
block|,
literal|"Specifies to continue even if version checking fails (boolean)"
block|,
name|ENGINE_CMD_FLAG_NUMERIC
block|}
block|,
block|{
name|DYNAMIC_CMD_ID
block|,
literal|"ID"
block|,
literal|"Specifies an ENGINE id name for loading"
block|,
name|ENGINE_CMD_FLAG_STRING
block|}
block|,
block|{
name|DYNAMIC_CMD_LIST_ADD
block|,
literal|"LIST_ADD"
block|,
literal|"Whether to add a loaded ENGINE to the internal list (0=no,1=yes,2=mandatory)"
block|,
name|ENGINE_CMD_FLAG_NUMERIC
block|}
block|,
block|{
name|DYNAMIC_CMD_LOAD
block|,
literal|"LOAD"
block|,
literal|"Load up the ENGINE specified by other settings"
block|,
name|ENGINE_CMD_FLAG_NO_INPUT
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|ENGINE_CMD_DEFN
name|dynamic_cmd_defns_empty
index|[]
init|=
block|{
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Loading code stores state inside the ENGINE structure via the "ex_data"  * element. We load all our state into a single structure and use that as a  * single context in the "ex_data" stack. */
end_comment

begin_struct
struct|struct
name|st_dynamic_data_ctx
block|{
comment|/* The DSO object we load that supplies the ENGINE code */
name|DSO
modifier|*
name|dynamic_dso
decl_stmt|;
comment|/* The function pointer to the version checking shared library function */
name|dynamic_v_check_fn
name|v_check
decl_stmt|;
comment|/* The function pointer to the engine-binding shared library function */
name|dynamic_bind_engine
name|bind_engine
decl_stmt|;
comment|/* The default name/path for loading the shared library */
specifier|const
name|char
modifier|*
name|DYNAMIC_LIBNAME
decl_stmt|;
comment|/* Whether to continue loading on a version check failure */
name|int
name|no_vcheck
decl_stmt|;
comment|/* If non-NULL, stipulates the 'id' of the ENGINE to be loaded */
specifier|const
name|char
modifier|*
name|engine_id
decl_stmt|;
comment|/* If non-zero, a successfully loaded ENGINE should be added to the internal 	 * ENGINE list. If 2, the add must succeed or the entire load should fail. */
name|int
name|list_add_value
decl_stmt|;
comment|/* The symbol name for the version checking function */
specifier|const
name|char
modifier|*
name|DYNAMIC_F1
decl_stmt|;
comment|/* The symbol name for the "initialise ENGINE structure" function */
specifier|const
name|char
modifier|*
name|DYNAMIC_F2
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is the "ex_data" index we obtain and reserve for use with our context  * structure. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dynamic_ex_data_idx
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Because our ex_data element may or may not get allocated depending on whether  * a "first-use" occurs before the ENGINE is freed, we have a memory leak  * problem to solve. We can't declare a "new" handler for the ex_data as we  * don't want a dynamic_data_ctx in *all* ENGINE structures of all types (this  * is a bug in the design of CRYPTO_EX_DATA). As such, we just declare a "free"  * handler and that will get called if an ENGINE is being destroyed and there  * was an ex_data element corresponding to our context type. */
end_comment

begin_function
specifier|static
name|void
name|dynamic_data_ctx_free_func
parameter_list|(
name|void
modifier|*
name|parent
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|,
name|int
name|idx
parameter_list|,
name|long
name|argl
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|)
block|{
if|if
condition|(
name|ptr
condition|)
block|{
name|dynamic_data_ctx
modifier|*
name|ctx
init|=
operator|(
name|dynamic_data_ctx
operator|*
operator|)
name|ptr
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|dynamic_dso
condition|)
name|DSO_free
argument_list|(
name|ctx
operator|->
name|dynamic_dso
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|DYNAMIC_LIBNAME
condition|)
name|OPENSSL_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ctx
operator|->
name|DYNAMIC_LIBNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|engine_id
condition|)
name|OPENSSL_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ctx
operator|->
name|engine_id
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Construct the per-ENGINE context. We create it blindly and then use a lock to  * check for a race - if so, all but one of the threads "racing" will have  * wasted their time. The alternative involves creating everything inside the  * lock which is far worse. */
end_comment

begin_function
specifier|static
name|int
name|dynamic_set_data_ctx
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|dynamic_data_ctx
modifier|*
modifier|*
name|ctx
parameter_list|)
block|{
name|dynamic_data_ctx
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dynamic_data_ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_SET_DATA_CTX
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memset
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dynamic_data_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|dynamic_dso
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|v_check
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|bind_engine
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|DYNAMIC_LIBNAME
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|no_vcheck
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|engine_id
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|list_add_value
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|DYNAMIC_F1
operator|=
literal|"v_check"
expr_stmt|;
name|c
operator|->
name|DYNAMIC_F2
operator|=
literal|"bind_engine"
expr_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ctx
operator|=
operator|(
name|dynamic_data_ctx
operator|*
operator|)
name|ENGINE_get_ex_data
argument_list|(
name|e
argument_list|,
name|dynamic_ex_data_idx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Good, we're the first */
name|ENGINE_set_ex_data
argument_list|(
name|e
argument_list|,
name|dynamic_ex_data_idx
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|*
name|ctx
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|NULL
expr_stmt|;
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
comment|/* If we lost the race to set the context, c is non-NULL and *ctx is the 	 * context of the thread that won. */
if|if
condition|(
name|c
condition|)
name|OPENSSL_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This function retrieves the context structure from an ENGINE's "ex_data", or  * if it doesn't exist yet, sets it up. */
end_comment

begin_function
specifier|static
name|dynamic_data_ctx
modifier|*
name|dynamic_get_data_ctx
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|dynamic_data_ctx
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|dynamic_ex_data_idx
operator|<
literal|0
condition|)
block|{
comment|/* Create and register the ENGINE ex_data, and associate our 		 * "free" function with it to ensure any allocated contexts get 		 * freed when an ENGINE goes underground. */
name|int
name|new_idx
init|=
name|ENGINE_get_ex_new_index
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dynamic_data_ctx_free_func
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_idx
operator|==
operator|-
literal|1
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_DYNAMIC_GET_DATA_CTX
argument_list|,
name|ENGINE_R_NO_INDEX
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
comment|/* Avoid a race by checking again inside this lock */
if|if
condition|(
name|dynamic_ex_data_idx
operator|<
literal|0
condition|)
block|{
comment|/* Good, someone didn't beat us to it */
name|dynamic_ex_data_idx
operator|=
name|new_idx
expr_stmt|;
name|new_idx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
comment|/* In theory we could "give back" the index here if 		 * (new_idx>-1), but it's not possible and wouldn't gain us much 		 * if it were. */
block|}
name|ctx
operator|=
operator|(
name|dynamic_data_ctx
operator|*
operator|)
name|ENGINE_get_ex_data
argument_list|(
name|e
argument_list|,
name|dynamic_ex_data_idx
argument_list|)
expr_stmt|;
comment|/* Check if the context needs to be created */
if|if
condition|(
operator|(
name|ctx
operator|==
name|NULL
operator|)
operator|&&
operator|!
name|dynamic_set_data_ctx
argument_list|(
name|e
argument_list|,
operator|&
name|ctx
argument_list|)
condition|)
comment|/* "set_data" will set errors if necessary */
return|return
name|NULL
return|;
return|return
name|ctx
return|;
block|}
end_function

begin_function
specifier|static
name|ENGINE
modifier|*
name|engine_dynamic
parameter_list|(
name|void
parameter_list|)
block|{
name|ENGINE
modifier|*
name|ret
init|=
name|ENGINE_new
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|ENGINE_set_id
argument_list|(
name|ret
argument_list|,
name|engine_dynamic_id
argument_list|)
operator|||
operator|!
name|ENGINE_set_name
argument_list|(
name|ret
argument_list|,
name|engine_dynamic_name
argument_list|)
operator|||
operator|!
name|ENGINE_set_init_function
argument_list|(
name|ret
argument_list|,
name|dynamic_init
argument_list|)
operator|||
operator|!
name|ENGINE_set_finish_function
argument_list|(
name|ret
argument_list|,
name|dynamic_finish
argument_list|)
operator|||
operator|!
name|ENGINE_set_ctrl_function
argument_list|(
name|ret
argument_list|,
name|dynamic_ctrl
argument_list|)
operator|||
operator|!
name|ENGINE_set_flags
argument_list|(
name|ret
argument_list|,
name|ENGINE_FLAGS_BY_ID_COPY
argument_list|)
operator|||
operator|!
name|ENGINE_set_cmd_defns
argument_list|(
name|ret
argument_list|,
name|dynamic_cmd_defns
argument_list|)
condition|)
block|{
name|ENGINE_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|ENGINE_load_dynamic
parameter_list|(
name|void
parameter_list|)
block|{
name|ENGINE
modifier|*
name|toadd
init|=
name|engine_dynamic
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|toadd
condition|)
return|return;
name|ENGINE_add
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
comment|/* If the "add" worked, it gets a structural reference. So either way, 	 * we release our just-created reference. */
name|ENGINE_free
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
comment|/* If the "add" didn't work, it was probably a conflict because it was 	 * already added (eg. someone calling ENGINE_load_blah then calling 	 * ENGINE_load_builtin_engines() perhaps). */
name|ERR_clear_error
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dynamic_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
comment|/* We always return failure - the "dyanamic" engine itself can't be used 	 * for anything. */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dynamic_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
comment|/* This should never be called on account of "dynamic_init" always 	 * failing. */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dynamic_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
parameter_list|)
block|{
name|dynamic_data_ctx
modifier|*
name|ctx
init|=
name|dynamic_get_data_ctx
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|int
name|initialised
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_DYNAMIC_CTRL
argument_list|,
name|ENGINE_R_NOT_LOADED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|initialised
operator|=
operator|(
operator|(
name|ctx
operator|->
name|dynamic_dso
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
comment|/* All our control commands require the ENGINE to be uninitialised */
if|if
condition|(
name|initialised
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_DYNAMIC_CTRL
argument_list|,
name|ENGINE_R_ALREADY_LOADED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DYNAMIC_CMD_SO_PATH
case|:
comment|/* a NULL 'p' or a string of zero-length is the same thing */
if|if
condition|(
name|p
operator|&&
operator|(
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|)
operator|<
literal|1
operator|)
condition|)
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|DYNAMIC_LIBNAME
condition|)
name|OPENSSL_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ctx
operator|->
name|DYNAMIC_LIBNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|ctx
operator|->
name|DYNAMIC_LIBNAME
operator|=
name|BUF_strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|ctx
operator|->
name|DYNAMIC_LIBNAME
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ctx
operator|->
name|DYNAMIC_LIBNAME
condition|?
literal|1
else|:
literal|0
operator|)
return|;
case|case
name|DYNAMIC_CMD_NO_VCHECK
case|:
name|ctx
operator|->
name|no_vcheck
operator|=
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|DYNAMIC_CMD_ID
case|:
comment|/* a NULL 'p' or a string of zero-length is the same thing */
if|if
condition|(
name|p
operator|&&
operator|(
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|)
operator|<
literal|1
operator|)
condition|)
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|engine_id
condition|)
name|OPENSSL_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ctx
operator|->
name|engine_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|ctx
operator|->
name|engine_id
operator|=
name|BUF_strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|ctx
operator|->
name|engine_id
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ctx
operator|->
name|engine_id
condition|?
literal|1
else|:
literal|0
operator|)
return|;
case|case
name|DYNAMIC_CMD_LIST_ADD
case|:
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|>
literal|2
operator|)
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_DYNAMIC_CTRL
argument_list|,
name|ENGINE_R_INVALID_ARGUMENT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ctx
operator|->
name|list_add_value
operator|=
operator|(
name|int
operator|)
name|i
expr_stmt|;
return|return
literal|1
return|;
case|case
name|DYNAMIC_CMD_LOAD
case|:
return|return
name|dynamic_load
argument_list|(
name|e
argument_list|,
name|ctx
argument_list|)
return|;
default|default:
break|break;
block|}
name|ENGINEerr
argument_list|(
name|ENGINE_F_DYNAMIC_CTRL
argument_list|,
name|ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dynamic_load
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|dynamic_data_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|ENGINE
name|cpy
decl_stmt|;
name|dynamic_fns
name|fns
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|DYNAMIC_LIBNAME
operator|||
operator|(
operator|(
name|ctx
operator|->
name|dynamic_dso
operator|=
name|DSO_load
argument_list|(
name|NULL
argument_list|,
name|ctx
operator|->
name|DYNAMIC_LIBNAME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ENGINE_F_DYNAMIC_LOAD
argument_list|,
name|ENGINE_R_DSO_NOT_FOUND
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We have to find a bind function otherwise it'll always end badly */
if|if
condition|(
operator|!
operator|(
name|ctx
operator|->
name|bind_engine
operator|=
operator|(
name|dynamic_bind_engine
operator|)
name|DSO_bind_func
argument_list|(
name|ctx
operator|->
name|dynamic_dso
argument_list|,
name|ctx
operator|->
name|DYNAMIC_F2
argument_list|)
operator|)
condition|)
block|{
name|ctx
operator|->
name|bind_engine
operator|=
name|NULL
expr_stmt|;
name|DSO_free
argument_list|(
name|ctx
operator|->
name|dynamic_dso
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|dynamic_dso
operator|=
name|NULL
expr_stmt|;
name|ENGINEerr
argument_list|(
name|ENGINE_F_DYNAMIC_LOAD
argument_list|,
name|ENGINE_R_DSO_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Do we perform version checking? */
if|if
condition|(
operator|!
name|ctx
operator|->
name|no_vcheck
condition|)
block|{
name|unsigned
name|long
name|vcheck_res
init|=
literal|0
decl_stmt|;
comment|/* Now we try to find a version checking function and decide how 		 * to cope with failure if/when it fails. */
name|ctx
operator|->
name|v_check
operator|=
operator|(
name|dynamic_v_check_fn
operator|)
name|DSO_bind_func
argument_list|(
name|ctx
operator|->
name|dynamic_dso
argument_list|,
name|ctx
operator|->
name|DYNAMIC_F1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|v_check
condition|)
name|vcheck_res
operator|=
name|ctx
operator|->
name|v_check
argument_list|(
name|OSSL_DYNAMIC_VERSION
argument_list|)
expr_stmt|;
comment|/* We fail if the version checker veto'd the load *or* if it is 		 * deferring to us (by returning its version) and we think it is 		 * too old. */
if|if
condition|(
name|vcheck_res
operator|<
name|OSSL_DYNAMIC_OLDEST
condition|)
block|{
comment|/* Fail */
name|ctx
operator|->
name|bind_engine
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|v_check
operator|=
name|NULL
expr_stmt|;
name|DSO_free
argument_list|(
name|ctx
operator|->
name|dynamic_dso
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|dynamic_dso
operator|=
name|NULL
expr_stmt|;
name|ENGINEerr
argument_list|(
name|ENGINE_F_DYNAMIC_LOAD
argument_list|,
name|ENGINE_R_VERSION_INCOMPATIBILITY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* First binary copy the ENGINE structure so that we can roll back if 	 * the hand-over fails */
name|memcpy
argument_list|(
operator|&
name|cpy
argument_list|,
name|e
argument_list|,
sizeof|sizeof
argument_list|(
name|ENGINE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Provide the ERR, "ex_data", memory, and locking callbacks so the 	 * loaded library uses our state rather than its own. FIXME: As noted in 	 * engine.h, much of this would be simplified if each area of code 	 * provided its own "summary" structure of all related callbacks. It 	 * would also increase opaqueness. */
name|fns
operator|.
name|err_fns
operator|=
name|ERR_get_implementation
argument_list|()
expr_stmt|;
name|fns
operator|.
name|ex_data_fns
operator|=
name|CRYPTO_get_ex_data_implementation
argument_list|()
expr_stmt|;
name|CRYPTO_get_mem_functions
argument_list|(
operator|&
name|fns
operator|.
name|mem_fns
operator|.
name|malloc_cb
argument_list|,
operator|&
name|fns
operator|.
name|mem_fns
operator|.
name|realloc_cb
argument_list|,
operator|&
name|fns
operator|.
name|mem_fns
operator|.
name|free_cb
argument_list|)
expr_stmt|;
name|fns
operator|.
name|lock_fns
operator|.
name|lock_locking_cb
operator|=
name|CRYPTO_get_locking_callback
argument_list|()
expr_stmt|;
name|fns
operator|.
name|lock_fns
operator|.
name|lock_add_lock_cb
operator|=
name|CRYPTO_get_add_lock_callback
argument_list|()
expr_stmt|;
name|fns
operator|.
name|lock_fns
operator|.
name|dynlock_create_cb
operator|=
name|CRYPTO_get_dynlock_create_callback
argument_list|()
expr_stmt|;
name|fns
operator|.
name|lock_fns
operator|.
name|dynlock_lock_cb
operator|=
name|CRYPTO_get_dynlock_lock_callback
argument_list|()
expr_stmt|;
name|fns
operator|.
name|lock_fns
operator|.
name|dynlock_destroy_cb
operator|=
name|CRYPTO_get_dynlock_destroy_callback
argument_list|()
expr_stmt|;
comment|/* Now that we've loaded the dynamic engine, make sure no "dynamic" 	 * ENGINE elements will show through. */
name|engine_set_all_null
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Try to bind the ENGINE onto our own ENGINE structure */
if|if
condition|(
operator|!
name|ctx
operator|->
name|bind_engine
argument_list|(
name|e
argument_list|,
name|ctx
operator|->
name|engine_id
argument_list|,
operator|&
name|fns
argument_list|)
condition|)
block|{
name|ctx
operator|->
name|bind_engine
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|v_check
operator|=
name|NULL
expr_stmt|;
name|DSO_free
argument_list|(
name|ctx
operator|->
name|dynamic_dso
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|dynamic_dso
operator|=
name|NULL
expr_stmt|;
name|ENGINEerr
argument_list|(
name|ENGINE_F_DYNAMIC_LOAD
argument_list|,
name|ENGINE_R_INIT_FAILED
argument_list|)
expr_stmt|;
comment|/* Copy the original ENGINE structure back */
name|memcpy
argument_list|(
name|e
argument_list|,
operator|&
name|cpy
argument_list|,
sizeof|sizeof
argument_list|(
name|ENGINE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Do we try to add this ENGINE to the internal list too? */
if|if
condition|(
name|ctx
operator|->
name|list_add_value
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ENGINE_add
argument_list|(
name|e
argument_list|)
condition|)
block|{
comment|/* Do we tolerate this or fail? */
if|if
condition|(
name|ctx
operator|->
name|list_add_value
operator|>
literal|1
condition|)
block|{
comment|/* Fail - NB: By this time, it's too late to 				 * rollback, and trying to do so allows the 				 * bind_engine() code to have created leaks. We 				 * just have to fail where we are, after the 				 * ENGINE has changed. */
name|ENGINEerr
argument_list|(
name|ENGINE_F_DYNAMIC_LOAD
argument_list|,
name|ENGINE_R_CONFLICTING_ENGINE_ID
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Tolerate */
name|ERR_clear_error
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

