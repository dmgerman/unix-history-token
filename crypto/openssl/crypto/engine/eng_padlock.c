begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Support for VIA PadLock Advanced Cryptography Engine (ACE)  * Written by Michal Ludvig<michal@logix.cz>  *            http://www.logix.cz/michal  *  * Big thanks to Andy Polyakov for a help with optimization,   * assembler fixes, port to MS Windows and a lot of other   * valuable work on this engine!  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1999-2001 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/opensslconf.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/dso.h>
end_include

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_AES
end_ifndef

begin_include
include|#
directive|include
file|<openssl/aes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HW
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HW_PADLOCK
end_ifndef

begin_comment
comment|/* Attempt to have a single source for both 0.9.7 and 0.9.8 :-) */
end_comment

begin_if
if|#
directive|if
operator|(
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x00908000L
operator|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DYNAMIC_ENGINE
end_ifndef

begin_define
define|#
directive|define
name|DYNAMIC_ENGINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_elif
elif|#
directive|elif
operator|(
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x00907000L
operator|)
end_elif

begin_ifdef
ifdef|#
directive|ifdef
name|ENGINE_DYNAMIC_SUPPORT
end_ifdef

begin_define
define|#
directive|define
name|DYNAMIC_ENGINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"Only OpenSSL>= 0.9.7 is supported"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VIA PadLock AES is available *ONLY* on some x86 CPUs.    Not only that it doesn't exist elsewhere, but it    even can't be compiled on other platforms!      In addition, because of the heavy use of inline assembler,    compiler choice is limited to GCC and Microsoft C. */
end_comment

begin_undef
undef|#
directive|undef
name|COMPILE_HW_PADLOCK
end_undef

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|I386_ONLY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_INLINE_ASM
argument_list|)
end_if

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386
argument_list|)
operator|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_M_IX86
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|COMPILE_HW_PADLOCK
end_define

begin_function_decl
specifier|static
name|ENGINE
modifier|*
name|ENGINE_padlock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|ENGINE_load_padlock
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* On non-x86 CPUs it just returns. */
ifdef|#
directive|ifdef
name|COMPILE_HW_PADLOCK
name|ENGINE
modifier|*
name|toadd
init|=
name|ENGINE_padlock
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|toadd
condition|)
return|return;
name|ENGINE_add
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ENGINE_free
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_HW_PADLOCK
end_ifdef

begin_comment
comment|/* We do these includes here to avoid header problems on platforms that    do not have the VIA padlock anyway... */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_define
define|#
directive|define
name|alloca
value|_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Function for ENGINE detection and control */
end_comment

begin_function_decl
specifier|static
name|int
name|padlock_available
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|padlock_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* RNG Stuff */
end_comment

begin_decl_stmt
specifier|static
name|RAND_METHOD
name|padlock_rand
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cipher Stuff */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_AES
end_ifndef

begin_function_decl
specifier|static
name|int
name|padlock_ciphers
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|EVP_CIPHER
modifier|*
modifier|*
name|cipher
parameter_list|,
specifier|const
name|int
modifier|*
modifier|*
name|nids
parameter_list|,
name|int
name|nid
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Engine names */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|padlock_id
init|=
literal|"padlock"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|padlock_name
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Available features */
end_comment

begin_decl_stmt
specifier|static
name|int
name|padlock_use_ace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Advanced Cryptography Engine */
end_comment

begin_decl_stmt
specifier|static
name|int
name|padlock_use_rng
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Random Number Generator */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_AES
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|padlock_aes_align_required
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ===== Engine "management" functions ===== */
end_comment

begin_comment
comment|/* Prepare the ENGINE structure for registration */
end_comment

begin_function
specifier|static
name|int
name|padlock_bind_helper
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
comment|/* Check available features */
name|padlock_available
argument_list|()
expr_stmt|;
if|#
directive|if
literal|1
comment|/* disable RNG for now, see commentary in vicinity of RNG code */
name|padlock_use_rng
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Generate a nice engine name with available features */
name|BIO_snprintf
argument_list|(
name|padlock_name
argument_list|,
sizeof|sizeof
argument_list|(
name|padlock_name
argument_list|)
argument_list|,
literal|"VIA PadLock (%s, %s)"
argument_list|,
name|padlock_use_rng
condition|?
literal|"RNG"
else|:
literal|"no-RNG"
argument_list|,
name|padlock_use_ace
condition|?
literal|"ACE"
else|:
literal|"no-ACE"
argument_list|)
expr_stmt|;
comment|/* Register everything or return with an error */
if|if
condition|(
operator|!
name|ENGINE_set_id
argument_list|(
name|e
argument_list|,
name|padlock_id
argument_list|)
operator|||
operator|!
name|ENGINE_set_name
argument_list|(
name|e
argument_list|,
name|padlock_name
argument_list|)
operator|||
operator|!
name|ENGINE_set_init_function
argument_list|(
name|e
argument_list|,
name|padlock_init
argument_list|)
operator|||
ifndef|#
directive|ifndef
name|OPENSSL_NO_AES
operator|(
name|padlock_use_ace
operator|&&
operator|!
name|ENGINE_set_ciphers
argument_list|(
name|e
argument_list|,
name|padlock_ciphers
argument_list|)
operator|)
operator|||
endif|#
directive|endif
operator|(
name|padlock_use_rng
operator|&&
operator|!
name|ENGINE_set_RAND
argument_list|(
name|e
argument_list|,
operator|&
name|padlock_rand
argument_list|)
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* Everything looks good */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Constructor */
end_comment

begin_function
specifier|static
name|ENGINE
modifier|*
name|ENGINE_padlock
parameter_list|(
name|void
parameter_list|)
block|{
name|ENGINE
modifier|*
name|eng
init|=
name|ENGINE_new
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|eng
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|padlock_bind_helper
argument_list|(
name|eng
argument_list|)
condition|)
block|{
name|ENGINE_free
argument_list|(
name|eng
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|eng
return|;
block|}
end_function

begin_comment
comment|/* Check availability of the engine */
end_comment

begin_function
specifier|static
name|int
name|padlock_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
return|return
operator|(
name|padlock_use_rng
operator|||
name|padlock_use_ace
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This stuff is needed if this ENGINE is being compiled into a self-contained  * shared-library.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DYNAMIC_ENGINE
end_ifdef

begin_function
specifier|static
name|int
name|padlock_bind_fn
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|&&
operator|(
name|strcmp
argument_list|(
name|id
argument_list|,
name|padlock_id
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|padlock_bind_helper
argument_list|(
name|e
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_expr_stmt
name|IMPLEMENT_DYNAMIC_CHECK_FN
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IMPLEMENT_DYNAMIC_BIND_FN
argument_list|(
name|padlock_bind_fn
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DYNAMIC_ENGINE */
end_comment

begin_comment
comment|/* ===== Here comes the "real" engine ===== */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_AES
end_ifndef

begin_comment
comment|/* Some AES-related constants */
end_comment

begin_define
define|#
directive|define
name|AES_BLOCK_SIZE
value|16
end_define

begin_define
define|#
directive|define
name|AES_KEY_SIZE_128
value|16
end_define

begin_define
define|#
directive|define
name|AES_KEY_SIZE_192
value|24
end_define

begin_define
define|#
directive|define
name|AES_KEY_SIZE_256
value|32
end_define

begin_comment
comment|/* Here we store the status information relevant to the     current context. */
end_comment

begin_comment
comment|/* BIG FAT WARNING:  * 	Inline assembler in PADLOCK_XCRYPT_ASM()  * 	depends on the order of items in this structure.  * 	Don't blindly modify, reorder, etc!  */
end_comment

begin_struct
struct|struct
name|padlock_cipher_data
block|{
name|unsigned
name|char
name|iv
index|[
name|AES_BLOCK_SIZE
index|]
decl_stmt|;
comment|/* Initialization vector */
union|union
block|{
name|unsigned
name|int
name|pad
index|[
literal|4
index|]
decl_stmt|;
struct|struct
block|{
name|int
name|rounds
range|:
literal|4
decl_stmt|;
name|int
name|dgst
range|:
literal|1
decl_stmt|;
comment|/* n/a in C3 */
name|int
name|align
range|:
literal|1
decl_stmt|;
comment|/* n/a in C3 */
name|int
name|ciphr
range|:
literal|1
decl_stmt|;
comment|/* n/a in C3 */
name|unsigned
name|int
name|keygen
range|:
literal|1
decl_stmt|;
name|int
name|interm
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|encdec
range|:
literal|1
decl_stmt|;
name|int
name|ksize
range|:
literal|2
decl_stmt|;
block|}
name|b
struct|;
block|}
name|cword
union|;
comment|/* Control word */
name|AES_KEY
name|ks
decl_stmt|;
comment|/* Encryption key */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Essentially this variable belongs in thread local storage.  * Having this variable global on the other hand can only cause  * few bogus key reloads [if any at all on single-CPU system],  * so we accept the penatly...  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|struct
name|padlock_cipher_data
modifier|*
name|padlock_saved_context
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * =======================================================  * Inline assembler section(s).  * =======================================================  * Order of arguments is chosen to facilitate Windows port  * using __fastcall calling convention. If you wish to add  * more routines, keep in mind that first __fastcall  * argument is passed in %ecx and second - in %edx.  * =======================================================  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|2
end_if

begin_comment
comment|/*  * As for excessive "push %ebx"/"pop %ebx" found all over.  * When generating position-independent code GCC won't let  * us use "b" in assembler templates nor even respect "ebx"  * in "clobber description." Therefore the trouble...  */
end_comment

begin_comment
comment|/* Helper function - check if a CPUID instruction    is available on this CPU */
end_comment

begin_function
specifier|static
name|int
name|padlock_insn_cpuid_available
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
comment|/* We're checking if the bit #21 of EFLAGS  	   can be toggled. If yes = CPUID is available. */
asm|asm
specifier|volatile
asm|( 		"pushf\n" 		"popl %%eax\n" 		"xorl $0x200000, %%eax\n" 		"movl %%eax, %%ecx\n" 		"andl $0x200000, %%ecx\n" 		"pushl %%eax\n" 		"popf\n" 		"pushf\n" 		"popl %%eax\n" 		"andl $0x200000, %%eax\n" 		"xorl %%eax, %%ecx\n" 		"movl %%ecx, %0\n" 		: "=r" (result) : : "eax", "ecx");
return|return
operator|(
name|result
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Load supported features of the CPU to see if    the PadLock is available. */
end_comment

begin_function
specifier|static
name|int
name|padlock_available
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|vendor_string
index|[
literal|16
index|]
decl_stmt|;
name|unsigned
name|int
name|eax
decl_stmt|,
name|edx
decl_stmt|;
comment|/* First check if the CPUID instruction is available at all... */
if|if
condition|(
operator|!
name|padlock_insn_cpuid_available
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* Are we running on the Centaur (VIA) CPU? */
name|eax
operator|=
literal|0x00000000
expr_stmt|;
name|vendor_string
index|[
literal|12
index|]
operator|=
literal|0
expr_stmt|;
asm|asm
specifier|volatile
asm|( 		"pushl	%%ebx\n" 		"cpuid\n" 		"movl	%%ebx,(%%edi)\n" 		"movl	%%edx,4(%%edi)\n" 		"movl	%%ecx,8(%%edi)\n" 		"popl	%%ebx" 		: "+a"(eax) : "D"(vendor_string) : "ecx", "edx");
if|if
condition|(
name|strcmp
argument_list|(
name|vendor_string
argument_list|,
literal|"CentaurHauls"
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Check for Centaur Extended Feature Flags presence */
name|eax
operator|=
literal|0xC0000000
expr_stmt|;
asm|asm
specifier|volatile
asm|("pushl %%ebx; cpuid; popl	%%ebx" 		: "+a"(eax) : : "ecx", "edx");
if|if
condition|(
name|eax
operator|<
literal|0xC0000001
condition|)
return|return
literal|0
return|;
comment|/* Read the Centaur Extended Feature Flags */
name|eax
operator|=
literal|0xC0000001
expr_stmt|;
asm|asm
specifier|volatile
asm|("pushl %%ebx; cpuid; popl %%ebx" 		: "+a"(eax), "=d"(edx) : : "ecx");
comment|/* Fill up some flags */
name|padlock_use_ace
operator|=
operator|(
operator|(
name|edx
operator|&
operator|(
literal|0x3
operator|<<
literal|6
operator|)
operator|)
operator|==
operator|(
literal|0x3
operator|<<
literal|6
operator|)
operator|)
expr_stmt|;
name|padlock_use_rng
operator|=
operator|(
operator|(
name|edx
operator|&
operator|(
literal|0x3
operator|<<
literal|2
operator|)
operator|)
operator|==
operator|(
literal|0x3
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
return|return
name|padlock_use_ace
operator|+
name|padlock_use_rng
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_AES
end_ifndef

begin_comment
comment|/* Our own htonl()/ntohl() */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|padlock_bswapl
parameter_list|(
name|AES_KEY
modifier|*
name|ks
parameter_list|)
block|{
name|size_t
name|i
init|=
sizeof|sizeof
argument_list|(
name|ks
operator|->
name|rd_key
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ks
operator|->
name|rd_key
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|unsigned
name|int
modifier|*
name|key
init|=
name|ks
operator|->
name|rd_key
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
asm|asm
specifier|volatile
asm|("bswapl %0" : "+r"(*key));
name|key
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Force key reload from memory to the CPU microcode.    Loading EFLAGS from the stack clears EFLAGS[30]     which does the trick. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|padlock_reload_key
parameter_list|(
name|void
parameter_list|)
block|{
asm|asm
specifier|volatile
asm|("pushfl; popfl");
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_AES
end_ifndef

begin_comment
comment|/*  * This is heuristic key context tracing. At first one  * believes that one should use atomic swap instructions,  * but it's not actually necessary. Point is that if  * padlock_saved_context was changed by another thread  * after we've read it and before we compare it with cdata,  * our key *shall* be reloaded upon thread context switch  * and we are therefore set in either case...  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|padlock_verify_context
parameter_list|(
name|struct
name|padlock_cipher_data
modifier|*
name|cdata
parameter_list|)
block|{
asm|asm
specifier|volatile
asm|( 	"pushfl\n" "	btl	$30,(%%esp)\n" "	jnc	1f\n" "	cmpl	%2,%1\n" "	je	1f\n" "	popfl\n" "	subl	$4,%%esp\n" "1:	addl	$4,%%esp\n" "	movl	%2,%0" 	:"+m"(padlock_saved_context) 	: "r"(padlock_saved_context), "r"(cdata) : "cc");
block|}
end_function

begin_comment
comment|/* Template for padlock_xcrypt_* modes */
end_comment

begin_comment
comment|/* BIG FAT WARNING:   * 	The offsets used with 'leal' instructions  * 	describe items of the 'padlock_cipher_data'  * 	structure.  */
end_comment

begin_define
define|#
directive|define
name|PADLOCK_XCRYPT_ASM
parameter_list|(
name|name
parameter_list|,
name|rep_xcrypt
parameter_list|)
define|\
value|static inline void *name(size_t cnt,		\ 	struct padlock_cipher_data *cdata,	\ 	void *out, const void *inp) 		\ {	void *iv; 				\ 	asm volatile ( "pushl	%%ebx\n"	\ 		"	leal	16(%0),%%edx\n"	\ 		"	leal	32(%0),%%ebx\n"	\ 			rep_xcrypt "\n"		\ 		"	popl	%%ebx"		\ 		: "=a"(iv), "=c"(cnt), "=D"(out), "=S"(inp) \ 		: "0"(cdata), "1"(cnt), "2"(out), "3"(inp) \ 		: "edx", "cc");			\ 	return iv;				\ }
end_define

begin_comment
comment|/* Generate all functions with appropriate opcodes */
end_comment

begin_macro
name|PADLOCK_XCRYPT_ASM
argument_list|(
argument|padlock_xcrypt_ecb
argument_list|,
literal|".byte 0xf3,0x0f,0xa7,0xc8"
argument_list|)
end_macro

begin_comment
comment|/* rep xcryptecb */
end_comment

begin_macro
name|PADLOCK_XCRYPT_ASM
argument_list|(
argument|padlock_xcrypt_cbc
argument_list|,
literal|".byte 0xf3,0x0f,0xa7,0xd0"
argument_list|)
end_macro

begin_comment
comment|/* rep xcryptcbc */
end_comment

begin_macro
name|PADLOCK_XCRYPT_ASM
argument_list|(
argument|padlock_xcrypt_cfb
argument_list|,
literal|".byte 0xf3,0x0f,0xa7,0xe0"
argument_list|)
end_macro

begin_comment
comment|/* rep xcryptcfb */
end_comment

begin_macro
name|PADLOCK_XCRYPT_ASM
argument_list|(
argument|padlock_xcrypt_ofb
argument_list|,
literal|".byte 0xf3,0x0f,0xa7,0xe8"
argument_list|)
end_macro

begin_comment
comment|/* rep xcryptofb */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The RNG call itself */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|padlock_xstore
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|unsigned
name|int
name|edx_in
parameter_list|)
block|{
name|unsigned
name|int
name|eax_out
decl_stmt|;
asm|asm
specifier|volatile
asm|(".byte 0x0f,0xa7,0xc0"
comment|/* xstore */
asm|: "=a"(eax_out),"=m"(*(unsigned *)addr) 	    : "D"(addr), "d" (edx_in) 	    );
return|return
name|eax_out
return|;
block|}
end_function

begin_comment
comment|/* Why not inline 'rep movsd'? I failed to find information on what  * value in Direction Flag one can expect and consequently have to  * apply "better-safe-than-sorry" approach and assume "undefined."  * I could explicitly clear it and restore the original value upon  * return from padlock_aes_cipher, but it's presumably too much  * trouble for too little gain...  *  * In case you wonder 'rep xcrypt*' instructions above are *not*  * affected by the Direction Flag and pointers advance toward  * larger addresses unconditionally.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|char
modifier|*
name|padlock_memcpy
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|long
modifier|*
name|d
init|=
name|dst
decl_stmt|;
specifier|const
name|long
modifier|*
name|s
init|=
name|src
decl_stmt|;
name|n
operator|/=
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
do|do
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
return|return
name|dst
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_elif

begin_comment
comment|/*  * Unlike GCC these are real functions. In order to minimize impact  * on performance we adhere to __fastcall calling convention in  * order to get two first arguments passed through %ecx and %edx.  * Which kind of suits very well, as instructions in question use  * both %ecx and %edx as input:-)  */
end_comment

begin_define
define|#
directive|define
name|REP_XCRYPT
parameter_list|(
name|code
parameter_list|)
define|\
value|_asm _emit 0xf3			\ 	_asm _emit 0x0f _asm _emit 0xa7	\ 	_asm _emit code
end_define

begin_comment
comment|/* BIG FAT WARNING:   * 	The offsets used with 'lea' instructions  * 	describe items of the 'padlock_cipher_data'  * 	structure.  */
end_comment

begin_define
define|#
directive|define
name|PADLOCK_XCRYPT_ASM
parameter_list|(
name|name
parameter_list|,
name|code
parameter_list|)
define|\
value|static void * __fastcall 		\ 	name (size_t cnt, void *cdata,	\ 	void *outp, const void *inp)	\ {	_asm	mov	eax,edx		\ 	_asm	lea	edx,[eax+16]	\ 	_asm	lea	ebx,[eax+32]	\ 	_asm	mov	edi,outp	\ 	_asm	mov	esi,inp		\ 	REP_XCRYPT(code)		\ }
end_define

begin_macro
name|PADLOCK_XCRYPT_ASM
argument_list|(
argument|padlock_xcrypt_ecb
argument_list|,
literal|0xc8
argument_list|)
end_macro

begin_macro
name|PADLOCK_XCRYPT_ASM
argument_list|(
argument|padlock_xcrypt_cbc
argument_list|,
literal|0xd0
argument_list|)
end_macro

begin_macro
name|PADLOCK_XCRYPT_ASM
argument_list|(
argument|padlock_xcrypt_cfb
argument_list|,
literal|0xe0
argument_list|)
end_macro

begin_macro
name|PADLOCK_XCRYPT_ASM
argument_list|(
argument|padlock_xcrypt_ofb
argument_list|,
literal|0xe8
argument_list|)
end_macro

begin_function
specifier|static
name|int
name|__fastcall
name|padlock_xstore
parameter_list|(
name|void
modifier|*
name|outp
parameter_list|,
name|unsigned
name|int
name|code
parameter_list|)
block|{
name|_asm
name|mov
name|edi
decl_stmt|,
name|ecx
name|_asm
name|_emit
decl|0x0f
name|_asm
name|_emit
decl|0xa7
name|_asm
name|_emit
decl|0xc0
block|}
end_function

begin_function
specifier|static
name|void
name|__fastcall
name|padlock_reload_key
parameter_list|(
name|void
parameter_list|)
block|{
name|_asm
name|pushfd
name|_asm
name|popfd
block|}
end_function

begin_function
specifier|static
name|void
name|__fastcall
name|padlock_verify_context
parameter_list|(
name|void
modifier|*
name|cdata
parameter_list|)
block|{
name|_asm
block|{
name|pushfd
name|bt
name|DWORD
name|PTR
index|[
name|esp
index|]
decl_stmt|,30
name|jnc
name|skip
name|cmp
name|ecx
decl_stmt|,
name|padlock_saved_context
name|je
name|skip
name|popfd
name|sub
name|esp
decl_stmt|,4
name|skip
range|:
name|add
name|esp
decl_stmt|,4
name|mov
name|padlock_saved_context
decl_stmt|,
name|ecx
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|padlock_available
parameter_list|(
name|void
parameter_list|)
block|{
name|_asm
block|{
name|pushfd
name|pop
name|eax
name|mov
name|ecx
decl_stmt|,
name|eax
name|xor
name|eax
decl_stmt|,1<<21
name|push
name|eax
name|popfd
name|pushfd
name|pop
name|eax
name|xor
name|eax
decl_stmt|,
name|ecx
name|bt
name|eax
decl_stmt|,21
name|jnc
name|noluck
name|mov
name|eax
decl_stmt|,0
name|cpuid
name|xor
name|eax
decl_stmt|,
name|eax
name|cmp
name|ebx
decl_stmt|,'tneC'
name|jne
name|noluck
name|cmp
name|edx
decl_stmt|,'Hrua'
name|jne
name|noluck
name|cmp
name|ecx
decl_stmt|,'slua'
name|jne
name|noluck
name|mov
name|eax
decl_stmt|,0xC0000000
name|cpuid
name|mov
name|edx
decl_stmt|,
name|eax
name|xor
name|eax
decl_stmt|,
name|eax
name|cmp
name|edx
decl_stmt|,0xC0000001
name|jb
name|noluck
name|mov
name|eax
decl_stmt|,0xC0000001
name|cpuid
name|xor
name|eax
decl_stmt|,
name|eax
name|bt
name|edx
decl_stmt|,6
name|jnc
name|skip_a
name|bt
name|edx
decl_stmt|,7
name|jnc
name|skip_a
name|mov
name|padlock_use_ace
decl_stmt|,1
name|inc
name|eax
name|skip_a
range|:
name|bt
name|edx
decl_stmt|,2
name|jnc
name|skip_r
name|bt
name|edx
decl_stmt|,3
name|jnc
name|skip_r
name|mov
name|padlock_use_rng
decl_stmt|,1
name|inc
name|eax
name|skip_r
range|:
name|noluck
operator|:
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__fastcall
name|padlock_bswapl
parameter_list|(
name|void
modifier|*
name|key
parameter_list|)
block|{
name|_asm
block|{
name|pushfd
name|cld
name|mov
name|esi
decl_stmt|,
name|ecx
name|mov
name|edi
decl_stmt|,
name|ecx
name|mov
name|ecx
decl_stmt|,60
name|up
range|:
name|lodsd
name|bswap
name|eax
name|stosd
name|loop
name|up
name|popfd
block|}
block|}
end_function

begin_comment
comment|/* MS actually specifies status of Direction Flag and compiler even  * manages to compile following as 'rep movsd' all by itself...  */
end_comment

begin_define
define|#
directive|define
name|padlock_memcpy
parameter_list|(
name|o
parameter_list|,
name|i
parameter_list|,
name|n
parameter_list|)
value|((unsigned char *)memcpy((o),(i),(n)&~3U))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ===== AES encryption/decryption ===== */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_AES
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NID_aes_128_cfb128
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NID_aes_128_cfb
argument_list|)
end_if

begin_define
define|#
directive|define
name|NID_aes_128_cfb
value|NID_aes_128_cfb128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NID_aes_128_ofb128
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NID_aes_128_ofb
argument_list|)
end_if

begin_define
define|#
directive|define
name|NID_aes_128_ofb
value|NID_aes_128_ofb128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NID_aes_192_cfb128
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NID_aes_192_cfb
argument_list|)
end_if

begin_define
define|#
directive|define
name|NID_aes_192_cfb
value|NID_aes_192_cfb128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NID_aes_192_ofb128
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NID_aes_192_ofb
argument_list|)
end_if

begin_define
define|#
directive|define
name|NID_aes_192_ofb
value|NID_aes_192_ofb128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NID_aes_256_cfb128
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NID_aes_256_cfb
argument_list|)
end_if

begin_define
define|#
directive|define
name|NID_aes_256_cfb
value|NID_aes_256_cfb128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NID_aes_256_ofb128
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NID_aes_256_ofb
argument_list|)
end_if

begin_define
define|#
directive|define
name|NID_aes_256_ofb
value|NID_aes_256_ofb128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* List of supported ciphers. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|padlock_cipher_nids
index|[]
init|=
block|{
name|NID_aes_128_ecb
block|,
name|NID_aes_128_cbc
block|,
name|NID_aes_128_cfb
block|,
name|NID_aes_128_ofb
block|,
name|NID_aes_192_ecb
block|,
name|NID_aes_192_cbc
block|,
name|NID_aes_192_cfb
block|,
name|NID_aes_192_ofb
block|,
name|NID_aes_256_ecb
block|,
name|NID_aes_256_cbc
block|,
name|NID_aes_256_cfb
block|,
name|NID_aes_256_ofb
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|padlock_cipher_nids_num
init|=
operator|(
sizeof|sizeof
argument_list|(
name|padlock_cipher_nids
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|padlock_cipher_nids
index|[
literal|0
index|]
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function prototypes ... */
end_comment

begin_function_decl
specifier|static
name|int
name|padlock_aes_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|padlock_aes_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NEAREST_ALIGNED
parameter_list|(
name|ptr
parameter_list|)
value|( (unsigned char *)(ptr) +		\ 	( (0x10 - ((size_t)(ptr)& 0x0F))& 0x0F )	)
end_define

begin_define
define|#
directive|define
name|ALIGNED_CIPHER_DATA
parameter_list|(
name|ctx
parameter_list|)
value|((struct padlock_cipher_data *)\ 	NEAREST_ALIGNED(ctx->cipher_data))
end_define

begin_define
define|#
directive|define
name|EVP_CIPHER_block_size_ECB
value|AES_BLOCK_SIZE
end_define

begin_define
define|#
directive|define
name|EVP_CIPHER_block_size_CBC
value|AES_BLOCK_SIZE
end_define

begin_define
define|#
directive|define
name|EVP_CIPHER_block_size_OFB
value|1
end_define

begin_define
define|#
directive|define
name|EVP_CIPHER_block_size_CFB
value|1
end_define

begin_comment
comment|/* Declaring so many ciphers by hand would be a pain.    Instead introduce a bit of preprocessor magic :-) */
end_comment

begin_define
define|#
directive|define
name|DECLARE_AES_EVP
parameter_list|(
name|ksize
parameter_list|,
name|lmode
parameter_list|,
name|umode
parameter_list|)
define|\
value|static const EVP_CIPHER padlock_aes_##ksize##_##lmode = {	\ 	NID_aes_##ksize##_##lmode,		\ 	EVP_CIPHER_block_size_##umode,	\ 	AES_KEY_SIZE_##ksize,		\ 	AES_BLOCK_SIZE,			\ 	0 | EVP_CIPH_##umode##_MODE,	\ 	padlock_aes_init_key,		\ 	padlock_aes_cipher,		\ 	NULL,				\ 	sizeof(struct padlock_cipher_data) + 16,	\ 	EVP_CIPHER_set_asn1_iv,		\ 	EVP_CIPHER_get_asn1_iv,		\ 	NULL,				\ 	NULL				\ }
end_define

begin_expr_stmt
name|DECLARE_AES_EVP
argument_list|(
literal|128
argument_list|,
name|ecb
argument_list|,
name|ECB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_AES_EVP
argument_list|(
literal|128
argument_list|,
name|cbc
argument_list|,
name|CBC
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_AES_EVP
argument_list|(
literal|128
argument_list|,
name|cfb
argument_list|,
name|CFB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_AES_EVP
argument_list|(
literal|128
argument_list|,
name|ofb
argument_list|,
name|OFB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_AES_EVP
argument_list|(
literal|192
argument_list|,
name|ecb
argument_list|,
name|ECB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_AES_EVP
argument_list|(
literal|192
argument_list|,
name|cbc
argument_list|,
name|CBC
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_AES_EVP
argument_list|(
literal|192
argument_list|,
name|cfb
argument_list|,
name|CFB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_AES_EVP
argument_list|(
literal|192
argument_list|,
name|ofb
argument_list|,
name|OFB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_AES_EVP
argument_list|(
literal|256
argument_list|,
name|ecb
argument_list|,
name|ECB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_AES_EVP
argument_list|(
literal|256
argument_list|,
name|cbc
argument_list|,
name|CBC
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_AES_EVP
argument_list|(
literal|256
argument_list|,
name|cfb
argument_list|,
name|CFB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_AES_EVP
argument_list|(
literal|256
argument_list|,
name|ofb
argument_list|,
name|OFB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|padlock_ciphers
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|EVP_CIPHER
modifier|*
modifier|*
name|cipher
parameter_list|,
specifier|const
name|int
modifier|*
modifier|*
name|nids
parameter_list|,
name|int
name|nid
parameter_list|)
block|{
comment|/* No specific cipher => return a list of supported nids ... */
if|if
condition|(
operator|!
name|cipher
condition|)
block|{
operator|*
name|nids
operator|=
name|padlock_cipher_nids
expr_stmt|;
return|return
name|padlock_cipher_nids_num
return|;
block|}
comment|/* ... or the requested "cipher" otherwise */
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
name|NID_aes_128_ecb
case|:
operator|*
name|cipher
operator|=
operator|&
name|padlock_aes_128_ecb
expr_stmt|;
break|break;
case|case
name|NID_aes_128_cbc
case|:
operator|*
name|cipher
operator|=
operator|&
name|padlock_aes_128_cbc
expr_stmt|;
break|break;
case|case
name|NID_aes_128_cfb
case|:
operator|*
name|cipher
operator|=
operator|&
name|padlock_aes_128_cfb
expr_stmt|;
break|break;
case|case
name|NID_aes_128_ofb
case|:
operator|*
name|cipher
operator|=
operator|&
name|padlock_aes_128_ofb
expr_stmt|;
break|break;
case|case
name|NID_aes_192_ecb
case|:
operator|*
name|cipher
operator|=
operator|&
name|padlock_aes_192_ecb
expr_stmt|;
break|break;
case|case
name|NID_aes_192_cbc
case|:
operator|*
name|cipher
operator|=
operator|&
name|padlock_aes_192_cbc
expr_stmt|;
break|break;
case|case
name|NID_aes_192_cfb
case|:
operator|*
name|cipher
operator|=
operator|&
name|padlock_aes_192_cfb
expr_stmt|;
break|break;
case|case
name|NID_aes_192_ofb
case|:
operator|*
name|cipher
operator|=
operator|&
name|padlock_aes_192_ofb
expr_stmt|;
break|break;
case|case
name|NID_aes_256_ecb
case|:
operator|*
name|cipher
operator|=
operator|&
name|padlock_aes_256_ecb
expr_stmt|;
break|break;
case|case
name|NID_aes_256_cbc
case|:
operator|*
name|cipher
operator|=
operator|&
name|padlock_aes_256_cbc
expr_stmt|;
break|break;
case|case
name|NID_aes_256_cfb
case|:
operator|*
name|cipher
operator|=
operator|&
name|padlock_aes_256_cfb
expr_stmt|;
break|break;
case|case
name|NID_aes_256_ofb
case|:
operator|*
name|cipher
operator|=
operator|&
name|padlock_aes_256_ofb
expr_stmt|;
break|break;
default|default:
comment|/* Sorry, we don't support this NID */
operator|*
name|cipher
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Prepare the encryption key for PadLock usage */
end_comment

begin_function
specifier|static
name|int
name|padlock_aes_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|struct
name|padlock_cipher_data
modifier|*
name|cdata
decl_stmt|;
name|int
name|key_len
init|=
name|EVP_CIPHER_CTX_key_length
argument_list|(
name|ctx
argument_list|)
operator|*
literal|8
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* ERROR */
name|cdata
operator|=
name|ALIGNED_CIPHER_DATA
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|padlock_cipher_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepare Control word. */
if|if
condition|(
name|EVP_CIPHER_CTX_mode
argument_list|(
name|ctx
argument_list|)
operator|==
name|EVP_CIPH_OFB_MODE
condition|)
name|cdata
operator|->
name|cword
operator|.
name|b
operator|.
name|encdec
operator|=
literal|0
expr_stmt|;
else|else
name|cdata
operator|->
name|cword
operator|.
name|b
operator|.
name|encdec
operator|=
operator|(
name|ctx
operator|->
name|encrypt
operator|==
literal|0
operator|)
expr_stmt|;
name|cdata
operator|->
name|cword
operator|.
name|b
operator|.
name|rounds
operator|=
literal|10
operator|+
operator|(
name|key_len
operator|-
literal|128
operator|)
operator|/
literal|32
expr_stmt|;
name|cdata
operator|->
name|cword
operator|.
name|b
operator|.
name|ksize
operator|=
operator|(
name|key_len
operator|-
literal|128
operator|)
operator|/
literal|64
expr_stmt|;
switch|switch
condition|(
name|key_len
condition|)
block|{
case|case
literal|128
case|:
comment|/* PadLock can generate an extended key for 			   AES128 in hardware */
name|memcpy
argument_list|(
name|cdata
operator|->
name|ks
operator|.
name|rd_key
argument_list|,
name|key
argument_list|,
name|AES_KEY_SIZE_128
argument_list|)
expr_stmt|;
name|cdata
operator|->
name|cword
operator|.
name|b
operator|.
name|keygen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|192
case|:
case|case
literal|256
case|:
comment|/* Generate an extended AES key in software. 			   Needed for AES192/AES256 */
comment|/* Well, the above applies to Stepping 8 CPUs 			   and is listed as hardware errata. They most 			   likely will fix it at some point and then 			   a check for stepping would be due here. */
if|if
condition|(
name|EVP_CIPHER_CTX_mode
argument_list|(
name|ctx
argument_list|)
operator|==
name|EVP_CIPH_CFB_MODE
operator|||
name|EVP_CIPHER_CTX_mode
argument_list|(
name|ctx
argument_list|)
operator|==
name|EVP_CIPH_OFB_MODE
operator|||
name|enc
condition|)
name|AES_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|key_len
argument_list|,
operator|&
name|cdata
operator|->
name|ks
argument_list|)
expr_stmt|;
else|else
name|AES_set_decrypt_key
argument_list|(
name|key
argument_list|,
name|key_len
argument_list|,
operator|&
name|cdata
operator|->
name|ks
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|AES_ASM
comment|/* OpenSSL C functions use byte-swapped extended key. */
name|padlock_bswapl
argument_list|(
operator|&
name|cdata
operator|->
name|ks
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cdata
operator|->
name|cword
operator|.
name|b
operator|.
name|keygen
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* ERROR */
return|return
literal|0
return|;
block|}
comment|/* 	 * This is done to cover for cases when user reuses the 	 * context for new key. The catch is that if we don't do 	 * this, padlock_eas_cipher might proceed with old key... 	 */
name|padlock_reload_key
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*   * Simplified version of padlock_aes_cipher() used when  * 1) both input and output buffers are at aligned addresses.  * or when  * 2) running on a newer CPU that doesn't require aligned buffers.  */
end_comment

begin_function
specifier|static
name|int
name|padlock_aes_cipher_omnivorous
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out_arg
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in_arg
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|struct
name|padlock_cipher_data
modifier|*
name|cdata
decl_stmt|;
name|void
modifier|*
name|iv
decl_stmt|;
name|cdata
operator|=
name|ALIGNED_CIPHER_DATA
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|padlock_verify_context
argument_list|(
name|cdata
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|EVP_CIPHER_CTX_mode
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
case|case
name|EVP_CIPH_ECB_MODE
case|:
name|padlock_xcrypt_ecb
argument_list|(
name|nbytes
operator|/
name|AES_BLOCK_SIZE
argument_list|,
name|cdata
argument_list|,
name|out_arg
argument_list|,
name|in_arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVP_CIPH_CBC_MODE
case|:
name|memcpy
argument_list|(
name|cdata
operator|->
name|iv
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|iv
operator|=
name|padlock_xcrypt_cbc
argument_list|(
name|nbytes
operator|/
name|AES_BLOCK_SIZE
argument_list|,
name|cdata
argument_list|,
name|out_arg
argument_list|,
name|in_arg
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVP_CIPH_CFB_MODE
case|:
name|memcpy
argument_list|(
name|cdata
operator|->
name|iv
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|iv
operator|=
name|padlock_xcrypt_cfb
argument_list|(
name|nbytes
operator|/
name|AES_BLOCK_SIZE
argument_list|,
name|cdata
argument_list|,
name|out_arg
argument_list|,
name|in_arg
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVP_CIPH_OFB_MODE
case|:
name|memcpy
argument_list|(
name|cdata
operator|->
name|iv
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|padlock_xcrypt_ofb
argument_list|(
name|nbytes
operator|/
name|AES_BLOCK_SIZE
argument_list|,
name|cdata
argument_list|,
name|out_arg
argument_list|,
name|in_arg
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
name|cdata
operator|->
name|iv
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
name|memset
argument_list|(
name|cdata
operator|->
name|iv
argument_list|,
literal|0
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|PADLOCK_CHUNK
end_ifndef

begin_define
define|#
directive|define
name|PADLOCK_CHUNK
value|512
end_define

begin_comment
comment|/* Must be a power of 2 larger than 16 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|PADLOCK_CHUNK
operator|<
literal|16
operator|||
name|PADLOCK_CHUNK
operator|&
operator|(
name|PADLOCK_CHUNK
operator|-
literal|1
operator|)
end_if

begin_error
error|#
directive|error
literal|"insane PADLOCK_CHUNK..."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Re-align the arguments to 16-Bytes boundaries and run the     encryption function itself. This function is not AES-specific. */
end_comment

begin_function
specifier|static
name|int
name|padlock_aes_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out_arg
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in_arg
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|struct
name|padlock_cipher_data
modifier|*
name|cdata
decl_stmt|;
specifier|const
name|void
modifier|*
name|inp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|out
decl_stmt|;
name|void
modifier|*
name|iv
decl_stmt|;
name|int
name|inp_misaligned
decl_stmt|,
name|out_misaligned
decl_stmt|,
name|realign_in_loop
decl_stmt|;
name|size_t
name|chunk
decl_stmt|,
name|allocated
init|=
literal|0
decl_stmt|;
comment|/* ctx->num is maintained in byte-oriented modes, 	   such as CFB and OFB... */
if|if
condition|(
operator|(
name|chunk
operator|=
name|ctx
operator|->
name|num
operator|)
condition|)
block|{
comment|/* borrow chunk variable */
name|unsigned
name|char
modifier|*
name|ivp
init|=
name|ctx
operator|->
name|iv
decl_stmt|;
switch|switch
condition|(
name|EVP_CIPHER_CTX_mode
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
case|case
name|EVP_CIPH_CFB_MODE
case|:
if|if
condition|(
name|chunk
operator|>=
name|AES_BLOCK_SIZE
condition|)
return|return
literal|0
return|;
comment|/* bogus value */
if|if
condition|(
name|ctx
operator|->
name|encrypt
condition|)
while|while
condition|(
name|chunk
operator|<
name|AES_BLOCK_SIZE
operator|&&
name|nbytes
operator|!=
literal|0
condition|)
block|{
name|ivp
index|[
name|chunk
index|]
operator|=
operator|*
operator|(
name|out_arg
operator|++
operator|)
operator|=
operator|*
operator|(
name|in_arg
operator|++
operator|)
operator|^
name|ivp
index|[
name|chunk
index|]
expr_stmt|;
name|chunk
operator|++
operator|,
name|nbytes
operator|--
expr_stmt|;
block|}
else|else
while|while
condition|(
name|chunk
operator|<
name|AES_BLOCK_SIZE
operator|&&
name|nbytes
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
operator|(
name|in_arg
operator|++
operator|)
decl_stmt|;
operator|*
operator|(
name|out_arg
operator|++
operator|)
operator|=
name|c
operator|^
name|ivp
index|[
name|chunk
index|]
expr_stmt|;
name|ivp
index|[
name|chunk
operator|++
index|]
operator|=
name|c
operator|,
name|nbytes
operator|--
expr_stmt|;
block|}
name|ctx
operator|->
name|num
operator|=
name|chunk
operator|%
name|AES_BLOCK_SIZE
expr_stmt|;
break|break;
case|case
name|EVP_CIPH_OFB_MODE
case|:
if|if
condition|(
name|chunk
operator|>=
name|AES_BLOCK_SIZE
condition|)
return|return
literal|0
return|;
comment|/* bogus value */
while|while
condition|(
name|chunk
operator|<
name|AES_BLOCK_SIZE
operator|&&
name|nbytes
operator|!=
literal|0
condition|)
block|{
operator|*
operator|(
name|out_arg
operator|++
operator|)
operator|=
operator|*
operator|(
name|in_arg
operator|++
operator|)
operator|^
name|ivp
index|[
name|chunk
index|]
expr_stmt|;
name|chunk
operator|++
operator|,
name|nbytes
operator|--
expr_stmt|;
block|}
name|ctx
operator|->
name|num
operator|=
name|chunk
operator|%
name|AES_BLOCK_SIZE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|#
directive|if
literal|0
block|if (nbytes % AES_BLOCK_SIZE) 		return 0;
comment|/* are we expected to do tail processing? */
else|#
directive|else
comment|/* nbytes is always multiple of AES_BLOCK_SIZE in ECB and CBC 	   modes and arbitrary value in byte-oriented modes, such as 	   CFB and OFB... */
endif|#
directive|endif
comment|/* VIA promises CPUs that won't require alignment in the future. 	   For now padlock_aes_align_required is initialized to 1 and 	   the condition is never met... */
comment|/* C7 core is capable to manage unaligned input in non-ECB[!] 	   mode, but performance penalties appear to be approximately 	   same as for software alignment below or ~3x. They promise to 	   improve it in the future, but for now we can just as well 	   pretend that it can only handle aligned input... */
if|if
condition|(
operator|!
name|padlock_aes_align_required
operator|&&
operator|(
name|nbytes
operator|%
name|AES_BLOCK_SIZE
operator|)
operator|==
literal|0
condition|)
return|return
name|padlock_aes_cipher_omnivorous
argument_list|(
name|ctx
argument_list|,
name|out_arg
argument_list|,
name|in_arg
argument_list|,
name|nbytes
argument_list|)
return|;
name|inp_misaligned
operator|=
operator|(
operator|(
operator|(
name|size_t
operator|)
name|in_arg
operator|)
operator|&
literal|0x0F
operator|)
expr_stmt|;
name|out_misaligned
operator|=
operator|(
operator|(
operator|(
name|size_t
operator|)
name|out_arg
operator|)
operator|&
literal|0x0F
operator|)
expr_stmt|;
comment|/* Note that even if output is aligned and input not, 	 * I still prefer to loop instead of copy the whole 	 * input and then encrypt in one stroke. This is done 	 * in order to improve L1 cache utilization... */
name|realign_in_loop
operator|=
name|out_misaligned
operator||
name|inp_misaligned
expr_stmt|;
if|if
condition|(
operator|!
name|realign_in_loop
operator|&&
operator|(
name|nbytes
operator|%
name|AES_BLOCK_SIZE
operator|)
operator|==
literal|0
condition|)
return|return
name|padlock_aes_cipher_omnivorous
argument_list|(
name|ctx
argument_list|,
name|out_arg
argument_list|,
name|in_arg
argument_list|,
name|nbytes
argument_list|)
return|;
comment|/* this takes one "if" out of the loops */
name|chunk
operator|=
name|nbytes
expr_stmt|;
name|chunk
operator|%=
name|PADLOCK_CHUNK
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
literal|0
condition|)
name|chunk
operator|=
name|PADLOCK_CHUNK
expr_stmt|;
if|if
condition|(
name|out_misaligned
condition|)
block|{
comment|/* optmize for small input */
name|allocated
operator|=
operator|(
name|chunk
operator|<
name|nbytes
condition|?
name|PADLOCK_CHUNK
else|:
name|nbytes
operator|)
expr_stmt|;
name|out
operator|=
name|alloca
argument_list|(
literal|0x10
operator|+
name|allocated
argument_list|)
expr_stmt|;
name|out
operator|=
name|NEAREST_ALIGNED
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
name|out
operator|=
name|out_arg
expr_stmt|;
name|cdata
operator|=
name|ALIGNED_CIPHER_DATA
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|padlock_verify_context
argument_list|(
name|cdata
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|EVP_CIPHER_CTX_mode
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
case|case
name|EVP_CIPH_ECB_MODE
case|:
do|do
block|{
if|if
condition|(
name|inp_misaligned
condition|)
name|inp
operator|=
name|padlock_memcpy
argument_list|(
name|out
argument_list|,
name|in_arg
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
else|else
name|inp
operator|=
name|in_arg
expr_stmt|;
name|in_arg
operator|+=
name|chunk
expr_stmt|;
name|padlock_xcrypt_ecb
argument_list|(
name|chunk
operator|/
name|AES_BLOCK_SIZE
argument_list|,
name|cdata
argument_list|,
name|out
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_misaligned
condition|)
name|out_arg
operator|=
name|padlock_memcpy
argument_list|(
name|out_arg
argument_list|,
name|out
argument_list|,
name|chunk
argument_list|)
operator|+
name|chunk
expr_stmt|;
else|else
name|out
operator|=
name|out_arg
operator|+=
name|chunk
expr_stmt|;
name|nbytes
operator|-=
name|chunk
expr_stmt|;
name|chunk
operator|=
name|PADLOCK_CHUNK
expr_stmt|;
block|}
do|while
condition|(
name|nbytes
condition|)
do|;
break|break;
case|case
name|EVP_CIPH_CBC_MODE
case|:
name|memcpy
argument_list|(
name|cdata
operator|->
name|iv
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|cbc_shortcut
goto|;
do|do
block|{
if|if
condition|(
name|iv
operator|!=
name|cdata
operator|->
name|iv
condition|)
name|memcpy
argument_list|(
name|cdata
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|PADLOCK_CHUNK
expr_stmt|;
name|cbc_shortcut
label|:
comment|/* optimize for small input */
if|if
condition|(
name|inp_misaligned
condition|)
name|inp
operator|=
name|padlock_memcpy
argument_list|(
name|out
argument_list|,
name|in_arg
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
else|else
name|inp
operator|=
name|in_arg
expr_stmt|;
name|in_arg
operator|+=
name|chunk
expr_stmt|;
name|iv
operator|=
name|padlock_xcrypt_cbc
argument_list|(
name|chunk
operator|/
name|AES_BLOCK_SIZE
argument_list|,
name|cdata
argument_list|,
name|out
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_misaligned
condition|)
name|out_arg
operator|=
name|padlock_memcpy
argument_list|(
name|out_arg
argument_list|,
name|out
argument_list|,
name|chunk
argument_list|)
operator|+
name|chunk
expr_stmt|;
else|else
name|out
operator|=
name|out_arg
operator|+=
name|chunk
expr_stmt|;
block|}
do|while
condition|(
name|nbytes
operator|-=
name|chunk
condition|)
do|;
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVP_CIPH_CFB_MODE
case|:
name|memcpy
argument_list|(
name|iv
operator|=
name|cdata
operator|->
name|iv
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|chunk
operator|&=
operator|~
operator|(
name|AES_BLOCK_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|chunk
condition|)
goto|goto
name|cfb_shortcut
goto|;
else|else
goto|goto
name|cfb_skiploop
goto|;
do|do
block|{
if|if
condition|(
name|iv
operator|!=
name|cdata
operator|->
name|iv
condition|)
name|memcpy
argument_list|(
name|cdata
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|PADLOCK_CHUNK
expr_stmt|;
name|cfb_shortcut
label|:
comment|/* optimize for small input */
if|if
condition|(
name|inp_misaligned
condition|)
name|inp
operator|=
name|padlock_memcpy
argument_list|(
name|out
argument_list|,
name|in_arg
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
else|else
name|inp
operator|=
name|in_arg
expr_stmt|;
name|in_arg
operator|+=
name|chunk
expr_stmt|;
name|iv
operator|=
name|padlock_xcrypt_cfb
argument_list|(
name|chunk
operator|/
name|AES_BLOCK_SIZE
argument_list|,
name|cdata
argument_list|,
name|out
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_misaligned
condition|)
name|out_arg
operator|=
name|padlock_memcpy
argument_list|(
name|out_arg
argument_list|,
name|out
argument_list|,
name|chunk
argument_list|)
operator|+
name|chunk
expr_stmt|;
else|else
name|out
operator|=
name|out_arg
operator|+=
name|chunk
expr_stmt|;
name|nbytes
operator|-=
name|chunk
expr_stmt|;
block|}
do|while
condition|(
name|nbytes
operator|>=
name|AES_BLOCK_SIZE
condition|)
do|;
name|cfb_skiploop
label|:
if|if
condition|(
name|nbytes
condition|)
block|{
name|unsigned
name|char
modifier|*
name|ivp
init|=
name|cdata
operator|->
name|iv
decl_stmt|;
if|if
condition|(
name|iv
operator|!=
name|ivp
condition|)
block|{
name|memcpy
argument_list|(
name|ivp
argument_list|,
name|iv
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|iv
operator|=
name|ivp
expr_stmt|;
block|}
name|ctx
operator|->
name|num
operator|=
name|nbytes
expr_stmt|;
if|if
condition|(
name|cdata
operator|->
name|cword
operator|.
name|b
operator|.
name|encdec
condition|)
block|{
name|cdata
operator|->
name|cword
operator|.
name|b
operator|.
name|encdec
operator|=
literal|0
expr_stmt|;
name|padlock_reload_key
argument_list|()
expr_stmt|;
name|padlock_xcrypt_ecb
argument_list|(
literal|1
argument_list|,
name|cdata
argument_list|,
name|ivp
argument_list|,
name|ivp
argument_list|)
expr_stmt|;
name|cdata
operator|->
name|cword
operator|.
name|b
operator|.
name|encdec
operator|=
literal|1
expr_stmt|;
name|padlock_reload_key
argument_list|()
expr_stmt|;
while|while
condition|(
name|nbytes
condition|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
operator|(
name|in_arg
operator|++
operator|)
decl_stmt|;
operator|*
operator|(
name|out_arg
operator|++
operator|)
operator|=
name|c
operator|^
operator|*
name|ivp
expr_stmt|;
operator|*
operator|(
name|ivp
operator|++
operator|)
operator|=
name|c
operator|,
name|nbytes
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|padlock_reload_key
argument_list|()
expr_stmt|;
name|padlock_xcrypt_ecb
argument_list|(
literal|1
argument_list|,
name|cdata
argument_list|,
name|ivp
argument_list|,
name|ivp
argument_list|)
expr_stmt|;
name|padlock_reload_key
argument_list|()
expr_stmt|;
while|while
condition|(
name|nbytes
condition|)
block|{
operator|*
name|ivp
operator|=
operator|*
operator|(
name|out_arg
operator|++
operator|)
operator|=
operator|*
operator|(
name|in_arg
operator|++
operator|)
operator|^
operator|*
name|ivp
expr_stmt|;
name|ivp
operator|++
operator|,
name|nbytes
operator|--
expr_stmt|;
block|}
block|}
block|}
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVP_CIPH_OFB_MODE
case|:
name|memcpy
argument_list|(
name|cdata
operator|->
name|iv
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|chunk
operator|&=
operator|~
operator|(
name|AES_BLOCK_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|chunk
condition|)
do|do
block|{
if|if
condition|(
name|inp_misaligned
condition|)
name|inp
operator|=
name|padlock_memcpy
argument_list|(
name|out
argument_list|,
name|in_arg
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
else|else
name|inp
operator|=
name|in_arg
expr_stmt|;
name|in_arg
operator|+=
name|chunk
expr_stmt|;
name|padlock_xcrypt_ofb
argument_list|(
name|chunk
operator|/
name|AES_BLOCK_SIZE
argument_list|,
name|cdata
argument_list|,
name|out
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_misaligned
condition|)
name|out_arg
operator|=
name|padlock_memcpy
argument_list|(
name|out_arg
argument_list|,
name|out
argument_list|,
name|chunk
argument_list|)
operator|+
name|chunk
expr_stmt|;
else|else
name|out
operator|=
name|out_arg
operator|+=
name|chunk
expr_stmt|;
name|nbytes
operator|-=
name|chunk
expr_stmt|;
name|chunk
operator|=
name|PADLOCK_CHUNK
expr_stmt|;
block|}
do|while
condition|(
name|nbytes
operator|>=
name|AES_BLOCK_SIZE
condition|)
do|;
if|if
condition|(
name|nbytes
condition|)
block|{
name|unsigned
name|char
modifier|*
name|ivp
init|=
name|cdata
operator|->
name|iv
decl_stmt|;
name|ctx
operator|->
name|num
operator|=
name|nbytes
expr_stmt|;
name|padlock_reload_key
argument_list|()
expr_stmt|;
comment|/* empirically found */
name|padlock_xcrypt_ecb
argument_list|(
literal|1
argument_list|,
name|cdata
argument_list|,
name|ivp
argument_list|,
name|ivp
argument_list|)
expr_stmt|;
name|padlock_reload_key
argument_list|()
expr_stmt|;
comment|/* empirically found */
while|while
condition|(
name|nbytes
condition|)
block|{
operator|*
operator|(
name|out_arg
operator|++
operator|)
operator|=
operator|*
operator|(
name|in_arg
operator|++
operator|)
operator|^
operator|*
name|ivp
expr_stmt|;
name|ivp
operator|++
operator|,
name|nbytes
operator|--
expr_stmt|;
block|}
block|}
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
name|cdata
operator|->
name|iv
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
comment|/* Clean the realign buffer if it was used */
if|if
condition|(
name|out_misaligned
condition|)
block|{
specifier|volatile
name|unsigned
name|long
modifier|*
name|p
init|=
operator|(
name|void
operator|*
operator|)
name|out
decl_stmt|;
name|size_t
name|n
init|=
name|allocated
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|memset
argument_list|(
name|cdata
operator|->
name|iv
argument_list|,
literal|0
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL_NO_AES */
end_comment

begin_comment
comment|/* ===== Random Number Generator ===== */
end_comment

begin_comment
comment|/*  * This code is not engaged. The reason is that it does not comply  * with recommendations for VIA RNG usage for secure applications  * (posted at http://www.via.com.tw/en/viac3/c3.jsp) nor does it  * provide meaningful error control...  */
end_comment

begin_comment
comment|/* Wrapper that provides an interface between the API and     the raw PadLock RNG */
end_comment

begin_function
specifier|static
name|int
name|padlock_rand_bytes
parameter_list|(
name|unsigned
name|char
modifier|*
name|output
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|unsigned
name|int
name|eax
decl_stmt|,
name|buf
decl_stmt|;
while|while
condition|(
name|count
operator|>=
literal|8
condition|)
block|{
name|eax
operator|=
name|padlock_xstore
argument_list|(
name|output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|eax
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* RNG disabled */
comment|/* this ---vv--- covers DC bias, Raw Bits and String Filter */
if|if
condition|(
name|eax
operator|&
operator|(
literal|0x1F
operator|<<
literal|10
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|eax
operator|&
literal|0x1F
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* no data, retry... */
if|if
condition|(
operator|(
name|eax
operator|&
literal|0x1F
operator|)
operator|!=
literal|8
condition|)
return|return
literal|0
return|;
comment|/* fatal failure...  */
name|output
operator|+=
literal|8
expr_stmt|;
name|count
operator|-=
literal|8
expr_stmt|;
block|}
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|eax
operator|=
name|padlock_xstore
argument_list|(
operator|&
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|eax
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* RNG disabled */
comment|/* this ---vv--- covers DC bias, Raw Bits and String Filter */
if|if
condition|(
name|eax
operator|&
operator|(
literal|0x1F
operator|<<
literal|10
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|eax
operator|&
literal|0x1F
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* no data, retry... */
if|if
condition|(
operator|(
name|eax
operator|&
literal|0x1F
operator|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* fatal failure...  */
operator|*
name|output
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|buf
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
operator|*
operator|(
specifier|volatile
name|unsigned
name|int
operator|*
operator|)
operator|&
name|buf
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Dummy but necessary function */
end_comment

begin_function
specifier|static
name|int
name|padlock_rand_status
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Prepare structure for registration */
end_comment

begin_decl_stmt
specifier|static
name|RAND_METHOD
name|padlock_rand
init|=
block|{
name|NULL
block|,
comment|/* seed */
name|padlock_rand_bytes
block|,
comment|/* bytes */
name|NULL
block|,
comment|/* cleanup */
name|NULL
block|,
comment|/* add */
name|padlock_rand_bytes
block|,
comment|/* pseudorand */
name|padlock_rand_status
block|,
comment|/* rand status */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPILE_HW_PADLOCK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_HW_PADLOCK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_HW */
end_comment

end_unit

