begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/rand/rand_win.c */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *   * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *   * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from   *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *   * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|"rand_lcl.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WINDOWS
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32_WINNT
end_ifndef

begin_define
define|#
directive|define
name|_WIN32_WINNT
value|0x0400
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<wincrypt.h>
end_include

begin_include
include|#
directive|include
file|<tlhelp32.h>
end_include

begin_comment
comment|/* Intel hardware RNG CSP -- available from  * http://developer.intel.com/design/security/rng/redist_license.htm  */
end_comment

begin_define
define|#
directive|define
name|PROV_INTEL_SEC
value|22
end_define

begin_define
define|#
directive|define
name|INTEL_DEF_PROV
value|"Intel Hardware Cryptographic Service Provider"
end_define

begin_function_decl
specifier|static
name|void
name|readtimer
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|readscreen
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* It appears like CURSORINFO, PCURSORINFO and LPCURSORINFO are only defined    when WINVER is 0x0500 and up, which currently only happens on Win2000.    Unfortunately, those are typedefs, so they're a little bit difficult to    detect properly.  On the other hand, the macro CURSOR_SHOWING is defined    within the same conditional, so it can be use to detect the absence of said    typedefs. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CURSOR_SHOWING
end_ifndef

begin_comment
comment|/*  * Information about the global cursor.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|tagCURSORINFO
block|{
name|DWORD
name|cbSize
decl_stmt|;
name|DWORD
name|flags
decl_stmt|;
name|HCURSOR
name|hCursor
decl_stmt|;
name|POINT
name|ptScreenPos
decl_stmt|;
block|}
name|CURSORINFO
operator|,
typedef|*
name|PCURSORINFO
operator|,
typedef|*
name|LPCURSORINFO
typedef|;
end_typedef

begin_define
define|#
directive|define
name|CURSOR_SHOWING
value|0x00000001
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CURSOR_SHOWING */
end_comment

begin_typedef
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|CRYPTACQUIRECONTEXT
function_decl|)
parameter_list|(
name|HCRYPTPROV
modifier|*
parameter_list|,
name|LPCTSTR
parameter_list|,
name|LPCTSTR
parameter_list|,
name|DWORD
parameter_list|,
name|DWORD
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|CRYPTGENRANDOM
function_decl|)
parameter_list|(
name|HCRYPTPROV
parameter_list|,
name|DWORD
parameter_list|,
name|BYTE
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|CRYPTRELEASECONTEXT
function_decl|)
parameter_list|(
name|HCRYPTPROV
parameter_list|,
name|DWORD
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|HWND
function_decl|(
name|WINAPI
modifier|*
name|GETFOREGROUNDWINDOW
function_decl|)
parameter_list|(
name|VOID
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|GETCURSORINFO
function_decl|)
parameter_list|(
name|PCURSORINFO
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|DWORD
function_decl|(
name|WINAPI
modifier|*
name|GETQUEUESTATUS
function_decl|)
parameter_list|(
name|UINT
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|HANDLE
function_decl|(
name|WINAPI
modifier|*
name|CREATETOOLHELP32SNAPSHOT
function_decl|)
parameter_list|(
name|DWORD
parameter_list|,
name|DWORD
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|HEAP32FIRST
function_decl|)
parameter_list|(
name|LPHEAPENTRY32
parameter_list|,
name|DWORD
parameter_list|,
name|DWORD
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|HEAP32NEXT
function_decl|)
parameter_list|(
name|LPHEAPENTRY32
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|HEAP32LIST
function_decl|)
parameter_list|(
name|HANDLE
parameter_list|,
name|LPHEAPLIST32
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|PROCESS32
function_decl|)
parameter_list|(
name|HANDLE
parameter_list|,
name|LPPROCESSENTRY32
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|THREAD32
function_decl|)
parameter_list|(
name|HANDLE
parameter_list|,
name|LPTHREADENTRY32
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|MODULE32
function_decl|)
parameter_list|(
name|HANDLE
parameter_list|,
name|LPMODULEENTRY32
parameter_list|)
function_decl|;
end_typedef

begin_include
include|#
directive|include
file|<lmcons.h>
end_include

begin_include
include|#
directive|include
file|<lmstats.h>
end_include

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* The NET API is Unicode only.  It requires the use of the UNICODE        * macro.  When UNICODE is defined LPTSTR becomes LPWSTR.  LMSTR was        * was added to the Platform SDK to allow the NET API to be used in        * non-Unicode applications provided that Unicode strings were still        * used for input.  LMSTR is defined as LPWSTR.        */
end_comment

begin_typedef
typedef|typedef
name|NET_API_STATUS
function_decl|(
name|NET_API_FUNCTION
modifier|*
name|NETSTATGET
function_decl|)
parameter_list|(
name|LPWSTR
parameter_list|,
name|LPWSTR
parameter_list|,
name|DWORD
parameter_list|,
name|DWORD
parameter_list|,
name|LPBYTE
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|NET_API_STATUS
function_decl|(
name|NET_API_FUNCTION
modifier|*
name|NETFREE
function_decl|)
parameter_list|(
name|LPBYTE
parameter_list|)
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 1 */
end_comment

begin_function
name|int
name|RAND_poll
parameter_list|(
name|void
parameter_list|)
block|{
name|MEMORYSTATUS
name|m
decl_stmt|;
name|HCRYPTPROV
name|hProvider
init|=
literal|0
decl_stmt|;
name|BYTE
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|DWORD
name|w
decl_stmt|;
name|HWND
name|h
decl_stmt|;
name|HMODULE
name|advapi
decl_stmt|,
name|kernel
decl_stmt|,
name|user
decl_stmt|,
name|netapi
decl_stmt|;
name|CRYPTACQUIRECONTEXT
name|acquire
init|=
literal|0
decl_stmt|;
name|CRYPTGENRANDOM
name|gen
init|=
literal|0
decl_stmt|;
name|CRYPTRELEASECONTEXT
name|release
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|1
comment|/* There was previously a problem with NETSTATGET.  Currently, this        * section is still experimental, but if all goes well, this conditional        * will be removed        */
name|NETSTATGET
name|netstatget
init|=
literal|0
decl_stmt|;
name|NETFREE
name|netfree
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* 1 */
comment|/* Determine the OS version we are on so we can turn off things  	 * that do not work properly. 	 */
name|OSVERSIONINFO
name|osverinfo
decl_stmt|;
name|osverinfo
operator|.
name|dwOSVersionInfoSize
operator|=
sizeof|sizeof
argument_list|(
name|OSVERSIONINFO
argument_list|)
expr_stmt|;
name|GetVersionEx
argument_list|(
operator|&
name|osverinfo
argument_list|)
expr_stmt|;
comment|/* load functions dynamically - not available on all systems */
name|advapi
operator|=
name|LoadLibrary
argument_list|(
literal|"ADVAPI32.DLL"
argument_list|)
expr_stmt|;
name|kernel
operator|=
name|LoadLibrary
argument_list|(
literal|"KERNEL32.DLL"
argument_list|)
expr_stmt|;
name|user
operator|=
name|LoadLibrary
argument_list|(
literal|"USER32.DLL"
argument_list|)
expr_stmt|;
name|netapi
operator|=
name|LoadLibrary
argument_list|(
literal|"NETAPI32.DLL"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* There was previously a problem with NETSTATGET.  Currently, this        * section is still experimental, but if all goes well, this conditional        * will be removed        */
if|if
condition|(
name|netapi
condition|)
block|{
name|netstatget
operator|=
operator|(
name|NETSTATGET
operator|)
name|GetProcAddress
argument_list|(
name|netapi
argument_list|,
literal|"NetStatisticsGet"
argument_list|)
expr_stmt|;
name|netfree
operator|=
operator|(
name|NETFREE
operator|)
name|GetProcAddress
argument_list|(
name|netapi
argument_list|,
literal|"NetApiBufferFree"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|netstatget
operator|&&
name|netfree
condition|)
block|{
name|LPBYTE
name|outbuf
decl_stmt|;
comment|/* NetStatisticsGet() is a Unicode only function  		 * STAT_WORKSTATION_0 contains 45 fields and STAT_SERVER_0 		 * contains 17 fields.  We treat each field as a source of 		 * one byte of entropy.                  */
if|if
condition|(
name|netstatget
argument_list|(
name|NULL
argument_list|,
literal|L"LanmanWorkstation"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|outbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|RAND_add
argument_list|(
name|outbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|STAT_WORKSTATION_0
argument_list|)
argument_list|,
literal|45
argument_list|)
expr_stmt|;
name|netfree
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|netstatget
argument_list|(
name|NULL
argument_list|,
literal|L"LanmanServer"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|outbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|RAND_add
argument_list|(
name|outbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|STAT_SERVER_0
argument_list|)
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|netfree
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|netapi
condition|)
name|FreeLibrary
argument_list|(
name|netapi
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 1 */
comment|/* It appears like this can cause an exception deep within ADVAPI32.DLL          * at random times on Windows 2000.  Reported by Jeffrey Altman.            * Only use it on NT. 	 */
if|if
condition|(
name|osverinfo
operator|.
name|dwPlatformId
operator|==
name|VER_PLATFORM_WIN32_NT
operator|&&
name|osverinfo
operator|.
name|dwMajorVersion
operator|<
literal|5
condition|)
block|{
comment|/* Read Performance Statistics from NT/2000 registry 		 * The size of the performance data can vary from call 		 * to call so we must guess the size of the buffer to use 		 * and increase its size if we get an ERROR_MORE_DATA 		 * return instead of ERROR_SUCCESS. 		 */
name|LONG
name|rc
init|=
name|ERROR_MORE_DATA
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|DWORD
name|bufsz
init|=
literal|0
decl_stmt|;
name|DWORD
name|length
decl_stmt|;
while|while
condition|(
name|rc
operator|==
name|ERROR_MORE_DATA
condition|)
block|{
name|buf
operator|=
name|realloc
argument_list|(
name|buf
argument_list|,
name|bufsz
operator|+
literal|8192
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
break|break;
name|bufsz
operator|+=
literal|8192
expr_stmt|;
name|length
operator|=
name|bufsz
expr_stmt|;
name|rc
operator|=
name|RegQueryValueEx
argument_list|(
name|HKEY_PERFORMANCE_DATA
argument_list|,
literal|"Global"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
name|ERROR_SUCCESS
condition|)
block|{
comment|/* For entropy count assume only least significant 			 * byte of each DWORD is random.                          */
name|RAND_add
argument_list|(
operator|&
name|length
argument_list|,
sizeof|sizeof
argument_list|(
name|length
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RAND_add
argument_list|(
name|buf
argument_list|,
name|length
argument_list|,
name|length
operator|/
literal|4.0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|advapi
condition|)
block|{
name|acquire
operator|=
operator|(
name|CRYPTACQUIRECONTEXT
operator|)
name|GetProcAddress
argument_list|(
name|advapi
argument_list|,
literal|"CryptAcquireContextA"
argument_list|)
expr_stmt|;
name|gen
operator|=
operator|(
name|CRYPTGENRANDOM
operator|)
name|GetProcAddress
argument_list|(
name|advapi
argument_list|,
literal|"CryptGenRandom"
argument_list|)
expr_stmt|;
name|release
operator|=
operator|(
name|CRYPTRELEASECONTEXT
operator|)
name|GetProcAddress
argument_list|(
name|advapi
argument_list|,
literal|"CryptReleaseContext"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acquire
operator|&&
name|gen
operator|&&
name|release
condition|)
block|{
comment|/* poll the CryptoAPI PRNG */
comment|/* The CryptoAPI returns sizeof(buf) bytes of randomness */
if|if
condition|(
name|acquire
argument_list|(
operator|&
name|hProvider
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PROV_RSA_FULL
argument_list|,
name|CRYPT_VERIFYCONTEXT
argument_list|)
condition|)
block|{
if|if
condition|(
name|gen
argument_list|(
name|hProvider
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|RAND_add
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"randomness from PROV_RSA_FULL\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|release
argument_list|(
name|hProvider
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* poll the Pentium PRG with CryptoAPI */
if|if
condition|(
name|acquire
argument_list|(
operator|&
name|hProvider
argument_list|,
literal|0
argument_list|,
name|INTEL_DEF_PROV
argument_list|,
name|PROV_INTEL_SEC
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|gen
argument_list|(
name|hProvider
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|RAND_add
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"randomness from PROV_INTEL_SEC\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|release
argument_list|(
name|hProvider
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|advapi
condition|)
name|FreeLibrary
argument_list|(
name|advapi
argument_list|)
expr_stmt|;
comment|/* timer data */
name|readtimer
argument_list|()
expr_stmt|;
comment|/* memory usage statistics */
name|GlobalMemoryStatus
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* process ID */
name|w
operator|=
name|GetCurrentProcessId
argument_list|()
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
condition|)
block|{
name|GETCURSORINFO
name|cursor
decl_stmt|;
name|GETFOREGROUNDWINDOW
name|win
decl_stmt|;
name|GETQUEUESTATUS
name|queue
decl_stmt|;
name|win
operator|=
operator|(
name|GETFOREGROUNDWINDOW
operator|)
name|GetProcAddress
argument_list|(
name|user
argument_list|,
literal|"GetForegroundWindow"
argument_list|)
expr_stmt|;
name|cursor
operator|=
operator|(
name|GETCURSORINFO
operator|)
name|GetProcAddress
argument_list|(
name|user
argument_list|,
literal|"GetCursorInfo"
argument_list|)
expr_stmt|;
name|queue
operator|=
operator|(
name|GETQUEUESTATUS
operator|)
name|GetProcAddress
argument_list|(
name|user
argument_list|,
literal|"GetQueueStatus"
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
condition|)
block|{
comment|/* window handle */
name|h
operator|=
name|win
argument_list|()
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|h
argument_list|,
sizeof|sizeof
argument_list|(
name|h
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cursor
condition|)
block|{
comment|/* unfortunately, its not safe to call GetCursorInfo() 			 * on NT4 even though it exists in SP3 (or SP6) and 			 * higher. 			 */
if|if
condition|(
name|osverinfo
operator|.
name|dwPlatformId
operator|==
name|VER_PLATFORM_WIN32_NT
operator|&&
name|osverinfo
operator|.
name|dwMajorVersion
operator|<
literal|5
condition|)
name|cursor
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cursor
condition|)
block|{
comment|/* cursor position */
comment|/* assume 2 bytes of entropy */
name|CURSORINFO
name|ci
decl_stmt|;
name|ci
operator|.
name|cbSize
operator|=
sizeof|sizeof
argument_list|(
name|CURSORINFO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor
argument_list|(
operator|&
name|ci
argument_list|)
condition|)
name|RAND_add
argument_list|(
operator|&
name|ci
argument_list|,
name|ci
operator|.
name|cbSize
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queue
condition|)
block|{
comment|/* message queue status */
comment|/* assume 1 byte of entropy */
name|w
operator|=
name|queue
argument_list|(
name|QS_ALLEVENTS
argument_list|)
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|FreeLibrary
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
comment|/* Toolhelp32 snapshot: enumerate processes, threads, modules and heap 	 * http://msdn.microsoft.com/library/psdk/winbase/toolhelp_5pfd.htm 	 * (Win 9x and 2000 only, not available on NT) 	 * 	 * This seeding method was proposed in Peter Gutmann, Software 	 * Generation of Practically Strong Random Numbers, 	 * http://www.usenix.org/publications/library/proceedings/sec98/gutmann.html      * revised version at http://www.cryptoengines.com/~peter/06_random.pdf 	 * (The assignment of entropy estimates below is arbitrary, but based 	 * on Peter's analysis the full poll appears to be safe. Additional 	 * interactive seeding is encouraged.) 	 */
if|if
condition|(
name|kernel
condition|)
block|{
name|CREATETOOLHELP32SNAPSHOT
name|snap
decl_stmt|;
name|HANDLE
name|handle
decl_stmt|;
name|HEAP32FIRST
name|heap_first
decl_stmt|;
name|HEAP32NEXT
name|heap_next
decl_stmt|;
name|HEAP32LIST
name|heaplist_first
decl_stmt|,
name|heaplist_next
decl_stmt|;
name|PROCESS32
name|process_first
decl_stmt|,
name|process_next
decl_stmt|;
name|THREAD32
name|thread_first
decl_stmt|,
name|thread_next
decl_stmt|;
name|MODULE32
name|module_first
decl_stmt|,
name|module_next
decl_stmt|;
name|HEAPLIST32
name|hlist
decl_stmt|;
name|HEAPENTRY32
name|hentry
decl_stmt|;
name|PROCESSENTRY32
name|p
decl_stmt|;
name|THREADENTRY32
name|t
decl_stmt|;
name|MODULEENTRY32
name|m
decl_stmt|;
name|snap
operator|=
operator|(
name|CREATETOOLHELP32SNAPSHOT
operator|)
name|GetProcAddress
argument_list|(
name|kernel
argument_list|,
literal|"CreateToolhelp32Snapshot"
argument_list|)
expr_stmt|;
name|heap_first
operator|=
operator|(
name|HEAP32FIRST
operator|)
name|GetProcAddress
argument_list|(
name|kernel
argument_list|,
literal|"Heap32First"
argument_list|)
expr_stmt|;
name|heap_next
operator|=
operator|(
name|HEAP32NEXT
operator|)
name|GetProcAddress
argument_list|(
name|kernel
argument_list|,
literal|"Heap32Next"
argument_list|)
expr_stmt|;
name|heaplist_first
operator|=
operator|(
name|HEAP32LIST
operator|)
name|GetProcAddress
argument_list|(
name|kernel
argument_list|,
literal|"Heap32ListFirst"
argument_list|)
expr_stmt|;
name|heaplist_next
operator|=
operator|(
name|HEAP32LIST
operator|)
name|GetProcAddress
argument_list|(
name|kernel
argument_list|,
literal|"Heap32ListNext"
argument_list|)
expr_stmt|;
name|process_first
operator|=
operator|(
name|PROCESS32
operator|)
name|GetProcAddress
argument_list|(
name|kernel
argument_list|,
literal|"Process32First"
argument_list|)
expr_stmt|;
name|process_next
operator|=
operator|(
name|PROCESS32
operator|)
name|GetProcAddress
argument_list|(
name|kernel
argument_list|,
literal|"Process32Next"
argument_list|)
expr_stmt|;
name|thread_first
operator|=
operator|(
name|THREAD32
operator|)
name|GetProcAddress
argument_list|(
name|kernel
argument_list|,
literal|"Thread32First"
argument_list|)
expr_stmt|;
name|thread_next
operator|=
operator|(
name|THREAD32
operator|)
name|GetProcAddress
argument_list|(
name|kernel
argument_list|,
literal|"Thread32Next"
argument_list|)
expr_stmt|;
name|module_first
operator|=
operator|(
name|MODULE32
operator|)
name|GetProcAddress
argument_list|(
name|kernel
argument_list|,
literal|"Module32First"
argument_list|)
expr_stmt|;
name|module_next
operator|=
operator|(
name|MODULE32
operator|)
name|GetProcAddress
argument_list|(
name|kernel
argument_list|,
literal|"Module32Next"
argument_list|)
expr_stmt|;
if|if
condition|(
name|snap
operator|&&
name|heap_first
operator|&&
name|heap_next
operator|&&
name|heaplist_first
operator|&&
name|heaplist_next
operator|&&
name|process_first
operator|&&
name|process_next
operator|&&
name|thread_first
operator|&&
name|thread_next
operator|&&
name|module_first
operator|&&
name|module_next
operator|&&
operator|(
name|handle
operator|=
name|snap
argument_list|(
name|TH32CS_SNAPALL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* heap list and heap walking */
comment|/* HEAPLIST32 contains 3 fields that will change with                          * each entry.  Consider each field a source of 1 byte                          * of entropy.                          * HEAPENTRY32 contains 5 fields that will change with                           * each entry.  Consider each field a source of 1 byte                          * of entropy.                          */
name|hlist
operator|.
name|dwSize
operator|=
sizeof|sizeof
argument_list|(
name|HEAPLIST32
argument_list|)
expr_stmt|;
if|if
condition|(
name|heaplist_first
argument_list|(
name|handle
argument_list|,
operator|&
name|hlist
argument_list|)
condition|)
do|do
block|{
name|RAND_add
argument_list|(
operator|&
name|hlist
argument_list|,
name|hlist
operator|.
name|dwSize
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|hentry
operator|.
name|dwSize
operator|=
sizeof|sizeof
argument_list|(
name|HEAPENTRY32
argument_list|)
expr_stmt|;
if|if
condition|(
name|heap_first
argument_list|(
operator|&
name|hentry
argument_list|,
name|hlist
operator|.
name|th32ProcessID
argument_list|,
name|hlist
operator|.
name|th32HeapID
argument_list|)
condition|)
block|{
name|int
name|entrycnt
init|=
literal|50
decl_stmt|;
do|do
name|RAND_add
argument_list|(
operator|&
name|hentry
argument_list|,
name|hentry
operator|.
name|dwSize
argument_list|,
literal|5
argument_list|)
expr_stmt|;
do|while
condition|(
name|heap_next
argument_list|(
operator|&
name|hentry
argument_list|)
operator|&&
operator|--
name|entrycnt
operator|>
literal|0
condition|)
do|;
block|}
block|}
do|while
condition|(
name|heaplist_next
argument_list|(
name|handle
argument_list|,
operator|&
name|hlist
argument_list|)
condition|)
do|;
comment|/* process walking */
comment|/* PROCESSENTRY32 contains 9 fields that will change                          * with each entry.  Consider each field a source of                          * 1 byte of entropy.                          */
name|p
operator|.
name|dwSize
operator|=
sizeof|sizeof
argument_list|(
name|PROCESSENTRY32
argument_list|)
expr_stmt|;
if|if
condition|(
name|process_first
argument_list|(
name|handle
argument_list|,
operator|&
name|p
argument_list|)
condition|)
do|do
name|RAND_add
argument_list|(
operator|&
name|p
argument_list|,
name|p
operator|.
name|dwSize
argument_list|,
literal|9
argument_list|)
expr_stmt|;
do|while
condition|(
name|process_next
argument_list|(
name|handle
argument_list|,
operator|&
name|p
argument_list|)
condition|)
do|;
comment|/* thread walking */
comment|/* THREADENTRY32 contains 6 fields that will change                          * with each entry.  Consider each field a source of                          * 1 byte of entropy.                          */
name|t
operator|.
name|dwSize
operator|=
sizeof|sizeof
argument_list|(
name|THREADENTRY32
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread_first
argument_list|(
name|handle
argument_list|,
operator|&
name|t
argument_list|)
condition|)
do|do
name|RAND_add
argument_list|(
operator|&
name|t
argument_list|,
name|t
operator|.
name|dwSize
argument_list|,
literal|6
argument_list|)
expr_stmt|;
do|while
condition|(
name|thread_next
argument_list|(
name|handle
argument_list|,
operator|&
name|t
argument_list|)
condition|)
do|;
comment|/* module walking */
comment|/* MODULEENTRY32 contains 9 fields that will change                          * with each entry.  Consider each field a source of                          * 1 byte of entropy.                          */
name|m
operator|.
name|dwSize
operator|=
sizeof|sizeof
argument_list|(
name|MODULEENTRY32
argument_list|)
expr_stmt|;
if|if
condition|(
name|module_first
argument_list|(
name|handle
argument_list|,
operator|&
name|m
argument_list|)
condition|)
do|do
name|RAND_add
argument_list|(
operator|&
name|m
argument_list|,
name|m
operator|.
name|dwSize
argument_list|,
literal|9
argument_list|)
expr_stmt|;
do|while
condition|(
name|module_next
argument_list|(
name|handle
argument_list|,
operator|&
name|m
argument_list|)
condition|)
do|;
name|CloseHandle
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
name|FreeLibrary
argument_list|(
name|kernel
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Exiting RAND_poll\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|RAND_event
parameter_list|(
name|UINT
name|iMsg
parameter_list|,
name|WPARAM
name|wParam
parameter_list|,
name|LPARAM
name|lParam
parameter_list|)
block|{
name|double
name|add_entropy
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|iMsg
condition|)
block|{
case|case
name|WM_KEYDOWN
case|:
block|{
specifier|static
name|WPARAM
name|key
decl_stmt|;
if|if
condition|(
name|key
operator|!=
name|wParam
condition|)
name|add_entropy
operator|=
literal|0.05
expr_stmt|;
name|key
operator|=
name|wParam
expr_stmt|;
block|}
break|break;
case|case
name|WM_MOUSEMOVE
case|:
block|{
specifier|static
name|int
name|lastx
decl_stmt|,
name|lasty
decl_stmt|,
name|lastdx
decl_stmt|,
name|lastdy
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|x
operator|=
name|LOWORD
argument_list|(
name|lParam
argument_list|)
expr_stmt|;
name|y
operator|=
name|HIWORD
argument_list|(
name|lParam
argument_list|)
expr_stmt|;
name|dx
operator|=
name|lastx
operator|-
name|x
expr_stmt|;
name|dy
operator|=
name|lasty
operator|-
name|y
expr_stmt|;
if|if
condition|(
name|dx
operator|!=
literal|0
operator|&&
name|dy
operator|!=
literal|0
operator|&&
name|dx
operator|-
name|lastdx
operator|!=
literal|0
operator|&&
name|dy
operator|-
name|lastdy
operator|!=
literal|0
condition|)
name|add_entropy
operator|=
literal|.2
expr_stmt|;
name|lastx
operator|=
name|x
operator|,
name|lasty
operator|=
name|y
expr_stmt|;
name|lastdx
operator|=
name|dx
operator|,
name|lastdy
operator|=
name|dy
expr_stmt|;
block|}
break|break;
block|}
name|readtimer
argument_list|()
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|iMsg
argument_list|,
sizeof|sizeof
argument_list|(
name|iMsg
argument_list|)
argument_list|,
name|add_entropy
argument_list|)
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|wParam
argument_list|,
sizeof|sizeof
argument_list|(
name|wParam
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|lParam
argument_list|,
sizeof|sizeof
argument_list|(
name|lParam
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|RAND_status
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|void
name|RAND_screen
parameter_list|(
name|void
parameter_list|)
comment|/* function available for backward compatibility */
block|{
name|RAND_poll
argument_list|()
expr_stmt|;
name|readscreen
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* feed timing information to the PRNG */
end_comment

begin_function
specifier|static
name|void
name|readtimer
parameter_list|(
name|void
parameter_list|)
block|{
name|DWORD
name|w
decl_stmt|;
name|LARGE_INTEGER
name|l
decl_stmt|;
specifier|static
name|int
name|have_perfc
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|_MSC_VER
specifier|static
name|int
name|have_tsc
init|=
literal|1
decl_stmt|;
name|DWORD
name|cyclecount
decl_stmt|;
if|if
condition|(
name|have_tsc
condition|)
block|{
name|__try
block|{
asm|__asm {
asm|_emit 0x0f
asm|_emit 0x31
asm|mov cyclecount, eax
asm|}
name|RAND_add
argument_list|(
operator|&
name|cyclecount
argument_list|,
sizeof|sizeof
argument_list|(
name|cyclecount
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|__except
argument_list|(
argument|EXCEPTION_EXECUTE_HANDLER
argument_list|)
block|{
name|have_tsc
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|#
directive|else
define|#
directive|define
name|have_tsc
value|0
endif|#
directive|endif
if|if
condition|(
name|have_perfc
condition|)
block|{
if|if
condition|(
name|QueryPerformanceCounter
argument_list|(
operator|&
name|l
argument_list|)
operator|==
literal|0
condition|)
name|have_perfc
operator|=
literal|0
expr_stmt|;
else|else
name|RAND_add
argument_list|(
operator|&
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_tsc
operator|&&
operator|!
name|have_perfc
condition|)
block|{
name|w
operator|=
name|GetTickCount
argument_list|()
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* feed screen contents to PRNG */
end_comment

begin_comment
comment|/*****************************************************************************  *  * Created 960901 by Gertjan van Oosten, gertjan@West.NL, West Consulting B.V.  *  * Code adapted from  *<URL:http://www.microsoft.com/kb/developr/win_dk/q97193.htm>;  * the original copyright message is:  *  *   (C) Copyright Microsoft Corp. 1993.  All rights reserved.  *  *   You have a royalty-free right to use, modify, reproduce and  *   distribute the Sample Files (and/or any modified version) in  *   any way you find useful, provided that you agree that  *   Microsoft has no warranty obligations or liability for any  *   Sample Application Files which are modified.  */
end_comment

begin_function
specifier|static
name|void
name|readscreen
parameter_list|(
name|void
parameter_list|)
block|{
name|HDC
name|hScrDC
decl_stmt|;
comment|/* screen DC */
name|HDC
name|hMemDC
decl_stmt|;
comment|/* memory DC */
name|HBITMAP
name|hBitmap
decl_stmt|;
comment|/* handle for our bitmap */
name|HBITMAP
name|hOldBitmap
decl_stmt|;
comment|/* handle for previous bitmap */
name|BITMAP
name|bm
decl_stmt|;
comment|/* bitmap properties */
name|unsigned
name|int
name|size
decl_stmt|;
comment|/* size of bitmap */
name|char
modifier|*
name|bmbits
decl_stmt|;
comment|/* contents of bitmap */
name|int
name|w
decl_stmt|;
comment|/* screen width */
name|int
name|h
decl_stmt|;
comment|/* screen height */
name|int
name|y
decl_stmt|;
comment|/* y-coordinate of screen lines to grab */
name|int
name|n
init|=
literal|16
decl_stmt|;
comment|/* number of screen lines to grab at a time */
comment|/* Create a screen DC and a memory DC compatible to screen DC */
name|hScrDC
operator|=
name|CreateDC
argument_list|(
literal|"DISPLAY"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hMemDC
operator|=
name|CreateCompatibleDC
argument_list|(
name|hScrDC
argument_list|)
expr_stmt|;
comment|/* Get screen resolution */
name|w
operator|=
name|GetDeviceCaps
argument_list|(
name|hScrDC
argument_list|,
name|HORZRES
argument_list|)
expr_stmt|;
name|h
operator|=
name|GetDeviceCaps
argument_list|(
name|hScrDC
argument_list|,
name|VERTRES
argument_list|)
expr_stmt|;
comment|/* Create a bitmap compatible with the screen DC */
name|hBitmap
operator|=
name|CreateCompatibleBitmap
argument_list|(
name|hScrDC
argument_list|,
name|w
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Select new bitmap into memory DC */
name|hOldBitmap
operator|=
name|SelectObject
argument_list|(
name|hMemDC
argument_list|,
name|hBitmap
argument_list|)
expr_stmt|;
comment|/* Get bitmap properties */
name|GetObject
argument_list|(
name|hBitmap
argument_list|,
sizeof|sizeof
argument_list|(
name|BITMAP
argument_list|)
argument_list|,
operator|(
name|LPSTR
operator|)
operator|&
name|bm
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|unsigned
name|int
operator|)
name|bm
operator|.
name|bmWidthBytes
operator|*
name|bm
operator|.
name|bmHeight
operator|*
name|bm
operator|.
name|bmPlanes
expr_stmt|;
name|bmbits
operator|=
name|OPENSSL_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmbits
condition|)
block|{
comment|/* Now go through the whole screen, repeatedly grabbing n lines */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|h
operator|-
name|n
condition|;
name|y
operator|+=
name|n
control|)
block|{
name|unsigned
name|char
name|md
index|[
name|MD_DIGEST_LENGTH
index|]
decl_stmt|;
comment|/* Bitblt screen DC to memory DC */
name|BitBlt
argument_list|(
name|hMemDC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|n
argument_list|,
name|hScrDC
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|SRCCOPY
argument_list|)
expr_stmt|;
comment|/* Copy bitmap bits from memory DC to bmbits */
name|GetBitmapBits
argument_list|(
name|hBitmap
argument_list|,
name|size
argument_list|,
name|bmbits
argument_list|)
expr_stmt|;
comment|/* Get the hash of the bitmap */
name|MD
argument_list|(
name|bmbits
argument_list|,
name|size
argument_list|,
name|md
argument_list|)
expr_stmt|;
comment|/* Seed the random generator with the hash value */
name|RAND_add
argument_list|(
name|md
argument_list|,
name|MD_DIGEST_LENGTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|OPENSSL_free
argument_list|(
name|bmbits
argument_list|)
expr_stmt|;
block|}
comment|/* Select old bitmap back into memory DC */
name|hBitmap
operator|=
name|SelectObject
argument_list|(
name|hMemDC
argument_list|,
name|hOldBitmap
argument_list|)
expr_stmt|;
comment|/* Clean up */
name|DeleteObject
argument_list|(
name|hBitmap
argument_list|)
expr_stmt|;
name|DeleteDC
argument_list|(
name|hMemDC
argument_list|)
expr_stmt|;
name|DeleteDC
argument_list|(
name|hScrDC
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Unix version */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_function
name|int
name|RAND_poll
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|l
decl_stmt|;
name|pid_t
name|curr_pid
init|=
name|getpid
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVRANDOM
name|FILE
modifier|*
name|fh
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEVRANDOM
comment|/* Use a random entropy pool device. Linux, FreeBSD and OpenBSD 	 * have this. Use /dev/urandom if you can as /dev/random may block 	 * if it runs out of random entries.  */
if|if
condition|(
operator|(
name|fh
operator|=
name|fopen
argument_list|(
name|DEVRANDOM
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|char
name|tmpbuf
index|[
name|ENTROPY_NEEDED
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|setvbuf
argument_list|(
name|fh
argument_list|,
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|fread
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tmpbuf
argument_list|,
literal|1
argument_list|,
name|ENTROPY_NEEDED
argument_list|,
name|fh
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fh
argument_list|)
expr_stmt|;
name|RAND_add
argument_list|(
name|tmpbuf
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmpbuf
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* put in some default random data, we need more than just this */
name|l
operator|=
name|curr_pid
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|l
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|l
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVRANDOM
return|return
literal|1
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

