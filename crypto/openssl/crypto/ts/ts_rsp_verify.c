begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/ts/ts_resp_verify.c */
end_comment

begin_comment
comment|/* Written by Zoltan Glozik (zglozik@stones.com) for the OpenSSL  * project 2002.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ts.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pkcs7.h>
end_include

begin_comment
comment|/* Private function declarations. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|TS_verify_cert
argument_list|(
name|X509_STORE
operator|*
name|store
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|untrusted
argument_list|,
name|X509
operator|*
name|signer
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
operator|*
name|chain
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TS_check_signing_certs
argument_list|(
name|PKCS7_SIGNER_INFO
operator|*
name|si
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|chain
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|ESS_SIGNING_CERT
modifier|*
name|ESS_get_signing_cert
parameter_list|(
name|PKCS7_SIGNER_INFO
modifier|*
name|si
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|TS_find_cert
argument_list|(
name|STACK_OF
argument_list|(
name|ESS_CERT_ID
argument_list|)
operator|*
name|cert_ids
argument_list|,
name|X509
operator|*
name|cert
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|TS_issuer_serial_cmp
parameter_list|(
name|ESS_ISSUER_SERIAL
modifier|*
name|is
parameter_list|,
name|X509_CINF
modifier|*
name|cinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|int_TS_RESP_verify_token
parameter_list|(
name|TS_VERIFY_CTX
modifier|*
name|ctx
parameter_list|,
name|PKCS7
modifier|*
name|token
parameter_list|,
name|TS_TST_INFO
modifier|*
name|tst_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|TS_check_status_info
parameter_list|(
name|TS_RESP
modifier|*
name|response
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|TS_get_status_text
argument_list|(
name|STACK_OF
argument_list|(
name|ASN1_UTF8STRING
argument_list|)
operator|*
name|text
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|TS_check_policy
parameter_list|(
name|ASN1_OBJECT
modifier|*
name|req_oid
parameter_list|,
name|TS_TST_INFO
modifier|*
name|tst_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|TS_compute_imprint
parameter_list|(
name|BIO
modifier|*
name|data
parameter_list|,
name|TS_TST_INFO
modifier|*
name|tst_info
parameter_list|,
name|X509_ALGOR
modifier|*
modifier|*
name|md_alg
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|imprint
parameter_list|,
name|unsigned
modifier|*
name|imprint_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|TS_check_imprints
parameter_list|(
name|X509_ALGOR
modifier|*
name|algor_a
parameter_list|,
name|unsigned
name|char
modifier|*
name|imprint_a
parameter_list|,
name|unsigned
name|len_a
parameter_list|,
name|TS_TST_INFO
modifier|*
name|tst_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|TS_check_nonces
parameter_list|(
specifier|const
name|ASN1_INTEGER
modifier|*
name|a
parameter_list|,
name|TS_TST_INFO
modifier|*
name|tst_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|TS_check_signer_name
parameter_list|(
name|GENERAL_NAME
modifier|*
name|tsa_name
parameter_list|,
name|X509
modifier|*
name|signer
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|TS_find_name
argument_list|(
name|STACK_OF
argument_list|(
name|GENERAL_NAME
argument_list|)
operator|*
name|gen_names
argument_list|,
name|GENERAL_NAME
operator|*
name|name
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local mapping between response codes and descriptions.  * Don't forget to change TS_STATUS_BUF_SIZE when modifying   * the elements of this array.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|TS_status_text
index|[]
init|=
block|{
literal|"granted"
block|,
literal|"grantedWithMods"
block|,
literal|"rejection"
block|,
literal|"waiting"
block|,
literal|"revocationWarning"
block|,
literal|"revocationNotification"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TS_STATUS_TEXT_SIZE
value|(sizeof(TS_status_text)/sizeof(*TS_status_text))
end_define

begin_comment
comment|/*  * This must be greater or equal to the sum of the strings in TS_status_text  * plus the number of its elements.  */
end_comment

begin_define
define|#
directive|define
name|TS_STATUS_BUF_SIZE
value|256
end_define

begin_struct
specifier|static
struct|struct
block|{
name|int
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
block|}
name|TS_failure_info
index|[]
init|=
block|{
block|{
name|TS_INFO_BAD_ALG
block|,
literal|"badAlg"
block|}
block|,
block|{
name|TS_INFO_BAD_REQUEST
block|,
literal|"badRequest"
block|}
block|,
block|{
name|TS_INFO_BAD_DATA_FORMAT
block|,
literal|"badDataFormat"
block|}
block|,
block|{
name|TS_INFO_TIME_NOT_AVAILABLE
block|,
literal|"timeNotAvailable"
block|}
block|,
block|{
name|TS_INFO_UNACCEPTED_POLICY
block|,
literal|"unacceptedPolicy"
block|}
block|,
block|{
name|TS_INFO_UNACCEPTED_EXTENSION
block|,
literal|"unacceptedExtension"
block|}
block|,
block|{
name|TS_INFO_ADD_INFO_NOT_AVAILABLE
block|,
literal|"addInfoNotAvailable"
block|}
block|,
block|{
name|TS_INFO_SYSTEM_FAILURE
block|,
literal|"systemFailure"
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TS_FAILURE_INFO_SIZE
value|(sizeof(TS_failure_info) / \ 				sizeof(*TS_failure_info))
end_define

begin_comment
comment|/* Functions for verifying a signed TS_TST_INFO structure. */
end_comment

begin_comment
comment|/*  * This function carries out the following tasks:  *	- Checks if there is one and only one signer.  *	- Search for the signing certificate in 'certs' and in the response.  *	- Check the extended key usage and key usage fields of the signer  *	certificate (done by the path validation).  *	- Build and validate the certificate path.  *	- Check if the certificate path meets the requirements of the  *	SigningCertificate ESS signed attribute.  *	- Verify the signature value.  *	- Returns the signer certificate in 'signer', if 'signer' is not NULL.  */
end_comment

begin_decl_stmt
name|int
name|TS_RESP_verify_signature
argument_list|(
name|PKCS7
operator|*
name|token
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|certs
argument_list|,
name|X509_STORE
operator|*
name|store
argument_list|,
name|X509
operator|*
operator|*
name|signer_out
argument_list|)
block|{
name|STACK_OF
argument_list|(
name|PKCS7_SIGNER_INFO
argument_list|)
operator|*
name|sinfos
operator|=
name|NULL
expr_stmt|;
name|PKCS7_SIGNER_INFO
modifier|*
name|si
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|signers
operator|=
name|NULL
expr_stmt|;
name|X509
modifier|*
name|signer
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|chain
operator|=
name|NULL
expr_stmt|;
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|BIO
modifier|*
name|p7bio
init|=
name|NULL
decl_stmt|;
comment|/* Some sanity checks first. */
if|if
condition|(
operator|!
name|token
condition|)
block|{
name|TSerr
argument_list|(
name|TS_F_TS_RESP_VERIFY_SIGNATURE
argument_list|,
name|TS_R_INVALID_NULL_POINTER
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Check for the correct content type */
if|if
condition|(
operator|!
name|PKCS7_type_is_signed
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|TSerr
argument_list|(
name|TS_F_TS_RESP_VERIFY_SIGNATURE
argument_list|,
name|TS_R_WRONG_CONTENT_TYPE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Check if there is one and only one signer. */
name|sinfos
operator|=
name|PKCS7_get_signer_info
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sinfos
operator|||
name|sk_PKCS7_SIGNER_INFO_num
argument_list|(
name|sinfos
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|TSerr
argument_list|(
name|TS_F_TS_RESP_VERIFY_SIGNATURE
argument_list|,
name|TS_R_THERE_MUST_BE_ONE_SIGNER
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|si
operator|=
name|sk_PKCS7_SIGNER_INFO_value
argument_list|(
name|sinfos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for no content: no data to verify signature. */
if|if
condition|(
name|PKCS7_get_detached
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|TSerr
argument_list|(
name|TS_F_TS_RESP_VERIFY_SIGNATURE
argument_list|,
name|TS_R_NO_CONTENT
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Get hold of the signer certificate, search only internal 	   certificates if it was requested. */
name|signers
operator|=
name|PKCS7_get0_signers
argument_list|(
name|token
argument_list|,
name|certs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|signers
operator|||
name|sk_X509_num
argument_list|(
name|signers
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|err
goto|;
name|signer
operator|=
name|sk_X509_value
argument_list|(
name|signers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now verify the certificate. */
if|if
condition|(
operator|!
name|TS_verify_cert
argument_list|(
name|store
argument_list|,
name|certs
argument_list|,
name|signer
argument_list|,
operator|&
name|chain
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Check if the signer certificate is consistent with the 	   ESS extension. */
if|if
condition|(
operator|!
name|TS_check_signing_certs
argument_list|(
name|si
argument_list|,
name|chain
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Creating the message digest. */
name|p7bio
operator|=
name|PKCS7_dataInit
argument_list|(
name|token
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* We now have to 'read' from p7bio to calculate digests etc. */
while|while
condition|(
operator|(
name|i
operator|=
name|BIO_read
argument_list|(
name|p7bio
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* Verifying the signature. */
name|j
operator|=
name|PKCS7_signatureVerify
argument_list|(
name|p7bio
argument_list|,
name|token
argument_list|,
name|si
argument_list|,
name|signer
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<=
literal|0
condition|)
block|{
name|TSerr
argument_list|(
name|TS_F_TS_RESP_VERIFY_SIGNATURE
argument_list|,
name|TS_R_SIGNATURE_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Return the signer certificate if needed. */
if|if
condition|(
name|signer_out
condition|)
block|{
operator|*
name|signer_out
operator|=
name|signer
expr_stmt|;
name|CRYPTO_add
argument_list|(
operator|&
name|signer
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_X509
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|BIO_free_all
argument_list|(
name|p7bio
argument_list|)
expr_stmt|;
name|sk_X509_pop_free
argument_list|(
name|chain
argument_list|,
name|X509_free
argument_list|)
expr_stmt|;
name|sk_X509_free
argument_list|(
name|signers
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * The certificate chain is returned in chain. Caller is responsible for  * freeing the vector.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|TS_verify_cert
argument_list|(
name|X509_STORE
operator|*
name|store
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|untrusted
argument_list|,
name|X509
operator|*
name|signer
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
operator|*
name|chain
argument_list|)
block|{
name|X509_STORE_CTX
name|cert_ctx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
comment|/* chain is an out argument. */
operator|*
name|chain
operator|=
name|NULL
expr_stmt|;
name|X509_STORE_CTX_init
argument_list|(
operator|&
name|cert_ctx
argument_list|,
name|store
argument_list|,
name|signer
argument_list|,
name|untrusted
argument_list|)
expr_stmt|;
name|X509_STORE_CTX_set_purpose
argument_list|(
operator|&
name|cert_ctx
argument_list|,
name|X509_PURPOSE_TIMESTAMP_SIGN
argument_list|)
expr_stmt|;
name|i
operator|=
name|X509_verify_cert
argument_list|(
operator|&
name|cert_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|int
name|j
init|=
name|X509_STORE_CTX_get_error
argument_list|(
operator|&
name|cert_ctx
argument_list|)
decl_stmt|;
name|TSerr
argument_list|(
name|TS_F_TS_VERIFY_CERT
argument_list|,
name|TS_R_CERTIFICATE_VERIFY_ERROR
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"Verify error:"
argument_list|,
name|X509_verify_cert_error_string
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Get a copy of the certificate chain. */
operator|*
name|chain
operator|=
name|X509_STORE_CTX_get1_chain
argument_list|(
operator|&
name|cert_ctx
argument_list|)
expr_stmt|;
block|}
name|X509_STORE_CTX_cleanup
argument_list|(
operator|&
name|cert_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TS_check_signing_certs
argument_list|(
name|PKCS7_SIGNER_INFO
operator|*
name|si
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|chain
argument_list|)
block|{
name|ESS_SIGNING_CERT
modifier|*
name|ss
init|=
name|ESS_get_signing_cert
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|STACK_OF
argument_list|(
name|ESS_CERT_ID
argument_list|)
operator|*
name|cert_ids
operator|=
name|NULL
expr_stmt|;
name|X509
modifier|*
name|cert
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ss
condition|)
goto|goto
name|err
goto|;
name|cert_ids
operator|=
name|ss
operator|->
name|cert_ids
expr_stmt|;
comment|/* The signer certificate must be the first in cert_ids. */
name|cert
operator|=
name|sk_X509_value
argument_list|(
name|chain
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TS_find_cert
argument_list|(
name|cert_ids
argument_list|,
name|cert
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* Check the other certificates of the chain if there are more 	   than one certificate ids in cert_ids. */
if|if
condition|(
name|sk_ESS_CERT_ID_num
argument_list|(
name|cert_ids
argument_list|)
operator|>
literal|1
condition|)
block|{
comment|/* All the certificates of the chain must be in cert_ids. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sk_X509_num
argument_list|(
name|chain
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|cert
operator|=
name|sk_X509_value
argument_list|(
name|chain
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TS_find_cert
argument_list|(
name|cert_ids
argument_list|,
name|cert
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
operator|!
name|ret
condition|)
name|TSerr
argument_list|(
name|TS_F_TS_CHECK_SIGNING_CERTS
argument_list|,
name|TS_R_ESS_SIGNING_CERTIFICATE_ERROR
argument_list|)
expr_stmt|;
name|ESS_SIGNING_CERT_free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|ESS_SIGNING_CERT
modifier|*
name|ESS_get_signing_cert
parameter_list|(
name|PKCS7_SIGNER_INFO
modifier|*
name|si
parameter_list|)
block|{
name|ASN1_TYPE
modifier|*
name|attr
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|attr
operator|=
name|PKCS7_get_signed_attribute
argument_list|(
name|si
argument_list|,
name|NID_id_smime_aa_signingCertificate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attr
condition|)
return|return
name|NULL
return|;
name|p
operator|=
name|attr
operator|->
name|value
operator|.
name|sequence
operator|->
name|data
expr_stmt|;
return|return
name|d2i_ESS_SIGNING_CERT
argument_list|(
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|attr
operator|->
name|value
operator|.
name|sequence
operator|->
name|length
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns< 0 if certificate is not found, certificate index otherwise. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|TS_find_cert
argument_list|(
name|STACK_OF
argument_list|(
name|ESS_CERT_ID
argument_list|)
operator|*
name|cert_ids
argument_list|,
name|X509
operator|*
name|cert
argument_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|cert_ids
operator|||
operator|!
name|cert
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Recompute SHA1 hash of certificate if necessary (side effect). */
name|X509_check_purpose
argument_list|(
name|cert
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Look for cert in the cert_ids vector. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_ESS_CERT_ID_num
argument_list|(
name|cert_ids
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|ESS_CERT_ID
modifier|*
name|cid
init|=
name|sk_ESS_CERT_ID_value
argument_list|(
name|cert_ids
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* Check the SHA-1 hash first. */
if|if
condition|(
name|cid
operator|->
name|hash
operator|->
name|length
operator|==
sizeof|sizeof
argument_list|(
name|cert
operator|->
name|sha1_hash
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|cid
operator|->
name|hash
operator|->
name|data
argument_list|,
name|cert
operator|->
name|sha1_hash
argument_list|,
sizeof|sizeof
argument_list|(
name|cert
operator|->
name|sha1_hash
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Check the issuer/serial as well if specified. */
name|ESS_ISSUER_SERIAL
modifier|*
name|is
init|=
name|cid
operator|->
name|issuer_serial
decl_stmt|;
if|if
condition|(
operator|!
name|is
operator|||
operator|!
name|TS_issuer_serial_cmp
argument_list|(
name|is
argument_list|,
name|cert
operator|->
name|cert_info
argument_list|)
condition|)
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|TS_issuer_serial_cmp
parameter_list|(
name|ESS_ISSUER_SERIAL
modifier|*
name|is
parameter_list|,
name|X509_CINF
modifier|*
name|cinfo
parameter_list|)
block|{
name|GENERAL_NAME
modifier|*
name|issuer
decl_stmt|;
if|if
condition|(
operator|!
name|is
operator|||
operator|!
name|cinfo
operator|||
name|sk_GENERAL_NAME_num
argument_list|(
name|is
operator|->
name|issuer
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Check the issuer first. It must be a directory name. */
name|issuer
operator|=
name|sk_GENERAL_NAME_value
argument_list|(
name|is
operator|->
name|issuer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|issuer
operator|->
name|type
operator|!=
name|GEN_DIRNAME
operator|||
name|X509_NAME_cmp
argument_list|(
name|issuer
operator|->
name|d
operator|.
name|dirn
argument_list|,
name|cinfo
operator|->
name|issuer
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Check the serial number, too. */
if|if
condition|(
name|ASN1_INTEGER_cmp
argument_list|(
name|is
operator|->
name|serial
argument_list|,
name|cinfo
operator|->
name|serialNumber
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Verifies whether 'response' contains a valid response with regards   * to the settings of the context:  *	- Gives an error message if the TS_TST_INFO is not present.  *	- Calls _TS_RESP_verify_token to verify the token content.  */
end_comment

begin_function
name|int
name|TS_RESP_verify_response
parameter_list|(
name|TS_VERIFY_CTX
modifier|*
name|ctx
parameter_list|,
name|TS_RESP
modifier|*
name|response
parameter_list|)
block|{
name|PKCS7
modifier|*
name|token
init|=
name|TS_RESP_get_token
argument_list|(
name|response
argument_list|)
decl_stmt|;
name|TS_TST_INFO
modifier|*
name|tst_info
init|=
name|TS_RESP_get_tst_info
argument_list|(
name|response
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* Check if we have a successful TS_TST_INFO object in place. */
if|if
condition|(
operator|!
name|TS_check_status_info
argument_list|(
name|response
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Check the contents of the time stamp token. */
if|if
condition|(
operator|!
name|int_TS_RESP_verify_token
argument_list|(
name|ctx
argument_list|,
name|token
argument_list|,
name|tst_info
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Tries to extract a TS_TST_INFO structure from the PKCS7 token and  * calls the internal int_TS_RESP_verify_token function for verifying it.  */
end_comment

begin_function
name|int
name|TS_RESP_verify_token
parameter_list|(
name|TS_VERIFY_CTX
modifier|*
name|ctx
parameter_list|,
name|PKCS7
modifier|*
name|token
parameter_list|)
block|{
name|TS_TST_INFO
modifier|*
name|tst_info
init|=
name|PKCS7_to_TS_TST_INFO
argument_list|(
name|token
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tst_info
condition|)
block|{
name|ret
operator|=
name|int_TS_RESP_verify_token
argument_list|(
name|ctx
argument_list|,
name|token
argument_list|,
name|tst_info
argument_list|)
expr_stmt|;
name|TS_TST_INFO_free
argument_list|(
name|tst_info
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Verifies whether the 'token' contains a valid time stamp token   * with regards to the settings of the context. Only those checks are  * carried out that are specified in the context:  *	- Verifies the signature of the TS_TST_INFO.  *	- Checks the version number of the response.  *	- Check if the requested and returned policies math.  *	- Check if the message imprints are the same.  *	- Check if the nonces are the same.  *	- Check if the TSA name matches the signer.  *	- Check if the TSA name is the expected TSA.  */
end_comment

begin_function
specifier|static
name|int
name|int_TS_RESP_verify_token
parameter_list|(
name|TS_VERIFY_CTX
modifier|*
name|ctx
parameter_list|,
name|PKCS7
modifier|*
name|token
parameter_list|,
name|TS_TST_INFO
modifier|*
name|tst_info
parameter_list|)
block|{
name|X509
modifier|*
name|signer
init|=
name|NULL
decl_stmt|;
name|GENERAL_NAME
modifier|*
name|tsa_name
init|=
name|TS_TST_INFO_get_tsa
argument_list|(
name|tst_info
argument_list|)
decl_stmt|;
name|X509_ALGOR
modifier|*
name|md_alg
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|imprint
init|=
name|NULL
decl_stmt|;
name|unsigned
name|imprint_len
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* Verify the signature. */
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|TS_VFY_SIGNATURE
operator|)
operator|&&
operator|!
name|TS_RESP_verify_signature
argument_list|(
name|token
argument_list|,
name|ctx
operator|->
name|certs
argument_list|,
name|ctx
operator|->
name|store
argument_list|,
operator|&
name|signer
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Check version number of response. */
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|TS_VFY_VERSION
operator|)
operator|&&
name|TS_TST_INFO_get_version
argument_list|(
name|tst_info
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|TSerr
argument_list|(
name|TS_F_INT_TS_RESP_VERIFY_TOKEN
argument_list|,
name|TS_R_UNSUPPORTED_VERSION
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Check policies. */
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|TS_VFY_POLICY
operator|)
operator|&&
operator|!
name|TS_check_policy
argument_list|(
name|ctx
operator|->
name|policy
argument_list|,
name|tst_info
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Check message imprints. */
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|TS_VFY_IMPRINT
operator|)
operator|&&
operator|!
name|TS_check_imprints
argument_list|(
name|ctx
operator|->
name|md_alg
argument_list|,
name|ctx
operator|->
name|imprint
argument_list|,
name|ctx
operator|->
name|imprint_len
argument_list|,
name|tst_info
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Compute and check message imprints. */
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|TS_VFY_DATA
operator|)
operator|&&
operator|(
operator|!
name|TS_compute_imprint
argument_list|(
name|ctx
operator|->
name|data
argument_list|,
name|tst_info
argument_list|,
operator|&
name|md_alg
argument_list|,
operator|&
name|imprint
argument_list|,
operator|&
name|imprint_len
argument_list|)
operator|||
operator|!
name|TS_check_imprints
argument_list|(
name|md_alg
argument_list|,
name|imprint
argument_list|,
name|imprint_len
argument_list|,
name|tst_info
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
comment|/* Check nonces. */
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|TS_VFY_NONCE
operator|)
operator|&&
operator|!
name|TS_check_nonces
argument_list|(
name|ctx
operator|->
name|nonce
argument_list|,
name|tst_info
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Check whether TSA name and signer certificate match. */
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|TS_VFY_SIGNER
operator|)
operator|&&
name|tsa_name
operator|&&
operator|!
name|TS_check_signer_name
argument_list|(
name|tsa_name
argument_list|,
name|signer
argument_list|)
condition|)
block|{
name|TSerr
argument_list|(
name|TS_F_INT_TS_RESP_VERIFY_TOKEN
argument_list|,
name|TS_R_TSA_NAME_MISMATCH
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Check whether the TSA is the expected one. */
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|TS_VFY_TSA_NAME
operator|)
operator|&&
operator|!
name|TS_check_signer_name
argument_list|(
name|ctx
operator|->
name|tsa_name
argument_list|,
name|signer
argument_list|)
condition|)
block|{
name|TSerr
argument_list|(
name|TS_F_INT_TS_RESP_VERIFY_TOKEN
argument_list|,
name|TS_R_TSA_UNTRUSTED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|X509_free
argument_list|(
name|signer
argument_list|)
expr_stmt|;
name|X509_ALGOR_free
argument_list|(
name|md_alg
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|imprint
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|TS_check_status_info
parameter_list|(
name|TS_RESP
modifier|*
name|response
parameter_list|)
block|{
name|TS_STATUS_INFO
modifier|*
name|info
init|=
name|TS_RESP_get_status_info
argument_list|(
name|response
argument_list|)
decl_stmt|;
name|long
name|status
init|=
name|ASN1_INTEGER_get
argument_list|(
name|info
operator|->
name|status
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|status_text
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|embedded_status_text
init|=
name|NULL
decl_stmt|;
name|char
name|failure_text
index|[
name|TS_STATUS_BUF_SIZE
index|]
init|=
literal|""
decl_stmt|;
comment|/* Check if everything went fine. */
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|status
operator|==
literal|1
condition|)
return|return
literal|1
return|;
comment|/* There was an error, get the description in status_text. */
if|if
condition|(
literal|0
operator|<=
name|status
operator|&&
name|status
operator|<
operator|(
name|long
operator|)
name|TS_STATUS_TEXT_SIZE
condition|)
name|status_text
operator|=
name|TS_status_text
index|[
name|status
index|]
expr_stmt|;
else|else
name|status_text
operator|=
literal|"unknown code"
expr_stmt|;
comment|/* Set the embedded_status_text to the returned description. */
if|if
condition|(
name|sk_ASN1_UTF8STRING_num
argument_list|(
name|info
operator|->
name|text
argument_list|)
operator|>
literal|0
operator|&&
operator|!
operator|(
name|embedded_status_text
operator|=
name|TS_get_status_text
argument_list|(
name|info
operator|->
name|text
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Filling in failure_text with the failure information. */
if|if
condition|(
name|info
operator|->
name|failure_info
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|TS_FAILURE_INFO_SIZE
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ASN1_BIT_STRING_get_bit
argument_list|(
name|info
operator|->
name|failure_info
argument_list|,
name|TS_failure_info
index|[
name|i
index|]
operator|.
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|strcpy
argument_list|(
name|failure_text
argument_list|,
literal|","
argument_list|)
expr_stmt|;
else|else
name|first
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|failure_text
argument_list|,
name|TS_failure_info
index|[
name|i
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|failure_text
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|failure_text
argument_list|,
literal|"unspecified"
argument_list|)
expr_stmt|;
comment|/* Making up the error string. */
name|TSerr
argument_list|(
name|TS_F_TS_CHECK_STATUS_INFO
argument_list|,
name|TS_R_NO_TIME_STAMP_TOKEN
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|6
argument_list|,
literal|"status code: "
argument_list|,
name|status_text
argument_list|,
literal|", status text: "
argument_list|,
name|embedded_status_text
condition|?
name|embedded_status_text
else|:
literal|"unspecified"
argument_list|,
literal|", failure codes: "
argument_list|,
name|failure_text
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|embedded_status_text
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|TS_get_status_text
argument_list|(
name|STACK_OF
argument_list|(
name|ASN1_UTF8STRING
argument_list|)
operator|*
name|text
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|length
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Determine length first. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_ASN1_UTF8STRING_num
argument_list|(
name|text
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|ASN1_UTF8STRING
modifier|*
name|current
init|=
name|sk_ASN1_UTF8STRING_value
argument_list|(
name|text
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|length
operator|+=
name|ASN1_STRING_length
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|length
operator|+=
literal|1
expr_stmt|;
comment|/* separator character */
block|}
comment|/* Allocate memory (closing '\0' included). */
if|if
condition|(
operator|!
operator|(
name|result
operator|=
name|OPENSSL_malloc
argument_list|(
name|length
argument_list|)
operator|)
condition|)
block|{
name|TSerr
argument_list|(
name|TS_F_TS_GET_STATUS_TEXT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Concatenate the descriptions. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|result
init|;
name|i
operator|<
name|sk_ASN1_UTF8STRING_num
argument_list|(
name|text
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|ASN1_UTF8STRING
modifier|*
name|current
init|=
name|sk_ASN1_UTF8STRING_value
argument_list|(
name|text
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|length
operator|=
name|ASN1_STRING_length
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ASN1_STRING_data
argument_list|(
name|current
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
name|length
expr_stmt|;
block|}
comment|/* We do have space for this, too. */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|TS_check_policy
parameter_list|(
name|ASN1_OBJECT
modifier|*
name|req_oid
parameter_list|,
name|TS_TST_INFO
modifier|*
name|tst_info
parameter_list|)
block|{
name|ASN1_OBJECT
modifier|*
name|resp_oid
init|=
name|TS_TST_INFO_get_policy_id
argument_list|(
name|tst_info
argument_list|)
decl_stmt|;
if|if
condition|(
name|OBJ_cmp
argument_list|(
name|req_oid
argument_list|,
name|resp_oid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|TSerr
argument_list|(
name|TS_F_TS_CHECK_POLICY
argument_list|,
name|TS_R_POLICY_MISMATCH
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|TS_compute_imprint
parameter_list|(
name|BIO
modifier|*
name|data
parameter_list|,
name|TS_TST_INFO
modifier|*
name|tst_info
parameter_list|,
name|X509_ALGOR
modifier|*
modifier|*
name|md_alg
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|imprint
parameter_list|,
name|unsigned
modifier|*
name|imprint_len
parameter_list|)
block|{
name|TS_MSG_IMPRINT
modifier|*
name|msg_imprint
init|=
name|TS_TST_INFO_get_msg_imprint
argument_list|(
name|tst_info
argument_list|)
decl_stmt|;
name|X509_ALGOR
modifier|*
name|md_alg_resp
init|=
name|TS_MSG_IMPRINT_get_algo
argument_list|(
name|msg_imprint
argument_list|)
decl_stmt|;
specifier|const
name|EVP_MD
modifier|*
name|md
decl_stmt|;
name|EVP_MD_CTX
name|md_ctx
decl_stmt|;
name|unsigned
name|char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|length
decl_stmt|;
operator|*
name|md_alg
operator|=
name|NULL
expr_stmt|;
operator|*
name|imprint
operator|=
name|NULL
expr_stmt|;
comment|/* Return the MD algorithm of the response. */
if|if
condition|(
operator|!
operator|(
operator|*
name|md_alg
operator|=
name|X509_ALGOR_dup
argument_list|(
name|md_alg_resp
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
comment|/* Getting the MD object. */
if|if
condition|(
operator|!
operator|(
name|md
operator|=
name|EVP_get_digestbyobj
argument_list|(
operator|(
operator|*
name|md_alg
operator|)
operator|->
name|algorithm
argument_list|)
operator|)
condition|)
block|{
name|TSerr
argument_list|(
name|TS_F_TS_COMPUTE_IMPRINT
argument_list|,
name|TS_R_UNSUPPORTED_MD_ALGORITHM
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Compute message digest. */
name|length
operator|=
name|EVP_MD_size
argument_list|(
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
operator|*
name|imprint_len
operator|=
name|length
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|imprint
operator|=
name|OPENSSL_malloc
argument_list|(
operator|*
name|imprint_len
argument_list|)
operator|)
condition|)
block|{
name|TSerr
argument_list|(
name|TS_F_TS_COMPUTE_IMPRINT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|EVP_DigestInit
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|md
argument_list|)
condition|)
goto|goto
name|err
goto|;
while|while
condition|(
operator|(
name|length
operator|=
name|BIO_read
argument_list|(
name|data
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|EVP_DigestFinal
argument_list|(
operator|&
name|md_ctx
argument_list|,
operator|*
name|imprint
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
literal|1
return|;
name|err
label|:
name|X509_ALGOR_free
argument_list|(
operator|*
name|md_alg
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
operator|*
name|imprint
argument_list|)
expr_stmt|;
operator|*
name|imprint_len
operator|=
literal|0
expr_stmt|;
operator|*
name|imprint
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|TS_check_imprints
parameter_list|(
name|X509_ALGOR
modifier|*
name|algor_a
parameter_list|,
name|unsigned
name|char
modifier|*
name|imprint_a
parameter_list|,
name|unsigned
name|len_a
parameter_list|,
name|TS_TST_INFO
modifier|*
name|tst_info
parameter_list|)
block|{
name|TS_MSG_IMPRINT
modifier|*
name|b
init|=
name|TS_TST_INFO_get_msg_imprint
argument_list|(
name|tst_info
argument_list|)
decl_stmt|;
name|X509_ALGOR
modifier|*
name|algor_b
init|=
name|TS_MSG_IMPRINT_get_algo
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* algor_a is optional. */
if|if
condition|(
name|algor_a
condition|)
block|{
comment|/* Compare algorithm OIDs. */
if|if
condition|(
name|OBJ_cmp
argument_list|(
name|algor_a
operator|->
name|algorithm
argument_list|,
name|algor_b
operator|->
name|algorithm
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* The parameter must be NULL in both. */
if|if
condition|(
operator|(
name|algor_a
operator|->
name|parameter
operator|&&
name|ASN1_TYPE_get
argument_list|(
name|algor_a
operator|->
name|parameter
argument_list|)
operator|!=
name|V_ASN1_NULL
operator|)
operator|||
operator|(
name|algor_b
operator|->
name|parameter
operator|&&
name|ASN1_TYPE_get
argument_list|(
name|algor_b
operator|->
name|parameter
argument_list|)
operator|!=
name|V_ASN1_NULL
operator|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* Compare octet strings. */
name|ret
operator|=
name|len_a
operator|==
operator|(
name|unsigned
operator|)
name|ASN1_STRING_length
argument_list|(
name|b
operator|->
name|hashed_msg
argument_list|)
operator|&&
name|memcmp
argument_list|(
name|imprint_a
argument_list|,
name|ASN1_STRING_data
argument_list|(
name|b
operator|->
name|hashed_msg
argument_list|)
argument_list|,
name|len_a
argument_list|)
operator|==
literal|0
expr_stmt|;
name|err
label|:
if|if
condition|(
operator|!
name|ret
condition|)
name|TSerr
argument_list|(
name|TS_F_TS_CHECK_IMPRINTS
argument_list|,
name|TS_R_MESSAGE_IMPRINT_MISMATCH
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|TS_check_nonces
parameter_list|(
specifier|const
name|ASN1_INTEGER
modifier|*
name|a
parameter_list|,
name|TS_TST_INFO
modifier|*
name|tst_info
parameter_list|)
block|{
specifier|const
name|ASN1_INTEGER
modifier|*
name|b
init|=
name|TS_TST_INFO_get_nonce
argument_list|(
name|tst_info
argument_list|)
decl_stmt|;
comment|/* Error if nonce is missing. */
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|TSerr
argument_list|(
name|TS_F_TS_CHECK_NONCES
argument_list|,
name|TS_R_NONCE_NOT_RETURNED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* No error if a nonce is returned without being requested. */
if|if
condition|(
name|ASN1_INTEGER_cmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|TSerr
argument_list|(
name|TS_F_TS_CHECK_NONCES
argument_list|,
name|TS_R_NONCE_MISMATCH
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check if the specified TSA name matches either the subject    or one of the subject alternative names of the TSA certificate. */
end_comment

begin_function
specifier|static
name|int
name|TS_check_signer_name
parameter_list|(
name|GENERAL_NAME
modifier|*
name|tsa_name
parameter_list|,
name|X509
modifier|*
name|signer
parameter_list|)
block|{
name|STACK_OF
argument_list|(
name|GENERAL_NAME
argument_list|)
operator|*
name|gen_names
operator|=
name|NULL
expr_stmt|;
name|int
name|idx
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* Check the subject name first. */
if|if
condition|(
name|tsa_name
operator|->
name|type
operator|==
name|GEN_DIRNAME
operator|&&
name|X509_name_cmp
argument_list|(
name|tsa_name
operator|->
name|d
operator|.
name|dirn
argument_list|,
name|signer
operator|->
name|cert_info
operator|->
name|subject
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Check all the alternative names. */
name|gen_names
operator|=
name|X509_get_ext_d2i
argument_list|(
name|signer
argument_list|,
name|NID_subject_alt_name
argument_list|,
name|NULL
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
while|while
condition|(
name|gen_names
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|found
operator|=
name|TS_find_name
argument_list|(
name|gen_names
argument_list|,
name|tsa_name
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
comment|/* Get the next subject alternative name, 		   although there should be no more than one. */
name|GENERAL_NAMES_free
argument_list|(
name|gen_names
argument_list|)
expr_stmt|;
name|gen_names
operator|=
name|X509_get_ext_d2i
argument_list|(
name|signer
argument_list|,
name|NID_subject_alt_name
argument_list|,
name|NULL
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gen_names
condition|)
name|GENERAL_NAMES_free
argument_list|(
name|gen_names
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if name is in gen_names, 0 otherwise. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|TS_find_name
argument_list|(
name|STACK_OF
argument_list|(
name|GENERAL_NAME
argument_list|)
operator|*
name|gen_names
argument_list|,
name|GENERAL_NAME
operator|*
name|name
argument_list|)
block|{
name|int
name|i
decl_stmt|,
name|found
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|found
operator|=
literal|0
init|;
operator|!
name|found
operator|&&
name|i
operator|<
name|sk_GENERAL_NAME_num
argument_list|(
name|gen_names
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|GENERAL_NAME
modifier|*
name|current
init|=
name|sk_GENERAL_NAME_value
argument_list|(
name|gen_names
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|found
operator|=
name|GENERAL_NAME_cmp
argument_list|(
name|current
argument_list|,
name|name
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
return|return
name|found
condition|?
name|i
operator|-
literal|1
else|:
operator|-
literal|1
return|;
block|}
end_decl_stmt

end_unit

