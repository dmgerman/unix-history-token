begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/ts/ts_conf.c */
end_comment

begin_comment
comment|/*  * Written by Zoltan Glozik (zglozik@stones.com) for the OpenSSL project  * 2002.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_ENGINE
end_ifndef

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/ts.h>
end_include

begin_comment
comment|/* Macro definitions for the configuration file. */
end_comment

begin_define
define|#
directive|define
name|BASE_SECTION
value|"tsa"
end_define

begin_define
define|#
directive|define
name|ENV_DEFAULT_TSA
value|"default_tsa"
end_define

begin_define
define|#
directive|define
name|ENV_SERIAL
value|"serial"
end_define

begin_define
define|#
directive|define
name|ENV_CRYPTO_DEVICE
value|"crypto_device"
end_define

begin_define
define|#
directive|define
name|ENV_SIGNER_CERT
value|"signer_cert"
end_define

begin_define
define|#
directive|define
name|ENV_CERTS
value|"certs"
end_define

begin_define
define|#
directive|define
name|ENV_SIGNER_KEY
value|"signer_key"
end_define

begin_define
define|#
directive|define
name|ENV_DEFAULT_POLICY
value|"default_policy"
end_define

begin_define
define|#
directive|define
name|ENV_OTHER_POLICIES
value|"other_policies"
end_define

begin_define
define|#
directive|define
name|ENV_DIGESTS
value|"digests"
end_define

begin_define
define|#
directive|define
name|ENV_ACCURACY
value|"accuracy"
end_define

begin_define
define|#
directive|define
name|ENV_ORDERING
value|"ordering"
end_define

begin_define
define|#
directive|define
name|ENV_TSA_NAME
value|"tsa_name"
end_define

begin_define
define|#
directive|define
name|ENV_ESS_CERT_ID_CHAIN
value|"ess_cert_id_chain"
end_define

begin_define
define|#
directive|define
name|ENV_VALUE_SECS
value|"secs"
end_define

begin_define
define|#
directive|define
name|ENV_VALUE_MILLISECS
value|"millisecs"
end_define

begin_define
define|#
directive|define
name|ENV_VALUE_MICROSECS
value|"microsecs"
end_define

begin_define
define|#
directive|define
name|ENV_CLOCK_PRECISION_DIGITS
value|"clock_precision_digits"
end_define

begin_define
define|#
directive|define
name|ENV_VALUE_YES
value|"yes"
end_define

begin_define
define|#
directive|define
name|ENV_VALUE_NO
value|"no"
end_define

begin_comment
comment|/* Function definitions for certificate and key loading. */
end_comment

begin_function
name|X509
modifier|*
name|TS_CONF_load_cert
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|BIO
modifier|*
name|cert
init|=
name|NULL
decl_stmt|;
name|X509
modifier|*
name|x
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|cert
operator|=
name|BIO_new_file
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
name|x
operator|=
name|PEM_read_bio_X509_AUX
argument_list|(
name|cert
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to load certificate: %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_expr_stmt
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|TS_CONF_load_certs
argument_list|(
argument|const char *file
argument_list|)
block|{
name|BIO
operator|*
name|certs
operator|=
name|NULL
block|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|othercerts
operator|=
name|NULL
block|;
name|STACK_OF
argument_list|(
name|X509_INFO
argument_list|)
operator|*
name|allcerts
operator|=
name|NULL
block|;
name|int
name|i
block|;
if|if
condition|(
operator|!
operator|(
name|certs
operator|=
name|BIO_new_file
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
goto|goto
name|end
goto|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
operator|(
name|othercerts
operator|=
name|sk_X509_new_null
argument_list|()
operator|)
condition|)
goto|goto
name|end
goto|;
end_if

begin_expr_stmt
name|allcerts
operator|=
name|PEM_X509_INFO_read_bio
argument_list|(
name|certs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_INFO_num
argument_list|(
name|allcerts
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|X509_INFO
modifier|*
name|xi
init|=
name|sk_X509_INFO_value
argument_list|(
name|allcerts
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|xi
operator|->
name|x509
condition|)
block|{
name|sk_X509_push
argument_list|(
name|othercerts
argument_list|,
name|xi
operator|->
name|x509
argument_list|)
expr_stmt|;
name|xi
operator|->
name|x509
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_for

begin_label
name|end
label|:
end_label

begin_if
if|if
condition|(
name|othercerts
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to load certificates: %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|sk_X509_INFO_pop_free
argument_list|(
name|allcerts
argument_list|,
name|X509_INFO_free
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BIO_free
argument_list|(
name|certs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|othercerts
return|;
end_return

begin_expr_stmt
unit|}  EVP_PKEY
operator|*
name|TS_CONF_load_key
argument_list|(
argument|const char *file
argument_list|,
argument|const char *pass
argument_list|)
block|{
name|BIO
operator|*
name|key
operator|=
name|NULL
block|;
name|EVP_PKEY
operator|*
name|pkey
operator|=
name|NULL
block|;
if|if
condition|(
operator|!
operator|(
name|key
operator|=
name|BIO_new_file
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
goto|goto
name|end
goto|;
name|pkey
operator|=
name|PEM_read_bio_PrivateKey
argument_list|(
name|key
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pass
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|end
label|:
end_label

begin_if
if|if
condition|(
name|pkey
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to load private key: %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|BIO_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|pkey
return|;
end_return

begin_comment
unit|}
comment|/* Function definitions for handling configuration options. */
end_comment

begin_function
unit|static
name|void
name|TS_CONF_lookup_fail
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"variable lookup failed for %s::%s\n"
argument_list|,
name|name
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|TS_CONF_invalid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid variable value for %s::%s\n"
argument_list|,
name|name
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|TS_CONF_get_tsa_section
parameter_list|(
name|CONF
modifier|*
name|conf
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|)
block|{
if|if
condition|(
operator|!
name|section
condition|)
block|{
name|section
operator|=
name|NCONF_get_string
argument_list|(
name|conf
argument_list|,
name|BASE_SECTION
argument_list|,
name|ENV_DEFAULT_TSA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|section
condition|)
name|TS_CONF_lookup_fail
argument_list|(
name|BASE_SECTION
argument_list|,
name|ENV_DEFAULT_TSA
argument_list|)
expr_stmt|;
block|}
return|return
name|section
return|;
block|}
end_function

begin_function
name|int
name|TS_CONF_set_serial
parameter_list|(
name|CONF
modifier|*
name|conf
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|TS_serial_cb
name|cb
parameter_list|,
name|TS_RESP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|serial
init|=
name|NCONF_get_string
argument_list|(
name|conf
argument_list|,
name|section
argument_list|,
name|ENV_SERIAL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|serial
condition|)
block|{
name|TS_CONF_lookup_fail
argument_list|(
name|section
argument_list|,
name|ENV_SERIAL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|TS_RESP_CTX_set_serial_cb
argument_list|(
name|ctx
argument_list|,
name|cb
argument_list|,
name|serial
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_ENGINE
end_ifndef

begin_function
name|int
name|TS_CONF_set_crypto_device
parameter_list|(
name|CONF
modifier|*
name|conf
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|device
condition|)
name|device
operator|=
name|NCONF_get_string
argument_list|(
name|conf
argument_list|,
name|section
argument_list|,
name|ENV_CRYPTO_DEVICE
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|&&
operator|!
name|TS_CONF_set_default_engine
argument_list|(
name|device
argument_list|)
condition|)
block|{
name|TS_CONF_invalid
argument_list|(
name|section
argument_list|,
name|ENV_CRYPTO_DEVICE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|TS_CONF_set_default_engine
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ENGINE
modifier|*
name|e
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* Leave the default if builtin specified. */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"builtin"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|e
operator|=
name|ENGINE_by_id
argument_list|(
name|name
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
comment|/* Enable the use of the NCipher HSM for forked children. */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"chil"
argument_list|)
operator|==
literal|0
condition|)
name|ENGINE_ctrl
argument_list|(
name|e
argument_list|,
name|ENGINE_CTRL_CHIL_SET_FORKCHECK
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* All the operations are going to be carried out by the engine. */
if|if
condition|(
operator|!
name|ENGINE_set_default
argument_list|(
name|e
argument_list|,
name|ENGINE_METHOD_ALL
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|TSerr
argument_list|(
name|TS_F_TS_CONF_SET_DEFAULT_ENGINE
argument_list|,
name|TS_R_COULD_NOT_SET_ENGINE
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"engine:"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
condition|)
name|ENGINE_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|TS_CONF_set_signer_cert
parameter_list|(
name|CONF
modifier|*
name|conf
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|cert
parameter_list|,
name|TS_RESP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|X509
modifier|*
name|cert_obj
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|cert
condition|)
name|cert
operator|=
name|NCONF_get_string
argument_list|(
name|conf
argument_list|,
name|section
argument_list|,
name|ENV_SIGNER_CERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cert
condition|)
block|{
name|TS_CONF_lookup_fail
argument_list|(
name|section
argument_list|,
name|ENV_SIGNER_CERT
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|cert_obj
operator|=
name|TS_CONF_load_cert
argument_list|(
name|cert
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|TS_RESP_CTX_set_signer_cert
argument_list|(
name|ctx
argument_list|,
name|cert_obj
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|X509_free
argument_list|(
name|cert_obj
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|TS_CONF_set_certs
parameter_list|(
name|CONF
modifier|*
name|conf
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|certs
parameter_list|,
name|TS_RESP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|certs_obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|certs
condition|)
name|certs
operator|=
name|NCONF_get_string
argument_list|(
name|conf
argument_list|,
name|section
argument_list|,
name|ENV_CERTS
argument_list|)
expr_stmt|;
comment|/* Certificate chain is optional. */
if|if
condition|(
operator|!
name|certs
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
operator|(
name|certs_obj
operator|=
name|TS_CONF_load_certs
argument_list|(
name|certs
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|TS_RESP_CTX_set_certs
argument_list|(
name|ctx
argument_list|,
name|certs_obj
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|end
label|:
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|sk_X509_pop_free
argument_list|(
name|certs_obj
argument_list|,
name|X509_free
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|TS_CONF_set_signer_key
parameter_list|(
name|CONF
modifier|*
name|conf
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|pass
parameter_list|,
name|TS_RESP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|EVP_PKEY
modifier|*
name|key_obj
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
name|key
operator|=
name|NCONF_get_string
argument_list|(
name|conf
argument_list|,
name|section
argument_list|,
name|ENV_SIGNER_KEY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
block|{
name|TS_CONF_lookup_fail
argument_list|(
name|section
argument_list|,
name|ENV_SIGNER_KEY
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|key_obj
operator|=
name|TS_CONF_load_key
argument_list|(
name|key
argument_list|,
name|pass
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|TS_RESP_CTX_set_signer_key
argument_list|(
name|ctx
argument_list|,
name|key_obj
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|EVP_PKEY_free
argument_list|(
name|key_obj
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|TS_CONF_set_def_policy
parameter_list|(
name|CONF
modifier|*
name|conf
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|policy
parameter_list|,
name|TS_RESP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|ASN1_OBJECT
modifier|*
name|policy_obj
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|policy
condition|)
name|policy
operator|=
name|NCONF_get_string
argument_list|(
name|conf
argument_list|,
name|section
argument_list|,
name|ENV_DEFAULT_POLICY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|policy
condition|)
block|{
name|TS_CONF_lookup_fail
argument_list|(
name|section
argument_list|,
name|ENV_DEFAULT_POLICY
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|policy_obj
operator|=
name|OBJ_txt2obj
argument_list|(
name|policy
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|TS_CONF_invalid
argument_list|(
name|section
argument_list|,
name|ENV_DEFAULT_POLICY
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|TS_RESP_CTX_set_def_policy
argument_list|(
name|ctx
argument_list|,
name|policy_obj
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|ASN1_OBJECT_free
argument_list|(
name|policy_obj
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|TS_CONF_set_policies
parameter_list|(
name|CONF
modifier|*
name|conf
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|TS_RESP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
name|char
modifier|*
name|policies
init|=
name|NCONF_get_string
argument_list|(
name|conf
argument_list|,
name|section
argument_list|,
name|ENV_OTHER_POLICIES
argument_list|)
decl_stmt|;
comment|/* If no other policy is specified, that's fine. */
if|if
condition|(
name|policies
operator|&&
operator|!
operator|(
name|list
operator|=
name|X509V3_parse_list
argument_list|(
name|policies
argument_list|)
operator|)
condition|)
block|{
name|TS_CONF_invalid
argument_list|(
name|section
argument_list|,
name|ENV_OTHER_POLICIES
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_CONF_VALUE_num
argument_list|(
name|list
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|CONF_VALUE
modifier|*
name|val
init|=
name|sk_CONF_VALUE_value
argument_list|(
name|list
argument_list|,
name|i
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|extval
init|=
name|val
operator|->
name|value
condition|?
name|val
operator|->
name|value
else|:
name|val
operator|->
name|name
decl_stmt|;
name|ASN1_OBJECT
modifier|*
name|objtmp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|objtmp
operator|=
name|OBJ_txt2obj
argument_list|(
name|extval
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|TS_CONF_invalid
argument_list|(
name|section
argument_list|,
name|ENV_OTHER_POLICIES
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|TS_RESP_CTX_add_policy
argument_list|(
name|ctx
argument_list|,
name|objtmp
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ASN1_OBJECT_free
argument_list|(
name|objtmp
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|sk_CONF_VALUE_pop_free
argument_list|(
name|list
argument_list|,
name|X509V3_conf_free
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|TS_CONF_set_digests
parameter_list|(
name|CONF
modifier|*
name|conf
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|TS_RESP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
name|char
modifier|*
name|digests
init|=
name|NCONF_get_string
argument_list|(
name|conf
argument_list|,
name|section
argument_list|,
name|ENV_DIGESTS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|digests
condition|)
block|{
name|TS_CONF_lookup_fail
argument_list|(
name|section
argument_list|,
name|ENV_DIGESTS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|list
operator|=
name|X509V3_parse_list
argument_list|(
name|digests
argument_list|)
operator|)
condition|)
block|{
name|TS_CONF_invalid
argument_list|(
name|section
argument_list|,
name|ENV_DIGESTS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|sk_CONF_VALUE_num
argument_list|(
name|list
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TS_CONF_invalid
argument_list|(
name|section
argument_list|,
name|ENV_DIGESTS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_CONF_VALUE_num
argument_list|(
name|list
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|CONF_VALUE
modifier|*
name|val
init|=
name|sk_CONF_VALUE_value
argument_list|(
name|list
argument_list|,
name|i
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|extval
init|=
name|val
operator|->
name|value
condition|?
name|val
operator|->
name|value
else|:
name|val
operator|->
name|name
decl_stmt|;
specifier|const
name|EVP_MD
modifier|*
name|md
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|md
operator|=
name|EVP_get_digestbyname
argument_list|(
name|extval
argument_list|)
operator|)
condition|)
block|{
name|TS_CONF_invalid
argument_list|(
name|section
argument_list|,
name|ENV_DIGESTS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|TS_RESP_CTX_add_md
argument_list|(
name|ctx
argument_list|,
name|md
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|sk_CONF_VALUE_pop_free
argument_list|(
name|list
argument_list|,
name|X509V3_conf_free
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|TS_CONF_set_accuracy
parameter_list|(
name|CONF
modifier|*
name|conf
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|TS_RESP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|secs
init|=
literal|0
decl_stmt|,
name|millis
init|=
literal|0
decl_stmt|,
name|micros
init|=
literal|0
decl_stmt|;
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
name|char
modifier|*
name|accuracy
init|=
name|NCONF_get_string
argument_list|(
name|conf
argument_list|,
name|section
argument_list|,
name|ENV_ACCURACY
argument_list|)
decl_stmt|;
if|if
condition|(
name|accuracy
operator|&&
operator|!
operator|(
name|list
operator|=
name|X509V3_parse_list
argument_list|(
name|accuracy
argument_list|)
operator|)
condition|)
block|{
name|TS_CONF_invalid
argument_list|(
name|section
argument_list|,
name|ENV_ACCURACY
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_CONF_VALUE_num
argument_list|(
name|list
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|CONF_VALUE
modifier|*
name|val
init|=
name|sk_CONF_VALUE_value
argument_list|(
name|list
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|val
operator|->
name|name
argument_list|,
name|ENV_VALUE_SECS
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|->
name|value
condition|)
name|secs
operator|=
name|atoi
argument_list|(
name|val
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|val
operator|->
name|name
argument_list|,
name|ENV_VALUE_MILLISECS
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|->
name|value
condition|)
name|millis
operator|=
name|atoi
argument_list|(
name|val
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|val
operator|->
name|name
argument_list|,
name|ENV_VALUE_MICROSECS
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|->
name|value
condition|)
name|micros
operator|=
name|atoi
argument_list|(
name|val
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TS_CONF_invalid
argument_list|(
name|section
argument_list|,
name|ENV_ACCURACY
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|TS_RESP_CTX_set_accuracy
argument_list|(
name|ctx
argument_list|,
name|secs
argument_list|,
name|millis
argument_list|,
name|micros
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|sk_CONF_VALUE_pop_free
argument_list|(
name|list
argument_list|,
name|X509V3_conf_free
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|TS_CONF_set_clock_precision_digits
parameter_list|(
name|CONF
modifier|*
name|conf
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|TS_RESP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|long
name|digits
init|=
literal|0
decl_stmt|;
comment|/*      * If not specified, set the default value to 0, i.e. sec precision      */
if|if
condition|(
operator|!
name|NCONF_get_number_e
argument_list|(
name|conf
argument_list|,
name|section
argument_list|,
name|ENV_CLOCK_PRECISION_DIGITS
argument_list|,
operator|&
name|digits
argument_list|)
condition|)
name|digits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|digits
operator|<
literal|0
operator|||
name|digits
operator|>
name|TS_MAX_CLOCK_PRECISION_DIGITS
condition|)
block|{
name|TS_CONF_invalid
argument_list|(
name|section
argument_list|,
name|ENV_CLOCK_PRECISION_DIGITS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|TS_RESP_CTX_set_clock_precision_digits
argument_list|(
name|ctx
argument_list|,
name|digits
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
literal|1
return|;
name|err
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|TS_CONF_add_flag
parameter_list|(
name|CONF
modifier|*
name|conf
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|,
name|int
name|flag
parameter_list|,
name|TS_RESP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
comment|/* Default is false. */
specifier|const
name|char
modifier|*
name|value
init|=
name|NCONF_get_string
argument_list|(
name|conf
argument_list|,
name|section
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|ENV_VALUE_YES
argument_list|)
operator|==
literal|0
condition|)
name|TS_RESP_CTX_add_flags
argument_list|(
name|ctx
argument_list|,
name|flag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|ENV_VALUE_NO
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|TS_CONF_invalid
argument_list|(
name|section
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|TS_CONF_set_ordering
parameter_list|(
name|CONF
modifier|*
name|conf
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|TS_RESP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|TS_CONF_add_flag
argument_list|(
name|conf
argument_list|,
name|section
argument_list|,
name|ENV_ORDERING
argument_list|,
name|TS_ORDERING
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|TS_CONF_set_tsa_name
parameter_list|(
name|CONF
modifier|*
name|conf
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|TS_RESP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|TS_CONF_add_flag
argument_list|(
name|conf
argument_list|,
name|section
argument_list|,
name|ENV_TSA_NAME
argument_list|,
name|TS_TSA_NAME
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|TS_CONF_set_ess_cert_id_chain
parameter_list|(
name|CONF
modifier|*
name|conf
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|TS_RESP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|TS_CONF_add_flag
argument_list|(
name|conf
argument_list|,
name|section
argument_list|,
name|ENV_ESS_CERT_ID_CHAIN
argument_list|,
name|TS_ESS_CERT_ID_CHAIN
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

end_unit

