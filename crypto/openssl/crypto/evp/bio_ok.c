begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/evp/bio_ok.c */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *   * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *   * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from   *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *   * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_comment
comment|/* 	From: Arne Ansper<arne@cyber.ee>  	Why BIO_f_reliable?  	I wrote function which took BIO* as argument, read data from it 	and processed it. Then I wanted to store the input file in  	encrypted form. OK I pushed BIO_f_cipher to the BIO stack 	and everything was OK. BUT if user types wrong password  	BIO_f_cipher outputs only garbage and my function crashes. Yes 	I can and I should fix my function, but BIO_f_cipher is  	easy way to add encryption support to many existing applications 	and it's hard to debug and fix them all.   	So I wanted another BIO which would catch the incorrect passwords and 	file damages which cause garbage on BIO_f_cipher's output.   	The easy way is to push the BIO_f_md and save the checksum at  	the end of the file. However there are several problems with this 	approach:  	1) you must somehow separate checksum from actual data.  	2) you need lot's of memory when reading the file, because you  	must read to the end of the file and verify the checksum before 	letting the application to read the data.  	 	BIO_f_reliable tries to solve both problems, so that you can  	read and write arbitrary long streams using only fixed amount 	of memory.  	BIO_f_reliable splits data stream into blocks. Each block is prefixed 	with it's length and suffixed with it's digest. So you need only  	several Kbytes of memory to buffer single block before verifying  	it's digest.   	BIO_f_reliable goes further and adds several important capabilities:  	1) the digest of the block is computed over the whole stream  	-- so nobody can rearrange the blocks or remove or replace them.  	2) to detect invalid passwords right at the start BIO_f_reliable  	adds special prefix to the stream. In order to avoid known plain-text 	attacks this prefix is generated as follows:  		*) digest is initialized with random seed instead of  		standardized one. 		*) same seed is written to ouput 		*) well-known text is then hashed and the output  		of the digest is also written to output.  	reader can now read the seed from stream, hash the same string 	and then compare the digest output.  	Bad things: BIO_f_reliable knows what's going on in EVP_Digest. I  	initially wrote and tested this code on x86 machine and wrote the 	digests out in machine-dependent order :( There are people using 	this code and I cannot change this easily without making existing 	data files unreadable.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/buffer.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_function_decl
specifier|static
name|int
name|ok_write
parameter_list|(
name|BIO
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ok_read
parameter_list|(
name|BIO
modifier|*
name|h
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|ok_ctrl
parameter_list|(
name|BIO
modifier|*
name|h
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ok_new
parameter_list|(
name|BIO
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ok_free
parameter_list|(
name|BIO
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|ok_callback_ctrl
parameter_list|(
name|BIO
modifier|*
name|h
parameter_list|,
name|int
name|cmd
parameter_list|,
name|bio_info_cb
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sig_out
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sig_in
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|block_out
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|block_in
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|OK_BLOCK_SIZE
value|(1024*4)
end_define

begin_define
define|#
directive|define
name|OK_BLOCK_BLOCK
value|4
end_define

begin_define
define|#
directive|define
name|IOBS
value|(OK_BLOCK_SIZE+ OK_BLOCK_BLOCK+ 3*EVP_MAX_MD_SIZE)
end_define

begin_define
define|#
directive|define
name|WELLKNOWN
value|"The quick brown fox jumped over the lazy dog's back."
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|L_ENDIAN
end_ifndef

begin_define
define|#
directive|define
name|swapem
parameter_list|(
name|x
parameter_list|)
define|\
value|((unsigned long int)((((unsigned long int)(x)& 0x000000ffU)<< 24) | \ 			     (((unsigned long int)(x)& 0x0000ff00U)<<  8) | \ 			     (((unsigned long int)(x)& 0x00ff0000U)>>  8) | \ 			     (((unsigned long int)(x)& 0xff000000U)>> 24)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|swapem
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|ok_struct
block|{
name|int
name|buf_len
decl_stmt|;
name|int
name|buf_off
decl_stmt|;
name|int
name|buf_len_save
decl_stmt|;
name|int
name|buf_off_save
decl_stmt|;
name|int
name|cont
decl_stmt|;
comment|/*<= 0 when finished */
name|int
name|finished
decl_stmt|;
name|EVP_MD_CTX
name|md
decl_stmt|;
name|int
name|blockout
decl_stmt|;
comment|/* output block is ready */
name|int
name|sigio
decl_stmt|;
comment|/* must process signature */
name|unsigned
name|char
name|buf
index|[
name|IOBS
index|]
decl_stmt|;
block|}
name|BIO_OK_CTX
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|BIO_METHOD
name|methods_ok
init|=
block|{
name|BIO_TYPE_CIPHER
block|,
literal|"reliable"
block|,
name|ok_write
block|,
name|ok_read
block|,
name|NULL
block|,
comment|/* ok_puts, */
name|NULL
block|,
comment|/* ok_gets, */
name|ok_ctrl
block|,
name|ok_new
block|,
name|ok_free
block|,
name|ok_callback_ctrl
block|, 	}
decl_stmt|;
end_decl_stmt

begin_function
name|BIO_METHOD
modifier|*
name|BIO_f_reliable
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|&
name|methods_ok
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ok_new
parameter_list|(
name|BIO
modifier|*
name|bi
parameter_list|)
block|{
name|BIO_OK_CTX
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
operator|(
name|BIO_OK_CTX
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BIO_OK_CTX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ctx
operator|->
name|buf_len
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|buf_off
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|buf_len_save
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|buf_off_save
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|cont
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|finished
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|blockout
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|sigio
operator|=
literal|1
expr_stmt|;
name|EVP_MD_CTX_init
argument_list|(
operator|&
name|ctx
operator|->
name|md
argument_list|)
expr_stmt|;
name|bi
operator|->
name|init
operator|=
literal|0
expr_stmt|;
name|bi
operator|->
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|ctx
expr_stmt|;
name|bi
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ok_free
parameter_list|(
name|BIO
modifier|*
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
operator|(
operator|(
name|BIO_OK_CTX
operator|*
operator|)
name|a
operator|->
name|ptr
operator|)
operator|->
name|md
argument_list|)
expr_stmt|;
name|OPENSSL_cleanse
argument_list|(
name|a
operator|->
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|BIO_OK_CTX
argument_list|)
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|a
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|a
operator|->
name|ptr
operator|=
name|NULL
expr_stmt|;
name|a
operator|->
name|init
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ok_read
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
name|char
modifier|*
name|out
parameter_list|,
name|int
name|outl
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|BIO_OK_CTX
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ctx
operator|=
operator|(
name|BIO_OK_CTX
operator|*
operator|)
name|b
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|==
name|NULL
operator|)
operator|||
operator|(
name|b
operator|->
name|next_bio
operator|==
name|NULL
operator|)
operator|||
operator|(
name|b
operator|->
name|init
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|outl
operator|>
literal|0
condition|)
block|{
comment|/* copy clean bytes to output buffer */
if|if
condition|(
name|ctx
operator|->
name|blockout
condition|)
block|{
name|i
operator|=
name|ctx
operator|->
name|buf_len
operator|-
name|ctx
operator|->
name|buf_off
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|outl
condition|)
name|i
operator|=
name|outl
expr_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
operator|&
operator|(
name|ctx
operator|->
name|buf
index|[
name|ctx
operator|->
name|buf_off
index|]
operator|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|i
expr_stmt|;
name|out
operator|+=
name|i
expr_stmt|;
name|outl
operator|-=
name|i
expr_stmt|;
name|ctx
operator|->
name|buf_off
operator|+=
name|i
expr_stmt|;
comment|/* all clean bytes are out */
if|if
condition|(
name|ctx
operator|->
name|buf_len
operator|==
name|ctx
operator|->
name|buf_off
condition|)
block|{
name|ctx
operator|->
name|buf_off
operator|=
literal|0
expr_stmt|;
comment|/* copy start of the next block into proper place */
if|if
condition|(
name|ctx
operator|->
name|buf_len_save
operator|-
name|ctx
operator|->
name|buf_off_save
operator|>
literal|0
condition|)
block|{
name|ctx
operator|->
name|buf_len
operator|=
name|ctx
operator|->
name|buf_len_save
operator|-
name|ctx
operator|->
name|buf_off_save
expr_stmt|;
name|memmove
argument_list|(
name|ctx
operator|->
name|buf
argument_list|,
operator|&
operator|(
name|ctx
operator|->
name|buf
index|[
name|ctx
operator|->
name|buf_off_save
index|]
operator|)
argument_list|,
name|ctx
operator|->
name|buf_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|buf_len
operator|=
literal|0
expr_stmt|;
block|}
name|ctx
operator|->
name|blockout
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* output buffer full -- cancel */
if|if
condition|(
name|outl
operator|==
literal|0
condition|)
break|break;
comment|/* no clean bytes in buffer -- fill it */
name|n
operator|=
name|IOBS
operator|-
name|ctx
operator|->
name|buf_len
expr_stmt|;
name|i
operator|=
name|BIO_read
argument_list|(
name|b
operator|->
name|next_bio
argument_list|,
operator|&
operator|(
name|ctx
operator|->
name|buf
index|[
name|ctx
operator|->
name|buf_len
index|]
operator|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
comment|/* nothing new */
name|ctx
operator|->
name|buf_len
operator|+=
name|i
expr_stmt|;
comment|/* no signature yet -- check if we got one */
if|if
condition|(
name|ctx
operator|->
name|sigio
operator|==
literal|1
condition|)
name|sig_in
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* signature ok -- check if we got block */
if|if
condition|(
name|ctx
operator|->
name|sigio
operator|==
literal|0
condition|)
name|block_in
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* invalid block -- cancel */
if|if
condition|(
name|ctx
operator|->
name|cont
operator|<=
literal|0
condition|)
break|break;
block|}
name|BIO_clear_retry_flags
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|BIO_copy_next_retry
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ok_write
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|int
name|inl
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|;
name|BIO_OK_CTX
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
operator|(
name|BIO_OK_CTX
operator|*
operator|)
name|b
operator|->
name|ptr
expr_stmt|;
name|ret
operator|=
name|inl
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|==
name|NULL
operator|)
operator|||
operator|(
name|b
operator|->
name|next_bio
operator|==
name|NULL
operator|)
operator|||
operator|(
name|b
operator|->
name|init
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ctx
operator|->
name|sigio
condition|)
name|sig_out
argument_list|(
name|b
argument_list|)
expr_stmt|;
do|do
block|{
name|BIO_clear_retry_flags
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|n
operator|=
name|ctx
operator|->
name|buf_len
operator|-
name|ctx
operator|->
name|buf_off
expr_stmt|;
while|while
condition|(
name|ctx
operator|->
name|blockout
operator|&&
name|n
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|BIO_write
argument_list|(
name|b
operator|->
name|next_bio
argument_list|,
operator|&
operator|(
name|ctx
operator|->
name|buf
index|[
name|ctx
operator|->
name|buf_off
index|]
operator|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|BIO_copy_next_retry
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BIO_should_retry
argument_list|(
name|b
argument_list|)
condition|)
name|ctx
operator|->
name|cont
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|ctx
operator|->
name|buf_off
operator|+=
name|i
expr_stmt|;
name|n
operator|-=
name|i
expr_stmt|;
block|}
comment|/* at this point all pending data has been written */
name|ctx
operator|->
name|blockout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|buf_len
operator|==
name|ctx
operator|->
name|buf_off
condition|)
block|{
name|ctx
operator|->
name|buf_len
operator|=
name|OK_BLOCK_BLOCK
expr_stmt|;
name|ctx
operator|->
name|buf_off
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inl
operator|<=
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|n
operator|=
operator|(
name|inl
operator|+
name|ctx
operator|->
name|buf_len
operator|>
name|OK_BLOCK_SIZE
operator|+
name|OK_BLOCK_BLOCK
operator|)
condition|?
name|OK_BLOCK_SIZE
operator|+
name|OK_BLOCK_BLOCK
operator|-
name|ctx
operator|->
name|buf_len
else|:
name|inl
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|&
operator|(
name|ctx
operator|->
name|buf
index|[
name|ctx
operator|->
name|buf_len
index|]
operator|)
operator|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|buf_len
operator|+=
name|n
expr_stmt|;
name|inl
operator|-=
name|n
expr_stmt|;
name|in
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|buf_len
operator|>=
name|OK_BLOCK_SIZE
operator|+
name|OK_BLOCK_BLOCK
condition|)
block|{
name|block_out
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|inl
operator|>
literal|0
condition|)
do|;
name|BIO_clear_retry_flags
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|BIO_copy_next_retry
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|ok_ctrl
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|num
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|BIO_OK_CTX
modifier|*
name|ctx
decl_stmt|;
name|EVP_MD
modifier|*
name|md
decl_stmt|;
specifier|const
name|EVP_MD
modifier|*
modifier|*
name|ppmd
decl_stmt|;
name|long
name|ret
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ctx
operator|=
name|b
operator|->
name|ptr
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|BIO_CTRL_RESET
case|:
name|ctx
operator|->
name|buf_len
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|buf_off
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|buf_len_save
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|buf_off_save
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|cont
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|finished
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|blockout
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|sigio
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|BIO_ctrl
argument_list|(
name|b
operator|->
name|next_bio
argument_list|,
name|cmd
argument_list|,
name|num
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_CTRL_EOF
case|:
comment|/* More to read */
if|if
condition|(
name|ctx
operator|->
name|cont
operator|<=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
else|else
name|ret
operator|=
name|BIO_ctrl
argument_list|(
name|b
operator|->
name|next_bio
argument_list|,
name|cmd
argument_list|,
name|num
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_CTRL_PENDING
case|:
comment|/* More to read in buffer */
case|case
name|BIO_CTRL_WPENDING
case|:
comment|/* More to read in buffer */
name|ret
operator|=
name|ctx
operator|->
name|blockout
condition|?
name|ctx
operator|->
name|buf_len
operator|-
name|ctx
operator|->
name|buf_off
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
name|ret
operator|=
name|BIO_ctrl
argument_list|(
name|b
operator|->
name|next_bio
argument_list|,
name|cmd
argument_list|,
name|num
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_CTRL_FLUSH
case|:
comment|/* do a final write */
if|if
condition|(
name|ctx
operator|->
name|blockout
operator|==
literal|0
condition|)
name|block_out
argument_list|(
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
name|ctx
operator|->
name|blockout
condition|)
block|{
name|i
operator|=
name|ok_write
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|ctx
operator|->
name|finished
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|buf_off
operator|=
name|ctx
operator|->
name|buf_len
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|cont
operator|=
operator|(
name|int
operator|)
name|ret
expr_stmt|;
comment|/* Finally flush the underlying BIO */
name|ret
operator|=
name|BIO_ctrl
argument_list|(
name|b
operator|->
name|next_bio
argument_list|,
name|cmd
argument_list|,
name|num
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_C_DO_STATE_MACHINE
case|:
name|BIO_clear_retry_flags
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|ret
operator|=
name|BIO_ctrl
argument_list|(
name|b
operator|->
name|next_bio
argument_list|,
name|cmd
argument_list|,
name|num
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|BIO_copy_next_retry
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_CTRL_INFO
case|:
name|ret
operator|=
operator|(
name|long
operator|)
name|ctx
operator|->
name|cont
expr_stmt|;
break|break;
case|case
name|BIO_C_SET_MD
case|:
name|md
operator|=
name|ptr
expr_stmt|;
name|EVP_DigestInit_ex
argument_list|(
operator|&
name|ctx
operator|->
name|md
argument_list|,
name|md
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|b
operator|->
name|init
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BIO_C_GET_MD
case|:
if|if
condition|(
name|b
operator|->
name|init
condition|)
block|{
name|ppmd
operator|=
name|ptr
expr_stmt|;
operator|*
name|ppmd
operator|=
name|ctx
operator|->
name|md
operator|.
name|digest
expr_stmt|;
block|}
else|else
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|BIO_ctrl
argument_list|(
name|b
operator|->
name|next_bio
argument_list|,
name|cmd
argument_list|,
name|num
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|ok_callback_ctrl
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
name|int
name|cmd
parameter_list|,
name|bio_info_cb
modifier|*
name|fp
parameter_list|)
block|{
name|long
name|ret
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|next_bio
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
name|ret
operator|=
name|BIO_callback_ctrl
argument_list|(
name|b
operator|->
name|next_bio
argument_list|,
name|cmd
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|longswap
parameter_list|(
name|void
modifier|*
name|_ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|L_ENDIAN
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|_ptr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|4
control|)
block|{
operator|*
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
operator|(
name|ptr
index|[
name|i
index|]
operator|)
operator|)
operator|=
name|swapem
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
operator|(
name|ptr
index|[
name|i
index|]
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sig_out
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|)
block|{
name|BIO_OK_CTX
modifier|*
name|ctx
decl_stmt|;
name|EVP_MD_CTX
modifier|*
name|md
decl_stmt|;
name|ctx
operator|=
name|b
operator|->
name|ptr
expr_stmt|;
name|md
operator|=
operator|&
name|ctx
operator|->
name|md
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|buf_len
operator|+
literal|2
operator|*
name|md
operator|->
name|digest
operator|->
name|md_size
operator|>
name|OK_BLOCK_SIZE
condition|)
return|return;
name|EVP_DigestInit_ex
argument_list|(
name|md
argument_list|,
name|md
operator|->
name|digest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* FIXME: there's absolutely no guarantee this makes any sense at all, 	 * particularly now EVP_MD_CTX has been restructured. 	 */
name|RAND_pseudo_bytes
argument_list|(
name|md
operator|->
name|md_data
argument_list|,
name|md
operator|->
name|digest
operator|->
name|md_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|ctx
operator|->
name|buf
index|[
name|ctx
operator|->
name|buf_len
index|]
operator|)
argument_list|,
name|md
operator|->
name|md_data
argument_list|,
name|md
operator|->
name|digest
operator|->
name|md_size
argument_list|)
expr_stmt|;
name|longswap
argument_list|(
operator|&
operator|(
name|ctx
operator|->
name|buf
index|[
name|ctx
operator|->
name|buf_len
index|]
operator|)
argument_list|,
name|md
operator|->
name|digest
operator|->
name|md_size
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|buf_len
operator|+=
name|md
operator|->
name|digest
operator|->
name|md_size
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
name|md
argument_list|,
name|WELLKNOWN
argument_list|,
name|strlen
argument_list|(
name|WELLKNOWN
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestFinal_ex
argument_list|(
name|md
argument_list|,
operator|&
operator|(
name|ctx
operator|->
name|buf
index|[
name|ctx
operator|->
name|buf_len
index|]
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|buf_len
operator|+=
name|md
operator|->
name|digest
operator|->
name|md_size
expr_stmt|;
name|ctx
operator|->
name|blockout
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|sigio
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sig_in
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|)
block|{
name|BIO_OK_CTX
modifier|*
name|ctx
decl_stmt|;
name|EVP_MD_CTX
modifier|*
name|md
decl_stmt|;
name|unsigned
name|char
name|tmp
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|ctx
operator|=
name|b
operator|->
name|ptr
expr_stmt|;
name|md
operator|=
operator|&
name|ctx
operator|->
name|md
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|buf_len
operator|-
name|ctx
operator|->
name|buf_off
operator|<
literal|2
operator|*
name|md
operator|->
name|digest
operator|->
name|md_size
condition|)
return|return;
name|EVP_DigestInit_ex
argument_list|(
name|md
argument_list|,
name|md
operator|->
name|digest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|md
operator|->
name|md_data
argument_list|,
operator|&
operator|(
name|ctx
operator|->
name|buf
index|[
name|ctx
operator|->
name|buf_off
index|]
operator|)
argument_list|,
name|md
operator|->
name|digest
operator|->
name|md_size
argument_list|)
expr_stmt|;
name|longswap
argument_list|(
name|md
operator|->
name|md_data
argument_list|,
name|md
operator|->
name|digest
operator|->
name|md_size
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|buf_off
operator|+=
name|md
operator|->
name|digest
operator|->
name|md_size
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
name|md
argument_list|,
name|WELLKNOWN
argument_list|,
name|strlen
argument_list|(
name|WELLKNOWN
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestFinal_ex
argument_list|(
name|md
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|memcmp
argument_list|(
operator|&
operator|(
name|ctx
operator|->
name|buf
index|[
name|ctx
operator|->
name|buf_off
index|]
operator|)
argument_list|,
name|tmp
argument_list|,
name|md
operator|->
name|digest
operator|->
name|md_size
argument_list|)
operator|==
literal|0
expr_stmt|;
name|ctx
operator|->
name|buf_off
operator|+=
name|md
operator|->
name|digest
operator|->
name|md_size
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|ctx
operator|->
name|sigio
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|buf_len
operator|!=
name|ctx
operator|->
name|buf_off
condition|)
block|{
name|memmove
argument_list|(
name|ctx
operator|->
name|buf
argument_list|,
operator|&
operator|(
name|ctx
operator|->
name|buf
index|[
name|ctx
operator|->
name|buf_off
index|]
operator|)
argument_list|,
name|ctx
operator|->
name|buf_len
operator|-
name|ctx
operator|->
name|buf_off
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|->
name|buf_len
operator|-=
name|ctx
operator|->
name|buf_off
expr_stmt|;
name|ctx
operator|->
name|buf_off
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|cont
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|block_out
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|)
block|{
name|BIO_OK_CTX
modifier|*
name|ctx
decl_stmt|;
name|EVP_MD_CTX
modifier|*
name|md
decl_stmt|;
name|unsigned
name|long
name|tl
decl_stmt|;
name|ctx
operator|=
name|b
operator|->
name|ptr
expr_stmt|;
name|md
operator|=
operator|&
name|ctx
operator|->
name|md
expr_stmt|;
name|tl
operator|=
name|ctx
operator|->
name|buf_len
operator|-
name|OK_BLOCK_BLOCK
expr_stmt|;
name|tl
operator|=
name|swapem
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ctx
operator|->
name|buf
argument_list|,
operator|&
name|tl
argument_list|,
name|OK_BLOCK_BLOCK
argument_list|)
expr_stmt|;
name|tl
operator|=
name|swapem
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
name|md
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
name|ctx
operator|->
name|buf
index|[
name|OK_BLOCK_BLOCK
index|]
operator|)
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|EVP_DigestFinal_ex
argument_list|(
name|md
argument_list|,
operator|&
operator|(
name|ctx
operator|->
name|buf
index|[
name|ctx
operator|->
name|buf_len
index|]
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|buf_len
operator|+=
name|md
operator|->
name|digest
operator|->
name|md_size
expr_stmt|;
name|ctx
operator|->
name|blockout
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|block_in
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|)
block|{
name|BIO_OK_CTX
modifier|*
name|ctx
decl_stmt|;
name|EVP_MD_CTX
modifier|*
name|md
decl_stmt|;
name|long
name|tl
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|tmp
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
name|ctx
operator|=
name|b
operator|->
name|ptr
expr_stmt|;
name|md
operator|=
operator|&
name|ctx
operator|->
name|md
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tl
argument_list|,
name|ctx
operator|->
name|buf
argument_list|,
name|OK_BLOCK_BLOCK
argument_list|)
expr_stmt|;
name|tl
operator|=
name|swapem
argument_list|(
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|buf_len
operator|<
name|tl
operator|+
name|OK_BLOCK_BLOCK
operator|+
name|md
operator|->
name|digest
operator|->
name|md_size
condition|)
return|return;
name|EVP_DigestUpdate
argument_list|(
name|md
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
name|ctx
operator|->
name|buf
index|[
name|OK_BLOCK_BLOCK
index|]
operator|)
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|EVP_DigestFinal_ex
argument_list|(
name|md
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
operator|(
name|ctx
operator|->
name|buf
index|[
name|tl
operator|+
name|OK_BLOCK_BLOCK
index|]
operator|)
argument_list|,
name|tmp
argument_list|,
name|md
operator|->
name|digest
operator|->
name|md_size
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* there might be parts from next block lurking around ! */
name|ctx
operator|->
name|buf_off_save
operator|=
name|tl
operator|+
name|OK_BLOCK_BLOCK
operator|+
name|md
operator|->
name|digest
operator|->
name|md_size
expr_stmt|;
name|ctx
operator|->
name|buf_len_save
operator|=
name|ctx
operator|->
name|buf_len
expr_stmt|;
name|ctx
operator|->
name|buf_off
operator|=
name|OK_BLOCK_BLOCK
expr_stmt|;
name|ctx
operator|->
name|buf_len
operator|=
name|tl
operator|+
name|OK_BLOCK_BLOCK
expr_stmt|;
name|ctx
operator|->
name|blockout
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|cont
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

