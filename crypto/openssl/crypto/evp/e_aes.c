begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ====================================================================  * Copyright (c) 2001-2011 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  */
end_comment

begin_include
include|#
directive|include
file|<openssl/opensslconf.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_AES
end_ifndef

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<openssl/aes.h>
end_include

begin_include
include|#
directive|include
file|"evp_locl.h"
end_include

begin_include
include|#
directive|include
file|"modes_lcl.h"
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_undef
undef|#
directive|undef
name|EVP_CIPH_FLAG_FIPS
end_undef

begin_define
define|#
directive|define
name|EVP_CIPH_FLAG_FIPS
value|0
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
union|union
block|{
name|double
name|align
decl_stmt|;
name|AES_KEY
name|ks
decl_stmt|;
block|}
name|ks
union|;
name|block128_f
name|block
decl_stmt|;
union|union
block|{
name|cbc128_f
name|cbc
decl_stmt|;
name|ctr128_f
name|ctr
decl_stmt|;
block|}
name|stream
union|;
block|}
name|EVP_AES_KEY
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
union|union
block|{
name|double
name|align
decl_stmt|;
name|AES_KEY
name|ks
decl_stmt|;
block|}
name|ks
union|;
comment|/* AES key schedule to use */
name|int
name|key_set
decl_stmt|;
comment|/* Set if key initialised */
name|int
name|iv_set
decl_stmt|;
comment|/* Set if an iv is set */
name|GCM128_CONTEXT
name|gcm
decl_stmt|;
name|unsigned
name|char
modifier|*
name|iv
decl_stmt|;
comment|/* Temporary IV store */
name|int
name|ivlen
decl_stmt|;
comment|/* IV length */
name|int
name|taglen
decl_stmt|;
name|int
name|iv_gen
decl_stmt|;
comment|/* It is OK to generate IVs */
name|int
name|tls_aad_len
decl_stmt|;
comment|/* TLS AAD length */
name|ctr128_f
name|ctr
decl_stmt|;
block|}
name|EVP_AES_GCM_CTX
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
union|union
block|{
name|double
name|align
decl_stmt|;
name|AES_KEY
name|ks
decl_stmt|;
block|}
name|ks1
union|,
name|ks2
union|;
comment|/* AES key schedules to use */
name|XTS128_CONTEXT
name|xts
decl_stmt|;
name|void
function_decl|(
modifier|*
name|stream
function_decl|)
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key1
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key2
parameter_list|,
specifier|const
name|unsigned
name|char
name|iv
index|[
literal|16
index|]
parameter_list|)
function_decl|;
block|}
name|EVP_AES_XTS_CTX
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
union|union
block|{
name|double
name|align
decl_stmt|;
name|AES_KEY
name|ks
decl_stmt|;
block|}
name|ks
union|;
comment|/* AES key schedule to use */
name|int
name|key_set
decl_stmt|;
comment|/* Set if key initialised */
name|int
name|iv_set
decl_stmt|;
comment|/* Set if an iv is set */
name|int
name|tag_set
decl_stmt|;
comment|/* Set if tag is valid */
name|int
name|len_set
decl_stmt|;
comment|/* Set if message length set */
name|int
name|L
decl_stmt|,
name|M
decl_stmt|;
comment|/* L and M parameters from RFC3610 */
name|CCM128_CONTEXT
name|ccm
decl_stmt|;
name|ccm128_f
name|str
decl_stmt|;
block|}
name|EVP_AES_CCM_CTX
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MAXBITCHUNK
value|((size_t)1<<(sizeof(size_t)*8-4))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|VPAES_ASM
end_ifdef

begin_function_decl
name|int
name|vpaes_set_encrypt_key
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|userKey
parameter_list|,
name|int
name|bits
parameter_list|,
name|AES_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|vpaes_set_decrypt_key
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|userKey
parameter_list|,
name|int
name|bits
parameter_list|,
name|AES_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|vpaes_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|vpaes_decrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|vpaes_cbc_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|,
name|int
name|enc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSAES_ASM
end_ifdef

begin_function_decl
name|void
name|bsaes_cbc_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
name|ivec
index|[
literal|16
index|]
parameter_list|,
name|int
name|enc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bsaes_ctr32_encrypt_blocks
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
name|ivec
index|[
literal|16
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bsaes_xts_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|inp
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key1
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key2
parameter_list|,
specifier|const
name|unsigned
name|char
name|iv
index|[
literal|16
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bsaes_xts_decrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|inp
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key1
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key2
parameter_list|,
specifier|const
name|unsigned
name|char
name|iv
index|[
literal|16
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AES_CTR_ASM
end_ifdef

begin_function_decl
name|void
name|AES_ctr32_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|blocks
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
name|ivec
index|[
name|AES_BLOCK_SIZE
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AES_XTS_ASM
end_ifdef

begin_function_decl
name|void
name|AES_xts_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|inp
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key1
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key2
parameter_list|,
specifier|const
name|unsigned
name|char
name|iv
index|[
literal|16
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|AES_xts_decrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|inp
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key1
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key2
parameter_list|,
specifier|const
name|unsigned
name|char
name|iv
index|[
literal|16
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_CPUID_OBJ
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__powerpc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ppc__
argument_list|)
operator|||
name|defined
argument_list|(
name|_ARCH_PPC
argument_list|)
operator|)
end_if

begin_include
include|#
directive|include
file|"ppc_arch.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VPAES_ASM
end_ifdef

begin_define
define|#
directive|define
name|VPAES_CAPABLE
value|(OPENSSL_ppccap_P& PPC_ALTIVEC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HWAES_CAPABLE
value|(OPENSSL_ppccap_P& PPC_CRYPTO207)
end_define

begin_define
define|#
directive|define
name|HWAES_set_encrypt_key
value|aes_p8_set_encrypt_key
end_define

begin_define
define|#
directive|define
name|HWAES_set_decrypt_key
value|aes_p8_set_decrypt_key
end_define

begin_define
define|#
directive|define
name|HWAES_encrypt
value|aes_p8_encrypt
end_define

begin_define
define|#
directive|define
name|HWAES_decrypt
value|aes_p8_decrypt
end_define

begin_define
define|#
directive|define
name|HWAES_cbc_encrypt
value|aes_p8_cbc_encrypt
end_define

begin_define
define|#
directive|define
name|HWAES_ctr32_encrypt_blocks
value|aes_p8_ctr32_encrypt_blocks
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|AES_ASM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|I386_ONLY
argument_list|)
operator|&&
operator|(
expr|\
operator|(
operator|(
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|_M_IX86
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|OPENSSL_IA32_SSE2
argument_list|)
operator|)
operator|||
expr|\
name|defined
argument_list|(
name|__x86_64
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|_M_AMD64
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_X64
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__INTEL__
argument_list|)
operator|)
end_if

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|OPENSSL_ia32cap_P
index|[]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VPAES_ASM
end_ifdef

begin_define
define|#
directive|define
name|VPAES_CAPABLE
value|(OPENSSL_ia32cap_P[1]&(1<<(41-32)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSAES_ASM
end_ifdef

begin_define
define|#
directive|define
name|BSAES_CAPABLE
value|(OPENSSL_ia32cap_P[1]&(1<<(41-32)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * AES-NI section  */
end_comment

begin_define
define|#
directive|define
name|AESNI_CAPABLE
value|(OPENSSL_ia32cap_P[1]&(1<<(57-32)))
end_define

begin_function_decl
name|int
name|aesni_set_encrypt_key
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|userKey
parameter_list|,
name|int
name|bits
parameter_list|,
name|AES_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|aesni_set_decrypt_key
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|userKey
parameter_list|,
name|int
name|bits
parameter_list|,
name|AES_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aesni_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aesni_decrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aesni_ecb_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
name|int
name|enc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aesni_cbc_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|,
name|int
name|enc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aesni_ctr32_encrypt_blocks
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|blocks
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aesni_xts_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key1
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key2
parameter_list|,
specifier|const
name|unsigned
name|char
name|iv
index|[
literal|16
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aesni_xts_decrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key1
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key2
parameter_list|,
specifier|const
name|unsigned
name|char
name|iv
index|[
literal|16
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aesni_ccm64_encrypt_blocks
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|blocks
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
name|ivec
index|[
literal|16
index|]
parameter_list|,
name|unsigned
name|char
name|cmac
index|[
literal|16
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aesni_ccm64_decrypt_blocks
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|blocks
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
name|ivec
index|[
literal|16
index|]
parameter_list|,
name|unsigned
name|char
name|cmac
index|[
literal|16
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__x86_64
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_AMD64
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_X64
argument_list|)
end_if

begin_function_decl
name|size_t
name|aesni_gcm_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
name|ivec
index|[
literal|16
index|]
parameter_list|,
name|u64
modifier|*
name|Xi
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|AES_gcm_encrypt
value|aesni_gcm_encrypt
end_define

begin_function_decl
name|size_t
name|aesni_gcm_decrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
name|ivec
index|[
literal|16
index|]
parameter_list|,
name|u64
modifier|*
name|Xi
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|AES_gcm_decrypt
value|aesni_gcm_decrypt
end_define

begin_function_decl
name|void
name|gcm_ghash_avx
parameter_list|(
name|u64
name|Xi
index|[
literal|2
index|]
parameter_list|,
specifier|const
name|u128
name|Htable
index|[
literal|16
index|]
parameter_list|,
specifier|const
name|u8
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|AES_GCM_ASM
parameter_list|(
name|gctx
parameter_list|)
value|(gctx->ctr==aesni_ctr32_encrypt_blocks&& \                                  gctx->gcm.ghash==gcm_ghash_avx)
end_define

begin_define
define|#
directive|define
name|AES_GCM_ASM2
parameter_list|(
name|gctx
parameter_list|)
value|(gctx->gcm.block==(block128_f)aesni_encrypt&& \                                  gctx->gcm.ghash==gcm_ghash_avx)
end_define

begin_undef
undef|#
directive|undef
name|AES_GCM_ASM2
end_undef

begin_comment
comment|/* minor size optimization */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|aesni_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|mode
decl_stmt|;
name|EVP_AES_KEY
modifier|*
name|dat
init|=
operator|(
name|EVP_AES_KEY
operator|*
operator|)
name|ctx
operator|->
name|cipher_data
decl_stmt|;
name|mode
operator|=
name|ctx
operator|->
name|cipher
operator|->
name|flags
operator|&
name|EVP_CIPH_MODE
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|==
name|EVP_CIPH_ECB_MODE
operator|||
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
operator|)
operator|&&
operator|!
name|enc
condition|)
block|{
name|ret
operator|=
name|aesni_set_decrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
name|ctx
operator|->
name|cipher_data
argument_list|)
expr_stmt|;
name|dat
operator|->
name|block
operator|=
operator|(
name|block128_f
operator|)
name|aesni_decrypt
expr_stmt|;
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
condition|?
operator|(
name|cbc128_f
operator|)
name|aesni_cbc_encrypt
else|:
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|aesni_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
name|ctx
operator|->
name|cipher_data
argument_list|)
expr_stmt|;
name|dat
operator|->
name|block
operator|=
operator|(
name|block128_f
operator|)
name|aesni_encrypt
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
condition|)
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
operator|(
name|cbc128_f
operator|)
name|aesni_cbc_encrypt
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|EVP_CIPH_CTR_MODE
condition|)
name|dat
operator|->
name|stream
operator|.
name|ctr
operator|=
operator|(
name|ctr128_f
operator|)
name|aesni_ctr32_encrypt_blocks
expr_stmt|;
else|else
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|EVPerr
argument_list|(
name|EVP_F_AESNI_INIT_KEY
argument_list|,
name|EVP_R_AES_KEY_SETUP_FAILED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aesni_cbc_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|aesni_cbc_encrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
name|ctx
operator|->
name|cipher_data
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
name|ctx
operator|->
name|encrypt
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aesni_ecb_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|bl
init|=
name|ctx
operator|->
name|cipher
operator|->
name|block_size
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|bl
condition|)
return|return
literal|1
return|;
name|aesni_ecb_encrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
name|ctx
operator|->
name|cipher_data
argument_list|,
name|ctx
operator|->
name|encrypt
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|aesni_ofb_cipher
value|aes_ofb_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aesni_ofb_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|aesni_cfb_cipher
value|aes_cfb_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aesni_cfb_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|aesni_cfb8_cipher
value|aes_cfb8_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aesni_cfb8_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|aesni_cfb1_cipher
value|aes_cfb1_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aesni_cfb1_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|aesni_ctr_cipher
value|aes_ctr_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aesni_ctr_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|aesni_gcm_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|EVP_AES_GCM_CTX
modifier|*
name|gctx
init|=
name|ctx
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
operator|!
name|iv
operator|&&
operator|!
name|key
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|key
condition|)
block|{
name|aesni_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|gctx
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|CRYPTO_gcm128_init
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
operator|&
name|gctx
operator|->
name|ks
argument_list|,
operator|(
name|block128_f
operator|)
name|aesni_encrypt
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|ctr
operator|=
operator|(
name|ctr128_f
operator|)
name|aesni_ctr32_encrypt_blocks
expr_stmt|;
comment|/*          * If we have an iv can set it directly, otherwise use saved IV.          */
if|if
condition|(
name|iv
operator|==
name|NULL
operator|&&
name|gctx
operator|->
name|iv_set
condition|)
name|iv
operator|=
name|gctx
operator|->
name|iv
expr_stmt|;
if|if
condition|(
name|iv
condition|)
block|{
name|CRYPTO_gcm128_setiv
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|iv
argument_list|,
name|gctx
operator|->
name|ivlen
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|iv_set
operator|=
literal|1
expr_stmt|;
block|}
name|gctx
operator|->
name|key_set
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* If key set use IV, otherwise copy */
if|if
condition|(
name|gctx
operator|->
name|key_set
condition|)
name|CRYPTO_gcm128_setiv
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|iv
argument_list|,
name|gctx
operator|->
name|ivlen
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|gctx
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
name|gctx
operator|->
name|ivlen
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|iv_set
operator|=
literal|1
expr_stmt|;
name|gctx
operator|->
name|iv_gen
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|aesni_gcm_cipher
value|aes_gcm_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aesni_gcm_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|aesni_xts_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|EVP_AES_XTS_CTX
modifier|*
name|xctx
init|=
name|ctx
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
operator|!
name|iv
operator|&&
operator|!
name|key
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|key
condition|)
block|{
comment|/* key_len is two AES keys */
if|if
condition|(
name|enc
condition|)
block|{
name|aesni_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|4
argument_list|,
operator|&
name|xctx
operator|->
name|ks1
operator|.
name|ks
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|block1
operator|=
operator|(
name|block128_f
operator|)
name|aesni_encrypt
expr_stmt|;
name|xctx
operator|->
name|stream
operator|=
name|aesni_xts_encrypt
expr_stmt|;
block|}
else|else
block|{
name|aesni_set_decrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|4
argument_list|,
operator|&
name|xctx
operator|->
name|ks1
operator|.
name|ks
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|block1
operator|=
operator|(
name|block128_f
operator|)
name|aesni_decrypt
expr_stmt|;
name|xctx
operator|->
name|stream
operator|=
name|aesni_xts_decrypt
expr_stmt|;
block|}
name|aesni_set_encrypt_key
argument_list|(
name|key
operator|+
name|ctx
operator|->
name|key_len
operator|/
literal|2
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|4
argument_list|,
operator|&
name|xctx
operator|->
name|ks2
operator|.
name|ks
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|block2
operator|=
operator|(
name|block128_f
operator|)
name|aesni_encrypt
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|key1
operator|=
operator|&
name|xctx
operator|->
name|ks1
expr_stmt|;
block|}
if|if
condition|(
name|iv
condition|)
block|{
name|xctx
operator|->
name|xts
operator|.
name|key2
operator|=
operator|&
name|xctx
operator|->
name|ks2
expr_stmt|;
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|aesni_xts_cipher
value|aes_xts_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aesni_xts_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|aesni_ccm_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|EVP_AES_CCM_CTX
modifier|*
name|cctx
init|=
name|ctx
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
operator|!
name|iv
operator|&&
operator|!
name|key
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|key
condition|)
block|{
name|aesni_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|cctx
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|CRYPTO_ccm128_init
argument_list|(
operator|&
name|cctx
operator|->
name|ccm
argument_list|,
name|cctx
operator|->
name|M
argument_list|,
name|cctx
operator|->
name|L
argument_list|,
operator|&
name|cctx
operator|->
name|ks
argument_list|,
operator|(
name|block128_f
operator|)
name|aesni_encrypt
argument_list|)
expr_stmt|;
name|cctx
operator|->
name|str
operator|=
name|enc
condition|?
operator|(
name|ccm128_f
operator|)
name|aesni_ccm64_encrypt_blocks
else|:
operator|(
name|ccm128_f
operator|)
name|aesni_ccm64_decrypt_blocks
expr_stmt|;
name|cctx
operator|->
name|key_set
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|iv
condition|)
block|{
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
literal|15
operator|-
name|cctx
operator|->
name|L
argument_list|)
expr_stmt|;
name|cctx
operator|->
name|iv_set
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|aesni_ccm_cipher
value|aes_ccm_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aesni_ccm_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BLOCK_CIPHER_generic
parameter_list|(
name|nid
parameter_list|,
name|keylen
parameter_list|,
name|blocksize
parameter_list|,
name|ivlen
parameter_list|,
name|nmode
parameter_list|,
name|mode
parameter_list|,
name|MODE
parameter_list|,
name|flags
parameter_list|)
define|\
value|static const EVP_CIPHER aesni_##keylen##_##mode = { \         nid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \         flags|EVP_CIPH_##MODE##_MODE,   \         aesni_init_key,                 \         aesni_##mode##_cipher,          \         NULL,                           \         sizeof(EVP_AES_KEY),            \         NULL,NULL,NULL,NULL }; \ static const EVP_CIPHER aes_##keylen##_##mode = { \         nid##_##keylen##_##nmode,blocksize,     \         keylen/8,ivlen, \         flags|EVP_CIPH_##MODE##_MODE,   \         aes_init_key,                   \         aes_##mode##_cipher,            \         NULL,                           \         sizeof(EVP_AES_KEY),            \         NULL,NULL,NULL,NULL }; \ const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \ { return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
end_define

begin_define
define|#
directive|define
name|BLOCK_CIPHER_custom
parameter_list|(
name|nid
parameter_list|,
name|keylen
parameter_list|,
name|blocksize
parameter_list|,
name|ivlen
parameter_list|,
name|mode
parameter_list|,
name|MODE
parameter_list|,
name|flags
parameter_list|)
define|\
value|static const EVP_CIPHER aesni_##keylen##_##mode = { \         nid##_##keylen##_##mode,blocksize, \         (EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \         flags|EVP_CIPH_##MODE##_MODE,   \         aesni_##mode##_init_key,        \         aesni_##mode##_cipher,          \         aes_##mode##_cleanup,           \         sizeof(EVP_AES_##MODE##_CTX),   \         NULL,NULL,aes_##mode##_ctrl,NULL }; \ static const EVP_CIPHER aes_##keylen##_##mode = { \         nid##_##keylen##_##mode,blocksize, \         (EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \         flags|EVP_CIPH_##MODE##_MODE,   \         aes_##mode##_init_key,          \         aes_##mode##_cipher,            \         aes_##mode##_cleanup,           \         sizeof(EVP_AES_##MODE##_CTX),   \         NULL,NULL,aes_##mode##_ctrl,NULL }; \ const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \ { return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|AES_ASM
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__sparc
argument_list|)
operator|||
name|defined
argument_list|(
name|__sparc__
argument_list|)
operator|)
end_elif

begin_include
include|#
directive|include
file|"sparc_arch.h"
end_include

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|OPENSSL_sparcv9cap_P
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SPARC_AES_CAPABLE
value|(OPENSSL_sparcv9cap_P[1]& CFR_AES)
end_define

begin_function_decl
name|void
name|aes_t4_set_encrypt_key
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|int
name|bits
parameter_list|,
name|AES_KEY
modifier|*
name|ks
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aes_t4_set_decrypt_key
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|int
name|bits
parameter_list|,
name|AES_KEY
modifier|*
name|ks
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aes_t4_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aes_t4_decrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Key-length specific subroutines were chosen for following reason.  * Each SPARC T4 core can execute up to 8 threads which share core's  * resources. Loading as much key material to registers allows to  * minimize references to shared memory interface, as well as amount  * of instructions in inner loops [much needed on T4]. But then having  * non-key-length specific routines would require conditional branches  * either in inner loops or on subroutines' entries. Former is hardly  * acceptable, while latter means code size increase to size occupied  * by multiple key-length specfic subroutines, so why fight?  */
end_comment

begin_function_decl
name|void
name|aes128_t4_cbc_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aes128_t4_cbc_decrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aes192_t4_cbc_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aes192_t4_cbc_decrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aes256_t4_cbc_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aes256_t4_cbc_decrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aes128_t4_ctr32_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|blocks
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aes192_t4_ctr32_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|blocks
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aes256_t4_ctr32_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|blocks
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aes128_t4_xts_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|blocks
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key1
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key2
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aes128_t4_xts_decrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|blocks
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key1
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key2
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aes256_t4_xts_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|blocks
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key1
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key2
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aes256_t4_xts_decrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|blocks
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key1
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key2
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|aes_t4_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|mode
decl_stmt|,
name|bits
decl_stmt|;
name|EVP_AES_KEY
modifier|*
name|dat
init|=
operator|(
name|EVP_AES_KEY
operator|*
operator|)
name|ctx
operator|->
name|cipher_data
decl_stmt|;
name|mode
operator|=
name|ctx
operator|->
name|cipher
operator|->
name|flags
operator|&
name|EVP_CIPH_MODE
expr_stmt|;
name|bits
operator|=
name|ctx
operator|->
name|key_len
operator|*
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|==
name|EVP_CIPH_ECB_MODE
operator|||
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
operator|)
operator|&&
operator|!
name|enc
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
name|aes_t4_set_decrypt_key
argument_list|(
name|key
argument_list|,
name|bits
argument_list|,
name|ctx
operator|->
name|cipher_data
argument_list|)
expr_stmt|;
name|dat
operator|->
name|block
operator|=
operator|(
name|block128_f
operator|)
name|aes_t4_decrypt
expr_stmt|;
switch|switch
condition|(
name|bits
condition|)
block|{
case|case
literal|128
case|:
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
condition|?
operator|(
name|cbc128_f
operator|)
name|aes128_t4_cbc_decrypt
else|:
name|NULL
expr_stmt|;
break|break;
case|case
literal|192
case|:
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
condition|?
operator|(
name|cbc128_f
operator|)
name|aes192_t4_cbc_decrypt
else|:
name|NULL
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
condition|?
operator|(
name|cbc128_f
operator|)
name|aes256_t4_cbc_decrypt
else|:
name|NULL
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
literal|0
expr_stmt|;
name|aes_t4_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|bits
argument_list|,
name|ctx
operator|->
name|cipher_data
argument_list|)
expr_stmt|;
name|dat
operator|->
name|block
operator|=
operator|(
name|block128_f
operator|)
name|aes_t4_encrypt
expr_stmt|;
switch|switch
condition|(
name|bits
condition|)
block|{
case|case
literal|128
case|:
if|if
condition|(
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
condition|)
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
operator|(
name|cbc128_f
operator|)
name|aes128_t4_cbc_encrypt
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|EVP_CIPH_CTR_MODE
condition|)
name|dat
operator|->
name|stream
operator|.
name|ctr
operator|=
operator|(
name|ctr128_f
operator|)
name|aes128_t4_ctr32_encrypt
expr_stmt|;
else|else
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|192
case|:
if|if
condition|(
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
condition|)
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
operator|(
name|cbc128_f
operator|)
name|aes192_t4_cbc_encrypt
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|EVP_CIPH_CTR_MODE
condition|)
name|dat
operator|->
name|stream
operator|.
name|ctr
operator|=
operator|(
name|ctr128_f
operator|)
name|aes192_t4_ctr32_encrypt
expr_stmt|;
else|else
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|256
case|:
if|if
condition|(
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
condition|)
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
operator|(
name|cbc128_f
operator|)
name|aes256_t4_cbc_encrypt
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|EVP_CIPH_CTR_MODE
condition|)
name|dat
operator|->
name|stream
operator|.
name|ctr
operator|=
operator|(
name|ctr128_f
operator|)
name|aes256_t4_ctr32_encrypt
expr_stmt|;
else|else
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|EVPerr
argument_list|(
name|EVP_F_AES_T4_INIT_KEY
argument_list|,
name|EVP_R_AES_KEY_SETUP_FAILED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|aes_t4_cbc_cipher
value|aes_cbc_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aes_t4_cbc_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|aes_t4_ecb_cipher
value|aes_ecb_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aes_t4_ecb_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|aes_t4_ofb_cipher
value|aes_ofb_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aes_t4_ofb_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|aes_t4_cfb_cipher
value|aes_cfb_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aes_t4_cfb_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|aes_t4_cfb8_cipher
value|aes_cfb8_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aes_t4_cfb8_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|aes_t4_cfb1_cipher
value|aes_cfb1_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aes_t4_cfb1_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|aes_t4_ctr_cipher
value|aes_ctr_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aes_t4_ctr_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|aes_t4_gcm_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|EVP_AES_GCM_CTX
modifier|*
name|gctx
init|=
name|ctx
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
operator|!
name|iv
operator|&&
operator|!
name|key
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|key
condition|)
block|{
name|int
name|bits
init|=
name|ctx
operator|->
name|key_len
operator|*
literal|8
decl_stmt|;
name|aes_t4_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|bits
argument_list|,
operator|&
name|gctx
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|CRYPTO_gcm128_init
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
operator|&
name|gctx
operator|->
name|ks
argument_list|,
operator|(
name|block128_f
operator|)
name|aes_t4_encrypt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bits
condition|)
block|{
case|case
literal|128
case|:
name|gctx
operator|->
name|ctr
operator|=
operator|(
name|ctr128_f
operator|)
name|aes128_t4_ctr32_encrypt
expr_stmt|;
break|break;
case|case
literal|192
case|:
name|gctx
operator|->
name|ctr
operator|=
operator|(
name|ctr128_f
operator|)
name|aes192_t4_ctr32_encrypt
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|gctx
operator|->
name|ctr
operator|=
operator|(
name|ctr128_f
operator|)
name|aes256_t4_ctr32_encrypt
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
comment|/*          * If we have an iv can set it directly, otherwise use saved IV.          */
if|if
condition|(
name|iv
operator|==
name|NULL
operator|&&
name|gctx
operator|->
name|iv_set
condition|)
name|iv
operator|=
name|gctx
operator|->
name|iv
expr_stmt|;
if|if
condition|(
name|iv
condition|)
block|{
name|CRYPTO_gcm128_setiv
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|iv
argument_list|,
name|gctx
operator|->
name|ivlen
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|iv_set
operator|=
literal|1
expr_stmt|;
block|}
name|gctx
operator|->
name|key_set
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* If key set use IV, otherwise copy */
if|if
condition|(
name|gctx
operator|->
name|key_set
condition|)
name|CRYPTO_gcm128_setiv
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|iv
argument_list|,
name|gctx
operator|->
name|ivlen
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|gctx
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
name|gctx
operator|->
name|ivlen
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|iv_set
operator|=
literal|1
expr_stmt|;
name|gctx
operator|->
name|iv_gen
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|aes_t4_gcm_cipher
value|aes_gcm_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aes_t4_gcm_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|aes_t4_xts_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|EVP_AES_XTS_CTX
modifier|*
name|xctx
init|=
name|ctx
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
operator|!
name|iv
operator|&&
operator|!
name|key
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|key
condition|)
block|{
name|int
name|bits
init|=
name|ctx
operator|->
name|key_len
operator|*
literal|4
decl_stmt|;
name|xctx
operator|->
name|stream
operator|=
name|NULL
expr_stmt|;
comment|/* key_len is two AES keys */
if|if
condition|(
name|enc
condition|)
block|{
name|aes_t4_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|bits
argument_list|,
operator|&
name|xctx
operator|->
name|ks1
operator|.
name|ks
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|block1
operator|=
operator|(
name|block128_f
operator|)
name|aes_t4_encrypt
expr_stmt|;
switch|switch
condition|(
name|bits
condition|)
block|{
case|case
literal|128
case|:
name|xctx
operator|->
name|stream
operator|=
name|aes128_t4_xts_encrypt
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* not yet */
block|case 192:                 xctx->stream = aes192_t4_xts_encrypt;                 break;
endif|#
directive|endif
case|case
literal|256
case|:
name|xctx
operator|->
name|stream
operator|=
name|aes256_t4_xts_encrypt
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|aes_t4_set_decrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|4
argument_list|,
operator|&
name|xctx
operator|->
name|ks1
operator|.
name|ks
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|block1
operator|=
operator|(
name|block128_f
operator|)
name|aes_t4_decrypt
expr_stmt|;
switch|switch
condition|(
name|bits
condition|)
block|{
case|case
literal|128
case|:
name|xctx
operator|->
name|stream
operator|=
name|aes128_t4_xts_decrypt
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* not yet */
block|case 192:                 xctx->stream = aes192_t4_xts_decrypt;                 break;
endif|#
directive|endif
case|case
literal|256
case|:
name|xctx
operator|->
name|stream
operator|=
name|aes256_t4_xts_decrypt
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
name|aes_t4_set_encrypt_key
argument_list|(
name|key
operator|+
name|ctx
operator|->
name|key_len
operator|/
literal|2
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|4
argument_list|,
operator|&
name|xctx
operator|->
name|ks2
operator|.
name|ks
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|block2
operator|=
operator|(
name|block128_f
operator|)
name|aes_t4_encrypt
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|key1
operator|=
operator|&
name|xctx
operator|->
name|ks1
expr_stmt|;
block|}
if|if
condition|(
name|iv
condition|)
block|{
name|xctx
operator|->
name|xts
operator|.
name|key2
operator|=
operator|&
name|xctx
operator|->
name|ks2
expr_stmt|;
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|aes_t4_xts_cipher
value|aes_xts_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aes_t4_xts_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|aes_t4_ccm_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|EVP_AES_CCM_CTX
modifier|*
name|cctx
init|=
name|ctx
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
operator|!
name|iv
operator|&&
operator|!
name|key
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|key
condition|)
block|{
name|int
name|bits
init|=
name|ctx
operator|->
name|key_len
operator|*
literal|8
decl_stmt|;
name|aes_t4_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|bits
argument_list|,
operator|&
name|cctx
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|CRYPTO_ccm128_init
argument_list|(
operator|&
name|cctx
operator|->
name|ccm
argument_list|,
name|cctx
operator|->
name|M
argument_list|,
name|cctx
operator|->
name|L
argument_list|,
operator|&
name|cctx
operator|->
name|ks
argument_list|,
operator|(
name|block128_f
operator|)
name|aes_t4_encrypt
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* not yet */
block|switch (bits) {         case 128:             cctx->str = enc ? (ccm128_f) aes128_t4_ccm64_encrypt :                 (ccm128_f) ae128_t4_ccm64_decrypt;             break;         case 192:             cctx->str = enc ? (ccm128_f) aes192_t4_ccm64_encrypt :                 (ccm128_f) ae192_t4_ccm64_decrypt;             break;         case 256:             cctx->str = enc ? (ccm128_f) aes256_t4_ccm64_encrypt :                 (ccm128_f) ae256_t4_ccm64_decrypt;             break;         default:             return 0;         }
else|#
directive|else
name|cctx
operator|->
name|str
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|cctx
operator|->
name|key_set
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|iv
condition|)
block|{
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
literal|15
operator|-
name|cctx
operator|->
name|L
argument_list|)
expr_stmt|;
name|cctx
operator|->
name|iv_set
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|aes_t4_ccm_cipher
value|aes_ccm_cipher
end_define

begin_function_decl
specifier|static
name|int
name|aes_t4_ccm_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BLOCK_CIPHER_generic
parameter_list|(
name|nid
parameter_list|,
name|keylen
parameter_list|,
name|blocksize
parameter_list|,
name|ivlen
parameter_list|,
name|nmode
parameter_list|,
name|mode
parameter_list|,
name|MODE
parameter_list|,
name|flags
parameter_list|)
define|\
value|static const EVP_CIPHER aes_t4_##keylen##_##mode = { \         nid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \         flags|EVP_CIPH_##MODE##_MODE,   \         aes_t4_init_key,                \         aes_t4_##mode##_cipher,         \         NULL,                           \         sizeof(EVP_AES_KEY),            \         NULL,NULL,NULL,NULL }; \ static const EVP_CIPHER aes_##keylen##_##mode = { \         nid##_##keylen##_##nmode,blocksize,     \         keylen/8,ivlen, \         flags|EVP_CIPH_##MODE##_MODE,   \         aes_init_key,                   \         aes_##mode##_cipher,            \         NULL,                           \         sizeof(EVP_AES_KEY),            \         NULL,NULL,NULL,NULL }; \ const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \ { return SPARC_AES_CAPABLE?&aes_t4_##keylen##_##mode:&aes_##keylen##_##mode; }
end_define

begin_define
define|#
directive|define
name|BLOCK_CIPHER_custom
parameter_list|(
name|nid
parameter_list|,
name|keylen
parameter_list|,
name|blocksize
parameter_list|,
name|ivlen
parameter_list|,
name|mode
parameter_list|,
name|MODE
parameter_list|,
name|flags
parameter_list|)
define|\
value|static const EVP_CIPHER aes_t4_##keylen##_##mode = { \         nid##_##keylen##_##mode,blocksize, \         (EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \         flags|EVP_CIPH_##MODE##_MODE,   \         aes_t4_##mode##_init_key,       \         aes_t4_##mode##_cipher,         \         aes_##mode##_cleanup,           \         sizeof(EVP_AES_##MODE##_CTX),   \         NULL,NULL,aes_##mode##_ctrl,NULL }; \ static const EVP_CIPHER aes_##keylen##_##mode = { \         nid##_##keylen##_##mode,blocksize, \         (EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \         flags|EVP_CIPH_##MODE##_MODE,   \         aes_##mode##_init_key,          \         aes_##mode##_cipher,            \         aes_##mode##_cleanup,           \         sizeof(EVP_AES_##MODE##_CTX),   \         NULL,NULL,aes_##mode##_ctrl,NULL }; \ const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \ { return SPARC_AES_CAPABLE?&aes_t4_##keylen##_##mode:&aes_##keylen##_##mode; }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BLOCK_CIPHER_generic
parameter_list|(
name|nid
parameter_list|,
name|keylen
parameter_list|,
name|blocksize
parameter_list|,
name|ivlen
parameter_list|,
name|nmode
parameter_list|,
name|mode
parameter_list|,
name|MODE
parameter_list|,
name|flags
parameter_list|)
define|\
value|static const EVP_CIPHER aes_##keylen##_##mode = { \         nid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \         flags|EVP_CIPH_##MODE##_MODE,   \         aes_init_key,                   \         aes_##mode##_cipher,            \         NULL,                           \         sizeof(EVP_AES_KEY),            \         NULL,NULL,NULL,NULL }; \ const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \ { return&aes_##keylen##_##mode; }
end_define

begin_define
define|#
directive|define
name|BLOCK_CIPHER_custom
parameter_list|(
name|nid
parameter_list|,
name|keylen
parameter_list|,
name|blocksize
parameter_list|,
name|ivlen
parameter_list|,
name|mode
parameter_list|,
name|MODE
parameter_list|,
name|flags
parameter_list|)
define|\
value|static const EVP_CIPHER aes_##keylen##_##mode = { \         nid##_##keylen##_##mode,blocksize, \         (EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \         flags|EVP_CIPH_##MODE##_MODE,   \         aes_##mode##_init_key,          \         aes_##mode##_cipher,            \         aes_##mode##_cleanup,           \         sizeof(EVP_AES_##MODE##_CTX),   \         NULL,NULL,aes_##mode##_ctrl,NULL }; \ const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \ { return&aes_##keylen##_##mode; }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_CPUID_OBJ
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__arm__
argument_list|)
operator|||
name|defined
argument_list|(
name|__arm
argument_list|)
operator|||
name|defined
argument_list|(
name|__aarch64__
argument_list|)
operator|)
end_if

begin_include
include|#
directive|include
file|"arm_arch.h"
end_include

begin_if
if|#
directive|if
name|__ARM_MAX_ARCH__
operator|>=
literal|7
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSAES_ASM
argument_list|)
end_if

begin_define
define|#
directive|define
name|BSAES_CAPABLE
value|(OPENSSL_armcap_P& ARMV7_NEON)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HWAES_CAPABLE
value|(OPENSSL_armcap_P& ARMV8_AES)
end_define

begin_define
define|#
directive|define
name|HWAES_set_encrypt_key
value|aes_v8_set_encrypt_key
end_define

begin_define
define|#
directive|define
name|HWAES_set_decrypt_key
value|aes_v8_set_decrypt_key
end_define

begin_define
define|#
directive|define
name|HWAES_encrypt
value|aes_v8_encrypt
end_define

begin_define
define|#
directive|define
name|HWAES_decrypt
value|aes_v8_decrypt
end_define

begin_define
define|#
directive|define
name|HWAES_cbc_encrypt
value|aes_v8_cbc_encrypt
end_define

begin_define
define|#
directive|define
name|HWAES_ctr32_encrypt_blocks
value|aes_v8_ctr32_encrypt_blocks
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HWAES_CAPABLE
argument_list|)
end_if

begin_function_decl
name|int
name|HWAES_set_encrypt_key
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|userKey
parameter_list|,
specifier|const
name|int
name|bits
parameter_list|,
name|AES_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|HWAES_set_decrypt_key
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|userKey
parameter_list|,
specifier|const
name|int
name|bits
parameter_list|,
name|AES_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|HWAES_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|HWAES_decrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|HWAES_cbc_encrypt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
modifier|*
name|ivec
parameter_list|,
specifier|const
name|int
name|enc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|HWAES_ctr32_encrypt_blocks
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|AES_KEY
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
name|ivec
index|[
literal|16
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BLOCK_CIPHER_generic_pack
parameter_list|(
name|nid
parameter_list|,
name|keylen
parameter_list|,
name|flags
parameter_list|)
define|\
value|BLOCK_CIPHER_generic(nid,keylen,16,16,cbc,cbc,CBC,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)     \         BLOCK_CIPHER_generic(nid,keylen,16,0,ecb,ecb,ECB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)      \         BLOCK_CIPHER_generic(nid,keylen,1,16,ofb128,ofb,OFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)   \         BLOCK_CIPHER_generic(nid,keylen,1,16,cfb128,cfb,CFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)   \         BLOCK_CIPHER_generic(nid,keylen,1,16,cfb1,cfb1,CFB,flags)       \         BLOCK_CIPHER_generic(nid,keylen,1,16,cfb8,cfb8,CFB,flags)       \         BLOCK_CIPHER_generic(nid,keylen,1,16,ctr,ctr,CTR,flags)
end_define

begin_function
specifier|static
name|int
name|aes_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|mode
decl_stmt|;
name|EVP_AES_KEY
modifier|*
name|dat
init|=
operator|(
name|EVP_AES_KEY
operator|*
operator|)
name|ctx
operator|->
name|cipher_data
decl_stmt|;
name|mode
operator|=
name|ctx
operator|->
name|cipher
operator|->
name|flags
operator|&
name|EVP_CIPH_MODE
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|==
name|EVP_CIPH_ECB_MODE
operator|||
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
operator|)
operator|&&
operator|!
name|enc
condition|)
ifdef|#
directive|ifdef
name|HWAES_CAPABLE
if|if
condition|(
name|HWAES_CAPABLE
condition|)
block|{
name|ret
operator|=
name|HWAES_set_decrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|dat
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|dat
operator|->
name|block
operator|=
operator|(
name|block128_f
operator|)
name|HWAES_decrypt
expr_stmt|;
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|HWAES_cbc_encrypt
if|if
condition|(
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
condition|)
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
operator|(
name|cbc128_f
operator|)
name|HWAES_cbc_encrypt
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSAES_CAPABLE
if|if
condition|(
name|BSAES_CAPABLE
operator|&&
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
condition|)
block|{
name|ret
operator|=
name|AES_set_decrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|dat
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|dat
operator|->
name|block
operator|=
operator|(
name|block128_f
operator|)
name|AES_decrypt
expr_stmt|;
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
operator|(
name|cbc128_f
operator|)
name|bsaes_cbc_encrypt
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VPAES_CAPABLE
if|if
condition|(
name|VPAES_CAPABLE
condition|)
block|{
name|ret
operator|=
name|vpaes_set_decrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|dat
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|dat
operator|->
name|block
operator|=
operator|(
name|block128_f
operator|)
name|vpaes_decrypt
expr_stmt|;
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
condition|?
operator|(
name|cbc128_f
operator|)
name|vpaes_cbc_encrypt
else|:
name|NULL
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|ret
operator|=
name|AES_set_decrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|dat
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|dat
operator|->
name|block
operator|=
operator|(
name|block128_f
operator|)
name|AES_decrypt
expr_stmt|;
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
condition|?
operator|(
name|cbc128_f
operator|)
name|AES_cbc_encrypt
else|:
name|NULL
expr_stmt|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|HWAES_CAPABLE
if|if
condition|(
name|HWAES_CAPABLE
condition|)
block|{
name|ret
operator|=
name|HWAES_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|dat
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|dat
operator|->
name|block
operator|=
operator|(
name|block128_f
operator|)
name|HWAES_encrypt
expr_stmt|;
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|HWAES_cbc_encrypt
if|if
condition|(
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
condition|)
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
operator|(
name|cbc128_f
operator|)
name|HWAES_cbc_encrypt
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HWAES_ctr32_encrypt_blocks
if|if
condition|(
name|mode
operator|==
name|EVP_CIPH_CTR_MODE
condition|)
name|dat
operator|->
name|stream
operator|.
name|ctr
operator|=
operator|(
name|ctr128_f
operator|)
name|HWAES_ctr32_encrypt_blocks
expr_stmt|;
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
literal|0
expr_stmt|;
comment|/* terminate potentially open 'else' */
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSAES_CAPABLE
if|if
condition|(
name|BSAES_CAPABLE
operator|&&
name|mode
operator|==
name|EVP_CIPH_CTR_MODE
condition|)
block|{
name|ret
operator|=
name|AES_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|dat
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|dat
operator|->
name|block
operator|=
operator|(
name|block128_f
operator|)
name|AES_encrypt
expr_stmt|;
name|dat
operator|->
name|stream
operator|.
name|ctr
operator|=
operator|(
name|ctr128_f
operator|)
name|bsaes_ctr32_encrypt_blocks
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VPAES_CAPABLE
if|if
condition|(
name|VPAES_CAPABLE
condition|)
block|{
name|ret
operator|=
name|vpaes_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|dat
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|dat
operator|->
name|block
operator|=
operator|(
name|block128_f
operator|)
name|vpaes_encrypt
expr_stmt|;
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
condition|?
operator|(
name|cbc128_f
operator|)
name|vpaes_cbc_encrypt
else|:
name|NULL
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|ret
operator|=
name|AES_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|dat
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|dat
operator|->
name|block
operator|=
operator|(
name|block128_f
operator|)
name|AES_encrypt
expr_stmt|;
name|dat
operator|->
name|stream
operator|.
name|cbc
operator|=
name|mode
operator|==
name|EVP_CIPH_CBC_MODE
condition|?
operator|(
name|cbc128_f
operator|)
name|AES_cbc_encrypt
else|:
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|AES_CTR_ASM
if|if
condition|(
name|mode
operator|==
name|EVP_CIPH_CTR_MODE
condition|)
name|dat
operator|->
name|stream
operator|.
name|ctr
operator|=
operator|(
name|ctr128_f
operator|)
name|AES_ctr32_encrypt
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|EVPerr
argument_list|(
name|EVP_F_AES_INIT_KEY
argument_list|,
name|EVP_R_AES_KEY_SETUP_FAILED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aes_cbc_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|EVP_AES_KEY
modifier|*
name|dat
init|=
operator|(
name|EVP_AES_KEY
operator|*
operator|)
name|ctx
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
name|dat
operator|->
name|stream
operator|.
name|cbc
condition|)
call|(
modifier|*
name|dat
operator|->
name|stream
operator|.
name|cbc
call|)
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
operator|&
name|dat
operator|->
name|ks
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
name|ctx
operator|->
name|encrypt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|->
name|encrypt
condition|)
name|CRYPTO_cbc128_encrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
operator|&
name|dat
operator|->
name|ks
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
name|dat
operator|->
name|block
argument_list|)
expr_stmt|;
else|else
name|CRYPTO_cbc128_decrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
operator|&
name|dat
operator|->
name|ks
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
name|dat
operator|->
name|block
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aes_ecb_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|bl
init|=
name|ctx
operator|->
name|cipher
operator|->
name|block_size
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|EVP_AES_KEY
modifier|*
name|dat
init|=
operator|(
name|EVP_AES_KEY
operator|*
operator|)
name|ctx
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|bl
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|len
operator|-=
name|bl
init|;
name|i
operator|<=
name|len
condition|;
name|i
operator|+=
name|bl
control|)
call|(
modifier|*
name|dat
operator|->
name|block
call|)
argument_list|(
name|in
operator|+
name|i
argument_list|,
name|out
operator|+
name|i
argument_list|,
operator|&
name|dat
operator|->
name|ks
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aes_ofb_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|EVP_AES_KEY
modifier|*
name|dat
init|=
operator|(
name|EVP_AES_KEY
operator|*
operator|)
name|ctx
operator|->
name|cipher_data
decl_stmt|;
name|CRYPTO_ofb128_encrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
operator|&
name|dat
operator|->
name|ks
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
operator|&
name|ctx
operator|->
name|num
argument_list|,
name|dat
operator|->
name|block
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aes_cfb_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|EVP_AES_KEY
modifier|*
name|dat
init|=
operator|(
name|EVP_AES_KEY
operator|*
operator|)
name|ctx
operator|->
name|cipher_data
decl_stmt|;
name|CRYPTO_cfb128_encrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
operator|&
name|dat
operator|->
name|ks
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
operator|&
name|ctx
operator|->
name|num
argument_list|,
name|ctx
operator|->
name|encrypt
argument_list|,
name|dat
operator|->
name|block
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aes_cfb8_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|EVP_AES_KEY
modifier|*
name|dat
init|=
operator|(
name|EVP_AES_KEY
operator|*
operator|)
name|ctx
operator|->
name|cipher_data
decl_stmt|;
name|CRYPTO_cfb128_8_encrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
operator|&
name|dat
operator|->
name|ks
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
operator|&
name|ctx
operator|->
name|num
argument_list|,
name|ctx
operator|->
name|encrypt
argument_list|,
name|dat
operator|->
name|block
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aes_cfb1_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|EVP_AES_KEY
modifier|*
name|dat
init|=
operator|(
name|EVP_AES_KEY
operator|*
operator|)
name|ctx
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|flags
operator|&
name|EVP_CIPH_FLAG_LENGTH_BITS
condition|)
block|{
name|CRYPTO_cfb128_1_encrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
operator|&
name|dat
operator|->
name|ks
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
operator|&
name|ctx
operator|->
name|num
argument_list|,
name|ctx
operator|->
name|encrypt
argument_list|,
name|dat
operator|->
name|block
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
while|while
condition|(
name|len
operator|>=
name|MAXBITCHUNK
condition|)
block|{
name|CRYPTO_cfb128_1_encrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|MAXBITCHUNK
operator|*
literal|8
argument_list|,
operator|&
name|dat
operator|->
name|ks
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
operator|&
name|ctx
operator|->
name|num
argument_list|,
name|ctx
operator|->
name|encrypt
argument_list|,
name|dat
operator|->
name|block
argument_list|)
expr_stmt|;
name|len
operator|-=
name|MAXBITCHUNK
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
name|CRYPTO_cfb128_1_encrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
operator|*
literal|8
argument_list|,
operator|&
name|dat
operator|->
name|ks
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
operator|&
name|ctx
operator|->
name|num
argument_list|,
name|ctx
operator|->
name|encrypt
argument_list|,
name|dat
operator|->
name|block
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aes_ctr_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|num
init|=
name|ctx
operator|->
name|num
decl_stmt|;
name|EVP_AES_KEY
modifier|*
name|dat
init|=
operator|(
name|EVP_AES_KEY
operator|*
operator|)
name|ctx
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
name|dat
operator|->
name|stream
operator|.
name|ctr
condition|)
name|CRYPTO_ctr128_encrypt_ctr32
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
operator|&
name|dat
operator|->
name|ks
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
name|ctx
operator|->
name|buf
argument_list|,
operator|&
name|num
argument_list|,
name|dat
operator|->
name|stream
operator|.
name|ctr
argument_list|)
expr_stmt|;
else|else
name|CRYPTO_ctr128_encrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
operator|&
name|dat
operator|->
name|ks
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
name|ctx
operator|->
name|buf
argument_list|,
operator|&
name|num
argument_list|,
name|dat
operator|->
name|block
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|num
operator|=
operator|(
name|size_t
operator|)
name|num
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_macro
name|BLOCK_CIPHER_generic_pack
argument_list|(
argument|NID_aes
argument_list|,
literal|128
argument_list|,
argument|EVP_CIPH_FLAG_FIPS
argument_list|)
end_macro

begin_macro
name|BLOCK_CIPHER_generic_pack
argument_list|(
argument|NID_aes
argument_list|,
literal|192
argument_list|,
argument|EVP_CIPH_FLAG_FIPS
argument_list|)
end_macro

begin_macro
name|BLOCK_CIPHER_generic_pack
argument_list|(
argument|NID_aes
argument_list|,
literal|256
argument_list|,
argument|EVP_CIPH_FLAG_FIPS
argument_list|)
end_macro

begin_function
specifier|static
name|int
name|aes_gcm_cleanup
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|c
parameter_list|)
block|{
name|EVP_AES_GCM_CTX
modifier|*
name|gctx
init|=
name|c
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
name|gctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|OPENSSL_cleanse
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
sizeof|sizeof
argument_list|(
name|gctx
operator|->
name|gcm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gctx
operator|->
name|iv
operator|!=
name|c
operator|->
name|iv
condition|)
name|OPENSSL_free
argument_list|(
name|gctx
operator|->
name|iv
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* increment counter (64-bit int) by 1 */
end_comment

begin_function
specifier|static
name|void
name|ctr64_inc
parameter_list|(
name|unsigned
name|char
modifier|*
name|counter
parameter_list|)
block|{
name|int
name|n
init|=
literal|8
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
do|do
block|{
operator|--
name|n
expr_stmt|;
name|c
operator|=
name|counter
index|[
name|n
index|]
expr_stmt|;
operator|++
name|c
expr_stmt|;
name|counter
index|[
name|n
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
condition|)
return|return;
block|}
do|while
condition|(
name|n
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|aes_gcm_ctrl
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|c
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|arg
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|EVP_AES_GCM_CTX
modifier|*
name|gctx
init|=
name|c
operator|->
name|cipher_data
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EVP_CTRL_INIT
case|:
name|gctx
operator|->
name|key_set
operator|=
literal|0
expr_stmt|;
name|gctx
operator|->
name|iv_set
operator|=
literal|0
expr_stmt|;
name|gctx
operator|->
name|ivlen
operator|=
name|c
operator|->
name|cipher
operator|->
name|iv_len
expr_stmt|;
name|gctx
operator|->
name|iv
operator|=
name|c
operator|->
name|iv
expr_stmt|;
name|gctx
operator|->
name|taglen
operator|=
operator|-
literal|1
expr_stmt|;
name|gctx
operator|->
name|iv_gen
operator|=
literal|0
expr_stmt|;
name|gctx
operator|->
name|tls_aad_len
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|EVP_CTRL_GCM_SET_IVLEN
case|:
if|if
condition|(
name|arg
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Allocate memory for IV if needed */
if|if
condition|(
operator|(
name|arg
operator|>
name|EVP_MAX_IV_LENGTH
operator|)
operator|&&
operator|(
name|arg
operator|>
name|gctx
operator|->
name|ivlen
operator|)
condition|)
block|{
if|if
condition|(
name|gctx
operator|->
name|iv
operator|!=
name|c
operator|->
name|iv
condition|)
name|OPENSSL_free
argument_list|(
name|gctx
operator|->
name|iv
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|iv
operator|=
name|OPENSSL_malloc
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gctx
operator|->
name|iv
condition|)
return|return
literal|0
return|;
block|}
name|gctx
operator|->
name|ivlen
operator|=
name|arg
expr_stmt|;
return|return
literal|1
return|;
case|case
name|EVP_CTRL_GCM_SET_TAG
case|:
if|if
condition|(
name|arg
operator|<=
literal|0
operator|||
name|arg
operator|>
literal|16
operator|||
name|c
operator|->
name|encrypt
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|c
operator|->
name|buf
argument_list|,
name|ptr
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|taglen
operator|=
name|arg
expr_stmt|;
return|return
literal|1
return|;
case|case
name|EVP_CTRL_GCM_GET_TAG
case|:
if|if
condition|(
name|arg
operator|<=
literal|0
operator|||
name|arg
operator|>
literal|16
operator|||
operator|!
name|c
operator|->
name|encrypt
operator|||
name|gctx
operator|->
name|taglen
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|c
operator|->
name|buf
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|EVP_CTRL_GCM_SET_IV_FIXED
case|:
comment|/* Special case: -1 length restores whole IV */
if|if
condition|(
name|arg
operator|==
operator|-
literal|1
condition|)
block|{
name|memcpy
argument_list|(
name|gctx
operator|->
name|iv
argument_list|,
name|ptr
argument_list|,
name|gctx
operator|->
name|ivlen
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|iv_gen
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*          * Fixed field must be at least 4 bytes and invocation field at least          * 8.          */
if|if
condition|(
operator|(
name|arg
operator|<
literal|4
operator|)
operator|||
operator|(
name|gctx
operator|->
name|ivlen
operator|-
name|arg
operator|)
operator|<
literal|8
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|arg
condition|)
name|memcpy
argument_list|(
name|gctx
operator|->
name|iv
argument_list|,
name|ptr
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|encrypt
operator|&&
name|RAND_bytes
argument_list|(
name|gctx
operator|->
name|iv
operator|+
name|arg
argument_list|,
name|gctx
operator|->
name|ivlen
operator|-
name|arg
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|gctx
operator|->
name|iv_gen
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|EVP_CTRL_GCM_IV_GEN
case|:
if|if
condition|(
name|gctx
operator|->
name|iv_gen
operator|==
literal|0
operator|||
name|gctx
operator|->
name|key_set
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|CRYPTO_gcm128_setiv
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|gctx
operator|->
name|iv
argument_list|,
name|gctx
operator|->
name|ivlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|<=
literal|0
operator|||
name|arg
operator|>
name|gctx
operator|->
name|ivlen
condition|)
name|arg
operator|=
name|gctx
operator|->
name|ivlen
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|gctx
operator|->
name|iv
operator|+
name|gctx
operator|->
name|ivlen
operator|-
name|arg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/*          * Invocation field will be at least 8 bytes in size and so no need          * to check wrap around or increment more than last 8 bytes.          */
name|ctr64_inc
argument_list|(
name|gctx
operator|->
name|iv
operator|+
name|gctx
operator|->
name|ivlen
operator|-
literal|8
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|iv_set
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|EVP_CTRL_GCM_SET_IV_INV
case|:
if|if
condition|(
name|gctx
operator|->
name|iv_gen
operator|==
literal|0
operator|||
name|gctx
operator|->
name|key_set
operator|==
literal|0
operator|||
name|c
operator|->
name|encrypt
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|gctx
operator|->
name|iv
operator|+
name|gctx
operator|->
name|ivlen
operator|-
name|arg
argument_list|,
name|ptr
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|CRYPTO_gcm128_setiv
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|gctx
operator|->
name|iv
argument_list|,
name|gctx
operator|->
name|ivlen
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|iv_set
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|EVP_CTRL_AEAD_TLS1_AAD
case|:
comment|/* Save the AAD for later use */
if|if
condition|(
name|arg
operator|!=
name|EVP_AEAD_TLS1_AAD_LEN
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|c
operator|->
name|buf
argument_list|,
name|ptr
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|tls_aad_len
operator|=
name|arg
expr_stmt|;
block|{
name|unsigned
name|int
name|len
init|=
name|c
operator|->
name|buf
index|[
name|arg
operator|-
literal|2
index|]
operator|<<
literal|8
operator||
name|c
operator|->
name|buf
index|[
name|arg
operator|-
literal|1
index|]
decl_stmt|;
comment|/* Correct length for explicit IV */
if|if
condition|(
name|len
operator|<
name|EVP_GCM_TLS_EXPLICIT_IV_LEN
condition|)
return|return
literal|0
return|;
name|len
operator|-=
name|EVP_GCM_TLS_EXPLICIT_IV_LEN
expr_stmt|;
comment|/* If decrypting correct for tag too */
if|if
condition|(
operator|!
name|c
operator|->
name|encrypt
condition|)
block|{
if|if
condition|(
name|len
operator|<
name|EVP_GCM_TLS_TAG_LEN
condition|)
return|return
literal|0
return|;
name|len
operator|-=
name|EVP_GCM_TLS_TAG_LEN
expr_stmt|;
block|}
name|c
operator|->
name|buf
index|[
name|arg
operator|-
literal|2
index|]
operator|=
name|len
operator|>>
literal|8
expr_stmt|;
name|c
operator|->
name|buf
index|[
name|arg
operator|-
literal|1
index|]
operator|=
name|len
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* Extra padding: tag appended to record */
return|return
name|EVP_GCM_TLS_TAG_LEN
return|;
case|case
name|EVP_CTRL_COPY
case|:
block|{
name|EVP_CIPHER_CTX
modifier|*
name|out
init|=
name|ptr
decl_stmt|;
name|EVP_AES_GCM_CTX
modifier|*
name|gctx_out
init|=
name|out
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
name|gctx
operator|->
name|gcm
operator|.
name|key
condition|)
block|{
if|if
condition|(
name|gctx
operator|->
name|gcm
operator|.
name|key
operator|!=
operator|&
name|gctx
operator|->
name|ks
condition|)
return|return
literal|0
return|;
name|gctx_out
operator|->
name|gcm
operator|.
name|key
operator|=
operator|&
name|gctx_out
operator|->
name|ks
expr_stmt|;
block|}
if|if
condition|(
name|gctx
operator|->
name|iv
operator|==
name|c
operator|->
name|iv
condition|)
name|gctx_out
operator|->
name|iv
operator|=
name|out
operator|->
name|iv
expr_stmt|;
else|else
block|{
name|gctx_out
operator|->
name|iv
operator|=
name|OPENSSL_malloc
argument_list|(
name|gctx
operator|->
name|ivlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gctx_out
operator|->
name|iv
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|gctx_out
operator|->
name|iv
argument_list|,
name|gctx
operator|->
name|iv
argument_list|,
name|gctx
operator|->
name|ivlen
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|aes_gcm_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|EVP_AES_GCM_CTX
modifier|*
name|gctx
init|=
name|ctx
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
operator|!
name|iv
operator|&&
operator|!
name|key
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|key
condition|)
block|{
do|do
block|{
ifdef|#
directive|ifdef
name|HWAES_CAPABLE
if|if
condition|(
name|HWAES_CAPABLE
condition|)
block|{
name|HWAES_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|gctx
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|CRYPTO_gcm128_init
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
operator|&
name|gctx
operator|->
name|ks
argument_list|,
operator|(
name|block128_f
operator|)
name|HWAES_encrypt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HWAES_ctr32_encrypt_blocks
name|gctx
operator|->
name|ctr
operator|=
operator|(
name|ctr128_f
operator|)
name|HWAES_ctr32_encrypt_blocks
expr_stmt|;
else|#
directive|else
name|gctx
operator|->
name|ctr
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSAES_CAPABLE
if|if
condition|(
name|BSAES_CAPABLE
condition|)
block|{
name|AES_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|gctx
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|CRYPTO_gcm128_init
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
operator|&
name|gctx
operator|->
name|ks
argument_list|,
operator|(
name|block128_f
operator|)
name|AES_encrypt
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|ctr
operator|=
operator|(
name|ctr128_f
operator|)
name|bsaes_ctr32_encrypt_blocks
expr_stmt|;
break|break;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VPAES_CAPABLE
if|if
condition|(
name|VPAES_CAPABLE
condition|)
block|{
name|vpaes_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|gctx
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|CRYPTO_gcm128_init
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
operator|&
name|gctx
operator|->
name|ks
argument_list|,
operator|(
name|block128_f
operator|)
name|vpaes_encrypt
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|ctr
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
literal|0
expr_stmt|;
comment|/* terminate potentially open 'else' */
name|AES_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|gctx
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|CRYPTO_gcm128_init
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
operator|&
name|gctx
operator|->
name|ks
argument_list|,
operator|(
name|block128_f
operator|)
name|AES_encrypt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AES_CTR_ASM
name|gctx
operator|->
name|ctr
operator|=
operator|(
name|ctr128_f
operator|)
name|AES_ctr32_encrypt
expr_stmt|;
else|#
directive|else
name|gctx
operator|->
name|ctr
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|/*          * If we have an iv can set it directly, otherwise use saved IV.          */
if|if
condition|(
name|iv
operator|==
name|NULL
operator|&&
name|gctx
operator|->
name|iv_set
condition|)
name|iv
operator|=
name|gctx
operator|->
name|iv
expr_stmt|;
if|if
condition|(
name|iv
condition|)
block|{
name|CRYPTO_gcm128_setiv
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|iv
argument_list|,
name|gctx
operator|->
name|ivlen
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|iv_set
operator|=
literal|1
expr_stmt|;
block|}
name|gctx
operator|->
name|key_set
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* If key set use IV, otherwise copy */
if|if
condition|(
name|gctx
operator|->
name|key_set
condition|)
name|CRYPTO_gcm128_setiv
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|iv
argument_list|,
name|gctx
operator|->
name|ivlen
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|gctx
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
name|gctx
operator|->
name|ivlen
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|iv_set
operator|=
literal|1
expr_stmt|;
name|gctx
operator|->
name|iv_gen
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Handle TLS GCM packet format. This consists of the last portion of the IV  * followed by the payload and finally the tag. On encrypt generate IV,  * encrypt payload and write the tag. On verify retrieve IV, decrypt payload  * and verify tag.  */
end_comment

begin_function
specifier|static
name|int
name|aes_gcm_tls_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|EVP_AES_GCM_CTX
modifier|*
name|gctx
init|=
name|ctx
operator|->
name|cipher_data
decl_stmt|;
name|int
name|rv
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Encrypt/decrypt must be performed in place */
if|if
condition|(
name|out
operator|!=
name|in
operator|||
name|len
operator|<
operator|(
name|EVP_GCM_TLS_EXPLICIT_IV_LEN
operator|+
name|EVP_GCM_TLS_TAG_LEN
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/*      * Set IV from start of buffer or generate IV and write to start of      * buffer.      */
if|if
condition|(
name|EVP_CIPHER_CTX_ctrl
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|encrypt
condition|?
name|EVP_CTRL_GCM_IV_GEN
else|:
name|EVP_CTRL_GCM_SET_IV_INV
argument_list|,
name|EVP_GCM_TLS_EXPLICIT_IV_LEN
argument_list|,
name|out
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* Use saved AAD */
if|if
condition|(
name|CRYPTO_gcm128_aad
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|ctx
operator|->
name|buf
argument_list|,
name|gctx
operator|->
name|tls_aad_len
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Fix buffer and length to point to payload */
name|in
operator|+=
name|EVP_GCM_TLS_EXPLICIT_IV_LEN
expr_stmt|;
name|out
operator|+=
name|EVP_GCM_TLS_EXPLICIT_IV_LEN
expr_stmt|;
name|len
operator|-=
name|EVP_GCM_TLS_EXPLICIT_IV_LEN
operator|+
name|EVP_GCM_TLS_TAG_LEN
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|encrypt
condition|)
block|{
comment|/* Encrypt payload */
if|if
condition|(
name|gctx
operator|->
name|ctr
condition|)
block|{
name|size_t
name|bulk
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AES_GCM_ASM
argument_list|)
if|if
condition|(
name|len
operator|>=
literal|32
operator|&&
name|AES_GCM_ASM
argument_list|(
name|gctx
argument_list|)
condition|)
block|{
if|if
condition|(
name|CRYPTO_gcm128_encrypt
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bulk
operator|=
name|AES_gcm_encrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|key
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Yi
operator|.
name|c
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Xi
operator|.
name|u
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|gcm
operator|.
name|len
operator|.
name|u
index|[
literal|1
index|]
operator|+=
name|bulk
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|CRYPTO_gcm128_encrypt_ctr32
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|in
operator|+
name|bulk
argument_list|,
name|out
operator|+
name|bulk
argument_list|,
name|len
operator|-
name|bulk
argument_list|,
name|gctx
operator|->
name|ctr
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|size_t
name|bulk
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AES_GCM_ASM2
argument_list|)
if|if
condition|(
name|len
operator|>=
literal|32
operator|&&
name|AES_GCM_ASM2
argument_list|(
name|gctx
argument_list|)
condition|)
block|{
if|if
condition|(
name|CRYPTO_gcm128_encrypt
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bulk
operator|=
name|AES_gcm_encrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|key
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Yi
operator|.
name|c
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Xi
operator|.
name|u
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|gcm
operator|.
name|len
operator|.
name|u
index|[
literal|1
index|]
operator|+=
name|bulk
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|CRYPTO_gcm128_encrypt
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|in
operator|+
name|bulk
argument_list|,
name|out
operator|+
name|bulk
argument_list|,
name|len
operator|-
name|bulk
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
name|out
operator|+=
name|len
expr_stmt|;
comment|/* Finally write tag */
name|CRYPTO_gcm128_tag
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|out
argument_list|,
name|EVP_GCM_TLS_TAG_LEN
argument_list|)
expr_stmt|;
name|rv
operator|=
name|len
operator|+
name|EVP_GCM_TLS_EXPLICIT_IV_LEN
operator|+
name|EVP_GCM_TLS_TAG_LEN
expr_stmt|;
block|}
else|else
block|{
comment|/* Decrypt */
if|if
condition|(
name|gctx
operator|->
name|ctr
condition|)
block|{
name|size_t
name|bulk
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AES_GCM_ASM
argument_list|)
if|if
condition|(
name|len
operator|>=
literal|16
operator|&&
name|AES_GCM_ASM
argument_list|(
name|gctx
argument_list|)
condition|)
block|{
if|if
condition|(
name|CRYPTO_gcm128_decrypt
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bulk
operator|=
name|AES_gcm_decrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|key
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Yi
operator|.
name|c
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Xi
operator|.
name|u
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|gcm
operator|.
name|len
operator|.
name|u
index|[
literal|1
index|]
operator|+=
name|bulk
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|CRYPTO_gcm128_decrypt_ctr32
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|in
operator|+
name|bulk
argument_list|,
name|out
operator|+
name|bulk
argument_list|,
name|len
operator|-
name|bulk
argument_list|,
name|gctx
operator|->
name|ctr
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|size_t
name|bulk
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AES_GCM_ASM2
argument_list|)
if|if
condition|(
name|len
operator|>=
literal|16
operator|&&
name|AES_GCM_ASM2
argument_list|(
name|gctx
argument_list|)
condition|)
block|{
if|if
condition|(
name|CRYPTO_gcm128_decrypt
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bulk
operator|=
name|AES_gcm_decrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|key
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Yi
operator|.
name|c
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Xi
operator|.
name|u
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|gcm
operator|.
name|len
operator|.
name|u
index|[
literal|1
index|]
operator|+=
name|bulk
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|CRYPTO_gcm128_decrypt
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|in
operator|+
name|bulk
argument_list|,
name|out
operator|+
name|bulk
argument_list|,
name|len
operator|-
name|bulk
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* Retrieve tag */
name|CRYPTO_gcm128_tag
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|ctx
operator|->
name|buf
argument_list|,
name|EVP_GCM_TLS_TAG_LEN
argument_list|)
expr_stmt|;
comment|/* If tag mismatch wipe buffer */
if|if
condition|(
name|CRYPTO_memcmp
argument_list|(
name|ctx
operator|->
name|buf
argument_list|,
name|in
operator|+
name|len
argument_list|,
name|EVP_GCM_TLS_TAG_LEN
argument_list|)
condition|)
block|{
name|OPENSSL_cleanse
argument_list|(
name|out
argument_list|,
name|len
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|rv
operator|=
name|len
expr_stmt|;
block|}
name|err
label|:
name|gctx
operator|->
name|iv_set
operator|=
literal|0
expr_stmt|;
name|gctx
operator|->
name|tls_aad_len
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aes_gcm_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|EVP_AES_GCM_CTX
modifier|*
name|gctx
init|=
name|ctx
operator|->
name|cipher_data
decl_stmt|;
comment|/* If not set up, return error */
if|if
condition|(
operator|!
name|gctx
operator|->
name|key_set
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|gctx
operator|->
name|tls_aad_len
operator|>=
literal|0
condition|)
return|return
name|aes_gcm_tls_cipher
argument_list|(
name|ctx
argument_list|,
name|out
argument_list|,
name|in
argument_list|,
name|len
argument_list|)
return|;
if|if
condition|(
operator|!
name|gctx
operator|->
name|iv_set
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|in
condition|)
block|{
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|CRYPTO_gcm128_aad
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|in
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|encrypt
condition|)
block|{
if|if
condition|(
name|gctx
operator|->
name|ctr
condition|)
block|{
name|size_t
name|bulk
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AES_GCM_ASM
argument_list|)
if|if
condition|(
name|len
operator|>=
literal|32
operator|&&
name|AES_GCM_ASM
argument_list|(
name|gctx
argument_list|)
condition|)
block|{
name|size_t
name|res
init|=
operator|(
literal|16
operator|-
name|gctx
operator|->
name|gcm
operator|.
name|mres
operator|)
operator|%
literal|16
decl_stmt|;
if|if
condition|(
name|CRYPTO_gcm128_encrypt
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|res
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bulk
operator|=
name|AES_gcm_encrypt
argument_list|(
name|in
operator|+
name|res
argument_list|,
name|out
operator|+
name|res
argument_list|,
name|len
operator|-
name|res
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|key
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Yi
operator|.
name|c
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Xi
operator|.
name|u
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|gcm
operator|.
name|len
operator|.
name|u
index|[
literal|1
index|]
operator|+=
name|bulk
expr_stmt|;
name|bulk
operator|+=
name|res
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|CRYPTO_gcm128_encrypt_ctr32
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|in
operator|+
name|bulk
argument_list|,
name|out
operator|+
name|bulk
argument_list|,
name|len
operator|-
name|bulk
argument_list|,
name|gctx
operator|->
name|ctr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|size_t
name|bulk
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AES_GCM_ASM2
argument_list|)
if|if
condition|(
name|len
operator|>=
literal|32
operator|&&
name|AES_GCM_ASM2
argument_list|(
name|gctx
argument_list|)
condition|)
block|{
name|size_t
name|res
init|=
operator|(
literal|16
operator|-
name|gctx
operator|->
name|gcm
operator|.
name|mres
operator|)
operator|%
literal|16
decl_stmt|;
if|if
condition|(
name|CRYPTO_gcm128_encrypt
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|res
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bulk
operator|=
name|AES_gcm_encrypt
argument_list|(
name|in
operator|+
name|res
argument_list|,
name|out
operator|+
name|res
argument_list|,
name|len
operator|-
name|res
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|key
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Yi
operator|.
name|c
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Xi
operator|.
name|u
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|gcm
operator|.
name|len
operator|.
name|u
index|[
literal|1
index|]
operator|+=
name|bulk
expr_stmt|;
name|bulk
operator|+=
name|res
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|CRYPTO_gcm128_encrypt
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|in
operator|+
name|bulk
argument_list|,
name|out
operator|+
name|bulk
argument_list|,
name|len
operator|-
name|bulk
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|gctx
operator|->
name|ctr
condition|)
block|{
name|size_t
name|bulk
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AES_GCM_ASM
argument_list|)
if|if
condition|(
name|len
operator|>=
literal|16
operator|&&
name|AES_GCM_ASM
argument_list|(
name|gctx
argument_list|)
condition|)
block|{
name|size_t
name|res
init|=
operator|(
literal|16
operator|-
name|gctx
operator|->
name|gcm
operator|.
name|mres
operator|)
operator|%
literal|16
decl_stmt|;
if|if
condition|(
name|CRYPTO_gcm128_decrypt
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|res
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bulk
operator|=
name|AES_gcm_decrypt
argument_list|(
name|in
operator|+
name|res
argument_list|,
name|out
operator|+
name|res
argument_list|,
name|len
operator|-
name|res
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|key
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Yi
operator|.
name|c
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Xi
operator|.
name|u
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|gcm
operator|.
name|len
operator|.
name|u
index|[
literal|1
index|]
operator|+=
name|bulk
expr_stmt|;
name|bulk
operator|+=
name|res
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|CRYPTO_gcm128_decrypt_ctr32
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|in
operator|+
name|bulk
argument_list|,
name|out
operator|+
name|bulk
argument_list|,
name|len
operator|-
name|bulk
argument_list|,
name|gctx
operator|->
name|ctr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|size_t
name|bulk
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AES_GCM_ASM2
argument_list|)
if|if
condition|(
name|len
operator|>=
literal|16
operator|&&
name|AES_GCM_ASM2
argument_list|(
name|gctx
argument_list|)
condition|)
block|{
name|size_t
name|res
init|=
operator|(
literal|16
operator|-
name|gctx
operator|->
name|gcm
operator|.
name|mres
operator|)
operator|%
literal|16
decl_stmt|;
if|if
condition|(
name|CRYPTO_gcm128_decrypt
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|res
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bulk
operator|=
name|AES_gcm_decrypt
argument_list|(
name|in
operator|+
name|res
argument_list|,
name|out
operator|+
name|res
argument_list|,
name|len
operator|-
name|res
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|key
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Yi
operator|.
name|c
argument_list|,
name|gctx
operator|->
name|gcm
operator|.
name|Xi
operator|.
name|u
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|gcm
operator|.
name|len
operator|.
name|u
index|[
literal|1
index|]
operator|+=
name|bulk
expr_stmt|;
name|bulk
operator|+=
name|res
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|CRYPTO_gcm128_decrypt
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|in
operator|+
name|bulk
argument_list|,
name|out
operator|+
name|bulk
argument_list|,
name|len
operator|-
name|bulk
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|len
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ctx
operator|->
name|encrypt
condition|)
block|{
if|if
condition|(
name|gctx
operator|->
name|taglen
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|CRYPTO_gcm128_finish
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|ctx
operator|->
name|buf
argument_list|,
name|gctx
operator|->
name|taglen
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|gctx
operator|->
name|iv_set
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CRYPTO_gcm128_tag
argument_list|(
operator|&
name|gctx
operator|->
name|gcm
argument_list|,
name|ctx
operator|->
name|buf
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|taglen
operator|=
literal|16
expr_stmt|;
comment|/* Don't reuse the IV */
name|gctx
operator|->
name|iv_set
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|CUSTOM_FLAGS
value|(EVP_CIPH_FLAG_DEFAULT_ASN1 \                 | EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \                 | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \                 | EVP_CIPH_CUSTOM_COPY)
end_define

begin_macro
name|BLOCK_CIPHER_custom
argument_list|(
argument|NID_aes
argument_list|,
literal|128
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
argument|gcm
argument_list|,
argument|GCM
argument_list|,
argument|EVP_CIPH_FLAG_FIPS | EVP_CIPH_FLAG_AEAD_CIPHER |                     CUSTOM_FLAGS
argument_list|)
end_macro

begin_macro
name|BLOCK_CIPHER_custom
argument_list|(
argument|NID_aes
argument_list|,
literal|192
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
argument|gcm
argument_list|,
argument|GCM
argument_list|,
argument|EVP_CIPH_FLAG_FIPS | EVP_CIPH_FLAG_AEAD_CIPHER |                     CUSTOM_FLAGS
argument_list|)
end_macro

begin_macro
name|BLOCK_CIPHER_custom
argument_list|(
argument|NID_aes
argument_list|,
literal|256
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
argument|gcm
argument_list|,
argument|GCM
argument_list|,
argument|EVP_CIPH_FLAG_FIPS | EVP_CIPH_FLAG_AEAD_CIPHER |                     CUSTOM_FLAGS
argument_list|)
end_macro

begin_function
specifier|static
name|int
name|aes_xts_ctrl
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|c
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|arg
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|EVP_AES_XTS_CTX
modifier|*
name|xctx
init|=
name|c
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|EVP_CTRL_COPY
condition|)
block|{
name|EVP_CIPHER_CTX
modifier|*
name|out
init|=
name|ptr
decl_stmt|;
name|EVP_AES_XTS_CTX
modifier|*
name|xctx_out
init|=
name|out
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
name|xctx
operator|->
name|xts
operator|.
name|key1
condition|)
block|{
if|if
condition|(
name|xctx
operator|->
name|xts
operator|.
name|key1
operator|!=
operator|&
name|xctx
operator|->
name|ks1
condition|)
return|return
literal|0
return|;
name|xctx_out
operator|->
name|xts
operator|.
name|key1
operator|=
operator|&
name|xctx_out
operator|->
name|ks1
expr_stmt|;
block|}
if|if
condition|(
name|xctx
operator|->
name|xts
operator|.
name|key2
condition|)
block|{
if|if
condition|(
name|xctx
operator|->
name|xts
operator|.
name|key2
operator|!=
operator|&
name|xctx
operator|->
name|ks2
condition|)
return|return
literal|0
return|;
name|xctx_out
operator|->
name|xts
operator|.
name|key2
operator|=
operator|&
name|xctx_out
operator|->
name|ks2
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|EVP_CTRL_INIT
condition|)
return|return
operator|-
literal|1
return|;
comment|/* key1 and key2 are used as an indicator both key and IV are set */
name|xctx
operator|->
name|xts
operator|.
name|key1
operator|=
name|NULL
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|key2
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aes_xts_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|EVP_AES_XTS_CTX
modifier|*
name|xctx
init|=
name|ctx
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
operator|!
name|iv
operator|&&
operator|!
name|key
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|key
condition|)
do|do
block|{
ifdef|#
directive|ifdef
name|AES_XTS_ASM
name|xctx
operator|->
name|stream
operator|=
name|enc
condition|?
name|AES_xts_encrypt
else|:
name|AES_xts_decrypt
expr_stmt|;
else|#
directive|else
name|xctx
operator|->
name|stream
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* key_len is two AES keys */
ifdef|#
directive|ifdef
name|HWAES_CAPABLE
if|if
condition|(
name|HWAES_CAPABLE
condition|)
block|{
if|if
condition|(
name|enc
condition|)
block|{
name|HWAES_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|4
argument_list|,
operator|&
name|xctx
operator|->
name|ks1
operator|.
name|ks
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|block1
operator|=
operator|(
name|block128_f
operator|)
name|HWAES_encrypt
expr_stmt|;
block|}
else|else
block|{
name|HWAES_set_decrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|4
argument_list|,
operator|&
name|xctx
operator|->
name|ks1
operator|.
name|ks
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|block1
operator|=
operator|(
name|block128_f
operator|)
name|HWAES_decrypt
expr_stmt|;
block|}
name|HWAES_set_encrypt_key
argument_list|(
name|key
operator|+
name|ctx
operator|->
name|key_len
operator|/
literal|2
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|4
argument_list|,
operator|&
name|xctx
operator|->
name|ks2
operator|.
name|ks
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|block2
operator|=
operator|(
name|block128_f
operator|)
name|HWAES_encrypt
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|key1
operator|=
operator|&
name|xctx
operator|->
name|ks1
expr_stmt|;
break|break;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSAES_CAPABLE
if|if
condition|(
name|BSAES_CAPABLE
condition|)
name|xctx
operator|->
name|stream
operator|=
name|enc
condition|?
name|bsaes_xts_encrypt
else|:
name|bsaes_xts_decrypt
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VPAES_CAPABLE
if|if
condition|(
name|VPAES_CAPABLE
condition|)
block|{
if|if
condition|(
name|enc
condition|)
block|{
name|vpaes_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|4
argument_list|,
operator|&
name|xctx
operator|->
name|ks1
operator|.
name|ks
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|block1
operator|=
operator|(
name|block128_f
operator|)
name|vpaes_encrypt
expr_stmt|;
block|}
else|else
block|{
name|vpaes_set_decrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|4
argument_list|,
operator|&
name|xctx
operator|->
name|ks1
operator|.
name|ks
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|block1
operator|=
operator|(
name|block128_f
operator|)
name|vpaes_decrypt
expr_stmt|;
block|}
name|vpaes_set_encrypt_key
argument_list|(
name|key
operator|+
name|ctx
operator|->
name|key_len
operator|/
literal|2
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|4
argument_list|,
operator|&
name|xctx
operator|->
name|ks2
operator|.
name|ks
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|block2
operator|=
operator|(
name|block128_f
operator|)
name|vpaes_encrypt
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|key1
operator|=
operator|&
name|xctx
operator|->
name|ks1
expr_stmt|;
break|break;
block|}
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
literal|0
expr_stmt|;
comment|/* terminate potentially open 'else' */
if|if
condition|(
name|enc
condition|)
block|{
name|AES_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|4
argument_list|,
operator|&
name|xctx
operator|->
name|ks1
operator|.
name|ks
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|block1
operator|=
operator|(
name|block128_f
operator|)
name|AES_encrypt
expr_stmt|;
block|}
else|else
block|{
name|AES_set_decrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|4
argument_list|,
operator|&
name|xctx
operator|->
name|ks1
operator|.
name|ks
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|block1
operator|=
operator|(
name|block128_f
operator|)
name|AES_decrypt
expr_stmt|;
block|}
name|AES_set_encrypt_key
argument_list|(
name|key
operator|+
name|ctx
operator|->
name|key_len
operator|/
literal|2
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|4
argument_list|,
operator|&
name|xctx
operator|->
name|ks2
operator|.
name|ks
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|block2
operator|=
operator|(
name|block128_f
operator|)
name|AES_encrypt
expr_stmt|;
name|xctx
operator|->
name|xts
operator|.
name|key1
operator|=
operator|&
name|xctx
operator|->
name|ks1
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|iv
condition|)
block|{
name|xctx
operator|->
name|xts
operator|.
name|key2
operator|=
operator|&
name|xctx
operator|->
name|ks2
expr_stmt|;
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aes_xts_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|EVP_AES_XTS_CTX
modifier|*
name|xctx
init|=
name|ctx
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
operator|!
name|xctx
operator|->
name|xts
operator|.
name|key1
operator|||
operator|!
name|xctx
operator|->
name|xts
operator|.
name|key2
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|out
operator|||
operator|!
name|in
operator|||
name|len
operator|<
name|AES_BLOCK_SIZE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|xctx
operator|->
name|stream
condition|)
call|(
modifier|*
name|xctx
operator|->
name|stream
call|)
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
name|xctx
operator|->
name|xts
operator|.
name|key1
argument_list|,
name|xctx
operator|->
name|xts
operator|.
name|key2
argument_list|,
name|ctx
operator|->
name|iv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CRYPTO_xts128_encrypt
argument_list|(
operator|&
name|xctx
operator|->
name|xts
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
name|ctx
operator|->
name|encrypt
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|aes_xts_cleanup
value|NULL
end_define

begin_define
define|#
directive|define
name|XTS_FLAGS
value|(EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \                          | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \                          | EVP_CIPH_CUSTOM_COPY)
end_define

begin_macro
name|BLOCK_CIPHER_custom
argument_list|(
argument|NID_aes
argument_list|,
literal|128
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
argument|xts
argument_list|,
argument|XTS
argument_list|,
argument|EVP_CIPH_FLAG_FIPS | XTS_FLAGS
argument_list|)
end_macro

begin_macro
name|BLOCK_CIPHER_custom
argument_list|(
argument|NID_aes
argument_list|,
literal|256
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
argument|xts
argument_list|,
argument|XTS
argument_list|,
argument|EVP_CIPH_FLAG_FIPS | XTS_FLAGS
argument_list|)
end_macro

begin_function
specifier|static
name|int
name|aes_ccm_ctrl
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|c
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|arg
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|EVP_AES_CCM_CTX
modifier|*
name|cctx
init|=
name|c
operator|->
name|cipher_data
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EVP_CTRL_INIT
case|:
name|cctx
operator|->
name|key_set
operator|=
literal|0
expr_stmt|;
name|cctx
operator|->
name|iv_set
operator|=
literal|0
expr_stmt|;
name|cctx
operator|->
name|L
operator|=
literal|8
expr_stmt|;
name|cctx
operator|->
name|M
operator|=
literal|12
expr_stmt|;
name|cctx
operator|->
name|tag_set
operator|=
literal|0
expr_stmt|;
name|cctx
operator|->
name|len_set
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
case|case
name|EVP_CTRL_CCM_SET_IVLEN
case|:
name|arg
operator|=
literal|15
operator|-
name|arg
expr_stmt|;
case|case
name|EVP_CTRL_CCM_SET_L
case|:
if|if
condition|(
name|arg
operator|<
literal|2
operator|||
name|arg
operator|>
literal|8
condition|)
return|return
literal|0
return|;
name|cctx
operator|->
name|L
operator|=
name|arg
expr_stmt|;
return|return
literal|1
return|;
case|case
name|EVP_CTRL_CCM_SET_TAG
case|:
if|if
condition|(
operator|(
name|arg
operator|&
literal|1
operator|)
operator|||
name|arg
operator|<
literal|4
operator|||
name|arg
operator|>
literal|16
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|->
name|encrypt
operator|&&
name|ptr
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ptr
condition|)
block|{
name|cctx
operator|->
name|tag_set
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|c
operator|->
name|buf
argument_list|,
name|ptr
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|cctx
operator|->
name|M
operator|=
name|arg
expr_stmt|;
return|return
literal|1
return|;
case|case
name|EVP_CTRL_CCM_GET_TAG
case|:
if|if
condition|(
operator|!
name|c
operator|->
name|encrypt
operator|||
operator|!
name|cctx
operator|->
name|tag_set
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|CRYPTO_ccm128_tag
argument_list|(
operator|&
name|cctx
operator|->
name|ccm
argument_list|,
name|ptr
argument_list|,
operator|(
name|size_t
operator|)
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
name|cctx
operator|->
name|tag_set
operator|=
literal|0
expr_stmt|;
name|cctx
operator|->
name|iv_set
operator|=
literal|0
expr_stmt|;
name|cctx
operator|->
name|len_set
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
case|case
name|EVP_CTRL_COPY
case|:
block|{
name|EVP_CIPHER_CTX
modifier|*
name|out
init|=
name|ptr
decl_stmt|;
name|EVP_AES_CCM_CTX
modifier|*
name|cctx_out
init|=
name|out
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
name|cctx
operator|->
name|ccm
operator|.
name|key
condition|)
block|{
if|if
condition|(
name|cctx
operator|->
name|ccm
operator|.
name|key
operator|!=
operator|&
name|cctx
operator|->
name|ks
condition|)
return|return
literal|0
return|;
name|cctx_out
operator|->
name|ccm
operator|.
name|key
operator|=
operator|&
name|cctx_out
operator|->
name|ks
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|aes_ccm_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|EVP_AES_CCM_CTX
modifier|*
name|cctx
init|=
name|ctx
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
operator|!
name|iv
operator|&&
operator|!
name|key
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|key
condition|)
do|do
block|{
ifdef|#
directive|ifdef
name|HWAES_CAPABLE
if|if
condition|(
name|HWAES_CAPABLE
condition|)
block|{
name|HWAES_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|cctx
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|CRYPTO_ccm128_init
argument_list|(
operator|&
name|cctx
operator|->
name|ccm
argument_list|,
name|cctx
operator|->
name|M
argument_list|,
name|cctx
operator|->
name|L
argument_list|,
operator|&
name|cctx
operator|->
name|ks
argument_list|,
operator|(
name|block128_f
operator|)
name|HWAES_encrypt
argument_list|)
expr_stmt|;
name|cctx
operator|->
name|str
operator|=
name|NULL
expr_stmt|;
name|cctx
operator|->
name|key_set
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VPAES_CAPABLE
if|if
condition|(
name|VPAES_CAPABLE
condition|)
block|{
name|vpaes_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|cctx
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|CRYPTO_ccm128_init
argument_list|(
operator|&
name|cctx
operator|->
name|ccm
argument_list|,
name|cctx
operator|->
name|M
argument_list|,
name|cctx
operator|->
name|L
argument_list|,
operator|&
name|cctx
operator|->
name|ks
argument_list|,
operator|(
name|block128_f
operator|)
name|vpaes_encrypt
argument_list|)
expr_stmt|;
name|cctx
operator|->
name|str
operator|=
name|NULL
expr_stmt|;
name|cctx
operator|->
name|key_set
operator|=
literal|1
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|AES_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|cctx
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
name|CRYPTO_ccm128_init
argument_list|(
operator|&
name|cctx
operator|->
name|ccm
argument_list|,
name|cctx
operator|->
name|M
argument_list|,
name|cctx
operator|->
name|L
argument_list|,
operator|&
name|cctx
operator|->
name|ks
argument_list|,
operator|(
name|block128_f
operator|)
name|AES_encrypt
argument_list|)
expr_stmt|;
name|cctx
operator|->
name|str
operator|=
name|NULL
expr_stmt|;
name|cctx
operator|->
name|key_set
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|iv
condition|)
block|{
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
literal|15
operator|-
name|cctx
operator|->
name|L
argument_list|)
expr_stmt|;
name|cctx
operator|->
name|iv_set
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aes_ccm_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|EVP_AES_CCM_CTX
modifier|*
name|cctx
init|=
name|ctx
operator|->
name|cipher_data
decl_stmt|;
name|CCM128_CONTEXT
modifier|*
name|ccm
init|=
operator|&
name|cctx
operator|->
name|ccm
decl_stmt|;
comment|/* If not set up, return error */
if|if
condition|(
operator|!
name|cctx
operator|->
name|iv_set
operator|&&
operator|!
name|cctx
operator|->
name|key_set
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|encrypt
operator|&&
operator|!
name|cctx
operator|->
name|tag_set
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
if|if
condition|(
operator|!
name|in
condition|)
block|{
if|if
condition|(
name|CRYPTO_ccm128_setiv
argument_list|(
name|ccm
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
literal|15
operator|-
name|cctx
operator|->
name|L
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|cctx
operator|->
name|len_set
operator|=
literal|1
expr_stmt|;
return|return
name|len
return|;
block|}
comment|/* If have AAD need message length */
if|if
condition|(
operator|!
name|cctx
operator|->
name|len_set
operator|&&
name|len
condition|)
return|return
operator|-
literal|1
return|;
name|CRYPTO_ccm128_aad
argument_list|(
name|ccm
argument_list|,
name|in
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
comment|/* EVP_*Final() doesn't return any data */
if|if
condition|(
operator|!
name|in
condition|)
return|return
literal|0
return|;
comment|/* If not set length yet do it */
if|if
condition|(
operator|!
name|cctx
operator|->
name|len_set
condition|)
block|{
if|if
condition|(
name|CRYPTO_ccm128_setiv
argument_list|(
name|ccm
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
literal|15
operator|-
name|cctx
operator|->
name|L
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|cctx
operator|->
name|len_set
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|encrypt
condition|)
block|{
if|if
condition|(
name|cctx
operator|->
name|str
condition|?
name|CRYPTO_ccm128_encrypt_ccm64
argument_list|(
name|ccm
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
name|cctx
operator|->
name|str
argument_list|)
else|:
name|CRYPTO_ccm128_encrypt
argument_list|(
name|ccm
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|cctx
operator|->
name|tag_set
operator|=
literal|1
expr_stmt|;
return|return
name|len
return|;
block|}
else|else
block|{
name|int
name|rv
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|cctx
operator|->
name|str
condition|?
operator|!
name|CRYPTO_ccm128_decrypt_ccm64
argument_list|(
name|ccm
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
name|cctx
operator|->
name|str
argument_list|)
else|:
operator|!
name|CRYPTO_ccm128_decrypt
argument_list|(
name|ccm
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|unsigned
name|char
name|tag
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|CRYPTO_ccm128_tag
argument_list|(
name|ccm
argument_list|,
name|tag
argument_list|,
name|cctx
operator|->
name|M
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|CRYPTO_memcmp
argument_list|(
name|tag
argument_list|,
name|ctx
operator|->
name|buf
argument_list|,
name|cctx
operator|->
name|M
argument_list|)
condition|)
name|rv
operator|=
name|len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
name|OPENSSL_cleanse
argument_list|(
name|out
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cctx
operator|->
name|iv_set
operator|=
literal|0
expr_stmt|;
name|cctx
operator|->
name|tag_set
operator|=
literal|0
expr_stmt|;
name|cctx
operator|->
name|len_set
operator|=
literal|0
expr_stmt|;
return|return
name|rv
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|aes_ccm_cleanup
value|NULL
end_define

begin_macro
name|BLOCK_CIPHER_custom
argument_list|(
argument|NID_aes
argument_list|,
literal|128
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
argument|ccm
argument_list|,
argument|CCM
argument_list|,
argument|EVP_CIPH_FLAG_FIPS | CUSTOM_FLAGS
argument_list|)
end_macro

begin_macro
name|BLOCK_CIPHER_custom
argument_list|(
argument|NID_aes
argument_list|,
literal|192
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
argument|ccm
argument_list|,
argument|CCM
argument_list|,
argument|EVP_CIPH_FLAG_FIPS | CUSTOM_FLAGS
argument_list|)
end_macro

begin_macro
name|BLOCK_CIPHER_custom
argument_list|(
argument|NID_aes
argument_list|,
literal|256
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
argument|ccm
argument_list|,
argument|CCM
argument_list|,
argument|EVP_CIPH_FLAG_FIPS | CUSTOM_FLAGS
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
block|{
union|union
block|{
name|double
name|align
decl_stmt|;
name|AES_KEY
name|ks
decl_stmt|;
block|}
name|ks
union|;
comment|/* Indicates if IV has been set */
name|unsigned
name|char
modifier|*
name|iv
decl_stmt|;
block|}
name|EVP_AES_WRAP_CTX
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|aes_wrap_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|EVP_AES_WRAP_CTX
modifier|*
name|wctx
init|=
name|ctx
operator|->
name|cipher_data
decl_stmt|;
if|if
condition|(
operator|!
name|iv
operator|&&
operator|!
name|key
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|key
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|encrypt
condition|)
name|AES_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|wctx
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
else|else
name|AES_set_decrypt_key
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|key_len
operator|*
literal|8
argument_list|,
operator|&
name|wctx
operator|->
name|ks
operator|.
name|ks
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iv
condition|)
name|wctx
operator|->
name|iv
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|iv
condition|)
block|{
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
name|iv
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|wctx
operator|->
name|iv
operator|=
name|ctx
operator|->
name|iv
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aes_wrap_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|inlen
parameter_list|)
block|{
name|EVP_AES_WRAP_CTX
modifier|*
name|wctx
init|=
name|ctx
operator|->
name|cipher_data
decl_stmt|;
name|size_t
name|rv
decl_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|inlen
operator|%
literal|8
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ctx
operator|->
name|encrypt
operator|&&
name|inlen
operator|<
literal|8
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|encrypt
operator|&&
name|inlen
operator|<
literal|16
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|encrypt
condition|)
return|return
name|inlen
operator|+
literal|8
return|;
else|else
return|return
name|inlen
operator|-
literal|8
return|;
block|}
if|if
condition|(
name|ctx
operator|->
name|encrypt
condition|)
name|rv
operator|=
name|CRYPTO_128_wrap
argument_list|(
operator|&
name|wctx
operator|->
name|ks
operator|.
name|ks
argument_list|,
name|wctx
operator|->
name|iv
argument_list|,
name|out
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|,
operator|(
name|block128_f
operator|)
name|AES_encrypt
argument_list|)
expr_stmt|;
else|else
name|rv
operator|=
name|CRYPTO_128_unwrap
argument_list|(
operator|&
name|wctx
operator|->
name|ks
operator|.
name|ks
argument_list|,
name|wctx
operator|->
name|iv
argument_list|,
name|out
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|,
operator|(
name|block128_f
operator|)
name|AES_decrypt
argument_list|)
expr_stmt|;
return|return
name|rv
condition|?
operator|(
name|int
operator|)
name|rv
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|WRAP_FLAGS
value|(EVP_CIPH_WRAP_MODE \                 | EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \                 | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_FLAG_DEFAULT_ASN1)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|EVP_CIPHER
name|aes_128_wrap
init|=
block|{
name|NID_id_aes128_wrap
block|,
literal|8
block|,
literal|16
block|,
literal|8
block|,
name|WRAP_FLAGS
block|,
name|aes_wrap_init_key
block|,
name|aes_wrap_cipher
block|,
name|NULL
block|,
sizeof|sizeof
argument_list|(
name|EVP_AES_WRAP_CTX
argument_list|)
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|EVP_CIPHER
modifier|*
name|EVP_aes_128_wrap
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|aes_128_wrap
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|EVP_CIPHER
name|aes_192_wrap
init|=
block|{
name|NID_id_aes192_wrap
block|,
literal|8
block|,
literal|24
block|,
literal|8
block|,
name|WRAP_FLAGS
block|,
name|aes_wrap_init_key
block|,
name|aes_wrap_cipher
block|,
name|NULL
block|,
sizeof|sizeof
argument_list|(
name|EVP_AES_WRAP_CTX
argument_list|)
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|EVP_CIPHER
modifier|*
name|EVP_aes_192_wrap
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|aes_192_wrap
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|EVP_CIPHER
name|aes_256_wrap
init|=
block|{
name|NID_id_aes256_wrap
block|,
literal|8
block|,
literal|32
block|,
literal|8
block|,
name|WRAP_FLAGS
block|,
name|aes_wrap_init_key
block|,
name|aes_wrap_cipher
block|,
name|NULL
block|,
sizeof|sizeof
argument_list|(
name|EVP_AES_WRAP_CTX
argument_list|)
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|EVP_CIPHER
modifier|*
name|EVP_aes_256_wrap
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|aes_256_wrap
return|;
block|}
end_function

end_unit

