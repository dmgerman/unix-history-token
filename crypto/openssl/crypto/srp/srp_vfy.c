begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/srp/srp_vfy.c */
end_comment

begin_comment
comment|/*  * Written by Christophe Renou (christophe.renou@edelweb.fr) with the  * precious help of Peter Sylvester (peter.sylvester@edelweb.fr) for the  * EdelKey project and contributed to the OpenSSL project 2004.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2004 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRP
end_ifndef

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|"srp_lcl.h"
end_include

begin_include
include|#
directive|include
file|<openssl/srp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/buffer.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/txt_db.h>
end_include

begin_define
define|#
directive|define
name|SRP_RANDOM_SALT_LEN
value|20
end_define

begin_define
define|#
directive|define
name|MAX_LEN
value|2500
end_define

begin_decl_stmt
specifier|static
name|char
name|b64table
index|[]
init|=
literal|"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz./"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * the following two conversion routines have been inspired by code from  * Stanford  */
end_comment

begin_comment
comment|/*  * Convert a base64 string into raw byte array representation.  */
end_comment

begin_function
specifier|static
name|int
name|t_fromb64
parameter_list|(
name|unsigned
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
modifier|*
name|loc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|size
decl_stmt|;
while|while
condition|(
operator|*
name|src
operator|&&
operator|(
operator|*
name|src
operator|==
literal|' '
operator|||
operator|*
name|src
operator|==
literal|'\t'
operator|||
operator|*
name|src
operator|==
literal|'\n'
operator|)
condition|)
operator|++
name|src
expr_stmt|;
name|size
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|size
condition|)
block|{
name|loc
operator|=
name|strchr
argument_list|(
name|b64table
argument_list|,
name|src
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
break|break;
else|else
name|a
index|[
name|i
index|]
operator|=
name|loc
operator|-
name|b64table
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
comment|/* if nothing valid to process we have a zero length response */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|size
operator|=
name|i
expr_stmt|;
name|i
operator|=
name|size
operator|-
literal|1
expr_stmt|;
name|j
operator|=
name|size
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|a
index|[
name|j
index|]
operator|=
name|a
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
break|break;
name|a
index|[
name|j
index|]
operator||=
operator|(
name|a
index|[
name|i
index|]
operator|&
literal|3
operator|)
operator|<<
literal|6
expr_stmt|;
operator|--
name|j
expr_stmt|;
name|a
index|[
name|j
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|a
index|[
name|i
index|]
operator|&
literal|0x3c
operator|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
break|break;
name|a
index|[
name|j
index|]
operator||=
operator|(
name|a
index|[
name|i
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|4
expr_stmt|;
operator|--
name|j
expr_stmt|;
name|a
index|[
name|j
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|a
index|[
name|i
index|]
operator|&
literal|0x30
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
break|break;
name|a
index|[
name|j
index|]
operator||=
operator|(
name|a
index|[
name|i
index|]
operator|<<
literal|2
operator|)
expr_stmt|;
name|a
index|[
operator|--
name|j
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
break|break;
block|}
while|while
condition|(
name|a
index|[
name|j
index|]
operator|==
literal|0
operator|&&
name|j
operator|<=
name|size
condition|)
operator|++
name|j
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|<=
name|size
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
name|a
index|[
name|j
operator|++
index|]
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a raw byte string into a null-terminated base64 ASCII string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|t_tob64
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|pos
init|=
name|size
operator|%
literal|3
decl_stmt|;
name|unsigned
name|char
name|b0
init|=
literal|0
decl_stmt|,
name|b1
init|=
literal|0
decl_stmt|,
name|b2
init|=
literal|0
decl_stmt|,
name|notleading
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|olddst
init|=
name|dst
decl_stmt|;
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
literal|1
case|:
name|b2
operator|=
name|src
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|b1
operator|=
name|src
index|[
literal|0
index|]
expr_stmt|;
name|b2
operator|=
name|src
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|(
name|b0
operator|&
literal|0xfc
operator|)
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|notleading
operator|||
name|c
operator|!=
literal|0
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
name|b64table
index|[
name|c
index|]
expr_stmt|;
name|notleading
operator|=
literal|1
expr_stmt|;
block|}
name|c
operator|=
operator|(
operator|(
name|b0
operator|&
literal|3
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|b1
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|notleading
operator|||
name|c
operator|!=
literal|0
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
name|b64table
index|[
name|c
index|]
expr_stmt|;
name|notleading
operator|=
literal|1
expr_stmt|;
block|}
name|c
operator|=
operator|(
operator|(
name|b1
operator|&
literal|0xf
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|b2
operator|&
literal|0xc0
operator|)
operator|>>
literal|6
operator|)
expr_stmt|;
if|if
condition|(
name|notleading
operator|||
name|c
operator|!=
literal|0
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
name|b64table
index|[
name|c
index|]
expr_stmt|;
name|notleading
operator|=
literal|1
expr_stmt|;
block|}
name|c
operator|=
name|b2
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|notleading
operator|||
name|c
operator|!=
literal|0
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
name|b64table
index|[
name|c
index|]
expr_stmt|;
name|notleading
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|>=
name|size
condition|)
break|break;
else|else
block|{
name|b0
operator|=
name|src
index|[
name|pos
operator|++
index|]
expr_stmt|;
name|b1
operator|=
name|src
index|[
name|pos
operator|++
index|]
expr_stmt|;
name|b2
operator|=
name|src
index|[
name|pos
operator|++
index|]
expr_stmt|;
block|}
block|}
operator|*
name|dst
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|olddst
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|SRP_user_pwd_free
parameter_list|(
name|SRP_user_pwd
modifier|*
name|user_pwd
parameter_list|)
block|{
if|if
condition|(
name|user_pwd
operator|==
name|NULL
condition|)
return|return;
name|BN_free
argument_list|(
name|user_pwd
operator|->
name|s
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|user_pwd
operator|->
name|v
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|user_pwd
operator|->
name|id
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|user_pwd
operator|->
name|info
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|user_pwd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|SRP_user_pwd
modifier|*
name|SRP_user_pwd_new
parameter_list|()
block|{
name|SRP_user_pwd
modifier|*
name|ret
init|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SRP_user_pwd
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|N
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|g
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|s
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|v
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|id
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|info
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|SRP_user_pwd_set_gN
parameter_list|(
name|SRP_user_pwd
modifier|*
name|vinfo
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|N
parameter_list|)
block|{
name|vinfo
operator|->
name|N
operator|=
name|N
expr_stmt|;
name|vinfo
operator|->
name|g
operator|=
name|g
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|SRP_user_pwd_set_ids
parameter_list|(
name|SRP_user_pwd
modifier|*
name|vinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|id
operator|!=
name|NULL
operator|&&
name|NULL
operator|==
operator|(
name|vinfo
operator|->
name|id
operator|=
name|BUF_strdup
argument_list|(
name|id
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|info
operator|==
name|NULL
operator|||
name|NULL
operator|!=
operator|(
name|vinfo
operator|->
name|info
operator|=
name|BUF_strdup
argument_list|(
name|info
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SRP_user_pwd_set_sv
parameter_list|(
name|SRP_user_pwd
modifier|*
name|vinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|)
block|{
name|unsigned
name|char
name|tmp
index|[
name|MAX_LEN
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|>
name|MAX_LEN
operator|||
name|strlen
argument_list|(
name|v
argument_list|)
operator|>
name|MAX_LEN
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|t_fromb64
argument_list|(
name|tmp
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|vinfo
operator|->
name|v
operator|=
name|BN_bin2bn
argument_list|(
name|tmp
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|t_fromb64
argument_list|(
name|tmp
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|vinfo
operator|->
name|s
operator|=
name|BN_bin2bn
argument_list|(
name|tmp
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SRP_user_pwd_set_sv_BN
parameter_list|(
name|SRP_user_pwd
modifier|*
name|vinfo
parameter_list|,
name|BIGNUM
modifier|*
name|s
parameter_list|,
name|BIGNUM
modifier|*
name|v
parameter_list|)
block|{
name|vinfo
operator|->
name|v
operator|=
name|v
expr_stmt|;
name|vinfo
operator|->
name|s
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|vinfo
operator|->
name|s
operator|!=
name|NULL
operator|&&
name|vinfo
operator|->
name|v
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|SRP_VBASE
modifier|*
name|SRP_VBASE_new
parameter_list|(
name|char
modifier|*
name|seed_key
parameter_list|)
block|{
name|SRP_VBASE
modifier|*
name|vb
init|=
operator|(
name|SRP_VBASE
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SRP_VBASE
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|vb
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|vb
operator|->
name|users_pwd
operator|=
name|sk_SRP_user_pwd_new_null
argument_list|()
operator|)
operator|||
operator|!
operator|(
name|vb
operator|->
name|gN_cache
operator|=
name|sk_SRP_gN_cache_new_null
argument_list|()
operator|)
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|vb
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|vb
operator|->
name|default_g
operator|=
name|NULL
expr_stmt|;
name|vb
operator|->
name|default_N
operator|=
name|NULL
expr_stmt|;
name|vb
operator|->
name|seed_key
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|seed_key
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|vb
operator|->
name|seed_key
operator|=
name|BUF_strdup
argument_list|(
name|seed_key
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sk_SRP_user_pwd_free
argument_list|(
name|vb
operator|->
name|users_pwd
argument_list|)
expr_stmt|;
name|sk_SRP_gN_cache_free
argument_list|(
name|vb
operator|->
name|gN_cache
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|vb
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|vb
return|;
block|}
end_function

begin_function
name|int
name|SRP_VBASE_free
parameter_list|(
name|SRP_VBASE
modifier|*
name|vb
parameter_list|)
block|{
name|sk_SRP_user_pwd_pop_free
argument_list|(
name|vb
operator|->
name|users_pwd
argument_list|,
name|SRP_user_pwd_free
argument_list|)
expr_stmt|;
name|sk_SRP_gN_cache_free
argument_list|(
name|vb
operator|->
name|gN_cache
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|vb
operator|->
name|seed_key
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|vb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|SRP_gN_cache
modifier|*
name|SRP_gN_new_init
parameter_list|(
specifier|const
name|char
modifier|*
name|ch
parameter_list|)
block|{
name|unsigned
name|char
name|tmp
index|[
name|MAX_LEN
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|SRP_gN_cache
modifier|*
name|newgN
init|=
operator|(
name|SRP_gN_cache
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SRP_gN_cache
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|newgN
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|newgN
operator|->
name|b64_bn
operator|=
name|BUF_strdup
argument_list|(
name|ch
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|len
operator|=
name|t_fromb64
argument_list|(
name|tmp
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newgN
operator|->
name|bn
operator|=
name|BN_bin2bn
argument_list|(
name|tmp
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
return|return
name|newgN
return|;
name|OPENSSL_free
argument_list|(
name|newgN
operator|->
name|b64_bn
argument_list|)
expr_stmt|;
name|err
label|:
name|OPENSSL_free
argument_list|(
name|newgN
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|SRP_gN_free
parameter_list|(
name|SRP_gN_cache
modifier|*
name|gN_cache
parameter_list|)
block|{
if|if
condition|(
name|gN_cache
operator|==
name|NULL
condition|)
return|return;
name|OPENSSL_free
argument_list|(
name|gN_cache
operator|->
name|b64_bn
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|gN_cache
operator|->
name|bn
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|gN_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|SRP_gN
modifier|*
name|SRP_get_gN_by_id
argument_list|(
specifier|const
name|char
operator|*
name|id
argument_list|,
name|STACK_OF
argument_list|(
name|SRP_gN
argument_list|)
operator|*
name|gN_tab
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|SRP_gN
modifier|*
name|gN
decl_stmt|;
if|if
condition|(
name|gN_tab
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_SRP_gN_num
argument_list|(
name|gN_tab
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|gN
operator|=
name|sk_SRP_gN_value
argument_list|(
name|gN_tab
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|gN
operator|&&
operator|(
name|id
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|gN
operator|->
name|id
argument_list|,
name|id
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|gN
return|;
block|}
return|return
name|SRP_get_default_gN
argument_list|(
name|id
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|BIGNUM
modifier|*
name|SRP_gN_place_bn
argument_list|(
name|STACK_OF
argument_list|(
name|SRP_gN_cache
argument_list|)
operator|*
name|gN_cache
argument_list|,
name|char
operator|*
name|ch
argument_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|gN_cache
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* search if we have already one... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_SRP_gN_cache_num
argument_list|(
name|gN_cache
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|SRP_gN_cache
modifier|*
name|cache
init|=
name|sk_SRP_gN_cache_value
argument_list|(
name|gN_cache
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cache
operator|->
name|b64_bn
argument_list|,
name|ch
argument_list|)
operator|==
literal|0
condition|)
return|return
name|cache
operator|->
name|bn
return|;
block|}
block|{
comment|/* it is the first time that we find it */
name|SRP_gN_cache
modifier|*
name|newgN
init|=
name|SRP_gN_new_init
argument_list|(
name|ch
argument_list|)
decl_stmt|;
if|if
condition|(
name|newgN
condition|)
block|{
if|if
condition|(
name|sk_SRP_gN_cache_insert
argument_list|(
name|gN_cache
argument_list|,
name|newgN
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
return|return
name|newgN
operator|->
name|bn
return|;
name|SRP_gN_free
argument_list|(
name|newgN
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * this function parses verifier file. Format is:  * string(index):base64(N):base64(g):0  * string(username):base64(v):base64(salt):int(index)  */
end_comment

begin_function
name|int
name|SRP_VBASE_init
parameter_list|(
name|SRP_VBASE
modifier|*
name|vb
parameter_list|,
name|char
modifier|*
name|verifier_file
parameter_list|)
block|{
name|int
name|error_code
decl_stmt|;
name|STACK_OF
argument_list|(
name|SRP_gN
argument_list|)
operator|*
name|SRP_gN_tab
operator|=
name|sk_SRP_gN_new_null
argument_list|()
expr_stmt|;
name|char
modifier|*
name|last_index
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|SRP_gN
modifier|*
name|gN
init|=
name|NULL
decl_stmt|;
name|SRP_user_pwd
modifier|*
name|user_pwd
init|=
name|NULL
decl_stmt|;
name|TXT_DB
modifier|*
name|tmpdb
init|=
name|NULL
decl_stmt|;
name|BIO
modifier|*
name|in
init|=
name|BIO_new
argument_list|(
name|BIO_s_file
argument_list|()
argument_list|)
decl_stmt|;
name|error_code
operator|=
name|SRP_ERR_OPEN_FILE
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
operator|||
name|BIO_read_filename
argument_list|(
name|in
argument_list|,
name|verifier_file
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
name|error_code
operator|=
name|SRP_ERR_VBASE_INCOMPLETE_FILE
expr_stmt|;
if|if
condition|(
operator|(
name|tmpdb
operator|=
name|TXT_DB_read
argument_list|(
name|in
argument_list|,
name|DB_NUMBER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|error_code
operator|=
name|SRP_ERR_MEMORY
expr_stmt|;
if|if
condition|(
name|vb
operator|->
name|seed_key
condition|)
block|{
name|last_index
operator|=
name|SRP_get_default_gN
argument_list|(
name|NULL
argument_list|)
operator|->
name|id
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_OPENSSL_PSTRING_num
argument_list|(
name|tmpdb
operator|->
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|pp
operator|=
name|sk_OPENSSL_PSTRING_value
argument_list|(
name|tmpdb
operator|->
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
index|[
name|DB_srptype
index|]
index|[
literal|0
index|]
operator|==
name|DB_SRP_INDEX
condition|)
block|{
comment|/*              * we add this couple in the internal Stack              */
if|if
condition|(
operator|(
name|gN
operator|=
operator|(
name|SRP_gN
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SRP_gN
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
operator|(
name|gN
operator|->
name|id
operator|=
name|BUF_strdup
argument_list|(
name|pp
index|[
name|DB_srpid
index|]
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|gN
operator|->
name|N
operator|=
name|SRP_gN_place_bn
argument_list|(
name|vb
operator|->
name|gN_cache
argument_list|,
name|pp
index|[
name|DB_srpverifier
index|]
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|gN
operator|->
name|g
operator|=
name|SRP_gN_place_bn
argument_list|(
name|vb
operator|->
name|gN_cache
argument_list|,
name|pp
index|[
name|DB_srpsalt
index|]
argument_list|)
operator|)
operator|||
name|sk_SRP_gN_insert
argument_list|(
name|SRP_gN_tab
argument_list|,
name|gN
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
name|gN
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vb
operator|->
name|seed_key
operator|!=
name|NULL
condition|)
block|{
name|last_index
operator|=
name|pp
index|[
name|DB_srpid
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pp
index|[
name|DB_srptype
index|]
index|[
literal|0
index|]
operator|==
name|DB_SRP_VALID
condition|)
block|{
comment|/* it is a user .... */
name|SRP_gN
modifier|*
name|lgN
decl_stmt|;
if|if
condition|(
operator|(
name|lgN
operator|=
name|SRP_get_gN_by_id
argument_list|(
name|pp
index|[
name|DB_srpgN
index|]
argument_list|,
name|SRP_gN_tab
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error_code
operator|=
name|SRP_ERR_MEMORY
expr_stmt|;
if|if
condition|(
operator|(
name|user_pwd
operator|=
name|SRP_user_pwd_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|SRP_user_pwd_set_gN
argument_list|(
name|user_pwd
argument_list|,
name|lgN
operator|->
name|g
argument_list|,
name|lgN
operator|->
name|N
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SRP_user_pwd_set_ids
argument_list|(
name|user_pwd
argument_list|,
name|pp
index|[
name|DB_srpid
index|]
argument_list|,
name|pp
index|[
name|DB_srpinfo
index|]
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|error_code
operator|=
name|SRP_ERR_VBASE_BN_LIB
expr_stmt|;
if|if
condition|(
operator|!
name|SRP_user_pwd_set_sv
argument_list|(
name|user_pwd
argument_list|,
name|pp
index|[
name|DB_srpsalt
index|]
argument_list|,
name|pp
index|[
name|DB_srpverifier
index|]
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|sk_SRP_user_pwd_insert
argument_list|(
name|vb
operator|->
name|users_pwd
argument_list|,
name|user_pwd
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
name|user_pwd
operator|=
name|NULL
expr_stmt|;
comment|/* abandon responsability */
block|}
block|}
block|}
if|if
condition|(
name|last_index
operator|!=
name|NULL
condition|)
block|{
comment|/* this means that we want to simulate a default user */
if|if
condition|(
operator|(
operator|(
name|gN
operator|=
name|SRP_get_gN_by_id
argument_list|(
name|last_index
argument_list|,
name|SRP_gN_tab
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|error_code
operator|=
name|SRP_ERR_VBASE_BN_LIB
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|vb
operator|->
name|default_g
operator|=
name|gN
operator|->
name|g
expr_stmt|;
name|vb
operator|->
name|default_N
operator|=
name|gN
operator|->
name|N
expr_stmt|;
name|gN
operator|=
name|NULL
expr_stmt|;
block|}
name|error_code
operator|=
name|SRP_NO_ERROR
expr_stmt|;
name|err
label|:
comment|/*      * there may be still some leaks to fix, if this fails, the application      * terminates most likely      */
if|if
condition|(
name|gN
operator|!=
name|NULL
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|gN
operator|->
name|id
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|gN
argument_list|)
expr_stmt|;
block|}
name|SRP_user_pwd_free
argument_list|(
name|user_pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpdb
condition|)
name|TXT_DB_free
argument_list|(
name|tmpdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
condition|)
name|BIO_free_all
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|sk_SRP_gN_free
argument_list|(
name|SRP_gN_tab
argument_list|)
expr_stmt|;
return|return
name|error_code
return|;
block|}
end_function

begin_function
name|SRP_user_pwd
modifier|*
name|SRP_VBASE_get_by_user
parameter_list|(
name|SRP_VBASE
modifier|*
name|vb
parameter_list|,
name|char
modifier|*
name|username
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|SRP_user_pwd
modifier|*
name|user
decl_stmt|;
name|unsigned
name|char
name|digv
index|[
name|SHA_DIGEST_LENGTH
index|]
decl_stmt|;
name|unsigned
name|char
name|digs
index|[
name|SHA_DIGEST_LENGTH
index|]
decl_stmt|;
name|EVP_MD_CTX
name|ctxt
decl_stmt|;
if|if
condition|(
name|vb
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_SRP_user_pwd_num
argument_list|(
name|vb
operator|->
name|users_pwd
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|user
operator|=
name|sk_SRP_user_pwd_value
argument_list|(
name|vb
operator|->
name|users_pwd
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|user
operator|->
name|id
argument_list|,
name|username
argument_list|)
operator|==
literal|0
condition|)
return|return
name|user
return|;
block|}
if|if
condition|(
operator|(
name|vb
operator|->
name|seed_key
operator|==
name|NULL
operator|)
operator|||
operator|(
name|vb
operator|->
name|default_g
operator|==
name|NULL
operator|)
operator|||
operator|(
name|vb
operator|->
name|default_N
operator|==
name|NULL
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* if the user is unknown we set parameters as well if we have a seed_key */
if|if
condition|(
operator|(
name|user
operator|=
name|SRP_user_pwd_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|SRP_user_pwd_set_gN
argument_list|(
name|user
argument_list|,
name|vb
operator|->
name|default_g
argument_list|,
name|vb
operator|->
name|default_N
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SRP_user_pwd_set_ids
argument_list|(
name|user
argument_list|,
name|username
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|RAND_pseudo_bytes
argument_list|(
name|digv
argument_list|,
name|SHA_DIGEST_LENGTH
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_init
argument_list|(
operator|&
name|ctxt
argument_list|)
expr_stmt|;
name|EVP_DigestInit_ex
argument_list|(
operator|&
name|ctxt
argument_list|,
name|EVP_sha1
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|ctxt
argument_list|,
name|vb
operator|->
name|seed_key
argument_list|,
name|strlen
argument_list|(
name|vb
operator|->
name|seed_key
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|ctxt
argument_list|,
name|username
argument_list|,
name|strlen
argument_list|(
name|username
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestFinal_ex
argument_list|(
operator|&
name|ctxt
argument_list|,
name|digs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|ctxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|SRP_user_pwd_set_sv_BN
argument_list|(
name|user
argument_list|,
name|BN_bin2bn
argument_list|(
name|digs
argument_list|,
name|SHA_DIGEST_LENGTH
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|BN_bin2bn
argument_list|(
name|digv
argument_list|,
name|SHA_DIGEST_LENGTH
argument_list|,
name|NULL
argument_list|)
argument_list|)
condition|)
return|return
name|user
return|;
name|err
label|:
name|SRP_user_pwd_free
argument_list|(
name|user
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * create a verifier (*salt,*verifier,g and N are in base64)  */
end_comment

begin_function
name|char
modifier|*
name|SRP_create_verifier
parameter_list|(
specifier|const
name|char
modifier|*
name|user
parameter_list|,
specifier|const
name|char
modifier|*
name|pass
parameter_list|,
name|char
modifier|*
modifier|*
name|salt
parameter_list|,
name|char
modifier|*
modifier|*
name|verifier
parameter_list|,
specifier|const
name|char
modifier|*
name|N
parameter_list|,
specifier|const
name|char
modifier|*
name|g
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|vf
decl_stmt|;
name|BIGNUM
modifier|*
name|N_bn
init|=
name|NULL
decl_stmt|,
modifier|*
name|g_bn
init|=
name|NULL
decl_stmt|,
modifier|*
name|s
init|=
name|NULL
decl_stmt|,
modifier|*
name|v
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|tmp
index|[
name|MAX_LEN
index|]
decl_stmt|;
name|unsigned
name|char
name|tmp2
index|[
name|MAX_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|defgNid
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|user
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pass
operator|==
name|NULL
operator|)
operator|||
operator|(
name|salt
operator|==
name|NULL
operator|)
operator|||
operator|(
name|verifier
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|N
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|len
operator|=
name|t_fromb64
argument_list|(
name|tmp
argument_list|,
name|N
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
name|N_bn
operator|=
name|BN_bin2bn
argument_list|(
name|tmp
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|len
operator|=
name|t_fromb64
argument_list|(
name|tmp
argument_list|,
name|g
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
name|g_bn
operator|=
name|BN_bin2bn
argument_list|(
name|tmp
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|defgNid
operator|=
literal|"*"
expr_stmt|;
block|}
else|else
block|{
name|SRP_gN
modifier|*
name|gN
init|=
name|SRP_get_gN_by_id
argument_list|(
name|g
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|gN
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|N_bn
operator|=
name|gN
operator|->
name|N
expr_stmt|;
name|g_bn
operator|=
name|gN
operator|->
name|g
expr_stmt|;
name|defgNid
operator|=
name|gN
operator|->
name|id
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|salt
operator|==
name|NULL
condition|)
block|{
name|RAND_pseudo_bytes
argument_list|(
name|tmp2
argument_list|,
name|SRP_RANDOM_SALT_LEN
argument_list|)
expr_stmt|;
name|s
operator|=
name|BN_bin2bn
argument_list|(
name|tmp2
argument_list|,
name|SRP_RANDOM_SALT_LEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|len
operator|=
name|t_fromb64
argument_list|(
name|tmp2
argument_list|,
operator|*
name|salt
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
name|s
operator|=
name|BN_bin2bn
argument_list|(
name|tmp2
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SRP_create_verifier_BN
argument_list|(
name|user
argument_list|,
name|pass
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|v
argument_list|,
name|N_bn
argument_list|,
name|g_bn
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|BN_bn2bin
argument_list|(
name|v
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|vf
operator|=
name|OPENSSL_malloc
argument_list|(
name|BN_num_bytes
argument_list|(
name|v
argument_list|)
operator|*
literal|2
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|err
goto|;
name|t_tob64
argument_list|(
name|vf
argument_list|,
name|tmp
argument_list|,
name|BN_num_bytes
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|verifier
operator|=
name|vf
expr_stmt|;
if|if
condition|(
operator|*
name|salt
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|tmp_salt
decl_stmt|;
if|if
condition|(
operator|(
name|tmp_salt
operator|=
name|OPENSSL_malloc
argument_list|(
name|SRP_RANDOM_SALT_LEN
operator|*
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|vf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|t_tob64
argument_list|(
name|tmp_salt
argument_list|,
name|tmp2
argument_list|,
name|SRP_RANDOM_SALT_LEN
argument_list|)
expr_stmt|;
operator|*
name|salt
operator|=
name|tmp_salt
expr_stmt|;
block|}
name|result
operator|=
name|defgNid
expr_stmt|;
name|err
label|:
if|if
condition|(
name|N
condition|)
block|{
name|BN_free
argument_list|(
name|N_bn
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|g_bn
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * create a verifier (*salt,*verifier,g and N are BIGNUMs)  */
end_comment

begin_function
name|int
name|SRP_create_verifier_BN
parameter_list|(
specifier|const
name|char
modifier|*
name|user
parameter_list|,
specifier|const
name|char
modifier|*
name|pass
parameter_list|,
name|BIGNUM
modifier|*
modifier|*
name|salt
parameter_list|,
name|BIGNUM
modifier|*
modifier|*
name|verifier
parameter_list|,
name|BIGNUM
modifier|*
name|N
parameter_list|,
name|BIGNUM
modifier|*
name|g
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|BIGNUM
modifier|*
name|x
init|=
name|NULL
decl_stmt|;
name|BN_CTX
modifier|*
name|bn_ctx
init|=
name|BN_CTX_new
argument_list|()
decl_stmt|;
name|unsigned
name|char
name|tmp2
index|[
name|MAX_LEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|user
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pass
operator|==
name|NULL
operator|)
operator|||
operator|(
name|salt
operator|==
name|NULL
operator|)
operator|||
operator|(
name|verifier
operator|==
name|NULL
operator|)
operator|||
operator|(
name|N
operator|==
name|NULL
operator|)
operator|||
operator|(
name|g
operator|==
name|NULL
operator|)
operator|||
operator|(
name|bn_ctx
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|err
goto|;
name|srp_bn_print
argument_list|(
name|N
argument_list|)
expr_stmt|;
name|srp_bn_print
argument_list|(
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|salt
operator|==
name|NULL
condition|)
block|{
name|RAND_pseudo_bytes
argument_list|(
name|tmp2
argument_list|,
name|SRP_RANDOM_SALT_LEN
argument_list|)
expr_stmt|;
operator|*
name|salt
operator|=
name|BN_bin2bn
argument_list|(
name|tmp2
argument_list|,
name|SRP_RANDOM_SALT_LEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|SRP_Calc_x
argument_list|(
operator|*
name|salt
argument_list|,
name|user
argument_list|,
name|pass
argument_list|)
expr_stmt|;
operator|*
name|verifier
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|verifier
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|BN_mod_exp
argument_list|(
operator|*
name|verifier
argument_list|,
name|g
argument_list|,
name|x
argument_list|,
name|N
argument_list|,
name|bn_ctx
argument_list|)
condition|)
block|{
name|BN_clear_free
argument_list|(
operator|*
name|verifier
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|srp_bn_print
argument_list|(
operator|*
name|verifier
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|BN_clear_free
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bn_ctx
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

