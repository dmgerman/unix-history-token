begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/comp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_function_decl
name|COMP_METHOD
modifier|*
name|COMP_zlib
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|COMP_METHOD
name|zlib_method_nozlib
init|=
block|{
name|NID_undef
block|,
literal|"(undef)"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|, 	}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ZLIB
end_ifndef

begin_undef
undef|#
directive|undef
name|ZLIB_SHARED
end_undef

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_function_decl
specifier|static
name|int
name|zlib_stateful_init
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zlib_stateful_finish
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zlib_stateful_compress_block
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|unsigned
name|int
name|olen
parameter_list|,
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|int
name|ilen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zlib_stateful_expand_block
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|unsigned
name|int
name|olen
parameter_list|,
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|int
name|ilen
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* memory allocations functions for zlib intialization */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|zlib_zalloc
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
name|unsigned
name|int
name|no
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|OPENSSL_malloc
argument_list|(
name|no
operator|*
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|no
operator|*
name|size
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zlib_zfree
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
name|void
modifier|*
name|address
parameter_list|)
block|{
name|OPENSSL_free
argument_list|(
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int zlib_compress_block(COMP_CTX *ctx, unsigned char *out, 	unsigned int olen, unsigned char *in, unsigned int ilen); static int zlib_expand_block(COMP_CTX *ctx, unsigned char *out, 	unsigned int olen, unsigned char *in, unsigned int ilen);  static int zz_uncompress(Bytef *dest, uLongf *destLen, const Bytef *source, 	uLong sourceLen);  static COMP_METHOD zlib_stateless_method={ 	NID_zlib_compression, 	LN_zlib_compression, 	NULL, 	NULL, 	zlib_compress_block, 	zlib_expand_block, 	NULL, 	NULL, 	};
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|COMP_METHOD
name|zlib_stateful_method
init|=
block|{
name|NID_zlib_compression
block|,
name|LN_zlib_compression
block|,
name|zlib_stateful_init
block|,
name|zlib_stateful_finish
block|,
name|zlib_stateful_compress_block
block|,
name|zlib_stateful_expand_block
block|,
name|NULL
block|,
name|NULL
block|, 	}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * When OpenSSL is built on Windows, we do not want to require that  * the ZLIB.DLL be available in order for the OpenSSL DLLs to  * work.  Therefore, all ZLIB routines are loaded at run time  * and we do not link to a .LIB file when ZLIB_SHARED is set.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_SYS_WINDOWS
argument_list|)
operator|||
name|defined
argument_list|(
name|OPENSSL_SYS_WIN32
argument_list|)
end_if

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !(OPENSSL_SYS_WINDOWS || OPENSSL_SYS_WIN32) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ZLIB_SHARED
end_ifdef

begin_include
include|#
directive|include
file|<openssl/dso.h>
end_include

begin_comment
comment|/* Function pointers */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|compress_ft
function_decl|)
parameter_list|(
name|Bytef
modifier|*
name|dest
parameter_list|,
name|uLongf
modifier|*
name|destLen
parameter_list|,
specifier|const
name|Bytef
modifier|*
name|source
parameter_list|,
name|uLong
name|sourceLen
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|inflateEnd_ft
function_decl|)
parameter_list|(
name|z_streamp
name|strm
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|inflate_ft
function_decl|)
parameter_list|(
name|z_streamp
name|strm
parameter_list|,
name|int
name|flush
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|inflateInit__ft
function_decl|)
parameter_list|(
name|z_streamp
name|strm
parameter_list|,
specifier|const
name|char
modifier|*
name|version
parameter_list|,
name|int
name|stream_size
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|deflateEnd_ft
function_decl|)
parameter_list|(
name|z_streamp
name|strm
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|deflate_ft
function_decl|)
parameter_list|(
name|z_streamp
name|strm
parameter_list|,
name|int
name|flush
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|deflateInit__ft
function_decl|)
parameter_list|(
name|z_streamp
name|strm
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|version
parameter_list|,
name|int
name|stream_size
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|compress_ft
name|p_compress
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|inflateEnd_ft
name|p_inflateEnd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|inflate_ft
name|p_inflate
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|inflateInit__ft
name|p_inflateInit_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|deflateEnd_ft
name|p_deflateEnd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|deflate_ft
name|p_deflate
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|deflateInit__ft
name|p_deflateInit_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zlib_loaded
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* only attempt to init func pts once */
end_comment

begin_decl_stmt
specifier|static
name|DSO
modifier|*
name|zlib_dso
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|compress
value|p_compress
end_define

begin_define
define|#
directive|define
name|inflateEnd
value|p_inflateEnd
end_define

begin_define
define|#
directive|define
name|inflate
value|p_inflate
end_define

begin_define
define|#
directive|define
name|inflateInit_
value|p_inflateInit_
end_define

begin_define
define|#
directive|define
name|deflateEnd
value|p_deflateEnd
end_define

begin_define
define|#
directive|define
name|deflate
value|p_deflate
end_define

begin_define
define|#
directive|define
name|deflateInit_
value|p_deflateInit_
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ZLIB_SHARED */
end_comment

begin_struct
struct|struct
name|zlib_state
block|{
name|z_stream
name|istream
decl_stmt|;
name|z_stream
name|ostream
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|zlib_stateful_ex_idx
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|zlib_stateful_free_ex_data
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|CRYPTO_EX_DATA
modifier|*
name|ad
parameter_list|,
name|int
name|ind
parameter_list|,
name|long
name|argl
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|)
block|{
name|struct
name|zlib_state
modifier|*
name|state
init|=
operator|(
expr|struct
name|zlib_state
operator|*
operator|)
name|item
decl_stmt|;
name|inflateEnd
argument_list|(
operator|&
name|state
operator|->
name|istream
argument_list|)
expr_stmt|;
name|deflateEnd
argument_list|(
operator|&
name|state
operator|->
name|ostream
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zlib_stateful_init
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|zlib_state
modifier|*
name|state
init|=
operator|(
expr|struct
name|zlib_state
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|zlib_state
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|state
operator|->
name|istream
operator|.
name|zalloc
operator|=
name|zlib_zalloc
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|zfree
operator|=
name|zlib_zfree
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|next_out
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|inflateInit_
argument_list|(
operator|&
name|state
operator|->
name|istream
argument_list|,
name|ZLIB_VERSION
argument_list|,
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
goto|goto
name|err
goto|;
name|state
operator|->
name|ostream
operator|.
name|zalloc
operator|=
name|zlib_zalloc
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|zfree
operator|=
name|zlib_zfree
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|next_out
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|deflateInit_
argument_list|(
operator|&
name|state
operator|->
name|ostream
argument_list|,
name|Z_DEFAULT_COMPRESSION
argument_list|,
name|ZLIB_VERSION
argument_list|,
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
goto|goto
name|err
goto|;
name|CRYPTO_new_ex_data
argument_list|(
name|CRYPTO_EX_INDEX_COMP
argument_list|,
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|ex_data
argument_list|)
expr_stmt|;
name|CRYPTO_set_ex_data
argument_list|(
operator|&
name|ctx
operator|->
name|ex_data
argument_list|,
name|zlib_stateful_ex_idx
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|err
label|:
if|if
condition|(
name|state
condition|)
name|OPENSSL_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zlib_stateful_finish
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|CRYPTO_free_ex_data
argument_list|(
name|CRYPTO_EX_INDEX_COMP
argument_list|,
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|ex_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zlib_stateful_compress_block
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|unsigned
name|int
name|olen
parameter_list|,
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|int
name|ilen
parameter_list|)
block|{
name|int
name|err
init|=
name|Z_OK
decl_stmt|;
name|struct
name|zlib_state
modifier|*
name|state
init|=
operator|(
expr|struct
name|zlib_state
operator|*
operator|)
name|CRYPTO_get_ex_data
argument_list|(
operator|&
name|ctx
operator|->
name|ex_data
argument_list|,
name|zlib_stateful_ex_idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|state
operator|->
name|ostream
operator|.
name|next_in
operator|=
name|in
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|avail_in
operator|=
name|ilen
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|next_out
operator|=
name|out
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|avail_out
operator|=
name|olen
expr_stmt|;
if|if
condition|(
name|ilen
operator|>
literal|0
condition|)
name|err
operator|=
name|deflate
argument_list|(
operator|&
name|state
operator|->
name|ostream
argument_list|,
name|Z_SYNC_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compress(%4d)->%4d %s\n"
argument_list|,
name|ilen
argument_list|,
name|olen
operator|-
name|state
operator|->
name|ostream
operator|.
name|avail_out
argument_list|,
operator|(
name|ilen
operator|!=
name|olen
operator|-
name|state
operator|->
name|ostream
operator|.
name|avail_out
operator|)
condition|?
literal|"zlib"
else|:
literal|"clear"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|olen
operator|-
name|state
operator|->
name|ostream
operator|.
name|avail_out
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zlib_stateful_expand_block
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|unsigned
name|int
name|olen
parameter_list|,
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|int
name|ilen
parameter_list|)
block|{
name|int
name|err
init|=
name|Z_OK
decl_stmt|;
name|struct
name|zlib_state
modifier|*
name|state
init|=
operator|(
expr|struct
name|zlib_state
operator|*
operator|)
name|CRYPTO_get_ex_data
argument_list|(
operator|&
name|ctx
operator|->
name|ex_data
argument_list|,
name|zlib_stateful_ex_idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|state
operator|->
name|istream
operator|.
name|next_in
operator|=
name|in
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|avail_in
operator|=
name|ilen
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|next_out
operator|=
name|out
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|avail_out
operator|=
name|olen
expr_stmt|;
if|if
condition|(
name|ilen
operator|>
literal|0
condition|)
name|err
operator|=
name|inflate
argument_list|(
operator|&
name|state
operator|->
name|istream
argument_list|,
name|Z_SYNC_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expand(%4d)->%4d %s\n"
argument_list|,
name|ilen
argument_list|,
name|olen
operator|-
name|state
operator|->
name|istream
operator|.
name|avail_out
argument_list|,
operator|(
name|ilen
operator|!=
name|olen
operator|-
name|state
operator|->
name|istream
operator|.
name|avail_out
operator|)
condition|?
literal|"zlib"
else|:
literal|"clear"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|olen
operator|-
name|state
operator|->
name|istream
operator|.
name|avail_out
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_ifdef
unit|static int zlib_compress_block(COMP_CTX *ctx, unsigned char *out, 	unsigned int olen, unsigned char *in, unsigned int ilen) 	{ 	unsigned long l; 	int i; 	int clear=1;  	if (ilen> 128) 		{ 		out[0]=1; 		l=olen-1; 		i=compress(&(out[1]),&l,in,(unsigned long)ilen); 		if (i != Z_OK) 			return(-1); 		if (ilen> l) 			{ 			clear=0; 			l++; 			} 		} 	if (clear) 		{ 		out[0]=0; 		memcpy(&(out[1]),in,ilen); 		l=ilen+1; 		}
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
end_ifdef

begin_endif
unit|fprintf(stderr,"compress(%4d)->%4d %s\n", 		ilen,(int)l,(clear)?"clear":"zlib");
endif|#
directive|endif
end_endif

begin_ifdef
unit|return((int)l); 	}  static int zlib_expand_block(COMP_CTX *ctx, unsigned char *out, 	unsigned int olen, unsigned char *in, unsigned int ilen) 	{ 	unsigned long l; 	int i;  	if (in[0]) 		{ 		l=olen; 		i=zz_uncompress(out,&l,&(in[1]),(unsigned long)ilen-1); 		if (i != Z_OK) 			return(-1); 		} 	else 		{ 		memcpy(out,&(in[1]),ilen-1); 		l=ilen-1; 		}
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
end_ifdef

begin_endif
unit|fprintf(stderr,"expand  (%4d)->%4d %s\n", 		ilen,(int)l,in[0]?"zlib":"clear");
endif|#
directive|endif
end_endif

begin_comment
unit|return((int)l); 	}  static int zz_uncompress (Bytef *dest, uLongf *destLen, const Bytef *source, 	     uLong sourceLen) {     z_stream stream;     int err;      stream.next_in = (Bytef*)source;     stream.avail_in = (uInt)sourceLen;
comment|/* Check for source> 64K on 16-bit machine: */
end_comment

begin_endif
unit|if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;      stream.next_out = dest;     stream.avail_out = (uInt)*destLen;     if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;      stream.zalloc = (alloc_func)0;     stream.zfree = (free_func)0;      err = inflateInit_(&stream, 	    ZLIB_VERSION, sizeof(z_stream));     if (err != Z_OK) return err;      err = inflate(&stream, Z_FINISH);     if (err != Z_STREAM_END) {         inflateEnd(&stream);         return err;     }     *destLen = stream.total_out;      err = inflateEnd(&stream);     return err; }
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|COMP_METHOD
modifier|*
name|COMP_zlib
parameter_list|(
name|void
parameter_list|)
block|{
name|COMP_METHOD
modifier|*
name|meth
init|=
operator|&
name|zlib_method_nozlib
decl_stmt|;
ifdef|#
directive|ifdef
name|ZLIB_SHARED
if|if
condition|(
operator|!
name|zlib_loaded
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_SYS_WINDOWS
argument_list|)
operator|||
name|defined
argument_list|(
name|OPENSSL_SYS_WIN32
argument_list|)
name|zlib_dso
operator|=
name|DSO_load
argument_list|(
name|NULL
argument_list|,
literal|"ZLIB1"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|zlib_dso
operator|=
name|DSO_load
argument_list|(
name|NULL
argument_list|,
literal|"z"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zlib_dso
operator|!=
name|NULL
condition|)
block|{
name|p_compress
operator|=
operator|(
name|compress_ft
operator|)
name|DSO_bind_func
argument_list|(
name|zlib_dso
argument_list|,
literal|"compress"
argument_list|)
expr_stmt|;
name|p_inflateEnd
operator|=
operator|(
name|inflateEnd_ft
operator|)
name|DSO_bind_func
argument_list|(
name|zlib_dso
argument_list|,
literal|"inflateEnd"
argument_list|)
expr_stmt|;
name|p_inflate
operator|=
operator|(
name|inflate_ft
operator|)
name|DSO_bind_func
argument_list|(
name|zlib_dso
argument_list|,
literal|"inflate"
argument_list|)
expr_stmt|;
name|p_inflateInit_
operator|=
operator|(
name|inflateInit__ft
operator|)
name|DSO_bind_func
argument_list|(
name|zlib_dso
argument_list|,
literal|"inflateInit_"
argument_list|)
expr_stmt|;
name|p_deflateEnd
operator|=
operator|(
name|deflateEnd_ft
operator|)
name|DSO_bind_func
argument_list|(
name|zlib_dso
argument_list|,
literal|"deflateEnd"
argument_list|)
expr_stmt|;
name|p_deflate
operator|=
operator|(
name|deflate_ft
operator|)
name|DSO_bind_func
argument_list|(
name|zlib_dso
argument_list|,
literal|"deflate"
argument_list|)
expr_stmt|;
name|p_deflateInit_
operator|=
operator|(
name|deflateInit__ft
operator|)
name|DSO_bind_func
argument_list|(
name|zlib_dso
argument_list|,
literal|"deflateInit_"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_compress
operator|&&
name|p_inflateEnd
operator|&&
name|p_inflate
operator|&&
name|p_inflateInit_
operator|&&
name|p_deflateEnd
operator|&&
name|p_deflate
operator|&&
name|p_deflateInit_
condition|)
name|zlib_loaded
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ZLIB_SHARED
if|if
condition|(
name|zlib_loaded
condition|)
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ZLIB
argument_list|)
operator|||
name|defined
argument_list|(
name|ZLIB_SHARED
argument_list|)
block|{
comment|/* init zlib_stateful_ex_idx here so that in a multi-process 		 * application it's enough to intialize openssl before forking 		 * (idx will be inherited in all the children) */
if|if
condition|(
name|zlib_stateful_ex_idx
operator|==
operator|-
literal|1
condition|)
block|{
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_COMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|zlib_stateful_ex_idx
operator|==
operator|-
literal|1
condition|)
name|zlib_stateful_ex_idx
operator|=
name|CRYPTO_get_ex_new_index
argument_list|(
name|CRYPTO_EX_INDEX_COMP
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|zlib_stateful_free_ex_data
argument_list|)
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_COMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|zlib_stateful_ex_idx
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
block|}
name|meth
operator|=
operator|&
name|zlib_stateful_method
expr_stmt|;
block|}
name|err
label|:
endif|#
directive|endif
return|return
operator|(
name|meth
operator|)
return|;
block|}
end_function

end_unit

