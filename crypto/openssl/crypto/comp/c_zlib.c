begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/comp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_function_decl
name|COMP_METHOD
modifier|*
name|COMP_zlib
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|COMP_METHOD
name|zlib_method_nozlib
init|=
block|{
name|NID_undef
block|,
literal|"(undef)"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|, 	}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ZLIB
end_ifndef

begin_undef
undef|#
directive|undef
name|ZLIB_SHARED
end_undef

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_function_decl
specifier|static
name|int
name|zlib_stateful_init
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zlib_stateful_finish
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zlib_stateful_compress_block
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|unsigned
name|int
name|olen
parameter_list|,
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|int
name|ilen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zlib_stateful_expand_block
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|unsigned
name|int
name|olen
parameter_list|,
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|int
name|ilen
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* memory allocations functions for zlib intialization */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|zlib_zalloc
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
name|unsigned
name|int
name|no
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|OPENSSL_malloc
argument_list|(
name|no
operator|*
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|no
operator|*
name|size
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zlib_zfree
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
name|void
modifier|*
name|address
parameter_list|)
block|{
name|OPENSSL_free
argument_list|(
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int zlib_compress_block(COMP_CTX *ctx, unsigned char *out, 	unsigned int olen, unsigned char *in, unsigned int ilen); static int zlib_expand_block(COMP_CTX *ctx, unsigned char *out, 	unsigned int olen, unsigned char *in, unsigned int ilen);  static int zz_uncompress(Bytef *dest, uLongf *destLen, const Bytef *source, 	uLong sourceLen);  static COMP_METHOD zlib_stateless_method={ 	NID_zlib_compression, 	LN_zlib_compression, 	NULL, 	NULL, 	zlib_compress_block, 	zlib_expand_block, 	NULL, 	NULL, 	};
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|COMP_METHOD
name|zlib_stateful_method
init|=
block|{
name|NID_zlib_compression
block|,
name|LN_zlib_compression
block|,
name|zlib_stateful_init
block|,
name|zlib_stateful_finish
block|,
name|zlib_stateful_compress_block
block|,
name|zlib_stateful_expand_block
block|,
name|NULL
block|,
name|NULL
block|, 	}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * When OpenSSL is built on Windows, we do not want to require that  * the ZLIB.DLL be available in order for the OpenSSL DLLs to  * work.  Therefore, all ZLIB routines are loaded at run time  * and we do not link to a .LIB file when ZLIB_SHARED is set.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_SYS_WINDOWS
argument_list|)
operator|||
name|defined
argument_list|(
name|OPENSSL_SYS_WIN32
argument_list|)
end_if

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !(OPENSSL_SYS_WINDOWS || OPENSSL_SYS_WIN32) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ZLIB_SHARED
end_ifdef

begin_include
include|#
directive|include
file|<openssl/dso.h>
end_include

begin_comment
comment|/* Function pointers */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|compress_ft
function_decl|)
parameter_list|(
name|Bytef
modifier|*
name|dest
parameter_list|,
name|uLongf
modifier|*
name|destLen
parameter_list|,
specifier|const
name|Bytef
modifier|*
name|source
parameter_list|,
name|uLong
name|sourceLen
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|inflateEnd_ft
function_decl|)
parameter_list|(
name|z_streamp
name|strm
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|inflate_ft
function_decl|)
parameter_list|(
name|z_streamp
name|strm
parameter_list|,
name|int
name|flush
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|inflateInit__ft
function_decl|)
parameter_list|(
name|z_streamp
name|strm
parameter_list|,
specifier|const
name|char
modifier|*
name|version
parameter_list|,
name|int
name|stream_size
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|deflateEnd_ft
function_decl|)
parameter_list|(
name|z_streamp
name|strm
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|deflate_ft
function_decl|)
parameter_list|(
name|z_streamp
name|strm
parameter_list|,
name|int
name|flush
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|deflateInit__ft
function_decl|)
parameter_list|(
name|z_streamp
name|strm
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|version
parameter_list|,
name|int
name|stream_size
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|zError__ft
function_decl|)
parameter_list|(
name|int
name|err
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|compress_ft
name|p_compress
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|inflateEnd_ft
name|p_inflateEnd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|inflate_ft
name|p_inflate
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|inflateInit__ft
name|p_inflateInit_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|deflateEnd_ft
name|p_deflateEnd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|deflate_ft
name|p_deflate
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|deflateInit__ft
name|p_deflateInit_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|zError__ft
name|p_zError
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zlib_loaded
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* only attempt to init func pts once */
end_comment

begin_decl_stmt
specifier|static
name|DSO
modifier|*
name|zlib_dso
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|compress
value|p_compress
end_define

begin_define
define|#
directive|define
name|inflateEnd
value|p_inflateEnd
end_define

begin_define
define|#
directive|define
name|inflate
value|p_inflate
end_define

begin_define
define|#
directive|define
name|inflateInit_
value|p_inflateInit_
end_define

begin_define
define|#
directive|define
name|deflateEnd
value|p_deflateEnd
end_define

begin_define
define|#
directive|define
name|deflate
value|p_deflate
end_define

begin_define
define|#
directive|define
name|deflateInit_
value|p_deflateInit_
end_define

begin_define
define|#
directive|define
name|zError
value|p_zError
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ZLIB_SHARED */
end_comment

begin_struct
struct|struct
name|zlib_state
block|{
name|z_stream
name|istream
decl_stmt|;
name|z_stream
name|ostream
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|zlib_stateful_ex_idx
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zlib_stateful_init
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|zlib_state
modifier|*
name|state
init|=
operator|(
expr|struct
name|zlib_state
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|zlib_state
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|state
operator|->
name|istream
operator|.
name|zalloc
operator|=
name|zlib_zalloc
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|zfree
operator|=
name|zlib_zfree
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|next_out
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|inflateInit_
argument_list|(
operator|&
name|state
operator|->
name|istream
argument_list|,
name|ZLIB_VERSION
argument_list|,
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
goto|goto
name|err
goto|;
name|state
operator|->
name|ostream
operator|.
name|zalloc
operator|=
name|zlib_zalloc
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|zfree
operator|=
name|zlib_zfree
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|next_out
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|deflateInit_
argument_list|(
operator|&
name|state
operator|->
name|ostream
argument_list|,
name|Z_DEFAULT_COMPRESSION
argument_list|,
name|ZLIB_VERSION
argument_list|,
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
goto|goto
name|err
goto|;
name|CRYPTO_new_ex_data
argument_list|(
name|CRYPTO_EX_INDEX_COMP
argument_list|,
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|ex_data
argument_list|)
expr_stmt|;
name|CRYPTO_set_ex_data
argument_list|(
operator|&
name|ctx
operator|->
name|ex_data
argument_list|,
name|zlib_stateful_ex_idx
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|err
label|:
if|if
condition|(
name|state
condition|)
name|OPENSSL_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zlib_stateful_finish
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|zlib_state
modifier|*
name|state
init|=
operator|(
expr|struct
name|zlib_state
operator|*
operator|)
name|CRYPTO_get_ex_data
argument_list|(
operator|&
name|ctx
operator|->
name|ex_data
argument_list|,
name|zlib_stateful_ex_idx
argument_list|)
decl_stmt|;
name|inflateEnd
argument_list|(
operator|&
name|state
operator|->
name|istream
argument_list|)
expr_stmt|;
name|deflateEnd
argument_list|(
operator|&
name|state
operator|->
name|ostream
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|CRYPTO_free_ex_data
argument_list|(
name|CRYPTO_EX_INDEX_COMP
argument_list|,
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|ex_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zlib_stateful_compress_block
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|unsigned
name|int
name|olen
parameter_list|,
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|int
name|ilen
parameter_list|)
block|{
name|int
name|err
init|=
name|Z_OK
decl_stmt|;
name|struct
name|zlib_state
modifier|*
name|state
init|=
operator|(
expr|struct
name|zlib_state
operator|*
operator|)
name|CRYPTO_get_ex_data
argument_list|(
operator|&
name|ctx
operator|->
name|ex_data
argument_list|,
name|zlib_stateful_ex_idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|state
operator|->
name|ostream
operator|.
name|next_in
operator|=
name|in
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|avail_in
operator|=
name|ilen
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|next_out
operator|=
name|out
expr_stmt|;
name|state
operator|->
name|ostream
operator|.
name|avail_out
operator|=
name|olen
expr_stmt|;
if|if
condition|(
name|ilen
operator|>
literal|0
condition|)
name|err
operator|=
name|deflate
argument_list|(
operator|&
name|state
operator|->
name|ostream
argument_list|,
name|Z_SYNC_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compress(%4d)->%4d %s\n"
argument_list|,
name|ilen
argument_list|,
name|olen
operator|-
name|state
operator|->
name|ostream
operator|.
name|avail_out
argument_list|,
operator|(
name|ilen
operator|!=
name|olen
operator|-
name|state
operator|->
name|ostream
operator|.
name|avail_out
operator|)
condition|?
literal|"zlib"
else|:
literal|"clear"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|olen
operator|-
name|state
operator|->
name|ostream
operator|.
name|avail_out
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zlib_stateful_expand_block
parameter_list|(
name|COMP_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|unsigned
name|int
name|olen
parameter_list|,
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|int
name|ilen
parameter_list|)
block|{
name|int
name|err
init|=
name|Z_OK
decl_stmt|;
name|struct
name|zlib_state
modifier|*
name|state
init|=
operator|(
expr|struct
name|zlib_state
operator|*
operator|)
name|CRYPTO_get_ex_data
argument_list|(
operator|&
name|ctx
operator|->
name|ex_data
argument_list|,
name|zlib_stateful_ex_idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|state
operator|->
name|istream
operator|.
name|next_in
operator|=
name|in
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|avail_in
operator|=
name|ilen
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|next_out
operator|=
name|out
expr_stmt|;
name|state
operator|->
name|istream
operator|.
name|avail_out
operator|=
name|olen
expr_stmt|;
if|if
condition|(
name|ilen
operator|>
literal|0
condition|)
name|err
operator|=
name|inflate
argument_list|(
operator|&
name|state
operator|->
name|istream
argument_list|,
name|Z_SYNC_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expand(%4d)->%4d %s\n"
argument_list|,
name|ilen
argument_list|,
name|olen
operator|-
name|state
operator|->
name|istream
operator|.
name|avail_out
argument_list|,
operator|(
name|ilen
operator|!=
name|olen
operator|-
name|state
operator|->
name|istream
operator|.
name|avail_out
operator|)
condition|?
literal|"zlib"
else|:
literal|"clear"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|olen
operator|-
name|state
operator|->
name|istream
operator|.
name|avail_out
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_ifdef
unit|static int zlib_compress_block(COMP_CTX *ctx, unsigned char *out, 	unsigned int olen, unsigned char *in, unsigned int ilen) 	{ 	unsigned long l; 	int i; 	int clear=1;  	if (ilen> 128) 		{ 		out[0]=1; 		l=olen-1; 		i=compress(&(out[1]),&l,in,(unsigned long)ilen); 		if (i != Z_OK) 			return(-1); 		if (ilen> l) 			{ 			clear=0; 			l++; 			} 		} 	if (clear) 		{ 		out[0]=0; 		memcpy(&(out[1]),in,ilen); 		l=ilen+1; 		}
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
end_ifdef

begin_endif
unit|fprintf(stderr,"compress(%4d)->%4d %s\n", 		ilen,(int)l,(clear)?"clear":"zlib");
endif|#
directive|endif
end_endif

begin_ifdef
unit|return((int)l); 	}  static int zlib_expand_block(COMP_CTX *ctx, unsigned char *out, 	unsigned int olen, unsigned char *in, unsigned int ilen) 	{ 	unsigned long l; 	int i;  	if (in[0]) 		{ 		l=olen; 		i=zz_uncompress(out,&l,&(in[1]),(unsigned long)ilen-1); 		if (i != Z_OK) 			return(-1); 		} 	else 		{ 		memcpy(out,&(in[1]),ilen-1); 		l=ilen-1; 		}
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
end_ifdef

begin_endif
unit|fprintf(stderr,"expand  (%4d)->%4d %s\n", 		ilen,(int)l,in[0]?"zlib":"clear");
endif|#
directive|endif
end_endif

begin_comment
unit|return((int)l); 	}  static int zz_uncompress (Bytef *dest, uLongf *destLen, const Bytef *source, 	     uLong sourceLen) {     z_stream stream;     int err;      stream.next_in = (Bytef*)source;     stream.avail_in = (uInt)sourceLen;
comment|/* Check for source> 64K on 16-bit machine: */
end_comment

begin_endif
unit|if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;      stream.next_out = dest;     stream.avail_out = (uInt)*destLen;     if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;      stream.zalloc = (alloc_func)0;     stream.zfree = (free_func)0;      err = inflateInit_(&stream, 	    ZLIB_VERSION, sizeof(z_stream));     if (err != Z_OK) return err;      err = inflate(&stream, Z_FINISH);     if (err != Z_STREAM_END) {         inflateEnd(&stream);         return err;     }     *destLen = stream.total_out;      err = inflateEnd(&stream);     return err; }
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|COMP_METHOD
modifier|*
name|COMP_zlib
parameter_list|(
name|void
parameter_list|)
block|{
name|COMP_METHOD
modifier|*
name|meth
init|=
operator|&
name|zlib_method_nozlib
decl_stmt|;
ifdef|#
directive|ifdef
name|ZLIB_SHARED
if|if
condition|(
operator|!
name|zlib_loaded
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_SYS_WINDOWS
argument_list|)
operator|||
name|defined
argument_list|(
name|OPENSSL_SYS_WIN32
argument_list|)
name|zlib_dso
operator|=
name|DSO_load
argument_list|(
name|NULL
argument_list|,
literal|"ZLIB1"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|zlib_dso
operator|=
name|DSO_load
argument_list|(
name|NULL
argument_list|,
literal|"z"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zlib_dso
operator|!=
name|NULL
condition|)
block|{
name|p_compress
operator|=
operator|(
name|compress_ft
operator|)
name|DSO_bind_func
argument_list|(
name|zlib_dso
argument_list|,
literal|"compress"
argument_list|)
expr_stmt|;
name|p_inflateEnd
operator|=
operator|(
name|inflateEnd_ft
operator|)
name|DSO_bind_func
argument_list|(
name|zlib_dso
argument_list|,
literal|"inflateEnd"
argument_list|)
expr_stmt|;
name|p_inflate
operator|=
operator|(
name|inflate_ft
operator|)
name|DSO_bind_func
argument_list|(
name|zlib_dso
argument_list|,
literal|"inflate"
argument_list|)
expr_stmt|;
name|p_inflateInit_
operator|=
operator|(
name|inflateInit__ft
operator|)
name|DSO_bind_func
argument_list|(
name|zlib_dso
argument_list|,
literal|"inflateInit_"
argument_list|)
expr_stmt|;
name|p_deflateEnd
operator|=
operator|(
name|deflateEnd_ft
operator|)
name|DSO_bind_func
argument_list|(
name|zlib_dso
argument_list|,
literal|"deflateEnd"
argument_list|)
expr_stmt|;
name|p_deflate
operator|=
operator|(
name|deflate_ft
operator|)
name|DSO_bind_func
argument_list|(
name|zlib_dso
argument_list|,
literal|"deflate"
argument_list|)
expr_stmt|;
name|p_deflateInit_
operator|=
operator|(
name|deflateInit__ft
operator|)
name|DSO_bind_func
argument_list|(
name|zlib_dso
argument_list|,
literal|"deflateInit_"
argument_list|)
expr_stmt|;
name|p_zError
operator|=
operator|(
name|zError__ft
operator|)
name|DSO_bind_func
argument_list|(
name|zlib_dso
argument_list|,
literal|"zError"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_compress
operator|&&
name|p_inflateEnd
operator|&&
name|p_inflate
operator|&&
name|p_inflateInit_
operator|&&
name|p_deflateEnd
operator|&&
name|p_deflate
operator|&&
name|p_deflateInit_
operator|&&
name|p_zError
condition|)
name|zlib_loaded
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ZLIB_SHARED
if|if
condition|(
name|zlib_loaded
condition|)
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ZLIB
argument_list|)
operator|||
name|defined
argument_list|(
name|ZLIB_SHARED
argument_list|)
block|{
comment|/* init zlib_stateful_ex_idx here so that in a multi-process 		 * application it's enough to intialize openssl before forking 		 * (idx will be inherited in all the children) */
if|if
condition|(
name|zlib_stateful_ex_idx
operator|==
operator|-
literal|1
condition|)
block|{
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_COMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|zlib_stateful_ex_idx
operator|==
operator|-
literal|1
condition|)
name|zlib_stateful_ex_idx
operator|=
name|CRYPTO_get_ex_new_index
argument_list|(
name|CRYPTO_EX_INDEX_COMP
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_COMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|zlib_stateful_ex_idx
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
block|}
name|meth
operator|=
operator|&
name|zlib_stateful_method
expr_stmt|;
block|}
name|err
label|:
endif|#
directive|endif
return|return
operator|(
name|meth
operator|)
return|;
block|}
end_function

begin_function
name|void
name|COMP_zlib_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ZLIB_SHARED
if|if
condition|(
name|zlib_dso
condition|)
name|DSO_free
argument_list|(
name|zlib_dso
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ZLIB
end_ifdef

begin_comment
comment|/* Zlib based compression/decompression filter BIO */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
modifier|*
name|ibuf
decl_stmt|;
comment|/* Input buffer */
name|int
name|ibufsize
decl_stmt|;
comment|/* Buffer size */
name|z_stream
name|zin
decl_stmt|;
comment|/* Input decompress context */
name|unsigned
name|char
modifier|*
name|obuf
decl_stmt|;
comment|/* Output buffer */
name|int
name|obufsize
decl_stmt|;
comment|/* Output buffer size */
name|unsigned
name|char
modifier|*
name|optr
decl_stmt|;
comment|/* Position in output buffer */
name|int
name|ocount
decl_stmt|;
comment|/* Amount of data in output buffer */
name|int
name|odone
decl_stmt|;
comment|/* deflate EOF */
name|int
name|comp_level
decl_stmt|;
comment|/* Compression level to use */
name|z_stream
name|zout
decl_stmt|;
comment|/* Output compression context */
block|}
name|BIO_ZLIB_CTX
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ZLIB_DEFAULT_BUFSIZE
value|1024
end_define

begin_function_decl
specifier|static
name|int
name|bio_zlib_new
parameter_list|(
name|BIO
modifier|*
name|bi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bio_zlib_free
parameter_list|(
name|BIO
modifier|*
name|bi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bio_zlib_read
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
name|char
modifier|*
name|out
parameter_list|,
name|int
name|outl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bio_zlib_write
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|int
name|inl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|bio_zlib_ctrl
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|num
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|bio_zlib_callback_ctrl
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
name|int
name|cmd
parameter_list|,
name|bio_info_cb
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|BIO_METHOD
name|bio_meth_zlib
init|=
block|{
name|BIO_TYPE_COMP
block|,
literal|"zlib"
block|,
name|bio_zlib_write
block|,
name|bio_zlib_read
block|,
name|NULL
block|,
name|NULL
block|,
name|bio_zlib_ctrl
block|,
name|bio_zlib_new
block|,
name|bio_zlib_free
block|,
name|bio_zlib_callback_ctrl
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|BIO_METHOD
modifier|*
name|BIO_f_zlib
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|bio_meth_zlib
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bio_zlib_new
parameter_list|(
name|BIO
modifier|*
name|bi
parameter_list|)
block|{
name|BIO_ZLIB_CTX
modifier|*
name|ctx
decl_stmt|;
ifdef|#
directive|ifdef
name|ZLIB_SHARED
operator|(
name|void
operator|)
name|COMP_zlib
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zlib_loaded
condition|)
block|{
name|COMPerr
argument_list|(
name|COMP_F_BIO_ZLIB_NEW
argument_list|,
name|COMP_R_ZLIB_NOT_SUPPORTED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|ctx
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BIO_ZLIB_CTX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|COMPerr
argument_list|(
name|COMP_F_BIO_ZLIB_NEW
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ctx
operator|->
name|ibuf
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|obuf
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|ibufsize
operator|=
name|ZLIB_DEFAULT_BUFSIZE
expr_stmt|;
name|ctx
operator|->
name|obufsize
operator|=
name|ZLIB_DEFAULT_BUFSIZE
expr_stmt|;
name|ctx
operator|->
name|zin
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|ctx
operator|->
name|zin
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|ctx
operator|->
name|zin
operator|.
name|next_in
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|zin
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|zin
operator|.
name|next_out
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|zin
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|zout
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|ctx
operator|->
name|zout
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|ctx
operator|->
name|zout
operator|.
name|next_in
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|zout
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|zout
operator|.
name|next_out
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|zout
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|odone
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|comp_level
operator|=
name|Z_DEFAULT_COMPRESSION
expr_stmt|;
name|bi
operator|->
name|init
operator|=
literal|1
expr_stmt|;
name|bi
operator|->
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|ctx
expr_stmt|;
name|bi
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bio_zlib_free
parameter_list|(
name|BIO
modifier|*
name|bi
parameter_list|)
block|{
name|BIO_ZLIB_CTX
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
operator|!
name|bi
condition|)
return|return
literal|0
return|;
name|ctx
operator|=
operator|(
name|BIO_ZLIB_CTX
operator|*
operator|)
name|bi
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ibuf
condition|)
block|{
comment|/* Destroy decompress context */
name|inflateEnd
argument_list|(
operator|&
name|ctx
operator|->
name|zin
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|ctx
operator|->
name|ibuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|obuf
condition|)
block|{
comment|/* Destroy compress context */
name|deflateEnd
argument_list|(
operator|&
name|ctx
operator|->
name|zout
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|ctx
operator|->
name|obuf
argument_list|)
expr_stmt|;
block|}
name|OPENSSL_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|bi
operator|->
name|ptr
operator|=
name|NULL
expr_stmt|;
name|bi
operator|->
name|init
operator|=
literal|0
expr_stmt|;
name|bi
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bio_zlib_read
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
name|char
modifier|*
name|out
parameter_list|,
name|int
name|outl
parameter_list|)
block|{
name|BIO_ZLIB_CTX
modifier|*
name|ctx
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|z_stream
modifier|*
name|zin
decl_stmt|;
if|if
condition|(
operator|!
name|out
operator|||
operator|!
name|outl
condition|)
return|return
literal|0
return|;
name|ctx
operator|=
operator|(
name|BIO_ZLIB_CTX
operator|*
operator|)
name|b
operator|->
name|ptr
expr_stmt|;
name|zin
operator|=
operator|&
name|ctx
operator|->
name|zin
expr_stmt|;
name|BIO_clear_retry_flags
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|ibuf
condition|)
block|{
name|ctx
operator|->
name|ibuf
operator|=
name|OPENSSL_malloc
argument_list|(
name|ctx
operator|->
name|ibufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|ibuf
condition|)
block|{
name|COMPerr
argument_list|(
name|COMP_F_BIO_ZLIB_READ
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|inflateInit
argument_list|(
name|zin
argument_list|)
expr_stmt|;
name|zin
operator|->
name|next_in
operator|=
name|ctx
operator|->
name|ibuf
expr_stmt|;
name|zin
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Copy output data directly to supplied buffer */
name|zin
operator|->
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|out
expr_stmt|;
name|zin
operator|->
name|avail_out
operator|=
operator|(
name|unsigned
name|int
operator|)
name|outl
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Decompress while data available */
while|while
condition|(
name|zin
operator|->
name|avail_in
condition|)
block|{
name|ret
operator|=
name|inflate
argument_list|(
name|zin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|!=
name|Z_OK
operator|)
operator|&&
operator|(
name|ret
operator|!=
name|Z_STREAM_END
operator|)
condition|)
block|{
name|COMPerr
argument_list|(
name|COMP_F_BIO_ZLIB_READ
argument_list|,
name|COMP_R_ZLIB_INFLATE_ERROR
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"zlib error:"
argument_list|,
name|zError
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If EOF or we've read everything then return */
if|if
condition|(
operator|(
name|ret
operator|==
name|Z_STREAM_END
operator|)
operator|||
operator|!
name|zin
operator|->
name|avail_out
condition|)
return|return
name|outl
operator|-
name|zin
operator|->
name|avail_out
return|;
block|}
comment|/* No data in input buffer try to read some in, 		 * if an error then return the total data read. 		 */
name|ret
operator|=
name|BIO_read
argument_list|(
name|b
operator|->
name|next_bio
argument_list|,
name|ctx
operator|->
name|ibuf
argument_list|,
name|ctx
operator|->
name|ibufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
block|{
comment|/* Total data read */
name|int
name|tot
init|=
name|outl
operator|-
name|zin
operator|->
name|avail_out
decl_stmt|;
name|BIO_copy_next_retry
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|tot
operator|>
literal|0
operator|)
condition|?
name|tot
else|:
name|ret
return|;
return|return
name|tot
return|;
block|}
name|zin
operator|->
name|avail_in
operator|=
name|ret
expr_stmt|;
name|zin
operator|->
name|next_in
operator|=
name|ctx
operator|->
name|ibuf
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bio_zlib_write
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|int
name|inl
parameter_list|)
block|{
name|BIO_ZLIB_CTX
modifier|*
name|ctx
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|z_stream
modifier|*
name|zout
decl_stmt|;
if|if
condition|(
operator|!
name|in
operator|||
operator|!
name|inl
condition|)
return|return
literal|0
return|;
name|ctx
operator|=
operator|(
name|BIO_ZLIB_CTX
operator|*
operator|)
name|b
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|odone
condition|)
return|return
literal|0
return|;
name|zout
operator|=
operator|&
name|ctx
operator|->
name|zout
expr_stmt|;
name|BIO_clear_retry_flags
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|obuf
condition|)
block|{
name|ctx
operator|->
name|obuf
operator|=
name|OPENSSL_malloc
argument_list|(
name|ctx
operator|->
name|obufsize
argument_list|)
expr_stmt|;
comment|/* Need error here */
if|if
condition|(
operator|!
name|ctx
operator|->
name|obuf
condition|)
block|{
name|COMPerr
argument_list|(
name|COMP_F_BIO_ZLIB_WRITE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ctx
operator|->
name|optr
operator|=
name|ctx
operator|->
name|obuf
expr_stmt|;
name|ctx
operator|->
name|ocount
operator|=
literal|0
expr_stmt|;
name|deflateInit
argument_list|(
name|zout
argument_list|,
name|ctx
operator|->
name|comp_level
argument_list|)
expr_stmt|;
name|zout
operator|->
name|next_out
operator|=
name|ctx
operator|->
name|obuf
expr_stmt|;
name|zout
operator|->
name|avail_out
operator|=
name|ctx
operator|->
name|obufsize
expr_stmt|;
block|}
comment|/* Obtain input data directly from supplied buffer */
name|zout
operator|->
name|next_in
operator|=
operator|(
name|void
operator|*
operator|)
name|in
expr_stmt|;
name|zout
operator|->
name|avail_in
operator|=
name|inl
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If data in output buffer write it first */
while|while
condition|(
name|ctx
operator|->
name|ocount
condition|)
block|{
name|ret
operator|=
name|BIO_write
argument_list|(
name|b
operator|->
name|next_bio
argument_list|,
name|ctx
operator|->
name|optr
argument_list|,
name|ctx
operator|->
name|ocount
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
block|{
comment|/* Total data written */
name|int
name|tot
init|=
name|inl
operator|-
name|zout
operator|->
name|avail_in
decl_stmt|;
name|BIO_copy_next_retry
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|tot
operator|>
literal|0
operator|)
condition|?
name|tot
else|:
name|ret
return|;
return|return
name|tot
return|;
block|}
name|ctx
operator|->
name|optr
operator|+=
name|ret
expr_stmt|;
name|ctx
operator|->
name|ocount
operator|-=
name|ret
expr_stmt|;
block|}
comment|/* Have we consumed all supplied data? */
if|if
condition|(
operator|!
name|zout
operator|->
name|avail_in
condition|)
return|return
name|inl
return|;
comment|/* Compress some more */
comment|/* Reset buffer */
name|ctx
operator|->
name|optr
operator|=
name|ctx
operator|->
name|obuf
expr_stmt|;
name|zout
operator|->
name|next_out
operator|=
name|ctx
operator|->
name|obuf
expr_stmt|;
name|zout
operator|->
name|avail_out
operator|=
name|ctx
operator|->
name|obufsize
expr_stmt|;
comment|/* Compress some more */
name|ret
operator|=
name|deflate
argument_list|(
name|zout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
block|{
name|COMPerr
argument_list|(
name|COMP_F_BIO_ZLIB_WRITE
argument_list|,
name|COMP_R_ZLIB_DEFLATE_ERROR
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"zlib error:"
argument_list|,
name|zError
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ctx
operator|->
name|ocount
operator|=
name|ctx
operator|->
name|obufsize
operator|-
name|zout
operator|->
name|avail_out
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bio_zlib_flush
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|)
block|{
name|BIO_ZLIB_CTX
modifier|*
name|ctx
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|z_stream
modifier|*
name|zout
decl_stmt|;
name|ctx
operator|=
operator|(
name|BIO_ZLIB_CTX
operator|*
operator|)
name|b
operator|->
name|ptr
expr_stmt|;
comment|/* If no data written or already flush show success */
if|if
condition|(
operator|!
name|ctx
operator|->
name|obuf
operator|||
operator|(
name|ctx
operator|->
name|odone
operator|&&
operator|!
name|ctx
operator|->
name|ocount
operator|)
condition|)
return|return
literal|1
return|;
name|zout
operator|=
operator|&
name|ctx
operator|->
name|zout
expr_stmt|;
name|BIO_clear_retry_flags
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* No more input data */
name|zout
operator|->
name|next_in
operator|=
name|NULL
expr_stmt|;
name|zout
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If data in output buffer write it first */
while|while
condition|(
name|ctx
operator|->
name|ocount
condition|)
block|{
name|ret
operator|=
name|BIO_write
argument_list|(
name|b
operator|->
name|next_bio
argument_list|,
name|ctx
operator|->
name|optr
argument_list|,
name|ctx
operator|->
name|ocount
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
block|{
name|BIO_copy_next_retry
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ctx
operator|->
name|optr
operator|+=
name|ret
expr_stmt|;
name|ctx
operator|->
name|ocount
operator|-=
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|odone
condition|)
return|return
literal|1
return|;
comment|/* Compress some more */
comment|/* Reset buffer */
name|ctx
operator|->
name|optr
operator|=
name|ctx
operator|->
name|obuf
expr_stmt|;
name|zout
operator|->
name|next_out
operator|=
name|ctx
operator|->
name|obuf
expr_stmt|;
name|zout
operator|->
name|avail_out
operator|=
name|ctx
operator|->
name|obufsize
expr_stmt|;
comment|/* Compress some more */
name|ret
operator|=
name|deflate
argument_list|(
name|zout
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
name|ctx
operator|->
name|odone
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
block|{
name|COMPerr
argument_list|(
name|COMP_F_BIO_ZLIB_FLUSH
argument_list|,
name|COMP_R_ZLIB_DEFLATE_ERROR
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"zlib error:"
argument_list|,
name|zError
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ctx
operator|->
name|ocount
operator|=
name|ctx
operator|->
name|obufsize
operator|-
name|zout
operator|->
name|avail_out
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|long
name|bio_zlib_ctrl
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|num
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|BIO_ZLIB_CTX
modifier|*
name|ctx
decl_stmt|;
name|int
name|ret
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
name|int
name|ibs
decl_stmt|,
name|obs
decl_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|next_bio
condition|)
return|return
literal|0
return|;
name|ctx
operator|=
operator|(
name|BIO_ZLIB_CTX
operator|*
operator|)
name|b
operator|->
name|ptr
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|BIO_CTRL_RESET
case|:
name|ctx
operator|->
name|ocount
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|odone
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BIO_CTRL_FLUSH
case|:
name|ret
operator|=
name|bio_zlib_flush
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
name|ret
operator|=
name|BIO_flush
argument_list|(
name|b
operator|->
name|next_bio
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_C_SET_BUFF_SIZE
case|:
name|ibs
operator|=
operator|-
literal|1
expr_stmt|;
name|obs
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|==
literal|0
condition|)
name|ibs
operator|=
operator|(
name|int
operator|)
name|num
expr_stmt|;
else|else
name|obs
operator|=
operator|(
name|int
operator|)
name|num
expr_stmt|;
block|}
else|else
block|{
name|ibs
operator|=
operator|(
name|int
operator|)
name|num
expr_stmt|;
name|obs
operator|=
name|ibs
expr_stmt|;
block|}
if|if
condition|(
name|ibs
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ibuf
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|ctx
operator|->
name|ibuf
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ibuf
operator|=
name|NULL
expr_stmt|;
block|}
name|ctx
operator|->
name|ibufsize
operator|=
name|ibs
expr_stmt|;
block|}
if|if
condition|(
name|obs
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|obuf
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|ctx
operator|->
name|obuf
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|obuf
operator|=
name|NULL
expr_stmt|;
block|}
name|ctx
operator|->
name|obufsize
operator|=
name|obs
expr_stmt|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BIO_C_DO_STATE_MACHINE
case|:
name|BIO_clear_retry_flags
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|ret
operator|=
name|BIO_ctrl
argument_list|(
name|b
operator|->
name|next_bio
argument_list|,
name|cmd
argument_list|,
name|num
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|BIO_copy_next_retry
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|BIO_ctrl
argument_list|(
name|b
operator|->
name|next_bio
argument_list|,
name|cmd
argument_list|,
name|num
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|bio_zlib_callback_ctrl
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
name|int
name|cmd
parameter_list|,
name|bio_info_cb
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|b
operator|->
name|next_bio
condition|)
return|return
literal|0
return|;
return|return
name|BIO_callback_ctrl
argument_list|(
name|b
operator|->
name|next_bio
argument_list|,
name|cmd
argument_list|,
name|fp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

