begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ssl/t1_lib.c */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *   * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *   * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from   *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *   * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/hmac.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ocsp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|"ssl_locl.h"
end_include

begin_decl_stmt
specifier|const
name|char
name|tls1_version_str
index|[]
init|=
literal|"TLSv1"
name|OPENSSL_VERSION_PTEXT
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
end_ifndef

begin_function_decl
specifier|static
name|int
name|tls_decrypt_ticket
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|tick
parameter_list|,
name|int
name|ticklen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sess_id
parameter_list|,
name|int
name|sesslen
parameter_list|,
name|SSL_SESSION
modifier|*
modifier|*
name|psess
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|SSL3_ENC_METHOD
name|TLSv1_enc_data
init|=
block|{
name|tls1_enc
block|,
name|tls1_mac
block|,
name|tls1_setup_key_block
block|,
name|tls1_generate_master_secret
block|,
name|tls1_change_cipher_state
block|,
name|tls1_final_finish_mac
block|,
name|TLS1_FINISH_MAC_LENGTH
block|,
name|tls1_cert_verify_mac
block|,
name|TLS_MD_CLIENT_FINISH_CONST
block|,
name|TLS_MD_CLIENT_FINISH_CONST_SIZE
block|,
name|TLS_MD_SERVER_FINISH_CONST
block|,
name|TLS_MD_SERVER_FINISH_CONST_SIZE
block|,
name|tls1_alert_code
block|,
name|tls1_export_keying_material
block|, 	}
decl_stmt|;
end_decl_stmt

begin_function
name|long
name|tls1_default_timeout
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 2 hours, the 24 hours mentioned in the TLSv1 spec 	 * is way too long for http, the cache would over fill */
return|return
operator|(
literal|60
operator|*
literal|60
operator|*
literal|2
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tls1_new
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ssl3_new
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|->
name|method
operator|->
name|ssl_clear
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tls1_free
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
if|if
condition|(
name|s
operator|->
name|tlsext_session_ticket
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|tlsext_session_ticket
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OPENSSL_NO_TLSEXT */
name|ssl3_free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tls1_clear
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|ssl3_clear
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|version
operator|=
name|s
operator|->
name|method
operator|->
name|version
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|nid_list
index|[]
init|=
block|{
name|NID_sect163k1
block|,
comment|/* sect163k1 (1) */
name|NID_sect163r1
block|,
comment|/* sect163r1 (2) */
name|NID_sect163r2
block|,
comment|/* sect163r2 (3) */
name|NID_sect193r1
block|,
comment|/* sect193r1 (4) */
name|NID_sect193r2
block|,
comment|/* sect193r2 (5) */
name|NID_sect233k1
block|,
comment|/* sect233k1 (6) */
name|NID_sect233r1
block|,
comment|/* sect233r1 (7) */
name|NID_sect239k1
block|,
comment|/* sect239k1 (8) */
name|NID_sect283k1
block|,
comment|/* sect283k1 (9) */
name|NID_sect283r1
block|,
comment|/* sect283r1 (10) */
name|NID_sect409k1
block|,
comment|/* sect409k1 (11) */
name|NID_sect409r1
block|,
comment|/* sect409r1 (12) */
name|NID_sect571k1
block|,
comment|/* sect571k1 (13) */
name|NID_sect571r1
block|,
comment|/* sect571r1 (14) */
name|NID_secp160k1
block|,
comment|/* secp160k1 (15) */
name|NID_secp160r1
block|,
comment|/* secp160r1 (16) */
name|NID_secp160r2
block|,
comment|/* secp160r2 (17) */
name|NID_secp192k1
block|,
comment|/* secp192k1 (18) */
name|NID_X9_62_prime192v1
block|,
comment|/* secp192r1 (19) */
name|NID_secp224k1
block|,
comment|/* secp224k1 (20) */
name|NID_secp224r1
block|,
comment|/* secp224r1 (21) */
name|NID_secp256k1
block|,
comment|/* secp256k1 (22) */
name|NID_X9_62_prime256v1
block|,
comment|/* secp256r1 (23) */
name|NID_secp384r1
block|,
comment|/* secp384r1 (24) */
name|NID_secp521r1
comment|/* secp521r1 (25) */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pref_list
index|[]
init|=
block|{
name|NID_sect571r1
block|,
comment|/* sect571r1 (14) */
name|NID_sect571k1
block|,
comment|/* sect571k1 (13) */
name|NID_secp521r1
block|,
comment|/* secp521r1 (25) */
name|NID_sect409k1
block|,
comment|/* sect409k1 (11) */
name|NID_sect409r1
block|,
comment|/* sect409r1 (12) */
name|NID_secp384r1
block|,
comment|/* secp384r1 (24) */
name|NID_sect283k1
block|,
comment|/* sect283k1 (9) */
name|NID_sect283r1
block|,
comment|/* sect283r1 (10) */
name|NID_secp256k1
block|,
comment|/* secp256k1 (22) */
name|NID_X9_62_prime256v1
block|,
comment|/* secp256r1 (23) */
name|NID_sect239k1
block|,
comment|/* sect239k1 (8) */
name|NID_sect233k1
block|,
comment|/* sect233k1 (6) */
name|NID_sect233r1
block|,
comment|/* sect233r1 (7) */
name|NID_secp224k1
block|,
comment|/* secp224k1 (20) */
name|NID_secp224r1
block|,
comment|/* secp224r1 (21) */
name|NID_sect193r1
block|,
comment|/* sect193r1 (4) */
name|NID_sect193r2
block|,
comment|/* sect193r2 (5) */
name|NID_secp192k1
block|,
comment|/* secp192k1 (18) */
name|NID_X9_62_prime192v1
block|,
comment|/* secp192r1 (19) */
name|NID_sect163k1
block|,
comment|/* sect163k1 (1) */
name|NID_sect163r1
block|,
comment|/* sect163r1 (2) */
name|NID_sect163r2
block|,
comment|/* sect163r2 (3) */
name|NID_secp160k1
block|,
comment|/* secp160k1 (15) */
name|NID_secp160r1
block|,
comment|/* secp160r1 (16) */
name|NID_secp160r2
block|,
comment|/* secp160r2 (17) */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|tls1_ec_curve_id2nid
parameter_list|(
name|int
name|curve_id
parameter_list|)
block|{
comment|/* ECC curves from draft-ietf-tls-ecc-12.txt (Oct. 17, 2005) */
if|if
condition|(
operator|(
name|curve_id
operator|<
literal|1
operator|)
operator|||
operator|(
operator|(
name|unsigned
name|int
operator|)
name|curve_id
operator|>
sizeof|sizeof
argument_list|(
name|nid_list
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|nid_list
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|nid_list
index|[
name|curve_id
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_function
name|int
name|tls1_ec_nid2curve_id
parameter_list|(
name|int
name|nid
parameter_list|)
block|{
comment|/* ECC curves from draft-ietf-tls-ecc-12.txt (Oct. 17, 2005) */
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
name|NID_sect163k1
case|:
comment|/* sect163k1 (1) */
return|return
literal|1
return|;
case|case
name|NID_sect163r1
case|:
comment|/* sect163r1 (2) */
return|return
literal|2
return|;
case|case
name|NID_sect163r2
case|:
comment|/* sect163r2 (3) */
return|return
literal|3
return|;
case|case
name|NID_sect193r1
case|:
comment|/* sect193r1 (4) */
return|return
literal|4
return|;
case|case
name|NID_sect193r2
case|:
comment|/* sect193r2 (5) */
return|return
literal|5
return|;
case|case
name|NID_sect233k1
case|:
comment|/* sect233k1 (6) */
return|return
literal|6
return|;
case|case
name|NID_sect233r1
case|:
comment|/* sect233r1 (7) */
return|return
literal|7
return|;
case|case
name|NID_sect239k1
case|:
comment|/* sect239k1 (8) */
return|return
literal|8
return|;
case|case
name|NID_sect283k1
case|:
comment|/* sect283k1 (9) */
return|return
literal|9
return|;
case|case
name|NID_sect283r1
case|:
comment|/* sect283r1 (10) */
return|return
literal|10
return|;
case|case
name|NID_sect409k1
case|:
comment|/* sect409k1 (11) */
return|return
literal|11
return|;
case|case
name|NID_sect409r1
case|:
comment|/* sect409r1 (12) */
return|return
literal|12
return|;
case|case
name|NID_sect571k1
case|:
comment|/* sect571k1 (13) */
return|return
literal|13
return|;
case|case
name|NID_sect571r1
case|:
comment|/* sect571r1 (14) */
return|return
literal|14
return|;
case|case
name|NID_secp160k1
case|:
comment|/* secp160k1 (15) */
return|return
literal|15
return|;
case|case
name|NID_secp160r1
case|:
comment|/* secp160r1 (16) */
return|return
literal|16
return|;
case|case
name|NID_secp160r2
case|:
comment|/* secp160r2 (17) */
return|return
literal|17
return|;
case|case
name|NID_secp192k1
case|:
comment|/* secp192k1 (18) */
return|return
literal|18
return|;
case|case
name|NID_X9_62_prime192v1
case|:
comment|/* secp192r1 (19) */
return|return
literal|19
return|;
case|case
name|NID_secp224k1
case|:
comment|/* secp224k1 (20) */
return|return
literal|20
return|;
case|case
name|NID_secp224r1
case|:
comment|/* secp224r1 (21) */
return|return
literal|21
return|;
case|case
name|NID_secp256k1
case|:
comment|/* secp256k1 (22) */
return|return
literal|22
return|;
case|case
name|NID_X9_62_prime256v1
case|:
comment|/* secp256r1 (23) */
return|return
literal|23
return|;
case|case
name|NID_secp384r1
case|:
comment|/* secp384r1 (24) */
return|return
literal|24
return|;
case|case
name|NID_secp521r1
case|:
comment|/* secp521r1 (25) */
return|return
literal|25
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL_NO_EC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
end_ifndef

begin_comment
comment|/* List of supported signature algorithms and hashes. Should make this  * customisable at some point, for now include everything we support.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_NO_RSA
end_ifdef

begin_define
define|#
directive|define
name|tlsext_sigalg_rsa
parameter_list|(
name|md
parameter_list|)
end_define

begin_comment
comment|/* */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|tlsext_sigalg_rsa
parameter_list|(
name|md
parameter_list|)
value|md, TLSEXT_signature_rsa,
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_NO_DSA
end_ifdef

begin_define
define|#
directive|define
name|tlsext_sigalg_dsa
parameter_list|(
name|md
parameter_list|)
end_define

begin_comment
comment|/* */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|tlsext_sigalg_dsa
parameter_list|(
name|md
parameter_list|)
value|md, TLSEXT_signature_dsa,
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_NO_ECDSA
end_ifdef

begin_define
define|#
directive|define
name|tlsext_sigalg_ecdsa
parameter_list|(
name|md
parameter_list|)
end_define

begin_comment
comment|/* */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|tlsext_sigalg_ecdsa
parameter_list|(
name|md
parameter_list|)
value|md, TLSEXT_signature_ecdsa,
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|tlsext_sigalg
parameter_list|(
name|md
parameter_list|)
define|\
value|tlsext_sigalg_rsa(md) \ 		tlsext_sigalg_dsa(md) \ 		tlsext_sigalg_ecdsa(md)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|tls12_sigalgs
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA512
name|tlsext_sigalg
argument_list|(
argument|TLSEXT_hash_sha512
argument_list|)
name|tlsext_sigalg
argument_list|(
argument|TLSEXT_hash_sha384
argument_list|)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA256
name|tlsext_sigalg
argument_list|(
argument|TLSEXT_hash_sha256
argument_list|)
name|tlsext_sigalg
argument_list|(
argument|TLSEXT_hash_sha224
argument_list|)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA
name|tlsext_sigalg
argument_list|(
argument|TLSEXT_hash_sha1
argument_list|)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_MD5
name|tlsext_sigalg_rsa
argument_list|(
argument|TLSEXT_hash_md5
argument_list|)
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|tls12_get_req_sig_algs
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
name|size_t
name|slen
init|=
sizeof|sizeof
argument_list|(
name|tls12_sigalgs
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
comment|/* If FIPS mode don't include MD5 which is last */
if|if
condition|(
name|FIPS_mode
argument_list|()
condition|)
name|slen
operator|-=
literal|2
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
condition|)
name|memcpy
argument_list|(
name|p
argument_list|,
name|tls12_sigalgs
argument_list|,
name|slen
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|slen
return|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
name|ssl_add_clienthello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
modifier|*
name|limit
parameter_list|)
block|{
name|int
name|extdatalen
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ret
init|=
name|p
decl_stmt|;
comment|/* don't add extensions for SSLv3 unless doing secure renegotiation */
if|if
condition|(
name|s
operator|->
name|client_version
operator|==
name|SSL3_VERSION
operator|&&
operator|!
name|s
operator|->
name|s3
operator|->
name|send_connection_binding
condition|)
return|return
name|p
return|;
name|ret
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
name|limit
condition|)
return|return
name|NULL
return|;
comment|/* this really never occurs, but ... */
if|if
condition|(
name|s
operator|->
name|tlsext_hostname
operator|!=
name|NULL
condition|)
block|{
comment|/* Add TLS extension servername to the Client Hello message */
name|unsigned
name|long
name|size_str
decl_stmt|;
name|long
name|lenmax
decl_stmt|;
comment|/* check for enough space. 		   4 for the servername type and entension length 		   2 for servernamelist length 		   1 for the hostname type 		   2 for hostname length 		   + hostname length  		*/
if|if
condition|(
operator|(
name|lenmax
operator|=
name|limit
operator|-
name|ret
operator|-
literal|9
operator|)
operator|<
literal|0
operator|||
operator|(
name|size_str
operator|=
name|strlen
argument_list|(
name|s
operator|->
name|tlsext_hostname
argument_list|)
operator|)
operator|>
operator|(
name|unsigned
name|long
operator|)
name|lenmax
condition|)
return|return
name|NULL
return|;
comment|/* extension type and length */
name|s2n
argument_list|(
name|TLSEXT_TYPE_server_name
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|size_str
operator|+
literal|5
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* length of servername list */
name|s2n
argument_list|(
name|size_str
operator|+
literal|3
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* hostname type, length and hostname */
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
operator|(
name|unsigned
name|char
operator|)
name|TLSEXT_NAMETYPE_host_name
expr_stmt|;
name|s2n
argument_list|(
name|size_str
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|s
operator|->
name|tlsext_hostname
argument_list|,
name|size_str
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|size_str
expr_stmt|;
block|}
comment|/* Add RI if renegotiating */
if|if
condition|(
name|s
operator|->
name|renegotiate
condition|)
block|{
name|int
name|el
decl_stmt|;
if|if
condition|(
operator|!
name|ssl_add_clienthello_renegotiate_ext
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|el
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|limit
operator|-
name|p
operator|-
literal|4
operator|-
name|el
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_renegotiate
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|el
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_add_clienthello_renegotiate_ext
argument_list|(
name|s
argument_list|,
name|ret
argument_list|,
operator|&
name|el
argument_list|,
name|el
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|+=
name|el
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRP
comment|/* Add SRP username if there is one */
if|if
condition|(
name|s
operator|->
name|srp_ctx
operator|.
name|login
operator|!=
name|NULL
condition|)
block|{
comment|/* Add TLS extension SRP username to the Client Hello message */
name|int
name|login_len
init|=
name|strlen
argument_list|(
name|s
operator|->
name|srp_ctx
operator|.
name|login
argument_list|)
decl_stmt|;
if|if
condition|(
name|login_len
operator|>
literal|255
operator|||
name|login_len
operator|==
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* check for enough space. 		   4 for the srp type type and entension length 		   1 for the srp user identity 		   + srp user identity length  		*/
if|if
condition|(
operator|(
name|limit
operator|-
name|ret
operator|-
literal|5
operator|-
name|login_len
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* fill in the extension */
name|s2n
argument_list|(
name|TLSEXT_TYPE_srp
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|login_len
operator|+
literal|1
argument_list|,
name|ret
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ret
operator|++
operator|)
operator|=
operator|(
name|unsigned
name|char
operator|)
name|login_len
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|s
operator|->
name|srp_ctx
operator|.
name|login
argument_list|,
name|login_len
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|login_len
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
if|if
condition|(
name|s
operator|->
name|tlsext_ecpointformatlist
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|version
operator|!=
name|DTLS1_VERSION
condition|)
block|{
comment|/* Add TLS extension ECPointFormats to the ClientHello message */
name|long
name|lenmax
decl_stmt|;
if|if
condition|(
operator|(
name|lenmax
operator|=
name|limit
operator|-
name|ret
operator|-
literal|5
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|s
operator|->
name|tlsext_ecpointformatlist_length
operator|>
operator|(
name|unsigned
name|long
operator|)
name|lenmax
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|s
operator|->
name|tlsext_ecpointformatlist_length
operator|>
literal|255
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|s2n
argument_list|(
name|TLSEXT_TYPE_ec_point_formats
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|s
operator|->
name|tlsext_ecpointformatlist_length
operator|+
literal|1
argument_list|,
name|ret
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
operator|(
name|unsigned
name|char
operator|)
name|s
operator|->
name|tlsext_ecpointformatlist_length
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|s
operator|->
name|tlsext_ecpointformatlist
argument_list|,
name|s
operator|->
name|tlsext_ecpointformatlist_length
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|s
operator|->
name|tlsext_ecpointformatlist_length
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|tlsext_ellipticcurvelist
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|version
operator|!=
name|DTLS1_VERSION
condition|)
block|{
comment|/* Add TLS extension EllipticCurves to the ClientHello message */
name|long
name|lenmax
decl_stmt|;
if|if
condition|(
operator|(
name|lenmax
operator|=
name|limit
operator|-
name|ret
operator|-
literal|6
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|s
operator|->
name|tlsext_ellipticcurvelist_length
operator|>
operator|(
name|unsigned
name|long
operator|)
name|lenmax
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|s
operator|->
name|tlsext_ellipticcurvelist_length
operator|>
literal|65532
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|s2n
argument_list|(
name|TLSEXT_TYPE_elliptic_curves
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|s
operator|->
name|tlsext_ellipticcurvelist_length
operator|+
literal|2
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* NB: draft-ietf-tls-ecc-12.txt uses a one-byte prefix for 		 * elliptic_curve_list, but the examples use two bytes. 		 * http://www1.ietf.org/mail-archive/web/tls/current/msg00538.html 		 * resolves this to two bytes. 		 */
name|s2n
argument_list|(
name|s
operator|->
name|tlsext_ellipticcurvelist_length
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|s
operator|->
name|tlsext_ellipticcurvelist
argument_list|,
name|s
operator|->
name|tlsext_ellipticcurvelist_length
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|s
operator|->
name|tlsext_ellipticcurvelist_length
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OPENSSL_NO_EC */
if|if
condition|(
operator|!
operator|(
name|SSL_get_options
argument_list|(
name|s
argument_list|)
operator|&
name|SSL_OP_NO_TICKET
operator|)
condition|)
block|{
name|int
name|ticklen
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|new_session
operator|&&
name|s
operator|->
name|session
operator|&&
name|s
operator|->
name|session
operator|->
name|tlsext_tick
condition|)
name|ticklen
operator|=
name|s
operator|->
name|session
operator|->
name|tlsext_ticklen
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|session
operator|&&
name|s
operator|->
name|tlsext_session_ticket
operator|&&
name|s
operator|->
name|tlsext_session_ticket
operator|->
name|data
condition|)
block|{
name|ticklen
operator|=
name|s
operator|->
name|tlsext_session_ticket
operator|->
name|length
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|tlsext_tick
operator|=
name|OPENSSL_malloc
argument_list|(
name|ticklen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|session
operator|->
name|tlsext_tick
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_tick
argument_list|,
name|s
operator|->
name|tlsext_session_ticket
operator|->
name|data
argument_list|,
name|ticklen
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|tlsext_ticklen
operator|=
name|ticklen
expr_stmt|;
block|}
else|else
name|ticklen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ticklen
operator|==
literal|0
operator|&&
name|s
operator|->
name|tlsext_session_ticket
operator|&&
name|s
operator|->
name|tlsext_session_ticket
operator|->
name|data
operator|==
name|NULL
condition|)
goto|goto
name|skip_ext
goto|;
comment|/* Check for enough room 2 for extension type, 2 for len  		 * rest for ticket   		 */
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|limit
operator|-
name|ret
operator|-
literal|4
operator|-
name|ticklen
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_session_ticket
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|ticklen
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ticklen
condition|)
block|{
name|memcpy
argument_list|(
name|ret
argument_list|,
name|s
operator|->
name|session
operator|->
name|tlsext_tick
argument_list|,
name|ticklen
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|ticklen
expr_stmt|;
block|}
block|}
name|skip_ext
label|:
if|if
condition|(
name|TLS1_get_client_version
argument_list|(
name|s
argument_list|)
operator|>=
name|TLS1_2_VERSION
condition|)
block|{
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|limit
operator|-
name|ret
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|tls12_sigalgs
argument_list|)
operator|+
literal|6
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_signature_algorithms
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
sizeof|sizeof
argument_list|(
name|tls12_sigalgs
argument_list|)
operator|+
literal|2
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
sizeof|sizeof
argument_list|(
name|tls12_sigalgs
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|tls12_sigalgs
argument_list|,
sizeof|sizeof
argument_list|(
name|tls12_sigalgs
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|+=
sizeof|sizeof
argument_list|(
name|tls12_sigalgs
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TLSEXT_TYPE_opaque_prf_input
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|version
operator|!=
name|DTLS1_VERSION
condition|)
block|{
name|size_t
name|col
init|=
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
decl_stmt|;
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|limit
operator|-
name|ret
operator|-
literal|6
operator|-
name|col
operator|<
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|col
operator|>
literal|0xFFFD
condition|)
comment|/* can't happen */
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_opaque_prf_input
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|col
operator|+
literal|2
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|col
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|col
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|tlsext_status_type
operator|==
name|TLSEXT_STATUSTYPE_ocsp
operator|&&
name|s
operator|->
name|version
operator|!=
name|DTLS1_VERSION
condition|)
block|{
name|int
name|i
decl_stmt|;
name|long
name|extlen
decl_stmt|,
name|idlen
decl_stmt|,
name|itmp
decl_stmt|;
name|OCSP_RESPID
modifier|*
name|id
decl_stmt|;
name|idlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_OCSP_RESPID_num
argument_list|(
name|s
operator|->
name|tlsext_ocsp_ids
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|=
name|sk_OCSP_RESPID_value
argument_list|(
name|s
operator|->
name|tlsext_ocsp_ids
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|itmp
operator|=
name|i2d_OCSP_RESPID
argument_list|(
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|itmp
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
name|idlen
operator|+=
name|itmp
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|tlsext_ocsp_exts
condition|)
block|{
name|extlen
operator|=
name|i2d_X509_EXTENSIONS
argument_list|(
name|s
operator|->
name|tlsext_ocsp_exts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|extlen
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
block|}
else|else
name|extlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|limit
operator|-
name|ret
operator|-
literal|7
operator|-
name|extlen
operator|-
name|idlen
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_status_request
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|extlen
operator|+
name|idlen
operator|>
literal|0xFFF0
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|extlen
operator|+
name|idlen
operator|+
literal|5
argument_list|,
name|ret
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
name|TLSEXT_STATUSTYPE_ocsp
expr_stmt|;
name|s2n
argument_list|(
name|idlen
argument_list|,
name|ret
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_OCSP_RESPID_num
argument_list|(
name|s
operator|->
name|tlsext_ocsp_ids
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* save position of id len */
name|unsigned
name|char
modifier|*
name|q
init|=
name|ret
decl_stmt|;
name|id
operator|=
name|sk_OCSP_RESPID_value
argument_list|(
name|s
operator|->
name|tlsext_ocsp_ids
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* skip over id len */
name|ret
operator|+=
literal|2
expr_stmt|;
name|itmp
operator|=
name|i2d_OCSP_RESPID
argument_list|(
name|id
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
comment|/* write id len */
name|s2n
argument_list|(
name|itmp
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
name|s2n
argument_list|(
name|extlen
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|extlen
operator|>
literal|0
condition|)
name|i2d_X509_EXTENSIONS
argument_list|(
name|s
operator|->
name|tlsext_ocsp_exts
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
comment|/* Add Heartbeat extension */
name|s2n
argument_list|(
name|TLSEXT_TYPE_heartbeat
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
literal|1
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Set mode: 	 * 1: peer may send requests 	 * 2: peer not allowed to send requests 	 */
if|if
condition|(
name|s
operator|->
name|tlsext_heartbeat
operator|&
name|SSL_TLSEXT_HB_DONT_RECV_REQUESTS
condition|)
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
expr_stmt|;
else|else
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
name|SSL_TLSEXT_HB_ENABLED
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|next_proto_select_cb
operator|&&
operator|!
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md_len
condition|)
block|{
comment|/* The client advertises an emtpy extension to indicate its 		 * support for Next Protocol Negotiation */
if|if
condition|(
name|limit
operator|-
name|ret
operator|-
literal|4
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_next_proto_neg
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRTP
if|if
condition|(
name|SSL_get_srtp_profiles
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|int
name|el
decl_stmt|;
name|ssl_add_clienthello_use_srtp_ext
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|el
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|limit
operator|-
name|p
operator|-
literal|4
operator|-
name|el
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_use_srtp
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|el
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl_add_clienthello_use_srtp_ext
argument_list|(
name|s
argument_list|,
name|ret
argument_list|,
operator|&
name|el
argument_list|,
name|el
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|+=
name|el
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|extdatalen
operator|=
name|ret
operator|-
name|p
operator|-
literal|2
operator|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
name|s2n
argument_list|(
name|extdatalen
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
name|ssl_add_serverhello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
modifier|*
name|limit
parameter_list|)
block|{
name|int
name|extdatalen
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ret
init|=
name|p
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
name|int
name|next_proto_neg_seen
decl_stmt|;
endif|#
directive|endif
comment|/* don't add extensions for SSLv3, unless doing secure renegotiation */
if|if
condition|(
name|s
operator|->
name|version
operator|==
name|SSL3_VERSION
operator|&&
operator|!
name|s
operator|->
name|s3
operator|->
name|send_connection_binding
condition|)
return|return
name|p
return|;
name|ret
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
name|limit
condition|)
return|return
name|NULL
return|;
comment|/* this really never occurs, but ... */
if|if
condition|(
operator|!
name|s
operator|->
name|hit
operator|&&
name|s
operator|->
name|servername_done
operator|==
literal|1
operator|&&
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|limit
operator|-
name|ret
operator|-
literal|4
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_server_name
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|send_connection_binding
condition|)
block|{
name|int
name|el
decl_stmt|;
if|if
condition|(
operator|!
name|ssl_add_serverhello_renegotiate_ext
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|el
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_SERVERHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|limit
operator|-
name|p
operator|-
literal|4
operator|-
name|el
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_renegotiate
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|el
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_add_serverhello_renegotiate_ext
argument_list|(
name|s
argument_list|,
name|ret
argument_list|,
operator|&
name|el
argument_list|,
name|el
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_SERVERHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|+=
name|el
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
if|if
condition|(
name|s
operator|->
name|tlsext_ecpointformatlist
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|version
operator|!=
name|DTLS1_VERSION
condition|)
block|{
comment|/* Add TLS extension ECPointFormats to the ServerHello message */
name|long
name|lenmax
decl_stmt|;
if|if
condition|(
operator|(
name|lenmax
operator|=
name|limit
operator|-
name|ret
operator|-
literal|5
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|s
operator|->
name|tlsext_ecpointformatlist_length
operator|>
operator|(
name|unsigned
name|long
operator|)
name|lenmax
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|s
operator|->
name|tlsext_ecpointformatlist_length
operator|>
literal|255
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_SERVERHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|s2n
argument_list|(
name|TLSEXT_TYPE_ec_point_formats
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|s
operator|->
name|tlsext_ecpointformatlist_length
operator|+
literal|1
argument_list|,
name|ret
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
operator|(
name|unsigned
name|char
operator|)
name|s
operator|->
name|tlsext_ecpointformatlist_length
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|s
operator|->
name|tlsext_ecpointformatlist
argument_list|,
name|s
operator|->
name|tlsext_ecpointformatlist_length
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|s
operator|->
name|tlsext_ecpointformatlist_length
expr_stmt|;
block|}
comment|/* Currently the server should not respond with a SupportedCurves extension */
endif|#
directive|endif
comment|/* OPENSSL_NO_EC */
if|if
condition|(
name|s
operator|->
name|tlsext_ticket_expected
operator|&&
operator|!
operator|(
name|SSL_get_options
argument_list|(
name|s
argument_list|)
operator|&
name|SSL_OP_NO_TICKET
operator|)
condition|)
block|{
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|limit
operator|-
name|ret
operator|-
literal|4
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_session_ticket
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|tlsext_status_expected
condition|)
block|{
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|limit
operator|-
name|ret
operator|-
literal|4
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_status_request
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TLSEXT_TYPE_opaque_prf_input
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|version
operator|!=
name|DTLS1_VERSION
condition|)
block|{
name|size_t
name|sol
init|=
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
decl_stmt|;
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|limit
operator|-
name|ret
operator|-
literal|6
operator|-
name|sol
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|sol
operator|>
literal|0xFFFD
condition|)
comment|/* can't happen */
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_opaque_prf_input
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|sol
operator|+
literal|2
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|sol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
argument_list|,
name|sol
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|sol
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRTP
if|if
condition|(
name|s
operator|->
name|srtp_profile
condition|)
block|{
name|int
name|el
decl_stmt|;
name|ssl_add_serverhello_use_srtp_ext
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|el
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|limit
operator|-
name|p
operator|-
literal|4
operator|-
name|el
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_use_srtp
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|el
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl_add_serverhello_use_srtp_ext
argument_list|(
name|s
argument_list|,
name|ret
argument_list|,
operator|&
name|el
argument_list|,
name|el
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_SERVERHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|+=
name|el
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|id
operator|&
literal|0xFFFF
operator|)
operator|==
literal|0x80
operator|||
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|id
operator|&
literal|0xFFFF
operator|)
operator|==
literal|0x81
operator|)
operator|&&
operator|(
name|SSL_get_options
argument_list|(
name|s
argument_list|)
operator|&
name|SSL_OP_CRYPTOPRO_TLSEXT_BUG
operator|)
condition|)
block|{
specifier|const
name|unsigned
name|char
name|cryptopro_ext
index|[
literal|36
index|]
init|=
block|{
literal|0xfd
block|,
literal|0xe8
block|,
comment|/*65000*/
literal|0x00
block|,
literal|0x20
block|,
comment|/*32 bytes length*/
literal|0x30
block|,
literal|0x1e
block|,
literal|0x30
block|,
literal|0x08
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x2a
block|,
literal|0x85
block|,
literal|0x03
block|,
literal|0x02
block|,
literal|0x02
block|,
literal|0x09
block|,
literal|0x30
block|,
literal|0x08
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x2a
block|,
literal|0x85
block|,
literal|0x03
block|,
literal|0x02
block|,
literal|0x02
block|,
literal|0x16
block|,
literal|0x30
block|,
literal|0x08
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x2a
block|,
literal|0x85
block|,
literal|0x03
block|,
literal|0x02
block|,
literal|0x02
block|,
literal|0x17
block|}
decl_stmt|;
if|if
condition|(
name|limit
operator|-
name|ret
operator|<
literal|36
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|cryptopro_ext
argument_list|,
literal|36
argument_list|)
expr_stmt|;
name|ret
operator|+=
literal|36
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
comment|/* Add Heartbeat extension if we've received one */
if|if
condition|(
name|s
operator|->
name|tlsext_heartbeat
operator|&
name|SSL_TLSEXT_HB_ENABLED
condition|)
block|{
name|s2n
argument_list|(
name|TLSEXT_TYPE_heartbeat
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
literal|1
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Set mode: 		 * 1: peer may send requests 		 * 2: peer not allowed to send requests 		 */
if|if
condition|(
name|s
operator|->
name|tlsext_heartbeat
operator|&
name|SSL_TLSEXT_HB_DONT_RECV_REQUESTS
condition|)
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
expr_stmt|;
else|else
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
name|SSL_TLSEXT_HB_ENABLED
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
name|next_proto_neg_seen
operator|=
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|next_proto_neg_seen
operator|&&
name|s
operator|->
name|ctx
operator|->
name|next_protos_advertised_cb
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|npa
decl_stmt|;
name|unsigned
name|int
name|npalen
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|s
operator|->
name|ctx
operator|->
name|next_protos_advertised_cb
argument_list|(
name|s
argument_list|,
operator|&
name|npa
argument_list|,
operator|&
name|npalen
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|next_protos_advertised_cb_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|SSL_TLSEXT_ERR_OK
condition|)
block|{
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|limit
operator|-
name|ret
operator|-
literal|4
operator|-
name|npalen
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_next_proto_neg
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|npalen
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|npa
argument_list|,
name|npalen
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|npalen
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|extdatalen
operator|=
name|ret
operator|-
name|p
operator|-
literal|2
operator|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
name|s2n
argument_list|(
name|extdatalen
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ssl_parse_clienthello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
modifier|*
name|d
parameter_list|,
name|int
name|n
parameter_list|,
name|int
modifier|*
name|al
parameter_list|)
block|{
name|unsigned
name|short
name|type
decl_stmt|;
name|unsigned
name|short
name|size
decl_stmt|;
name|unsigned
name|short
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
init|=
operator|*
name|p
decl_stmt|;
name|int
name|renegotiate_seen
init|=
literal|0
decl_stmt|;
name|int
name|sigalg_seen
init|=
literal|0
decl_stmt|;
name|s
operator|->
name|servername_done
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|tlsext_status_type
operator|=
operator|-
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
name|s
operator|->
name|tlsext_heartbeat
operator|&=
operator|~
operator|(
name|SSL_TLSEXT_HB_ENABLED
operator||
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|data
operator|>=
operator|(
name|d
operator|+
name|n
operator|-
literal|2
operator|)
condition|)
goto|goto
name|ri_check
goto|;
name|n2s
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|>
operator|(
name|d
operator|+
name|n
operator|-
name|len
operator|)
condition|)
goto|goto
name|ri_check
goto|;
while|while
condition|(
name|data
operator|<=
operator|(
name|d
operator|+
name|n
operator|-
literal|4
operator|)
condition|)
block|{
name|n2s
argument_list|(
name|data
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|n2s
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|+
name|size
operator|>
operator|(
name|d
operator|+
name|n
operator|)
condition|)
goto|goto
name|ri_check
goto|;
if|#
directive|if
literal|0
block|fprintf(stderr,"Received extension type %d size %d\n",type,size);
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|tlsext_debug_cb
condition|)
name|s
operator|->
name|tlsext_debug_cb
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|s
operator|->
name|tlsext_debug_arg
argument_list|)
expr_stmt|;
comment|/* The servername extension is treated as follows:     - Only the hostname type is supported with a maximum length of 255.    - The servername is rejected if too long or if it contains zeros,      in which case an fatal alert is generated.    - The servername field is maintained together with the session cache.    - When a session is resumed, the servername call back invoked in order      to allow the application to position itself to the right context.     - The servername is acknowledged if it is new for a session or when       it is identical to a previously used for the same session.       Applications can control the behaviour.  They can at any time      set a 'desirable' servername for a new SSL object. This can be the      case for example with HTTPS when a Host: header field is received and      a renegotiation is requested. In this case, a possible servername      presented in the new client hello is only acknowledged if it matches      the value of the Host: field.     - Applications must  use SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION      if they provide for changing an explicit servername context for the session,      i.e. when the session has been established with a servername extension.     - On session reconnect, the servername extension may be absent.   */
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_server_name
condition|)
block|{
name|unsigned
name|char
modifier|*
name|sdata
decl_stmt|;
name|int
name|servname_type
decl_stmt|;
name|int
name|dsize
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|2
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|n2s
argument_list|(
name|data
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|size
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|dsize
operator|>
name|size
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sdata
operator|=
name|data
expr_stmt|;
while|while
condition|(
name|dsize
operator|>
literal|3
condition|)
block|{
name|servname_type
operator|=
operator|*
operator|(
name|sdata
operator|++
operator|)
expr_stmt|;
name|n2s
argument_list|(
name|sdata
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dsize
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|dsize
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|s
operator|->
name|servername_done
operator|==
literal|0
condition|)
switch|switch
condition|(
name|servname_type
condition|)
block|{
case|case
name|TLSEXT_NAMETYPE_host_name
case|:
if|if
condition|(
operator|!
name|s
operator|->
name|hit
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|len
operator|>
name|TLSEXT_MAXLEN_host_name
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_UNRECOGNIZED_NAME
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
argument_list|,
name|sdata
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
argument_list|)
operator|!=
name|len
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
operator|=
name|NULL
expr_stmt|;
operator|*
name|al
operator|=
name|TLS1_AD_UNRECOGNIZED_NAME
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|->
name|servername_done
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|s
operator|->
name|servername_done
operator|=
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
operator|&&
name|strlen
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
argument_list|)
operator|==
name|len
operator|&&
name|strncmp
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sdata
argument_list|,
name|len
argument_list|)
operator|==
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|dsize
operator|-=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|dsize
operator|!=
literal|0
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRP
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_srp
condition|)
block|{
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
operator|(
operator|(
name|len
operator|=
name|data
index|[
literal|0
index|]
operator|)
operator|)
operator|!=
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|s
operator|->
name|srp_ctx
operator|.
name|login
operator|!=
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|srp_ctx
operator|.
name|login
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|s
operator|->
name|srp_ctx
operator|.
name|login
argument_list|,
operator|&
name|data
index|[
literal|1
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|->
name|srp_ctx
operator|.
name|login
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s
operator|->
name|srp_ctx
operator|.
name|login
argument_list|)
operator|!=
name|len
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_ec_point_formats
operator|&&
name|s
operator|->
name|version
operator|!=
name|DTLS1_VERSION
condition|)
block|{
name|unsigned
name|char
modifier|*
name|sdata
init|=
name|data
decl_stmt|;
name|int
name|ecpointformatlist_length
init|=
operator|*
operator|(
name|sdata
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|ecpointformatlist_length
operator|!=
name|size
operator|-
literal|1
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|hit
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
operator|=
name|NULL
expr_stmt|;
block|}
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
operator|=
name|OPENSSL_malloc
argument_list|(
name|ecpointformatlist_length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist_length
operator|=
name|ecpointformatlist_length
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
argument_list|,
name|sdata
argument_list|,
name|ecpointformatlist_length
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|fprintf(stderr,"ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) ", s->session->tlsext_ecpointformatlist_length); 			sdata = s->session->tlsext_ecpointformatlist; 			for (i = 0; i< s->session->tlsext_ecpointformatlist_length; i++) 				fprintf(stderr,"%i ",*(sdata++)); 			fprintf(stderr,"\n");
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_elliptic_curves
operator|&&
name|s
operator|->
name|version
operator|!=
name|DTLS1_VERSION
condition|)
block|{
name|unsigned
name|char
modifier|*
name|sdata
init|=
name|data
decl_stmt|;
name|int
name|ellipticcurvelist_length
init|=
operator|(
operator|*
operator|(
name|sdata
operator|++
operator|)
operator|<<
literal|8
operator|)
decl_stmt|;
name|ellipticcurvelist_length
operator|+=
operator|(
operator|*
operator|(
name|sdata
operator|++
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ellipticcurvelist_length
operator|!=
name|size
operator|-
literal|2
operator|||
name|ellipticcurvelist_length
operator|<
literal|1
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|hit
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|tlsext_ellipticcurvelist
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|->
name|session
operator|->
name|tlsext_ellipticcurvelist_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|session
operator|->
name|tlsext_ellipticcurvelist
operator|=
name|OPENSSL_malloc
argument_list|(
name|ellipticcurvelist_length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|->
name|session
operator|->
name|tlsext_ellipticcurvelist_length
operator|=
name|ellipticcurvelist_length
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_ellipticcurvelist
argument_list|,
name|sdata
argument_list|,
name|ellipticcurvelist_length
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|fprintf(stderr,"ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) ", s->session->tlsext_ellipticcurvelist_length); 			sdata = s->session->tlsext_ellipticcurvelist; 			for (i = 0; i< s->session->tlsext_ellipticcurvelist_length; i++) 				fprintf(stderr,"%i ",*(sdata++)); 			fprintf(stderr,"\n");
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* OPENSSL_NO_EC */
ifdef|#
directive|ifdef
name|TLSEXT_TYPE_opaque_prf_input
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_opaque_prf_input
operator|&&
name|s
operator|->
name|version
operator|!=
name|DTLS1_VERSION
condition|)
block|{
name|unsigned
name|char
modifier|*
name|sdata
init|=
name|data
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|2
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|n2s
argument_list|(
name|sdata
argument_list|,
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
operator|!=
name|size
operator|-
literal|2
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|!=
name|NULL
condition|)
comment|/* shouldn't really happen */
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
operator|==
literal|0
condition|)
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|=
name|OPENSSL_malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* dummy byte just to get non-NULL */
else|else
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|=
name|BUF_memdup
argument_list|(
name|sdata
argument_list|,
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_session_ticket
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|tls_session_ticket_ext_cb
operator|&&
operator|!
name|s
operator|->
name|tls_session_ticket_ext_cb
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|s
operator|->
name|tls_session_ticket_ext_cb_arg
argument_list|)
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_renegotiate
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_parse_clienthello_renegotiate_ext
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|al
argument_list|)
condition|)
return|return
literal|0
return|;
name|renegotiate_seen
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_signature_algorithms
condition|)
block|{
name|int
name|dsize
decl_stmt|;
if|if
condition|(
name|sigalg_seen
operator|||
name|size
operator|<
literal|2
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sigalg_seen
operator|=
literal|1
expr_stmt|;
name|n2s
argument_list|(
name|data
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|size
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|dsize
operator|!=
name|size
operator|||
name|dsize
operator|&
literal|1
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|tls1_process_sigalgs
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|dsize
argument_list|)
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_status_request
operator|&&
name|s
operator|->
name|version
operator|!=
name|DTLS1_VERSION
operator|&&
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_cb
condition|)
block|{
if|if
condition|(
name|size
operator|<
literal|5
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|->
name|tlsext_status_type
operator|=
operator|*
name|data
operator|++
expr_stmt|;
name|size
operator|--
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|tlsext_status_type
operator|==
name|TLSEXT_STATUSTYPE_ocsp
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|sdata
decl_stmt|;
name|int
name|dsize
decl_stmt|;
comment|/* Read in responder_id_list */
name|n2s
argument_list|(
name|data
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|size
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|dsize
operator|>
name|size
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|dsize
operator|>
literal|0
condition|)
block|{
name|OCSP_RESPID
modifier|*
name|id
decl_stmt|;
name|int
name|idsize
decl_stmt|;
if|if
condition|(
name|dsize
operator|<
literal|4
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|n2s
argument_list|(
name|data
argument_list|,
name|idsize
argument_list|)
expr_stmt|;
name|dsize
operator|-=
literal|2
operator|+
name|idsize
expr_stmt|;
name|size
operator|-=
literal|2
operator|+
name|idsize
expr_stmt|;
if|if
condition|(
name|dsize
operator|<
literal|0
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sdata
operator|=
name|data
expr_stmt|;
name|data
operator|+=
name|idsize
expr_stmt|;
name|id
operator|=
name|d2i_OCSP_RESPID
argument_list|(
name|NULL
argument_list|,
operator|&
name|sdata
argument_list|,
name|idsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|id
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|data
operator|!=
name|sdata
condition|)
block|{
name|OCSP_RESPID_free
argument_list|(
name|id
argument_list|)
expr_stmt|;
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|tlsext_ocsp_ids
operator|&&
operator|!
operator|(
name|s
operator|->
name|tlsext_ocsp_ids
operator|=
name|sk_OCSP_RESPID_new_null
argument_list|()
operator|)
condition|)
block|{
name|OCSP_RESPID_free
argument_list|(
name|id
argument_list|)
expr_stmt|;
operator|*
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|sk_OCSP_RESPID_push
argument_list|(
name|s
operator|->
name|tlsext_ocsp_ids
argument_list|,
name|id
argument_list|)
condition|)
block|{
name|OCSP_RESPID_free
argument_list|(
name|id
argument_list|)
expr_stmt|;
operator|*
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Read in request_extensions */
if|if
condition|(
name|size
operator|<
literal|2
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|n2s
argument_list|(
name|data
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|size
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|dsize
operator|!=
name|size
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sdata
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|dsize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|tlsext_ocsp_exts
condition|)
block|{
name|sk_X509_EXTENSION_pop_free
argument_list|(
name|s
operator|->
name|tlsext_ocsp_exts
argument_list|,
name|X509_EXTENSION_free
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|tlsext_ocsp_exts
operator|=
name|d2i_X509_EXTENSIONS
argument_list|(
name|NULL
argument_list|,
operator|&
name|sdata
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|tlsext_ocsp_exts
operator|||
operator|(
name|data
operator|+
name|dsize
operator|!=
name|sdata
operator|)
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/* We don't know what to do with any other type  			 	* so ignore it.  			 	*/
else|else
name|s
operator|->
name|tlsext_status_type
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_heartbeat
condition|)
block|{
switch|switch
condition|(
name|data
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0x01
case|:
comment|/* Client allows us to send HB requests */
name|s
operator|->
name|tlsext_heartbeat
operator||=
name|SSL_TLSEXT_HB_ENABLED
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
comment|/* Client doesn't accept HB requests */
name|s
operator|->
name|tlsext_heartbeat
operator||=
name|SSL_TLSEXT_HB_ENABLED
expr_stmt|;
name|s
operator|->
name|tlsext_heartbeat
operator||=
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
expr_stmt|;
break|break;
default|default:
operator|*
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_next_proto_neg
operator|&&
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md_len
operator|==
literal|0
condition|)
block|{
comment|/* We shouldn't accept this extension on a 			 * renegotiation. 			 * 			 * s->new_session will be set on renegotiation, but we 			 * probably shouldn't rely that it couldn't be set on 			 * the initial renegotation too in certain cases (when 			 * there's some other reason to disallow resuming an 			 * earlier session -- the current code won't be doing 			 * anything like that, but this might change).  			 * A valid sign that there's been a previous handshake 			 * in this connection is if s->s3->tmp.finish_md_len> 			 * 0.  (We are talking about a check that will happen 			 * in the Hello protocol round, well before a new 			 * Finished message could have been computed.) */
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* session ticket processed earlier */
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRTP
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_use_srtp
condition|)
block|{
if|if
condition|(
name|ssl_parse_clienthello_use_srtp_ext
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|al
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|data
operator|+=
name|size
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|data
expr_stmt|;
name|ri_check
label|:
comment|/* Need RI if renegotiating */
if|if
condition|(
operator|!
name|renegotiate_seen
operator|&&
name|s
operator|->
name|renegotiate
operator|&&
operator|!
operator|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
operator|)
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_HANDSHAKE_FAILURE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT
argument_list|,
name|SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
end_ifndef

begin_comment
comment|/* ssl_next_proto_validate validates a Next Protocol Negotiation block. No  * elements of zero length are allowed and the set of elements must exactly fill  * the length of the block. */
end_comment

begin_function
specifier|static
name|char
name|ssl_next_proto_validate
parameter_list|(
name|unsigned
name|char
modifier|*
name|d
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|off
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|off
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|d
index|[
name|off
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|off
operator|+=
name|d
index|[
name|off
index|]
expr_stmt|;
name|off
operator|++
expr_stmt|;
block|}
return|return
name|off
operator|==
name|len
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ssl_parse_serverhello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
modifier|*
name|d
parameter_list|,
name|int
name|n
parameter_list|,
name|int
modifier|*
name|al
parameter_list|)
block|{
name|unsigned
name|short
name|length
decl_stmt|;
name|unsigned
name|short
name|type
decl_stmt|;
name|unsigned
name|short
name|size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
init|=
operator|*
name|p
decl_stmt|;
name|int
name|tlsext_servername
init|=
literal|0
decl_stmt|;
name|int
name|renegotiate_seen
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
name|s
operator|->
name|tlsext_heartbeat
operator|&=
operator|~
operator|(
name|SSL_TLSEXT_HB_ENABLED
operator||
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|data
operator|>=
operator|(
name|d
operator|+
name|n
operator|-
literal|2
operator|)
condition|)
goto|goto
name|ri_check
goto|;
name|n2s
argument_list|(
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|+
name|length
operator|!=
name|d
operator|+
name|n
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|data
operator|<=
operator|(
name|d
operator|+
name|n
operator|-
literal|4
operator|)
condition|)
block|{
name|n2s
argument_list|(
name|data
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|n2s
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|+
name|size
operator|>
operator|(
name|d
operator|+
name|n
operator|)
condition|)
goto|goto
name|ri_check
goto|;
if|if
condition|(
name|s
operator|->
name|tlsext_debug_cb
condition|)
name|s
operator|->
name|tlsext_debug_cb
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
name|type
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|s
operator|->
name|tlsext_debug_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_server_name
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|tlsext_hostname
operator|==
name|NULL
operator|||
name|size
operator|>
literal|0
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_UNRECOGNIZED_NAME
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tlsext_servername
operator|=
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_ec_point_formats
operator|&&
name|s
operator|->
name|version
operator|!=
name|DTLS1_VERSION
condition|)
block|{
name|unsigned
name|char
modifier|*
name|sdata
init|=
name|data
decl_stmt|;
name|int
name|ecpointformatlist_length
init|=
operator|*
operator|(
name|sdata
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|ecpointformatlist_length
operator|!=
name|size
operator|-
literal|1
operator|||
name|ecpointformatlist_length
operator|<
literal|1
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|hit
condition|)
block|{
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
operator|=
name|OPENSSL_malloc
argument_list|(
name|ecpointformatlist_length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist_length
operator|=
name|ecpointformatlist_length
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
argument_list|,
name|sdata
argument_list|,
name|ecpointformatlist_length
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|fprintf(stderr,"ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist "); 			sdata = s->session->tlsext_ecpointformatlist; 			for (i = 0; i< s->session->tlsext_ecpointformatlist_length; i++) 				fprintf(stderr,"%i ",*(sdata++)); 			fprintf(stderr,"\n");
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* OPENSSL_NO_EC */
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_session_ticket
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|tls_session_ticket_ext_cb
operator|&&
operator|!
name|s
operator|->
name|tls_session_ticket_ext_cb
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|s
operator|->
name|tls_session_ticket_ext_cb_arg
argument_list|)
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|SSL_get_options
argument_list|(
name|s
argument_list|)
operator|&
name|SSL_OP_NO_TICKET
operator|)
operator|||
operator|(
name|size
operator|>
literal|0
operator|)
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_UNSUPPORTED_EXTENSION
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|->
name|tlsext_ticket_expected
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TLSEXT_TYPE_opaque_prf_input
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_opaque_prf_input
operator|&&
name|s
operator|->
name|version
operator|!=
name|DTLS1_VERSION
condition|)
block|{
name|unsigned
name|char
modifier|*
name|sdata
init|=
name|data
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|2
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|n2s
argument_list|(
name|sdata
argument_list|,
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
operator|!=
name|size
operator|-
literal|2
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|!=
name|NULL
condition|)
comment|/* shouldn't really happen */
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
operator|==
literal|0
condition|)
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|=
name|OPENSSL_malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* dummy byte just to get non-NULL */
else|else
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|=
name|BUF_memdup
argument_list|(
name|sdata
argument_list|,
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_status_request
operator|&&
name|s
operator|->
name|version
operator|!=
name|DTLS1_VERSION
condition|)
block|{
comment|/* MUST be empty and only sent if we've requested 			 * a status request message. 			 */
if|if
condition|(
operator|(
name|s
operator|->
name|tlsext_status_type
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|size
operator|>
literal|0
operator|)
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_UNSUPPORTED_EXTENSION
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Set flag to expect CertificateStatus message */
name|s
operator|->
name|tlsext_status_expected
operator|=
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_next_proto_neg
operator|&&
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md_len
operator|==
literal|0
condition|)
block|{
name|unsigned
name|char
modifier|*
name|selected
decl_stmt|;
name|unsigned
name|char
name|selected_len
decl_stmt|;
comment|/* We must have requested it. */
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|next_proto_select_cb
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_UNSUPPORTED_EXTENSION
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* The data must be valid */
if|if
condition|(
operator|!
name|ssl_next_proto_validate
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|next_proto_select_cb
argument_list|(
name|s
argument_list|,
operator|&
name|selected
argument_list|,
operator|&
name|selected_len
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|next_proto_select_cb_arg
argument_list|)
operator|!=
name|SSL_TLSEXT_ERR_OK
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|->
name|next_proto_negotiated
operator|=
name|OPENSSL_malloc
argument_list|(
name|selected_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|next_proto_negotiated
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|s
operator|->
name|next_proto_negotiated
argument_list|,
name|selected
argument_list|,
name|selected_len
argument_list|)
expr_stmt|;
name|s
operator|->
name|next_proto_negotiated_len
operator|=
name|selected_len
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_renegotiate
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_parse_serverhello_renegotiate_ext
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|al
argument_list|)
condition|)
return|return
literal|0
return|;
name|renegotiate_seen
operator|=
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_heartbeat
condition|)
block|{
switch|switch
condition|(
name|data
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0x01
case|:
comment|/* Server allows us to send HB requests */
name|s
operator|->
name|tlsext_heartbeat
operator||=
name|SSL_TLSEXT_HB_ENABLED
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
comment|/* Server doesn't accept HB requests */
name|s
operator|->
name|tlsext_heartbeat
operator||=
name|SSL_TLSEXT_HB_ENABLED
expr_stmt|;
name|s
operator|->
name|tlsext_heartbeat
operator||=
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
expr_stmt|;
break|break;
default|default:
operator|*
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRTP
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_use_srtp
condition|)
block|{
if|if
condition|(
name|ssl_parse_serverhello_use_srtp_ext
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|al
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|data
operator|+=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|!=
name|d
operator|+
name|n
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|hit
operator|&&
name|tlsext_servername
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|tlsext_hostname
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
operator|==
name|NULL
condition|)
block|{
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
operator|=
name|BUF_strdup
argument_list|(
name|s
operator|->
name|tlsext_hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_UNRECOGNIZED_NAME
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
operator|*
name|p
operator|=
name|data
expr_stmt|;
name|ri_check
label|:
comment|/* Determine if we need to see RI. Strictly speaking if we want to 	 * avoid an attack we should *always* see RI even on initial server 	 * hello because the client doesn't see any renegotiation during an 	 * attack. However this would mean we could not connect to any server 	 * which doesn't support RI so for the immediate future tolerate RI 	 * absence on initial connect only. 	 */
if|if
condition|(
operator|!
name|renegotiate_seen
operator|&&
operator|!
operator|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_LEGACY_SERVER_CONNECT
operator|)
operator|&&
operator|!
operator|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
operator|)
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_HANDSHAKE_FAILURE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL_PARSE_SERVERHELLO_TLSEXT
argument_list|,
name|SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ssl_prepare_clienthello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
comment|/* If we are client and using an elliptic curve cryptography cipher suite, send the point formats  	 * and elliptic curves we support. 	 */
name|int
name|using_ecc
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|j
decl_stmt|;
name|unsigned
name|long
name|alg_k
decl_stmt|,
name|alg_a
decl_stmt|;
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|cipher_stack
operator|=
name|SSL_get_ciphers
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_SSL_CIPHER_num
argument_list|(
name|cipher_stack
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|SSL_CIPHER
modifier|*
name|c
init|=
name|sk_SSL_CIPHER_value
argument_list|(
name|cipher_stack
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|alg_k
operator|=
name|c
operator|->
name|algorithm_mkey
expr_stmt|;
name|alg_a
operator|=
name|c
operator|->
name|algorithm_auth
expr_stmt|;
if|if
condition|(
operator|(
name|alg_k
operator|&
operator|(
name|SSL_kEECDH
operator||
name|SSL_kECDHr
operator||
name|SSL_kECDHe
operator|)
operator|||
operator|(
name|alg_a
operator|&
name|SSL_aECDSA
operator|)
operator|)
condition|)
block|{
name|using_ecc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|using_ecc
operator|=
name|using_ecc
operator|&&
operator|(
name|s
operator|->
name|version
operator|>=
name|TLS1_VERSION
operator|)
expr_stmt|;
if|if
condition|(
name|using_ecc
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|tlsext_ecpointformatlist
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|tlsext_ecpointformatlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|tlsext_ecpointformatlist
operator|=
name|OPENSSL_malloc
argument_list|(
literal|3
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|s
operator|->
name|tlsext_ecpointformatlist_length
operator|=
literal|3
expr_stmt|;
name|s
operator|->
name|tlsext_ecpointformatlist
index|[
literal|0
index|]
operator|=
name|TLSEXT_ECPOINTFORMAT_uncompressed
expr_stmt|;
name|s
operator|->
name|tlsext_ecpointformatlist
index|[
literal|1
index|]
operator|=
name|TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime
expr_stmt|;
name|s
operator|->
name|tlsext_ecpointformatlist
index|[
literal|2
index|]
operator|=
name|TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2
expr_stmt|;
comment|/* we support all named elliptic curves in draft-ietf-tls-ecc-12 */
if|if
condition|(
name|s
operator|->
name|tlsext_ellipticcurvelist
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|tlsext_ellipticcurvelist
argument_list|)
expr_stmt|;
name|s
operator|->
name|tlsext_ellipticcurvelist_length
operator|=
sizeof|sizeof
argument_list|(
name|pref_list
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pref_list
index|[
literal|0
index|]
argument_list|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|tlsext_ellipticcurvelist
operator|=
name|OPENSSL_malloc
argument_list|(
name|s
operator|->
name|tlsext_ellipticcurvelist_length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|->
name|tlsext_ellipticcurvelist_length
operator|=
literal|0
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|s
operator|->
name|tlsext_ellipticcurvelist
init|;
operator|(
name|unsigned
name|int
operator|)
name|i
operator|<
sizeof|sizeof
argument_list|(
name|pref_list
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pref_list
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|id
init|=
name|tls1_ec_nid2curve_id
argument_list|(
name|pref_list
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|s2n
argument_list|(
name|id
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* OPENSSL_NO_EC */
ifdef|#
directive|ifdef
name|TLSEXT_TYPE_opaque_prf_input
block|{
name|int
name|r
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|tlsext_opaque_prf_input_callback
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|s
operator|->
name|ctx
operator|->
name|tlsext_opaque_prf_input_callback
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|tlsext_opaque_prf_input_callback_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|s
operator|->
name|tlsext_opaque_prf_input
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|!=
name|NULL
condition|)
comment|/* shouldn't really happen */
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|tlsext_opaque_prf_input_len
operator|==
literal|0
condition|)
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|=
name|OPENSSL_malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* dummy byte just to get non-NULL */
else|else
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|=
name|BUF_memdup
argument_list|(
name|s
operator|->
name|tlsext_opaque_prf_input
argument_list|,
name|s
operator|->
name|tlsext_opaque_prf_input_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
operator|=
name|s
operator|->
name|tlsext_opaque_prf_input_len
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
literal|2
condition|)
comment|/* at callback's request, insist on receiving an appropriate server opaque PRF input */
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
operator|=
name|s
operator|->
name|tlsext_opaque_prf_input_len
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ssl_prepare_serverhello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
comment|/* If we are server and using an ECC cipher suite, send the point formats we support  	 * if the client sent us an ECPointsFormat extension.  Note that the server is not 	 * supposed to send an EllipticCurves extension. 	 */
name|unsigned
name|long
name|alg_k
init|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_mkey
decl_stmt|;
name|unsigned
name|long
name|alg_a
init|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_auth
decl_stmt|;
name|int
name|using_ecc
init|=
operator|(
name|alg_k
operator|&
operator|(
name|SSL_kEECDH
operator||
name|SSL_kECDHr
operator||
name|SSL_kECDHe
operator|)
operator|)
operator|||
operator|(
name|alg_a
operator|&
name|SSL_aECDSA
operator|)
decl_stmt|;
name|using_ecc
operator|=
name|using_ecc
operator|&&
operator|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|using_ecc
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|tlsext_ecpointformatlist
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|tlsext_ecpointformatlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|tlsext_ecpointformatlist
operator|=
name|OPENSSL_malloc
argument_list|(
literal|3
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_PREPARE_SERVERHELLO_TLSEXT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|s
operator|->
name|tlsext_ecpointformatlist_length
operator|=
literal|3
expr_stmt|;
name|s
operator|->
name|tlsext_ecpointformatlist
index|[
literal|0
index|]
operator|=
name|TLSEXT_ECPOINTFORMAT_uncompressed
expr_stmt|;
name|s
operator|->
name|tlsext_ecpointformatlist
index|[
literal|1
index|]
operator|=
name|TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime
expr_stmt|;
name|s
operator|->
name|tlsext_ecpointformatlist
index|[
literal|2
index|]
operator|=
name|TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OPENSSL_NO_EC */
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ssl_check_clienthello_tlsext_early
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|ret
init|=
name|SSL_TLSEXT_ERR_NOACK
decl_stmt|;
name|int
name|al
init|=
name|SSL_AD_UNRECOGNIZED_NAME
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
comment|/* The handling of the ECPointFormats extension is done elsewhere, namely in  	 * ssl3_choose_cipher in s3_lib.c. 	 */
comment|/* The handling of the EllipticCurves extension is done elsewhere, namely in  	 * ssl3_choose_cipher in s3_lib.c. 	 */
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|ctx
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|ctx
operator|->
name|tlsext_servername_callback
operator|!=
literal|0
condition|)
name|ret
operator|=
name|s
operator|->
name|ctx
operator|->
name|tlsext_servername_callback
argument_list|(
name|s
argument_list|,
operator|&
name|al
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|tlsext_servername_arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|initial_ctx
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|initial_ctx
operator|->
name|tlsext_servername_callback
operator|!=
literal|0
condition|)
name|ret
operator|=
name|s
operator|->
name|initial_ctx
operator|->
name|tlsext_servername_callback
argument_list|(
name|s
argument_list|,
operator|&
name|al
argument_list|,
name|s
operator|->
name|initial_ctx
operator|->
name|tlsext_servername_arg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TLSEXT_TYPE_opaque_prf_input
block|{
comment|/* This sort of belongs into ssl_prepare_serverhello_tlsext(), 		 * but we might be sending an alert in response to the client hello, 		 * so this has to happen here in 		 * ssl_check_clienthello_tlsext_early(). */
name|int
name|r
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|tlsext_opaque_prf_input_callback
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|s
operator|->
name|ctx
operator|->
name|tlsext_opaque_prf_input_callback
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|tlsext_opaque_prf_input_callback_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|ret
operator|=
name|SSL_TLSEXT_ERR_ALERT_FATAL
expr_stmt|;
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|!=
name|NULL
condition|)
comment|/* shouldn't really happen */
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
argument_list|)
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|tlsext_opaque_prf_input
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
operator|==
name|s
operator|->
name|tlsext_opaque_prf_input_len
condition|)
block|{
comment|/* can only use this extension if we have a server opaque PRF input 				 * of the same length as the client opaque PRF input! */
if|if
condition|(
name|s
operator|->
name|tlsext_opaque_prf_input_len
operator|==
literal|0
condition|)
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|=
name|OPENSSL_malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* dummy byte just to get non-NULL */
else|else
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|=
name|BUF_memdup
argument_list|(
name|s
operator|->
name|tlsext_opaque_prf_input
argument_list|,
name|s
operator|->
name|tlsext_opaque_prf_input_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSL_TLSEXT_ERR_ALERT_FATAL
expr_stmt|;
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
operator|=
name|s
operator|->
name|tlsext_opaque_prf_input_len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|==
literal|2
operator|&&
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|==
name|NULL
condition|)
block|{
comment|/* The callback wants to enforce use of the extension, 			 * but we can't do that with the client opaque PRF input; 			 * abort the handshake. 			 */
name|ret
operator|=
name|SSL_TLSEXT_ERR_ALERT_FATAL
expr_stmt|;
name|al
operator|=
name|SSL_AD_HANDSHAKE_FAILURE
expr_stmt|;
block|}
block|}
name|err
label|:
endif|#
directive|endif
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|SSL_TLSEXT_ERR_ALERT_FATAL
case|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|SSL_TLSEXT_ERR_ALERT_WARNING
case|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_WARNING
argument_list|,
name|al
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SSL_TLSEXT_ERR_NOACK
case|:
name|s
operator|->
name|servername_done
operator|=
literal|0
expr_stmt|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
name|int
name|ssl_check_clienthello_tlsext_late
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|ret
init|=
name|SSL_TLSEXT_ERR_OK
decl_stmt|;
name|int
name|al
decl_stmt|;
comment|/* If status request then ask callback what to do.  	 * Note: this must be called after servername callbacks in case   	 * the certificate has changed, and must be called after the cipher 	 * has been chosen because this may influence which certificate is sent  	 */
if|if
condition|(
operator|(
name|s
operator|->
name|tlsext_status_type
operator|!=
operator|-
literal|1
operator|)
operator|&&
name|s
operator|->
name|ctx
operator|&&
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_cb
condition|)
block|{
name|int
name|r
decl_stmt|;
name|CERT_PKEY
modifier|*
name|certpkey
decl_stmt|;
name|certpkey
operator|=
name|ssl_get_server_send_pkey
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* If no certificate can't return certificate status */
if|if
condition|(
name|certpkey
operator|==
name|NULL
condition|)
block|{
name|s
operator|->
name|tlsext_status_expected
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Set current certificate to one we will use so 		 * SSL_get_certificate et al can pick it up. 		 */
name|s
operator|->
name|cert
operator|->
name|key
operator|=
name|certpkey
expr_stmt|;
name|r
operator|=
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_cb
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_arg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
comment|/* We don't want to send a status request response */
case|case
name|SSL_TLSEXT_ERR_NOACK
case|:
name|s
operator|->
name|tlsext_status_expected
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* status request response should be sent */
case|case
name|SSL_TLSEXT_ERR_OK
case|:
if|if
condition|(
name|s
operator|->
name|tlsext_ocsp_resp
condition|)
name|s
operator|->
name|tlsext_status_expected
operator|=
literal|1
expr_stmt|;
else|else
name|s
operator|->
name|tlsext_status_expected
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* something bad happened */
case|case
name|SSL_TLSEXT_ERR_ALERT_FATAL
case|:
name|ret
operator|=
name|SSL_TLSEXT_ERR_ALERT_FATAL
expr_stmt|;
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
else|else
name|s
operator|->
name|tlsext_status_expected
operator|=
literal|0
expr_stmt|;
name|err
label|:
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|SSL_TLSEXT_ERR_ALERT_FATAL
case|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|SSL_TLSEXT_ERR_ALERT_WARNING
case|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_WARNING
argument_list|,
name|al
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
name|int
name|ssl_check_serverhello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|ret
init|=
name|SSL_TLSEXT_ERR_NOACK
decl_stmt|;
name|int
name|al
init|=
name|SSL_AD_UNRECOGNIZED_NAME
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
comment|/* If we are client and using an elliptic curve cryptography cipher 	 * suite, then if server returns an EC point formats lists extension 	 * it must contain uncompressed. 	 */
name|unsigned
name|long
name|alg_k
init|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_mkey
decl_stmt|;
name|unsigned
name|long
name|alg_a
init|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_auth
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|tlsext_ecpointformatlist
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|s
operator|->
name|tlsext_ecpointformatlist_length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist_length
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|alg_k
operator|&
operator|(
name|SSL_kEECDH
operator||
name|SSL_kECDHr
operator||
name|SSL_kECDHe
operator|)
operator|)
operator|||
operator|(
name|alg_a
operator|&
name|SSL_aECDSA
operator|)
operator|)
condition|)
block|{
comment|/* we are using an ECC cipher */
name|size_t
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|list
decl_stmt|;
name|int
name|found_uncompressed
init|=
literal|0
decl_stmt|;
name|list
operator|=
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist_length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|list
operator|++
operator|)
operator|==
name|TLSEXT_ECPOINTFORMAT_uncompressed
condition|)
block|{
name|found_uncompressed
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found_uncompressed
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT
argument_list|,
name|SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|ret
operator|=
name|SSL_TLSEXT_ERR_OK
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL_NO_EC */
if|if
condition|(
name|s
operator|->
name|ctx
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|ctx
operator|->
name|tlsext_servername_callback
operator|!=
literal|0
condition|)
name|ret
operator|=
name|s
operator|->
name|ctx
operator|->
name|tlsext_servername_callback
argument_list|(
name|s
argument_list|,
operator|&
name|al
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|tlsext_servername_arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|initial_ctx
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|initial_ctx
operator|->
name|tlsext_servername_callback
operator|!=
literal|0
condition|)
name|ret
operator|=
name|s
operator|->
name|initial_ctx
operator|->
name|tlsext_servername_callback
argument_list|(
name|s
argument_list|,
operator|&
name|al
argument_list|,
name|s
operator|->
name|initial_ctx
operator|->
name|tlsext_servername_arg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TLSEXT_TYPE_opaque_prf_input
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
operator|>
literal|0
condition|)
block|{
comment|/* This case may indicate that we, as a client, want to insist on using opaque PRF inputs. 		 * So first verify that we really have a value from the server too. */
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSL_TLSEXT_ERR_ALERT_FATAL
expr_stmt|;
name|al
operator|=
name|SSL_AD_HANDSHAKE_FAILURE
expr_stmt|;
block|}
comment|/* Anytime the server *has* sent an opaque PRF input, we need to check 		 * that we have a client opaque PRF input of the same size. */
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|==
name|NULL
operator|||
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
operator|!=
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
condition|)
block|{
name|ret
operator|=
name|SSL_TLSEXT_ERR_ALERT_FATAL
expr_stmt|;
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* If we've requested certificate status and we wont get one  	 * tell the callback  	 */
if|if
condition|(
operator|(
name|s
operator|->
name|tlsext_status_type
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|!
operator|(
name|s
operator|->
name|tlsext_status_expected
operator|)
operator|&&
name|s
operator|->
name|ctx
operator|&&
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_cb
condition|)
block|{
name|int
name|r
decl_stmt|;
comment|/* Set resp to NULL, resplen to -1 so callback knows  		 * there is no response.  		 */
if|if
condition|(
name|s
operator|->
name|tlsext_ocsp_resp
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|tlsext_ocsp_resp
argument_list|)
expr_stmt|;
name|s
operator|->
name|tlsext_ocsp_resp
operator|=
name|NULL
expr_stmt|;
block|}
name|s
operator|->
name|tlsext_ocsp_resplen
operator|=
operator|-
literal|1
expr_stmt|;
name|r
operator|=
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_cb
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|al
operator|=
name|SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE
expr_stmt|;
name|ret
operator|=
name|SSL_TLSEXT_ERR_ALERT_FATAL
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
name|ret
operator|=
name|SSL_TLSEXT_ERR_ALERT_FATAL
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|SSL_TLSEXT_ERR_ALERT_FATAL
case|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|SSL_TLSEXT_ERR_ALERT_WARNING
case|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_WARNING
argument_list|,
name|al
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SSL_TLSEXT_ERR_NOACK
case|:
name|s
operator|->
name|servername_done
operator|=
literal|0
expr_stmt|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Since the server cache lookup is done early on in the processing of the  * ClientHello, and other operations depend on the result, we need to handle  * any TLS session ticket extension at the same time.  *  *   session_id: points at the session ID in the ClientHello. This code will  *       read past the end of this in order to parse out the session ticket  *       extension, if any.  *   len: the length of the session ID.  *   limit: a pointer to the first byte after the ClientHello.  *   ret: (output) on return, if a ticket was decrypted, then this is set to  *       point to the resulting session.  *  * If s->tls_session_secret_cb is set then we are expecting a pre-shared key  * ciphersuite, in which case we have no use for session tickets and one will  * never be decrypted, nor will s->tlsext_ticket_expected be set to 1.  *  * Returns:  *   -1: fatal error, either from parsing or decrypting the ticket.  *    0: no ticket was found (or was ignored, based on settings).  *    1: a zero length extension was found, indicating that the client supports  *       session tickets but doesn't currently have one to offer.  *    2: either s->tls_session_secret_cb was set, or a ticket was offered but  *       couldn't be decrypted because of a non-fatal error.  *    3: a ticket was successfully decrypted and *ret was set.  *  * Side effects:  *   Sets s->tlsext_ticket_expected to 1 if the server will have to issue  *   a new session ticket to the client because the client indicated support  *   (and s->tls_session_secret_cb is NULL) but the client either doesn't have  *   a session ticket or we couldn't use the one it gave us, or if  *   s->ctx->tlsext_ticket_key_cb asked to renew the client's ticket.  *   Otherwise, s->tlsext_ticket_expected is set to 0.  */
end_comment

begin_function
name|int
name|tls1_process_ticket
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|session_id
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|limit
parameter_list|,
name|SSL_SESSION
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
comment|/* Point after session ID in client hello */
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
name|session_id
operator|+
name|len
decl_stmt|;
name|unsigned
name|short
name|i
decl_stmt|;
operator|*
name|ret
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|tlsext_ticket_expected
operator|=
literal|0
expr_stmt|;
comment|/* If tickets disabled behave as if no ticket present 	 * to permit stateful resumption. 	 */
if|if
condition|(
name|SSL_get_options
argument_list|(
name|s
argument_list|)
operator|&
name|SSL_OP_NO_TICKET
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|s
operator|->
name|version
operator|<=
name|SSL3_VERSION
operator|)
operator|||
operator|!
name|limit
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Skip past DTLS cookie */
if|if
condition|(
name|s
operator|->
name|version
operator|==
name|DTLS1_VERSION
operator|||
name|s
operator|->
name|version
operator|==
name|DTLS1_BAD_VER
condition|)
block|{
name|i
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Skip past cipher list */
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Skip past compression algorithm list */
name|i
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|limit
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Now at start of extensions */
if|if
condition|(
operator|(
name|p
operator|+
literal|2
operator|)
operator|>=
name|limit
condition|)
return|return
literal|0
return|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|+
literal|4
operator|)
operator|<=
name|limit
condition|)
block|{
name|unsigned
name|short
name|type
decl_stmt|,
name|size
decl_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|size
operator|>
name|limit
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_session_ticket
condition|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/* The client will accept a ticket but doesn't 				 * currently have one. */
name|s
operator|->
name|tlsext_ticket_expected
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|s
operator|->
name|tls_session_secret_cb
condition|)
block|{
comment|/* Indicate that the ticket couldn't be 				 * decrypted rather than generating the session 				 * from ticket now, trigger abbreviated 				 * handshake based on external mechanism to 				 * calculate the master secret later. */
return|return
literal|2
return|;
block|}
name|r
operator|=
name|tls_decrypt_ticket
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|size
argument_list|,
name|session_id
argument_list|,
name|len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|2
case|:
comment|/* ticket couldn't be decrypted */
name|s
operator|->
name|tlsext_ticket_expected
operator|=
literal|1
expr_stmt|;
return|return
literal|2
return|;
case|case
literal|3
case|:
comment|/* ticket was decrypted */
return|return
name|r
return|;
case|case
literal|4
case|:
comment|/* ticket decrypted but need to renew */
name|s
operator|->
name|tlsext_ticket_expected
operator|=
literal|1
expr_stmt|;
return|return
literal|3
return|;
default|default:
comment|/* fatal error */
return|return
operator|-
literal|1
return|;
block|}
block|}
name|p
operator|+=
name|size
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* tls_decrypt_ticket attempts to decrypt a session ticket.  *  *   etick: points to the body of the session ticket extension.  *   eticklen: the length of the session tickets extenion.  *   sess_id: points at the session ID.  *   sesslen: the length of the session ID.  *   psess: (output) on return, if a ticket was decrypted, then this is set to  *       point to the resulting session.  *  * Returns:  *   -1: fatal error, either from parsing or decrypting the ticket.  *    2: the ticket couldn't be decrypted.  *    3: a ticket was successfully decrypted and *psess was set.  *    4: same as 3, but the ticket needs to be renewed.  */
end_comment

begin_function
specifier|static
name|int
name|tls_decrypt_ticket
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|etick
parameter_list|,
name|int
name|eticklen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sess_id
parameter_list|,
name|int
name|sesslen
parameter_list|,
name|SSL_SESSION
modifier|*
modifier|*
name|psess
parameter_list|)
block|{
name|SSL_SESSION
modifier|*
name|sess
decl_stmt|;
name|unsigned
name|char
modifier|*
name|sdec
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|slen
decl_stmt|,
name|mlen
decl_stmt|,
name|renew_ticket
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|tick_hmac
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
name|HMAC_CTX
name|hctx
decl_stmt|;
name|EVP_CIPHER_CTX
name|ctx
decl_stmt|;
name|SSL_CTX
modifier|*
name|tctx
init|=
name|s
operator|->
name|initial_ctx
decl_stmt|;
comment|/* Need at least keyname + iv + some encrypted data */
if|if
condition|(
name|eticklen
operator|<
literal|48
condition|)
return|return
literal|2
return|;
comment|/* Initialize session ticket encryption and HMAC contexts */
name|HMAC_CTX_init
argument_list|(
operator|&
name|hctx
argument_list|)
expr_stmt|;
name|EVP_CIPHER_CTX_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tctx
operator|->
name|tlsext_ticket_key_cb
condition|)
block|{
name|unsigned
name|char
modifier|*
name|nctick
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|etick
decl_stmt|;
name|int
name|rv
init|=
name|tctx
operator|->
name|tlsext_ticket_key_cb
argument_list|(
name|s
argument_list|,
name|nctick
argument_list|,
name|nctick
operator|+
literal|16
argument_list|,
operator|&
name|ctx
argument_list|,
operator|&
name|hctx
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|rv
operator|==
literal|2
condition|)
name|renew_ticket
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Check key name matches */
if|if
condition|(
name|memcmp
argument_list|(
name|etick
argument_list|,
name|tctx
operator|->
name|tlsext_tick_key_name
argument_list|,
literal|16
argument_list|)
condition|)
return|return
literal|2
return|;
name|HMAC_Init_ex
argument_list|(
operator|&
name|hctx
argument_list|,
name|tctx
operator|->
name|tlsext_tick_hmac_key
argument_list|,
literal|16
argument_list|,
name|tlsext_tick_md
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|EVP_DecryptInit_ex
argument_list|(
operator|&
name|ctx
argument_list|,
name|EVP_aes_128_cbc
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|tctx
operator|->
name|tlsext_tick_aes_key
argument_list|,
name|etick
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* Attempt to process session ticket, first conduct sanity and 	 * integrity checks on ticket. 	 */
name|mlen
operator|=
name|HMAC_size
argument_list|(
operator|&
name|hctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlen
operator|<
literal|0
condition|)
block|{
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|eticklen
operator|-=
name|mlen
expr_stmt|;
comment|/* Check HMAC of encrypted ticket */
name|HMAC_Update
argument_list|(
operator|&
name|hctx
argument_list|,
name|etick
argument_list|,
name|eticklen
argument_list|)
expr_stmt|;
name|HMAC_Final
argument_list|(
operator|&
name|hctx
argument_list|,
name|tick_hmac
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|HMAC_CTX_cleanup
argument_list|(
operator|&
name|hctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|CRYPTO_memcmp
argument_list|(
name|tick_hmac
argument_list|,
name|etick
operator|+
name|eticklen
argument_list|,
name|mlen
argument_list|)
condition|)
return|return
literal|2
return|;
comment|/* Attempt to decrypt session data */
comment|/* Move p after IV to start of encrypted ticket, update length */
name|p
operator|=
name|etick
operator|+
literal|16
operator|+
name|EVP_CIPHER_CTX_iv_length
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|eticklen
operator|-=
literal|16
operator|+
name|EVP_CIPHER_CTX_iv_length
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sdec
operator|=
name|OPENSSL_malloc
argument_list|(
name|eticklen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sdec
condition|)
block|{
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|EVP_DecryptUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|sdec
argument_list|,
operator|&
name|slen
argument_list|,
name|p
argument_list|,
name|eticklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_DecryptFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|sdec
operator|+
name|slen
argument_list|,
operator|&
name|mlen
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|2
return|;
name|slen
operator|+=
name|mlen
expr_stmt|;
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|p
operator|=
name|sdec
expr_stmt|;
name|sess
operator|=
name|d2i_SSL_SESSION
argument_list|(
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|sdec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sess
condition|)
block|{
comment|/* The session ID, if non-empty, is used by some clients to 		 * detect that the ticket has been accepted. So we copy it to 		 * the session structure. If it is empty set length to zero 		 * as required by standard. 		 */
if|if
condition|(
name|sesslen
condition|)
name|memcpy
argument_list|(
name|sess
operator|->
name|session_id
argument_list|,
name|sess_id
argument_list|,
name|sesslen
argument_list|)
expr_stmt|;
name|sess
operator|->
name|session_id_length
operator|=
name|sesslen
expr_stmt|;
operator|*
name|psess
operator|=
name|sess
expr_stmt|;
if|if
condition|(
name|renew_ticket
condition|)
return|return
literal|4
return|;
else|else
return|return
literal|3
return|;
block|}
name|ERR_clear_error
argument_list|()
expr_stmt|;
comment|/* For session parse failure, indicate that we need to send a new 	 * ticket. */
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Tables to translate from NIDs to TLS v1.2 ids */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|nid
decl_stmt|;
name|int
name|id
decl_stmt|;
block|}
name|tls12_lookup
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|tls12_lookup
name|tls12_md
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_MD5
block|{
name|NID_md5
block|,
name|TLSEXT_hash_md5
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA
block|{
name|NID_sha1
block|,
name|TLSEXT_hash_sha1
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA256
block|{
name|NID_sha224
block|,
name|TLSEXT_hash_sha224
block|}
block|,
block|{
name|NID_sha256
block|,
name|TLSEXT_hash_sha256
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA512
block|{
name|NID_sha384
block|,
name|TLSEXT_hash_sha384
block|}
block|,
block|{
name|NID_sha512
block|,
name|TLSEXT_hash_sha512
block|}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tls12_lookup
name|tls12_sig
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
block|{
name|EVP_PKEY_RSA
block|,
name|TLSEXT_signature_rsa
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
block|{
name|EVP_PKEY_DSA
block|,
name|TLSEXT_signature_dsa
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDSA
block|{
name|EVP_PKEY_EC
block|,
name|TLSEXT_signature_ecdsa
block|}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|tls12_find_id
parameter_list|(
name|int
name|nid
parameter_list|,
name|tls12_lookup
modifier|*
name|table
parameter_list|,
name|size_t
name|tlen
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tlen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|table
index|[
name|i
index|]
operator|.
name|nid
operator|==
name|nid
condition|)
return|return
name|table
index|[
name|i
index|]
operator|.
name|id
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int tls12_find_nid(int id, tls12_lookup *table, size_t tlen) 	{ 	size_t i; 	for (i = 0; i< tlen; i++) 		{ 		if (table[i].id == id) 			return table[i].nid; 		} 	return -1; 	}
endif|#
directive|endif
end_endif

begin_function
name|int
name|tls12_get_sigandhash
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|EVP_PKEY
modifier|*
name|pk
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
name|md
parameter_list|)
block|{
name|int
name|sig_id
decl_stmt|,
name|md_id
decl_stmt|;
if|if
condition|(
operator|!
name|md
condition|)
return|return
literal|0
return|;
name|md_id
operator|=
name|tls12_find_id
argument_list|(
name|EVP_MD_type
argument_list|(
name|md
argument_list|)
argument_list|,
name|tls12_md
argument_list|,
sizeof|sizeof
argument_list|(
name|tls12_md
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tls12_lookup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|md_id
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|sig_id
operator|=
name|tls12_get_sigid
argument_list|(
name|pk
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig_id
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|p
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|md_id
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|sig_id
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|tls12_get_sigid
parameter_list|(
specifier|const
name|EVP_PKEY
modifier|*
name|pk
parameter_list|)
block|{
return|return
name|tls12_find_id
argument_list|(
name|pk
operator|->
name|type
argument_list|,
name|tls12_sig
argument_list|,
sizeof|sizeof
argument_list|(
name|tls12_sig
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tls12_lookup
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|EVP_MD
modifier|*
name|tls12_get_hash
parameter_list|(
name|unsigned
name|char
name|hash_alg
parameter_list|)
block|{
switch|switch
condition|(
name|hash_alg
condition|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_MD5
case|case
name|TLSEXT_hash_md5
case|:
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
if|if
condition|(
name|FIPS_mode
argument_list|()
condition|)
return|return
name|NULL
return|;
endif|#
directive|endif
return|return
name|EVP_md5
argument_list|()
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA
case|case
name|TLSEXT_hash_sha1
case|:
return|return
name|EVP_sha1
argument_list|()
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA256
case|case
name|TLSEXT_hash_sha224
case|:
return|return
name|EVP_sha224
argument_list|()
return|;
case|case
name|TLSEXT_hash_sha256
case|:
return|return
name|EVP_sha256
argument_list|()
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA512
case|case
name|TLSEXT_hash_sha384
case|:
return|return
name|EVP_sha384
argument_list|()
return|;
case|case
name|TLSEXT_hash_sha512
case|:
return|return
name|EVP_sha512
argument_list|()
return|;
endif|#
directive|endif
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Set preferred digest for each key type */
end_comment

begin_function
name|int
name|tls1_process_sigalgs
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|dsize
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|;
specifier|const
name|EVP_MD
modifier|*
name|md
decl_stmt|;
name|CERT
modifier|*
name|c
init|=
name|s
operator|->
name|cert
decl_stmt|;
comment|/* Extension ignored for TLS versions below 1.2 */
if|if
condition|(
name|TLS1_get_version
argument_list|(
name|s
argument_list|)
operator|<
name|TLS1_2_VERSION
condition|)
return|return
literal|1
return|;
comment|/* Should never happen */
if|if
condition|(
operator|!
name|c
condition|)
return|return
literal|0
return|;
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_DSA_SIGN
index|]
operator|.
name|digest
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_SIGN
index|]
operator|.
name|digest
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|digest
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_ECC
index|]
operator|.
name|digest
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dsize
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|unsigned
name|char
name|hash_alg
init|=
name|data
index|[
name|i
index|]
decl_stmt|,
name|sig_alg
init|=
name|data
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|sig_alg
condition|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
case|case
name|TLSEXT_signature_rsa
case|:
name|idx
operator|=
name|SSL_PKEY_RSA_SIGN
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
case|case
name|TLSEXT_signature_dsa
case|:
name|idx
operator|=
name|SSL_PKEY_DSA_SIGN
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDSA
case|case
name|TLSEXT_signature_ecdsa
case|:
name|idx
operator|=
name|SSL_PKEY_ECC
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
continue|continue;
block|}
if|if
condition|(
name|c
operator|->
name|pkeys
index|[
name|idx
index|]
operator|.
name|digest
operator|==
name|NULL
condition|)
block|{
name|md
operator|=
name|tls12_get_hash
argument_list|(
name|hash_alg
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
condition|)
block|{
name|c
operator|->
name|pkeys
index|[
name|idx
index|]
operator|.
name|digest
operator|=
name|md
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|SSL_PKEY_RSA_SIGN
condition|)
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|digest
operator|=
name|md
expr_stmt|;
block|}
block|}
block|}
comment|/* Set any remaining keys to default values. NOTE: if alg is not 	 * supported it stays as NULL. 	 */
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
if|if
condition|(
operator|!
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_DSA_SIGN
index|]
operator|.
name|digest
condition|)
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_DSA_SIGN
index|]
operator|.
name|digest
operator|=
name|EVP_sha1
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
operator|!
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_SIGN
index|]
operator|.
name|digest
condition|)
block|{
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_SIGN
index|]
operator|.
name|digest
operator|=
name|EVP_sha1
argument_list|()
expr_stmt|;
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|digest
operator|=
name|EVP_sha1
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDSA
if|if
condition|(
operator|!
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_ECC
index|]
operator|.
name|digest
condition|)
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_ECC
index|]
operator|.
name|digest
operator|=
name|EVP_sha1
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
end_ifndef

begin_function
name|int
name|tls1_process_heartbeat
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|&
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|data
index|[
literal|0
index|]
decl_stmt|,
modifier|*
name|pl
decl_stmt|;
name|unsigned
name|short
name|hbtype
decl_stmt|;
name|unsigned
name|int
name|payload
decl_stmt|;
name|unsigned
name|int
name|padding
init|=
literal|16
decl_stmt|;
comment|/* Use minimum padding */
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|0
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
operator|&
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|data
index|[
literal|0
index|]
argument_list|,
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|length
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
comment|/* Read type and payload length first */
if|if
condition|(
literal|1
operator|+
literal|2
operator|+
literal|16
operator|>
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|length
condition|)
return|return
literal|0
return|;
comment|/* silently discard */
name|hbtype
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|payload
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|+
literal|2
operator|+
name|payload
operator|+
literal|16
operator|>
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|length
condition|)
return|return
literal|0
return|;
comment|/* silently discard per RFC 6520 sec. 4 */
name|pl
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|hbtype
operator|==
name|TLS1_HB_REQUEST
condition|)
block|{
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Allocate memory for the response, size is 1 bytes 		 * message type, plus 2 bytes payload length, plus 		 * payload, plus padding 		 */
name|buffer
operator|=
name|OPENSSL_malloc
argument_list|(
literal|1
operator|+
literal|2
operator|+
name|payload
operator|+
name|padding
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
comment|/* Enter response type, length and copy payload */
operator|*
name|bp
operator|++
operator|=
name|TLS1_HB_RESPONSE
expr_stmt|;
name|s2n
argument_list|(
name|payload
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|pl
argument_list|,
name|payload
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|payload
expr_stmt|;
comment|/* Random padding */
name|RAND_pseudo_bytes
argument_list|(
name|bp
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|r
operator|=
name|ssl3_write_bytes
argument_list|(
name|s
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buffer
argument_list|,
literal|3
operator|+
name|payload
operator|+
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
operator|&&
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|1
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buffer
argument_list|,
literal|3
operator|+
name|payload
operator|+
name|padding
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|hbtype
operator|==
name|TLS1_HB_RESPONSE
condition|)
block|{
name|unsigned
name|int
name|seq
decl_stmt|;
comment|/* We only send sequence numbers (2 bytes unsigned int), 		 * and 16 random bytes, so we just try to read the 		 * sequence number */
name|n2s
argument_list|(
name|pl
argument_list|,
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|payload
operator|==
literal|18
operator|&&
name|seq
operator|==
name|s
operator|->
name|tlsext_hb_seq
condition|)
block|{
name|s
operator|->
name|tlsext_hb_seq
operator|++
expr_stmt|;
name|s
operator|->
name|tlsext_hb_pending
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tls1_heartbeat
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|int
name|payload
init|=
literal|18
decl_stmt|;
comment|/* Sequence number + random bytes */
name|unsigned
name|int
name|padding
init|=
literal|16
decl_stmt|;
comment|/* Use minimum padding */
comment|/* Only send if peer supports and accepts HB requests... */
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|tlsext_heartbeat
operator|&
name|SSL_TLSEXT_HB_ENABLED
operator|)
operator|||
name|s
operator|->
name|tlsext_heartbeat
operator|&
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS1_HEARTBEAT
argument_list|,
name|SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* ...and there is none in flight yet... */
if|if
condition|(
name|s
operator|->
name|tlsext_hb_pending
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS1_HEARTBEAT
argument_list|,
name|SSL_R_TLS_HEARTBEAT_PENDING
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* ...and no handshake in progress. */
if|if
condition|(
name|SSL_in_init
argument_list|(
name|s
argument_list|)
operator|||
name|s
operator|->
name|in_handshake
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS1_HEARTBEAT
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check if padding is too long, payload and padding 	 * must not exceed 2^14 - 3 = 16381 bytes in total. 	 */
name|OPENSSL_assert
argument_list|(
name|payload
operator|+
name|padding
operator|<=
literal|16381
argument_list|)
expr_stmt|;
comment|/* Create HeartBeat message, we just use a sequence number 	 * as payload to distuingish different messages and add 	 * some random stuff. 	 *  - Message Type, 1 byte 	 *  - Payload Length, 2 bytes (unsigned int) 	 *  - Payload, the sequence number (2 bytes uint) 	 *  - Payload, random bytes (16 bytes uint) 	 *  - Padding 	 */
name|buf
operator|=
name|OPENSSL_malloc
argument_list|(
literal|1
operator|+
literal|2
operator|+
name|payload
operator|+
name|padding
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
comment|/* Message Type */
operator|*
name|p
operator|++
operator|=
name|TLS1_HB_REQUEST
expr_stmt|;
comment|/* Payload length (18 bytes here) */
name|s2n
argument_list|(
name|payload
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Sequence number */
name|s2n
argument_list|(
name|s
operator|->
name|tlsext_hb_seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 16 random bytes */
name|RAND_pseudo_bytes
argument_list|(
name|p
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|16
expr_stmt|;
comment|/* Random padding */
name|RAND_pseudo_bytes
argument_list|(
name|p
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ssl3_write_bytes
argument_list|(
name|s
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buf
argument_list|,
literal|3
operator|+
name|payload
operator|+
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|1
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buf
argument_list|,
literal|3
operator|+
name|payload
operator|+
name|padding
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|s
operator|->
name|tlsext_hb_pending
operator|=
literal|1
expr_stmt|;
block|}
name|OPENSSL_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

