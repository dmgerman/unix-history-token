begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ssl/t1_lib.c */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *  * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *  * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from  *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/hmac.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_NO_EC2M
end_ifdef

begin_include
include|#
directive|include
file|<openssl/ec.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/ocsp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|"ssl_locl.h"
end_include

begin_decl_stmt
specifier|const
name|char
name|tls1_version_str
index|[]
init|=
literal|"TLSv1"
name|OPENSSL_VERSION_PTEXT
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
end_ifndef

begin_function_decl
specifier|static
name|int
name|tls_decrypt_ticket
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|tick
parameter_list|,
name|int
name|ticklen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sess_id
parameter_list|,
name|int
name|sesslen
parameter_list|,
name|SSL_SESSION
modifier|*
modifier|*
name|psess
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ssl_check_clienthello_tlsext_early
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ssl_check_serverhello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CHECKLEN
parameter_list|(
name|curr
parameter_list|,
name|val
parameter_list|,
name|limit
parameter_list|)
define|\
value|(((curr)>= (limit)) || (size_t)((limit) - (curr))< (size_t)(val))
end_define

begin_decl_stmt
name|SSL3_ENC_METHOD
name|TLSv1_enc_data
init|=
block|{
name|tls1_enc
block|,
name|tls1_mac
block|,
name|tls1_setup_key_block
block|,
name|tls1_generate_master_secret
block|,
name|tls1_change_cipher_state
block|,
name|tls1_final_finish_mac
block|,
name|TLS1_FINISH_MAC_LENGTH
block|,
name|tls1_cert_verify_mac
block|,
name|TLS_MD_CLIENT_FINISH_CONST
block|,
name|TLS_MD_CLIENT_FINISH_CONST_SIZE
block|,
name|TLS_MD_SERVER_FINISH_CONST
block|,
name|TLS_MD_SERVER_FINISH_CONST_SIZE
block|,
name|tls1_alert_code
block|,
name|tls1_export_keying_material
block|,
literal|0
block|,
name|SSL3_HM_HEADER_LENGTH
block|,
name|ssl3_set_handshake_header
block|,
name|ssl3_handshake_write
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SSL3_ENC_METHOD
name|TLSv1_1_enc_data
init|=
block|{
name|tls1_enc
block|,
name|tls1_mac
block|,
name|tls1_setup_key_block
block|,
name|tls1_generate_master_secret
block|,
name|tls1_change_cipher_state
block|,
name|tls1_final_finish_mac
block|,
name|TLS1_FINISH_MAC_LENGTH
block|,
name|tls1_cert_verify_mac
block|,
name|TLS_MD_CLIENT_FINISH_CONST
block|,
name|TLS_MD_CLIENT_FINISH_CONST_SIZE
block|,
name|TLS_MD_SERVER_FINISH_CONST
block|,
name|TLS_MD_SERVER_FINISH_CONST_SIZE
block|,
name|tls1_alert_code
block|,
name|tls1_export_keying_material
block|,
name|SSL_ENC_FLAG_EXPLICIT_IV
block|,
name|SSL3_HM_HEADER_LENGTH
block|,
name|ssl3_set_handshake_header
block|,
name|ssl3_handshake_write
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SSL3_ENC_METHOD
name|TLSv1_2_enc_data
init|=
block|{
name|tls1_enc
block|,
name|tls1_mac
block|,
name|tls1_setup_key_block
block|,
name|tls1_generate_master_secret
block|,
name|tls1_change_cipher_state
block|,
name|tls1_final_finish_mac
block|,
name|TLS1_FINISH_MAC_LENGTH
block|,
name|tls1_cert_verify_mac
block|,
name|TLS_MD_CLIENT_FINISH_CONST
block|,
name|TLS_MD_CLIENT_FINISH_CONST_SIZE
block|,
name|TLS_MD_SERVER_FINISH_CONST
block|,
name|TLS_MD_SERVER_FINISH_CONST_SIZE
block|,
name|tls1_alert_code
block|,
name|tls1_export_keying_material
block|,
name|SSL_ENC_FLAG_EXPLICIT_IV
operator||
name|SSL_ENC_FLAG_SIGALGS
operator||
name|SSL_ENC_FLAG_SHA256_PRF
operator||
name|SSL_ENC_FLAG_TLS1_2_CIPHERS
block|,
name|SSL3_HM_HEADER_LENGTH
block|,
name|ssl3_set_handshake_header
block|,
name|ssl3_handshake_write
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|long
name|tls1_default_timeout
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*      * 2 hours, the 24 hours mentioned in the TLSv1 spec is way too long for      * http, the cache would over fill      */
return|return
operator|(
literal|60
operator|*
literal|60
operator|*
literal|2
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tls1_new
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ssl3_new
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|->
name|method
operator|->
name|ssl_clear
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tls1_free
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
if|if
condition|(
name|s
operator|->
name|tlsext_session_ticket
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|tlsext_session_ticket
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OPENSSL_NO_TLSEXT */
name|ssl3_free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tls1_clear
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|ssl3_clear
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|version
operator|=
name|s
operator|->
name|method
operator|->
name|version
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|nid_list
index|[]
init|=
block|{
name|NID_sect163k1
block|,
comment|/* sect163k1 (1) */
name|NID_sect163r1
block|,
comment|/* sect163r1 (2) */
name|NID_sect163r2
block|,
comment|/* sect163r2 (3) */
name|NID_sect193r1
block|,
comment|/* sect193r1 (4) */
name|NID_sect193r2
block|,
comment|/* sect193r2 (5) */
name|NID_sect233k1
block|,
comment|/* sect233k1 (6) */
name|NID_sect233r1
block|,
comment|/* sect233r1 (7) */
name|NID_sect239k1
block|,
comment|/* sect239k1 (8) */
name|NID_sect283k1
block|,
comment|/* sect283k1 (9) */
name|NID_sect283r1
block|,
comment|/* sect283r1 (10) */
name|NID_sect409k1
block|,
comment|/* sect409k1 (11) */
name|NID_sect409r1
block|,
comment|/* sect409r1 (12) */
name|NID_sect571k1
block|,
comment|/* sect571k1 (13) */
name|NID_sect571r1
block|,
comment|/* sect571r1 (14) */
name|NID_secp160k1
block|,
comment|/* secp160k1 (15) */
name|NID_secp160r1
block|,
comment|/* secp160r1 (16) */
name|NID_secp160r2
block|,
comment|/* secp160r2 (17) */
name|NID_secp192k1
block|,
comment|/* secp192k1 (18) */
name|NID_X9_62_prime192v1
block|,
comment|/* secp192r1 (19) */
name|NID_secp224k1
block|,
comment|/* secp224k1 (20) */
name|NID_secp224r1
block|,
comment|/* secp224r1 (21) */
name|NID_secp256k1
block|,
comment|/* secp256k1 (22) */
name|NID_X9_62_prime256v1
block|,
comment|/* secp256r1 (23) */
name|NID_secp384r1
block|,
comment|/* secp384r1 (24) */
name|NID_secp521r1
block|,
comment|/* secp521r1 (25) */
name|NID_brainpoolP256r1
block|,
comment|/* brainpoolP256r1 (26) */
name|NID_brainpoolP384r1
block|,
comment|/* brainpoolP384r1 (27) */
name|NID_brainpoolP512r1
comment|/* brainpool512r1 (28) */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|ecformats_default
index|[]
init|=
block|{
name|TLSEXT_ECPOINTFORMAT_uncompressed
block|,
name|TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime
block|,
name|TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The client's default curves / the server's 'auto' curves. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|eccurves_auto
index|[]
init|=
block|{
comment|/* Prefer P-256 which has the fastest and most secure implementations. */
literal|0
block|,
literal|23
block|,
comment|/* secp256r1 (23) */
comment|/* Other>= 256-bit prime curves. */
literal|0
block|,
literal|25
block|,
comment|/* secp521r1 (25) */
literal|0
block|,
literal|28
block|,
comment|/* brainpool512r1 (28) */
literal|0
block|,
literal|27
block|,
comment|/* brainpoolP384r1 (27) */
literal|0
block|,
literal|24
block|,
comment|/* secp384r1 (24) */
literal|0
block|,
literal|26
block|,
comment|/* brainpoolP256r1 (26) */
literal|0
block|,
literal|22
block|,
comment|/* secp256k1 (22) */
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC2M
comment|/*>= 256-bit binary curves. */
literal|0
block|,
literal|14
block|,
comment|/* sect571r1 (14) */
literal|0
block|,
literal|13
block|,
comment|/* sect571k1 (13) */
literal|0
block|,
literal|11
block|,
comment|/* sect409k1 (11) */
literal|0
block|,
literal|12
block|,
comment|/* sect409r1 (12) */
literal|0
block|,
literal|9
block|,
comment|/* sect283k1 (9) */
literal|0
block|,
literal|10
block|,
comment|/* sect283r1 (10) */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|eccurves_all
index|[]
init|=
block|{
comment|/* Prefer P-256 which has the fastest and most secure implementations. */
literal|0
block|,
literal|23
block|,
comment|/* secp256r1 (23) */
comment|/* Other>= 256-bit prime curves. */
literal|0
block|,
literal|25
block|,
comment|/* secp521r1 (25) */
literal|0
block|,
literal|28
block|,
comment|/* brainpool512r1 (28) */
literal|0
block|,
literal|27
block|,
comment|/* brainpoolP384r1 (27) */
literal|0
block|,
literal|24
block|,
comment|/* secp384r1 (24) */
literal|0
block|,
literal|26
block|,
comment|/* brainpoolP256r1 (26) */
literal|0
block|,
literal|22
block|,
comment|/* secp256k1 (22) */
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC2M
comment|/*>= 256-bit binary curves. */
literal|0
block|,
literal|14
block|,
comment|/* sect571r1 (14) */
literal|0
block|,
literal|13
block|,
comment|/* sect571k1 (13) */
literal|0
block|,
literal|11
block|,
comment|/* sect409k1 (11) */
literal|0
block|,
literal|12
block|,
comment|/* sect409r1 (12) */
literal|0
block|,
literal|9
block|,
comment|/* sect283k1 (9) */
literal|0
block|,
literal|10
block|,
comment|/* sect283r1 (10) */
endif|#
directive|endif
comment|/*      * Remaining curves disabled by default but still permitted if set      * via an explicit callback or parameters.      */
literal|0
block|,
literal|20
block|,
comment|/* secp224k1 (20) */
literal|0
block|,
literal|21
block|,
comment|/* secp224r1 (21) */
literal|0
block|,
literal|18
block|,
comment|/* secp192k1 (18) */
literal|0
block|,
literal|19
block|,
comment|/* secp192r1 (19) */
literal|0
block|,
literal|15
block|,
comment|/* secp160k1 (15) */
literal|0
block|,
literal|16
block|,
comment|/* secp160r1 (16) */
literal|0
block|,
literal|17
block|,
comment|/* secp160r2 (17) */
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC2M
literal|0
block|,
literal|8
block|,
comment|/* sect239k1 (8) */
literal|0
block|,
literal|6
block|,
comment|/* sect233k1 (6) */
literal|0
block|,
literal|7
block|,
comment|/* sect233r1 (7) */
literal|0
block|,
literal|4
block|,
comment|/* sect193r1 (4) */
literal|0
block|,
literal|5
block|,
comment|/* sect193r2 (5) */
literal|0
block|,
literal|1
block|,
comment|/* sect163k1 (1) */
literal|0
block|,
literal|2
block|,
comment|/* sect163r1 (2) */
literal|0
block|,
literal|3
block|,
comment|/* sect163r2 (3) */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|suiteb_curves
index|[]
init|=
block|{
literal|0
block|,
name|TLSEXT_curve_P_256
block|,
literal|0
block|,
name|TLSEXT_curve_P_384
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
end_ifdef

begin_comment
comment|/* Brainpool not allowed in FIPS mode */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|fips_curves_default
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC2M
literal|0
block|,
literal|14
block|,
comment|/* sect571r1 (14) */
literal|0
block|,
literal|13
block|,
comment|/* sect571k1 (13) */
endif|#
directive|endif
literal|0
block|,
literal|25
block|,
comment|/* secp521r1 (25) */
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC2M
literal|0
block|,
literal|11
block|,
comment|/* sect409k1 (11) */
literal|0
block|,
literal|12
block|,
comment|/* sect409r1 (12) */
endif|#
directive|endif
literal|0
block|,
literal|24
block|,
comment|/* secp384r1 (24) */
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC2M
literal|0
block|,
literal|9
block|,
comment|/* sect283k1 (9) */
literal|0
block|,
literal|10
block|,
comment|/* sect283r1 (10) */
endif|#
directive|endif
literal|0
block|,
literal|22
block|,
comment|/* secp256k1 (22) */
literal|0
block|,
literal|23
block|,
comment|/* secp256r1 (23) */
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC2M
literal|0
block|,
literal|8
block|,
comment|/* sect239k1 (8) */
literal|0
block|,
literal|6
block|,
comment|/* sect233k1 (6) */
literal|0
block|,
literal|7
block|,
comment|/* sect233r1 (7) */
endif|#
directive|endif
literal|0
block|,
literal|20
block|,
comment|/* secp224k1 (20) */
literal|0
block|,
literal|21
block|,
comment|/* secp224r1 (21) */
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC2M
literal|0
block|,
literal|4
block|,
comment|/* sect193r1 (4) */
literal|0
block|,
literal|5
block|,
comment|/* sect193r2 (5) */
endif|#
directive|endif
literal|0
block|,
literal|18
block|,
comment|/* secp192k1 (18) */
literal|0
block|,
literal|19
block|,
comment|/* secp192r1 (19) */
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC2M
literal|0
block|,
literal|1
block|,
comment|/* sect163k1 (1) */
literal|0
block|,
literal|2
block|,
comment|/* sect163r1 (2) */
literal|0
block|,
literal|3
block|,
comment|/* sect163r2 (3) */
endif|#
directive|endif
literal|0
block|,
literal|15
block|,
comment|/* secp160k1 (15) */
literal|0
block|,
literal|16
block|,
comment|/* secp160r1 (16) */
literal|0
block|,
literal|17
block|,
comment|/* secp160r2 (17) */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|tls1_ec_curve_id2nid
parameter_list|(
name|int
name|curve_id
parameter_list|)
block|{
comment|/* ECC curves from RFC 4492 and RFC 7027 */
if|if
condition|(
operator|(
name|curve_id
operator|<
literal|1
operator|)
operator|||
operator|(
operator|(
name|unsigned
name|int
operator|)
name|curve_id
operator|>
sizeof|sizeof
argument_list|(
name|nid_list
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|nid_list
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|nid_list
index|[
name|curve_id
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_function
name|int
name|tls1_ec_nid2curve_id
parameter_list|(
name|int
name|nid
parameter_list|)
block|{
comment|/* ECC curves from RFC 4492 and RFC 7027 */
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
name|NID_sect163k1
case|:
comment|/* sect163k1 (1) */
return|return
literal|1
return|;
case|case
name|NID_sect163r1
case|:
comment|/* sect163r1 (2) */
return|return
literal|2
return|;
case|case
name|NID_sect163r2
case|:
comment|/* sect163r2 (3) */
return|return
literal|3
return|;
case|case
name|NID_sect193r1
case|:
comment|/* sect193r1 (4) */
return|return
literal|4
return|;
case|case
name|NID_sect193r2
case|:
comment|/* sect193r2 (5) */
return|return
literal|5
return|;
case|case
name|NID_sect233k1
case|:
comment|/* sect233k1 (6) */
return|return
literal|6
return|;
case|case
name|NID_sect233r1
case|:
comment|/* sect233r1 (7) */
return|return
literal|7
return|;
case|case
name|NID_sect239k1
case|:
comment|/* sect239k1 (8) */
return|return
literal|8
return|;
case|case
name|NID_sect283k1
case|:
comment|/* sect283k1 (9) */
return|return
literal|9
return|;
case|case
name|NID_sect283r1
case|:
comment|/* sect283r1 (10) */
return|return
literal|10
return|;
case|case
name|NID_sect409k1
case|:
comment|/* sect409k1 (11) */
return|return
literal|11
return|;
case|case
name|NID_sect409r1
case|:
comment|/* sect409r1 (12) */
return|return
literal|12
return|;
case|case
name|NID_sect571k1
case|:
comment|/* sect571k1 (13) */
return|return
literal|13
return|;
case|case
name|NID_sect571r1
case|:
comment|/* sect571r1 (14) */
return|return
literal|14
return|;
case|case
name|NID_secp160k1
case|:
comment|/* secp160k1 (15) */
return|return
literal|15
return|;
case|case
name|NID_secp160r1
case|:
comment|/* secp160r1 (16) */
return|return
literal|16
return|;
case|case
name|NID_secp160r2
case|:
comment|/* secp160r2 (17) */
return|return
literal|17
return|;
case|case
name|NID_secp192k1
case|:
comment|/* secp192k1 (18) */
return|return
literal|18
return|;
case|case
name|NID_X9_62_prime192v1
case|:
comment|/* secp192r1 (19) */
return|return
literal|19
return|;
case|case
name|NID_secp224k1
case|:
comment|/* secp224k1 (20) */
return|return
literal|20
return|;
case|case
name|NID_secp224r1
case|:
comment|/* secp224r1 (21) */
return|return
literal|21
return|;
case|case
name|NID_secp256k1
case|:
comment|/* secp256k1 (22) */
return|return
literal|22
return|;
case|case
name|NID_X9_62_prime256v1
case|:
comment|/* secp256r1 (23) */
return|return
literal|23
return|;
case|case
name|NID_secp384r1
case|:
comment|/* secp384r1 (24) */
return|return
literal|24
return|;
case|case
name|NID_secp521r1
case|:
comment|/* secp521r1 (25) */
return|return
literal|25
return|;
case|case
name|NID_brainpoolP256r1
case|:
comment|/* brainpoolP256r1 (26) */
return|return
literal|26
return|;
case|case
name|NID_brainpoolP384r1
case|:
comment|/* brainpoolP384r1 (27) */
return|return
literal|27
return|;
case|case
name|NID_brainpoolP512r1
case|:
comment|/* brainpool512r1 (28) */
return|return
literal|28
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get curves list, if "sess" is set return client curves otherwise  * preferred list.  * Sets |num_curves| to the number of curves in the list, i.e.,  * the length of |pcurves| is 2 * num_curves.  * Returns 1 on success and 0 if the client curves list has invalid format.  * The latter indicates an internal error: we should not be accepting such  * lists in the first place.  * TODO(emilia): we should really be storing the curves list in explicitly  * parsed form instead. (However, this would affect binary compatibility  * so cannot happen in the 1.0.x series.)  */
end_comment

begin_function
specifier|static
name|int
name|tls1_get_curvelist
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|sess
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|pcurves
parameter_list|,
name|size_t
modifier|*
name|num_curves
parameter_list|)
block|{
name|size_t
name|pcurveslen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sess
condition|)
block|{
operator|*
name|pcurves
operator|=
name|s
operator|->
name|session
operator|->
name|tlsext_ellipticcurvelist
expr_stmt|;
name|pcurveslen
operator|=
name|s
operator|->
name|session
operator|->
name|tlsext_ellipticcurvelist_length
expr_stmt|;
block|}
else|else
block|{
comment|/* For Suite B mode only include P-256, P-384 */
switch|switch
condition|(
name|tls1_suiteb
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|SSL_CERT_FLAG_SUITEB_128_LOS
case|:
operator|*
name|pcurves
operator|=
name|suiteb_curves
expr_stmt|;
name|pcurveslen
operator|=
sizeof|sizeof
argument_list|(
name|suiteb_curves
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSL_CERT_FLAG_SUITEB_128_LOS_ONLY
case|:
operator|*
name|pcurves
operator|=
name|suiteb_curves
expr_stmt|;
name|pcurveslen
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|SSL_CERT_FLAG_SUITEB_192_LOS
case|:
operator|*
name|pcurves
operator|=
name|suiteb_curves
operator|+
literal|2
expr_stmt|;
name|pcurveslen
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
operator|*
name|pcurves
operator|=
name|s
operator|->
name|tlsext_ellipticcurvelist
expr_stmt|;
name|pcurveslen
operator|=
name|s
operator|->
name|tlsext_ellipticcurvelist_length
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|pcurves
condition|)
block|{
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
if|if
condition|(
name|FIPS_mode
argument_list|()
condition|)
block|{
operator|*
name|pcurves
operator|=
name|fips_curves_default
expr_stmt|;
name|pcurveslen
operator|=
sizeof|sizeof
argument_list|(
name|fips_curves_default
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|server
operator|||
name|s
operator|->
name|cert
operator|->
name|ecdh_tmp_auto
condition|)
block|{
operator|*
name|pcurves
operator|=
name|eccurves_auto
expr_stmt|;
name|pcurveslen
operator|=
sizeof|sizeof
argument_list|(
name|eccurves_auto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pcurves
operator|=
name|eccurves_all
expr_stmt|;
name|pcurveslen
operator|=
sizeof|sizeof
argument_list|(
name|eccurves_all
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* We do not allow odd length arrays to enter the system. */
if|if
condition|(
name|pcurveslen
operator|&
literal|1
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS1_GET_CURVELIST
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
operator|*
name|num_curves
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
operator|*
name|num_curves
operator|=
name|pcurveslen
operator|/
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Check a curve is one of our preferences */
end_comment

begin_function
name|int
name|tls1_check_curve
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|curves
decl_stmt|;
name|size_t
name|num_curves
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|int
name|suiteb_flags
init|=
name|tls1_suiteb
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|!=
literal|3
operator|||
name|p
index|[
literal|0
index|]
operator|!=
name|NAMED_CURVE_TYPE
condition|)
return|return
literal|0
return|;
comment|/* Check curve matches Suite B preferences */
if|if
condition|(
name|suiteb_flags
condition|)
block|{
name|unsigned
name|long
name|cid
init|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|id
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cid
operator|==
name|TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|!=
name|TLSEXT_curve_P_256
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|cid
operator|==
name|TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|!=
name|TLSEXT_curve_P_384
condition|)
return|return
literal|0
return|;
block|}
else|else
comment|/* Should never happen */
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|tls1_get_curvelist
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|curves
argument_list|,
operator|&
name|num_curves
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_curves
condition|;
name|i
operator|++
operator|,
name|curves
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
name|curves
index|[
literal|0
index|]
operator|&&
name|p
index|[
literal|2
index|]
operator|==
name|curves
index|[
literal|1
index|]
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*-  * Return |nmatch|th shared curve or NID_undef if there is no match.  * For nmatch == -1, return number of  matches  * For nmatch == -2, return the NID of the curve to use for  * an EC tmp key, or NID_undef if there is no match.  */
end_comment

begin_function
name|int
name|tls1_shared_curve
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|nmatch
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|pref
decl_stmt|,
modifier|*
name|supp
decl_stmt|;
name|size_t
name|num_pref
decl_stmt|,
name|num_supp
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
comment|/* Can't do anything on client side */
if|if
condition|(
name|s
operator|->
name|server
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|nmatch
operator|==
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|tls1_suiteb
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/*              * For Suite B ciphersuite determines curve: we already know              * these are acceptable due to previous checks.              */
name|unsigned
name|long
name|cid
init|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|id
decl_stmt|;
if|if
condition|(
name|cid
operator|==
name|TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
condition|)
return|return
name|NID_X9_62_prime256v1
return|;
comment|/* P-256 */
if|if
condition|(
name|cid
operator|==
name|TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
condition|)
return|return
name|NID_secp384r1
return|;
comment|/* P-384 */
comment|/* Should never happen */
return|return
name|NID_undef
return|;
block|}
comment|/* If not Suite B just return first preference shared curve */
name|nmatch
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Avoid truncation. tls1_get_curvelist takes an int      * but s->options is a long...      */
if|if
condition|(
operator|!
name|tls1_get_curvelist
argument_list|(
name|s
argument_list|,
operator|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_CIPHER_SERVER_PREFERENCE
operator|)
operator|!=
literal|0
argument_list|,
operator|&
name|supp
argument_list|,
operator|&
name|num_supp
argument_list|)
condition|)
comment|/* In practice, NID_undef == 0 but let's be precise. */
return|return
name|nmatch
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
name|NID_undef
return|;
if|if
condition|(
operator|!
name|tls1_get_curvelist
argument_list|(
name|s
argument_list|,
operator|!
operator|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_CIPHER_SERVER_PREFERENCE
operator|)
argument_list|,
operator|&
name|pref
argument_list|,
operator|&
name|num_pref
argument_list|)
condition|)
return|return
name|nmatch
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
name|NID_undef
return|;
comment|/*      * If the client didn't send the elliptic_curves extension all of them      * are allowed.      */
if|if
condition|(
name|num_supp
operator|==
literal|0
operator|&&
operator|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_CIPHER_SERVER_PREFERENCE
operator|)
operator|!=
literal|0
condition|)
block|{
name|supp
operator|=
name|eccurves_all
expr_stmt|;
name|num_supp
operator|=
sizeof|sizeof
argument_list|(
name|eccurves_all
argument_list|)
operator|/
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_pref
operator|==
literal|0
operator|&&
operator|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_CIPHER_SERVER_PREFERENCE
operator|)
operator|==
literal|0
condition|)
block|{
name|pref
operator|=
name|eccurves_all
expr_stmt|;
name|num_pref
operator|=
sizeof|sizeof
argument_list|(
name|eccurves_all
argument_list|)
operator|/
literal|2
expr_stmt|;
block|}
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_pref
condition|;
name|i
operator|++
operator|,
name|pref
operator|+=
literal|2
control|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|tsupp
init|=
name|supp
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_supp
condition|;
name|j
operator|++
operator|,
name|tsupp
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|pref
index|[
literal|0
index|]
operator|==
name|tsupp
index|[
literal|0
index|]
operator|&&
name|pref
index|[
literal|1
index|]
operator|==
name|tsupp
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|nmatch
operator|==
name|k
condition|)
block|{
name|int
name|id
init|=
operator|(
name|pref
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|pref
index|[
literal|1
index|]
decl_stmt|;
return|return
name|tls1_ec_curve_id2nid
argument_list|(
name|id
argument_list|)
return|;
block|}
name|k
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nmatch
operator|==
operator|-
literal|1
condition|)
return|return
name|k
return|;
comment|/* Out of range (nmatch> k). */
return|return
name|NID_undef
return|;
block|}
end_function

begin_function
name|int
name|tls1_set_curves
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|pext
parameter_list|,
name|size_t
modifier|*
name|pextlen
parameter_list|,
name|int
modifier|*
name|curves
parameter_list|,
name|size_t
name|ncurves
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|clist
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/*      * Bitmap of curves included to detect duplicates: only works while curve      * ids< 32      */
name|unsigned
name|long
name|dup_list
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL_NO_EC2M
name|EC_GROUP
modifier|*
name|curve
decl_stmt|;
endif|#
directive|endif
name|clist
operator|=
name|OPENSSL_malloc
argument_list|(
name|ncurves
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clist
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|clist
init|;
name|i
operator|<
name|ncurves
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|idmask
decl_stmt|;
name|int
name|id
decl_stmt|;
name|id
operator|=
name|tls1_ec_nid2curve_id
argument_list|(
name|curves
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
comment|/* NB: 25 is last curve ID supported by FIPS module */
if|if
condition|(
name|FIPS_mode
argument_list|()
operator|&&
name|id
operator|>
literal|25
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|clist
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL_NO_EC2M
name|curve
operator|=
name|EC_GROUP_new_by_curve_name
argument_list|(
name|curves
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curve
operator|||
name|EC_METHOD_get_field_type
argument_list|(
name|EC_GROUP_method_of
argument_list|(
name|curve
argument_list|)
argument_list|)
operator|==
name|NID_X9_62_characteristic_two_field
condition|)
block|{
if|if
condition|(
name|curve
condition|)
name|EC_GROUP_free
argument_list|(
name|curve
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|clist
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|EC_GROUP_free
argument_list|(
name|curve
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|idmask
operator|=
literal|1L
operator|<<
name|id
expr_stmt|;
if|if
condition|(
operator|!
name|id
operator|||
operator|(
name|dup_list
operator|&
name|idmask
operator|)
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|clist
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dup_list
operator||=
name|idmask
expr_stmt|;
name|s2n
argument_list|(
name|id
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pext
condition|)
name|OPENSSL_free
argument_list|(
operator|*
name|pext
argument_list|)
expr_stmt|;
operator|*
name|pext
operator|=
name|clist
expr_stmt|;
operator|*
name|pextlen
operator|=
name|ncurves
operator|*
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_CURVELIST
value|28
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|size_t
name|nidcnt
decl_stmt|;
name|int
name|nid_arr
index|[
name|MAX_CURVELIST
index|]
decl_stmt|;
block|}
name|nid_cb_st
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|nid_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|elem
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|nid_cb_st
modifier|*
name|narg
init|=
name|arg
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|nid
decl_stmt|;
name|char
name|etmp
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|elem
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|narg
operator|->
name|nidcnt
operator|==
name|MAX_CURVELIST
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len
operator|>
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|etmp
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|etmp
argument_list|,
name|elem
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|etmp
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|nid
operator|=
name|EC_curve_nist2nid
argument_list|(
name|etmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nid
operator|==
name|NID_undef
condition|)
name|nid
operator|=
name|OBJ_sn2nid
argument_list|(
name|etmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nid
operator|==
name|NID_undef
condition|)
name|nid
operator|=
name|OBJ_ln2nid
argument_list|(
name|etmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nid
operator|==
name|NID_undef
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narg
operator|->
name|nidcnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|narg
operator|->
name|nid_arr
index|[
name|i
index|]
operator|==
name|nid
condition|)
return|return
literal|0
return|;
name|narg
operator|->
name|nid_arr
index|[
name|narg
operator|->
name|nidcnt
operator|++
index|]
operator|=
name|nid
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Set curves based on a colon separate list */
end_comment

begin_function
name|int
name|tls1_set_curves_list
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|pext
parameter_list|,
name|size_t
modifier|*
name|pextlen
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|nid_cb_st
name|ncb
decl_stmt|;
name|ncb
operator|.
name|nidcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|CONF_parse_list
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|,
literal|1
argument_list|,
name|nid_cb
argument_list|,
operator|&
name|ncb
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pext
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
return|return
name|tls1_set_curves
argument_list|(
name|pext
argument_list|,
name|pextlen
argument_list|,
name|ncb
operator|.
name|nid_arr
argument_list|,
name|ncb
operator|.
name|nidcnt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For an EC key set TLS id and required compression based on parameters */
end_comment

begin_function
specifier|static
name|int
name|tls1_set_ec_id
parameter_list|(
name|unsigned
name|char
modifier|*
name|curve_id
parameter_list|,
name|unsigned
name|char
modifier|*
name|comp_id
parameter_list|,
name|EC_KEY
modifier|*
name|ec
parameter_list|)
block|{
name|int
name|is_prime
decl_stmt|,
name|id
decl_stmt|;
specifier|const
name|EC_GROUP
modifier|*
name|grp
decl_stmt|;
specifier|const
name|EC_METHOD
modifier|*
name|meth
decl_stmt|;
if|if
condition|(
operator|!
name|ec
condition|)
return|return
literal|0
return|;
comment|/* Determine if it is a prime field */
name|grp
operator|=
name|EC_KEY_get0_group
argument_list|(
name|ec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|grp
condition|)
return|return
literal|0
return|;
name|meth
operator|=
name|EC_GROUP_method_of
argument_list|(
name|grp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|meth
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|EC_METHOD_get_field_type
argument_list|(
name|meth
argument_list|)
operator|==
name|NID_X9_62_prime_field
condition|)
name|is_prime
operator|=
literal|1
expr_stmt|;
else|else
name|is_prime
operator|=
literal|0
expr_stmt|;
comment|/* Determine curve ID */
name|id
operator|=
name|EC_GROUP_get_curve_name
argument_list|(
name|grp
argument_list|)
expr_stmt|;
name|id
operator|=
name|tls1_ec_nid2curve_id
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* If we have an ID set it, otherwise set arbitrary explicit curve */
if|if
condition|(
name|id
condition|)
block|{
name|curve_id
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|curve_id
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|id
expr_stmt|;
block|}
else|else
block|{
name|curve_id
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|is_prime
condition|)
name|curve_id
index|[
literal|1
index|]
operator|=
literal|0x01
expr_stmt|;
else|else
name|curve_id
index|[
literal|1
index|]
operator|=
literal|0x02
expr_stmt|;
block|}
if|if
condition|(
name|comp_id
condition|)
block|{
if|if
condition|(
name|EC_KEY_get0_public_key
argument_list|(
name|ec
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|EC_KEY_get_conv_form
argument_list|(
name|ec
argument_list|)
operator|==
name|POINT_CONVERSION_COMPRESSED
condition|)
block|{
if|if
condition|(
name|is_prime
condition|)
operator|*
name|comp_id
operator|=
name|TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime
expr_stmt|;
else|else
operator|*
name|comp_id
operator|=
name|TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2
expr_stmt|;
block|}
else|else
operator|*
name|comp_id
operator|=
name|TLSEXT_ECPOINTFORMAT_uncompressed
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check an EC key is compatible with extensions */
end_comment

begin_function
specifier|static
name|int
name|tls1_check_ec_key
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|curve_id
parameter_list|,
name|unsigned
name|char
modifier|*
name|comp_id
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|pformats
decl_stmt|,
modifier|*
name|pcurves
decl_stmt|;
name|size_t
name|num_formats
decl_stmt|,
name|num_curves
decl_stmt|,
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/*      * If point formats extension present check it, otherwise everything is      * supported (see RFC4492).      */
if|if
condition|(
name|comp_id
operator|&&
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
condition|)
block|{
name|pformats
operator|=
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
expr_stmt|;
name|num_formats
operator|=
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist_length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_formats
condition|;
name|i
operator|++
operator|,
name|pformats
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|comp_id
operator|==
operator|*
name|pformats
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|num_formats
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|curve_id
condition|)
return|return
literal|1
return|;
comment|/* Check curve is consistent with client and server preferences */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|1
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|tls1_get_curvelist
argument_list|(
name|s
argument_list|,
name|j
argument_list|,
operator|&
name|pcurves
argument_list|,
operator|&
name|num_curves
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|j
operator|==
literal|1
operator|&&
name|num_curves
operator|==
literal|0
condition|)
block|{
comment|/*              * If we've not received any curves then skip this check.              * RFC 4492 does not require the supported elliptic curves extension              * so if it is not sent we can just choose any curve.              * It is invalid to send an empty list in the elliptic curves              * extension, so num_curves == 0 always means no extension.              */
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_curves
condition|;
name|i
operator|++
operator|,
name|pcurves
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|pcurves
index|[
literal|0
index|]
operator|==
name|curve_id
index|[
literal|0
index|]
operator|&&
name|pcurves
index|[
literal|1
index|]
operator|==
name|curve_id
index|[
literal|1
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|num_curves
condition|)
return|return
literal|0
return|;
comment|/* For clients can only check sent curve list */
if|if
condition|(
operator|!
name|s
operator|->
name|server
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tls1_get_formatlist
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|pformats
parameter_list|,
name|size_t
modifier|*
name|num_formats
parameter_list|)
block|{
comment|/*      * If we have a custom point format list use it otherwise use default      */
if|if
condition|(
name|s
operator|->
name|tlsext_ecpointformatlist
condition|)
block|{
operator|*
name|pformats
operator|=
name|s
operator|->
name|tlsext_ecpointformatlist
expr_stmt|;
operator|*
name|num_formats
operator|=
name|s
operator|->
name|tlsext_ecpointformatlist_length
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pformats
operator|=
name|ecformats_default
expr_stmt|;
comment|/* For Suite B we don't support char2 fields */
if|if
condition|(
name|tls1_suiteb
argument_list|(
name|s
argument_list|)
condition|)
operator|*
name|num_formats
operator|=
sizeof|sizeof
argument_list|(
name|ecformats_default
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
operator|*
name|num_formats
operator|=
sizeof|sizeof
argument_list|(
name|ecformats_default
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check cert parameters compatible with extensions: currently just checks EC  * certificates have compatible curves and compression.  */
end_comment

begin_function
specifier|static
name|int
name|tls1_check_cert_param
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|X509
modifier|*
name|x
parameter_list|,
name|int
name|set_ee_md
parameter_list|)
block|{
name|unsigned
name|char
name|comp_id
decl_stmt|,
name|curve_id
index|[
literal|2
index|]
decl_stmt|;
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pkey
condition|)
return|return
literal|0
return|;
comment|/* If not EC nothing to do */
if|if
condition|(
name|pkey
operator|->
name|type
operator|!=
name|EVP_PKEY_EC
condition|)
block|{
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|rv
operator|=
name|tls1_set_ec_id
argument_list|(
name|curve_id
argument_list|,
operator|&
name|comp_id
argument_list|,
name|pkey
operator|->
name|pkey
operator|.
name|ec
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
return|return
literal|0
return|;
comment|/*      * Can't check curve_id for client certs as we don't have a supported      * curves extension.      */
name|rv
operator|=
name|tls1_check_ec_key
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|server
condition|?
name|curve_id
else|:
name|NULL
argument_list|,
operator|&
name|comp_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
return|return
literal|0
return|;
comment|/*      * Special case for suite B. We *MUST* sign using SHA256+P-256 or      * SHA384+P-384, adjust digest if necessary.      */
if|if
condition|(
name|set_ee_md
operator|&&
name|tls1_suiteb
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|int
name|check_md
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|CERT
modifier|*
name|c
init|=
name|s
operator|->
name|cert
decl_stmt|;
if|if
condition|(
name|curve_id
index|[
literal|0
index|]
condition|)
return|return
literal|0
return|;
comment|/* Check to see we have necessary signing algorithm */
if|if
condition|(
name|curve_id
index|[
literal|1
index|]
operator|==
name|TLSEXT_curve_P_256
condition|)
name|check_md
operator|=
name|NID_ecdsa_with_SHA256
expr_stmt|;
elseif|else
if|if
condition|(
name|curve_id
index|[
literal|1
index|]
operator|==
name|TLSEXT_curve_P_384
condition|)
name|check_md
operator|=
name|NID_ecdsa_with_SHA384
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* Should never happen */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|shared_sigalgslen
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|check_md
operator|==
name|c
operator|->
name|shared_sigalgs
index|[
name|i
index|]
operator|.
name|signandhash_nid
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|c
operator|->
name|shared_sigalgslen
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|set_ee_md
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|check_md
operator|==
name|NID_ecdsa_with_SHA256
condition|)
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_ECC
index|]
operator|.
name|digest
operator|=
name|EVP_sha256
argument_list|()
expr_stmt|;
else|else
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_ECC
index|]
operator|.
name|digest
operator|=
name|EVP_sha384
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|rv
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDH
end_ifndef

begin_comment
comment|/* Check EC temporary key is compatible with client extensions */
end_comment

begin_function
name|int
name|tls1_check_ec_tmp_key
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|long
name|cid
parameter_list|)
block|{
name|unsigned
name|char
name|curve_id
index|[
literal|2
index|]
decl_stmt|;
name|EC_KEY
modifier|*
name|ec
init|=
name|s
operator|->
name|cert
operator|->
name|ecdh_tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL
comment|/* Allow any curve: not just those peer supports */
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|cert_flags
operator|&
name|SSL_CERT_FLAG_BROKEN_PROTOCOL
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/*      * If Suite B, AES128 MUST use P-256 and AES256 MUST use P-384, no other      * curves permitted.      */
if|if
condition|(
name|tls1_suiteb
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/* Curve to check determined by ciphersuite */
if|if
condition|(
name|cid
operator|==
name|TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
condition|)
name|curve_id
index|[
literal|1
index|]
operator|=
name|TLSEXT_curve_P_256
expr_stmt|;
elseif|else
if|if
condition|(
name|cid
operator|==
name|TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
condition|)
name|curve_id
index|[
literal|1
index|]
operator|=
name|TLSEXT_curve_P_384
expr_stmt|;
else|else
return|return
literal|0
return|;
name|curve_id
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Check this curve is acceptable */
if|if
condition|(
operator|!
name|tls1_check_ec_key
argument_list|(
name|s
argument_list|,
name|curve_id
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If auto or setting curve from callback assume OK */
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|ecdh_tmp_auto
operator|||
name|s
operator|->
name|cert
operator|->
name|ecdh_tmp_cb
condition|)
return|return
literal|1
return|;
comment|/* Otherwise check curve is acceptable */
else|else
block|{
name|unsigned
name|char
name|curve_tmp
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ec
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|tls1_set_ec_id
argument_list|(
name|curve_tmp
argument_list|,
name|NULL
argument_list|,
name|ec
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|curve_tmp
index|[
literal|0
index|]
operator|||
name|curve_tmp
index|[
literal|1
index|]
operator|==
name|curve_id
index|[
literal|1
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|ecdh_tmp_auto
condition|)
block|{
comment|/* Need a shared curve */
if|if
condition|(
name|tls1_shared_curve
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|ec
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|ecdh_tmp_cb
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|tls1_set_ec_id
argument_list|(
name|curve_id
argument_list|,
name|NULL
argument_list|,
name|ec
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Set this to allow use of invalid curves for testing */
if|#
directive|if
literal|0
block|return 1;
else|#
directive|else
return|return
name|tls1_check_ec_key
argument_list|(
name|s
argument_list|,
name|curve_id
argument_list|,
name|NULL
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL_NO_ECDH */
end_comment

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|tls1_check_cert_param
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|X509
modifier|*
name|x
parameter_list|,
name|int
name|set_ee_md
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL_NO_EC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
end_ifndef

begin_comment
comment|/*  * List of supported signature algorithms and hashes. Should make this  * customisable at some point, for now include everything we support.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_NO_RSA
end_ifdef

begin_define
define|#
directive|define
name|tlsext_sigalg_rsa
parameter_list|(
name|md
parameter_list|)
end_define

begin_comment
comment|/* */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|tlsext_sigalg_rsa
parameter_list|(
name|md
parameter_list|)
value|md, TLSEXT_signature_rsa,
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_NO_DSA
end_ifdef

begin_define
define|#
directive|define
name|tlsext_sigalg_dsa
parameter_list|(
name|md
parameter_list|)
end_define

begin_comment
comment|/* */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|tlsext_sigalg_dsa
parameter_list|(
name|md
parameter_list|)
value|md, TLSEXT_signature_dsa,
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_NO_ECDSA
end_ifdef

begin_define
define|#
directive|define
name|tlsext_sigalg_ecdsa
parameter_list|(
name|md
parameter_list|)
end_define

begin_comment
comment|/* */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|tlsext_sigalg_ecdsa
parameter_list|(
name|md
parameter_list|)
value|md, TLSEXT_signature_ecdsa,
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|tlsext_sigalg
parameter_list|(
name|md
parameter_list|)
define|\
value|tlsext_sigalg_rsa(md) \                 tlsext_sigalg_dsa(md) \                 tlsext_sigalg_ecdsa(md)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|tls12_sigalgs
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA512
name|tlsext_sigalg
argument_list|(
argument|TLSEXT_hash_sha512
argument_list|)
name|tlsext_sigalg
argument_list|(
argument|TLSEXT_hash_sha384
argument_list|)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA256
name|tlsext_sigalg
argument_list|(
argument|TLSEXT_hash_sha256
argument_list|)
name|tlsext_sigalg
argument_list|(
argument|TLSEXT_hash_sha224
argument_list|)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA
name|tlsext_sigalg
argument_list|(
argument|TLSEXT_hash_sha1
argument_list|)
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDSA
end_ifndef

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|suiteb_sigalgs
index|[]
init|=
block|{
name|tlsext_sigalg_ecdsa
argument_list|(
argument|TLSEXT_hash_sha256
argument_list|)
name|tlsext_sigalg_ecdsa
argument_list|(
argument|TLSEXT_hash_sha384
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|size_t
name|tls12_get_psigalgs
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|sent
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|psigs
parameter_list|)
block|{
comment|/*      * If Suite B mode use Suite B sigalgs only, ignore any other      * preferences.      */
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
switch|switch
condition|(
name|tls1_suiteb
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|SSL_CERT_FLAG_SUITEB_128_LOS
case|:
operator|*
name|psigs
operator|=
name|suiteb_sigalgs
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
name|suiteb_sigalgs
argument_list|)
return|;
case|case
name|SSL_CERT_FLAG_SUITEB_128_LOS_ONLY
case|:
operator|*
name|psigs
operator|=
name|suiteb_sigalgs
expr_stmt|;
return|return
literal|2
return|;
case|case
name|SSL_CERT_FLAG_SUITEB_192_LOS
case|:
operator|*
name|psigs
operator|=
name|suiteb_sigalgs
operator|+
literal|2
expr_stmt|;
return|return
literal|2
return|;
block|}
endif|#
directive|endif
comment|/* If server use client authentication sigalgs if not NULL */
if|if
condition|(
name|s
operator|->
name|server
operator|==
name|sent
operator|&&
name|s
operator|->
name|cert
operator|->
name|client_sigalgs
condition|)
block|{
operator|*
name|psigs
operator|=
name|s
operator|->
name|cert
operator|->
name|client_sigalgs
expr_stmt|;
return|return
name|s
operator|->
name|cert
operator|->
name|client_sigalgslen
return|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|conf_sigalgs
condition|)
block|{
operator|*
name|psigs
operator|=
name|s
operator|->
name|cert
operator|->
name|conf_sigalgs
expr_stmt|;
return|return
name|s
operator|->
name|cert
operator|->
name|conf_sigalgslen
return|;
block|}
else|else
block|{
operator|*
name|psigs
operator|=
name|tls12_sigalgs
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
name|tls12_sigalgs
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check signature algorithm is consistent with sent supported signature  * algorithms and if so return relevant digest.  */
end_comment

begin_function
name|int
name|tls12_check_peer_sigalg
parameter_list|(
specifier|const
name|EVP_MD
modifier|*
modifier|*
name|pmd
parameter_list|,
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sig
parameter_list|,
name|EVP_PKEY
modifier|*
name|pkey
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|sent_sigs
decl_stmt|;
name|size_t
name|sent_sigslen
decl_stmt|,
name|i
decl_stmt|;
name|int
name|sigalg
init|=
name|tls12_get_sigid
argument_list|(
name|pkey
argument_list|)
decl_stmt|;
comment|/* Should never happen */
if|if
condition|(
name|sigalg
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Check key type is consistent with signature */
if|if
condition|(
name|sigalg
operator|!=
operator|(
name|int
operator|)
name|sig
index|[
literal|1
index|]
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS12_CHECK_PEER_SIGALG
argument_list|,
name|SSL_R_WRONG_SIGNATURE_TYPE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
if|if
condition|(
name|pkey
operator|->
name|type
operator|==
name|EVP_PKEY_EC
condition|)
block|{
name|unsigned
name|char
name|curve_id
index|[
literal|2
index|]
decl_stmt|,
name|comp_id
decl_stmt|;
comment|/* Check compression and curve matches extensions */
if|if
condition|(
operator|!
name|tls1_set_ec_id
argument_list|(
name|curve_id
argument_list|,
operator|&
name|comp_id
argument_list|,
name|pkey
operator|->
name|pkey
operator|.
name|ec
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|s
operator|->
name|server
operator|&&
operator|!
name|tls1_check_ec_key
argument_list|(
name|s
argument_list|,
name|curve_id
argument_list|,
operator|&
name|comp_id
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS12_CHECK_PEER_SIGALG
argument_list|,
name|SSL_R_WRONG_CURVE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If Suite B only P-384+SHA384 or P-256+SHA-256 allowed */
if|if
condition|(
name|tls1_suiteb
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|curve_id
index|[
literal|0
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|curve_id
index|[
literal|1
index|]
operator|==
name|TLSEXT_curve_P_256
condition|)
block|{
if|if
condition|(
name|sig
index|[
literal|0
index|]
operator|!=
name|TLSEXT_hash_sha256
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS12_CHECK_PEER_SIGALG
argument_list|,
name|SSL_R_ILLEGAL_SUITEB_DIGEST
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|curve_id
index|[
literal|1
index|]
operator|==
name|TLSEXT_curve_P_384
condition|)
block|{
if|if
condition|(
name|sig
index|[
literal|0
index|]
operator|!=
name|TLSEXT_hash_sha384
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS12_CHECK_PEER_SIGALG
argument_list|,
name|SSL_R_ILLEGAL_SUITEB_DIGEST
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|tls1_suiteb
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* Check signature matches a type we sent */
name|sent_sigslen
operator|=
name|tls12_get_psigalgs
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
operator|&
name|sent_sigs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sent_sigslen
condition|;
name|i
operator|+=
literal|2
operator|,
name|sent_sigs
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|sig
index|[
literal|0
index|]
operator|==
name|sent_sigs
index|[
literal|0
index|]
operator|&&
name|sig
index|[
literal|1
index|]
operator|==
name|sent_sigs
index|[
literal|1
index|]
condition|)
break|break;
block|}
comment|/* Allow fallback to SHA1 if not strict mode */
if|if
condition|(
name|i
operator|==
name|sent_sigslen
operator|&&
operator|(
name|sig
index|[
literal|0
index|]
operator|!=
name|TLSEXT_hash_sha1
operator|||
name|s
operator|->
name|cert
operator|->
name|cert_flags
operator|&
name|SSL_CERT_FLAGS_CHECK_TLS_STRICT
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS12_CHECK_PEER_SIGALG
argument_list|,
name|SSL_R_WRONG_SIGNATURE_TYPE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|pmd
operator|=
name|tls12_get_hash
argument_list|(
name|sig
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pmd
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS12_CHECK_PEER_SIGALG
argument_list|,
name|SSL_R_UNKNOWN_DIGEST
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*      * Store the digest used so applications can retrieve it if they wish.      */
if|if
condition|(
name|s
operator|->
name|session
operator|&&
name|s
operator|->
name|session
operator|->
name|sess_cert
condition|)
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_key
operator|->
name|digest
operator|=
operator|*
name|pmd
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Get a mask of disabled algorithms: an algorithm is disabled if it isn't  * supported or doesn't appear in supported signature algorithms. Unlike  * ssl_cipher_get_disabled this applies to a specific session and not global  * settings.  */
end_comment

begin_function
name|void
name|ssl_set_client_disabled
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|CERT
modifier|*
name|c
init|=
name|s
operator|->
name|cert
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|sigalgs
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|sigalgslen
decl_stmt|;
name|int
name|have_rsa
init|=
literal|0
decl_stmt|,
name|have_dsa
init|=
literal|0
decl_stmt|,
name|have_ecdsa
init|=
literal|0
decl_stmt|;
name|c
operator|->
name|mask_a
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|mask_k
operator|=
literal|0
expr_stmt|;
comment|/* Don't allow TLS 1.2 only ciphers if we don't suppport them */
if|if
condition|(
operator|!
name|SSL_CLIENT_USE_TLS1_2_CIPHERS
argument_list|(
name|s
argument_list|)
condition|)
name|c
operator|->
name|mask_ssl
operator|=
name|SSL_TLSV1_2
expr_stmt|;
else|else
name|c
operator|->
name|mask_ssl
operator|=
literal|0
expr_stmt|;
comment|/*      * Now go through all signature algorithms seeing if we support any for      * RSA, DSA, ECDSA. Do this for all versions not just TLS 1.2.      */
name|sigalgslen
operator|=
name|tls12_get_psigalgs
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
operator|&
name|sigalgs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sigalgslen
condition|;
name|i
operator|+=
literal|2
operator|,
name|sigalgs
operator|+=
literal|2
control|)
block|{
switch|switch
condition|(
name|sigalgs
index|[
literal|1
index|]
condition|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
case|case
name|TLSEXT_signature_rsa
case|:
name|have_rsa
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
case|case
name|TLSEXT_signature_dsa
case|:
name|have_dsa
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDSA
case|case
name|TLSEXT_signature_ecdsa
case|:
name|have_ecdsa
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
comment|/*      * Disable auth and static DH if we don't include any appropriate      * signature algorithms.      */
if|if
condition|(
operator|!
name|have_rsa
condition|)
block|{
name|c
operator|->
name|mask_a
operator||=
name|SSL_aRSA
expr_stmt|;
name|c
operator|->
name|mask_k
operator||=
name|SSL_kDHr
operator||
name|SSL_kECDHr
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_dsa
condition|)
block|{
name|c
operator|->
name|mask_a
operator||=
name|SSL_aDSS
expr_stmt|;
name|c
operator|->
name|mask_k
operator||=
name|SSL_kDHd
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_ecdsa
condition|)
block|{
name|c
operator|->
name|mask_a
operator||=
name|SSL_aECDSA
expr_stmt|;
name|c
operator|->
name|mask_k
operator||=
name|SSL_kECDHe
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_KRB5
if|if
condition|(
operator|!
name|kssl_tgt_is_available
argument_list|(
name|s
operator|->
name|kssl_ctx
argument_list|)
condition|)
block|{
name|c
operator|->
name|mask_a
operator||=
name|SSL_aKRB5
expr_stmt|;
name|c
operator|->
name|mask_k
operator||=
name|SSL_kKRB5
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_PSK
comment|/* with PSK there must be client callback set */
if|if
condition|(
operator|!
name|s
operator|->
name|psk_client_callback
condition|)
block|{
name|c
operator|->
name|mask_a
operator||=
name|SSL_aPSK
expr_stmt|;
name|c
operator|->
name|mask_k
operator||=
name|SSL_kPSK
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OPENSSL_NO_PSK */
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRP
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|srp_ctx
operator|.
name|srp_Mask
operator|&
name|SSL_kSRP
operator|)
condition|)
block|{
name|c
operator|->
name|mask_a
operator||=
name|SSL_aSRP
expr_stmt|;
name|c
operator|->
name|mask_k
operator||=
name|SSL_kSRP
expr_stmt|;
block|}
endif|#
directive|endif
name|c
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
name|ssl_add_clienthello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|char
modifier|*
name|limit
parameter_list|,
name|int
modifier|*
name|al
parameter_list|)
block|{
name|int
name|extdatalen
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|orig
init|=
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ret
init|=
name|buf
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
comment|/* See if we support any ECC ciphersuites */
name|int
name|using_ecc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|version
operator|>=
name|TLS1_VERSION
operator|||
name|SSL_IS_DTLS
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|alg_k
decl_stmt|,
name|alg_a
decl_stmt|;
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|cipher_stack
operator|=
name|SSL_get_ciphers
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_SSL_CIPHER_num
argument_list|(
name|cipher_stack
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|SSL_CIPHER
modifier|*
name|c
init|=
name|sk_SSL_CIPHER_value
argument_list|(
name|cipher_stack
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|alg_k
operator|=
name|c
operator|->
name|algorithm_mkey
expr_stmt|;
name|alg_a
operator|=
name|c
operator|->
name|algorithm_auth
expr_stmt|;
if|if
condition|(
operator|(
name|alg_k
operator|&
operator|(
name|SSL_kEECDH
operator||
name|SSL_kECDHr
operator||
name|SSL_kECDHe
operator|)
operator|||
operator|(
name|alg_a
operator|&
name|SSL_aECDSA
operator|)
operator|)
condition|)
block|{
name|using_ecc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* don't add extensions for SSLv3 unless doing secure renegotiation */
if|if
condition|(
name|s
operator|->
name|client_version
operator|==
name|SSL3_VERSION
operator|&&
operator|!
name|s
operator|->
name|s3
operator|->
name|send_connection_binding
condition|)
return|return
name|orig
return|;
name|ret
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
name|limit
condition|)
return|return
name|NULL
return|;
comment|/* this really never occurs, but ... */
if|if
condition|(
name|s
operator|->
name|tlsext_hostname
operator|!=
name|NULL
condition|)
block|{
comment|/* Add TLS extension servername to the Client Hello message */
name|size_t
name|size_str
decl_stmt|;
comment|/*-          * check for enough space.          * 4 for the servername type and entension length          * 2 for servernamelist length          * 1 for the hostname type          * 2 for hostname length          * + hostname length          */
name|size_str
operator|=
name|strlen
argument_list|(
name|s
operator|->
name|tlsext_hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|9
operator|+
name|size_str
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* extension type and length */
name|s2n
argument_list|(
name|TLSEXT_TYPE_server_name
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|size_str
operator|+
literal|5
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* length of servername list */
name|s2n
argument_list|(
name|size_str
operator|+
literal|3
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* hostname type, length and hostname */
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
operator|(
name|unsigned
name|char
operator|)
name|TLSEXT_NAMETYPE_host_name
expr_stmt|;
name|s2n
argument_list|(
name|size_str
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|s
operator|->
name|tlsext_hostname
argument_list|,
name|size_str
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|size_str
expr_stmt|;
block|}
comment|/* Add RI if renegotiating */
if|if
condition|(
name|s
operator|->
name|renegotiate
condition|)
block|{
name|int
name|el
decl_stmt|;
if|if
condition|(
operator|!
name|ssl_add_clienthello_renegotiate_ext
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|el
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|limit
operator|-
name|ret
operator|-
literal|4
operator|-
name|el
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_renegotiate
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|el
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_add_clienthello_renegotiate_ext
argument_list|(
name|s
argument_list|,
name|ret
argument_list|,
operator|&
name|el
argument_list|,
name|el
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|+=
name|el
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRP
comment|/* Add SRP username if there is one */
if|if
condition|(
name|s
operator|->
name|srp_ctx
operator|.
name|login
operator|!=
name|NULL
condition|)
block|{
comment|/* Add TLS extension SRP username to the                                      * Client Hello message */
name|size_t
name|login_len
init|=
name|strlen
argument_list|(
name|s
operator|->
name|srp_ctx
operator|.
name|login
argument_list|)
decl_stmt|;
if|if
condition|(
name|login_len
operator|>
literal|255
operator|||
name|login_len
operator|==
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*-          * check for enough space.          * 4 for the srp type type and entension length          * 1 for the srp user identity          * + srp user identity length          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|5
operator|+
name|login_len
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* fill in the extension */
name|s2n
argument_list|(
name|TLSEXT_TYPE_srp
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|login_len
operator|+
literal|1
argument_list|,
name|ret
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ret
operator|++
operator|)
operator|=
operator|(
name|unsigned
name|char
operator|)
name|login_len
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|s
operator|->
name|srp_ctx
operator|.
name|login
argument_list|,
name|login_len
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|login_len
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
if|if
condition|(
name|using_ecc
condition|)
block|{
comment|/*          * Add TLS extension ECPointFormats to the ClientHello message          */
specifier|const
name|unsigned
name|char
modifier|*
name|pcurves
decl_stmt|,
modifier|*
name|pformats
decl_stmt|;
name|size_t
name|num_curves
decl_stmt|,
name|num_formats
decl_stmt|,
name|curves_list_len
decl_stmt|;
name|tls1_get_formatlist
argument_list|(
name|s
argument_list|,
operator|&
name|pformats
argument_list|,
operator|&
name|num_formats
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_formats
operator|>
literal|255
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*-          * check for enough space.          * 4 bytes for the ec point formats type and extension length          * 1 byte for the length of the formats          * + formats length          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|5
operator|+
name|num_formats
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_ec_point_formats
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* The point format list has 1-byte length. */
name|s2n
argument_list|(
name|num_formats
operator|+
literal|1
argument_list|,
name|ret
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
operator|(
name|unsigned
name|char
operator|)
name|num_formats
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|pformats
argument_list|,
name|num_formats
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|num_formats
expr_stmt|;
comment|/*          * Add TLS extension EllipticCurves to the ClientHello message          */
name|pcurves
operator|=
name|s
operator|->
name|tlsext_ellipticcurvelist
expr_stmt|;
if|if
condition|(
operator|!
name|tls1_get_curvelist
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|pcurves
argument_list|,
operator|&
name|num_curves
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|num_curves
operator|>
literal|65532
operator|/
literal|2
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|curves_list_len
operator|=
literal|2
operator|*
name|num_curves
expr_stmt|;
comment|/*-          * check for enough space.          * 4 bytes for the ec curves type and extension length          * 2 bytes for the curve list length          * + curve list length          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|6
operator|+
name|curves_list_len
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_elliptic_curves
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|curves_list_len
operator|+
literal|2
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|curves_list_len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|pcurves
argument_list|,
name|curves_list_len
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|curves_list_len
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OPENSSL_NO_EC */
if|if
condition|(
operator|!
operator|(
name|SSL_get_options
argument_list|(
name|s
argument_list|)
operator|&
name|SSL_OP_NO_TICKET
operator|)
condition|)
block|{
name|size_t
name|ticklen
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|new_session
operator|&&
name|s
operator|->
name|session
operator|&&
name|s
operator|->
name|session
operator|->
name|tlsext_tick
condition|)
name|ticklen
operator|=
name|s
operator|->
name|session
operator|->
name|tlsext_ticklen
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|session
operator|&&
name|s
operator|->
name|tlsext_session_ticket
operator|&&
name|s
operator|->
name|tlsext_session_ticket
operator|->
name|data
condition|)
block|{
name|ticklen
operator|=
name|s
operator|->
name|tlsext_session_ticket
operator|->
name|length
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|tlsext_tick
operator|=
name|OPENSSL_malloc
argument_list|(
name|ticklen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|session
operator|->
name|tlsext_tick
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_tick
argument_list|,
name|s
operator|->
name|tlsext_session_ticket
operator|->
name|data
argument_list|,
name|ticklen
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|tlsext_ticklen
operator|=
name|ticklen
expr_stmt|;
block|}
else|else
name|ticklen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ticklen
operator|==
literal|0
operator|&&
name|s
operator|->
name|tlsext_session_ticket
operator|&&
name|s
operator|->
name|tlsext_session_ticket
operator|->
name|data
operator|==
name|NULL
condition|)
goto|goto
name|skip_ext
goto|;
comment|/*          * Check for enough room 2 for extension type, 2 for len rest for          * ticket          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|4
operator|+
name|ticklen
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_session_ticket
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|ticklen
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ticklen
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|ret
argument_list|,
name|s
operator|->
name|session
operator|->
name|tlsext_tick
argument_list|,
name|ticklen
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|ticklen
expr_stmt|;
block|}
block|}
name|skip_ext
label|:
if|if
condition|(
name|SSL_CLIENT_USE_SIGALGS
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|size_t
name|salglen
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|salg
decl_stmt|;
name|salglen
operator|=
name|tls12_get_psigalgs
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
operator|&
name|salg
argument_list|)
expr_stmt|;
comment|/*-          * check for enough space.          * 4 bytes for the sigalgs type and extension length          * 2 bytes for the sigalg list length          * + sigalg list length          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
name|salglen
operator|+
literal|6
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_signature_algorithms
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|salglen
operator|+
literal|2
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|salglen
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|salg
argument_list|,
name|salglen
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|salglen
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TLSEXT_TYPE_opaque_prf_input
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|col
init|=
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
decl_stmt|;
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|limit
operator|-
name|ret
operator|-
literal|6
operator|-
name|col
operator|<
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|col
operator|>
literal|0xFFFD
condition|)
comment|/* can't happen */
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_opaque_prf_input
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|col
operator|+
literal|2
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|col
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|col
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|tlsext_status_type
operator|==
name|TLSEXT_STATUSTYPE_ocsp
condition|)
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|extlen
decl_stmt|,
name|idlen
decl_stmt|;
name|int
name|lentmp
decl_stmt|;
name|OCSP_RESPID
modifier|*
name|id
decl_stmt|;
name|idlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_OCSP_RESPID_num
argument_list|(
name|s
operator|->
name|tlsext_ocsp_ids
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|=
name|sk_OCSP_RESPID_value
argument_list|(
name|s
operator|->
name|tlsext_ocsp_ids
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lentmp
operator|=
name|i2d_OCSP_RESPID
argument_list|(
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lentmp
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
name|idlen
operator|+=
operator|(
name|size_t
operator|)
name|lentmp
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|tlsext_ocsp_exts
condition|)
block|{
name|lentmp
operator|=
name|i2d_X509_EXTENSIONS
argument_list|(
name|s
operator|->
name|tlsext_ocsp_exts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lentmp
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|extlen
operator|=
operator|(
name|size_t
operator|)
name|lentmp
expr_stmt|;
block|}
else|else
name|extlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|extlen
operator|+
name|idlen
operator|>
literal|0xFFF0
condition|)
return|return
name|NULL
return|;
comment|/*          * 2 bytes for status request type          * 2 bytes for status request len          * 1 byte for OCSP request type          * 2 bytes for length of ids          * 2 bytes for length of extensions          * + length of ids          * + length of extensions          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|9
operator|+
name|idlen
operator|+
name|extlen
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_status_request
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|extlen
operator|+
name|idlen
operator|+
literal|5
argument_list|,
name|ret
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
name|TLSEXT_STATUSTYPE_ocsp
expr_stmt|;
name|s2n
argument_list|(
name|idlen
argument_list|,
name|ret
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_OCSP_RESPID_num
argument_list|(
name|s
operator|->
name|tlsext_ocsp_ids
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* save position of id len */
name|unsigned
name|char
modifier|*
name|q
init|=
name|ret
decl_stmt|;
name|id
operator|=
name|sk_OCSP_RESPID_value
argument_list|(
name|s
operator|->
name|tlsext_ocsp_ids
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* skip over id len */
name|ret
operator|+=
literal|2
expr_stmt|;
name|lentmp
operator|=
name|i2d_OCSP_RESPID
argument_list|(
name|id
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
comment|/* write id len */
name|s2n
argument_list|(
name|lentmp
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
name|s2n
argument_list|(
name|extlen
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|extlen
operator|>
literal|0
condition|)
name|i2d_X509_EXTENSIONS
argument_list|(
name|s
operator|->
name|tlsext_ocsp_exts
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
comment|/* Add Heartbeat extension */
comment|/*-      * check for enough space.      * 4 bytes for the heartbeat ext type and extension length      * 1 byte for the mode      */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|5
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_heartbeat
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
literal|1
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/*-      * Set mode:      * 1: peer may send requests      * 2: peer not allowed to send requests      */
if|if
condition|(
name|s
operator|->
name|tlsext_heartbeat
operator|&
name|SSL_TLSEXT_HB_DONT_RECV_REQUESTS
condition|)
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
expr_stmt|;
else|else
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
name|SSL_TLSEXT_HB_ENABLED
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|next_proto_select_cb
operator|&&
operator|!
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md_len
condition|)
block|{
comment|/*          * The client advertises an emtpy extension to indicate its support          * for Next Protocol Negotiation          */
comment|/*-          * check for enough space.          * 4 bytes for the NPN ext type and extension length          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|4
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_next_proto_neg
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|alpn_client_proto_list
operator|&&
operator|!
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md_len
condition|)
block|{
comment|/*-          * check for enough space.          * 4 bytes for the ALPN type and extension length          * 2 bytes for the ALPN protocol list length          * + ALPN protocol list length          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|6
operator|+
name|s
operator|->
name|alpn_client_proto_list_len
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_application_layer_protocol_negotiation
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
literal|2
operator|+
name|s
operator|->
name|alpn_client_proto_list_len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|s
operator|->
name|alpn_client_proto_list_len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|s
operator|->
name|alpn_client_proto_list
argument_list|,
name|s
operator|->
name|alpn_client_proto_list_len
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|s
operator|->
name|alpn_client_proto_list_len
expr_stmt|;
name|s
operator|->
name|cert
operator|->
name|alpn_sent
operator|=
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRTP
if|if
condition|(
name|SSL_IS_DTLS
argument_list|(
name|s
argument_list|)
operator|&&
name|SSL_get_srtp_profiles
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|int
name|el
decl_stmt|;
name|ssl_add_clienthello_use_srtp_ext
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|el
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*-          * check for enough space.          * 4 bytes for the SRTP type and extension length          * + SRTP profiles length          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|4
operator|+
name|el
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_use_srtp
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|el
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl_add_clienthello_use_srtp_ext
argument_list|(
name|s
argument_list|,
name|ret
argument_list|,
operator|&
name|el
argument_list|,
name|el
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|+=
name|el
expr_stmt|;
block|}
endif|#
directive|endif
name|custom_ext_init
argument_list|(
operator|&
name|s
operator|->
name|cert
operator|->
name|cli_ext
argument_list|)
expr_stmt|;
comment|/* Add custom TLS Extensions to ClientHello */
if|if
condition|(
operator|!
name|custom_ext_add
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|ret
argument_list|,
name|limit
argument_list|,
name|al
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/*      * Add padding to workaround bugs in F5 terminators. See      * https://tools.ietf.org/html/draft-agl-tls-padding-03 NB: because this      * code works out the length of all existing extensions it MUST always      * appear last.      */
if|if
condition|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_TLSEXT_PADDING
condition|)
block|{
name|int
name|hlen
init|=
name|ret
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
decl_stmt|;
comment|/*          * The code in s23_clnt.c to build ClientHello messages includes the          * 5-byte record header in the buffer, while the code in s3_clnt.c          * does not.          */
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL23_ST_CW_CLNT_HELLO_A
condition|)
name|hlen
operator|-=
literal|5
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
literal|0xff
operator|&&
name|hlen
operator|<
literal|0x200
condition|)
block|{
name|hlen
operator|=
literal|0x200
operator|-
name|hlen
expr_stmt|;
if|if
condition|(
name|hlen
operator|>=
literal|4
condition|)
name|hlen
operator|-=
literal|4
expr_stmt|;
else|else
name|hlen
operator|=
literal|0
expr_stmt|;
comment|/*-              * check for enough space. Strictly speaking we know we've already              * got enough space because to get here the message size is< 0x200,              * but we know that we've allocated far more than that in the buffer              * - but for consistency and robustness we're going to check anyway.              *              * 4 bytes for the padding type and extension length              * + padding length              */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|4
operator|+
name|hlen
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_padding
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|hlen
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|hlen
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|extdatalen
operator|=
name|ret
operator|-
name|orig
operator|-
literal|2
operator|)
operator|==
literal|0
condition|)
return|return
name|orig
return|;
name|s2n
argument_list|(
name|extdatalen
argument_list|,
name|orig
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
name|ssl_add_serverhello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|char
modifier|*
name|limit
parameter_list|,
name|int
modifier|*
name|al
parameter_list|)
block|{
name|int
name|extdatalen
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|orig
init|=
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ret
init|=
name|buf
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
name|int
name|next_proto_neg_seen
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
name|unsigned
name|long
name|alg_k
init|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_mkey
decl_stmt|;
name|unsigned
name|long
name|alg_a
init|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_auth
decl_stmt|;
name|int
name|using_ecc
init|=
operator|(
name|alg_k
operator|&
operator|(
name|SSL_kEECDH
operator||
name|SSL_kECDHr
operator||
name|SSL_kECDHe
operator|)
operator|)
operator|||
operator|(
name|alg_a
operator|&
name|SSL_aECDSA
operator|)
decl_stmt|;
name|using_ecc
operator|=
name|using_ecc
operator|&&
operator|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
operator|!=
name|NULL
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * don't add extensions for SSLv3, unless doing secure renegotiation      */
if|if
condition|(
name|s
operator|->
name|version
operator|==
name|SSL3_VERSION
operator|&&
operator|!
name|s
operator|->
name|s3
operator|->
name|send_connection_binding
condition|)
return|return
name|orig
return|;
name|ret
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
name|limit
condition|)
return|return
name|NULL
return|;
comment|/* this really never occurs, but ... */
if|if
condition|(
operator|!
name|s
operator|->
name|hit
operator|&&
name|s
operator|->
name|servername_done
operator|==
literal|1
operator|&&
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|limit
operator|-
name|ret
operator|-
literal|4
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_server_name
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|send_connection_binding
condition|)
block|{
name|int
name|el
decl_stmt|;
if|if
condition|(
operator|!
name|ssl_add_serverhello_renegotiate_ext
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|el
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_SERVERHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*-          * check for enough space.          * 4 bytes for the reneg type and extension length          * + reneg data length          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|4
operator|+
name|el
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_renegotiate
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|el
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_add_serverhello_renegotiate_ext
argument_list|(
name|s
argument_list|,
name|ret
argument_list|,
operator|&
name|el
argument_list|,
name|el
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_SERVERHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|+=
name|el
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
if|if
condition|(
name|using_ecc
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|plist
decl_stmt|;
name|size_t
name|plistlen
decl_stmt|;
comment|/*          * Add TLS extension ECPointFormats to the ServerHello message          */
name|tls1_get_formatlist
argument_list|(
name|s
argument_list|,
operator|&
name|plist
argument_list|,
operator|&
name|plistlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|plistlen
operator|>
literal|255
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_SERVERHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*-          * check for enough space.          * 4 bytes for the ec points format type and extension length          * 1 byte for the points format list length          * + length of points format list          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|5
operator|+
name|plistlen
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_ec_point_formats
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|plistlen
operator|+
literal|1
argument_list|,
name|ret
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
operator|(
name|unsigned
name|char
operator|)
name|plistlen
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|plist
argument_list|,
name|plistlen
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|plistlen
expr_stmt|;
block|}
comment|/*      * Currently the server should not respond with a SupportedCurves      * extension      */
endif|#
directive|endif
comment|/* OPENSSL_NO_EC */
if|if
condition|(
name|s
operator|->
name|tlsext_ticket_expected
operator|&&
operator|!
operator|(
name|SSL_get_options
argument_list|(
name|s
argument_list|)
operator|&
name|SSL_OP_NO_TICKET
operator|)
condition|)
block|{
comment|/*-          * check for enough space.          * 4 bytes for the Ticket type and extension length          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|4
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_session_ticket
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if we don't add the above TLSEXT, we can't add a session ticket later */
name|s
operator|->
name|tlsext_ticket_expected
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|tlsext_status_expected
condition|)
block|{
comment|/*-          * check for enough space.          * 4 bytes for the Status request type and extension length          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|4
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_status_request
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TLSEXT_TYPE_opaque_prf_input
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|sol
init|=
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
decl_stmt|;
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|limit
operator|-
name|ret
operator|-
literal|6
operator|-
name|sol
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|sol
operator|>
literal|0xFFFD
condition|)
comment|/* can't happen */
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_opaque_prf_input
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|sol
operator|+
literal|2
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|sol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
argument_list|,
name|sol
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|sol
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRTP
if|if
condition|(
name|SSL_IS_DTLS
argument_list|(
name|s
argument_list|)
operator|&&
name|s
operator|->
name|srtp_profile
condition|)
block|{
name|int
name|el
decl_stmt|;
name|ssl_add_serverhello_use_srtp_ext
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|el
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*-          * check for enough space.          * 4 bytes for the SRTP profiles type and extension length          * + length of the SRTP profiles list          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|4
operator|+
name|el
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_use_srtp
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|el
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl_add_serverhello_use_srtp_ext
argument_list|(
name|s
argument_list|,
name|ret
argument_list|,
operator|&
name|el
argument_list|,
name|el
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_ADD_SERVERHELLO_TLSEXT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|+=
name|el
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|id
operator|&
literal|0xFFFF
operator|)
operator|==
literal|0x80
operator|||
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|id
operator|&
literal|0xFFFF
operator|)
operator|==
literal|0x81
operator|)
operator|&&
operator|(
name|SSL_get_options
argument_list|(
name|s
argument_list|)
operator|&
name|SSL_OP_CRYPTOPRO_TLSEXT_BUG
operator|)
condition|)
block|{
specifier|const
name|unsigned
name|char
name|cryptopro_ext
index|[
literal|36
index|]
init|=
block|{
literal|0xfd
block|,
literal|0xe8
block|,
comment|/* 65000 */
literal|0x00
block|,
literal|0x20
block|,
comment|/* 32 bytes length */
literal|0x30
block|,
literal|0x1e
block|,
literal|0x30
block|,
literal|0x08
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x2a
block|,
literal|0x85
block|,
literal|0x03
block|,
literal|0x02
block|,
literal|0x02
block|,
literal|0x09
block|,
literal|0x30
block|,
literal|0x08
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x2a
block|,
literal|0x85
block|,
literal|0x03
block|,
literal|0x02
block|,
literal|0x02
block|,
literal|0x16
block|,
literal|0x30
block|,
literal|0x08
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x2a
block|,
literal|0x85
block|,
literal|0x03
block|,
literal|0x02
block|,
literal|0x02
block|,
literal|0x17
block|}
decl_stmt|;
comment|/* check for enough space. */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|cryptopro_ext
argument_list|)
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|cryptopro_ext
argument_list|,
sizeof|sizeof
argument_list|(
name|cryptopro_ext
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|+=
sizeof|sizeof
argument_list|(
name|cryptopro_ext
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
comment|/* Add Heartbeat extension if we've received one */
if|if
condition|(
name|s
operator|->
name|tlsext_heartbeat
operator|&
name|SSL_TLSEXT_HB_ENABLED
condition|)
block|{
comment|/*-          * check for enough space.          * 4 bytes for the Heartbeat type and extension length          * 1 byte for the mode          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|5
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_heartbeat
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
literal|1
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/*-          * Set mode:          * 1: peer may send requests          * 2: peer not allowed to send requests          */
if|if
condition|(
name|s
operator|->
name|tlsext_heartbeat
operator|&
name|SSL_TLSEXT_HB_DONT_RECV_REQUESTS
condition|)
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
expr_stmt|;
else|else
operator|*
operator|(
name|ret
operator|++
operator|)
operator|=
name|SSL_TLSEXT_HB_ENABLED
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
name|next_proto_neg_seen
operator|=
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|next_proto_neg_seen
operator|&&
name|s
operator|->
name|ctx
operator|->
name|next_protos_advertised_cb
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|npa
decl_stmt|;
name|unsigned
name|int
name|npalen
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|s
operator|->
name|ctx
operator|->
name|next_protos_advertised_cb
argument_list|(
name|s
argument_list|,
operator|&
name|npa
argument_list|,
operator|&
name|npalen
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|next_protos_advertised_cb_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|SSL_TLSEXT_ERR_OK
condition|)
block|{
comment|/*-              * check for enough space.              * 4 bytes for the NPN type and extension length              * + length of protocols list              */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|4
operator|+
name|npalen
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_next_proto_neg
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|npalen
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|npa
argument_list|,
name|npalen
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|npalen
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|custom_ext_add
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
operator|&
name|ret
argument_list|,
name|limit
argument_list|,
name|al
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|alpn_selected
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|selected
init|=
name|s
operator|->
name|s3
operator|->
name|alpn_selected
decl_stmt|;
name|size_t
name|len
init|=
name|s
operator|->
name|s3
operator|->
name|alpn_selected_len
decl_stmt|;
comment|/*-          * check for enough space.          * 4 bytes for the ALPN type and extension length          * 2 bytes for ALPN data length          * 1 byte for selected protocol length          * + length of the selected protocol          */
if|if
condition|(
name|CHECKLEN
argument_list|(
name|ret
argument_list|,
literal|7
operator|+
name|len
argument_list|,
name|limit
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s2n
argument_list|(
name|TLSEXT_TYPE_application_layer_protocol_negotiation
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
literal|3
operator|+
name|len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
literal|1
operator|+
name|len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|++
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|selected
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|extdatalen
operator|=
name|ret
operator|-
name|orig
operator|-
literal|2
operator|)
operator|==
literal|0
condition|)
return|return
name|orig
return|;
name|s2n
argument_list|(
name|extdatalen
argument_list|,
name|orig
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
end_ifndef

begin_comment
comment|/*-  * ssl_check_for_safari attempts to fingerprint Safari using OS X  * SecureTransport using the TLS extension block in |d|, of length |n|.  * Safari, since 10.6, sends exactly these extensions, in this order:  *   SNI,  *   elliptic_curves  *   ec_point_formats  *  * We wish to fingerprint Safari because they broke ECDHE-ECDSA support in 10.8,  * but they advertise support. So enabling ECDHE-ECDSA ciphers breaks them.  * Sadly we cannot differentiate 10.6, 10.7 and 10.8.4 (which work), from  * 10.8..10.8.3 (which don't work).  */
end_comment

begin_function
specifier|static
name|void
name|ssl_check_for_safari
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|limit
parameter_list|)
block|{
name|unsigned
name|short
name|type
decl_stmt|,
name|size
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|char
name|kSafariExtensionsBlock
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x0a
block|,
comment|/* elliptic_curves extension */
literal|0x00
block|,
literal|0x08
block|,
comment|/* 8 bytes */
literal|0x00
block|,
literal|0x06
block|,
comment|/* 6 bytes of curve ids */
literal|0x00
block|,
literal|0x17
block|,
comment|/* P-256 */
literal|0x00
block|,
literal|0x18
block|,
comment|/* P-384 */
literal|0x00
block|,
literal|0x19
block|,
comment|/* P-521 */
literal|0x00
block|,
literal|0x0b
block|,
comment|/* ec_point_formats */
literal|0x00
block|,
literal|0x02
block|,
comment|/* 2 bytes */
literal|0x01
block|,
comment|/* 1 point format */
literal|0x00
block|,
comment|/* uncompressed */
block|}
decl_stmt|;
comment|/* The following is only present in TLS 1.2 */
specifier|static
specifier|const
name|unsigned
name|char
name|kSafariTLS12ExtensionsBlock
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x0d
block|,
comment|/* signature_algorithms */
literal|0x00
block|,
literal|0x0c
block|,
comment|/* 12 bytes */
literal|0x00
block|,
literal|0x0a
block|,
comment|/* 10 bytes */
literal|0x05
block|,
literal|0x01
block|,
comment|/* SHA-384/RSA */
literal|0x04
block|,
literal|0x01
block|,
comment|/* SHA-256/RSA */
literal|0x02
block|,
literal|0x01
block|,
comment|/* SHA-1/RSA */
literal|0x04
block|,
literal|0x03
block|,
comment|/* SHA-256/ECDSA */
literal|0x02
block|,
literal|0x03
block|,
comment|/* SHA-1/ECDSA */
block|}
decl_stmt|;
if|if
condition|(
name|limit
operator|-
name|data
operator|<=
literal|2
condition|)
return|return;
name|data
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|limit
operator|-
name|data
operator|<
literal|4
condition|)
return|return;
name|n2s
argument_list|(
name|data
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|n2s
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TLSEXT_TYPE_server_name
condition|)
return|return;
if|if
condition|(
name|limit
operator|-
name|data
operator|<
name|size
condition|)
return|return;
name|data
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|TLS1_get_client_version
argument_list|(
name|s
argument_list|)
operator|>=
name|TLS1_2_VERSION
condition|)
block|{
specifier|const
name|size_t
name|len1
init|=
sizeof|sizeof
argument_list|(
name|kSafariExtensionsBlock
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|len2
init|=
sizeof|sizeof
argument_list|(
name|kSafariTLS12ExtensionsBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|limit
operator|-
name|data
operator|!=
call|(
name|int
call|)
argument_list|(
name|len1
operator|+
name|len2
argument_list|)
condition|)
return|return;
if|if
condition|(
name|memcmp
argument_list|(
name|data
argument_list|,
name|kSafariExtensionsBlock
argument_list|,
name|len1
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|memcmp
argument_list|(
name|data
operator|+
name|len1
argument_list|,
name|kSafariTLS12ExtensionsBlock
argument_list|,
name|len2
argument_list|)
operator|!=
literal|0
condition|)
return|return;
block|}
else|else
block|{
specifier|const
name|size_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|kSafariExtensionsBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|limit
operator|-
name|data
operator|!=
call|(
name|int
call|)
argument_list|(
name|len
argument_list|)
condition|)
return|return;
if|if
condition|(
name|memcmp
argument_list|(
name|data
argument_list|,
name|kSafariExtensionsBlock
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
return|return;
block|}
name|s
operator|->
name|s3
operator|->
name|is_probably_safari
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_EC */
end_comment

begin_comment
comment|/*  * tls1_alpn_handle_client_hello is called to save the ALPN extension in a  * ClientHello.  data: the contents of the extension, not including the type  * and length.  data_len: the number of bytes in |data| al: a pointer to the  * alert value to send in the event of a non-zero return.  returns: 0 on  * success.  */
end_comment

begin_function
specifier|static
name|int
name|tls1_alpn_handle_client_hello
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|data_len
parameter_list|,
name|int
modifier|*
name|al
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|proto_len
decl_stmt|;
if|if
condition|(
name|data_len
operator|<
literal|2
condition|)
goto|goto
name|parse_error
goto|;
comment|/*      * data should contain a uint16 length followed by a series of 8-bit,      * length-prefixed strings.      */
name|i
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|data
index|[
literal|0
index|]
operator|)
operator|<<
literal|8
operator||
operator|(
operator|(
name|unsigned
operator|)
name|data
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|data_len
operator|-=
literal|2
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|data_len
operator|!=
name|i
condition|)
goto|goto
name|parse_error
goto|;
if|if
condition|(
name|data_len
operator|<
literal|2
condition|)
goto|goto
name|parse_error
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data_len
condition|;
control|)
block|{
name|proto_len
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|proto_len
operator|==
literal|0
condition|)
goto|goto
name|parse_error
goto|;
if|if
condition|(
name|i
operator|+
name|proto_len
operator|<
name|i
operator|||
name|i
operator|+
name|proto_len
operator|>
name|data_len
condition|)
goto|goto
name|parse_error
goto|;
name|i
operator|+=
name|proto_len
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|alpn_proposed
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|cert
operator|->
name|alpn_proposed
argument_list|)
expr_stmt|;
name|s
operator|->
name|cert
operator|->
name|alpn_proposed
operator|=
name|OPENSSL_malloc
argument_list|(
name|data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|alpn_proposed
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|s
operator|->
name|cert
operator|->
name|alpn_proposed
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|s
operator|->
name|cert
operator|->
name|alpn_proposed_len
operator|=
name|data_len
expr_stmt|;
return|return
literal|0
return|;
name|parse_error
label|:
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Process the ALPN extension in a ClientHello.  * al: a pointer to the alert value to send in the event of a failure.  * returns 1 on success, 0 on failure: al set only on failure  */
end_comment

begin_function
specifier|static
name|int
name|tls1_alpn_handle_client_hello_late
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|al
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|selected
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|selected_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|alpn_select_cb
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|cert
operator|->
name|alpn_proposed
operator|!=
name|NULL
condition|)
block|{
name|int
name|r
init|=
name|s
operator|->
name|ctx
operator|->
name|alpn_select_cb
argument_list|(
name|s
argument_list|,
operator|&
name|selected
argument_list|,
operator|&
name|selected_len
argument_list|,
name|s
operator|->
name|cert
operator|->
name|alpn_proposed
argument_list|,
name|s
operator|->
name|cert
operator|->
name|alpn_proposed_len
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|alpn_select_cb_arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|SSL_TLSEXT_ERR_OK
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|s3
operator|->
name|alpn_selected
argument_list|)
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|alpn_selected
operator|=
name|OPENSSL_malloc
argument_list|(
name|selected_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|alpn_selected
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|s
operator|->
name|s3
operator|->
name|alpn_selected
argument_list|,
name|selected
argument_list|,
name|selected_len
argument_list|)
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|alpn_selected_len
operator|=
name|selected_len
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
comment|/* ALPN takes precedence over NPN. */
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ssl_scan_clienthello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
modifier|*
name|limit
parameter_list|,
name|int
modifier|*
name|al
parameter_list|)
block|{
name|unsigned
name|short
name|type
decl_stmt|;
name|unsigned
name|short
name|size
decl_stmt|;
name|unsigned
name|short
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
init|=
operator|*
name|p
decl_stmt|;
name|int
name|renegotiate_seen
init|=
literal|0
decl_stmt|;
name|s
operator|->
name|servername_done
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|tlsext_status_type
operator|=
operator|-
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|alpn_selected
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|s3
operator|->
name|alpn_selected
argument_list|)
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|alpn_selected
operator|=
name|NULL
expr_stmt|;
block|}
name|s
operator|->
name|s3
operator|->
name|alpn_selected_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|alpn_proposed
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|cert
operator|->
name|alpn_proposed
argument_list|)
expr_stmt|;
name|s
operator|->
name|cert
operator|->
name|alpn_proposed
operator|=
name|NULL
expr_stmt|;
block|}
name|s
operator|->
name|cert
operator|->
name|alpn_proposed_len
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
name|s
operator|->
name|tlsext_heartbeat
operator|&=
operator|~
operator|(
name|SSL_TLSEXT_HB_ENABLED
operator||
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
operator|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
if|if
condition|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_SAFARI_ECDHE_ECDSA_BUG
condition|)
name|ssl_check_for_safari
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !OPENSSL_NO_EC */
comment|/* Clear any signature algorithms extension received */
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|peer_sigalgs
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|cert
operator|->
name|peer_sigalgs
argument_list|)
expr_stmt|;
name|s
operator|->
name|cert
operator|->
name|peer_sigalgs
operator|=
name|NULL
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRP
if|if
condition|(
name|s
operator|->
name|srp_ctx
operator|.
name|login
operator|!=
name|NULL
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|srp_ctx
operator|.
name|login
argument_list|)
expr_stmt|;
name|s
operator|->
name|srp_ctx
operator|.
name|login
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|->
name|srtp_profile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|limit
condition|)
goto|goto
name|ri_check
goto|;
if|if
condition|(
name|limit
operator|-
name|data
operator|<
literal|2
condition|)
goto|goto
name|err
goto|;
name|n2s
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|-
name|data
operator|!=
name|len
condition|)
goto|goto
name|err
goto|;
while|while
condition|(
name|limit
operator|-
name|data
operator|>=
literal|4
condition|)
block|{
name|n2s
argument_list|(
name|data
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|n2s
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|-
name|data
operator|<
name|size
condition|)
goto|goto
name|err
goto|;
if|#
directive|if
literal|0
block|fprintf(stderr, "Received extension type %d size %d\n", type, size);
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|tlsext_debug_cb
condition|)
name|s
operator|->
name|tlsext_debug_cb
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|s
operator|->
name|tlsext_debug_arg
argument_list|)
expr_stmt|;
comment|/*-  * The servername extension is treated as follows:  *  * - Only the hostname type is supported with a maximum length of 255.  * - The servername is rejected if too long or if it contains zeros,  *   in which case an fatal alert is generated.  * - The servername field is maintained together with the session cache.  * - When a session is resumed, the servername call back invoked in order  *   to allow the application to position itself to the right context.  * - The servername is acknowledged if it is new for a session or when  *   it is identical to a previously used for the same session.  *   Applications can control the behaviour.  They can at any time  *   set a 'desirable' servername for a new SSL object. This can be the  *   case for example with HTTPS when a Host: header field is received and  *   a renegotiation is requested. In this case, a possible servername  *   presented in the new client hello is only acknowledged if it matches  *   the value of the Host: field.  * - Applications must  use SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION  *   if they provide for changing an explicit servername context for the  *   session, i.e. when the session has been established with a servername  *   extension.  * - On session reconnect, the servername extension may be absent.  *  */
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_server_name
condition|)
block|{
name|unsigned
name|char
modifier|*
name|sdata
decl_stmt|;
name|int
name|servname_type
decl_stmt|;
name|int
name|dsize
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|2
condition|)
goto|goto
name|err
goto|;
name|n2s
argument_list|(
name|data
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|size
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|dsize
operator|>
name|size
condition|)
goto|goto
name|err
goto|;
name|sdata
operator|=
name|data
expr_stmt|;
while|while
condition|(
name|dsize
operator|>
literal|3
condition|)
block|{
name|servname_type
operator|=
operator|*
operator|(
name|sdata
operator|++
operator|)
expr_stmt|;
name|n2s
argument_list|(
name|sdata
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dsize
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|dsize
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|s
operator|->
name|servername_done
operator|==
literal|0
condition|)
switch|switch
condition|(
name|servname_type
condition|)
block|{
case|case
name|TLSEXT_NAMETYPE_host_name
case|:
if|if
condition|(
operator|!
name|s
operator|->
name|hit
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|len
operator|>
name|TLSEXT_MAXLEN_host_name
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_UNRECOGNIZED_NAME
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
argument_list|,
name|sdata
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
argument_list|)
operator|!=
name|len
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
operator|=
name|NULL
expr_stmt|;
operator|*
name|al
operator|=
name|TLS1_AD_UNRECOGNIZED_NAME
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|->
name|servername_done
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|s
operator|->
name|servername_done
operator|=
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
operator|&&
name|strlen
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
argument_list|)
operator|==
name|len
operator|&&
name|strncmp
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sdata
argument_list|,
name|len
argument_list|)
operator|==
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|dsize
operator|-=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|dsize
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRP
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_srp
condition|)
block|{
if|if
condition|(
name|size
operator|==
literal|0
operator|||
operator|(
operator|(
name|len
operator|=
name|data
index|[
literal|0
index|]
operator|)
operator|)
operator|!=
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|s
operator|->
name|srp_ctx
operator|.
name|login
operator|!=
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|(
name|s
operator|->
name|srp_ctx
operator|.
name|login
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|s
operator|->
name|srp_ctx
operator|.
name|login
argument_list|,
operator|&
name|data
index|[
literal|1
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|->
name|srp_ctx
operator|.
name|login
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s
operator|->
name|srp_ctx
operator|.
name|login
argument_list|)
operator|!=
name|len
condition|)
goto|goto
name|err
goto|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_ec_point_formats
condition|)
block|{
name|unsigned
name|char
modifier|*
name|sdata
init|=
name|data
decl_stmt|;
name|int
name|ecpointformatlist_length
init|=
operator|*
operator|(
name|sdata
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|ecpointformatlist_length
operator|!=
name|size
operator|-
literal|1
operator|||
name|ecpointformatlist_length
operator|<
literal|1
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|s
operator|->
name|hit
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
operator|=
name|NULL
expr_stmt|;
block|}
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
operator|=
name|OPENSSL_malloc
argument_list|(
name|ecpointformatlist_length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist_length
operator|=
name|ecpointformatlist_length
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
argument_list|,
name|sdata
argument_list|,
name|ecpointformatlist_length
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|fprintf(stderr,                     "ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) ",                     s->session->tlsext_ecpointformatlist_length);             sdata = s->session->tlsext_ecpointformatlist;             for (i = 0; i< s->session->tlsext_ecpointformatlist_length; i++)                 fprintf(stderr, "%i ", *(sdata++));             fprintf(stderr, "\n");
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_elliptic_curves
condition|)
block|{
name|unsigned
name|char
modifier|*
name|sdata
init|=
name|data
decl_stmt|;
name|int
name|ellipticcurvelist_length
init|=
operator|(
operator|*
operator|(
name|sdata
operator|++
operator|)
operator|<<
literal|8
operator|)
decl_stmt|;
name|ellipticcurvelist_length
operator|+=
operator|(
operator|*
operator|(
name|sdata
operator|++
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ellipticcurvelist_length
operator|!=
name|size
operator|-
literal|2
operator|||
name|ellipticcurvelist_length
operator|<
literal|1
operator|||
comment|/* Each NamedCurve is 2 bytes. */
name|ellipticcurvelist_length
operator|&
literal|1
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|s
operator|->
name|hit
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|tlsext_ellipticcurvelist
condition|)
goto|goto
name|err
goto|;
name|s
operator|->
name|session
operator|->
name|tlsext_ellipticcurvelist_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|session
operator|->
name|tlsext_ellipticcurvelist
operator|=
name|OPENSSL_malloc
argument_list|(
name|ellipticcurvelist_length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|->
name|session
operator|->
name|tlsext_ellipticcurvelist_length
operator|=
name|ellipticcurvelist_length
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_ellipticcurvelist
argument_list|,
name|sdata
argument_list|,
name|ellipticcurvelist_length
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|fprintf(stderr,                     "ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) ",                     s->session->tlsext_ellipticcurvelist_length);             sdata = s->session->tlsext_ellipticcurvelist;             for (i = 0; i< s->session->tlsext_ellipticcurvelist_length; i++)                 fprintf(stderr, "%i ", *(sdata++));             fprintf(stderr, "\n");
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* OPENSSL_NO_EC */
ifdef|#
directive|ifdef
name|TLSEXT_TYPE_opaque_prf_input
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_opaque_prf_input
condition|)
block|{
name|unsigned
name|char
modifier|*
name|sdata
init|=
name|data
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|2
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|n2s
argument_list|(
name|sdata
argument_list|,
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
operator|!=
name|size
operator|-
literal|2
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|!=
name|NULL
condition|)
block|{
comment|/* shouldn't really happen */
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
argument_list|)
expr_stmt|;
block|}
comment|/* dummy byte just to get non-NULL */
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
operator|==
literal|0
condition|)
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|=
name|OPENSSL_malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|=
name|BUF_memdup
argument_list|(
name|sdata
argument_list|,
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_session_ticket
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|tls_session_ticket_ext_cb
operator|&&
operator|!
name|s
operator|->
name|tls_session_ticket_ext_cb
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|s
operator|->
name|tls_session_ticket_ext_cb_arg
argument_list|)
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_renegotiate
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_parse_clienthello_renegotiate_ext
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|al
argument_list|)
condition|)
return|return
literal|0
return|;
name|renegotiate_seen
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_signature_algorithms
condition|)
block|{
name|int
name|dsize
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|peer_sigalgs
operator|||
name|size
operator|<
literal|2
condition|)
goto|goto
name|err
goto|;
name|n2s
argument_list|(
name|data
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|size
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|dsize
operator|!=
name|size
operator|||
name|dsize
operator|&
literal|1
operator|||
operator|!
name|dsize
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|tls1_save_sigalgs
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|dsize
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_status_request
condition|)
block|{
if|if
condition|(
name|size
operator|<
literal|5
condition|)
goto|goto
name|err
goto|;
name|s
operator|->
name|tlsext_status_type
operator|=
operator|*
name|data
operator|++
expr_stmt|;
name|size
operator|--
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|tlsext_status_type
operator|==
name|TLSEXT_STATUSTYPE_ocsp
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|sdata
decl_stmt|;
name|int
name|dsize
decl_stmt|;
comment|/* Read in responder_id_list */
name|n2s
argument_list|(
name|data
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|size
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|dsize
operator|>
name|size
condition|)
goto|goto
name|err
goto|;
comment|/*                  * We remove any OCSP_RESPIDs from a previous handshake                  * to prevent unbounded memory growth - CVE-2016-6304                  */
name|sk_OCSP_RESPID_pop_free
argument_list|(
name|s
operator|->
name|tlsext_ocsp_ids
argument_list|,
name|OCSP_RESPID_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsize
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|tlsext_ocsp_ids
operator|=
name|sk_OCSP_RESPID_new_null
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|tlsext_ocsp_ids
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|s
operator|->
name|tlsext_ocsp_ids
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|dsize
operator|>
literal|0
condition|)
block|{
name|OCSP_RESPID
modifier|*
name|id
decl_stmt|;
name|int
name|idsize
decl_stmt|;
if|if
condition|(
name|dsize
operator|<
literal|4
condition|)
goto|goto
name|err
goto|;
name|n2s
argument_list|(
name|data
argument_list|,
name|idsize
argument_list|)
expr_stmt|;
name|dsize
operator|-=
literal|2
operator|+
name|idsize
expr_stmt|;
name|size
operator|-=
literal|2
operator|+
name|idsize
expr_stmt|;
if|if
condition|(
name|dsize
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
name|sdata
operator|=
name|data
expr_stmt|;
name|data
operator|+=
name|idsize
expr_stmt|;
name|id
operator|=
name|d2i_OCSP_RESPID
argument_list|(
name|NULL
argument_list|,
operator|&
name|sdata
argument_list|,
name|idsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|id
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|data
operator|!=
name|sdata
condition|)
block|{
name|OCSP_RESPID_free
argument_list|(
name|id
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|sk_OCSP_RESPID_push
argument_list|(
name|s
operator|->
name|tlsext_ocsp_ids
argument_list|,
name|id
argument_list|)
condition|)
block|{
name|OCSP_RESPID_free
argument_list|(
name|id
argument_list|)
expr_stmt|;
operator|*
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Read in request_extensions */
if|if
condition|(
name|size
operator|<
literal|2
condition|)
goto|goto
name|err
goto|;
name|n2s
argument_list|(
name|data
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|size
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|dsize
operator|!=
name|size
condition|)
goto|goto
name|err
goto|;
name|sdata
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|dsize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|tlsext_ocsp_exts
condition|)
block|{
name|sk_X509_EXTENSION_pop_free
argument_list|(
name|s
operator|->
name|tlsext_ocsp_exts
argument_list|,
name|X509_EXTENSION_free
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|tlsext_ocsp_exts
operator|=
name|d2i_X509_EXTENSIONS
argument_list|(
name|NULL
argument_list|,
operator|&
name|sdata
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|tlsext_ocsp_exts
operator|||
operator|(
name|data
operator|+
name|dsize
operator|!=
name|sdata
operator|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
comment|/*              * We don't know what to do with any other type * so ignore it.              */
else|else
name|s
operator|->
name|tlsext_status_type
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_heartbeat
condition|)
block|{
switch|switch
condition|(
name|data
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0x01
case|:
comment|/* Client allows us to send HB requests */
name|s
operator|->
name|tlsext_heartbeat
operator||=
name|SSL_TLSEXT_HB_ENABLED
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
comment|/* Client doesn't accept HB requests */
name|s
operator|->
name|tlsext_heartbeat
operator||=
name|SSL_TLSEXT_HB_ENABLED
expr_stmt|;
name|s
operator|->
name|tlsext_heartbeat
operator||=
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
expr_stmt|;
break|break;
default|default:
operator|*
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_next_proto_neg
operator|&&
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md_len
operator|==
literal|0
condition|)
block|{
comment|/*-              * We shouldn't accept this extension on a              * renegotiation.              *              * s->new_session will be set on renegotiation, but we              * probably shouldn't rely that it couldn't be set on              * the initial renegotation too in certain cases (when              * there's some other reason to disallow resuming an              * earlier session -- the current code won't be doing              * anything like that, but this might change).              *              * A valid sign that there's been a previous handshake              * in this connection is if s->s3->tmp.finish_md_len>              * 0.  (We are talking about a check that will happen              * in the Hello protocol round, well before a new              * Finished message could have been computed.)              */
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_application_layer_protocol_negotiation
operator|&&
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tls1_alpn_handle_client_hello
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|al
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* session ticket processed earlier */
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRTP
elseif|else
if|if
condition|(
name|SSL_IS_DTLS
argument_list|(
name|s
argument_list|)
operator|&&
name|SSL_get_srtp_profiles
argument_list|(
name|s
argument_list|)
operator|&&
name|type
operator|==
name|TLSEXT_TYPE_use_srtp
condition|)
block|{
if|if
condition|(
name|ssl_parse_clienthello_use_srtp_ext
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|al
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|data
operator|+=
name|size
expr_stmt|;
block|}
comment|/* Spurious data on the end */
if|if
condition|(
name|data
operator|!=
name|limit
condition|)
goto|goto
name|err
goto|;
operator|*
name|p
operator|=
name|data
expr_stmt|;
name|ri_check
label|:
comment|/* Need RI if renegotiating */
if|if
condition|(
operator|!
name|renegotiate_seen
operator|&&
name|s
operator|->
name|renegotiate
operator|&&
operator|!
operator|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
operator|)
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_HANDSHAKE_FAILURE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT
argument_list|,
name|SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
name|err
label|:
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Parse any custom extensions found.  "data" is the start of the extension data  * and "limit" is the end of the record. TODO: add strict syntax checking.  */
end_comment

begin_function
specifier|static
name|int
name|ssl_scan_clienthello_custom_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|limit
parameter_list|,
name|int
modifier|*
name|al
parameter_list|)
block|{
name|unsigned
name|short
name|type
decl_stmt|,
name|size
decl_stmt|,
name|len
decl_stmt|;
comment|/* If resumed session or no custom extensions nothing to do */
if|if
condition|(
name|s
operator|->
name|hit
operator|||
name|s
operator|->
name|cert
operator|->
name|srv_ext
operator|.
name|meths_count
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|limit
operator|-
name|data
operator|<=
literal|2
condition|)
return|return
literal|1
return|;
name|n2s
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|-
name|data
operator|<
name|len
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|limit
operator|-
name|data
operator|>=
literal|4
condition|)
block|{
name|n2s
argument_list|(
name|data
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|n2s
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|-
name|data
operator|<
name|size
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|custom_ext_parse
argument_list|(
name|s
argument_list|,
literal|1
comment|/* server */
argument_list|,
name|type
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|al
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|data
operator|+=
name|size
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ssl_parse_clienthello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
modifier|*
name|limit
parameter_list|)
block|{
name|int
name|al
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptmp
init|=
operator|*
name|p
decl_stmt|;
comment|/*      * Internally supported extensions are parsed first so SNI can be handled      * before custom extensions. An application processing SNI will typically      * switch the parent context using SSL_set_SSL_CTX and custom extensions      * need to be handled by the new SSL_CTX structure.      */
if|if
condition|(
name|ssl_scan_clienthello_tlsext
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|limit
argument_list|,
operator|&
name|al
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ssl_check_clienthello_tlsext_early
argument_list|(
name|s
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT
argument_list|,
name|SSL_R_CLIENTHELLO_TLSEXT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|custom_ext_init
argument_list|(
operator|&
name|s
operator|->
name|cert
operator|->
name|srv_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl_scan_clienthello_custom_tlsext
argument_list|(
name|s
argument_list|,
name|ptmp
argument_list|,
name|limit
argument_list|,
operator|&
name|al
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
end_ifndef

begin_comment
comment|/*  * ssl_next_proto_validate validates a Next Protocol Negotiation block. No  * elements of zero length are allowed and the set of elements must exactly  * fill the length of the block.  */
end_comment

begin_function
specifier|static
name|char
name|ssl_next_proto_validate
parameter_list|(
name|unsigned
name|char
modifier|*
name|d
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|off
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|off
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|d
index|[
name|off
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|off
operator|+=
name|d
index|[
name|off
index|]
expr_stmt|;
name|off
operator|++
expr_stmt|;
block|}
return|return
name|off
operator|==
name|len
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ssl_scan_serverhello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
modifier|*
name|d
parameter_list|,
name|int
name|n
parameter_list|,
name|int
modifier|*
name|al
parameter_list|)
block|{
name|unsigned
name|short
name|length
decl_stmt|;
name|unsigned
name|short
name|type
decl_stmt|;
name|unsigned
name|short
name|size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
init|=
operator|*
name|p
decl_stmt|;
name|int
name|tlsext_servername
init|=
literal|0
decl_stmt|;
name|int
name|renegotiate_seen
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|s
operator|->
name|tlsext_ticket_expected
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|alpn_selected
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|s3
operator|->
name|alpn_selected
argument_list|)
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|alpn_selected
operator|=
name|NULL
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
name|s
operator|->
name|tlsext_heartbeat
operator|&=
operator|~
operator|(
name|SSL_TLSEXT_HB_ENABLED
operator||
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|d
operator|+
name|n
operator|)
operator|-
name|data
operator|<=
literal|2
condition|)
goto|goto
name|ri_check
goto|;
name|n2s
argument_list|(
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|+
name|n
operator|)
operator|-
name|data
operator|!=
name|length
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|(
name|d
operator|+
name|n
operator|)
operator|-
name|data
operator|>=
literal|4
condition|)
block|{
name|n2s
argument_list|(
name|data
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|n2s
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|+
name|n
operator|)
operator|-
name|data
operator|<
name|size
condition|)
goto|goto
name|ri_check
goto|;
if|if
condition|(
name|s
operator|->
name|tlsext_debug_cb
condition|)
name|s
operator|->
name|tlsext_debug_cb
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
name|type
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|s
operator|->
name|tlsext_debug_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_server_name
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|tlsext_hostname
operator|==
name|NULL
operator|||
name|size
operator|>
literal|0
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_UNRECOGNIZED_NAME
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tlsext_servername
operator|=
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_ec_point_formats
condition|)
block|{
name|unsigned
name|char
modifier|*
name|sdata
init|=
name|data
decl_stmt|;
name|int
name|ecpointformatlist_length
init|=
operator|*
operator|(
name|sdata
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|ecpointformatlist_length
operator|!=
name|size
operator|-
literal|1
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|hit
condition|)
block|{
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
operator|=
name|OPENSSL_malloc
argument_list|(
name|ecpointformatlist_length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist_length
operator|=
name|ecpointformatlist_length
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
argument_list|,
name|sdata
argument_list|,
name|ecpointformatlist_length
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|fprintf(stderr,                     "ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist ");             sdata = s->session->tlsext_ecpointformatlist;             for (i = 0; i< s->session->tlsext_ecpointformatlist_length; i++)                 fprintf(stderr, "%i ", *(sdata++));             fprintf(stderr, "\n");
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* OPENSSL_NO_EC */
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_session_ticket
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|tls_session_ticket_ext_cb
operator|&&
operator|!
name|s
operator|->
name|tls_session_ticket_ext_cb
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|s
operator|->
name|tls_session_ticket_ext_cb_arg
argument_list|)
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|SSL_get_options
argument_list|(
name|s
argument_list|)
operator|&
name|SSL_OP_NO_TICKET
operator|)
operator|||
operator|(
name|size
operator|>
literal|0
operator|)
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_UNSUPPORTED_EXTENSION
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|->
name|tlsext_ticket_expected
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TLSEXT_TYPE_opaque_prf_input
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_opaque_prf_input
condition|)
block|{
name|unsigned
name|char
modifier|*
name|sdata
init|=
name|data
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|2
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|n2s
argument_list|(
name|sdata
argument_list|,
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
operator|!=
name|size
operator|-
literal|2
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|!=
name|NULL
condition|)
block|{
comment|/* shouldn't really happen */
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
operator|==
literal|0
condition|)
block|{
comment|/* dummy byte just to get non-NULL */
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|=
name|OPENSSL_malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|=
name|BUF_memdup
argument_list|(
name|sdata
argument_list|,
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_status_request
condition|)
block|{
comment|/*              * MUST be empty and only sent if we've requested a status              * request message.              */
if|if
condition|(
operator|(
name|s
operator|->
name|tlsext_status_type
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|size
operator|>
literal|0
operator|)
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_UNSUPPORTED_EXTENSION
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Set flag to expect CertificateStatus message */
name|s
operator|->
name|tlsext_status_expected
operator|=
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_next_proto_neg
operator|&&
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md_len
operator|==
literal|0
condition|)
block|{
name|unsigned
name|char
modifier|*
name|selected
decl_stmt|;
name|unsigned
name|char
name|selected_len
decl_stmt|;
comment|/* We must have requested it. */
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|next_proto_select_cb
operator|==
name|NULL
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_UNSUPPORTED_EXTENSION
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* The data must be valid */
if|if
condition|(
operator|!
name|ssl_next_proto_validate
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|next_proto_select_cb
argument_list|(
name|s
argument_list|,
operator|&
name|selected
argument_list|,
operator|&
name|selected_len
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|next_proto_select_cb_arg
argument_list|)
operator|!=
name|SSL_TLSEXT_ERR_OK
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*              * Could be non-NULL if server has sent multiple NPN extensions in              * a single Serverhello              */
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|next_proto_negotiated
argument_list|)
expr_stmt|;
name|s
operator|->
name|next_proto_negotiated
operator|=
name|OPENSSL_malloc
argument_list|(
name|selected_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|next_proto_negotiated
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|s
operator|->
name|next_proto_negotiated
argument_list|,
name|selected
argument_list|,
name|selected_len
argument_list|)
expr_stmt|;
name|s
operator|->
name|next_proto_negotiated_len
operator|=
name|selected_len
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_application_layer_protocol_negotiation
condition|)
block|{
name|unsigned
name|len
decl_stmt|;
comment|/* We must have requested it. */
if|if
condition|(
operator|!
name|s
operator|->
name|cert
operator|->
name|alpn_sent
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_UNSUPPORTED_EXTENSION
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|size
operator|<
literal|4
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*-              * The extension data consists of:              *   uint16 list_length              *   uint8 proto_length;              *   uint8 proto[proto_length];              */
name|len
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
name|len
operator|<<=
literal|8
expr_stmt|;
name|len
operator||=
name|data
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|len
operator|!=
operator|(
name|unsigned
operator|)
name|size
operator|-
literal|2
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|len
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|len
operator|!=
operator|(
name|unsigned
operator|)
name|size
operator|-
literal|3
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|alpn_selected
condition|)
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|s3
operator|->
name|alpn_selected
argument_list|)
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|alpn_selected
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|s3
operator|->
name|alpn_selected
condition|)
block|{
operator|*
name|al
operator|=
name|TLS1_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|s
operator|->
name|s3
operator|->
name|alpn_selected
argument_list|,
name|data
operator|+
literal|3
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|alpn_selected_len
operator|=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_renegotiate
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_parse_serverhello_renegotiate_ext
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|al
argument_list|)
condition|)
return|return
literal|0
return|;
name|renegotiate_seen
operator|=
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
elseif|else
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_heartbeat
condition|)
block|{
switch|switch
condition|(
name|data
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0x01
case|:
comment|/* Server allows us to send HB requests */
name|s
operator|->
name|tlsext_heartbeat
operator||=
name|SSL_TLSEXT_HB_ENABLED
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
comment|/* Server doesn't accept HB requests */
name|s
operator|->
name|tlsext_heartbeat
operator||=
name|SSL_TLSEXT_HB_ENABLED
expr_stmt|;
name|s
operator|->
name|tlsext_heartbeat
operator||=
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
expr_stmt|;
break|break;
default|default:
operator|*
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRTP
elseif|else
if|if
condition|(
name|SSL_IS_DTLS
argument_list|(
name|s
argument_list|)
operator|&&
name|type
operator|==
name|TLSEXT_TYPE_use_srtp
condition|)
block|{
if|if
condition|(
name|ssl_parse_serverhello_use_srtp_ext
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|al
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/*          * If this extension type was not otherwise handled, but matches a          * custom_cli_ext_record, then send it to the c callback          */
elseif|else
if|if
condition|(
name|custom_ext_parse
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|al
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|data
operator|+=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|!=
name|d
operator|+
name|n
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|hit
operator|&&
name|tlsext_servername
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|tlsext_hostname
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
operator|==
name|NULL
condition|)
block|{
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
operator|=
name|BUF_strdup
argument_list|(
name|s
operator|->
name|tlsext_hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|session
operator|->
name|tlsext_hostname
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_UNRECOGNIZED_NAME
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
operator|*
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
operator|*
name|p
operator|=
name|data
expr_stmt|;
name|ri_check
label|:
comment|/*      * Determine if we need to see RI. Strictly speaking if we want to avoid      * an attack we should *always* see RI even on initial server hello      * because the client doesn't see any renegotiation during an attack.      * However this would mean we could not connect to any server which      * doesn't support RI so for the immediate future tolerate RI absence on      * initial connect only.      */
if|if
condition|(
operator|!
name|renegotiate_seen
operator|&&
operator|!
operator|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_LEGACY_SERVER_CONNECT
operator|)
operator|&&
operator|!
operator|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
operator|)
condition|)
block|{
operator|*
name|al
operator|=
name|SSL_AD_HANDSHAKE_FAILURE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT
argument_list|,
name|SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ssl_prepare_clienthello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TLSEXT_TYPE_opaque_prf_input
block|{
name|int
name|r
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|tlsext_opaque_prf_input_callback
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|s
operator|->
name|ctx
operator|->
name|tlsext_opaque_prf_input_callback
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|tlsext_opaque_prf_input_callback_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|s
operator|->
name|tlsext_opaque_prf_input
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|!=
name|NULL
condition|)
block|{
comment|/* shouldn't really happen */
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|tlsext_opaque_prf_input_len
operator|==
literal|0
condition|)
block|{
comment|/* dummy byte just to get non-NULL */
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|=
name|OPENSSL_malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|=
name|BUF_memdup
argument_list|(
name|s
operator|->
name|tlsext_opaque_prf_input
argument_list|,
name|s
operator|->
name|tlsext_opaque_prf_input_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
operator|=
name|s
operator|->
name|tlsext_opaque_prf_input_len
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
literal|2
condition|)
comment|/*              * at callback's request, insist on receiving an appropriate              * server opaque PRF input              */
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
operator|=
name|s
operator|->
name|tlsext_opaque_prf_input_len
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|->
name|cert
operator|->
name|alpn_sent
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ssl_prepare_serverhello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ssl_check_clienthello_tlsext_early
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|ret
init|=
name|SSL_TLSEXT_ERR_NOACK
decl_stmt|;
name|int
name|al
init|=
name|SSL_AD_UNRECOGNIZED_NAME
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
comment|/*      * The handling of the ECPointFormats extension is done elsewhere, namely      * in ssl3_choose_cipher in s3_lib.c.      */
comment|/*      * The handling of the EllipticCurves extension is done elsewhere, namely      * in ssl3_choose_cipher in s3_lib.c.      */
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|ctx
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|ctx
operator|->
name|tlsext_servername_callback
operator|!=
literal|0
condition|)
name|ret
operator|=
name|s
operator|->
name|ctx
operator|->
name|tlsext_servername_callback
argument_list|(
name|s
argument_list|,
operator|&
name|al
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|tlsext_servername_arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|initial_ctx
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|initial_ctx
operator|->
name|tlsext_servername_callback
operator|!=
literal|0
condition|)
name|ret
operator|=
name|s
operator|->
name|initial_ctx
operator|->
name|tlsext_servername_callback
argument_list|(
name|s
argument_list|,
operator|&
name|al
argument_list|,
name|s
operator|->
name|initial_ctx
operator|->
name|tlsext_servername_arg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TLSEXT_TYPE_opaque_prf_input
block|{
comment|/*          * This sort of belongs into ssl_prepare_serverhello_tlsext(), but we          * might be sending an alert in response to the client hello, so this          * has to happen here in ssl_check_clienthello_tlsext_early().          */
name|int
name|r
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|tlsext_opaque_prf_input_callback
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|s
operator|->
name|ctx
operator|->
name|tlsext_opaque_prf_input_callback
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|tlsext_opaque_prf_input_callback_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|ret
operator|=
name|SSL_TLSEXT_ERR_ALERT_FATAL
expr_stmt|;
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|!=
name|NULL
condition|)
block|{
comment|/* shouldn't really happen */
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|tlsext_opaque_prf_input
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
operator|==
name|s
operator|->
name|tlsext_opaque_prf_input_len
condition|)
block|{
comment|/*                  * can only use this extension if we have a server opaque PRF                  * input of the same length as the client opaque PRF input!                  */
if|if
condition|(
name|s
operator|->
name|tlsext_opaque_prf_input_len
operator|==
literal|0
condition|)
block|{
comment|/* dummy byte just to get non-NULL */
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|=
name|OPENSSL_malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|=
name|BUF_memdup
argument_list|(
name|s
operator|->
name|tlsext_opaque_prf_input
argument_list|,
name|s
operator|->
name|tlsext_opaque_prf_input_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSL_TLSEXT_ERR_ALERT_FATAL
expr_stmt|;
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
operator|=
name|s
operator|->
name|tlsext_opaque_prf_input_len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|==
literal|2
operator|&&
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|==
name|NULL
condition|)
block|{
comment|/*              * The callback wants to enforce use of the extension, but we              * can't do that with the client opaque PRF input; abort the              * handshake.              */
name|ret
operator|=
name|SSL_TLSEXT_ERR_ALERT_FATAL
expr_stmt|;
name|al
operator|=
name|SSL_AD_HANDSHAKE_FAILURE
expr_stmt|;
block|}
block|}
name|err
label|:
endif|#
directive|endif
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|SSL_TLSEXT_ERR_ALERT_FATAL
case|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|SSL_TLSEXT_ERR_ALERT_WARNING
case|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_WARNING
argument_list|,
name|al
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SSL_TLSEXT_ERR_NOACK
case|:
name|s
operator|->
name|servername_done
operator|=
literal|0
expr_stmt|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
name|int
name|tls1_set_server_sigalgs
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|al
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* Clear any shared sigtnature algorithms */
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|shared_sigalgs
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|cert
operator|->
name|shared_sigalgs
argument_list|)
expr_stmt|;
name|s
operator|->
name|cert
operator|->
name|shared_sigalgs
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|cert
operator|->
name|shared_sigalgslen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Clear certificate digests and validity flags */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SSL_PKEY_NUM
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|->
name|cert
operator|->
name|pkeys
index|[
name|i
index|]
operator|.
name|digest
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|cert
operator|->
name|pkeys
index|[
name|i
index|]
operator|.
name|valid_flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If sigalgs received process it. */
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|peer_sigalgs
condition|)
block|{
if|if
condition|(
operator|!
name|tls1_process_sigalgs
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS1_SET_SERVER_SIGALGS
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Fatal error is no shared signature algorithms */
if|if
condition|(
operator|!
name|s
operator|->
name|cert
operator|->
name|shared_sigalgs
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS1_SET_SERVER_SIGALGS
argument_list|,
name|SSL_R_NO_SHARED_SIGATURE_ALGORITHMS
argument_list|)
expr_stmt|;
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
else|else
name|ssl_cert_set_default_md
argument_list|(
name|s
operator|->
name|cert
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|err
label|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Upon success, returns 1.  * Upon failure, returns 0 and sets |al| to the appropriate fatal alert.  */
end_comment

begin_function
name|int
name|ssl_check_clienthello_tlsext_late
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|al
parameter_list|)
block|{
comment|/*      * If status request then ask callback what to do. Note: this must be      * called after servername callbacks in case the certificate has changed,      * and must be called after the cipher has been chosen because this may      * influence which certificate is sent      */
if|if
condition|(
operator|(
name|s
operator|->
name|tlsext_status_type
operator|!=
operator|-
literal|1
operator|)
operator|&&
name|s
operator|->
name|ctx
operator|&&
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_cb
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|CERT_PKEY
modifier|*
name|certpkey
decl_stmt|;
name|certpkey
operator|=
name|ssl_get_server_send_pkey
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* If no certificate can't return certificate status */
if|if
condition|(
name|certpkey
operator|!=
name|NULL
condition|)
block|{
comment|/*              * Set current certificate to one we will use so SSL_get_certificate              * et al can pick it up.              */
name|s
operator|->
name|cert
operator|->
name|key
operator|=
name|certpkey
expr_stmt|;
name|ret
operator|=
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_cb
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_arg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
comment|/* We don't want to send a status request response */
case|case
name|SSL_TLSEXT_ERR_NOACK
case|:
name|s
operator|->
name|tlsext_status_expected
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* status request response should be sent */
case|case
name|SSL_TLSEXT_ERR_OK
case|:
if|if
condition|(
name|s
operator|->
name|tlsext_ocsp_resp
condition|)
name|s
operator|->
name|tlsext_status_expected
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* something bad happened */
case|case
name|SSL_TLSEXT_ERR_ALERT_FATAL
case|:
default|default:
operator|*
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|tls1_alpn_handle_client_hello_late
argument_list|(
name|s
argument_list|,
name|al
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ssl_check_serverhello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|ret
init|=
name|SSL_TLSEXT_ERR_NOACK
decl_stmt|;
name|int
name|al
init|=
name|SSL_AD_UNRECOGNIZED_NAME
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
comment|/*      * If we are client and using an elliptic curve cryptography cipher      * suite, then if server returns an EC point formats lists extension it      * must contain uncompressed.      */
name|unsigned
name|long
name|alg_k
init|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_mkey
decl_stmt|;
name|unsigned
name|long
name|alg_a
init|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_auth
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|tlsext_ecpointformatlist
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|s
operator|->
name|tlsext_ecpointformatlist_length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist_length
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|alg_k
operator|&
operator|(
name|SSL_kEECDH
operator||
name|SSL_kECDHr
operator||
name|SSL_kECDHe
operator|)
operator|)
operator|||
operator|(
name|alg_a
operator|&
name|SSL_aECDSA
operator|)
operator|)
condition|)
block|{
comment|/* we are using an ECC cipher */
name|size_t
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|list
decl_stmt|;
name|int
name|found_uncompressed
init|=
literal|0
decl_stmt|;
name|list
operator|=
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|session
operator|->
name|tlsext_ecpointformatlist_length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|list
operator|++
operator|)
operator|==
name|TLSEXT_ECPOINTFORMAT_uncompressed
condition|)
block|{
name|found_uncompressed
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found_uncompressed
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT
argument_list|,
name|SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|ret
operator|=
name|SSL_TLSEXT_ERR_OK
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL_NO_EC */
if|if
condition|(
name|s
operator|->
name|ctx
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|ctx
operator|->
name|tlsext_servername_callback
operator|!=
literal|0
condition|)
name|ret
operator|=
name|s
operator|->
name|ctx
operator|->
name|tlsext_servername_callback
argument_list|(
name|s
argument_list|,
operator|&
name|al
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|tlsext_servername_arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|initial_ctx
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|initial_ctx
operator|->
name|tlsext_servername_callback
operator|!=
literal|0
condition|)
name|ret
operator|=
name|s
operator|->
name|initial_ctx
operator|->
name|tlsext_servername_callback
argument_list|(
name|s
argument_list|,
operator|&
name|al
argument_list|,
name|s
operator|->
name|initial_ctx
operator|->
name|tlsext_servername_arg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TLSEXT_TYPE_opaque_prf_input
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
operator|>
literal|0
condition|)
block|{
comment|/*          * This case may indicate that we, as a client, want to insist on          * using opaque PRF inputs. So first verify that we really have a          * value from the server too.          */
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSL_TLSEXT_ERR_ALERT_FATAL
expr_stmt|;
name|al
operator|=
name|SSL_AD_HANDSHAKE_FAILURE
expr_stmt|;
block|}
comment|/*          * Anytime the server *has* sent an opaque PRF input, we need to          * check that we have a client opaque PRF input of the same size.          */
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input
operator|==
name|NULL
operator|||
name|s
operator|->
name|s3
operator|->
name|client_opaque_prf_input_len
operator|!=
name|s
operator|->
name|s3
operator|->
name|server_opaque_prf_input_len
condition|)
block|{
name|ret
operator|=
name|SSL_TLSEXT_ERR_ALERT_FATAL
expr_stmt|;
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|tlsext_ocsp_resp
argument_list|)
expr_stmt|;
name|s
operator|->
name|tlsext_ocsp_resp
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|tlsext_ocsp_resplen
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*      * If we've requested certificate status and we wont get one tell the      * callback      */
if|if
condition|(
operator|(
name|s
operator|->
name|tlsext_status_type
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|!
operator|(
name|s
operator|->
name|tlsext_status_expected
operator|)
operator|&&
operator|!
operator|(
name|s
operator|->
name|hit
operator|)
operator|&&
name|s
operator|->
name|ctx
operator|&&
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_cb
condition|)
block|{
name|int
name|r
decl_stmt|;
comment|/*          * Call callback with resp == NULL and resplen == -1 so callback          * knows there is no response          */
name|r
operator|=
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_cb
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|al
operator|=
name|SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE
expr_stmt|;
name|ret
operator|=
name|SSL_TLSEXT_ERR_ALERT_FATAL
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
name|ret
operator|=
name|SSL_TLSEXT_ERR_ALERT_FATAL
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|SSL_TLSEXT_ERR_ALERT_FATAL
case|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|SSL_TLSEXT_ERR_ALERT_WARNING
case|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_WARNING
argument_list|,
name|al
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SSL_TLSEXT_ERR_NOACK
case|:
name|s
operator|->
name|servername_done
operator|=
literal|0
expr_stmt|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
name|int
name|ssl_parse_serverhello_tlsext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
modifier|*
name|d
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|al
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|version
operator|<
name|SSL3_VERSION
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ssl_scan_serverhello_tlsext
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|d
argument_list|,
name|n
argument_list|,
operator|&
name|al
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ssl_check_serverhello_tlsext
argument_list|(
name|s
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_PARSE_SERVERHELLO_TLSEXT
argument_list|,
name|SSL_R_SERVERHELLO_TLSEXT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*-  * Since the server cache lookup is done early on in the processing of the  * ClientHello, and other operations depend on the result, we need to handle  * any TLS session ticket extension at the same time.  *  *   session_id: points at the session ID in the ClientHello. This code will  *       read past the end of this in order to parse out the session ticket  *       extension, if any.  *   len: the length of the session ID.  *   limit: a pointer to the first byte after the ClientHello.  *   ret: (output) on return, if a ticket was decrypted, then this is set to  *       point to the resulting session.  *  * If s->tls_session_secret_cb is set then we are expecting a pre-shared key  * ciphersuite, in which case we have no use for session tickets and one will  * never be decrypted, nor will s->tlsext_ticket_expected be set to 1.  *  * Returns:  *   -1: fatal error, either from parsing or decrypting the ticket.  *    0: no ticket was found (or was ignored, based on settings).  *    1: a zero length extension was found, indicating that the client supports  *       session tickets but doesn't currently have one to offer.  *    2: either s->tls_session_secret_cb was set, or a ticket was offered but  *       couldn't be decrypted because of a non-fatal error.  *    3: a ticket was successfully decrypted and *ret was set.  *  * Side effects:  *   Sets s->tlsext_ticket_expected to 1 if the server will have to issue  *   a new session ticket to the client because the client indicated support  *   (and s->tls_session_secret_cb is NULL) but the client either doesn't have  *   a session ticket or we couldn't use the one it gave us, or if  *   s->ctx->tlsext_ticket_key_cb asked to renew the client's ticket.  *   Otherwise, s->tlsext_ticket_expected is set to 0.  */
end_comment

begin_function
name|int
name|tls1_process_ticket
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|session_id
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|limit
parameter_list|,
name|SSL_SESSION
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
comment|/* Point after session ID in client hello */
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
name|session_id
operator|+
name|len
decl_stmt|;
name|unsigned
name|short
name|i
decl_stmt|;
operator|*
name|ret
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|tlsext_ticket_expected
operator|=
literal|0
expr_stmt|;
comment|/*      * If tickets disabled behave as if no ticket present to permit stateful      * resumption.      */
if|if
condition|(
name|SSL_get_options
argument_list|(
name|s
argument_list|)
operator|&
name|SSL_OP_NO_TICKET
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|s
operator|->
name|version
operator|<=
name|SSL3_VERSION
operator|)
operator|||
operator|!
name|limit
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Skip past DTLS cookie */
if|if
condition|(
name|SSL_IS_DTLS
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|i
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|limit
operator|-
name|p
operator|<=
name|i
condition|)
return|return
operator|-
literal|1
return|;
name|p
operator|+=
name|i
expr_stmt|;
block|}
comment|/* Skip past cipher list */
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|-
name|p
operator|<=
name|i
condition|)
return|return
operator|-
literal|1
return|;
name|p
operator|+=
name|i
expr_stmt|;
comment|/* Skip past compression algorithm list */
name|i
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|limit
operator|-
name|p
operator|<
name|i
condition|)
return|return
operator|-
literal|1
return|;
name|p
operator|+=
name|i
expr_stmt|;
comment|/* Now at start of extensions */
if|if
condition|(
name|limit
operator|-
name|p
operator|<=
literal|2
condition|)
return|return
literal|0
return|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|limit
operator|-
name|p
operator|>=
literal|4
condition|)
block|{
name|unsigned
name|short
name|type
decl_stmt|,
name|size
decl_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|-
name|p
operator|<
name|size
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|==
name|TLSEXT_TYPE_session_ticket
condition|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/*                  * The client will accept a ticket but doesn't currently have                  * one.                  */
name|s
operator|->
name|tlsext_ticket_expected
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|s
operator|->
name|tls_session_secret_cb
condition|)
block|{
comment|/*                  * Indicate that the ticket couldn't be decrypted rather than                  * generating the session from ticket now, trigger                  * abbreviated handshake based on external mechanism to                  * calculate the master secret later.                  */
return|return
literal|2
return|;
block|}
name|r
operator|=
name|tls_decrypt_ticket
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|size
argument_list|,
name|session_id
argument_list|,
name|len
argument_list|,
name|ret
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|2
case|:
comment|/* ticket couldn't be decrypted */
name|s
operator|->
name|tlsext_ticket_expected
operator|=
literal|1
expr_stmt|;
return|return
literal|2
return|;
case|case
literal|3
case|:
comment|/* ticket was decrypted */
return|return
name|r
return|;
case|case
literal|4
case|:
comment|/* ticket decrypted but need to renew */
name|s
operator|->
name|tlsext_ticket_expected
operator|=
literal|1
expr_stmt|;
return|return
literal|3
return|;
default|default:
comment|/* fatal error */
return|return
operator|-
literal|1
return|;
block|}
block|}
name|p
operator|+=
name|size
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*-  * tls_decrypt_ticket attempts to decrypt a session ticket.  *  *   etick: points to the body of the session ticket extension.  *   eticklen: the length of the session tickets extenion.  *   sess_id: points at the session ID.  *   sesslen: the length of the session ID.  *   psess: (output) on return, if a ticket was decrypted, then this is set to  *       point to the resulting session.  *  * Returns:  *   -1: fatal error, either from parsing or decrypting the ticket.  *    2: the ticket couldn't be decrypted.  *    3: a ticket was successfully decrypted and *psess was set.  *    4: same as 3, but the ticket needs to be renewed.  */
end_comment

begin_function
specifier|static
name|int
name|tls_decrypt_ticket
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|etick
parameter_list|,
name|int
name|eticklen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sess_id
parameter_list|,
name|int
name|sesslen
parameter_list|,
name|SSL_SESSION
modifier|*
modifier|*
name|psess
parameter_list|)
block|{
name|SSL_SESSION
modifier|*
name|sess
decl_stmt|;
name|unsigned
name|char
modifier|*
name|sdec
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|slen
decl_stmt|,
name|mlen
decl_stmt|,
name|renew_ticket
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|tick_hmac
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
name|HMAC_CTX
name|hctx
decl_stmt|;
name|EVP_CIPHER_CTX
name|ctx
decl_stmt|;
name|SSL_CTX
modifier|*
name|tctx
init|=
name|s
operator|->
name|initial_ctx
decl_stmt|;
comment|/* Initialize session ticket encryption and HMAC contexts */
name|HMAC_CTX_init
argument_list|(
operator|&
name|hctx
argument_list|)
expr_stmt|;
name|EVP_CIPHER_CTX_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tctx
operator|->
name|tlsext_ticket_key_cb
condition|)
block|{
name|unsigned
name|char
modifier|*
name|nctick
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|etick
decl_stmt|;
name|int
name|rv
init|=
name|tctx
operator|->
name|tlsext_ticket_key_cb
argument_list|(
name|s
argument_list|,
name|nctick
argument_list|,
name|nctick
operator|+
literal|16
argument_list|,
operator|&
name|ctx
argument_list|,
operator|&
name|hctx
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|rv
operator|==
literal|2
condition|)
name|renew_ticket
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Check key name matches */
if|if
condition|(
name|memcmp
argument_list|(
name|etick
argument_list|,
name|tctx
operator|->
name|tlsext_tick_key_name
argument_list|,
literal|16
argument_list|)
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|HMAC_Init_ex
argument_list|(
operator|&
name|hctx
argument_list|,
name|tctx
operator|->
name|tlsext_tick_hmac_key
argument_list|,
literal|16
argument_list|,
name|tlsext_tick_md
argument_list|()
argument_list|,
name|NULL
argument_list|)
operator|<=
literal|0
operator|||
name|EVP_DecryptInit_ex
argument_list|(
operator|&
name|ctx
argument_list|,
name|EVP_aes_128_cbc
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|tctx
operator|->
name|tlsext_tick_aes_key
argument_list|,
name|etick
operator|+
literal|16
argument_list|)
operator|<=
literal|0
condition|)
block|{
goto|goto
name|err
goto|;
block|}
block|}
comment|/*      * Attempt to process session ticket, first conduct sanity and integrity      * checks on ticket.      */
name|mlen
operator|=
name|HMAC_size
argument_list|(
operator|&
name|hctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlen
operator|<
literal|0
condition|)
block|{
goto|goto
name|err
goto|;
block|}
comment|/* Sanity check ticket length: must exceed keyname + IV + HMAC */
if|if
condition|(
name|eticklen
operator|<=
literal|16
operator|+
name|EVP_CIPHER_CTX_iv_length
argument_list|(
operator|&
name|ctx
argument_list|)
operator|+
name|mlen
condition|)
block|{
name|HMAC_CTX_cleanup
argument_list|(
operator|&
name|hctx
argument_list|)
expr_stmt|;
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
name|eticklen
operator|-=
name|mlen
expr_stmt|;
comment|/* Check HMAC of encrypted ticket */
if|if
condition|(
name|HMAC_Update
argument_list|(
operator|&
name|hctx
argument_list|,
name|etick
argument_list|,
name|eticklen
argument_list|)
operator|<=
literal|0
operator|||
name|HMAC_Final
argument_list|(
operator|&
name|hctx
argument_list|,
name|tick_hmac
argument_list|,
name|NULL
argument_list|)
operator|<=
literal|0
condition|)
block|{
goto|goto
name|err
goto|;
block|}
name|HMAC_CTX_cleanup
argument_list|(
operator|&
name|hctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|CRYPTO_memcmp
argument_list|(
name|tick_hmac
argument_list|,
name|etick
operator|+
name|eticklen
argument_list|,
name|mlen
argument_list|)
condition|)
block|{
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
comment|/* Attempt to decrypt session data */
comment|/* Move p after IV to start of encrypted ticket, update length */
name|p
operator|=
name|etick
operator|+
literal|16
operator|+
name|EVP_CIPHER_CTX_iv_length
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|eticklen
operator|-=
literal|16
operator|+
name|EVP_CIPHER_CTX_iv_length
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sdec
operator|=
name|OPENSSL_malloc
argument_list|(
name|eticklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdec
operator|==
name|NULL
operator|||
name|EVP_DecryptUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|sdec
argument_list|,
operator|&
name|slen
argument_list|,
name|p
argument_list|,
name|eticklen
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|sdec
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|EVP_DecryptFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|sdec
operator|+
name|slen
argument_list|,
operator|&
name|mlen
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|sdec
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
name|slen
operator|+=
name|mlen
expr_stmt|;
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|p
operator|=
name|sdec
expr_stmt|;
name|sess
operator|=
name|d2i_SSL_SESSION
argument_list|(
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|slen
operator|-=
name|p
operator|-
name|sdec
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|sdec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sess
condition|)
block|{
comment|/* Some additional consistency checks */
if|if
condition|(
name|slen
operator|!=
literal|0
operator|||
name|sess
operator|->
name|session_id_length
operator|!=
literal|0
condition|)
block|{
name|SSL_SESSION_free
argument_list|(
name|sess
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
comment|/*          * The session ID, if non-empty, is used by some clients to detect          * that the ticket has been accepted. So we copy it to the session          * structure. If it is empty set length to zero as required by          * standard.          */
if|if
condition|(
name|sesslen
condition|)
name|memcpy
argument_list|(
name|sess
operator|->
name|session_id
argument_list|,
name|sess_id
argument_list|,
name|sesslen
argument_list|)
expr_stmt|;
name|sess
operator|->
name|session_id_length
operator|=
name|sesslen
expr_stmt|;
operator|*
name|psess
operator|=
name|sess
expr_stmt|;
if|if
condition|(
name|renew_ticket
condition|)
return|return
literal|4
return|;
else|else
return|return
literal|3
return|;
block|}
name|ERR_clear_error
argument_list|()
expr_stmt|;
comment|/*      * For session parse failure, indicate that we need to send a new ticket.      */
return|return
literal|2
return|;
name|err
label|:
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|HMAC_CTX_cleanup
argument_list|(
operator|&
name|hctx
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Tables to translate from NIDs to TLS v1.2 ids */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|nid
decl_stmt|;
name|int
name|id
decl_stmt|;
block|}
name|tls12_lookup
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|tls12_lookup
name|tls12_md
index|[]
init|=
block|{
block|{
name|NID_md5
block|,
name|TLSEXT_hash_md5
block|}
block|,
block|{
name|NID_sha1
block|,
name|TLSEXT_hash_sha1
block|}
block|,
block|{
name|NID_sha224
block|,
name|TLSEXT_hash_sha224
block|}
block|,
block|{
name|NID_sha256
block|,
name|TLSEXT_hash_sha256
block|}
block|,
block|{
name|NID_sha384
block|,
name|TLSEXT_hash_sha384
block|}
block|,
block|{
name|NID_sha512
block|,
name|TLSEXT_hash_sha512
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tls12_lookup
name|tls12_sig
index|[]
init|=
block|{
block|{
name|EVP_PKEY_RSA
block|,
name|TLSEXT_signature_rsa
block|}
block|,
block|{
name|EVP_PKEY_DSA
block|,
name|TLSEXT_signature_dsa
block|}
block|,
block|{
name|EVP_PKEY_EC
block|,
name|TLSEXT_signature_ecdsa
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|tls12_find_id
parameter_list|(
name|int
name|nid
parameter_list|,
name|tls12_lookup
modifier|*
name|table
parameter_list|,
name|size_t
name|tlen
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tlen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|table
index|[
name|i
index|]
operator|.
name|nid
operator|==
name|nid
condition|)
return|return
name|table
index|[
name|i
index|]
operator|.
name|id
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tls12_find_nid
parameter_list|(
name|int
name|id
parameter_list|,
name|tls12_lookup
modifier|*
name|table
parameter_list|,
name|size_t
name|tlen
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tlen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|table
index|[
name|i
index|]
operator|.
name|id
operator|)
operator|==
name|id
condition|)
return|return
name|table
index|[
name|i
index|]
operator|.
name|nid
return|;
block|}
return|return
name|NID_undef
return|;
block|}
end_function

begin_function
name|int
name|tls12_get_sigandhash
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|EVP_PKEY
modifier|*
name|pk
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
name|md
parameter_list|)
block|{
name|int
name|sig_id
decl_stmt|,
name|md_id
decl_stmt|;
if|if
condition|(
operator|!
name|md
condition|)
return|return
literal|0
return|;
name|md_id
operator|=
name|tls12_find_id
argument_list|(
name|EVP_MD_type
argument_list|(
name|md
argument_list|)
argument_list|,
name|tls12_md
argument_list|,
sizeof|sizeof
argument_list|(
name|tls12_md
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tls12_lookup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|md_id
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|sig_id
operator|=
name|tls12_get_sigid
argument_list|(
name|pk
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig_id
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|p
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|md_id
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|sig_id
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|tls12_get_sigid
parameter_list|(
specifier|const
name|EVP_PKEY
modifier|*
name|pk
parameter_list|)
block|{
return|return
name|tls12_find_id
argument_list|(
name|pk
operator|->
name|type
argument_list|,
name|tls12_sig
argument_list|,
sizeof|sizeof
argument_list|(
name|tls12_sig
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tls12_lookup
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|EVP_MD
modifier|*
name|tls12_get_hash
parameter_list|(
name|unsigned
name|char
name|hash_alg
parameter_list|)
block|{
switch|switch
condition|(
name|hash_alg
condition|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_MD5
case|case
name|TLSEXT_hash_md5
case|:
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
if|if
condition|(
name|FIPS_mode
argument_list|()
condition|)
return|return
name|NULL
return|;
endif|#
directive|endif
return|return
name|EVP_md5
argument_list|()
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA
case|case
name|TLSEXT_hash_sha1
case|:
return|return
name|EVP_sha1
argument_list|()
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA256
case|case
name|TLSEXT_hash_sha224
case|:
return|return
name|EVP_sha224
argument_list|()
return|;
case|case
name|TLSEXT_hash_sha256
case|:
return|return
name|EVP_sha256
argument_list|()
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA512
case|case
name|TLSEXT_hash_sha384
case|:
return|return
name|EVP_sha384
argument_list|()
return|;
case|case
name|TLSEXT_hash_sha512
case|:
return|return
name|EVP_sha512
argument_list|()
return|;
endif|#
directive|endif
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|tls12_get_pkey_idx
parameter_list|(
name|unsigned
name|char
name|sig_alg
parameter_list|)
block|{
switch|switch
condition|(
name|sig_alg
condition|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
case|case
name|TLSEXT_signature_rsa
case|:
return|return
name|SSL_PKEY_RSA_SIGN
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
case|case
name|TLSEXT_signature_dsa
case|:
return|return
name|SSL_PKEY_DSA_SIGN
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDSA
case|case
name|TLSEXT_signature_ecdsa
case|:
return|return
name|SSL_PKEY_ECC
return|;
endif|#
directive|endif
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Convert TLS 1.2 signature algorithm extension values into NIDs */
end_comment

begin_function
specifier|static
name|void
name|tls1_lookup_sigalg
parameter_list|(
name|int
modifier|*
name|phash_nid
parameter_list|,
name|int
modifier|*
name|psign_nid
parameter_list|,
name|int
modifier|*
name|psignhash_nid
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|)
block|{
name|int
name|sign_nid
init|=
name|NID_undef
decl_stmt|,
name|hash_nid
init|=
name|NID_undef
decl_stmt|;
if|if
condition|(
operator|!
name|phash_nid
operator|&&
operator|!
name|psign_nid
operator|&&
operator|!
name|psignhash_nid
condition|)
return|return;
if|if
condition|(
name|phash_nid
operator|||
name|psignhash_nid
condition|)
block|{
name|hash_nid
operator|=
name|tls12_find_nid
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|,
name|tls12_md
argument_list|,
sizeof|sizeof
argument_list|(
name|tls12_md
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tls12_lookup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phash_nid
condition|)
operator|*
name|phash_nid
operator|=
name|hash_nid
expr_stmt|;
block|}
if|if
condition|(
name|psign_nid
operator|||
name|psignhash_nid
condition|)
block|{
name|sign_nid
operator|=
name|tls12_find_nid
argument_list|(
name|data
index|[
literal|1
index|]
argument_list|,
name|tls12_sig
argument_list|,
sizeof|sizeof
argument_list|(
name|tls12_sig
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tls12_lookup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|psign_nid
condition|)
operator|*
name|psign_nid
operator|=
name|sign_nid
expr_stmt|;
block|}
if|if
condition|(
name|psignhash_nid
condition|)
block|{
if|if
condition|(
name|sign_nid
operator|==
name|NID_undef
operator|||
name|hash_nid
operator|==
name|NID_undef
operator|||
name|OBJ_find_sigid_by_algs
argument_list|(
name|psignhash_nid
argument_list|,
name|hash_nid
argument_list|,
name|sign_nid
argument_list|)
operator|<=
literal|0
condition|)
operator|*
name|psignhash_nid
operator|=
name|NID_undef
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given preference and allowed sigalgs set shared sigalgs */
end_comment

begin_function
specifier|static
name|int
name|tls12_do_shared_sigalgs
parameter_list|(
name|TLS_SIGALGS
modifier|*
name|shsig
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|pref
parameter_list|,
name|size_t
name|preflen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|allow
parameter_list|,
name|size_t
name|allowlen
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|ptmp
decl_stmt|,
modifier|*
name|atmp
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nmatch
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ptmp
operator|=
name|pref
init|;
name|i
operator|<
name|preflen
condition|;
name|i
operator|+=
literal|2
operator|,
name|ptmp
operator|+=
literal|2
control|)
block|{
comment|/* Skip disabled hashes or signature algorithms */
if|if
condition|(
name|tls12_get_hash
argument_list|(
name|ptmp
index|[
literal|0
index|]
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|tls12_get_pkey_idx
argument_list|(
name|ptmp
index|[
literal|1
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|atmp
operator|=
name|allow
init|;
name|j
operator|<
name|allowlen
condition|;
name|j
operator|+=
literal|2
operator|,
name|atmp
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|ptmp
index|[
literal|0
index|]
operator|==
name|atmp
index|[
literal|0
index|]
operator|&&
name|ptmp
index|[
literal|1
index|]
operator|==
name|atmp
index|[
literal|1
index|]
condition|)
block|{
name|nmatch
operator|++
expr_stmt|;
if|if
condition|(
name|shsig
condition|)
block|{
name|shsig
operator|->
name|rhash
operator|=
name|ptmp
index|[
literal|0
index|]
expr_stmt|;
name|shsig
operator|->
name|rsign
operator|=
name|ptmp
index|[
literal|1
index|]
expr_stmt|;
name|tls1_lookup_sigalg
argument_list|(
operator|&
name|shsig
operator|->
name|hash_nid
argument_list|,
operator|&
name|shsig
operator|->
name|sign_nid
argument_list|,
operator|&
name|shsig
operator|->
name|signandhash_nid
argument_list|,
name|ptmp
argument_list|)
expr_stmt|;
name|shsig
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|nmatch
return|;
block|}
end_function

begin_comment
comment|/* Set shared signature algorithms for SSL structures */
end_comment

begin_function
specifier|static
name|int
name|tls1_set_shared_sigalgs
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|pref
decl_stmt|,
modifier|*
name|allow
decl_stmt|,
modifier|*
name|conf
decl_stmt|;
name|size_t
name|preflen
decl_stmt|,
name|allowlen
decl_stmt|,
name|conflen
decl_stmt|;
name|size_t
name|nmatch
decl_stmt|;
name|TLS_SIGALGS
modifier|*
name|salgs
init|=
name|NULL
decl_stmt|;
name|CERT
modifier|*
name|c
init|=
name|s
operator|->
name|cert
decl_stmt|;
name|unsigned
name|int
name|is_suiteb
init|=
name|tls1_suiteb
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|shared_sigalgs
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|c
operator|->
name|shared_sigalgs
argument_list|)
expr_stmt|;
name|c
operator|->
name|shared_sigalgs
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|shared_sigalgslen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If client use client signature algorithms if not NULL */
if|if
condition|(
operator|!
name|s
operator|->
name|server
operator|&&
name|c
operator|->
name|client_sigalgs
operator|&&
operator|!
name|is_suiteb
condition|)
block|{
name|conf
operator|=
name|c
operator|->
name|client_sigalgs
expr_stmt|;
name|conflen
operator|=
name|c
operator|->
name|client_sigalgslen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|conf_sigalgs
operator|&&
operator|!
name|is_suiteb
condition|)
block|{
name|conf
operator|=
name|c
operator|->
name|conf_sigalgs
expr_stmt|;
name|conflen
operator|=
name|c
operator|->
name|conf_sigalgslen
expr_stmt|;
block|}
else|else
name|conflen
operator|=
name|tls12_get_psigalgs
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_CIPHER_SERVER_PREFERENCE
operator|||
name|is_suiteb
condition|)
block|{
name|pref
operator|=
name|conf
expr_stmt|;
name|preflen
operator|=
name|conflen
expr_stmt|;
name|allow
operator|=
name|c
operator|->
name|peer_sigalgs
expr_stmt|;
name|allowlen
operator|=
name|c
operator|->
name|peer_sigalgslen
expr_stmt|;
block|}
else|else
block|{
name|allow
operator|=
name|conf
expr_stmt|;
name|allowlen
operator|=
name|conflen
expr_stmt|;
name|pref
operator|=
name|c
operator|->
name|peer_sigalgs
expr_stmt|;
name|preflen
operator|=
name|c
operator|->
name|peer_sigalgslen
expr_stmt|;
block|}
name|nmatch
operator|=
name|tls12_do_shared_sigalgs
argument_list|(
name|NULL
argument_list|,
name|pref
argument_list|,
name|preflen
argument_list|,
name|allow
argument_list|,
name|allowlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmatch
condition|)
block|{
name|salgs
operator|=
name|OPENSSL_malloc
argument_list|(
name|nmatch
operator|*
sizeof|sizeof
argument_list|(
name|TLS_SIGALGS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|salgs
condition|)
return|return
literal|0
return|;
name|nmatch
operator|=
name|tls12_do_shared_sigalgs
argument_list|(
name|salgs
argument_list|,
name|pref
argument_list|,
name|preflen
argument_list|,
name|allow
argument_list|,
name|allowlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|salgs
operator|=
name|NULL
expr_stmt|;
block|}
name|c
operator|->
name|shared_sigalgs
operator|=
name|salgs
expr_stmt|;
name|c
operator|->
name|shared_sigalgslen
operator|=
name|nmatch
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Set preferred digest for each key type */
end_comment

begin_function
name|int
name|tls1_save_sigalgs
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|dsize
parameter_list|)
block|{
name|CERT
modifier|*
name|c
init|=
name|s
operator|->
name|cert
decl_stmt|;
comment|/* Extension ignored for inappropriate versions */
if|if
condition|(
operator|!
name|SSL_USE_SIGALGS
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Should never happen */
if|if
condition|(
operator|!
name|c
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|->
name|peer_sigalgs
condition|)
name|OPENSSL_free
argument_list|(
name|c
operator|->
name|peer_sigalgs
argument_list|)
expr_stmt|;
name|c
operator|->
name|peer_sigalgs
operator|=
name|OPENSSL_malloc
argument_list|(
name|dsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|peer_sigalgs
condition|)
return|return
literal|0
return|;
name|c
operator|->
name|peer_sigalgslen
operator|=
name|dsize
expr_stmt|;
name|memcpy
argument_list|(
name|c
operator|->
name|peer_sigalgs
argument_list|,
name|data
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|tls1_process_sigalgs
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|size_t
name|i
decl_stmt|;
specifier|const
name|EVP_MD
modifier|*
name|md
decl_stmt|;
name|CERT
modifier|*
name|c
init|=
name|s
operator|->
name|cert
decl_stmt|;
name|TLS_SIGALGS
modifier|*
name|sigptr
decl_stmt|;
if|if
condition|(
operator|!
name|tls1_set_shared_sigalgs
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|cert_flags
operator|&
name|SSL_CERT_FLAG_BROKEN_PROTOCOL
condition|)
block|{
comment|/*          * Use first set signature preference to force message digest,          * ignoring any peer preferences.          */
specifier|const
name|unsigned
name|char
modifier|*
name|sigs
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|server
condition|)
name|sigs
operator|=
name|c
operator|->
name|conf_sigalgs
expr_stmt|;
else|else
name|sigs
operator|=
name|c
operator|->
name|client_sigalgs
expr_stmt|;
if|if
condition|(
name|sigs
condition|)
block|{
name|idx
operator|=
name|tls12_get_pkey_idx
argument_list|(
name|sigs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|md
operator|=
name|tls12_get_hash
argument_list|(
name|sigs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|c
operator|->
name|pkeys
index|[
name|idx
index|]
operator|.
name|digest
operator|=
name|md
expr_stmt|;
name|c
operator|->
name|pkeys
index|[
name|idx
index|]
operator|.
name|valid_flags
operator|=
name|CERT_PKEY_EXPLICIT_SIGN
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|SSL_PKEY_RSA_SIGN
condition|)
block|{
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|valid_flags
operator|=
name|CERT_PKEY_EXPLICIT_SIGN
expr_stmt|;
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|digest
operator|=
name|md
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sigptr
operator|=
name|c
operator|->
name|shared_sigalgs
init|;
name|i
operator|<
name|c
operator|->
name|shared_sigalgslen
condition|;
name|i
operator|++
operator|,
name|sigptr
operator|++
control|)
block|{
name|idx
operator|=
name|tls12_get_pkey_idx
argument_list|(
name|sigptr
operator|->
name|rsign
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>
literal|0
operator|&&
name|c
operator|->
name|pkeys
index|[
name|idx
index|]
operator|.
name|digest
operator|==
name|NULL
condition|)
block|{
name|md
operator|=
name|tls12_get_hash
argument_list|(
name|sigptr
operator|->
name|rhash
argument_list|)
expr_stmt|;
name|c
operator|->
name|pkeys
index|[
name|idx
index|]
operator|.
name|digest
operator|=
name|md
expr_stmt|;
name|c
operator|->
name|pkeys
index|[
name|idx
index|]
operator|.
name|valid_flags
operator|=
name|CERT_PKEY_EXPLICIT_SIGN
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|SSL_PKEY_RSA_SIGN
condition|)
block|{
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|valid_flags
operator|=
name|CERT_PKEY_EXPLICIT_SIGN
expr_stmt|;
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|digest
operator|=
name|md
expr_stmt|;
block|}
block|}
block|}
comment|/*      * In strict mode leave unset digests as NULL to indicate we can't use      * the certificate for signing.      */
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|cert
operator|->
name|cert_flags
operator|&
name|SSL_CERT_FLAGS_CHECK_TLS_STRICT
operator|)
condition|)
block|{
comment|/*          * Set any remaining keys to default values. NOTE: if alg is not          * supported it stays as NULL.          */
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
if|if
condition|(
operator|!
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_DSA_SIGN
index|]
operator|.
name|digest
condition|)
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_DSA_SIGN
index|]
operator|.
name|digest
operator|=
name|EVP_sha1
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
operator|!
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_SIGN
index|]
operator|.
name|digest
condition|)
block|{
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_SIGN
index|]
operator|.
name|digest
operator|=
name|EVP_sha1
argument_list|()
expr_stmt|;
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|digest
operator|=
name|EVP_sha1
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDSA
if|if
condition|(
operator|!
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_ECC
index|]
operator|.
name|digest
condition|)
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_ECC
index|]
operator|.
name|digest
operator|=
name|EVP_sha1
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|SSL_get_sigalgs
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
modifier|*
name|psign
parameter_list|,
name|int
modifier|*
name|phash
parameter_list|,
name|int
modifier|*
name|psignhash
parameter_list|,
name|unsigned
name|char
modifier|*
name|rsig
parameter_list|,
name|unsigned
name|char
modifier|*
name|rhash
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|psig
init|=
name|s
operator|->
name|cert
operator|->
name|peer_sigalgs
decl_stmt|;
if|if
condition|(
name|psig
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
block|{
name|idx
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
operator|(
name|int
operator|)
name|s
operator|->
name|cert
operator|->
name|peer_sigalgslen
condition|)
return|return
literal|0
return|;
name|psig
operator|+=
name|idx
expr_stmt|;
if|if
condition|(
name|rhash
condition|)
operator|*
name|rhash
operator|=
name|psig
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|rsig
condition|)
operator|*
name|rsig
operator|=
name|psig
index|[
literal|1
index|]
expr_stmt|;
name|tls1_lookup_sigalg
argument_list|(
name|phash
argument_list|,
name|psign
argument_list|,
name|psignhash
argument_list|,
name|psig
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|->
name|cert
operator|->
name|peer_sigalgslen
operator|/
literal|2
return|;
block|}
end_function

begin_function
name|int
name|SSL_get_shared_sigalgs
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
modifier|*
name|psign
parameter_list|,
name|int
modifier|*
name|phash
parameter_list|,
name|int
modifier|*
name|psignhash
parameter_list|,
name|unsigned
name|char
modifier|*
name|rsig
parameter_list|,
name|unsigned
name|char
modifier|*
name|rhash
parameter_list|)
block|{
name|TLS_SIGALGS
modifier|*
name|shsigalgs
init|=
name|s
operator|->
name|cert
operator|->
name|shared_sigalgs
decl_stmt|;
if|if
condition|(
operator|!
name|shsigalgs
operator|||
name|idx
operator|>=
operator|(
name|int
operator|)
name|s
operator|->
name|cert
operator|->
name|shared_sigalgslen
condition|)
return|return
literal|0
return|;
name|shsigalgs
operator|+=
name|idx
expr_stmt|;
if|if
condition|(
name|phash
condition|)
operator|*
name|phash
operator|=
name|shsigalgs
operator|->
name|hash_nid
expr_stmt|;
if|if
condition|(
name|psign
condition|)
operator|*
name|psign
operator|=
name|shsigalgs
operator|->
name|sign_nid
expr_stmt|;
if|if
condition|(
name|psignhash
condition|)
operator|*
name|psignhash
operator|=
name|shsigalgs
operator|->
name|signandhash_nid
expr_stmt|;
if|if
condition|(
name|rsig
condition|)
operator|*
name|rsig
operator|=
name|shsigalgs
operator|->
name|rsign
expr_stmt|;
if|if
condition|(
name|rhash
condition|)
operator|*
name|rhash
operator|=
name|shsigalgs
operator|->
name|rhash
expr_stmt|;
return|return
name|s
operator|->
name|cert
operator|->
name|shared_sigalgslen
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
end_ifndef

begin_function
name|int
name|tls1_process_heartbeat
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|&
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|data
index|[
literal|0
index|]
decl_stmt|,
modifier|*
name|pl
decl_stmt|;
name|unsigned
name|short
name|hbtype
decl_stmt|;
name|unsigned
name|int
name|payload
decl_stmt|;
name|unsigned
name|int
name|padding
init|=
literal|16
decl_stmt|;
comment|/* Use minimum padding */
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|0
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
operator|&
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|data
index|[
literal|0
index|]
argument_list|,
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|length
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
comment|/* Read type and payload length first */
if|if
condition|(
literal|1
operator|+
literal|2
operator|+
literal|16
operator|>
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|length
condition|)
return|return
literal|0
return|;
comment|/* silently discard */
name|hbtype
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|payload
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|+
literal|2
operator|+
name|payload
operator|+
literal|16
operator|>
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|length
condition|)
return|return
literal|0
return|;
comment|/* silently discard per RFC 6520 sec. 4 */
name|pl
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|hbtype
operator|==
name|TLS1_HB_REQUEST
condition|)
block|{
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/*          * Allocate memory for the response, size is 1 bytes message type,          * plus 2 bytes payload length, plus payload, plus padding          */
name|buffer
operator|=
name|OPENSSL_malloc
argument_list|(
literal|1
operator|+
literal|2
operator|+
name|payload
operator|+
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|bp
operator|=
name|buffer
expr_stmt|;
comment|/* Enter response type, length and copy payload */
operator|*
name|bp
operator|++
operator|=
name|TLS1_HB_RESPONSE
expr_stmt|;
name|s2n
argument_list|(
name|payload
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|pl
argument_list|,
name|payload
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|payload
expr_stmt|;
comment|/* Random padding */
if|if
condition|(
name|RAND_bytes
argument_list|(
name|bp
argument_list|,
name|padding
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|r
operator|=
name|ssl3_write_bytes
argument_list|(
name|s
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buffer
argument_list|,
literal|3
operator|+
name|payload
operator|+
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
operator|&&
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|1
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buffer
argument_list|,
literal|3
operator|+
name|payload
operator|+
name|padding
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|hbtype
operator|==
name|TLS1_HB_RESPONSE
condition|)
block|{
name|unsigned
name|int
name|seq
decl_stmt|;
comment|/*          * We only send sequence numbers (2 bytes unsigned int), and 16          * random bytes, so we just try to read the sequence number          */
name|n2s
argument_list|(
name|pl
argument_list|,
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|payload
operator|==
literal|18
operator|&&
name|seq
operator|==
name|s
operator|->
name|tlsext_hb_seq
condition|)
block|{
name|s
operator|->
name|tlsext_hb_seq
operator|++
expr_stmt|;
name|s
operator|->
name|tlsext_hb_pending
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tls1_heartbeat
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|payload
init|=
literal|18
decl_stmt|;
comment|/* Sequence number + random bytes */
name|unsigned
name|int
name|padding
init|=
literal|16
decl_stmt|;
comment|/* Use minimum padding */
comment|/* Only send if peer supports and accepts HB requests... */
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|tlsext_heartbeat
operator|&
name|SSL_TLSEXT_HB_ENABLED
operator|)
operator|||
name|s
operator|->
name|tlsext_heartbeat
operator|&
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS1_HEARTBEAT
argument_list|,
name|SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* ...and there is none in flight yet... */
if|if
condition|(
name|s
operator|->
name|tlsext_hb_pending
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS1_HEARTBEAT
argument_list|,
name|SSL_R_TLS_HEARTBEAT_PENDING
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* ...and no handshake in progress. */
if|if
condition|(
name|SSL_in_init
argument_list|(
name|s
argument_list|)
operator|||
name|s
operator|->
name|in_handshake
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS1_HEARTBEAT
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Check if padding is too long, payload and padding must not exceed 2^14      * - 3 = 16381 bytes in total.      */
name|OPENSSL_assert
argument_list|(
name|payload
operator|+
name|padding
operator|<=
literal|16381
argument_list|)
expr_stmt|;
comment|/*-      * Create HeartBeat message, we just use a sequence number      * as payload to distuingish different messages and add      * some random stuff.      *  - Message Type, 1 byte      *  - Payload Length, 2 bytes (unsigned int)      *  - Payload, the sequence number (2 bytes uint)      *  - Payload, random bytes (16 bytes uint)      *  - Padding      */
name|buf
operator|=
name|OPENSSL_malloc
argument_list|(
literal|1
operator|+
literal|2
operator|+
name|payload
operator|+
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|p
operator|=
name|buf
expr_stmt|;
comment|/* Message Type */
operator|*
name|p
operator|++
operator|=
name|TLS1_HB_REQUEST
expr_stmt|;
comment|/* Payload length (18 bytes here) */
name|s2n
argument_list|(
name|payload
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Sequence number */
name|s2n
argument_list|(
name|s
operator|->
name|tlsext_hb_seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 16 random bytes */
if|if
condition|(
name|RAND_bytes
argument_list|(
name|p
argument_list|,
literal|16
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS1_HEARTBEAT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|+=
literal|16
expr_stmt|;
comment|/* Random padding */
if|if
condition|(
name|RAND_bytes
argument_list|(
name|p
argument_list|,
name|padding
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_TLS1_HEARTBEAT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
name|ssl3_write_bytes
argument_list|(
name|s
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buf
argument_list|,
literal|3
operator|+
name|payload
operator|+
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|1
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buf
argument_list|,
literal|3
operator|+
name|payload
operator|+
name|padding
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|s
operator|->
name|tlsext_hb_pending
operator|=
literal|1
expr_stmt|;
block|}
name|err
label|:
name|OPENSSL_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_SIGALGLEN
value|(TLSEXT_hash_num * TLSEXT_signature_num * 2)
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|size_t
name|sigalgcnt
decl_stmt|;
name|int
name|sigalgs
index|[
name|MAX_SIGALGLEN
index|]
decl_stmt|;
block|}
name|sig_cb_st
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|sig_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|elem
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|sig_cb_st
modifier|*
name|sarg
init|=
name|arg
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|char
name|etmp
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|sig_alg
decl_stmt|,
name|hash_alg
decl_stmt|;
if|if
condition|(
name|elem
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sarg
operator|->
name|sigalgcnt
operator|==
name|MAX_SIGALGLEN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len
operator|>
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|etmp
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|etmp
argument_list|,
name|elem
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|etmp
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|etmp
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
literal|0
return|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|etmp
argument_list|,
literal|"RSA"
argument_list|)
condition|)
name|sig_alg
operator|=
name|EVP_PKEY_RSA
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|etmp
argument_list|,
literal|"DSA"
argument_list|)
condition|)
name|sig_alg
operator|=
name|EVP_PKEY_DSA
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|etmp
argument_list|,
literal|"ECDSA"
argument_list|)
condition|)
name|sig_alg
operator|=
name|EVP_PKEY_EC
expr_stmt|;
else|else
return|return
literal|0
return|;
name|hash_alg
operator|=
name|OBJ_sn2nid
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_alg
operator|==
name|NID_undef
condition|)
name|hash_alg
operator|=
name|OBJ_ln2nid
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_alg
operator|==
name|NID_undef
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sarg
operator|->
name|sigalgcnt
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|sarg
operator|->
name|sigalgs
index|[
name|i
index|]
operator|==
name|sig_alg
operator|&&
name|sarg
operator|->
name|sigalgs
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|hash_alg
condition|)
return|return
literal|0
return|;
block|}
name|sarg
operator|->
name|sigalgs
index|[
name|sarg
operator|->
name|sigalgcnt
operator|++
index|]
operator|=
name|hash_alg
expr_stmt|;
name|sarg
operator|->
name|sigalgs
index|[
name|sarg
operator|->
name|sigalgcnt
operator|++
index|]
operator|=
name|sig_alg
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Set suppored signature algorithms based on a colon separated list of the  * form sig+hash e.g. RSA+SHA512:DSA+SHA512  */
end_comment

begin_function
name|int
name|tls1_set_sigalgs_list
parameter_list|(
name|CERT
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|client
parameter_list|)
block|{
name|sig_cb_st
name|sig
decl_stmt|;
name|sig
operator|.
name|sigalgcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|CONF_parse_list
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|,
literal|1
argument_list|,
name|sig_cb
argument_list|,
operator|&
name|sig
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
return|return
name|tls1_set_sigalgs
argument_list|(
name|c
argument_list|,
name|sig
operator|.
name|sigalgs
argument_list|,
name|sig
operator|.
name|sigalgcnt
argument_list|,
name|client
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|tls1_set_sigalgs
parameter_list|(
name|CERT
modifier|*
name|c
parameter_list|,
specifier|const
name|int
modifier|*
name|psig_nids
parameter_list|,
name|size_t
name|salglen
parameter_list|,
name|int
name|client
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|sigalgs
decl_stmt|,
modifier|*
name|sptr
decl_stmt|;
name|int
name|rhash
decl_stmt|,
name|rsign
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|salglen
operator|&
literal|1
condition|)
return|return
literal|0
return|;
name|sigalgs
operator|=
name|OPENSSL_malloc
argument_list|(
name|salglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigalgs
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sptr
operator|=
name|sigalgs
init|;
name|i
operator|<
name|salglen
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|rhash
operator|=
name|tls12_find_id
argument_list|(
operator|*
name|psig_nids
operator|++
argument_list|,
name|tls12_md
argument_list|,
sizeof|sizeof
argument_list|(
name|tls12_md
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tls12_lookup
argument_list|)
argument_list|)
expr_stmt|;
name|rsign
operator|=
name|tls12_find_id
argument_list|(
operator|*
name|psig_nids
operator|++
argument_list|,
name|tls12_sig
argument_list|,
sizeof|sizeof
argument_list|(
name|tls12_sig
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tls12_lookup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhash
operator|==
operator|-
literal|1
operator|||
name|rsign
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
operator|*
name|sptr
operator|++
operator|=
name|rhash
expr_stmt|;
operator|*
name|sptr
operator|++
operator|=
name|rsign
expr_stmt|;
block|}
if|if
condition|(
name|client
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|client_sigalgs
condition|)
name|OPENSSL_free
argument_list|(
name|c
operator|->
name|client_sigalgs
argument_list|)
expr_stmt|;
name|c
operator|->
name|client_sigalgs
operator|=
name|sigalgs
expr_stmt|;
name|c
operator|->
name|client_sigalgslen
operator|=
name|salglen
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|conf_sigalgs
condition|)
name|OPENSSL_free
argument_list|(
name|c
operator|->
name|conf_sigalgs
argument_list|)
expr_stmt|;
name|c
operator|->
name|conf_sigalgs
operator|=
name|sigalgs
expr_stmt|;
name|c
operator|->
name|conf_sigalgslen
operator|=
name|salglen
expr_stmt|;
block|}
return|return
literal|1
return|;
name|err
label|:
name|OPENSSL_free
argument_list|(
name|sigalgs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tls1_check_sig_alg
parameter_list|(
name|CERT
modifier|*
name|c
parameter_list|,
name|X509
modifier|*
name|x
parameter_list|,
name|int
name|default_nid
parameter_list|)
block|{
name|int
name|sig_nid
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|default_nid
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|sig_nid
operator|=
name|X509_get_signature_nid
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_nid
condition|)
return|return
name|sig_nid
operator|==
name|default_nid
condition|?
literal|1
else|:
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|shared_sigalgslen
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sig_nid
operator|==
name|c
operator|->
name|shared_sigalgs
index|[
name|i
index|]
operator|.
name|signandhash_nid
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check to see if a certificate issuer name matches list of CA names */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ssl_check_ca_name
argument_list|(
name|STACK_OF
argument_list|(
name|X509_NAME
argument_list|)
operator|*
name|names
argument_list|,
name|X509
operator|*
name|x
argument_list|)
block|{
name|X509_NAME
modifier|*
name|nm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|nm
operator|=
name|X509_get_issuer_name
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_NAME_num
argument_list|(
name|names
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|X509_NAME_cmp
argument_list|(
name|nm
argument_list|,
name|sk_X509_NAME_value
argument_list|(
name|names
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Check certificate chain is consistent with TLS extensions and is usable by  * server. This servers two purposes: it allows users to check chains before  * passing them to the server and it allows the server to check chains before  * attempting to use them.  */
end_comment

begin_comment
comment|/* Flags which need to be set for a certificate when stict mode not set */
end_comment

begin_define
define|#
directive|define
name|CERT_PKEY_VALID_FLAGS
define|\
value|(CERT_PKEY_EE_SIGNATURE|CERT_PKEY_EE_PARAM)
end_define

begin_comment
comment|/* Strict mode flags */
end_comment

begin_define
define|#
directive|define
name|CERT_PKEY_STRICT_FLAGS
define|\
value|(CERT_PKEY_VALID_FLAGS|CERT_PKEY_CA_SIGNATURE|CERT_PKEY_CA_PARAM \          | CERT_PKEY_ISSUER_NAME|CERT_PKEY_CERT_TYPE)
end_define

begin_decl_stmt
name|int
name|tls1_check_chain
argument_list|(
name|SSL
operator|*
name|s
argument_list|,
name|X509
operator|*
name|x
argument_list|,
name|EVP_PKEY
operator|*
name|pk
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|chain
argument_list|,
name|int
name|idx
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|int
name|check_flags
init|=
literal|0
decl_stmt|,
name|strict_mode
decl_stmt|;
name|CERT_PKEY
modifier|*
name|cpk
init|=
name|NULL
decl_stmt|;
name|CERT
modifier|*
name|c
init|=
name|s
operator|->
name|cert
decl_stmt|;
name|unsigned
name|int
name|suiteb_flags
init|=
name|tls1_suiteb
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|/* idx == -1 means checking server chains */
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* idx == -2 means checking client certificate chains */
if|if
condition|(
name|idx
operator|==
operator|-
literal|2
condition|)
block|{
name|cpk
operator|=
name|c
operator|->
name|key
expr_stmt|;
name|idx
operator|=
name|cpk
operator|-
name|c
operator|->
name|pkeys
expr_stmt|;
block|}
else|else
name|cpk
operator|=
name|c
operator|->
name|pkeys
operator|+
name|idx
expr_stmt|;
name|x
operator|=
name|cpk
operator|->
name|x509
expr_stmt|;
name|pk
operator|=
name|cpk
operator|->
name|privatekey
expr_stmt|;
name|chain
operator|=
name|cpk
operator|->
name|chain
expr_stmt|;
name|strict_mode
operator|=
name|c
operator|->
name|cert_flags
operator|&
name|SSL_CERT_FLAGS_CHECK_TLS_STRICT
expr_stmt|;
comment|/* If no cert or key, forget it */
if|if
condition|(
operator|!
name|x
operator|||
operator|!
name|pk
condition|)
goto|goto
name|end
goto|;
ifdef|#
directive|ifdef
name|OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL
comment|/* Allow any certificate to pass test */
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|cert_flags
operator|&
name|SSL_CERT_FLAG_BROKEN_PROTOCOL
condition|)
block|{
name|rv
operator|=
name|CERT_PKEY_STRICT_FLAGS
operator||
name|CERT_PKEY_EXPLICIT_SIGN
operator||
name|CERT_PKEY_VALID
operator||
name|CERT_PKEY_SIGN
expr_stmt|;
name|cpk
operator|->
name|valid_flags
operator|=
name|rv
expr_stmt|;
return|return
name|rv
return|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|!
name|x
operator|||
operator|!
name|pk
condition|)
return|return
literal|0
return|;
name|idx
operator|=
name|ssl_cert_type
argument_list|(
name|x
argument_list|,
name|pk
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|cpk
operator|=
name|c
operator|->
name|pkeys
operator|+
name|idx
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|cert_flags
operator|&
name|SSL_CERT_FLAGS_CHECK_TLS_STRICT
condition|)
name|check_flags
operator|=
name|CERT_PKEY_STRICT_FLAGS
expr_stmt|;
else|else
name|check_flags
operator|=
name|CERT_PKEY_VALID_FLAGS
expr_stmt|;
name|strict_mode
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|suiteb_flags
condition|)
block|{
name|int
name|ok
decl_stmt|;
if|if
condition|(
name|check_flags
condition|)
name|check_flags
operator||=
name|CERT_PKEY_SUITEB
expr_stmt|;
name|ok
operator|=
name|X509_chain_check_suiteb
argument_list|(
name|NULL
argument_list|,
name|x
argument_list|,
name|chain
argument_list|,
name|suiteb_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
name|X509_V_OK
condition|)
name|rv
operator||=
name|CERT_PKEY_SUITEB
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|check_flags
condition|)
goto|goto
name|end
goto|;
block|}
comment|/*      * Check all signature algorithms are consistent with signature      * algorithms extension if TLS 1.2 or later and strict mode.      */
if|if
condition|(
name|TLS1_get_version
argument_list|(
name|s
argument_list|)
operator|>=
name|TLS1_2_VERSION
operator|&&
name|strict_mode
condition|)
block|{
name|int
name|default_nid
decl_stmt|;
name|unsigned
name|char
name|rsign
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|peer_sigalgs
condition|)
name|default_nid
operator|=
literal|0
expr_stmt|;
comment|/* If no sigalgs extension use defaults from RFC5246 */
else|else
block|{
switch|switch
condition|(
name|idx
condition|)
block|{
case|case
name|SSL_PKEY_RSA_ENC
case|:
case|case
name|SSL_PKEY_RSA_SIGN
case|:
case|case
name|SSL_PKEY_DH_RSA
case|:
name|rsign
operator|=
name|TLSEXT_signature_rsa
expr_stmt|;
name|default_nid
operator|=
name|NID_sha1WithRSAEncryption
expr_stmt|;
break|break;
case|case
name|SSL_PKEY_DSA_SIGN
case|:
case|case
name|SSL_PKEY_DH_DSA
case|:
name|rsign
operator|=
name|TLSEXT_signature_dsa
expr_stmt|;
name|default_nid
operator|=
name|NID_dsaWithSHA1
expr_stmt|;
break|break;
case|case
name|SSL_PKEY_ECC
case|:
name|rsign
operator|=
name|TLSEXT_signature_ecdsa
expr_stmt|;
name|default_nid
operator|=
name|NID_ecdsa_with_SHA1
expr_stmt|;
break|break;
default|default:
name|default_nid
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/*          * If peer sent no signature algorithms extension and we have set          * preferred signature algorithms check we support sha1.          */
if|if
condition|(
name|default_nid
operator|>
literal|0
operator|&&
name|c
operator|->
name|conf_sigalgs
condition|)
block|{
name|size_t
name|j
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
name|c
operator|->
name|conf_sigalgs
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|c
operator|->
name|conf_sigalgslen
condition|;
name|j
operator|+=
literal|2
operator|,
name|p
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
name|TLSEXT_hash_sha1
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|rsign
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|c
operator|->
name|conf_sigalgslen
condition|)
block|{
if|if
condition|(
name|check_flags
condition|)
goto|goto
name|skip_sigs
goto|;
else|else
goto|goto
name|end
goto|;
block|}
block|}
comment|/* Check signature algorithm of each cert in chain */
if|if
condition|(
operator|!
name|tls1_check_sig_alg
argument_list|(
name|c
argument_list|,
name|x
argument_list|,
name|default_nid
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|check_flags
condition|)
goto|goto
name|end
goto|;
block|}
else|else
name|rv
operator||=
name|CERT_PKEY_EE_SIGNATURE
expr_stmt|;
name|rv
operator||=
name|CERT_PKEY_CA_SIGNATURE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_num
argument_list|(
name|chain
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|tls1_check_sig_alg
argument_list|(
name|c
argument_list|,
name|sk_X509_value
argument_list|(
name|chain
argument_list|,
name|i
argument_list|)
argument_list|,
name|default_nid
argument_list|)
condition|)
block|{
if|if
condition|(
name|check_flags
condition|)
block|{
name|rv
operator|&=
operator|~
name|CERT_PKEY_CA_SIGNATURE
expr_stmt|;
break|break;
block|}
else|else
goto|goto
name|end
goto|;
block|}
block|}
block|}
comment|/* Else not TLS 1.2, so mark EE and CA signing algorithms OK */
elseif|else
if|if
condition|(
name|check_flags
condition|)
name|rv
operator||=
name|CERT_PKEY_EE_SIGNATURE
operator||
name|CERT_PKEY_CA_SIGNATURE
expr_stmt|;
name|skip_sigs
label|:
comment|/* Check cert parameters are consistent */
if|if
condition|(
name|tls1_check_cert_param
argument_list|(
name|s
argument_list|,
name|x
argument_list|,
name|check_flags
condition|?
literal|1
else|:
literal|2
argument_list|)
condition|)
name|rv
operator||=
name|CERT_PKEY_EE_PARAM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|check_flags
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|s
operator|->
name|server
condition|)
name|rv
operator||=
name|CERT_PKEY_CA_PARAM
expr_stmt|;
comment|/* In strict mode check rest of chain too */
elseif|else
if|if
condition|(
name|strict_mode
condition|)
block|{
name|rv
operator||=
name|CERT_PKEY_CA_PARAM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_num
argument_list|(
name|chain
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|X509
modifier|*
name|ca
init|=
name|sk_X509_value
argument_list|(
name|chain
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tls1_check_cert_param
argument_list|(
name|s
argument_list|,
name|ca
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|check_flags
condition|)
block|{
name|rv
operator|&=
operator|~
name|CERT_PKEY_CA_PARAM
expr_stmt|;
break|break;
block|}
else|else
goto|goto
name|end
goto|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|server
operator|&&
name|strict_mode
condition|)
block|{
name|STACK_OF
argument_list|(
name|X509_NAME
argument_list|)
operator|*
name|ca_dn
expr_stmt|;
name|int
name|check_type
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|pk
operator|->
name|type
condition|)
block|{
case|case
name|EVP_PKEY_RSA
case|:
name|check_type
operator|=
name|TLS_CT_RSA_SIGN
expr_stmt|;
break|break;
case|case
name|EVP_PKEY_DSA
case|:
name|check_type
operator|=
name|TLS_CT_DSS_SIGN
expr_stmt|;
break|break;
case|case
name|EVP_PKEY_EC
case|:
name|check_type
operator|=
name|TLS_CT_ECDSA_SIGN
expr_stmt|;
break|break;
case|case
name|EVP_PKEY_DH
case|:
case|case
name|EVP_PKEY_DHX
case|:
block|{
name|int
name|cert_type
init|=
name|X509_certificate_type
argument_list|(
name|x
argument_list|,
name|pk
argument_list|)
decl_stmt|;
if|if
condition|(
name|cert_type
operator|&
name|EVP_PKS_RSA
condition|)
name|check_type
operator|=
name|TLS_CT_RSA_FIXED_DH
expr_stmt|;
if|if
condition|(
name|cert_type
operator|&
name|EVP_PKS_DSA
condition|)
name|check_type
operator|=
name|TLS_CT_DSS_FIXED_DH
expr_stmt|;
block|}
block|}
if|if
condition|(
name|check_type
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|ctypes
decl_stmt|;
name|int
name|ctypelen
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|ctypes
condition|)
block|{
name|ctypes
operator|=
name|c
operator|->
name|ctypes
expr_stmt|;
name|ctypelen
operator|=
operator|(
name|int
operator|)
name|c
operator|->
name|ctype_num
expr_stmt|;
block|}
else|else
block|{
name|ctypes
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|ctype
expr_stmt|;
name|ctypelen
operator|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|ctype_num
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctypelen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctypes
index|[
name|i
index|]
operator|==
name|check_type
condition|)
block|{
name|rv
operator||=
name|CERT_PKEY_CERT_TYPE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|rv
operator|&
name|CERT_PKEY_CERT_TYPE
operator|)
operator|&&
operator|!
name|check_flags
condition|)
goto|goto
name|end
goto|;
block|}
else|else
name|rv
operator||=
name|CERT_PKEY_CERT_TYPE
expr_stmt|;
name|ca_dn
operator|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|ca_names
expr_stmt|;
if|if
condition|(
operator|!
name|sk_X509_NAME_num
argument_list|(
name|ca_dn
argument_list|)
condition|)
name|rv
operator||=
name|CERT_PKEY_ISSUER_NAME
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rv
operator|&
name|CERT_PKEY_ISSUER_NAME
operator|)
condition|)
block|{
if|if
condition|(
name|ssl_check_ca_name
argument_list|(
name|ca_dn
argument_list|,
name|x
argument_list|)
condition|)
name|rv
operator||=
name|CERT_PKEY_ISSUER_NAME
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|rv
operator|&
name|CERT_PKEY_ISSUER_NAME
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_num
argument_list|(
name|chain
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|X509
modifier|*
name|xtmp
init|=
name|sk_X509_value
argument_list|(
name|chain
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ssl_check_ca_name
argument_list|(
name|ca_dn
argument_list|,
name|xtmp
argument_list|)
condition|)
block|{
name|rv
operator||=
name|CERT_PKEY_ISSUER_NAME
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|check_flags
operator|&&
operator|!
operator|(
name|rv
operator|&
name|CERT_PKEY_ISSUER_NAME
operator|)
condition|)
goto|goto
name|end
goto|;
block|}
else|else
name|rv
operator||=
name|CERT_PKEY_ISSUER_NAME
operator||
name|CERT_PKEY_CERT_TYPE
expr_stmt|;
if|if
condition|(
operator|!
name|check_flags
operator|||
operator|(
name|rv
operator|&
name|check_flags
operator|)
operator|==
name|check_flags
condition|)
name|rv
operator||=
name|CERT_PKEY_VALID
expr_stmt|;
name|end
label|:
if|if
condition|(
name|TLS1_get_version
argument_list|(
name|s
argument_list|)
operator|>=
name|TLS1_2_VERSION
condition|)
block|{
if|if
condition|(
name|cpk
operator|->
name|valid_flags
operator|&
name|CERT_PKEY_EXPLICIT_SIGN
condition|)
name|rv
operator||=
name|CERT_PKEY_EXPLICIT_SIGN
operator||
name|CERT_PKEY_SIGN
expr_stmt|;
elseif|else
if|if
condition|(
name|cpk
operator|->
name|digest
condition|)
name|rv
operator||=
name|CERT_PKEY_SIGN
expr_stmt|;
block|}
else|else
name|rv
operator||=
name|CERT_PKEY_SIGN
operator||
name|CERT_PKEY_EXPLICIT_SIGN
expr_stmt|;
comment|/*      * When checking a CERT_PKEY structure all flags are irrelevant if the      * chain is invalid.      */
if|if
condition|(
operator|!
name|check_flags
condition|)
block|{
if|if
condition|(
name|rv
operator|&
name|CERT_PKEY_VALID
condition|)
name|cpk
operator|->
name|valid_flags
operator|=
name|rv
expr_stmt|;
else|else
block|{
comment|/* Preserve explicit sign flag, clear rest */
name|cpk
operator|->
name|valid_flags
operator|&=
name|CERT_PKEY_EXPLICIT_SIGN
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|rv
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Set validity of certificates in an SSL structure */
end_comment

begin_function
name|void
name|tls1_set_cert_validity
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|tls1_check_chain
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SSL_PKEY_RSA_ENC
argument_list|)
expr_stmt|;
name|tls1_check_chain
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SSL_PKEY_RSA_SIGN
argument_list|)
expr_stmt|;
name|tls1_check_chain
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SSL_PKEY_DSA_SIGN
argument_list|)
expr_stmt|;
name|tls1_check_chain
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SSL_PKEY_DH_RSA
argument_list|)
expr_stmt|;
name|tls1_check_chain
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SSL_PKEY_DH_DSA
argument_list|)
expr_stmt|;
name|tls1_check_chain
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SSL_PKEY_ECC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* User level utiity function to check a chain is suitable */
end_comment

begin_decl_stmt
name|int
name|SSL_check_chain
argument_list|(
name|SSL
operator|*
name|s
argument_list|,
name|X509
operator|*
name|x
argument_list|,
name|EVP_PKEY
operator|*
name|pk
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|chain
argument_list|)
block|{
return|return
name|tls1_check_chain
argument_list|(
name|s
argument_list|,
name|x
argument_list|,
name|pk
argument_list|,
name|chain
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

