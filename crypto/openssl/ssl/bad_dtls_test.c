begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.  *  * Licensed under the OpenSSL license (the "License").  You may not use  * this file except in compliance with the License.  You can obtain a copy  * in the file LICENSE in the source distribution or at  * https://www.openssl.org/source/license.html  */
end_comment

begin_comment
comment|/*  * Unit test for Cisco DTLS1_BAD_VER session resume, as used by  * AnyConnect VPN protocol.  *  * This is designed to exercise the code paths in  * http://git.infradead.org/users/dwmw2/openconnect.git/blob/HEAD:/dtls.c  * which have frequently been affected by regressions in DTLS1_BAD_VER  * support.  *  * Note that unlike other SSL tests, we don't test against our own SSL  * server method. Firstly because we don't have one; we *only* support  * DTLS1_BAD_VER as a client. And secondly because even if that were  * fixed up it's the wrong thing to test against â because if changes  * are made in generic DTLS code which don't take DTLS1_BAD_VER into  * account, there's plenty of scope for making those changes such that  * they break *both* the client and the server in the same way.  *  * So we handle the server side manually. In a session resume there isn't  * much to be done anyway.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* On Windows this will include<winsock2.h> and thus it needs to be  * included *before* anything that includes<windows.h>. Ick. */
end_comment

begin_include
include|#
directive|include
file|"e_os.h"
end_include

begin_comment
comment|/* for 'inline' */
end_comment

begin_include
include|#
directive|include
file|<openssl/bio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_comment
comment|/* PACKET functions lifted from OpenSSL 1.1's ssl/packet_locl.h */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Pointer to where we are currently reading from */
specifier|const
name|unsigned
name|char
modifier|*
name|curr
decl_stmt|;
comment|/* Number of bytes remaining */
name|size_t
name|remaining
decl_stmt|;
block|}
name|PACKET
typedef|;
end_typedef

begin_comment
comment|/* Internal unchecked shorthand; don't use outside this file. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|packet_forward
parameter_list|(
name|PACKET
modifier|*
name|pkt
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|pkt
operator|->
name|curr
operator|+=
name|len
expr_stmt|;
name|pkt
operator|->
name|remaining
operator|-=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns the number of bytes remaining to be read in the PACKET  */
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|PACKET_remaining
parameter_list|(
specifier|const
name|PACKET
modifier|*
name|pkt
parameter_list|)
block|{
return|return
name|pkt
operator|->
name|remaining
return|;
block|}
end_function

begin_comment
comment|/*  * Initialise a PACKET with |len| bytes held in |buf|. This does not make a  * copy of the data so |buf| must be present for the whole time that the PACKET  * is being used.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|PACKET_buf_init
parameter_list|(
name|PACKET
modifier|*
name|pkt
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
comment|/* Sanity check for negative values. */
if|if
condition|(
name|len
operator|>
operator|(
name|size_t
operator|)
literal|65536
condition|)
return|return
literal|0
return|;
name|pkt
operator|->
name|curr
operator|=
name|buf
expr_stmt|;
name|pkt
operator|->
name|remaining
operator|=
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 1 if the packet has length |num| and its contents equal the |num|  * bytes read from |ptr|. Returns 0 otherwise (lengths or contents not equal).  * If lengths are equal, performs the comparison in constant time.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|PACKET_equal
parameter_list|(
specifier|const
name|PACKET
modifier|*
name|pkt
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|num
parameter_list|)
block|{
if|if
condition|(
name|PACKET_remaining
argument_list|(
name|pkt
argument_list|)
operator|!=
name|num
condition|)
return|return
literal|0
return|;
return|return
name|CRYPTO_memcmp
argument_list|(
name|pkt
operator|->
name|curr
argument_list|,
name|ptr
argument_list|,
name|num
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Peek ahead at 2 bytes in network order from |pkt| and store the value in  * |*data|  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|PACKET_peek_net_2
parameter_list|(
specifier|const
name|PACKET
modifier|*
name|pkt
parameter_list|,
name|unsigned
name|int
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|PACKET_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
literal|2
condition|)
return|return
literal|0
return|;
operator|*
name|data
operator|=
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|*
name|pkt
operator|->
name|curr
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
operator|*
name|data
operator||=
operator|*
operator|(
name|pkt
operator|->
name|curr
operator|+
literal|1
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Equivalent of n2s */
end_comment

begin_comment
comment|/* Get 2 bytes in network order from |pkt| and store the value in |*data| */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|PACKET_get_net_2
parameter_list|(
name|PACKET
modifier|*
name|pkt
parameter_list|,
name|unsigned
name|int
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|!
name|PACKET_peek_net_2
argument_list|(
name|pkt
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|0
return|;
name|packet_forward
argument_list|(
name|pkt
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Peek ahead at 1 byte from |pkt| and store the value in |*data| */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|PACKET_peek_1
parameter_list|(
specifier|const
name|PACKET
modifier|*
name|pkt
parameter_list|,
name|unsigned
name|int
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|!
name|PACKET_remaining
argument_list|(
name|pkt
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|data
operator|=
operator|*
name|pkt
operator|->
name|curr
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Get 1 byte from |pkt| and store the value in |*data| */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|PACKET_get_1
parameter_list|(
name|PACKET
modifier|*
name|pkt
parameter_list|,
name|unsigned
name|int
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|!
name|PACKET_peek_1
argument_list|(
name|pkt
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|0
return|;
name|packet_forward
argument_list|(
name|pkt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Peek ahead at |len| bytes from the |pkt| and store a pointer to them in  * |*data|. This just points at the underlying buffer that |pkt| is using. The  * caller should not free this data directly (it will be freed when the  * underlying buffer gets freed  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|PACKET_peek_bytes
parameter_list|(
specifier|const
name|PACKET
modifier|*
name|pkt
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|PACKET_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
name|len
condition|)
return|return
literal|0
return|;
operator|*
name|data
operator|=
name|pkt
operator|->
name|curr
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Read |len| bytes from the |pkt| and store a pointer to them in |*data|. This  * just points at the underlying buffer that |pkt| is using. The caller should  * not free this data directly (it will be freed when the underlying buffer gets  * freed  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|PACKET_get_bytes
parameter_list|(
name|PACKET
modifier|*
name|pkt
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
operator|!
name|PACKET_peek_bytes
argument_list|(
name|pkt
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
name|packet_forward
argument_list|(
name|pkt
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Peek ahead at |len| bytes from |pkt| and copy them to |data| */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|PACKET_peek_copy_bytes
parameter_list|(
specifier|const
name|PACKET
modifier|*
name|pkt
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|PACKET_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
name|len
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|pkt
operator|->
name|curr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Read |len| bytes from |pkt| and copy them to |data|.  * The caller is responsible for ensuring that |data| can hold |len| bytes.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|PACKET_copy_bytes
parameter_list|(
name|PACKET
modifier|*
name|pkt
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
operator|!
name|PACKET_peek_copy_bytes
argument_list|(
name|pkt
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
name|packet_forward
argument_list|(
name|pkt
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Move the current reading position forward |len| bytes */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|PACKET_forward
parameter_list|(
name|PACKET
modifier|*
name|pkt
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|PACKET_remaining
argument_list|(
name|pkt
argument_list|)
operator|<
name|len
condition|)
return|return
literal|0
return|;
name|packet_forward
argument_list|(
name|pkt
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Reads a variable-length vector prefixed with a one-byte length, and stores  * the contents in |subpkt|. |pkt| can equal |subpkt|.  * Data is not copied: the |subpkt| packet will share its underlying buffer with  * the original |pkt|, so data wrapped by |pkt| must outlive the |subpkt|.  * Upon failure, the original |pkt| and |subpkt| are not modified.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|PACKET_get_length_prefixed_1
parameter_list|(
name|PACKET
modifier|*
name|pkt
parameter_list|,
name|PACKET
modifier|*
name|subpkt
parameter_list|)
block|{
name|unsigned
name|int
name|length
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|PACKET
name|tmp
init|=
operator|*
name|pkt
decl_stmt|;
if|if
condition|(
operator|!
name|PACKET_get_1
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|length
argument_list|)
operator|||
operator|!
name|PACKET_get_bytes
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|data
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
operator|*
name|pkt
operator|=
name|tmp
expr_stmt|;
name|subpkt
operator|->
name|curr
operator|=
name|data
expr_stmt|;
name|subpkt
operator|->
name|remaining
operator|=
name|length
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OSSL_NELEM
parameter_list|(
name|x
parameter_list|)
value|(sizeof(x)/sizeof(x[0]))
end_define

begin_comment
comment|/* For DTLS1_BAD_VER packets the MAC doesn't include the handshake header */
end_comment

begin_define
define|#
directive|define
name|MAC_OFFSET
value|(DTLS1_RT_HEADER_LENGTH + DTLS1_HM_HEADER_LENGTH)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|client_random
index|[
name|SSL3_RANDOM_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|server_random
index|[
name|SSL3_RANDOM_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are all generated locally, sized purely according to our own whim */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|session_id
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|master_secret
index|[
literal|48
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|cookie
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We've hard-coded the cipher suite; we know it's 104 bytes */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|key_block
index|[
literal|104
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|mac_key
value|(key_block + 20)
end_define

begin_define
define|#
directive|define
name|dec_key
value|(key_block + 40)
end_define

begin_define
define|#
directive|define
name|enc_key
value|(key_block + 56)
end_define

begin_decl_stmt
specifier|static
name|EVP_MD_CTX
name|handshake_md5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EVP_MD_CTX
name|handshake_sha1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PRF lifted from ssl/t1_enc.c since we can't easily use it directly */
end_comment

begin_function
specifier|static
name|int
name|tls1_P_hash
parameter_list|(
specifier|const
name|EVP_MD
modifier|*
name|md
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sec
parameter_list|,
name|int
name|sec_len
parameter_list|,
specifier|const
name|void
modifier|*
name|seed1
parameter_list|,
name|int
name|seed1_len
parameter_list|,
specifier|const
name|void
modifier|*
name|seed2
parameter_list|,
name|int
name|seed2_len
parameter_list|,
specifier|const
name|void
modifier|*
name|seed3
parameter_list|,
name|int
name|seed3_len
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|int
name|olen
parameter_list|)
block|{
name|int
name|chunk
decl_stmt|;
name|size_t
name|j
decl_stmt|;
name|EVP_MD_CTX
name|ctx
decl_stmt|,
name|ctx_tmp
decl_stmt|,
name|ctx_init
decl_stmt|;
name|EVP_PKEY
modifier|*
name|prf_mac_key
decl_stmt|;
name|unsigned
name|char
name|A1
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
name|size_t
name|A1_len
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|chunk
operator|=
name|EVP_MD_size
argument_list|(
name|md
argument_list|)
expr_stmt|;
name|OPENSSL_assert
argument_list|(
name|chunk
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_init
argument_list|(
operator|&
name|ctx_tmp
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_init
argument_list|(
operator|&
name|ctx_init
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_set_flags
argument_list|(
operator|&
name|ctx_init
argument_list|,
name|EVP_MD_CTX_FLAG_NON_FIPS_ALLOW
argument_list|)
expr_stmt|;
name|prf_mac_key
operator|=
name|EVP_PKEY_new_mac_key
argument_list|(
name|EVP_PKEY_HMAC
argument_list|,
name|NULL
argument_list|,
name|sec
argument_list|,
name|sec_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prf_mac_key
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|EVP_DigestSignInit
argument_list|(
operator|&
name|ctx_init
argument_list|,
name|NULL
argument_list|,
name|md
argument_list|,
name|NULL
argument_list|,
name|prf_mac_key
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|EVP_MD_CTX_copy_ex
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|ctx_init
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|seed1
operator|&&
operator|!
name|EVP_DigestSignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|seed1
argument_list|,
name|seed1_len
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|seed2
operator|&&
operator|!
name|EVP_DigestSignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|seed2
argument_list|,
name|seed2_len
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|seed3
operator|&&
operator|!
name|EVP_DigestSignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|seed3
argument_list|,
name|seed3_len
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|EVP_DigestSignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|A1
argument_list|,
operator|&
name|A1_len
argument_list|)
condition|)
goto|goto
name|err
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Reinit mac contexts */
if|if
condition|(
operator|!
name|EVP_MD_CTX_copy_ex
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|ctx_init
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|EVP_DigestSignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|A1
argument_list|,
name|A1_len
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|olen
operator|>
name|chunk
operator|&&
operator|!
name|EVP_MD_CTX_copy_ex
argument_list|(
operator|&
name|ctx_tmp
argument_list|,
operator|&
name|ctx
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|seed1
operator|&&
operator|!
name|EVP_DigestSignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|seed1
argument_list|,
name|seed1_len
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|seed2
operator|&&
operator|!
name|EVP_DigestSignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|seed2
argument_list|,
name|seed2_len
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|seed3
operator|&&
operator|!
name|EVP_DigestSignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|seed3
argument_list|,
name|seed3_len
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|olen
operator|>
name|chunk
condition|)
block|{
if|if
condition|(
operator|!
name|EVP_DigestSignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|out
argument_list|,
operator|&
name|j
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|out
operator|+=
name|j
expr_stmt|;
name|olen
operator|-=
name|j
expr_stmt|;
comment|/* calc the next A1 value */
if|if
condition|(
operator|!
name|EVP_DigestSignFinal
argument_list|(
operator|&
name|ctx_tmp
argument_list|,
name|A1
argument_list|,
operator|&
name|A1_len
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
comment|/* last one */
if|if
condition|(
operator|!
name|EVP_DigestSignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|A1
argument_list|,
operator|&
name|A1_len
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|memcpy
argument_list|(
name|out
argument_list|,
name|A1
argument_list|,
name|olen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|EVP_PKEY_free
argument_list|(
name|prf_mac_key
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|ctx_tmp
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|ctx_init
argument_list|)
expr_stmt|;
name|OPENSSL_cleanse
argument_list|(
name|A1
argument_list|,
sizeof|sizeof
argument_list|(
name|A1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* seed1 through seed5 are virtually concatenated */
end_comment

begin_function
specifier|static
name|int
name|do_PRF
parameter_list|(
specifier|const
name|void
modifier|*
name|seed1
parameter_list|,
name|int
name|seed1_len
parameter_list|,
specifier|const
name|void
modifier|*
name|seed2
parameter_list|,
name|int
name|seed2_len
parameter_list|,
specifier|const
name|void
modifier|*
name|seed3
parameter_list|,
name|int
name|seed3_len
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|int
name|olen
parameter_list|)
block|{
name|unsigned
name|char
name|out2
index|[
literal|104
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|olen
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|out2
argument_list|)
condition|)
return|return
literal|0
return|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|master_secret
argument_list|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|tls1_P_hash
argument_list|(
name|EVP_md5
argument_list|()
argument_list|,
name|master_secret
argument_list|,
name|len
argument_list|,
name|seed1
argument_list|,
name|seed1_len
argument_list|,
name|seed2
argument_list|,
name|seed2_len
argument_list|,
name|seed3
argument_list|,
name|seed3_len
argument_list|,
name|out
argument_list|,
name|olen
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|tls1_P_hash
argument_list|(
name|EVP_sha1
argument_list|()
argument_list|,
name|master_secret
operator|+
name|len
argument_list|,
name|len
argument_list|,
name|seed1
argument_list|,
name|seed1_len
argument_list|,
name|seed2
argument_list|,
name|seed2_len
argument_list|,
name|seed3
argument_list|,
name|seed3_len
argument_list|,
name|out2
argument_list|,
name|olen
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|olen
condition|;
name|i
operator|++
control|)
block|{
name|out
index|[
name|i
index|]
operator|^=
name|out2
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|SSL_SESSION
modifier|*
name|client_session
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|session_asn1
index|[]
init|=
block|{
literal|0x30
block|,
literal|0x5F
block|,
comment|/* SEQUENCE, length 0x5F */
literal|0x02
block|,
literal|0x01
block|,
literal|0x01
block|,
comment|/* INTEGER, SSL_SESSION_ASN1_VERSION */
literal|0x02
block|,
literal|0x02
block|,
literal|0x01
block|,
literal|0x00
block|,
comment|/* INTEGER, DTLS1_BAD_VER */
literal|0x04
block|,
literal|0x02
block|,
literal|0x00
block|,
literal|0x2F
block|,
comment|/* OCTET_STRING, AES128-SHA */
literal|0x04
block|,
literal|0x20
block|,
comment|/* OCTET_STRING, session id */
define|#
directive|define
name|SS_SESSID_OFS
value|15
comment|/* Session ID goes here */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x30
block|,
comment|/* OCTET_STRING, master secret */
define|#
directive|define
name|SS_SECRET_OFS
value|49
comment|/* Master secret goes here */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,     }
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
name|session_asn1
decl_stmt|;
comment|/* Copy the randomly-generated fields into the above ASN1 */
name|memcpy
argument_list|(
name|session_asn1
operator|+
name|SS_SESSID_OFS
argument_list|,
name|session_id
argument_list|,
sizeof|sizeof
argument_list|(
name|session_id
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|session_asn1
operator|+
name|SS_SECRET_OFS
argument_list|,
name|master_secret
argument_list|,
sizeof|sizeof
argument_list|(
name|master_secret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d2i_SSL_SESSION
argument_list|(
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|session_asn1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 for initial ClientHello, 2 for ClientHello with cookie */
end_comment

begin_function
specifier|static
name|int
name|validate_client_hello
parameter_list|(
name|BIO
modifier|*
name|wbio
parameter_list|)
block|{
name|PACKET
name|pkt
decl_stmt|,
name|pkt2
decl_stmt|;
name|long
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|cookie_found
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|u
decl_stmt|;
name|len
operator|=
name|BIO_get_mem_data
argument_list|(
name|wbio
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PACKET_buf_init
argument_list|(
operator|&
name|pkt
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check record header type */
if|if
condition|(
operator|!
name|PACKET_get_1
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|u
argument_list|)
operator|||
name|u
operator|!=
name|SSL3_RT_HANDSHAKE
condition|)
return|return
literal|0
return|;
comment|/* Version */
if|if
condition|(
operator|!
name|PACKET_get_net_2
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|u
argument_list|)
operator|||
name|u
operator|!=
name|DTLS1_BAD_VER
condition|)
return|return
literal|0
return|;
comment|/* Skip the rest of the record header */
if|if
condition|(
operator|!
name|PACKET_forward
argument_list|(
operator|&
name|pkt
argument_list|,
name|DTLS1_RT_HEADER_LENGTH
operator|-
literal|3
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check it's a ClientHello */
if|if
condition|(
operator|!
name|PACKET_get_1
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|u
argument_list|)
operator|||
name|u
operator|!=
name|SSL3_MT_CLIENT_HELLO
condition|)
return|return
literal|0
return|;
comment|/* Skip the rest of the handshake message header */
if|if
condition|(
operator|!
name|PACKET_forward
argument_list|(
operator|&
name|pkt
argument_list|,
name|DTLS1_HM_HEADER_LENGTH
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check client version */
if|if
condition|(
operator|!
name|PACKET_get_net_2
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|u
argument_list|)
operator|||
name|u
operator|!=
name|DTLS1_BAD_VER
condition|)
return|return
literal|0
return|;
comment|/* Store random */
if|if
condition|(
operator|!
name|PACKET_copy_bytes
argument_list|(
operator|&
name|pkt
argument_list|,
name|client_random
argument_list|,
name|SSL3_RANDOM_SIZE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check session id length and content */
if|if
condition|(
operator|!
name|PACKET_get_length_prefixed_1
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|pkt2
argument_list|)
operator|||
operator|!
name|PACKET_equal
argument_list|(
operator|&
name|pkt2
argument_list|,
name|session_id
argument_list|,
sizeof|sizeof
argument_list|(
name|session_id
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check cookie */
if|if
condition|(
operator|!
name|PACKET_get_length_prefixed_1
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|pkt2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|PACKET_remaining
argument_list|(
operator|&
name|pkt2
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PACKET_equal
argument_list|(
operator|&
name|pkt2
argument_list|,
name|cookie
argument_list|,
sizeof|sizeof
argument_list|(
name|cookie
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|cookie_found
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Skip ciphers */
if|if
condition|(
operator|!
name|PACKET_get_net_2
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|u
argument_list|)
operator|||
operator|!
name|PACKET_forward
argument_list|(
operator|&
name|pkt
argument_list|,
name|u
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Skip compression */
if|if
condition|(
operator|!
name|PACKET_get_1
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|u
argument_list|)
operator|||
operator|!
name|PACKET_forward
argument_list|(
operator|&
name|pkt
argument_list|,
name|u
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Skip extensions */
if|if
condition|(
operator|!
name|PACKET_get_net_2
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|u
argument_list|)
operator|||
operator|!
name|PACKET_forward
argument_list|(
operator|&
name|pkt
argument_list|,
name|u
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Now we are at the end */
if|if
condition|(
name|PACKET_remaining
argument_list|(
operator|&
name|pkt
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Update handshake MAC for second ClientHello (with cookie) */
if|if
condition|(
name|cookie_found
operator|&&
operator|(
operator|!
name|EVP_DigestUpdate
argument_list|(
operator|&
name|handshake_md5
argument_list|,
name|data
operator|+
name|MAC_OFFSET
argument_list|,
name|len
operator|-
name|MAC_OFFSET
argument_list|)
operator|||
operator|!
name|EVP_DigestUpdate
argument_list|(
operator|&
name|handshake_sha1
argument_list|,
name|data
operator|+
name|MAC_OFFSET
argument_list|,
name|len
operator|-
name|MAC_OFFSET
argument_list|)
operator|)
condition|)
name|printf
argument_list|(
literal|"EVP_DigestUpdate() failed\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_reset
argument_list|(
name|wbio
argument_list|)
expr_stmt|;
return|return
literal|1
operator|+
name|cookie_found
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_hello_verify
parameter_list|(
name|BIO
modifier|*
name|rbio
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|hello_verify
index|[]
init|=
block|{
literal|0x16
block|,
comment|/* Handshake */
literal|0x01
block|,
literal|0x00
block|,
comment|/* DTLS1_BAD_VER */
literal|0x00
block|,
literal|0x00
block|,
comment|/* Epoch 0 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* Seq# 0 */
literal|0x00
block|,
literal|0x23
block|,
comment|/* Length */
literal|0x03
block|,
comment|/* Hello Verify */
literal|0x00
block|,
literal|0x00
block|,
literal|0x17
block|,
comment|/* Length */
literal|0x00
block|,
literal|0x00
block|,
comment|/* Seq# 0 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* Fragment offset */
literal|0x00
block|,
literal|0x00
block|,
literal|0x17
block|,
comment|/* Fragment length */
literal|0x01
block|,
literal|0x00
block|,
comment|/* DTLS1_BAD_VER */
literal|0x14
block|,
comment|/* Cookie length */
define|#
directive|define
name|HV_COOKIE_OFS
value|28
comment|/* Cookie goes here */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,     }
decl_stmt|;
name|memcpy
argument_list|(
name|hello_verify
operator|+
name|HV_COOKIE_OFS
argument_list|,
name|cookie
argument_list|,
sizeof|sizeof
argument_list|(
name|cookie
argument_list|)
argument_list|)
expr_stmt|;
name|BIO_write
argument_list|(
name|rbio
argument_list|,
name|hello_verify
argument_list|,
sizeof|sizeof
argument_list|(
name|hello_verify
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_server_hello
parameter_list|(
name|BIO
modifier|*
name|rbio
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|server_hello
index|[]
init|=
block|{
literal|0x16
block|,
comment|/* Handshake */
literal|0x01
block|,
literal|0x00
block|,
comment|/* DTLS1_BAD_VER */
literal|0x00
block|,
literal|0x00
block|,
comment|/* Epoch 0 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
comment|/* Seq# 1 */
literal|0x00
block|,
literal|0x52
block|,
comment|/* Length */
literal|0x02
block|,
comment|/* Server Hello */
literal|0x00
block|,
literal|0x00
block|,
literal|0x46
block|,
comment|/* Length */
literal|0x00
block|,
literal|0x01
block|,
comment|/* Seq# */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* Fragment offset */
literal|0x00
block|,
literal|0x00
block|,
literal|0x46
block|,
comment|/* Fragment length */
literal|0x01
block|,
literal|0x00
block|,
comment|/* DTLS1_BAD_VER */
define|#
directive|define
name|SH_RANDOM_OFS
value|27
comment|/* Server random goes here */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x20
block|,
comment|/* Session ID length */
define|#
directive|define
name|SH_SESSID_OFS
value|60
comment|/* Session ID goes here */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x2f
block|,
comment|/* Cipher suite AES128-SHA */
literal|0x00
block|,
comment|/* Compression null */
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|change_cipher_spec
index|[]
init|=
block|{
literal|0x14
block|,
comment|/* Change Cipher Spec */
literal|0x01
block|,
literal|0x00
block|,
comment|/* DTLS1_BAD_VER */
literal|0x00
block|,
literal|0x00
block|,
comment|/* Epoch 0 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x02
block|,
comment|/* Seq# 2 */
literal|0x00
block|,
literal|0x03
block|,
comment|/* Length */
literal|0x01
block|,
literal|0x00
block|,
literal|0x02
block|,
comment|/* Message */
block|}
decl_stmt|;
name|memcpy
argument_list|(
name|server_hello
operator|+
name|SH_RANDOM_OFS
argument_list|,
name|server_random
argument_list|,
sizeof|sizeof
argument_list|(
name|server_random
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|server_hello
operator|+
name|SH_SESSID_OFS
argument_list|,
name|session_id
argument_list|,
sizeof|sizeof
argument_list|(
name|session_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EVP_DigestUpdate
argument_list|(
operator|&
name|handshake_md5
argument_list|,
name|server_hello
operator|+
name|MAC_OFFSET
argument_list|,
sizeof|sizeof
argument_list|(
name|server_hello
argument_list|)
operator|-
name|MAC_OFFSET
argument_list|)
operator|||
operator|!
name|EVP_DigestUpdate
argument_list|(
operator|&
name|handshake_sha1
argument_list|,
name|server_hello
operator|+
name|MAC_OFFSET
argument_list|,
sizeof|sizeof
argument_list|(
name|server_hello
argument_list|)
operator|-
name|MAC_OFFSET
argument_list|)
condition|)
name|printf
argument_list|(
literal|"EVP_DigestUpdate() failed\n"
argument_list|)
expr_stmt|;
name|BIO_write
argument_list|(
name|rbio
argument_list|,
name|server_hello
argument_list|,
sizeof|sizeof
argument_list|(
name|server_hello
argument_list|)
argument_list|)
expr_stmt|;
name|BIO_write
argument_list|(
name|rbio
argument_list|,
name|change_cipher_spec
argument_list|,
sizeof|sizeof
argument_list|(
name|change_cipher_spec
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Create header, HMAC, pad, encrypt and send a record */
end_comment

begin_function
specifier|static
name|int
name|send_record
parameter_list|(
name|BIO
modifier|*
name|rbio
parameter_list|,
name|unsigned
name|char
name|type
parameter_list|,
name|unsigned
name|long
name|seqnr
parameter_list|,
specifier|const
name|void
modifier|*
name|msg
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
comment|/* Note that the order of the record header fields on the wire,      * and in the HMAC, is different. So we just keep them in separate      * variables and handle them individually. */
specifier|static
name|unsigned
name|char
name|epoch
index|[
literal|2
index|]
init|=
block|{
literal|0x00
block|,
literal|0x01
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|seq
index|[
literal|6
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|ver
index|[
literal|2
index|]
init|=
block|{
literal|0x01
block|,
literal|0x00
block|}
decl_stmt|;
comment|/* DTLS1_BAD_VER */
name|unsigned
name|char
name|lenbytes
index|[
literal|2
index|]
decl_stmt|;
name|HMAC_CTX
name|ctx
decl_stmt|;
name|EVP_CIPHER_CTX
name|enc_ctx
decl_stmt|;
name|unsigned
name|char
name|iv
index|[
literal|16
index|]
decl_stmt|;
name|unsigned
name|char
name|pad
decl_stmt|;
name|unsigned
name|char
modifier|*
name|enc
decl_stmt|;
ifdef|#
directive|ifdef
name|SIXTY_FOUR_BIT_LONG
name|seq
index|[
literal|0
index|]
operator|=
operator|(
name|seqnr
operator|>>
literal|40
operator|)
operator|&
literal|0xff
expr_stmt|;
name|seq
index|[
literal|1
index|]
operator|=
operator|(
name|seqnr
operator|>>
literal|32
operator|)
operator|&
literal|0xff
expr_stmt|;
endif|#
directive|endif
name|seq
index|[
literal|2
index|]
operator|=
operator|(
name|seqnr
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|seq
index|[
literal|3
index|]
operator|=
operator|(
name|seqnr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|seq
index|[
literal|4
index|]
operator|=
operator|(
name|seqnr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|seq
index|[
literal|5
index|]
operator|=
name|seqnr
operator|&
literal|0xff
expr_stmt|;
name|pad
operator|=
literal|15
operator|-
operator|(
operator|(
name|len
operator|+
name|SHA_DIGEST_LENGTH
operator|)
operator|%
literal|16
operator|)
expr_stmt|;
name|enc
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
operator|+
name|SHA_DIGEST_LENGTH
operator|+
literal|1
operator|+
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Copy record to encryption buffer */
name|memcpy
argument_list|(
name|enc
argument_list|,
name|msg
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Append HMAC to data */
name|HMAC_Init
argument_list|(
operator|&
name|ctx
argument_list|,
name|mac_key
argument_list|,
literal|20
argument_list|,
name|EVP_sha1
argument_list|()
argument_list|)
expr_stmt|;
name|HMAC_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|epoch
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|HMAC_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|seq
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|HMAC_Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|HMAC_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|ver
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Version */
name|lenbytes
index|[
literal|0
index|]
operator|=
name|len
operator|>>
literal|8
expr_stmt|;
name|lenbytes
index|[
literal|1
index|]
operator|=
name|len
operator|&
literal|0xff
expr_stmt|;
name|HMAC_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|lenbytes
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Length */
name|HMAC_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|enc
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Finally the data itself */
name|HMAC_Final
argument_list|(
operator|&
name|ctx
argument_list|,
name|enc
operator|+
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|HMAC_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
comment|/* Append padding bytes */
name|len
operator|+=
name|SHA_DIGEST_LENGTH
expr_stmt|;
do|do
block|{
name|enc
index|[
name|len
operator|++
index|]
operator|=
name|pad
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|%
literal|16
condition|)
do|;
comment|/* Generate IV, and encrypt */
name|RAND_bytes
argument_list|(
name|iv
argument_list|,
sizeof|sizeof
argument_list|(
name|iv
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_CIPHER_CTX_init
argument_list|(
operator|&
name|enc_ctx
argument_list|)
expr_stmt|;
name|EVP_CipherInit_ex
argument_list|(
operator|&
name|enc_ctx
argument_list|,
name|EVP_aes_128_cbc
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|enc_key
argument_list|,
name|iv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|EVP_Cipher
argument_list|(
operator|&
name|enc_ctx
argument_list|,
name|enc
argument_list|,
name|enc
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|enc_ctx
argument_list|)
expr_stmt|;
comment|/* Finally write header (from fragmented variables), IV and encrypted record */
name|BIO_write
argument_list|(
name|rbio
argument_list|,
operator|&
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BIO_write
argument_list|(
name|rbio
argument_list|,
name|ver
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|BIO_write
argument_list|(
name|rbio
argument_list|,
name|epoch
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|BIO_write
argument_list|(
name|rbio
argument_list|,
name|seq
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|lenbytes
index|[
literal|0
index|]
operator|=
operator|(
name|len
operator|+
sizeof|sizeof
argument_list|(
name|iv
argument_list|)
operator|)
operator|>>
literal|8
expr_stmt|;
name|lenbytes
index|[
literal|1
index|]
operator|=
operator|(
name|len
operator|+
sizeof|sizeof
argument_list|(
name|iv
argument_list|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|BIO_write
argument_list|(
name|rbio
argument_list|,
name|lenbytes
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|BIO_write
argument_list|(
name|rbio
argument_list|,
name|iv
argument_list|,
sizeof|sizeof
argument_list|(
name|iv
argument_list|)
argument_list|)
expr_stmt|;
name|BIO_write
argument_list|(
name|rbio
argument_list|,
name|enc
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_finished
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|BIO
modifier|*
name|rbio
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|finished_msg
index|[
name|DTLS1_HM_HEADER_LENGTH
operator|+
name|TLS1_FINISH_MAC_LENGTH
index|]
init|=
block|{
literal|0x14
block|,
comment|/* Finished */
literal|0x00
block|,
literal|0x00
block|,
literal|0x0c
block|,
comment|/* Length */
literal|0x00
block|,
literal|0x03
block|,
comment|/* Seq# 3 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* Fragment offset */
literal|0x00
block|,
literal|0x00
block|,
literal|0x0c
block|,
comment|/* Fragment length */
comment|/* Finished MAC (12 bytes) */
block|}
decl_stmt|;
name|unsigned
name|char
name|handshake_hash
index|[
name|EVP_MAX_MD_SIZE
operator|*
literal|2
index|]
decl_stmt|;
comment|/* Derive key material */
name|do_PRF
argument_list|(
name|TLS_MD_KEY_EXPANSION_CONST
argument_list|,
name|TLS_MD_KEY_EXPANSION_CONST_SIZE
argument_list|,
name|server_random
argument_list|,
name|SSL3_RANDOM_SIZE
argument_list|,
name|client_random
argument_list|,
name|SSL3_RANDOM_SIZE
argument_list|,
name|key_block
argument_list|,
sizeof|sizeof
argument_list|(
name|key_block
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate Finished MAC */
if|if
condition|(
operator|!
name|EVP_DigestFinal_ex
argument_list|(
operator|&
name|handshake_md5
argument_list|,
name|handshake_hash
argument_list|,
name|NULL
argument_list|)
operator|||
operator|!
name|EVP_DigestFinal_ex
argument_list|(
operator|&
name|handshake_sha1
argument_list|,
name|handshake_hash
operator|+
name|EVP_MD_CTX_size
argument_list|(
operator|&
name|handshake_md5
argument_list|)
argument_list|,
name|NULL
argument_list|)
condition|)
name|printf
argument_list|(
literal|"EVP_DigestFinal_ex() failed\n"
argument_list|)
expr_stmt|;
name|do_PRF
argument_list|(
name|TLS_MD_SERVER_FINISH_CONST
argument_list|,
name|TLS_MD_SERVER_FINISH_CONST_SIZE
argument_list|,
name|handshake_hash
argument_list|,
name|EVP_MD_CTX_size
argument_list|(
operator|&
name|handshake_md5
argument_list|)
operator|+
name|EVP_MD_CTX_size
argument_list|(
operator|&
name|handshake_sha1
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|finished_msg
operator|+
name|DTLS1_HM_HEADER_LENGTH
argument_list|,
name|TLS1_FINISH_MAC_LENGTH
argument_list|)
expr_stmt|;
return|return
name|send_record
argument_list|(
name|rbio
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
literal|0
argument_list|,
name|finished_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|finished_msg
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|validate_ccs
parameter_list|(
name|BIO
modifier|*
name|wbio
parameter_list|)
block|{
name|PACKET
name|pkt
decl_stmt|;
name|long
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|u
decl_stmt|;
name|len
operator|=
name|BIO_get_mem_data
argument_list|(
name|wbio
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PACKET_buf_init
argument_list|(
operator|&
name|pkt
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check record header type */
if|if
condition|(
operator|!
name|PACKET_get_1
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|u
argument_list|)
operator|||
name|u
operator|!=
name|SSL3_RT_CHANGE_CIPHER_SPEC
condition|)
return|return
literal|0
return|;
comment|/* Version */
if|if
condition|(
operator|!
name|PACKET_get_net_2
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|u
argument_list|)
operator|||
name|u
operator|!=
name|DTLS1_BAD_VER
condition|)
return|return
literal|0
return|;
comment|/* Skip the rest of the record header */
if|if
condition|(
operator|!
name|PACKET_forward
argument_list|(
operator|&
name|pkt
argument_list|,
name|DTLS1_RT_HEADER_LENGTH
operator|-
literal|3
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check ChangeCipherSpec message */
if|if
condition|(
operator|!
name|PACKET_get_1
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|u
argument_list|)
operator|||
name|u
operator|!=
name|SSL3_MT_CCS
condition|)
return|return
literal|0
return|;
comment|/* A DTLS1_BAD_VER ChangeCipherSpec also contains the      * handshake sequence number (which is 2 here) */
if|if
condition|(
operator|!
name|PACKET_get_net_2
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|u
argument_list|)
operator|||
name|u
operator|!=
literal|0x0002
condition|)
return|return
literal|0
return|;
comment|/* Now check the Finished packet */
if|if
condition|(
operator|!
name|PACKET_get_1
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|u
argument_list|)
operator|||
name|u
operator|!=
name|SSL3_RT_HANDSHAKE
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|PACKET_get_net_2
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|u
argument_list|)
operator|||
name|u
operator|!=
name|DTLS1_BAD_VER
condition|)
return|return
literal|0
return|;
comment|/* Check epoch is now 1 */
if|if
condition|(
operator|!
name|PACKET_get_net_2
argument_list|(
operator|&
name|pkt
argument_list|,
operator|&
name|u
argument_list|)
operator|||
name|u
operator|!=
literal|0x0001
condition|)
return|return
literal|0
return|;
comment|/* That'll do for now. If OpenSSL accepted *our* Finished packet      * then it's evidently remembered that DTLS1_BAD_VER doesn't      * include the handshake header in the MAC. There's not a lot of      * point in implementing decryption here, just to check that it      * continues to get it right for one more packet. */
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NODROP
parameter_list|(
name|x
parameter_list|)
value|{ x##UL, 0 }
end_define

begin_define
define|#
directive|define
name|DROP
parameter_list|(
name|x
parameter_list|)
value|{ x##UL, 1 }
end_define

begin_struct
specifier|static
struct|struct
block|{
name|unsigned
name|long
name|seq
decl_stmt|;
name|int
name|drop
decl_stmt|;
block|}
name|tests
index|[]
init|=
block|{
name|NODROP
argument_list|(
literal|1
argument_list|)
block|,
name|NODROP
argument_list|(
literal|3
argument_list|)
block|,
name|NODROP
argument_list|(
literal|2
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x1234
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x1230
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x1235
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0xffff
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x10001
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0xfffe
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x10000
argument_list|)
block|,
name|DROP
argument_list|(
literal|0x10001
argument_list|)
block|,
name|DROP
argument_list|(
literal|0xff
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x100000
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x800000
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x7fffe1
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0xffffff
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x1000000
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0xfffffe
argument_list|)
block|,
name|DROP
argument_list|(
literal|0xffffff
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x1000010
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0xfffffd
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x1000011
argument_list|)
block|,
name|DROP
argument_list|(
literal|0x12
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x1000012
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x1ffffff
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x2000000
argument_list|)
block|,
name|DROP
argument_list|(
literal|0x1ff00fe
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x2000001
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x20fffff
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x2105500
argument_list|)
block|,
name|DROP
argument_list|(
literal|0x20ffffe
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x21054ff
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x211ffff
argument_list|)
block|,
name|DROP
argument_list|(
literal|0x2110000
argument_list|)
block|,
name|NODROP
argument_list|(
literal|0x2120000
argument_list|)
comment|/* The last test should be NODROP, because a DROP wouldn't get tested. */
block|}
struct|;
end_struct

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|SSL_SESSION
modifier|*
name|sess
decl_stmt|;
name|SSL_CTX
modifier|*
name|ctx
decl_stmt|;
name|SSL
modifier|*
name|con
decl_stmt|;
name|BIO
modifier|*
name|rbio
decl_stmt|;
name|BIO
modifier|*
name|wbio
decl_stmt|;
name|BIO
modifier|*
name|err
decl_stmt|;
name|int
name|testresult
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SSL_library_init
argument_list|()
expr_stmt|;
name|SSL_load_error_strings
argument_list|()
expr_stmt|;
name|err
operator|=
name|BIO_new_fp
argument_list|(
name|stderr
argument_list|,
name|BIO_NOCLOSE
operator||
name|BIO_FP_TEXT
argument_list|)
expr_stmt|;
name|CRYPTO_malloc_debug_init
argument_list|()
expr_stmt|;
name|CRYPTO_set_mem_debug_options
argument_list|(
name|V_CRYPTO_MDEBUG_ALL
argument_list|)
expr_stmt|;
name|CRYPTO_mem_ctrl
argument_list|(
name|CRYPTO_MEM_CHECK_ON
argument_list|)
expr_stmt|;
name|RAND_bytes
argument_list|(
name|session_id
argument_list|,
sizeof|sizeof
argument_list|(
name|session_id
argument_list|)
argument_list|)
expr_stmt|;
name|RAND_bytes
argument_list|(
name|master_secret
argument_list|,
sizeof|sizeof
argument_list|(
name|master_secret
argument_list|)
argument_list|)
expr_stmt|;
name|RAND_bytes
argument_list|(
name|cookie
argument_list|,
sizeof|sizeof
argument_list|(
name|cookie
argument_list|)
argument_list|)
expr_stmt|;
name|RAND_bytes
argument_list|(
name|server_random
operator|+
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|server_random
argument_list|)
operator|-
literal|4
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|(
name|void
operator|*
operator|)
name|server_random
argument_list|)
expr_stmt|;
name|sess
operator|=
name|client_session
argument_list|()
expr_stmt|;
if|if
condition|(
name|sess
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to generate SSL_SESSION\n"
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|!
name|EVP_DigestInit_ex
argument_list|(
operator|&
name|handshake_md5
argument_list|,
name|EVP_md5
argument_list|()
argument_list|,
name|NULL
argument_list|)
operator|||
operator|!
name|EVP_DigestInit_ex
argument_list|(
operator|&
name|handshake_sha1
argument_list|,
name|EVP_sha1
argument_list|()
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to initialise handshake_md\n"
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|ctx
operator|=
name|SSL_CTX_new
argument_list|(
name|DTLSv1_client_method
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to allocate SSL_CTX\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_md
goto|;
block|}
name|SSL_CTX_set_options
argument_list|(
name|ctx
argument_list|,
name|SSL_OP_CISCO_ANYCONNECT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_CTX_set_cipher_list
argument_list|(
name|ctx
argument_list|,
literal|"AES128-SHA"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"SSL_CTX_set_cipher_list() failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_ctx
goto|;
block|}
name|con
operator|=
name|SSL_new
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_set_session
argument_list|(
name|con
argument_list|,
name|sess
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"SSL_set_session() failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_con
goto|;
block|}
name|SSL_SESSION_free
argument_list|(
name|sess
argument_list|)
expr_stmt|;
name|rbio
operator|=
name|BIO_new
argument_list|(
name|BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
name|wbio
operator|=
name|BIO_new
argument_list|(
name|BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
name|BIO_set_nbio
argument_list|(
name|rbio
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BIO_set_nbio
argument_list|(
name|wbio
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SSL_set_bio
argument_list|(
name|con
argument_list|,
name|rbio
argument_list|,
name|wbio
argument_list|)
expr_stmt|;
name|SSL_set_connect_state
argument_list|(
name|con
argument_list|)
expr_stmt|;
comment|/* Send initial ClientHello */
name|ret
operator|=
name|SSL_do_handshake
argument_list|(
name|con
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
operator|||
name|SSL_get_error
argument_list|(
name|con
argument_list|,
name|ret
argument_list|)
operator|!=
name|SSL_ERROR_WANT_READ
condition|)
block|{
name|printf
argument_list|(
literal|"Unexpected handshake result at initial call!\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_con
goto|;
block|}
if|if
condition|(
name|validate_client_hello
argument_list|(
name|wbio
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Initial ClientHello failed validation\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_con
goto|;
block|}
if|if
condition|(
name|send_hello_verify
argument_list|(
name|rbio
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to send HelloVerify\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_con
goto|;
block|}
name|ret
operator|=
name|SSL_do_handshake
argument_list|(
name|con
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
operator|||
name|SSL_get_error
argument_list|(
name|con
argument_list|,
name|ret
argument_list|)
operator|!=
name|SSL_ERROR_WANT_READ
condition|)
block|{
name|printf
argument_list|(
literal|"Unexpected handshake result after HelloVerify!\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_con
goto|;
block|}
if|if
condition|(
name|validate_client_hello
argument_list|(
name|wbio
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"Second ClientHello failed validation\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_con
goto|;
block|}
if|if
condition|(
name|send_server_hello
argument_list|(
name|rbio
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to send ServerHello\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_con
goto|;
block|}
name|ret
operator|=
name|SSL_do_handshake
argument_list|(
name|con
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
operator|||
name|SSL_get_error
argument_list|(
name|con
argument_list|,
name|ret
argument_list|)
operator|!=
name|SSL_ERROR_WANT_READ
condition|)
block|{
name|printf
argument_list|(
literal|"Unexpected handshake result after ServerHello!\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_con
goto|;
block|}
if|if
condition|(
name|send_finished
argument_list|(
name|con
argument_list|,
name|rbio
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to send Finished\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_con
goto|;
block|}
name|ret
operator|=
name|SSL_do_handshake
argument_list|(
name|con
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Handshake not successful after Finished!\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_con
goto|;
block|}
if|if
condition|(
name|validate_ccs
argument_list|(
name|wbio
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to validate client CCS/Finished\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_con
goto|;
block|}
comment|/* While we're here and crafting packets by hand, we might as well do a        bit of a stress test on the DTLS record replay handling. Not Cisco-DTLS        specific but useful anyway for the general case. It's been broken        before, and in fact was broken even for a basic 0, 2, 1 test case        when this test was first added.... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|OSSL_NELEM
argument_list|(
name|tests
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|recv_buf
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|send_record
argument_list|(
name|rbio
argument_list|,
name|SSL3_RT_APPLICATION_DATA
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|seq
argument_list|,
operator|&
name|tests
index|[
name|i
index|]
operator|.
name|seq
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to send data seq #0x%lx (%d)\n"
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|seq
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|end_con
goto|;
block|}
if|if
condition|(
name|tests
index|[
name|i
index|]
operator|.
name|drop
condition|)
continue|continue;
name|ret
operator|=
name|SSL_read
argument_list|(
name|con
argument_list|,
name|recv_buf
argument_list|,
literal|2
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"SSL_read failed or wrong size on seq#0x%lx (%d)\n"
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|seq
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|end_con
goto|;
block|}
if|if
condition|(
name|recv_buf
index|[
literal|0
index|]
operator|!=
name|tests
index|[
name|i
index|]
operator|.
name|seq
condition|)
block|{
name|printf
argument_list|(
literal|"Wrong data packet received (0x%lx not 0x%lx) at packet %d\n"
argument_list|,
name|recv_buf
index|[
literal|0
index|]
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|seq
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|end_con
goto|;
block|}
block|}
if|if
condition|(
name|tests
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|drop
condition|)
block|{
name|printf
argument_list|(
literal|"Error: last test cannot be DROP()\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_con
goto|;
block|}
name|testresult
operator|=
literal|1
expr_stmt|;
name|end_con
label|:
name|SSL_free
argument_list|(
name|con
argument_list|)
expr_stmt|;
name|end_ctx
label|:
name|SSL_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|end_md
label|:
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|handshake_md5
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|handshake_sha1
argument_list|)
expr_stmt|;
name|end
label|:
name|ERR_print_errors_fp
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|testresult
condition|)
block|{
name|printf
argument_list|(
literal|"Cisco BadDTLS test: FAILED\n"
argument_list|)
expr_stmt|;
block|}
name|ERR_free_strings
argument_list|()
expr_stmt|;
name|ERR_remove_thread_state
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|EVP_cleanup
argument_list|()
expr_stmt|;
name|CRYPTO_cleanup_all_ex_data
argument_list|()
expr_stmt|;
name|CRYPTO_mem_leaks
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|testresult
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

end_unit

