begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ssl/s2_clnt.c */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *   * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *   * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from   *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *   * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"ssl_locl.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SSL2
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/buffer.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_function_decl
specifier|static
name|SSL_METHOD
modifier|*
name|ssl2_get_client_method
parameter_list|(
name|int
name|ver
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_server_finished
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_server_verify
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_server_hello
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|client_hello
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|client_master_key
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|client_finished
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|client_certificate
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ssl_rsa_public_encrypt
parameter_list|(
name|SESS_CERT
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|from
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
name|int
name|padding
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BREAK
value|break
end_define

begin_function
specifier|static
name|SSL_METHOD
modifier|*
name|ssl2_get_client_method
parameter_list|(
name|int
name|ver
parameter_list|)
block|{
if|if
condition|(
name|ver
operator|==
name|SSL2_VERSION
condition|)
return|return
operator|(
name|SSLv2_client_method
argument_list|()
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|SSL_METHOD
modifier|*
name|SSLv2_client_method
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|init
init|=
literal|1
decl_stmt|;
specifier|static
name|SSL_METHOD
name|SSLv2_client_data
decl_stmt|;
if|if
condition|(
name|init
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|SSLv2_client_data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sslv2_base_method
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|SSL_METHOD
argument_list|)
argument_list|)
expr_stmt|;
name|SSLv2_client_data
operator|.
name|ssl_connect
operator|=
name|ssl2_connect
expr_stmt|;
name|SSLv2_client_data
operator|.
name|get_ssl_method
operator|=
name|ssl2_get_client_method
expr_stmt|;
name|init
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|SSLv2_client_data
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ssl2_connect
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|long
name|l
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|BUF_MEM
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|()
init|=
name|NULL
function_decl|;
name|int
name|new_state
decl_stmt|,
name|state
decl_stmt|;
name|RAND_add
argument_list|(
operator|&
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
name|clear_sys_error
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|info_callback
operator|!=
name|NULL
condition|)
name|cb
operator|=
name|s
operator|->
name|info_callback
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|info_callback
operator|!=
name|NULL
condition|)
name|cb
operator|=
name|s
operator|->
name|ctx
operator|->
name|info_callback
expr_stmt|;
comment|/* init things to blank */
if|if
condition|(
operator|!
name|SSL_in_init
argument_list|(
name|s
argument_list|)
operator|||
name|SSL_in_before
argument_list|(
name|s
argument_list|)
condition|)
name|SSL_clear
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|in_handshake
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|state
operator|=
name|s
operator|->
name|state
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|state
condition|)
block|{
case|case
name|SSL_ST_BEFORE
case|:
case|case
name|SSL_ST_CONNECT
case|:
case|case
name|SSL_ST_BEFORE
operator||
name|SSL_ST_CONNECT
case|:
case|case
name|SSL_ST_OK
operator||
name|SSL_ST_CONNECT
case|:
name|s
operator|->
name|server
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cb
operator|!=
name|NULL
condition|)
name|cb
argument_list|(
name|s
argument_list|,
name|SSL_CB_HANDSHAKE_START
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|->
name|version
operator|=
name|SSL2_VERSION
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|SSL_ST_CONNECT
expr_stmt|;
name|buf
operator|=
name|s
operator|->
name|init_buf
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|buf
operator|=
name|BUF_MEM_new
argument_list|()
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|!
name|BUF_MEM_grow
argument_list|(
name|buf
argument_list|,
name|SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|s
operator|->
name|init_buf
operator|=
name|buf
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_CLIENT_HELLO_A
expr_stmt|;
name|s
operator|->
name|ctx
operator|->
name|stats
operator|.
name|sess_connect
operator|++
expr_stmt|;
name|s
operator|->
name|handshake_func
operator|=
name|ssl2_connect
expr_stmt|;
name|BREAK
expr_stmt|;
case|case
name|SSL2_ST_SEND_CLIENT_HELLO_A
case|:
case|case
name|SSL2_ST_SEND_CLIENT_HELLO_B
case|:
name|s
operator|->
name|shutdown
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|client_hello
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_GET_SERVER_HELLO_A
expr_stmt|;
name|BREAK
expr_stmt|;
case|case
name|SSL2_ST_GET_SERVER_HELLO_A
case|:
case|case
name|SSL2_ST_GET_SERVER_HELLO_B
case|:
name|ret
operator|=
name|get_server_hello
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|hit
condition|)
comment|/* new session */
block|{
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_CLIENT_MASTER_KEY_A
expr_stmt|;
name|BREAK
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|state
operator|=
name|SSL2_ST_CLIENT_START_ENCRYPTION
expr_stmt|;
break|break;
block|}
case|case
name|SSL2_ST_SEND_CLIENT_MASTER_KEY_A
case|:
case|case
name|SSL2_ST_SEND_CLIENT_MASTER_KEY_B
case|:
name|ret
operator|=
name|client_master_key
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_CLIENT_START_ENCRYPTION
expr_stmt|;
break|break;
case|case
name|SSL2_ST_CLIENT_START_ENCRYPTION
case|:
comment|/* Ok, we now have all the stuff needed to 			 * start encrypting, so lets fire it up :-) */
if|if
condition|(
operator|!
name|ssl2_enc_init
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|s
operator|->
name|s2
operator|->
name|clear_text
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_CLIENT_FINISHED_A
expr_stmt|;
break|break;
case|case
name|SSL2_ST_SEND_CLIENT_FINISHED_A
case|:
case|case
name|SSL2_ST_SEND_CLIENT_FINISHED_B
case|:
name|ret
operator|=
name|client_finished
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_GET_SERVER_VERIFY_A
expr_stmt|;
break|break;
case|case
name|SSL2_ST_GET_SERVER_VERIFY_A
case|:
case|case
name|SSL2_ST_GET_SERVER_VERIFY_B
case|:
name|ret
operator|=
name|get_server_verify
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_GET_SERVER_FINISHED_A
expr_stmt|;
break|break;
case|case
name|SSL2_ST_GET_SERVER_FINISHED_A
case|:
case|case
name|SSL2_ST_GET_SERVER_FINISHED_B
case|:
name|ret
operator|=
name|get_server_finished
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
break|break;
case|case
name|SSL2_ST_SEND_CLIENT_CERTIFICATE_A
case|:
case|case
name|SSL2_ST_SEND_CLIENT_CERTIFICATE_B
case|:
case|case
name|SSL2_ST_SEND_CLIENT_CERTIFICATE_C
case|:
case|case
name|SSL2_ST_SEND_CLIENT_CERTIFICATE_D
case|:
case|case
name|SSL2_ST_X509_GET_CLIENT_CERTIFICATE
case|:
name|ret
operator|=
name|client_certificate
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_GET_SERVER_FINISHED_A
expr_stmt|;
break|break;
case|case
name|SSL_ST_OK
case|:
if|if
condition|(
name|s
operator|->
name|init_buf
operator|!=
name|NULL
condition|)
block|{
name|BUF_MEM_free
argument_list|(
name|s
operator|->
name|init_buf
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_buf
operator|=
name|NULL
expr_stmt|;
block|}
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
comment|/*	ERR_clear_error();*/
comment|/* If we want to cache session-ids in the client 			 * and we successfully add the session-id to the 			 * cache, and there is a callback, then pass it out. 			 * 26/11/96 - eay - only add if not a re-used session. 			 */
name|ssl_update_cache
argument_list|(
name|s
argument_list|,
name|SSL_SESS_CACHE_CLIENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|hit
condition|)
name|s
operator|->
name|ctx
operator|->
name|stats
operator|.
name|sess_hit
operator|++
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* s->server=0; */
name|s
operator|->
name|ctx
operator|->
name|stats
operator|.
name|sess_connect_good
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|!=
name|NULL
condition|)
name|cb
argument_list|(
name|s
argument_list|,
name|SSL_CB_HANDSHAKE_DONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
comment|/* break; */
default|default:
name|SSLerr
argument_list|(
name|SSL_F_SSL2_CONNECT
argument_list|,
name|SSL_R_UNKNOWN_STATE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* break; */
block|}
if|if
condition|(
operator|(
name|cb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|s
operator|->
name|state
operator|!=
name|state
operator|)
condition|)
block|{
name|new_state
operator|=
name|s
operator|->
name|state
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|cb
argument_list|(
name|s
argument_list|,
name|SSL_CB_CONNECT_LOOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|new_state
expr_stmt|;
block|}
block|}
name|end
label|:
name|s
operator|->
name|in_handshake
operator|--
expr_stmt|;
if|if
condition|(
name|cb
operator|!=
name|NULL
condition|)
name|cb
argument_list|(
name|s
argument_list|,
name|SSL_CB_CONNECT_EXIT
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_server_hello
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|sk
operator|=
name|NULL
operator|,
operator|*
name|cl
expr_stmt|;
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_GET_SERVER_HELLO_A
condition|)
block|{
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|buf
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
literal|11
operator|-
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
literal|11
operator|-
name|s
operator|->
name|init_num
operator|)
condition|)
return|return
operator|(
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_GET_SERVER_HELLO
argument_list|,
name|i
argument_list|)
operator|)
return|;
if|if
condition|(
operator|*
operator|(
name|p
operator|++
operator|)
operator|!=
name|SSL2_MT_SERVER_HELLO
condition|)
block|{
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|SSL2_MT_ERROR
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_HELLO
argument_list|,
name|SSL_R_READ_WRONG_PACKET_TYPE
argument_list|)
expr_stmt|;
block|}
else|else
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_HELLO
argument_list|,
name|SSL_R_PEER_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|__APPLE_CC__
comment|/* The Rhapsody 5.5 (a.k.a. MacOS X) compiler bug 		 * workaround.<appro@fy.chalmers.se> */
name|s
operator|->
name|hit
operator|=
operator|(
name|i
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
else|#
directive|else
name|s
operator|->
name|hit
operator|=
operator|(
operator|*
operator|(
name|p
operator|++
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|cert_type
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|s
operator|->
name|version
condition|)
name|s
operator|->
name|version
operator|=
name|i
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|cert_length
operator|=
name|i
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|csl
operator|=
name|i
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|conn_id_length
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_GET_SERVER_HELLO_B
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
block|}
comment|/* SSL2_ST_GET_SERVER_HELLO_B */
name|j
operator|=
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|cert_length
operator|+
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|csl
operator|+
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|conn_id_length
operator|-
name|s
operator|->
name|init_num
expr_stmt|;
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|buf
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|j
condition|)
return|return
operator|(
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_GET_SERVER_HELLO
argument_list|,
name|i
argument_list|)
operator|)
return|;
comment|/* things are looking good */
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|hit
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|cert_length
operator|!=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_HELLO
argument_list|,
name|SSL_R_REUSE_CERT_LENGTH_NOT_ZERO
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|cert_type
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_HELLO
argument_list|,
name|SSL_R_REUSE_CERT_TYPE_NOT_ZERO
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|csl
operator|!=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_HELLO
argument_list|,
name|SSL_R_REUSE_CIPHER_LIST_NOT_ZERO
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|undef
comment|/* very bad */
name|memset
argument_list|(
name|s
operator|->
name|session
operator|->
name|session_id
argument_list|,
literal|0
argument_list|,
name|SSL_MAX_SSL_SESSION_ID_LENGTH_IN_BYTES
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|session_id_length
operator|=
literal|0
expr_stmt|;
operator|*
operator|/
endif|#
directive|endif
comment|/* we need to do this in case we were trying to reuse a  		 * client session but others are already reusing it. 		 * If this was a new 'blank' session ID, the session-id 		 * length will still be 0 */
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|session_id_length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_get_new_session
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ssl2_set_certificate
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|cert_type
argument_list|,
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|cert_length
argument_list|,
name|p
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_BAD_CERTIFICATE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|p
operator|+=
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|cert_length
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|csl
operator|==
literal|0
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_NO_CIPHER
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_HELLO
argument_list|,
name|SSL_R_NO_CIPHER_LIST
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* We have just received a list of ciphers back from the 		 * server.  We need to get the ones that match, then select 		 * the one we want the most :-). */
comment|/* load the ciphers */
name|sk
operator|=
name|ssl_bytes_to_cipher_list
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|csl
argument_list|,
operator|&
name|s
operator|->
name|session
operator|->
name|ciphers
argument_list|)
expr_stmt|;
name|p
operator|+=
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|csl
expr_stmt|;
if|if
condition|(
name|sk
operator|==
name|NULL
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_HELLO
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sk_SSL_CIPHER_set_cmp_func
argument_list|(
name|sk
argument_list|,
name|ssl_cipher_ptr_id_cmp
argument_list|)
expr_stmt|;
comment|/* get the array of ciphers we will accept */
name|cl
operator|=
name|ssl_get_ciphers_by_id
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* In theory we could have ciphers sent back that we 		 * don't want to use but that does not matter since we 		 * will check against the list we originally sent and 		 * for performance reasons we should not bother to match 		 * the two lists up just to check. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_SSL_CIPHER_num
argument_list|(
name|cl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sk_SSL_CIPHER_find
argument_list|(
name|sk
argument_list|,
name|sk_SSL_CIPHER_value
argument_list|(
name|cl
argument_list|,
name|i
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|sk_SSL_CIPHER_num
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_NO_CIPHER
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_HELLO
argument_list|,
name|SSL_R_NO_CIPHER_MATCH
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|s
operator|->
name|session
operator|->
name|cipher
operator|=
name|sk_SSL_CIPHER_value
argument_list|(
name|cl
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|peer
operator|!=
name|NULL
condition|)
comment|/* can't happen*/
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_HELLO
argument_list|,
name|SSL_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|s
operator|->
name|session
operator|->
name|peer
operator|=
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_key
operator|->
name|x509
expr_stmt|;
comment|/* peer_key->x509 has been set by ssl2_set_certificate. */
name|CRYPTO_add
argument_list|(
operator|&
name|s
operator|->
name|session
operator|->
name|peer
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_X509
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|peer
operator|!=
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_key
operator|->
name|x509
condition|)
comment|/* can't happen */
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_HELLO
argument_list|,
name|SSL_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|s
operator|->
name|s2
operator|->
name|conn_id_length
operator|=
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|conn_id_length
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|s2
operator|->
name|conn_id
argument_list|,
name|p
argument_list|,
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|conn_id_length
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|client_hello
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|d
decl_stmt|;
comment|/*	CIPHER **cipher;*/
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|j
decl_stmt|;
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_SEND_CLIENT_HELLO_A
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|session
operator|==
name|NULL
operator|)
operator|||
operator|(
name|s
operator|->
name|session
operator|->
name|ssl_version
operator|!=
name|s
operator|->
name|version
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_get_new_session
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* else use the pre-loaded session */
name|p
operator|=
name|buf
expr_stmt|;
comment|/* header */
name|d
operator|=
name|p
operator|+
literal|9
expr_stmt|;
comment|/* data section */
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|SSL2_MT_CLIENT_HELLO
expr_stmt|;
comment|/* type */
name|s2n
argument_list|(
name|SSL2_VERSION
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* version */
name|n
operator|=
name|j
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|ssl_cipher_list_to_bytes
argument_list|(
name|s
argument_list|,
name|SSL_get_ciphers
argument_list|(
name|s
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_CLIENT_HELLO
argument_list|,
name|SSL_R_NO_CIPHERS_AVAILABLE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|s2n
argument_list|(
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* cipher spec num bytes */
if|if
condition|(
operator|(
name|s
operator|->
name|session
operator|->
name|session_id_length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|s
operator|->
name|session
operator|->
name|session_id_length
operator|<=
name|SSL2_MAX_SSL_SESSION_ID_LENGTH
operator|)
condition|)
block|{
name|i
operator|=
name|s
operator|->
name|session
operator|->
name|session_id_length
expr_stmt|;
name|s2n
argument_list|(
name|i
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* session id length */
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
operator|->
name|session
operator|->
name|session_id
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|d
operator|+=
name|i
expr_stmt|;
block|}
else|else
block|{
name|s2n
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|s2
operator|->
name|challenge_length
operator|=
name|SSL2_CHALLENGE_LENGTH
expr_stmt|;
name|s2n
argument_list|(
name|SSL2_CHALLENGE_LENGTH
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* challenge length */
comment|/*challenge id data*/
name|RAND_pseudo_bytes
argument_list|(
name|s
operator|->
name|s2
operator|->
name|challenge
argument_list|,
name|SSL2_CHALLENGE_LENGTH
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
operator|->
name|s2
operator|->
name|challenge
argument_list|,
name|SSL2_CHALLENGE_LENGTH
argument_list|)
expr_stmt|;
name|d
operator|+=
name|SSL2_CHALLENGE_LENGTH
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_CLIENT_HELLO_B
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
name|d
operator|-
name|buf
expr_stmt|;
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
block|}
comment|/* SSL2_ST_SEND_CLIENT_HELLO_B */
return|return
operator|(
name|ssl2_do_write
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|client_master_key
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|int
name|clear
decl_stmt|,
name|enc
decl_stmt|,
name|karg
decl_stmt|,
name|i
decl_stmt|;
name|SSL_SESSION
modifier|*
name|sess
decl_stmt|;
specifier|const
name|EVP_CIPHER
modifier|*
name|c
decl_stmt|;
specifier|const
name|EVP_MD
modifier|*
name|md
decl_stmt|;
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_SEND_CLIENT_MASTER_KEY_A
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_cipher_get_evp
argument_list|(
name|s
operator|->
name|session
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|md
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_NO_CIPHER
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_CLIENT_MASTER_KEY
argument_list|,
name|SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sess
operator|=
name|s
operator|->
name|session
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|d
operator|=
name|p
operator|+
literal|10
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|SSL2_MT_CLIENT_MASTER_KEY
expr_stmt|;
comment|/* type */
name|i
operator|=
name|ssl_put_cipher_by_char
argument_list|(
name|s
argument_list|,
name|sess
operator|->
name|cipher
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
comment|/* make key_arg data */
name|i
operator|=
name|EVP_CIPHER_iv_length
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|sess
operator|->
name|key_arg_length
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|RAND_pseudo_bytes
argument_list|(
name|sess
operator|->
name|key_arg
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* make a master key */
name|i
operator|=
name|EVP_CIPHER_key_length
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|sess
operator|->
name|master_key_length
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|RAND_bytes
argument_list|(
name|sess
operator|->
name|master_key
argument_list|,
name|i
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|sess
operator|->
name|cipher
operator|->
name|algorithm2
operator|&
name|SSL2_CF_8_BYTE_ENC
condition|)
name|enc
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|SSL_C_IS_EXPORT
argument_list|(
name|sess
operator|->
name|cipher
argument_list|)
condition|)
name|enc
operator|=
literal|5
expr_stmt|;
else|else
name|enc
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|enc
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_CLIENT_MASTER_KEY
argument_list|,
name|SSL_R_CIPHER_TABLE_SRC_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|clear
operator|=
name|i
operator|-
name|enc
expr_stmt|;
name|s2n
argument_list|(
name|clear
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
argument_list|,
name|sess
operator|->
name|master_key
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|clear
argument_list|)
expr_stmt|;
name|d
operator|+=
name|clear
expr_stmt|;
name|enc
operator|=
name|ssl_rsa_public_encrypt
argument_list|(
name|sess
operator|->
name|sess_cert
argument_list|,
name|enc
argument_list|,
operator|&
operator|(
name|sess
operator|->
name|master_key
index|[
name|clear
index|]
operator|)
argument_list|,
name|d
argument_list|,
operator|(
name|s
operator|->
name|s2
operator|->
name|ssl2_rollback
operator|)
condition|?
name|RSA_SSLV23_PADDING
else|:
name|RSA_PKCS1_PADDING
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|<=
literal|0
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_CLIENT_MASTER_KEY
argument_list|,
name|SSL_R_PUBLIC_KEY_ENCRYPT_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|PKCS1_CHECK
if|if
condition|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_PKCS1_CHECK_1
condition|)
name|d
index|[
literal|1
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_PKCS1_CHECK_2
condition|)
name|sess
operator|->
name|master_key
index|[
name|clear
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|s2n
argument_list|(
name|enc
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|d
operator|+=
name|enc
expr_stmt|;
name|karg
operator|=
name|sess
operator|->
name|key_arg_length
expr_stmt|;
name|s2n
argument_list|(
name|karg
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* key arg size */
name|memcpy
argument_list|(
name|d
argument_list|,
name|sess
operator|->
name|key_arg
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|karg
argument_list|)
expr_stmt|;
name|d
operator|+=
name|karg
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_CLIENT_MASTER_KEY_B
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
name|d
operator|-
name|buf
expr_stmt|;
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
block|}
comment|/* SSL2_ST_SEND_CLIENT_MASTER_KEY_B */
return|return
operator|(
name|ssl2_do_write
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|client_finished
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_SEND_CLIENT_FINISHED_A
condition|)
block|{
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|SSL2_MT_CLIENT_FINISHED
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|s2
operator|->
name|conn_id
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|s2
operator|->
name|conn_id_length
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_CLIENT_FINISHED_B
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
name|s
operator|->
name|s2
operator|->
name|conn_id_length
operator|+
literal|1
expr_stmt|;
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ssl2_do_write
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* read the data and then respond */
end_comment

begin_function
specifier|static
name|int
name|client_certificate
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|int
name|cert_ch_len
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cert_ch
decl_stmt|;
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
name|cert_ch
operator|=
operator|&
operator|(
name|buf
index|[
literal|2
index|]
operator|)
expr_stmt|;
comment|/* We have a cert associated with the SSL, so attach it to 	 * the session if it does not have one */
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_SEND_CLIENT_CERTIFICATE_A
condition|)
block|{
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|buf
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
name|SSL2_MAX_CERT_CHALLENGE_LENGTH
operator|+
literal|1
operator|-
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|SSL2_MIN_CERT_CHALLENGE_LENGTH
operator|+
literal|1
operator|-
name|s
operator|->
name|init_num
operator|)
condition|)
return|return
operator|(
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_CLIENT_CERTIFICATE
argument_list|,
name|i
argument_list|)
operator|)
return|;
comment|/* type=buf[0]; */
comment|/* type eq x509 */
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|!=
name|SSL2_AT_MD5_WITH_RSA_ENCRYPTION
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNSUPPORTED_CERTIFICATE_TYPE
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_CLIENT_CERTIFICATE
argument_list|,
name|SSL_R_BAD_AUTHENTICATION_TYPE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cert_ch_len
operator|=
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|cert
operator|==
name|NULL
operator|)
operator|||
operator|(
name|s
operator|->
name|cert
operator|->
name|key
operator|->
name|x509
operator|==
name|NULL
operator|)
operator|||
operator|(
name|s
operator|->
name|cert
operator|->
name|key
operator|->
name|privatekey
operator|==
name|NULL
operator|)
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|SSL2_ST_X509_GET_CLIENT_CERTIFICATE
expr_stmt|;
block|}
else|else
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_CLIENT_CERTIFICATE_C
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_X509_GET_CLIENT_CERTIFICATE
condition|)
block|{
name|X509
modifier|*
name|x509
init|=
name|NULL
decl_stmt|;
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
comment|/* If we get an error we need to 		 * ssl->rwstate=SSL_X509_LOOKUP; 		 * return(error); 		 * We should then be retried when things are ok and we 		 * can get a cert or not */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|client_cert_cb
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
name|s
operator|->
name|ctx
operator|->
name|client_cert_cb
argument_list|(
name|s
argument_list|,
operator|&
operator|(
name|x509
operator|)
argument_list|,
operator|&
operator|(
name|pkey
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|s
operator|->
name|rwstate
operator|=
name|SSL_X509_LOOKUP
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|s
operator|->
name|rwstate
operator|=
name|SSL_NOTHING
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|1
operator|)
operator|&&
operator|(
name|pkey
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|x509
operator|!=
name|NULL
operator|)
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_CLIENT_CERTIFICATE_C
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_use_certificate
argument_list|(
name|s
argument_list|,
name|x509
argument_list|)
operator|||
operator|!
name|SSL_use_PrivateKey
argument_list|(
name|s
argument_list|,
name|pkey
argument_list|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|x509
operator|!=
name|NULL
condition|)
name|X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey
operator|!=
name|NULL
condition|)
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_CLIENT_CERTIFICATE
argument_list|,
name|SSL_R_BAD_DATA_RETURNED_BY_CALLBACK
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* We have no client certificate to respond with 			 * so send the correct error message back */
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_CLIENT_CERTIFICATE_B
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|SSL2_MT_ERROR
expr_stmt|;
name|s2n
argument_list|(
name|SSL2_PE_NO_CERTIFICATE
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|3
expr_stmt|;
comment|/* Write is done at the end */
block|}
block|}
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_SEND_CLIENT_CERTIFICATE_B
condition|)
block|{
return|return
operator|(
name|ssl2_do_write
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_SEND_CLIENT_CERTIFICATE_C
condition|)
block|{
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* ok, now we calculate the checksum 		 * do it first so we can reuse buf :-) */
name|p
operator|=
name|buf
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|rsa_md5
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|s
operator|->
name|s2
operator|->
name|key_material
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|s2
operator|->
name|key_material_length
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|cert_ch
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|cert_ch_len
argument_list|)
expr_stmt|;
name|n
operator|=
name|i2d_X509
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_key
operator|->
name|x509
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|d
operator|=
name|p
operator|+
literal|6
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|SSL2_MT_CLIENT_CERTIFICATE
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|SSL2_CT_X509_CERTIFICATE
expr_stmt|;
name|n
operator|=
name|i2d_X509
argument_list|(
name|s
operator|->
name|cert
operator|->
name|key
operator|->
name|x509
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|d
argument_list|,
operator|&
name|n
argument_list|,
name|s
operator|->
name|cert
operator|->
name|key
operator|->
name|privatekey
argument_list|)
condition|)
block|{
comment|/* this is not good.  If things have failed it 			 * means there so something wrong with the key. 			 * We will continue with a 0 length signature 			 */
block|}
name|memset
argument_list|(
operator|&
name|ctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|d
operator|+=
name|n
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_CLIENT_CERTIFICATE_D
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
name|d
operator|-
name|buf
expr_stmt|;
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_D) */
return|return
operator|(
name|ssl2_do_write
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_server_verify
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_GET_SERVER_VERIFY_A
condition|)
block|{
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
literal|1
operator|-
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
literal|1
operator|-
name|s
operator|->
name|init_num
operator|)
condition|)
return|return
operator|(
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_GET_SERVER_VERIFY
argument_list|,
name|i
argument_list|)
operator|)
return|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_GET_SERVER_VERIFY_B
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
name|SSL2_MT_SERVER_VERIFY
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
name|SSL2_MT_ERROR
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_VERIFY
argument_list|,
name|SSL_R_READ_WRONG_PACKET_TYPE
argument_list|)
expr_stmt|;
block|}
else|else
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_VERIFY
argument_list|,
name|SSL_R_PEER_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|s2
operator|->
name|challenge_length
operator|-
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
operator|(
name|int
operator|)
name|s
operator|->
name|s2
operator|->
name|challenge_length
operator|-
name|s
operator|->
name|init_num
operator|)
condition|)
return|return
operator|(
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_GET_SERVER_VERIFY
argument_list|,
name|i
argument_list|)
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|s2
operator|->
name|challenge
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|s2
operator|->
name|challenge_length
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_VERIFY
argument_list|,
name|SSL_R_CHALLENGE_IS_DIFFERENT
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_server_finished
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_GET_SERVER_FINISHED_A
condition|)
block|{
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|buf
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
literal|1
operator|-
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
literal|1
operator|-
name|s
operator|->
name|init_num
operator|)
condition|)
return|return
operator|(
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_GET_SERVER_FINISHED
argument_list|,
name|i
argument_list|)
operator|)
return|;
name|s
operator|->
name|init_num
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|SSL2_MT_REQUEST_CERTIFICATE
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_CLIENT_CERTIFICATE_A
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|!=
name|SSL2_MT_SERVER_FINISHED
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
name|SSL2_MT_ERROR
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_FINISHED
argument_list|,
name|SSL_R_READ_WRONG_PACKET_TYPE
argument_list|)
expr_stmt|;
block|}
else|else
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_FINISHED
argument_list|,
name|SSL_R_PEER_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|s
operator|->
name|state
operator|=
name|SSL_ST_OK
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|buf
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
name|SSL2_SSL_SESSION_ID_LENGTH
operator|-
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|SSL2_SSL_SESSION_ID_LENGTH
operator|-
name|s
operator|->
name|init_num
operator|)
condition|)
return|return
operator|(
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_GET_SERVER_FINISHED
argument_list|,
name|i
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|s
operator|->
name|hit
condition|)
comment|/* new session */
block|{
comment|/* new session-id */
comment|/* Make sure we were not trying to re-use an old SSL_SESSION 		 * or bad things can happen */
comment|/* ZZZZZZZZZZZZZ */
name|s
operator|->
name|session
operator|->
name|session_id_length
operator|=
name|SSL2_SSL_SESSION_ID_LENGTH
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|session
operator|->
name|session_id
argument_list|,
name|p
argument_list|,
name|SSL2_SSL_SESSION_ID_LENGTH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_MICROSOFT_SESS_ID_BUG
operator|)
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
name|s
operator|->
name|session
operator|->
name|session_id
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|session
operator|->
name|session_id_length
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_FINISHED
argument_list|,
name|SSL_R_SSL_SESSION_ID_IS_DIFFERENT
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* loads in the certificate from the server */
end_comment

begin_function
name|int
name|ssl2_set_certificate
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|)
block|{
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|sk
operator|=
name|NULL
expr_stmt|;
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
name|SESS_CERT
modifier|*
name|sc
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|X509
modifier|*
name|x509
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|x509
operator|=
name|d2i_X509
argument_list|(
name|NULL
argument_list|,
operator|&
name|data
argument_list|,
operator|(
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|x509
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL2_SET_CERTIFICATE
argument_list|,
name|ERR_R_X509_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|sk
operator|=
name|sk_X509_new_null
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|!
name|sk_X509_push
argument_list|(
name|sk
argument_list|,
name|x509
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL2_SET_CERTIFICATE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|i
operator|=
name|ssl_verify_cert_chain
argument_list|(
name|s
argument_list|,
name|sk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|verify_mode
operator|!=
name|SSL_VERIFY_NONE
operator|)
operator|&&
operator|(
operator|!
name|i
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL2_SET_CERTIFICATE
argument_list|,
name|SSL_R_CERTIFICATE_VERIFY_FAILED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ERR_clear_error
argument_list|()
expr_stmt|;
comment|/* but we keep s->verify_result */
name|s
operator|->
name|session
operator|->
name|verify_result
operator|=
name|s
operator|->
name|verify_result
expr_stmt|;
comment|/* server's cert for this session */
name|sc
operator|=
name|ssl_sess_cert_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|sess_cert
condition|)
name|ssl_sess_cert_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|peer_pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|x509
operator|=
name|x509
expr_stmt|;
name|sc
operator|->
name|peer_key
operator|=
operator|&
operator|(
name|sc
operator|->
name|peer_pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|)
expr_stmt|;
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|x509
argument_list|)
expr_stmt|;
name|x509
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pkey
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL2_SET_CERTIFICATE
argument_list|,
name|SSL_R_UNABLE_TO_EXTRACT_PUBLIC_KEY
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|pkey
operator|->
name|type
operator|!=
name|EVP_PKEY_RSA
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL2_SET_CERTIFICATE
argument_list|,
name|SSL_R_PUBLIC_KEY_NOT_RSA
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|ssl_set_peer_cert_type
argument_list|(
name|sc
argument_list|,
name|SSL2_CT_X509_CERTIFICATE
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|sk_X509_free
argument_list|(
name|sk
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ssl_rsa_public_encrypt
parameter_list|(
name|SESS_CERT
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|from
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
name|int
name|padding
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|->
name|peer_key
operator|->
name|x509
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|sc
operator|->
name|peer_key
operator|->
name|x509
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_RSA_PUBLIC_ENCRYPT
argument_list|,
name|SSL_R_NO_PUBLICKEY
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pkey
operator|->
name|type
operator|!=
name|EVP_PKEY_RSA
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_RSA_PUBLIC_ENCRYPT
argument_list|,
name|SSL_R_PUBLIC_KEY_IS_NOT_RSA
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* we have the public key */
name|i
operator|=
name|RSA_public_encrypt
argument_list|(
name|len
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|pkey
operator|->
name|pkey
operator|.
name|rsa
argument_list|,
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|SSLerr
argument_list|(
name|SSL_F_SSL_RSA_PUBLIC_ENCRYPT
argument_list|,
name|ERR_R_RSA_LIB
argument_list|)
expr_stmt|;
name|end
label|:
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !NO_SSL2 */
end_comment

begin_if
if|#
directive|if
name|PEDANTIC
end_if

begin_decl_stmt
specifier|static
name|void
modifier|*
name|dummy
init|=
operator|&
name|dummy
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

