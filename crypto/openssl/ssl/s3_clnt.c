begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ssl/s3_clnt.c */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *  * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *  * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from  *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.  *  * Portions of the attached software ("Contribution") are developed by  * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.  *  * The Contribution is licensed pursuant to the OpenSSL open source  * license provided above.  *  * ECC cipher suite support in OpenSSL originally written by  * Vipul Gupta and Sumit Gupta of Sun Microsystems Laboratories.  *  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright 2005 Nokia. All rights reserved.  *  * The portions of the attached software ("Contribution") is developed by  * Nokia Corporation and is licensed pursuant to the OpenSSL open source  * license.  *  * The Contribution, originally written by Mika Kousa and Pasi Eronen of  * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites  * support (see RFC 4279) to OpenSSL.  *  * No patent licenses or other rights except those expressly stated in  * the OpenSSL open source license shall be deemed granted or received  * expressly, by implication, estoppel, or otherwise.  *  * No assurances are provided by Nokia that the Contribution does not  * infringe the patent or other intellectual property rights of any third  * party or that the license provides you with all the necessary rights  * to make use of the Contribution.  *  * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN  * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA  * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY  * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR  * OTHERWISE.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ssl_locl.h"
end_include

begin_include
include|#
directive|include
file|"kssl_lcl.h"
end_include

begin_include
include|#
directive|include
file|<openssl/buffer.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/md5.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
end_ifdef

begin_include
include|#
directive|include
file|<openssl/fips.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_include
include|#
directive|include
file|<openssl/dh.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_ENGINE
end_ifndef

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ca_dn_cmp
parameter_list|(
specifier|const
name|X509_NAME
modifier|*
specifier|const
modifier|*
name|a
parameter_list|,
specifier|const
name|X509_NAME
modifier|*
specifier|const
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
end_ifndef

begin_function_decl
specifier|static
name|int
name|ssl3_check_finished
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_SSL3_METHOD
end_ifndef

begin_function
specifier|static
specifier|const
name|SSL_METHOD
modifier|*
name|ssl3_get_client_method
parameter_list|(
name|int
name|ver
parameter_list|)
block|{
if|if
condition|(
name|ver
operator|==
name|SSL3_VERSION
condition|)
return|return
operator|(
name|SSLv3_client_method
argument_list|()
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_macro
name|IMPLEMENT_ssl3_meth_func
argument_list|(
argument|SSLv3_client_method
argument_list|,
argument|ssl_undefined_function
argument_list|,
argument|ssl3_connect
argument_list|,
argument|ssl3_get_client_method
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ssl3_connect
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|BUF_MEM
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|Time
init|=
operator|(
name|unsigned
name|long
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
specifier|const
name|SSL
modifier|*
name|ssl
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|val
parameter_list|)
init|=
name|NULL
function_decl|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|new_state
decl_stmt|,
name|state
decl_stmt|,
name|skip
init|=
literal|0
decl_stmt|;
name|RAND_add
argument_list|(
operator|&
name|Time
argument_list|,
sizeof|sizeof
argument_list|(
name|Time
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
name|clear_sys_error
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|info_callback
operator|!=
name|NULL
condition|)
name|cb
operator|=
name|s
operator|->
name|info_callback
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|info_callback
operator|!=
name|NULL
condition|)
name|cb
operator|=
name|s
operator|->
name|ctx
operator|->
name|info_callback
expr_stmt|;
name|s
operator|->
name|in_handshake
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_in_init
argument_list|(
name|s
argument_list|)
operator|||
name|SSL_in_before
argument_list|(
name|s
argument_list|)
condition|)
name|SSL_clear
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
comment|/*      * If we're awaiting a HeartbeatResponse, pretend we already got and      * don't await it anymore, because Heartbeats don't make sense during      * handshakes anyway.      */
if|if
condition|(
name|s
operator|->
name|tlsext_hb_pending
condition|)
block|{
name|s
operator|->
name|tlsext_hb_pending
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|tlsext_hb_seq
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|state
operator|=
name|s
operator|->
name|state
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|state
condition|)
block|{
case|case
name|SSL_ST_RENEGOTIATE
case|:
name|s
operator|->
name|renegotiate
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_CONNECT
expr_stmt|;
name|s
operator|->
name|ctx
operator|->
name|stats
operator|.
name|sess_connect_renegotiate
operator|++
expr_stmt|;
comment|/* break */
case|case
name|SSL_ST_BEFORE
case|:
case|case
name|SSL_ST_CONNECT
case|:
case|case
name|SSL_ST_BEFORE
operator||
name|SSL_ST_CONNECT
case|:
case|case
name|SSL_ST_OK
operator||
name|SSL_ST_CONNECT
case|:
name|s
operator|->
name|server
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cb
operator|!=
name|NULL
condition|)
name|cb
argument_list|(
name|s
argument_list|,
name|SSL_CB_HANDSHAKE_START
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|version
operator|&
literal|0xff00
operator|)
operator|!=
literal|0x0300
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CONNECT
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* s->version=SSL3_VERSION; */
name|s
operator|->
name|type
operator|=
name|SSL_ST_CONNECT
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|init_buf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|buf
operator|=
name|BUF_MEM_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|!
name|BUF_MEM_grow
argument_list|(
name|buf
argument_list|,
name|SSL3_RT_MAX_PLAIN_LENGTH
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|s
operator|->
name|init_buf
operator|=
name|buf
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ssl3_setup_buffers
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* setup buffing BIO */
if|if
condition|(
operator|!
name|ssl_init_wbio_buffer
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* don't push the buffering BIO quite yet */
if|if
condition|(
operator|!
name|ssl3_init_finished_mac
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_CLNT_HELLO_A
expr_stmt|;
name|s
operator|->
name|ctx
operator|->
name|stats
operator|.
name|sess_connect
operator|++
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|flags
operator|&=
operator|~
name|SSL3_FLAGS_CCS_OK
expr_stmt|;
comment|/*              * Should have been reset by ssl3_get_finished, too.              */
name|s
operator|->
name|s3
operator|->
name|change_cipher_spec
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SSL3_ST_CW_CLNT_HELLO_A
case|:
case|case
name|SSL3_ST_CW_CLNT_HELLO_B
case|:
name|s
operator|->
name|shutdown
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|ssl3_client_hello
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CR_SRVR_HELLO_A
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
comment|/* turn on buffering for the next lot of output */
if|if
condition|(
name|s
operator|->
name|bbio
operator|!=
name|s
operator|->
name|wbio
condition|)
name|s
operator|->
name|wbio
operator|=
name|BIO_push
argument_list|(
name|s
operator|->
name|bbio
argument_list|,
name|s
operator|->
name|wbio
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSL3_ST_CR_SRVR_HELLO_A
case|:
case|case
name|SSL3_ST_CR_SRVR_HELLO_B
case|:
name|ret
operator|=
name|ssl3_get_server_hello
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|s
operator|->
name|hit
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CR_FINISHED_A
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
if|if
condition|(
name|s
operator|->
name|tlsext_ticket_expected
condition|)
block|{
comment|/* receive renewed session ticket */
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CR_SESSION_TICKET_A
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CR_CERT_A
expr_stmt|;
block|}
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SSL3_ST_CR_CERT_A
case|:
case|case
name|SSL3_ST_CR_CERT_B
case|:
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
comment|/* Noop (ret = 0) for everything but EAP-FAST. */
name|ret
operator|=
name|ssl3_check_finished
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|s
operator|->
name|hit
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CR_FINISHED_A
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* Check if it is anon DH/ECDH, SRP auth */
comment|/* or PSK */
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_auth
operator|&
operator|(
name|SSL_aNULL
operator||
name|SSL_aSRP
operator|)
operator|)
operator|&&
operator|!
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_mkey
operator|&
name|SSL_kPSK
operator|)
condition|)
block|{
name|ret
operator|=
name|ssl3_get_server_certificate
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
if|if
condition|(
name|s
operator|->
name|tlsext_status_expected
condition|)
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CR_CERT_STATUS_A
expr_stmt|;
else|else
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CR_KEY_EXCH_A
expr_stmt|;
block|}
else|else
block|{
name|skip
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CR_KEY_EXCH_A
expr_stmt|;
block|}
else|#
directive|else
block|}
else|else
name|skip
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CR_KEY_EXCH_A
expr_stmt|;
endif|#
directive|endif
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SSL3_ST_CR_KEY_EXCH_A
case|:
case|case
name|SSL3_ST_CR_KEY_EXCH_B
case|:
name|ret
operator|=
name|ssl3_get_key_exchange
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CR_CERT_REQ_A
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
comment|/*              * at this point we check that we have the required stuff from              * the server              */
if|if
condition|(
operator|!
name|ssl3_check_cert_and_algorithm
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
goto|goto
name|end
goto|;
block|}
break|break;
case|case
name|SSL3_ST_CR_CERT_REQ_A
case|:
case|case
name|SSL3_ST_CR_CERT_REQ_B
case|:
name|ret
operator|=
name|ssl3_get_certificate_request
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CR_SRVR_DONE_A
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SSL3_ST_CR_SRVR_DONE_A
case|:
case|case
name|SSL3_ST_CR_SRVR_DONE_B
case|:
name|ret
operator|=
name|ssl3_get_server_done
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRP
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_mkey
operator|&
name|SSL_kSRP
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|SRP_Calc_A_param
argument_list|(
name|s
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CONNECT
argument_list|,
name|SSL_R_SRP_A_CALC
argument_list|)
expr_stmt|;
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_INTERNAL_ERROR
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|cert_req
condition|)
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_CERT_A
expr_stmt|;
else|else
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_KEY_EXCH_A
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SSL3_ST_CW_CERT_A
case|:
case|case
name|SSL3_ST_CW_CERT_B
case|:
case|case
name|SSL3_ST_CW_CERT_C
case|:
case|case
name|SSL3_ST_CW_CERT_D
case|:
name|ret
operator|=
name|ssl3_send_client_certificate
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_KEY_EXCH_A
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SSL3_ST_CW_KEY_EXCH_A
case|:
case|case
name|SSL3_ST_CW_KEY_EXCH_B
case|:
name|ret
operator|=
name|ssl3_send_client_key_exchange
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
comment|/*              * EAY EAY EAY need to check for DH fix cert sent back              */
comment|/*              * For TLS, cert_req is set to 2, so a cert chain of nothing is              * sent, but no verify packet is sent              */
comment|/*              * XXX: For now, we do not support client authentication in ECDH              * cipher suites with ECDH (rather than ECDSA) certificates. We              * need to skip the certificate verify message when client's              * ECDH public key is sent inside the client certificate.              */
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|cert_req
operator|==
literal|1
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_CERT_VRFY_A
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_CHANGE_A
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|flags
operator|&
name|TLS1_FLAGS_SKIP_CERT_VERIFY
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_CHANGE_A
expr_stmt|;
block|}
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SSL3_ST_CW_CERT_VRFY_A
case|:
case|case
name|SSL3_ST_CW_CERT_VRFY_B
case|:
name|ret
operator|=
name|ssl3_send_client_verify
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_CHANGE_A
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SSL3_ST_CW_CHANGE_A
case|:
case|case
name|SSL3_ST_CW_CHANGE_B
case|:
name|ret
operator|=
name|ssl3_send_change_cipher_spec
argument_list|(
name|s
argument_list|,
name|SSL3_ST_CW_CHANGE_A
argument_list|,
name|SSL3_ST_CW_CHANGE_B
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL_NO_TLSEXT
argument_list|)
operator|||
name|defined
argument_list|(
name|OPENSSL_NO_NEXTPROTONEG
argument_list|)
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_FINISHED_A
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|next_proto_neg_seen
condition|)
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_NEXT_PROTO_A
expr_stmt|;
else|else
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_FINISHED_A
expr_stmt|;
endif|#
directive|endif
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|cipher
operator|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL_NO_COMP
name|s
operator|->
name|session
operator|->
name|compress_meth
operator|=
literal|0
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_compression
operator|==
name|NULL
condition|)
name|s
operator|->
name|session
operator|->
name|compress_meth
operator|=
literal|0
expr_stmt|;
else|else
name|s
operator|->
name|session
operator|->
name|compress_meth
operator|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_compression
operator|->
name|id
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|s
operator|->
name|method
operator|->
name|ssl3_enc
operator|->
name|setup_key_block
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|method
operator|->
name|ssl3_enc
operator|->
name|change_cipher_state
argument_list|(
name|s
argument_list|,
name|SSL3_CHANGE_CIPHER_CLIENT_WRITE
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
goto|goto
name|end
goto|;
block|}
break|break;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_TLSEXT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_NEXTPROTONEG
argument_list|)
case|case
name|SSL3_ST_CW_NEXT_PROTO_A
case|:
case|case
name|SSL3_ST_CW_NEXT_PROTO_B
case|:
name|ret
operator|=
name|ssl3_send_next_proto
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_FINISHED_A
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SSL3_ST_CW_FINISHED_A
case|:
case|case
name|SSL3_ST_CW_FINISHED_B
case|:
name|ret
operator|=
name|ssl3_send_finished
argument_list|(
name|s
argument_list|,
name|SSL3_ST_CW_FINISHED_A
argument_list|,
name|SSL3_ST_CW_FINISHED_B
argument_list|,
name|s
operator|->
name|method
operator|->
name|ssl3_enc
operator|->
name|client_finished_label
argument_list|,
name|s
operator|->
name|method
operator|->
name|ssl3_enc
operator|->
name|client_finished_label_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_FLUSH
expr_stmt|;
comment|/* clear flags */
name|s
operator|->
name|s3
operator|->
name|flags
operator|&=
operator|~
name|SSL3_FLAGS_POP_BUFFER
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|hit
condition|)
block|{
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|next_state
operator|=
name|SSL_ST_OK
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|flags
operator|&
name|SSL3_FLAGS_DELAY_CLIENT_FINISHED
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|SSL_ST_OK
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|flags
operator||=
name|SSL3_FLAGS_POP_BUFFER
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|delay_buf_pop_ret
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
comment|/*                  * Allow NewSessionTicket if ticket expected                  */
if|if
condition|(
name|s
operator|->
name|tlsext_ticket_expected
condition|)
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|next_state
operator|=
name|SSL3_ST_CR_SESSION_TICKET_A
expr_stmt|;
else|else
endif|#
directive|endif
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|next_state
operator|=
name|SSL3_ST_CR_FINISHED_A
expr_stmt|;
block|}
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
case|case
name|SSL3_ST_CR_SESSION_TICKET_A
case|:
case|case
name|SSL3_ST_CR_SESSION_TICKET_B
case|:
name|ret
operator|=
name|ssl3_get_new_session_ticket
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CR_FINISHED_A
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SSL3_ST_CR_CERT_STATUS_A
case|:
case|case
name|SSL3_ST_CR_CERT_STATUS_B
case|:
name|ret
operator|=
name|ssl3_get_cert_status
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CR_KEY_EXCH_A
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SSL3_ST_CR_FINISHED_A
case|:
case|case
name|SSL3_ST_CR_FINISHED_B
case|:
if|if
condition|(
operator|!
name|s
operator|->
name|s3
operator|->
name|change_cipher_spec
condition|)
name|s
operator|->
name|s3
operator|->
name|flags
operator||=
name|SSL3_FLAGS_CCS_OK
expr_stmt|;
name|ret
operator|=
name|ssl3_get_finished
argument_list|(
name|s
argument_list|,
name|SSL3_ST_CR_FINISHED_A
argument_list|,
name|SSL3_ST_CR_FINISHED_B
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|s
operator|->
name|hit
condition|)
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_CHANGE_A
expr_stmt|;
else|else
name|s
operator|->
name|state
operator|=
name|SSL_ST_OK
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SSL3_ST_CW_FLUSH
case|:
name|s
operator|->
name|rwstate
operator|=
name|SSL_WRITING
expr_stmt|;
if|if
condition|(
name|BIO_flush
argument_list|(
name|s
operator|->
name|wbio
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|s
operator|->
name|rwstate
operator|=
name|SSL_NOTHING
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|next_state
expr_stmt|;
break|break;
case|case
name|SSL_ST_OK
case|:
comment|/* clean a few things up */
name|ssl3_cleanup_key_block
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|init_buf
operator|!=
name|NULL
condition|)
block|{
name|BUF_MEM_free
argument_list|(
name|s
operator|->
name|init_buf
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_buf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*              * If we are not 'joining' the last two packets, remove the              * buffering now              */
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|s3
operator|->
name|flags
operator|&
name|SSL3_FLAGS_POP_BUFFER
operator|)
condition|)
name|ssl_free_wbio_buffer
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* else do it later in ssl3_write */
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|renegotiate
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|new_session
operator|=
literal|0
expr_stmt|;
name|ssl_update_cache
argument_list|(
name|s
argument_list|,
name|SSL_SESS_CACHE_CLIENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|hit
condition|)
name|s
operator|->
name|ctx
operator|->
name|stats
operator|.
name|sess_hit
operator|++
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* s->server=0; */
name|s
operator|->
name|handshake_func
operator|=
name|ssl3_connect
expr_stmt|;
name|s
operator|->
name|ctx
operator|->
name|stats
operator|.
name|sess_connect_good
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|!=
name|NULL
condition|)
name|cb
argument_list|(
name|s
argument_list|,
name|SSL_CB_HANDSHAKE_DONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
comment|/* break; */
case|case
name|SSL_ST_ERR
case|:
default|default:
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CONNECT
argument_list|,
name|SSL_R_UNKNOWN_STATE
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
comment|/* break; */
block|}
comment|/* did we do anything */
if|if
condition|(
operator|!
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|reuse_message
operator|&&
operator|!
name|skip
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|debug
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|BIO_flush
argument_list|(
name|s
operator|->
name|wbio
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|(
name|cb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|s
operator|->
name|state
operator|!=
name|state
operator|)
condition|)
block|{
name|new_state
operator|=
name|s
operator|->
name|state
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|cb
argument_list|(
name|s
argument_list|,
name|SSL_CB_CONNECT_LOOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|new_state
expr_stmt|;
block|}
block|}
name|skip
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_label
name|end
label|:
end_label

begin_expr_stmt
name|s
operator|->
name|in_handshake
operator|--
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|BUF_MEM_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|cb
operator|!=
name|NULL
condition|)
name|cb
argument_list|(
name|s
argument_list|,
name|SSL_CB_CONNECT_EXIT
argument_list|,
name|ret
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
operator|(
name|ret
operator|)
return|;
end_return

begin_macro
unit|}  int
name|ssl3_client_hello
argument_list|(
argument|SSL *s
argument_list|)
end_macro

begin_block
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|l
decl_stmt|;
name|int
name|al
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_COMP
name|int
name|j
decl_stmt|;
name|SSL_COMP
modifier|*
name|comp
decl_stmt|;
endif|#
directive|endif
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL3_ST_CW_CLNT_HELLO_A
condition|)
block|{
name|SSL_SESSION
modifier|*
name|sess
init|=
name|s
operator|->
name|session
decl_stmt|;
if|if
condition|(
operator|(
name|sess
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sess
operator|->
name|ssl_version
operator|!=
name|s
operator|->
name|version
operator|)
operator|||
ifdef|#
directive|ifdef
name|OPENSSL_NO_TLSEXT
operator|!
name|sess
operator|->
name|session_id_length
operator|||
else|#
directive|else
comment|/*              * In the case of EAP-FAST, we can have a pre-shared              * "ticket" without a session ID.              */
operator|(
operator|!
name|sess
operator|->
name|session_id_length
operator|&&
operator|!
name|sess
operator|->
name|tlsext_tick
operator|)
operator|||
endif|#
directive|endif
operator|(
name|sess
operator|->
name|not_resumable
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_get_new_session
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|s
operator|->
name|method
operator|->
name|version
operator|==
name|DTLS_ANY_VERSION
condition|)
block|{
comment|/* Determine which DTLS version to use */
name|int
name|options
init|=
name|s
operator|->
name|options
decl_stmt|;
comment|/* If DTLS 1.2 disabled correct the version number */
if|if
condition|(
name|options
operator|&
name|SSL_OP_NO_DTLSv1_2
condition|)
block|{
if|if
condition|(
name|tls1_suiteb
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CLIENT_HELLO
argument_list|,
name|SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/*                  * Disabling all versions is silly: return an error.                  */
if|if
condition|(
name|options
operator|&
name|SSL_OP_NO_DTLSv1
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CLIENT_HELLO
argument_list|,
name|SSL_R_WRONG_SSL_VERSION
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/*                  * Update method so we don't use any DTLS 1.2 features.                  */
name|s
operator|->
name|method
operator|=
name|DTLSv1_client_method
argument_list|()
expr_stmt|;
name|s
operator|->
name|version
operator|=
name|DTLS1_VERSION
expr_stmt|;
block|}
else|else
block|{
comment|/*                  * We only support one version: update method                  */
if|if
condition|(
name|options
operator|&
name|SSL_OP_NO_DTLSv1
condition|)
name|s
operator|->
name|method
operator|=
name|DTLSv1_2_client_method
argument_list|()
expr_stmt|;
name|s
operator|->
name|version
operator|=
name|DTLS1_2_VERSION
expr_stmt|;
block|}
name|s
operator|->
name|client_version
operator|=
name|s
operator|->
name|version
expr_stmt|;
block|}
comment|/* else use the pre-loaded session */
name|p
operator|=
name|s
operator|->
name|s3
operator|->
name|client_random
expr_stmt|;
comment|/*          * for DTLS if client_random is initialized, reuse it, we are          * required to use same upon reply to HelloVerify          */
if|if
condition|(
name|SSL_IS_DTLS
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|size_t
name|idx
decl_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
sizeof|sizeof
argument_list|(
name|s
operator|->
name|s3
operator|->
name|client_random
argument_list|)
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|idx
index|]
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|&&
name|ssl_fill_hello_random
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|s3
operator|->
name|client_random
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* Do the message type and length last */
name|d
operator|=
name|p
operator|=
name|ssl_handshake_start
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*-          * version indicates the negotiated version: for example from          * an SSLv2/v3 compatible client hello). The client_version          * field is the maximum version we permit and it is also          * used in RSA encrypted premaster secrets. Some servers can          * choke if we initially report a higher version then          * renegotiate to a lower one in the premaster secret. This          * didn't happen with TLS 1.0 as most servers supported it          * but it can with TLS 1.1 or later if the server only supports          * 1.0.          *          * Possible scenario with previous logic:          *      1. Client hello indicates TLS 1.2          *      2. Server hello says TLS 1.0          *      3. RSA encrypted premaster secret uses 1.2.          *      4. Handhaked proceeds using TLS 1.0.          *      5. Server sends hello request to renegotiate.          *      6. Client hello indicates TLS v1.0 as we now          *         know that is maximum server supports.          *      7. Server chokes on RSA encrypted premaster secret          *         containing version 1.0.          *          * For interoperability it should be OK to always use the          * maximum version we support in client hello and then rely          * on the checking of version to ensure the servers isn't          * being inconsistent: for example initially negotiating with          * TLS 1.0 and renegotiating with TLS 1.2. We do this by using          * client_version in client hello and not resetting it to          * the negotiated version.          */
if|#
directive|if
literal|0
block|*(p++) = s->version>> 8;         *(p++) = s->version& 0xff;         s->client_version = s->version;
else|#
directive|else
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|s
operator|->
name|client_version
operator|>>
literal|8
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|s
operator|->
name|client_version
operator|&
literal|0xff
expr_stmt|;
endif|#
directive|endif
comment|/* Random stuff */
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|s3
operator|->
name|client_random
argument_list|,
name|SSL3_RANDOM_SIZE
argument_list|)
expr_stmt|;
name|p
operator|+=
name|SSL3_RANDOM_SIZE
expr_stmt|;
comment|/* Session ID */
if|if
condition|(
name|s
operator|->
name|new_session
condition|)
name|i
operator|=
literal|0
expr_stmt|;
else|else
name|i
operator|=
name|s
operator|->
name|session
operator|->
name|session_id_length
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|s
operator|->
name|session
operator|->
name|session_id
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CLIENT_HELLO
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|session
operator|->
name|session_id
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
block|}
comment|/* cookie stuff for DTLS */
if|if
condition|(
name|SSL_IS_DTLS
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|cookie_len
operator|>
sizeof|sizeof
argument_list|(
name|s
operator|->
name|d1
operator|->
name|cookie
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CLIENT_HELLO
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|s
operator|->
name|d1
operator|->
name|cookie_len
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|d1
operator|->
name|cookie
argument_list|,
name|s
operator|->
name|d1
operator|->
name|cookie_len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|s
operator|->
name|d1
operator|->
name|cookie_len
expr_stmt|;
block|}
comment|/* Ciphers supported */
name|i
operator|=
name|ssl_cipher_list_to_bytes
argument_list|(
name|s
argument_list|,
name|SSL_get_ciphers
argument_list|(
name|s
argument_list|)
argument_list|,
operator|&
operator|(
name|p
index|[
literal|2
index|]
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CLIENT_HELLO
argument_list|,
name|SSL_R_NO_CIPHERS_AVAILABLE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
ifdef|#
directive|ifdef
name|OPENSSL_MAX_TLS1_2_CIPHER_LENGTH
comment|/*          * Some servers hang if client hello> 256 bytes as hack workaround          * chop number of supported ciphers to keep it well below this if we          * use TLS v1.2          */
if|if
condition|(
name|TLS1_get_version
argument_list|(
name|s
argument_list|)
operator|>=
name|TLS1_2_VERSION
operator|&&
name|i
operator|>
name|OPENSSL_MAX_TLS1_2_CIPHER_LENGTH
condition|)
name|i
operator|=
name|OPENSSL_MAX_TLS1_2_CIPHER_LENGTH
operator|&
operator|~
literal|1
expr_stmt|;
endif|#
directive|endif
name|s2n
argument_list|(
name|i
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
comment|/* COMPRESSION */
ifdef|#
directive|ifdef
name|OPENSSL_NO_COMP
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_NO_COMPRESSION
operator|)
operator|||
operator|!
name|s
operator|->
name|ctx
operator|->
name|comp_methods
condition|)
name|j
operator|=
literal|0
expr_stmt|;
else|else
name|j
operator|=
name|sk_SSL_COMP_num
argument_list|(
name|s
operator|->
name|ctx
operator|->
name|comp_methods
argument_list|)
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|1
operator|+
name|j
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|comp
operator|=
name|sk_SSL_COMP_value
argument_list|(
name|s
operator|->
name|ctx
operator|->
name|comp_methods
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|comp
operator|->
name|id
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* Add the NULL method */
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
comment|/* TLS extensions */
if|if
condition|(
name|ssl_prepare_clienthello_tlsext
argument_list|(
name|s
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CLIENT_HELLO
argument_list|,
name|SSL_R_CLIENTHELLO_TLSEXT
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|ssl_add_clienthello_tlsext
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|buf
operator|+
name|SSL3_RT_MAX_PLAIN_LENGTH
argument_list|,
operator|&
name|al
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CLIENT_HELLO
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
endif|#
directive|endif
name|l
operator|=
name|p
operator|-
name|d
expr_stmt|;
name|ssl_set_handshake_header
argument_list|(
name|s
argument_list|,
name|SSL3_MT_CLIENT_HELLO
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_CLNT_HELLO_B
expr_stmt|;
block|}
comment|/* SSL3_ST_CW_CLNT_HELLO_B */
return|return
name|ssl_do_write
argument_list|(
name|s
argument_list|)
return|;
name|err
label|:
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_function
name|int
name|ssl3_get_server_hello
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|sk
expr_stmt|;
specifier|const
name|SSL_CIPHER
modifier|*
name|c
decl_stmt|;
name|CERT
modifier|*
name|ct
init|=
name|s
operator|->
name|cert
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|,
name|al
init|=
name|SSL_AD_INTERNAL_ERROR
decl_stmt|,
name|ok
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|long
name|n
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_COMP
name|SSL_COMP
modifier|*
name|comp
decl_stmt|;
endif|#
directive|endif
comment|/*      * Hello verify request and/or server hello version may not match so set      * first packet if we're negotiating version.      */
if|if
condition|(
name|SSL_IS_DTLS
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|->
name|first_packet
operator|=
literal|1
expr_stmt|;
name|n
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_get_message
argument_list|(
name|s
argument_list|,
name|SSL3_ST_CR_SRVR_HELLO_A
argument_list|,
name|SSL3_ST_CR_SRVR_HELLO_B
argument_list|,
operator|-
literal|1
argument_list|,
literal|20000
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|n
operator|)
return|;
if|if
condition|(
name|SSL_IS_DTLS
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|s
operator|->
name|first_packet
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|==
name|DTLS1_MT_HELLO_VERIFY_REQUEST
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|send_cookie
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|reuse_message
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* already sent a cookie */
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_BAD_MESSAGE_TYPE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
block|}
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|!=
name|SSL3_MT_SERVER_HELLO
condition|)
block|{
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_BAD_MESSAGE_TYPE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|d
operator|=
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_msg
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|method
operator|->
name|version
operator|==
name|DTLS_ANY_VERSION
condition|)
block|{
comment|/* Work out correct protocol version to use */
name|int
name|hversion
init|=
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|1
index|]
decl_stmt|;
name|int
name|options
init|=
name|s
operator|->
name|options
decl_stmt|;
if|if
condition|(
name|hversion
operator|==
name|DTLS1_2_VERSION
operator|&&
operator|!
operator|(
name|options
operator|&
name|SSL_OP_NO_DTLSv1_2
operator|)
condition|)
name|s
operator|->
name|method
operator|=
name|DTLSv1_2_client_method
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|tls1_suiteb
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE
argument_list|)
expr_stmt|;
name|s
operator|->
name|version
operator|=
name|hversion
expr_stmt|;
name|al
operator|=
name|SSL_AD_PROTOCOL_VERSION
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
elseif|else
if|if
condition|(
name|hversion
operator|==
name|DTLS1_VERSION
operator|&&
operator|!
operator|(
name|options
operator|&
name|SSL_OP_NO_DTLSv1
operator|)
condition|)
name|s
operator|->
name|method
operator|=
name|DTLSv1_client_method
argument_list|()
expr_stmt|;
else|else
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_WRONG_SSL_VERSION
argument_list|)
expr_stmt|;
name|s
operator|->
name|version
operator|=
name|hversion
expr_stmt|;
name|al
operator|=
name|SSL_AD_PROTOCOL_VERSION
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|s
operator|->
name|session
operator|->
name|ssl_version
operator|=
name|s
operator|->
name|version
operator|=
name|s
operator|->
name|method
operator|->
name|version
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|!=
operator|(
name|s
operator|->
name|version
operator|>>
literal|8
operator|)
operator|)
operator|||
operator|(
name|p
index|[
literal|1
index|]
operator|!=
operator|(
name|s
operator|->
name|version
operator|&
literal|0xff
operator|)
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_WRONG_SSL_VERSION
argument_list|)
expr_stmt|;
name|s
operator|->
name|version
operator|=
operator|(
name|s
operator|->
name|version
operator|&
literal|0xff00
operator|)
operator||
name|p
index|[
literal|1
index|]
expr_stmt|;
name|al
operator|=
name|SSL_AD_PROTOCOL_VERSION
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* load the server hello data */
comment|/* load the server random */
name|memcpy
argument_list|(
name|s
operator|->
name|s3
operator|->
name|server_random
argument_list|,
name|p
argument_list|,
name|SSL3_RANDOM_SIZE
argument_list|)
expr_stmt|;
name|p
operator|+=
name|SSL3_RANDOM_SIZE
expr_stmt|;
name|s
operator|->
name|hit
operator|=
literal|0
expr_stmt|;
comment|/* get the session-id */
name|j
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|>
sizeof|sizeof
name|s
operator|->
name|session
operator|->
name|session_id
operator|)
operator|||
operator|(
name|j
operator|>
name|SSL3_SESSION_ID_SIZE
operator|)
condition|)
block|{
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_SSL3_SESSION_ID_TOO_LONG
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
comment|/*      * Check if we can resume the session based on external pre-shared secret.      * EAP-FAST (RFC 4851) supports two types of session resumption.      * Resumption based on server-side state works with session IDs.      * Resumption based on pre-shared Protected Access Credentials (PACs)      * works by overriding the SessionTicket extension at the application      * layer, and does not send a session ID. (We do not know whether EAP-FAST      * servers would honour the session ID.) Therefore, the session ID alone      * is not a reliable indicator of session resumption, so we first check if      * we can resume, and later peek at the next handshake message to see if the      * server wants to resume.      */
if|if
condition|(
name|s
operator|->
name|version
operator|>=
name|TLS1_VERSION
operator|&&
name|s
operator|->
name|tls_session_secret_cb
operator|&&
name|s
operator|->
name|session
operator|->
name|tlsext_tick
condition|)
block|{
name|SSL_CIPHER
modifier|*
name|pref_cipher
init|=
name|NULL
decl_stmt|;
name|s
operator|->
name|session
operator|->
name|master_key_length
operator|=
sizeof|sizeof
argument_list|(
name|s
operator|->
name|session
operator|->
name|master_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|tls_session_secret_cb
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|session
operator|->
name|master_key
argument_list|,
operator|&
name|s
operator|->
name|session
operator|->
name|master_key_length
argument_list|,
name|NULL
argument_list|,
operator|&
name|pref_cipher
argument_list|,
name|s
operator|->
name|tls_session_secret_cb_arg
argument_list|)
condition|)
block|{
name|s
operator|->
name|session
operator|->
name|cipher
operator|=
name|pref_cipher
condition|?
name|pref_cipher
else|:
name|ssl_get_cipher_by_char
argument_list|(
name|s
argument_list|,
name|p
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* OPENSSL_NO_TLSEXT */
if|if
condition|(
name|j
operator|!=
literal|0
operator|&&
name|j
operator|==
name|s
operator|->
name|session
operator|->
name|session_id_length
operator|&&
name|memcmp
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|session
operator|->
name|session_id
argument_list|,
name|j
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|sid_ctx_length
operator|!=
name|s
operator|->
name|session
operator|->
name|sid_ctx_length
operator|||
name|memcmp
argument_list|(
name|s
operator|->
name|session
operator|->
name|sid_ctx
argument_list|,
name|s
operator|->
name|sid_ctx
argument_list|,
name|s
operator|->
name|sid_ctx_length
argument_list|)
condition|)
block|{
comment|/* actually a client application bug */
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|s
operator|->
name|hit
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/*          * If we were trying for session-id reuse but the server          * didn't echo the ID, make a new SSL_SESSION.          * In the case of EAP-FAST and PAC, we do not send a session ID,          * so the PAC-based session secret is always preserved. It'll be          * overwritten if the server refuses resumption.          */
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|session_id_length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_get_new_session
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
condition|)
block|{
goto|goto
name|f_err
goto|;
block|}
block|}
name|s
operator|->
name|session
operator|->
name|session_id_length
operator|=
name|j
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|session
operator|->
name|session_id
argument_list|,
name|p
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* j could be 0 */
block|}
name|p
operator|+=
name|j
expr_stmt|;
name|c
operator|=
name|ssl_get_cipher_by_char
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
comment|/* unknown cipher */
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_UNKNOWN_CIPHER_RETURNED
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
comment|/* Set version disabled mask now we know version */
if|if
condition|(
operator|!
name|SSL_USE_TLS1_2_CIPHERS
argument_list|(
name|s
argument_list|)
condition|)
name|ct
operator|->
name|mask_ssl
operator|=
name|SSL_TLSV1_2
expr_stmt|;
else|else
name|ct
operator|->
name|mask_ssl
operator|=
literal|0
expr_stmt|;
comment|/*      * If it is a disabled cipher we didn't send it in client hello, so      * return an error.      */
if|if
condition|(
name|c
operator|->
name|algorithm_ssl
operator|&
name|ct
operator|->
name|mask_ssl
operator|||
name|c
operator|->
name|algorithm_mkey
operator|&
name|ct
operator|->
name|mask_k
operator|||
name|c
operator|->
name|algorithm_auth
operator|&
name|ct
operator|->
name|mask_a
condition|)
block|{
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_WRONG_CIPHER_RETURNED
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|p
operator|+=
name|ssl_put_cipher_by_char
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sk
operator|=
name|ssl_get_ciphers_by_id
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|i
operator|=
name|sk_SSL_CIPHER_find
argument_list|(
name|sk
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* we did not say we would use this cipher */
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_WRONG_CIPHER_RETURNED
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
comment|/*      * Depending on the session caching (internal/external), the cipher      * and/or cipher_id values may not be set. Make sure that cipher_id is      * set and use it for comparison.      */
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|cipher
condition|)
name|s
operator|->
name|session
operator|->
name|cipher_id
operator|=
name|s
operator|->
name|session
operator|->
name|cipher
operator|->
name|id
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|hit
operator|&&
operator|(
name|s
operator|->
name|session
operator|->
name|cipher_id
operator|!=
name|c
operator|->
name|id
operator|)
condition|)
block|{
comment|/* Workaround is now obsolete */
if|#
directive|if
literal|0
block|if (!(s->options& SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG))
endif|#
directive|endif
block|{
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
block|}
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|=
name|c
expr_stmt|;
comment|/*      * Don't digest cached records if no sigalgs: we may need them for client      * authentication.      */
if|if
condition|(
operator|!
name|SSL_USE_SIGALGS
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|ssl3_digest_cached_records
argument_list|(
name|s
argument_list|)
condition|)
goto|goto
name|f_err
goto|;
comment|/* lets get the compression algorithm */
comment|/* COMPRESSION */
ifdef|#
directive|ifdef
name|OPENSSL_NO_COMP
if|if
condition|(
operator|*
operator|(
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
comment|/*      * If compression is disabled we'd better not try to resume a session      * using compression.      */
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|compress_meth
operator|!=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_INCONSISTENT_COMPRESSION
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
else|#
directive|else
name|j
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|hit
operator|&&
name|j
operator|!=
name|s
operator|->
name|session
operator|->
name|compress_meth
condition|)
block|{
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|comp
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_NO_COMPRESSION
condition|)
block|{
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_COMPRESSION_DISABLED
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
else|else
name|comp
operator|=
name|ssl3_comp_find
argument_list|(
name|s
operator|->
name|ctx
operator|->
name|comp_methods
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|comp
operator|==
name|NULL
operator|)
condition|)
block|{
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
else|else
block|{
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_compression
operator|=
name|comp
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
comment|/* TLS extensions */
if|if
condition|(
operator|!
name|ssl_parse_serverhello_tlsext
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
name|d
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_PARSE_TLSEXT
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|p
operator|!=
operator|(
name|d
operator|+
name|n
operator|)
condition|)
block|{
comment|/* wrong packet length */
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_HELLO
argument_list|,
name|SSL_R_BAD_PACKET_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|f_err
label|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|err
label|:
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ssl3_get_server_certificate
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|al
decl_stmt|,
name|i
decl_stmt|,
name|ok
decl_stmt|,
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|long
name|n
decl_stmt|,
name|nc
decl_stmt|,
name|llen
decl_stmt|,
name|l
decl_stmt|;
name|X509
modifier|*
name|x
init|=
name|NULL
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|sk
operator|=
name|NULL
expr_stmt|;
name|SESS_CERT
modifier|*
name|sc
decl_stmt|;
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
name|int
name|need_cert
init|=
literal|1
decl_stmt|;
comment|/* VRS: 0=> will allow null cert if auth ==                                  * KRB5 */
name|n
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_get_message
argument_list|(
name|s
argument_list|,
name|SSL3_ST_CR_CERT_A
argument_list|,
name|SSL3_ST_CR_CERT_B
argument_list|,
operator|-
literal|1
argument_list|,
name|s
operator|->
name|max_cert_list
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|n
operator|)
return|;
if|if
condition|(
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|==
name|SSL3_MT_SERVER_KEY_EXCHANGE
operator|)
operator|||
operator|(
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_auth
operator|&
name|SSL_aKRB5
operator|)
operator|&&
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|==
name|SSL3_MT_SERVER_DONE
operator|)
operator|)
condition|)
block|{
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|reuse_message
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|!=
name|SSL3_MT_CERTIFICATE
condition|)
block|{
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_CERTIFICATE
argument_list|,
name|SSL_R_BAD_MESSAGE_TYPE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|p
operator|=
name|d
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_msg
expr_stmt|;
if|if
condition|(
operator|(
name|sk
operator|=
name|sk_X509_new_null
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_CERTIFICATE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|n2l3
argument_list|(
name|p
argument_list|,
name|llen
argument_list|)
expr_stmt|;
if|if
condition|(
name|llen
operator|+
literal|3
operator|!=
name|n
condition|)
block|{
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_CERTIFICATE
argument_list|,
name|SSL_R_LENGTH_MISMATCH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
for|for
control|(
name|nc
operator|=
literal|0
init|;
name|nc
operator|<
name|llen
condition|;
control|)
block|{
if|if
condition|(
name|nc
operator|+
literal|3
operator|>
name|llen
condition|)
block|{
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_CERTIFICATE
argument_list|,
name|SSL_R_CERT_LENGTH_MISMATCH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|n2l3
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l
operator|+
name|nc
operator|+
literal|3
operator|)
operator|>
name|llen
condition|)
block|{
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_CERTIFICATE
argument_list|,
name|SSL_R_CERT_LENGTH_MISMATCH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|q
operator|=
name|p
expr_stmt|;
name|x
operator|=
name|d2i_X509
argument_list|(
name|NULL
argument_list|,
operator|&
name|q
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
block|{
name|al
operator|=
name|SSL_AD_BAD_CERTIFICATE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_CERTIFICATE
argument_list|,
name|ERR_R_ASN1_LIB
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
if|if
condition|(
name|q
operator|!=
operator|(
name|p
operator|+
name|l
operator|)
condition|)
block|{
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_CERTIFICATE
argument_list|,
name|SSL_R_CERT_LENGTH_MISMATCH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
if|if
condition|(
operator|!
name|sk_X509_push
argument_list|(
name|sk
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_CERTIFICATE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|x
operator|=
name|NULL
expr_stmt|;
name|nc
operator|+=
name|l
operator|+
literal|3
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|i
operator|=
name|ssl_verify_cert_chain
argument_list|(
name|s
argument_list|,
name|sk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|verify_mode
operator|!=
name|SSL_VERIFY_NONE
operator|)
operator|&&
operator|(
name|i
operator|<=
literal|0
operator|)
ifndef|#
directive|ifndef
name|OPENSSL_NO_KRB5
operator|&&
operator|!
operator|(
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_mkey
operator|&
name|SSL_kKRB5
operator|)
operator|&&
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_auth
operator|&
name|SSL_aKRB5
operator|)
operator|)
endif|#
directive|endif
comment|/* OPENSSL_NO_KRB5 */
condition|)
block|{
name|al
operator|=
name|ssl_verify_alarm_type
argument_list|(
name|s
operator|->
name|verify_result
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_CERTIFICATE
argument_list|,
name|SSL_R_CERTIFICATE_VERIFY_FAILED
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|ERR_clear_error
argument_list|()
expr_stmt|;
comment|/* but we keep s->verify_result */
name|sc
operator|=
name|ssl_sess_cert_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|sess_cert
condition|)
name|ssl_sess_cert_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|cert_chain
operator|=
name|sk
expr_stmt|;
comment|/*      * Inconsistency alert: cert_chain does include the peer's certificate,      * which we don't include in s3_srvr.c      */
name|x
operator|=
name|sk_X509_value
argument_list|(
name|sk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sk
operator|=
name|NULL
expr_stmt|;
comment|/*      * VRS 19990621: possible memory leak; sk=null ==> !sk_pop_free() @end      */
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* VRS: allow null cert if auth == KRB5 */
name|need_cert
operator|=
operator|(
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_mkey
operator|&
name|SSL_kKRB5
operator|)
operator|&&
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_auth
operator|&
name|SSL_aKRB5
operator|)
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|KSSL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pkey,x = %p, %p\n"
argument_list|,
name|pkey
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ssl_cert_type(x,pkey) = %d\n"
argument_list|,
name|ssl_cert_type
argument_list|(
name|x
argument_list|,
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cipher, alg, nc = %s, %lx, %lx, %d\n"
argument_list|,
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|name
argument_list|,
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_mkey
argument_list|,
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_auth
argument_list|,
name|need_cert
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KSSL_DEBUG */
if|if
condition|(
name|need_cert
operator|&&
operator|(
operator|(
name|pkey
operator|==
name|NULL
operator|)
operator|||
name|EVP_PKEY_missing_parameters
argument_list|(
name|pkey
argument_list|)
operator|)
condition|)
block|{
name|x
operator|=
name|NULL
expr_stmt|;
name|al
operator|=
name|SSL3_AL_FATAL
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_CERTIFICATE
argument_list|,
name|SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|i
operator|=
name|ssl_cert_type
argument_list|(
name|x
argument_list|,
name|pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_cert
operator|&&
name|i
operator|<
literal|0
condition|)
block|{
name|x
operator|=
name|NULL
expr_stmt|;
name|al
operator|=
name|SSL3_AL_FATAL
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_CERTIFICATE
argument_list|,
name|SSL_R_UNKNOWN_CERTIFICATE_TYPE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
if|if
condition|(
name|need_cert
condition|)
block|{
name|int
name|exp_idx
init|=
name|ssl_cipher_get_cert_index
argument_list|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
argument_list|)
decl_stmt|;
if|if
condition|(
name|exp_idx
operator|>=
literal|0
operator|&&
name|i
operator|!=
name|exp_idx
condition|)
block|{
name|x
operator|=
name|NULL
expr_stmt|;
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_CERTIFICATE
argument_list|,
name|SSL_R_WRONG_CERTIFICATE_TYPE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|sc
operator|->
name|peer_cert_type
operator|=
name|i
expr_stmt|;
name|CRYPTO_add
argument_list|(
operator|&
name|x
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_X509
argument_list|)
expr_stmt|;
comment|/*          * Why would the following ever happen? We just created sc a couple          * of lines ago.          */
if|if
condition|(
name|sc
operator|->
name|peer_pkeys
index|[
name|i
index|]
operator|.
name|x509
operator|!=
name|NULL
condition|)
name|X509_free
argument_list|(
name|sc
operator|->
name|peer_pkeys
index|[
name|i
index|]
operator|.
name|x509
argument_list|)
expr_stmt|;
name|sc
operator|->
name|peer_pkeys
index|[
name|i
index|]
operator|.
name|x509
operator|=
name|x
expr_stmt|;
name|sc
operator|->
name|peer_key
operator|=
operator|&
operator|(
name|sc
operator|->
name|peer_pkeys
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|peer
operator|!=
name|NULL
condition|)
name|X509_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|peer
argument_list|)
expr_stmt|;
name|CRYPTO_add
argument_list|(
operator|&
name|x
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_X509
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|peer
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|peer_cert_type
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|peer_key
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|peer
operator|!=
name|NULL
condition|)
name|X509_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|peer
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|peer
operator|=
name|NULL
expr_stmt|;
block|}
name|s
operator|->
name|session
operator|->
name|verify_result
operator|=
name|s
operator|->
name|verify_result
expr_stmt|;
name|x
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
name|f_err
label|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|err
label|:
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
block|}
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sk_X509_pop_free
argument_list|(
name|sk
argument_list|,
name|X509_free
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ssl3_get_key_exchange
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|unsigned
name|char
modifier|*
name|q
decl_stmt|,
name|md_buf
index|[
name|EVP_MAX_MD_SIZE
operator|*
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|EVP_MD_CTX
name|md_ctx
decl_stmt|;
name|unsigned
name|char
modifier|*
name|param
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|al
decl_stmt|,
name|j
decl_stmt|,
name|ok
decl_stmt|;
name|long
name|i
decl_stmt|,
name|param_len
decl_stmt|,
name|n
decl_stmt|,
name|alg_k
decl_stmt|,
name|alg_a
decl_stmt|;
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
specifier|const
name|EVP_MD
modifier|*
name|md
init|=
name|NULL
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|RSA
modifier|*
name|rsa
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
name|DH
modifier|*
name|dh
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDH
name|EC_KEY
modifier|*
name|ecdh
init|=
name|NULL
decl_stmt|;
name|BN_CTX
modifier|*
name|bn_ctx
init|=
name|NULL
decl_stmt|;
name|EC_POINT
modifier|*
name|srvr_ecpoint
init|=
name|NULL
decl_stmt|;
name|int
name|curve_nid
init|=
literal|0
decl_stmt|;
name|int
name|encoded_pt_len
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|EVP_MD_CTX_init
argument_list|(
operator|&
name|md_ctx
argument_list|)
expr_stmt|;
comment|/*      * use same message size as in ssl3_get_certificate_request() as      * ServerKeyExchange message may be skipped      */
name|n
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_get_message
argument_list|(
name|s
argument_list|,
name|SSL3_ST_CR_KEY_EXCH_A
argument_list|,
name|SSL3_ST_CR_KEY_EXCH_B
argument_list|,
operator|-
literal|1
argument_list|,
name|s
operator|->
name|max_cert_list
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|n
operator|)
return|;
name|alg_k
operator|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_mkey
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|!=
name|SSL3_MT_SERVER_KEY_EXCHANGE
condition|)
block|{
comment|/*          * Can't skip server key exchange if this is an ephemeral          * ciphersuite.          */
if|if
condition|(
name|alg_k
operator|&
operator|(
name|SSL_kDHE
operator||
name|SSL_kECDHE
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_PSK
comment|/*          * In plain PSK ciphersuite, ServerKeyExchange can be omitted if no          * identity hint is sent. Set session->sess_cert anyway to avoid          * problems later.          */
if|if
condition|(
name|alg_k
operator|&
name|SSL_kPSK
condition|)
block|{
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|=
name|ssl_sess_cert_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|psk_identity_hint
condition|)
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|ctx
operator|->
name|psk_identity_hint
argument_list|)
expr_stmt|;
name|s
operator|->
name|ctx
operator|->
name|psk_identity_hint
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|reuse_message
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|param
operator|=
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_msg
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|!=
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_rsa_tmp
operator|!=
name|NULL
condition|)
block|{
name|RSA_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_rsa_tmp
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_rsa_tmp
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_dh_tmp
condition|)
block|{
name|DH_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_dh_tmp
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_dh_tmp
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDH
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_ecdh_tmp
condition|)
block|{
name|EC_KEY_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_ecdh_tmp
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_ecdh_tmp
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|=
name|ssl_sess_cert_new
argument_list|()
expr_stmt|;
block|}
comment|/* Total length of the parameters including the length prefix */
name|param_len
operator|=
literal|0
expr_stmt|;
name|alg_a
operator|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_auth
expr_stmt|;
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_PSK
if|if
condition|(
name|alg_k
operator|&
name|SSL_kPSK
condition|)
block|{
name|param_len
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|param_len
operator|>
name|n
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_LENGTH_TOO_SHORT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/*          * Store PSK identity hint for later use, hint is used in          * ssl3_send_client_key_exchange.  Assume that the maximum length of          * a PSK identity hint can be as long as the maximum length of a PSK          * identity.          */
if|if
condition|(
name|i
operator|>
name|PSK_MAX_IDENTITY_LEN
condition|)
block|{
name|al
operator|=
name|SSL_AD_HANDSHAKE_FAILURE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_DATA_LENGTH_TOO_LONG
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
if|if
condition|(
name|i
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
name|i
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|psk_identity_hint
operator|=
name|BUF_strndup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|psk_identity_hint
operator|==
name|NULL
condition|)
block|{
name|al
operator|=
name|SSL_AD_HANDSHAKE_FAILURE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|p
operator|+=
name|i
expr_stmt|;
name|n
operator|-=
name|param_len
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* !OPENSSL_NO_PSK */
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRP
if|if
condition|(
name|alg_k
operator|&
name|SSL_kSRP
condition|)
block|{
name|param_len
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|param_len
operator|>
name|n
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_LENGTH_TOO_SHORT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_SRP_N_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|srp_ctx
operator|.
name|N
operator|=
name|BN_bin2bn
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|+=
name|i
expr_stmt|;
if|if
condition|(
literal|2
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_LENGTH_TOO_SHORT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
literal|2
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_SRP_G_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|srp_ctx
operator|.
name|g
operator|=
name|BN_bin2bn
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|+=
name|i
expr_stmt|;
if|if
condition|(
literal|1
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_LENGTH_TOO_SHORT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
literal|1
expr_stmt|;
name|i
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_SRP_S_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|srp_ctx
operator|.
name|s
operator|=
name|BN_bin2bn
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|+=
name|i
expr_stmt|;
if|if
condition|(
literal|2
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_LENGTH_TOO_SHORT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
literal|2
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_SRP_B_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|srp_ctx
operator|.
name|B
operator|=
name|BN_bin2bn
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|+=
name|i
expr_stmt|;
name|n
operator|-=
name|param_len
expr_stmt|;
if|if
condition|(
operator|!
name|srp_verify_server_param
argument_list|(
name|s
argument_list|,
operator|&
name|al
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_SRP_PARAMETERS
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
comment|/* We must check if there is a certificate */
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|alg_a
operator|&
name|SSL_aRSA
condition|)
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|x509
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
literal|0
condition|)
empty_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
elseif|else
if|if
condition|(
name|alg_a
operator|&
name|SSL_aDSS
condition|)
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_pkeys
index|[
name|SSL_PKEY_DSA_SIGN
index|]
operator|.
name|x509
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
endif|#
directive|endif
comment|/* !OPENSSL_NO_SRP */
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|alg_k
operator|&
name|SSL_kRSA
condition|)
block|{
comment|/* Temporary RSA keys only allowed in export ciphersuites */
if|if
condition|(
operator|!
name|SSL_C_IS_EXPORT
argument_list|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
argument_list|)
condition|)
block|{
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
if|if
condition|(
operator|(
name|rsa
operator|=
name|RSA_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|param_len
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|param_len
operator|>
name|n
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_LENGTH_TOO_SHORT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_RSA_MODULUS_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rsa
operator|->
name|n
operator|=
name|BN_bin2bn
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|rsa
operator|->
name|n
argument_list|)
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|+=
name|i
expr_stmt|;
if|if
condition|(
literal|2
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_LENGTH_TOO_SHORT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
literal|2
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_RSA_E_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rsa
operator|->
name|e
operator|=
name|BN_bin2bn
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|rsa
operator|->
name|e
argument_list|)
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|+=
name|i
expr_stmt|;
name|n
operator|-=
name|param_len
expr_stmt|;
comment|/* this should be because we are using an export cipher */
if|if
condition|(
name|alg_a
operator|&
name|SSL_aRSA
condition|)
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|x509
argument_list|)
expr_stmt|;
else|else
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|EVP_PKEY_bits
argument_list|(
name|pkey
argument_list|)
operator|<=
name|SSL_C_EXPORT_PKEYLENGTH
argument_list|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
argument_list|)
condition|)
block|{
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_rsa_tmp
operator|=
name|rsa
expr_stmt|;
name|rsa
operator|=
name|NULL
expr_stmt|;
block|}
else|#
directive|else
comment|/* OPENSSL_NO_RSA */
if|if
condition|(
literal|0
condition|)
empty_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
elseif|else
if|if
condition|(
name|alg_k
operator|&
name|SSL_kEDH
condition|)
block|{
if|if
condition|(
operator|(
name|dh
operator|=
name|DH_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_DH_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|param_len
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|param_len
operator|>
name|n
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_LENGTH_TOO_SHORT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_DH_P_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dh
operator|->
name|p
operator|=
name|BN_bin2bn
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|+=
name|i
expr_stmt|;
if|if
condition|(
literal|2
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_LENGTH_TOO_SHORT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
literal|2
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_DH_G_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dh
operator|->
name|g
operator|=
name|BN_bin2bn
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|+=
name|i
expr_stmt|;
if|if
condition|(
literal|2
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_LENGTH_TOO_SHORT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
literal|2
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n
operator|-
name|param_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_DH_PUB_KEY_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dh
operator|->
name|pub_key
operator|=
name|BN_bin2bn
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|+=
name|i
expr_stmt|;
name|n
operator|-=
name|param_len
expr_stmt|;
if|if
condition|(
name|BN_is_zero
argument_list|(
name|dh
operator|->
name|pub_key
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_DH_PUB_KEY_VALUE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
comment|/*-          * Check that p and g are suitable enough          *          * p is odd          * 1< g< p - 1          */
block|{
name|BIGNUM
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|BN_is_odd
argument_list|(
name|dh
operator|->
name|p
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_DH_P_VALUE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
if|if
condition|(
name|BN_is_negative
argument_list|(
name|dh
operator|->
name|g
argument_list|)
operator|||
name|BN_is_zero
argument_list|(
name|dh
operator|->
name|g
argument_list|)
operator|||
name|BN_is_one
argument_list|(
name|dh
operator|->
name|g
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_DH_G_VALUE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
if|if
condition|(
operator|(
name|tmp
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
name|BN_copy
argument_list|(
name|tmp
argument_list|,
name|dh
operator|->
name|p
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|BN_sub_word
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|BN_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_BN_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|BN_cmp
argument_list|(
name|dh
operator|->
name|g
argument_list|,
name|tmp
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|BN_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_DH_G_VALUE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|BN_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|alg_a
operator|&
name|SSL_aRSA
condition|)
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|x509
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
literal|0
condition|)
empty_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
elseif|else
if|if
condition|(
name|alg_a
operator|&
name|SSL_aDSS
condition|)
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_pkeys
index|[
name|SSL_PKEY_DSA_SIGN
index|]
operator|.
name|x509
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* else anonymous DH, so no certificate or pkey. */
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_dh_tmp
operator|=
name|dh
expr_stmt|;
name|dh
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|alg_k
operator|&
name|SSL_kDHr
operator|)
operator|||
operator|(
name|alg_k
operator|&
name|SSL_kDHd
operator|)
condition|)
block|{
name|al
operator|=
name|SSL_AD_ILLEGAL_PARAMETER
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
endif|#
directive|endif
comment|/* !OPENSSL_NO_DH */
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDH
elseif|else
if|if
condition|(
name|alg_k
operator|&
name|SSL_kEECDH
condition|)
block|{
name|EC_GROUP
modifier|*
name|ngroup
decl_stmt|;
specifier|const
name|EC_GROUP
modifier|*
name|group
decl_stmt|;
if|if
condition|(
operator|(
name|ecdh
operator|=
name|EC_KEY_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/*          * Extract elliptic curve parameters and the server's ephemeral ECDH          * public key. Keep accumulating lengths of various components in          * param_len and make sure it never exceeds n.          */
comment|/*          * XXX: For now we only support named (not generic) curves and the          * ECParameters in this case is just three bytes. We also need one          * byte for the length of the encoded point          */
name|param_len
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|param_len
operator|>
name|n
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_LENGTH_TOO_SHORT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
comment|/*          * Check curve is one of our preferences, if not server has sent an          * invalid curve. ECParameters is 3 bytes.          */
if|if
condition|(
operator|!
name|tls1_check_curve
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_WRONG_CURVE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
if|if
condition|(
operator|(
name|curve_nid
operator|=
name|tls1_ec_curve_id2nid
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|ngroup
operator|=
name|EC_GROUP_new_by_curve_name
argument_list|(
name|curve_nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngroup
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_EC_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|EC_KEY_set_group
argument_list|(
name|ecdh
argument_list|,
name|ngroup
argument_list|)
operator|==
literal|0
condition|)
block|{
name|EC_GROUP_free
argument_list|(
name|ngroup
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_EC_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|EC_GROUP_free
argument_list|(
name|ngroup
argument_list|)
expr_stmt|;
name|group
operator|=
name|EC_KEY_get0_group
argument_list|(
name|ecdh
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSL_C_IS_EXPORT
argument_list|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
argument_list|)
operator|&&
operator|(
name|EC_GROUP_get_degree
argument_list|(
name|group
argument_list|)
operator|>
literal|163
operator|)
condition|)
block|{
name|al
operator|=
name|SSL_AD_EXPORT_RESTRICTION
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|p
operator|+=
literal|3
expr_stmt|;
comment|/* Next, get the encoded ECPoint */
if|if
condition|(
operator|(
operator|(
name|srvr_ecpoint
operator|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|bn_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|encoded_pt_len
operator|=
operator|*
name|p
expr_stmt|;
comment|/* length of encoded point */
name|p
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|encoded_pt_len
operator|>
name|n
operator|-
name|param_len
operator|)
operator|||
operator|(
name|EC_POINT_oct2point
argument_list|(
name|group
argument_list|,
name|srvr_ecpoint
argument_list|,
name|p
argument_list|,
name|encoded_pt_len
argument_list|,
name|bn_ctx
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_ECPOINT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|param_len
operator|+=
name|encoded_pt_len
expr_stmt|;
name|n
operator|-=
name|param_len
expr_stmt|;
name|p
operator|+=
name|encoded_pt_len
expr_stmt|;
comment|/*          * The ECC/TLS specification does not mention the use of DSA to sign          * ECParameters in the server key exchange message. We do support RSA          * and ECDSA.          */
if|if
condition|(
literal|0
condition|)
empty_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
elseif|else
if|if
condition|(
name|alg_a
operator|&
name|SSL_aRSA
condition|)
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|x509
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDSA
elseif|else
if|if
condition|(
name|alg_a
operator|&
name|SSL_aECDSA
condition|)
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_pkeys
index|[
name|SSL_PKEY_ECC
index|]
operator|.
name|x509
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* else anonymous ECDH, so no certificate or pkey. */
name|EC_KEY_set_public_key
argument_list|(
name|ecdh
argument_list|,
name|srvr_ecpoint
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_ecdh_tmp
operator|=
name|ecdh
expr_stmt|;
name|ecdh
operator|=
name|NULL
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bn_ctx
argument_list|)
expr_stmt|;
name|bn_ctx
operator|=
name|NULL
expr_stmt|;
name|EC_POINT_free
argument_list|(
name|srvr_ecpoint
argument_list|)
expr_stmt|;
name|srvr_ecpoint
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alg_k
condition|)
block|{
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
endif|#
directive|endif
comment|/* !OPENSSL_NO_ECDH */
comment|/* p points to the next byte, there are 'n' bytes left */
comment|/* if it was signed, check the signature */
if|if
condition|(
name|pkey
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SSL_USE_SIGALGS
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|int
name|rv
decl_stmt|;
if|if
condition|(
literal|2
operator|>
name|n
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_LENGTH_TOO_SHORT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|rv
operator|=
name|tls12_check_peer_sigalg
argument_list|(
operator|&
name|md
argument_list|,
name|s
argument_list|,
name|p
argument_list|,
name|pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
elseif|else
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
goto|goto
name|f_err
goto|;
block|}
ifdef|#
directive|ifdef
name|SSL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"USING TLSv1.2 HASH %s\n"
argument_list|,
name|EVP_MD_name
argument_list|(
name|md
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|+=
literal|2
expr_stmt|;
name|n
operator|-=
literal|2
expr_stmt|;
block|}
else|else
name|md
operator|=
name|EVP_sha1
argument_list|()
expr_stmt|;
if|if
condition|(
literal|2
operator|>
name|n
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_LENGTH_TOO_SHORT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|n
operator|-=
literal|2
expr_stmt|;
name|j
operator|=
name|EVP_PKEY_size
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
comment|/*          * Check signature length. If n is 0 then signature is empty          */
if|if
condition|(
operator|(
name|i
operator|!=
name|n
operator|)
operator|||
operator|(
name|n
operator|>
name|j
operator|)
operator|||
operator|(
name|n
operator|<=
literal|0
operator|)
condition|)
block|{
comment|/* wrong packet length */
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_WRONG_SIGNATURE_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|pkey
operator|->
name|type
operator|==
name|EVP_PKEY_RSA
operator|&&
operator|!
name|SSL_USE_SIGALGS
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|int
name|num
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|md_buf
expr_stmt|;
for|for
control|(
name|num
operator|=
literal|2
init|;
name|num
operator|>
literal|0
condition|;
name|num
operator|--
control|)
block|{
name|EVP_MD_CTX_set_flags
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|EVP_MD_CTX_FLAG_NON_FIPS_ALLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_DigestInit_ex
argument_list|(
operator|&
name|md_ctx
argument_list|,
operator|(
name|num
operator|==
literal|2
operator|)
condition|?
name|s
operator|->
name|ctx
operator|->
name|md5
else|:
name|s
operator|->
name|ctx
operator|->
name|sha1
argument_list|,
name|NULL
argument_list|)
operator|<=
literal|0
operator|||
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md_ctx
argument_list|,
operator|&
operator|(
name|s
operator|->
name|s3
operator|->
name|client_random
index|[
literal|0
index|]
operator|)
argument_list|,
name|SSL3_RANDOM_SIZE
argument_list|)
operator|<=
literal|0
operator|||
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md_ctx
argument_list|,
operator|&
operator|(
name|s
operator|->
name|s3
operator|->
name|server_random
index|[
literal|0
index|]
operator|)
argument_list|,
name|SSL3_RANDOM_SIZE
argument_list|)
operator|<=
literal|0
operator|||
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|param
argument_list|,
name|param_len
argument_list|)
operator|<=
literal|0
operator|||
name|EVP_DigestFinal_ex
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|q
argument_list|,
operator|&
name|size
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|q
operator|+=
name|size
expr_stmt|;
name|j
operator|+=
name|size
expr_stmt|;
block|}
name|i
operator|=
name|RSA_verify
argument_list|(
name|NID_md5_sha1
argument_list|,
name|md_buf
argument_list|,
name|j
argument_list|,
name|p
argument_list|,
name|n
argument_list|,
name|pkey
operator|->
name|pkey
operator|.
name|rsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|al
operator|=
name|SSL_AD_DECRYPT_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_RSA_DECRYPT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* bad signature */
name|al
operator|=
name|SSL_AD_DECRYPT_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_SIGNATURE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|EVP_VerifyInit_ex
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|md
argument_list|,
name|NULL
argument_list|)
operator|<=
literal|0
operator|||
name|EVP_VerifyUpdate
argument_list|(
operator|&
name|md_ctx
argument_list|,
operator|&
operator|(
name|s
operator|->
name|s3
operator|->
name|client_random
index|[
literal|0
index|]
operator|)
argument_list|,
name|SSL3_RANDOM_SIZE
argument_list|)
operator|<=
literal|0
operator|||
name|EVP_VerifyUpdate
argument_list|(
operator|&
name|md_ctx
argument_list|,
operator|&
operator|(
name|s
operator|->
name|s3
operator|->
name|server_random
index|[
literal|0
index|]
operator|)
argument_list|,
name|SSL3_RANDOM_SIZE
argument_list|)
operator|<=
literal|0
operator|||
name|EVP_VerifyUpdate
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|param
argument_list|,
name|param_len
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_EVP_LIB
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
if|if
condition|(
name|EVP_VerifyFinal
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|p
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|pkey
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|/* bad signature */
name|al
operator|=
name|SSL_AD_DECRYPT_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_SIGNATURE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* aNULL, aSRP or kPSK do not need public keys */
if|if
condition|(
operator|!
operator|(
name|alg_a
operator|&
operator|(
name|SSL_aNULL
operator||
name|SSL_aSRP
operator|)
operator|)
operator|&&
operator|!
operator|(
name|alg_k
operator|&
name|SSL_kPSK
operator|)
condition|)
block|{
comment|/* Might be wrong key type, check it */
if|if
condition|(
name|ssl3_check_cert_and_algorithm
argument_list|(
name|s
argument_list|)
condition|)
comment|/* Otherwise this shouldn't happen */
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* still data left over */
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_KEY_EXCHANGE
argument_list|,
name|SSL_R_EXTRA_DATA_IN_MESSAGE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
block|}
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|md_ctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|f_err
label|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|err
label|:
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|rsa
operator|!=
name|NULL
condition|)
name|RSA_free
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
if|if
condition|(
name|dh
operator|!=
name|NULL
condition|)
name|DH_free
argument_list|(
name|dh
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDH
name|BN_CTX_free
argument_list|(
name|bn_ctx
argument_list|)
expr_stmt|;
name|EC_POINT_free
argument_list|(
name|srvr_ecpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecdh
operator|!=
name|NULL
condition|)
name|EC_KEY_free
argument_list|(
name|ecdh
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|md_ctx
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ssl3_get_certificate_request
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|ok
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|n
decl_stmt|,
name|nc
decl_stmt|,
name|l
decl_stmt|;
name|unsigned
name|int
name|llen
decl_stmt|,
name|ctype_num
decl_stmt|,
name|i
decl_stmt|;
name|X509_NAME
modifier|*
name|xn
init|=
name|NULL
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509_NAME
argument_list|)
operator|*
name|ca_sk
operator|=
name|NULL
expr_stmt|;
name|n
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_get_message
argument_list|(
name|s
argument_list|,
name|SSL3_ST_CR_CERT_REQ_A
argument_list|,
name|SSL3_ST_CR_CERT_REQ_B
argument_list|,
operator|-
literal|1
argument_list|,
name|s
operator|->
name|max_cert_list
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|n
operator|)
return|;
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|cert_req
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|==
name|SSL3_MT_SERVER_DONE
condition|)
block|{
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|reuse_message
operator|=
literal|1
expr_stmt|;
comment|/*          * If we get here we don't need any cached handshake records as we          * wont be doing client auth.          */
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|handshake_buffer
condition|)
block|{
if|if
condition|(
operator|!
name|ssl3_digest_cached_records
argument_list|(
name|s
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|!=
name|SSL3_MT_CERTIFICATE_REQUEST
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERTIFICATE_REQUEST
argument_list|,
name|SSL_R_WRONG_MESSAGE_TYPE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* TLS does not like anon-DH with client cert */
if|if
condition|(
name|s
operator|->
name|version
operator|>
name|SSL3_VERSION
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_auth
operator|&
name|SSL_aNULL
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERTIFICATE_REQUEST
argument_list|,
name|SSL_R_TLS_CLIENT_CERT_REQ_WITH_ANON_CIPHER
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|p
operator|=
name|d
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_msg
expr_stmt|;
if|if
condition|(
operator|(
name|ca_sk
operator|=
name|sk_X509_NAME_new
argument_list|(
name|ca_dn_cmp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERTIFICATE_REQUEST
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* get the certificate types */
name|ctype_num
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|ctypes
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|cert
operator|->
name|ctypes
argument_list|)
expr_stmt|;
name|s
operator|->
name|cert
operator|->
name|ctypes
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ctype_num
operator|>
name|SSL3_CT_NUMBER
condition|)
block|{
comment|/* If we exceed static buffer copy all to cert structure */
name|s
operator|->
name|cert
operator|->
name|ctypes
operator|=
name|OPENSSL_malloc
argument_list|(
name|ctype_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|ctypes
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERTIFICATE_REQUEST
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|memcpy
argument_list|(
name|s
operator|->
name|cert
operator|->
name|ctypes
argument_list|,
name|p
argument_list|,
name|ctype_num
argument_list|)
expr_stmt|;
name|s
operator|->
name|cert
operator|->
name|ctype_num
operator|=
operator|(
name|size_t
operator|)
name|ctype_num
expr_stmt|;
name|ctype_num
operator|=
name|SSL3_CT_NUMBER
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctype_num
condition|;
name|i
operator|++
control|)
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|ctype
index|[
name|i
index|]
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
name|p
operator|+=
name|p
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|SSL_USE_SIGALGS
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|n2s
argument_list|(
name|p
argument_list|,
name|llen
argument_list|)
expr_stmt|;
comment|/*          * Check we have enough room for signature algorithms and following          * length value.          */
if|if
condition|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|p
operator|-
name|d
operator|+
name|llen
operator|+
literal|2
argument_list|)
operator|>
name|n
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_DECODE_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERTIFICATE_REQUEST
argument_list|,
name|SSL_R_DATA_LENGTH_TOO_LONG
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Clear certificate digests and validity flags */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SSL_PKEY_NUM
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|->
name|cert
operator|->
name|pkeys
index|[
name|i
index|]
operator|.
name|digest
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|cert
operator|->
name|pkeys
index|[
name|i
index|]
operator|.
name|valid_flags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|llen
operator|&
literal|1
operator|)
operator|||
operator|!
name|tls1_save_sigalgs
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|llen
argument_list|)
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_DECODE_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERTIFICATE_REQUEST
argument_list|,
name|SSL_R_SIGNATURE_ALGORITHMS_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|tls1_process_sigalgs
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_INTERNAL_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERTIFICATE_REQUEST
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|+=
name|llen
expr_stmt|;
block|}
comment|/* get the CA RDNs */
name|n2s
argument_list|(
name|p
argument_list|,
name|llen
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|{         FILE *out;         out = fopen("/tmp/vsign.der", "w");         fwrite(p, 1, llen, out);         fclose(out);     }
endif|#
directive|endif
if|if
condition|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|p
operator|-
name|d
operator|+
name|llen
argument_list|)
operator|!=
name|n
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_DECODE_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERTIFICATE_REQUEST
argument_list|,
name|SSL_R_LENGTH_MISMATCH
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|nc
operator|=
literal|0
init|;
name|nc
operator|<
name|llen
condition|;
control|)
block|{
if|if
condition|(
name|nc
operator|+
literal|2
operator|>
name|llen
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_DECODE_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERTIFICATE_REQUEST
argument_list|,
name|SSL_R_CA_DN_TOO_LONG
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|n2s
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l
operator|+
name|nc
operator|+
literal|2
operator|)
operator|>
name|llen
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_NETSCAPE_CA_DN_BUG
operator|)
condition|)
goto|goto
name|cont
goto|;
comment|/* netscape bugs */
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_DECODE_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERTIFICATE_REQUEST
argument_list|,
name|SSL_R_CA_DN_TOO_LONG
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|q
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|xn
operator|=
name|d2i_X509_NAME
argument_list|(
name|NULL
argument_list|,
operator|&
name|q
argument_list|,
name|l
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* If netscape tolerance is on, ignore errors */
if|if
condition|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_NETSCAPE_CA_DN_BUG
condition|)
goto|goto
name|cont
goto|;
else|else
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_DECODE_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERTIFICATE_REQUEST
argument_list|,
name|ERR_R_ASN1_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|q
operator|!=
operator|(
name|p
operator|+
name|l
operator|)
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_DECODE_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERTIFICATE_REQUEST
argument_list|,
name|SSL_R_CA_DN_LENGTH_MISMATCH
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|sk_X509_NAME_push
argument_list|(
name|ca_sk
argument_list|,
name|xn
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERTIFICATE_REQUEST
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|xn
operator|=
name|NULL
expr_stmt|;
name|p
operator|+=
name|l
expr_stmt|;
name|nc
operator|+=
name|l
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
literal|0
condition|)
block|{
name|cont
label|:
name|ERR_clear_error
argument_list|()
expr_stmt|;
block|}
comment|/* we should setup a certificate to return.... */
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|cert_req
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|ctype_num
operator|=
name|ctype_num
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|ca_names
operator|!=
name|NULL
condition|)
name|sk_X509_NAME_pop_free
argument_list|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|ca_names
argument_list|,
name|X509_NAME_free
argument_list|)
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|ca_names
operator|=
name|ca_sk
expr_stmt|;
name|ca_sk
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
name|err
label|:
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
name|done
label|:
name|X509_NAME_free
argument_list|(
name|xn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca_sk
operator|!=
name|NULL
condition|)
name|sk_X509_NAME_pop_free
argument_list|(
name|ca_sk
argument_list|,
name|X509_NAME_free
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ca_dn_cmp
parameter_list|(
specifier|const
name|X509_NAME
modifier|*
specifier|const
modifier|*
name|a
parameter_list|,
specifier|const
name|X509_NAME
modifier|*
specifier|const
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|X509_NAME_cmp
argument_list|(
operator|*
name|a
argument_list|,
operator|*
name|b
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
end_ifndef

begin_function
name|int
name|ssl3_get_new_session_ticket
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|ok
decl_stmt|,
name|al
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|ticklen
decl_stmt|;
name|long
name|n
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
decl_stmt|;
name|unsigned
name|long
name|ticket_lifetime_hint
decl_stmt|;
name|n
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_get_message
argument_list|(
name|s
argument_list|,
name|SSL3_ST_CR_SESSION_TICKET_A
argument_list|,
name|SSL3_ST_CR_SESSION_TICKET_B
argument_list|,
name|SSL3_MT_NEWSESSION_TICKET
argument_list|,
literal|16384
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|n
operator|)
return|;
if|if
condition|(
name|n
operator|<
literal|6
condition|)
block|{
comment|/* need at least ticket_lifetime_hint + ticket length */
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_NEW_SESSION_TICKET
argument_list|,
name|SSL_R_LENGTH_MISMATCH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|p
operator|=
name|d
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_msg
expr_stmt|;
name|n2l
argument_list|(
name|p
argument_list|,
name|ticket_lifetime_hint
argument_list|)
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|ticklen
argument_list|)
expr_stmt|;
comment|/* ticket_lifetime_hint + ticket_length + ticket */
if|if
condition|(
name|ticklen
operator|+
literal|6
operator|!=
name|n
condition|)
block|{
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_NEW_SESSION_TICKET
argument_list|,
name|SSL_R_LENGTH_MISMATCH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
comment|/* Server is allowed to change its mind and send an empty ticket. */
if|if
condition|(
name|ticklen
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|session_id_length
operator|>
literal|0
condition|)
block|{
name|int
name|i
init|=
name|s
operator|->
name|session_ctx
operator|->
name|session_cache_mode
decl_stmt|;
name|SSL_SESSION
modifier|*
name|new_sess
decl_stmt|;
comment|/*          * We reused an existing session, so we need to replace it with a new          * one          */
if|if
condition|(
name|i
operator|&
name|SSL_SESS_CACHE_CLIENT
condition|)
block|{
comment|/*              * Remove the old session from the cache              */
if|if
condition|(
name|i
operator|&
name|SSL_SESS_CACHE_NO_INTERNAL_STORE
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|session_ctx
operator|->
name|remove_session_cb
operator|!=
name|NULL
condition|)
name|s
operator|->
name|session_ctx
operator|->
name|remove_session_cb
argument_list|(
name|s
operator|->
name|session_ctx
argument_list|,
name|s
operator|->
name|session
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We carry on if this fails */
name|SSL_CTX_remove_session
argument_list|(
name|s
operator|->
name|session_ctx
argument_list|,
name|s
operator|->
name|session
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|new_sess
operator|=
name|ssl_session_dup
argument_list|(
name|s
operator|->
name|session
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_NEW_SESSION_TICKET
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|SSL_SESSION_free
argument_list|(
name|s
operator|->
name|session
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|=
name|new_sess
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|tlsext_tick
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_tick
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|tlsext_ticklen
operator|=
literal|0
expr_stmt|;
block|}
name|s
operator|->
name|session
operator|->
name|tlsext_tick
operator|=
name|OPENSSL_malloc
argument_list|(
name|ticklen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|session
operator|->
name|tlsext_tick
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_NEW_SESSION_TICKET
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|memcpy
argument_list|(
name|s
operator|->
name|session
operator|->
name|tlsext_tick
argument_list|,
name|p
argument_list|,
name|ticklen
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|tlsext_tick_lifetime_hint
operator|=
name|ticket_lifetime_hint
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|tlsext_ticklen
operator|=
name|ticklen
expr_stmt|;
comment|/*      * There are two ways to detect a resumed ticket session. One is to set      * an appropriate session ID and then the server must return a match in      * ServerHello. This allows the normal client session ID matching to work      * and we know much earlier that the ticket has been accepted. The      * other way is to set zero length session ID when the ticket is      * presented and rely on the handshake to determine session resumption.      * We choose the former approach because this fits in with assumptions      * elsewhere in OpenSSL. The session ID is set to the SHA256 (or SHA1 is      * SHA256 is disabled) hash of the ticket.      */
name|EVP_Digest
argument_list|(
name|p
argument_list|,
name|ticklen
argument_list|,
name|s
operator|->
name|session
operator|->
name|session_id
argument_list|,
operator|&
name|s
operator|->
name|session
operator|->
name|session_id_length
argument_list|,
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA256
name|EVP_sha256
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|EVP_sha1
argument_list|()
operator|,
name|NULL
block|)
function|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|ret
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|ret
operator|)
return|;
end_return

begin_label
name|f_err
label|:
end_label

begin_expr_stmt
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|err
label|:
end_label

begin_expr_stmt
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
operator|-
literal|1
operator|)
return|;
end_return

begin_macro
unit|}  int
name|ssl3_get_cert_status
argument_list|(
argument|SSL *s
argument_list|)
end_macro

begin_block
block|{
name|int
name|ok
decl_stmt|,
name|al
decl_stmt|;
name|unsigned
name|long
name|resplen
decl_stmt|,
name|n
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|n
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_get_message
argument_list|(
name|s
argument_list|,
name|SSL3_ST_CR_CERT_STATUS_A
argument_list|,
name|SSL3_ST_CR_CERT_STATUS_B
argument_list|,
operator|-
literal|1
argument_list|,
literal|16384
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|n
operator|)
return|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|!=
name|SSL3_MT_CERTIFICATE_STATUS
condition|)
block|{
comment|/*          * The CertificateStatus message is optional even if          * tlsext_status_expected is set          */
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|reuse_message
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|n
operator|<
literal|4
condition|)
block|{
comment|/* need at least status type + length */
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERT_STATUS
argument_list|,
name|SSL_R_LENGTH_MISMATCH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_msg
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|TLSEXT_STATUSTYPE_ocsp
condition|)
block|{
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERT_STATUS
argument_list|,
name|SSL_R_UNSUPPORTED_STATUS_TYPE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|n2l3
argument_list|(
name|p
argument_list|,
name|resplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|resplen
operator|+
literal|4
operator|!=
name|n
condition|)
block|{
name|al
operator|=
name|SSL_AD_DECODE_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERT_STATUS
argument_list|,
name|SSL_R_LENGTH_MISMATCH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|s
operator|->
name|tlsext_ocsp_resp
operator|=
name|BUF_memdup
argument_list|(
name|p
argument_list|,
name|resplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|tlsext_ocsp_resp
operator|==
name|NULL
condition|)
block|{
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERT_STATUS
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|s
operator|->
name|tlsext_ocsp_resplen
operator|=
name|resplen
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_cb
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_cb
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|tlsext_status_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|al
operator|=
name|SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERT_STATUS
argument_list|,
name|SSL_R_INVALID_STATUS_RESPONSE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_CERT_STATUS
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
block|}
return|return
literal|1
return|;
name|f_err
label|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ssl3_get_server_done
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|ok
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|long
name|n
decl_stmt|;
comment|/* Second to last param should be very small, like 0 :-) */
name|n
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_get_message
argument_list|(
name|s
argument_list|,
name|SSL3_ST_CR_SRVR_DONE_A
argument_list|,
name|SSL3_ST_CR_SRVR_DONE_B
argument_list|,
name|SSL3_MT_SERVER_DONE
argument_list|,
literal|30
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|n
operator|)
return|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
comment|/* should contain no data */
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_DECODE_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_GET_SERVER_DONE
argument_list|,
name|SSL_R_LENGTH_MISMATCH
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_function
specifier|static
name|DH
modifier|*
name|get_server_static_dh_key
parameter_list|(
name|SESS_CERT
modifier|*
name|scert
parameter_list|)
block|{
name|DH
modifier|*
name|dh_srvr
init|=
name|NULL
decl_stmt|;
name|EVP_PKEY
modifier|*
name|spkey
init|=
name|NULL
decl_stmt|;
name|int
name|idx
init|=
name|scert
operator|->
name|peer_cert_type
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
name|spkey
operator|=
name|X509_get_pubkey
argument_list|(
name|scert
operator|->
name|peer_pkeys
index|[
name|idx
index|]
operator|.
name|x509
argument_list|)
expr_stmt|;
if|if
condition|(
name|spkey
condition|)
block|{
name|dh_srvr
operator|=
name|EVP_PKEY_get1_DH
argument_list|(
name|spkey
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|spkey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dh_srvr
operator|==
name|NULL
condition|)
name|SSLerr
argument_list|(
name|SSL_F_GET_SERVER_STATIC_DH_KEY
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
name|dh_srvr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ssl3_send_client_key_exchange
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
name|unsigned
name|long
name|alg_k
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|unsigned
name|char
modifier|*
name|q
decl_stmt|;
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_KRB5
name|KSSL_ERR
name|kssl_err
decl_stmt|;
endif|#
directive|endif
comment|/* OPENSSL_NO_KRB5 */
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDH
name|EC_KEY
modifier|*
name|clnt_ecdh
init|=
name|NULL
decl_stmt|;
specifier|const
name|EC_POINT
modifier|*
name|srvr_ecpoint
init|=
name|NULL
decl_stmt|;
name|EVP_PKEY
modifier|*
name|srvr_pub_pkey
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|encodedPoint
init|=
name|NULL
decl_stmt|;
name|int
name|encoded_pt_len
init|=
literal|0
decl_stmt|;
name|BN_CTX
modifier|*
name|bn_ctx
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL3_ST_CW_KEY_EXCH_A
condition|)
block|{
name|p
operator|=
name|ssl_handshake_start
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|alg_k
operator|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_mkey
expr_stmt|;
comment|/* Fool emacs indentation */
if|if
condition|(
literal|0
condition|)
block|{         }
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
elseif|else
if|if
condition|(
name|alg_k
operator|&
name|SSL_kRSA
condition|)
block|{
name|RSA
modifier|*
name|rsa
decl_stmt|;
name|unsigned
name|char
name|tmp_buf
index|[
name|SSL_MAX_MASTER_KEY_LENGTH
index|]
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|==
name|NULL
condition|)
block|{
comment|/*                  * We should always have a server certificate with SSL_kRSA.                  */
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_rsa_tmp
operator|!=
name|NULL
condition|)
name|rsa
operator|=
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_rsa_tmp
expr_stmt|;
else|else
block|{
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|x509
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pkey
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pkey
operator|->
name|type
operator|!=
name|EVP_PKEY_RSA
operator|)
operator|||
operator|(
name|pkey
operator|->
name|pkey
operator|.
name|rsa
operator|==
name|NULL
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|rsa
operator|=
name|pkey
operator|->
name|pkey
operator|.
name|rsa
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
block|}
name|tmp_buf
index|[
literal|0
index|]
operator|=
name|s
operator|->
name|client_version
operator|>>
literal|8
expr_stmt|;
name|tmp_buf
index|[
literal|1
index|]
operator|=
name|s
operator|->
name|client_version
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|RAND_bytes
argument_list|(
operator|&
operator|(
name|tmp_buf
index|[
literal|2
index|]
operator|)
argument_list|,
sizeof|sizeof
name|tmp_buf
operator|-
literal|2
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
name|s
operator|->
name|session
operator|->
name|master_key_length
operator|=
sizeof|sizeof
name|tmp_buf
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
comment|/* Fix buf for TLS and beyond */
if|if
condition|(
name|s
operator|->
name|version
operator|>
name|SSL3_VERSION
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
name|n
operator|=
name|RSA_public_encrypt
argument_list|(
sizeof|sizeof
name|tmp_buf
argument_list|,
name|tmp_buf
argument_list|,
name|p
argument_list|,
name|rsa
argument_list|,
name|RSA_PKCS1_PADDING
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PKCS1_CHECK
if|if
condition|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_PKCS1_CHECK_1
condition|)
name|p
index|[
literal|1
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_PKCS1_CHECK_2
condition|)
name|tmp_buf
index|[
literal|0
index|]
operator|=
literal|0x70
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|SSL_R_BAD_RSA_ENCRYPT
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Fix buf for TLS and beyond */
if|if
condition|(
name|s
operator|->
name|version
operator|>
name|SSL3_VERSION
condition|)
block|{
name|s2n
argument_list|(
name|n
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
block|}
name|s
operator|->
name|session
operator|->
name|master_key_length
operator|=
name|s
operator|->
name|method
operator|->
name|ssl3_enc
operator|->
name|generate_master_secret
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|session
operator|->
name|master_key
argument_list|,
name|tmp_buf
argument_list|,
sizeof|sizeof
name|tmp_buf
argument_list|)
expr_stmt|;
name|OPENSSL_cleanse
argument_list|(
name|tmp_buf
argument_list|,
sizeof|sizeof
name|tmp_buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_KRB5
elseif|else
if|if
condition|(
name|alg_k
operator|&
name|SSL_kKRB5
condition|)
block|{
name|krb5_error_code
name|krb5rc
decl_stmt|;
name|KSSL_CTX
modifier|*
name|kssl_ctx
init|=
name|s
operator|->
name|kssl_ctx
decl_stmt|;
comment|/*  krb5_data   krb5_ap_req;  */
name|krb5_data
modifier|*
name|enc_ticket
decl_stmt|;
name|krb5_data
name|authenticator
decl_stmt|,
modifier|*
name|authp
init|=
name|NULL
decl_stmt|;
name|EVP_CIPHER_CTX
name|ciph_ctx
decl_stmt|;
specifier|const
name|EVP_CIPHER
modifier|*
name|enc
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|iv
index|[
name|EVP_MAX_IV_LENGTH
index|]
decl_stmt|;
name|unsigned
name|char
name|tmp_buf
index|[
name|SSL_MAX_MASTER_KEY_LENGTH
index|]
decl_stmt|;
name|unsigned
name|char
name|epms
index|[
name|SSL_MAX_MASTER_KEY_LENGTH
operator|+
name|EVP_MAX_IV_LENGTH
index|]
decl_stmt|;
name|int
name|padl
decl_stmt|,
name|outl
init|=
sizeof|sizeof
argument_list|(
name|epms
argument_list|)
decl_stmt|;
name|EVP_CIPHER_CTX_init
argument_list|(
operator|&
name|ciph_ctx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KSSL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ssl3_send_client_key_exchange(%lx& %lx)\n"
argument_list|,
name|alg_k
argument_list|,
name|SSL_kKRB5
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KSSL_DEBUG */
name|authp
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|KRB5SENDAUTH
if|if
condition|(
name|KRB5SENDAUTH
condition|)
name|authp
operator|=
operator|&
name|authenticator
expr_stmt|;
endif|#
directive|endif
comment|/* KRB5SENDAUTH */
name|krb5rc
operator|=
name|kssl_cget_tkt
argument_list|(
name|kssl_ctx
argument_list|,
operator|&
name|enc_ticket
argument_list|,
name|authp
argument_list|,
operator|&
name|kssl_err
argument_list|)
expr_stmt|;
name|enc
operator|=
name|kssl_map_enc
argument_list|(
name|kssl_ctx
operator|->
name|enctype
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
ifdef|#
directive|ifdef
name|KSSL_DEBUG
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"kssl_cget_tkt rtn %d\n"
argument_list|,
name|krb5rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|krb5rc
operator|&&
name|kssl_err
operator|.
name|text
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"kssl_cget_tkt kssl_err=%s\n"
argument_list|,
name|kssl_err
operator|.
name|text
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* KSSL_DEBUG */
if|if
condition|(
name|krb5rc
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_HANDSHAKE_FAILURE
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|kssl_err
operator|.
name|reason
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/*-              * 20010406 VRS - Earlier versions used KRB5 AP_REQ              * in place of RFC 2712 KerberosWrapper, as in:              *              * Send ticket (copy to *p, set n = length)              * n = krb5_ap_req.length;              * memcpy(p, krb5_ap_req.data, krb5_ap_req.length);              * if (krb5_ap_req.data)              *   kssl_krb5_free_data_contents(NULL,&krb5_ap_req);              *              * Now using real RFC 2712 KerberosWrapper              * (Thanks to Simon Wilkinson<sxw@sxw.org.uk>)              * Note: 2712 "opaque" types are here replaced              * with a 2-byte length followed by the value.              * Example:              * KerberosWrapper= xx xx asn1ticket 0 0 xx xx encpms              * Where "xx xx" = length bytes.  Shown here with              * optional authenticator omitted.              */
comment|/*  KerberosWrapper.Ticket              */
name|s2n
argument_list|(
name|enc_ticket
operator|->
name|length
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|enc_ticket
operator|->
name|data
argument_list|,
name|enc_ticket
operator|->
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
name|enc_ticket
operator|->
name|length
expr_stmt|;
name|n
operator|=
name|enc_ticket
operator|->
name|length
operator|+
literal|2
expr_stmt|;
comment|/*  KerberosWrapper.Authenticator       */
if|if
condition|(
name|authp
operator|&&
name|authp
operator|->
name|length
condition|)
block|{
name|s2n
argument_list|(
name|authp
operator|->
name|length
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|authp
operator|->
name|data
argument_list|,
name|authp
operator|->
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
name|authp
operator|->
name|length
expr_stmt|;
name|n
operator|+=
name|authp
operator|->
name|length
operator|+
literal|2
expr_stmt|;
name|free
argument_list|(
name|authp
operator|->
name|data
argument_list|)
expr_stmt|;
name|authp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|authp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|s2n
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* null authenticator length */
name|n
operator|+=
literal|2
expr_stmt|;
block|}
name|tmp_buf
index|[
literal|0
index|]
operator|=
name|s
operator|->
name|client_version
operator|>>
literal|8
expr_stmt|;
name|tmp_buf
index|[
literal|1
index|]
operator|=
name|s
operator|->
name|client_version
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|RAND_bytes
argument_list|(
operator|&
operator|(
name|tmp_buf
index|[
literal|2
index|]
operator|)
argument_list|,
sizeof|sizeof
name|tmp_buf
operator|-
literal|2
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/*-              * 20010420 VRS.  Tried it this way; failed.              *      EVP_EncryptInit_ex(&ciph_ctx,enc, NULL,NULL);              *      EVP_CIPHER_CTX_set_key_length(&ciph_ctx,              *                              kssl_ctx->length);              *      EVP_EncryptInit_ex(&ciph_ctx,NULL, key,iv);              */
name|memset
argument_list|(
name|iv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|iv
argument_list|)
expr_stmt|;
comment|/* per RFC 1510 */
name|EVP_EncryptInit_ex
argument_list|(
operator|&
name|ciph_ctx
argument_list|,
name|enc
argument_list|,
name|NULL
argument_list|,
name|kssl_ctx
operator|->
name|key
argument_list|,
name|iv
argument_list|)
expr_stmt|;
name|EVP_EncryptUpdate
argument_list|(
operator|&
name|ciph_ctx
argument_list|,
name|epms
argument_list|,
operator|&
name|outl
argument_list|,
name|tmp_buf
argument_list|,
sizeof|sizeof
name|tmp_buf
argument_list|)
expr_stmt|;
name|EVP_EncryptFinal_ex
argument_list|(
operator|&
name|ciph_ctx
argument_list|,
operator|&
operator|(
name|epms
index|[
name|outl
index|]
operator|)
argument_list|,
operator|&
name|padl
argument_list|)
expr_stmt|;
name|outl
operator|+=
name|padl
expr_stmt|;
if|if
condition|(
name|outl
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
name|epms
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|EVP_CIPHER_CTX_cleanup
argument_list|(
operator|&
name|ciph_ctx
argument_list|)
expr_stmt|;
comment|/*  KerberosWrapper.EncryptedPreMasterSecret    */
name|s2n
argument_list|(
name|outl
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|epms
argument_list|,
name|outl
argument_list|)
expr_stmt|;
name|p
operator|+=
name|outl
expr_stmt|;
name|n
operator|+=
name|outl
operator|+
literal|2
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|master_key_length
operator|=
name|s
operator|->
name|method
operator|->
name|ssl3_enc
operator|->
name|generate_master_secret
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|session
operator|->
name|master_key
argument_list|,
name|tmp_buf
argument_list|,
sizeof|sizeof
name|tmp_buf
argument_list|)
expr_stmt|;
name|OPENSSL_cleanse
argument_list|(
name|tmp_buf
argument_list|,
sizeof|sizeof
name|tmp_buf
argument_list|)
expr_stmt|;
name|OPENSSL_cleanse
argument_list|(
name|epms
argument_list|,
name|outl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
elseif|else
if|if
condition|(
name|alg_k
operator|&
operator|(
name|SSL_kEDH
operator||
name|SSL_kDHr
operator||
name|SSL_kDHd
operator|)
condition|)
block|{
name|DH
modifier|*
name|dh_srvr
decl_stmt|,
modifier|*
name|dh_clnt
decl_stmt|;
name|SESS_CERT
modifier|*
name|scert
init|=
name|s
operator|->
name|session
operator|->
name|sess_cert
decl_stmt|;
if|if
condition|(
name|scert
operator|==
name|NULL
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|scert
operator|->
name|peer_dh_tmp
operator|!=
name|NULL
condition|)
block|{
name|dh_srvr
operator|=
name|scert
operator|->
name|peer_dh_tmp
expr_stmt|;
block|}
else|else
block|{
name|dh_srvr
operator|=
name|get_server_static_dh_key
argument_list|(
name|scert
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh_srvr
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|flags
operator|&
name|TLS1_FLAGS_SKIP_CERT_VERIFY
condition|)
block|{
comment|/* Use client certificate key */
name|EVP_PKEY
modifier|*
name|clkey
init|=
name|s
operator|->
name|cert
operator|->
name|key
operator|->
name|privatekey
decl_stmt|;
name|dh_clnt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|clkey
condition|)
name|dh_clnt
operator|=
name|EVP_PKEY_get1_DH
argument_list|(
name|clkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh_clnt
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
else|else
block|{
comment|/* generate a new random key */
if|if
condition|(
operator|(
name|dh_clnt
operator|=
name|DHparams_dup
argument_list|(
name|dh_srvr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_DH_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|DH_generate_key
argument_list|(
name|dh_clnt
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_DH_LIB
argument_list|)
expr_stmt|;
name|DH_free
argument_list|(
name|dh_clnt
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
comment|/*              * use the 'p' output buffer for the DH key, but make sure to              * clear it out afterwards              */
name|n
operator|=
name|DH_compute_key
argument_list|(
name|p
argument_list|,
name|dh_srvr
operator|->
name|pub_key
argument_list|,
name|dh_clnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|scert
operator|->
name|peer_dh_tmp
operator|==
name|NULL
condition|)
name|DH_free
argument_list|(
name|dh_srvr
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_DH_LIB
argument_list|)
expr_stmt|;
name|DH_free
argument_list|(
name|dh_clnt
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* generate master key from the result */
name|s
operator|->
name|session
operator|->
name|master_key_length
operator|=
name|s
operator|->
name|method
operator|->
name|ssl3_enc
operator|->
name|generate_master_secret
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|session
operator|->
name|master_key
argument_list|,
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* clean up */
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|flags
operator|&
name|TLS1_FLAGS_SKIP_CERT_VERIFY
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* send off the data */
name|n
operator|=
name|BN_num_bytes
argument_list|(
name|dh_clnt
operator|->
name|pub_key
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|dh_clnt
operator|->
name|pub_key
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
block|}
name|DH_free
argument_list|(
name|dh_clnt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDH
elseif|else
if|if
condition|(
name|alg_k
operator|&
operator|(
name|SSL_kEECDH
operator||
name|SSL_kECDHr
operator||
name|SSL_kECDHe
operator|)
condition|)
block|{
specifier|const
name|EC_GROUP
modifier|*
name|srvr_group
init|=
name|NULL
decl_stmt|;
name|EC_KEY
modifier|*
name|tkey
decl_stmt|;
name|int
name|ecdh_clnt_cert
init|=
literal|0
decl_stmt|;
name|int
name|field_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|==
name|NULL
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/*              * Did we send out the client's ECDH share for use in premaster              * computation as part of client certificate? If so, set              * ecdh_clnt_cert to 1.              */
if|if
condition|(
operator|(
name|alg_k
operator|&
operator|(
name|SSL_kECDHr
operator||
name|SSL_kECDHe
operator|)
operator|)
operator|&&
operator|(
name|s
operator|->
name|cert
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/*-                  * XXX: For now, we do not support client                  * authentication using ECDH certificates.                  * To add such support, one needs to add                  * code that checks for appropriate                  * conditions and sets ecdh_clnt_cert to 1.                  * For example, the cert have an ECC                  * key on the same curve as the server's                  * and the key should be authorized for                  * key agreement.                  *                  * One also needs to add code in ssl3_connect                  * to skip sending the certificate verify                  * message.                  *                  * if ((s->cert->key->privatekey != NULL)&&                  *     (s->cert->key->privatekey->type ==                  *      EVP_PKEY_EC)&& ...)                  * ecdh_clnt_cert = 1;                  */
block|}
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_ecdh_tmp
operator|!=
name|NULL
condition|)
block|{
name|tkey
operator|=
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_ecdh_tmp
expr_stmt|;
block|}
else|else
block|{
comment|/* Get the Server Public Key from Cert */
name|srvr_pub_pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_pkeys
index|[
name|SSL_PKEY_ECC
index|]
operator|.
name|x509
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|srvr_pub_pkey
operator|==
name|NULL
operator|)
operator|||
operator|(
name|srvr_pub_pkey
operator|->
name|type
operator|!=
name|EVP_PKEY_EC
operator|)
operator|||
operator|(
name|srvr_pub_pkey
operator|->
name|pkey
operator|.
name|ec
operator|==
name|NULL
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|tkey
operator|=
name|srvr_pub_pkey
operator|->
name|pkey
operator|.
name|ec
expr_stmt|;
block|}
name|srvr_group
operator|=
name|EC_KEY_get0_group
argument_list|(
name|tkey
argument_list|)
expr_stmt|;
name|srvr_ecpoint
operator|=
name|EC_KEY_get0_public_key
argument_list|(
name|tkey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|srvr_group
operator|==
name|NULL
operator|)
operator|||
operator|(
name|srvr_ecpoint
operator|==
name|NULL
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|clnt_ecdh
operator|=
name|EC_KEY_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|EC_KEY_set_group
argument_list|(
name|clnt_ecdh
argument_list|,
name|srvr_group
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_EC_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|ecdh_clnt_cert
condition|)
block|{
comment|/*                  * Reuse key info from our certificate We only need our                  * private key to perform the ECDH computation.                  */
specifier|const
name|BIGNUM
modifier|*
name|priv_key
decl_stmt|;
name|tkey
operator|=
name|s
operator|->
name|cert
operator|->
name|key
operator|->
name|privatekey
operator|->
name|pkey
operator|.
name|ec
expr_stmt|;
name|priv_key
operator|=
name|EC_KEY_get0_private_key
argument_list|(
name|tkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv_key
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|EC_KEY_set_private_key
argument_list|(
name|clnt_ecdh
argument_list|,
name|priv_key
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_EC_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
else|else
block|{
comment|/* Generate a new ECDH key pair */
if|if
condition|(
operator|!
operator|(
name|EC_KEY_generate_key
argument_list|(
name|clnt_ecdh
argument_list|)
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_ECDH_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
comment|/*              * use the 'p' output buffer for the ECDH key, but make sure to              * clear it out afterwards              */
name|field_size
operator|=
name|EC_GROUP_get_degree
argument_list|(
name|srvr_group
argument_list|)
expr_stmt|;
if|if
condition|(
name|field_size
operator|<=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_ECDH_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|n
operator|=
name|ECDH_compute_key
argument_list|(
name|p
argument_list|,
operator|(
name|field_size
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
name|srvr_ecpoint
argument_list|,
name|clnt_ecdh
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_ECDH_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* generate master key from the result */
name|s
operator|->
name|session
operator|->
name|master_key_length
operator|=
name|s
operator|->
name|method
operator|->
name|ssl3_enc
operator|->
name|generate_master_secret
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|session
operator|->
name|master_key
argument_list|,
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* clean up */
if|if
condition|(
name|ecdh_clnt_cert
condition|)
block|{
comment|/* Send empty client key exch message */
name|n
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/*                  * First check the size of encoding and allocate memory                  * accordingly.                  */
name|encoded_pt_len
operator|=
name|EC_POINT_point2oct
argument_list|(
name|srvr_group
argument_list|,
name|EC_KEY_get0_public_key
argument_list|(
name|clnt_ecdh
argument_list|)
argument_list|,
name|POINT_CONVERSION_UNCOMPRESSED
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|encodedPoint
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
name|encoded_pt_len
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
name|bn_ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|encodedPoint
operator|==
name|NULL
operator|)
operator|||
operator|(
name|bn_ctx
operator|==
name|NULL
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Encode the public key */
name|n
operator|=
name|EC_POINT_point2oct
argument_list|(
name|srvr_group
argument_list|,
name|EC_KEY_get0_public_key
argument_list|(
name|clnt_ecdh
argument_list|)
argument_list|,
name|POINT_CONVERSION_UNCOMPRESSED
argument_list|,
name|encodedPoint
argument_list|,
name|encoded_pt_len
argument_list|,
name|bn_ctx
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|n
expr_stmt|;
comment|/* length of encoded point */
comment|/* Encoded point will be copied here */
name|p
operator|+=
literal|1
expr_stmt|;
comment|/* copy the point */
name|memcpy
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
argument_list|,
name|encodedPoint
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* increment n to account for length field */
name|n
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Free allocated memory */
name|BN_CTX_free
argument_list|(
name|bn_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|encodedPoint
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|encodedPoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|clnt_ecdh
operator|!=
name|NULL
condition|)
name|EC_KEY_free
argument_list|(
name|clnt_ecdh
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|srvr_pub_pkey
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !OPENSSL_NO_ECDH */
elseif|else
if|if
condition|(
name|alg_k
operator|&
name|SSL_kGOST
condition|)
block|{
comment|/* GOST key exchange message creation */
name|EVP_PKEY_CTX
modifier|*
name|pkey_ctx
decl_stmt|;
name|X509
modifier|*
name|peer_cert
decl_stmt|;
name|size_t
name|msglen
decl_stmt|;
name|unsigned
name|int
name|md_len
decl_stmt|;
name|int
name|keytype
decl_stmt|;
name|unsigned
name|char
name|premaster_secret
index|[
literal|32
index|]
decl_stmt|,
name|shared_ukm
index|[
literal|32
index|]
decl_stmt|,
name|tmp
index|[
literal|256
index|]
decl_stmt|;
name|EVP_MD_CTX
modifier|*
name|ukm_hash
decl_stmt|;
name|EVP_PKEY
modifier|*
name|pub_key
decl_stmt|;
comment|/*              * Get server sertificate PKEY and create ctx from it              */
name|peer_cert
operator|=
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_pkeys
index|[
operator|(
name|keytype
operator|=
name|SSL_PKEY_GOST01
operator|)
index|]
operator|.
name|x509
expr_stmt|;
if|if
condition|(
operator|!
name|peer_cert
condition|)
name|peer_cert
operator|=
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_pkeys
index|[
operator|(
name|keytype
operator|=
name|SSL_PKEY_GOST94
operator|)
index|]
operator|.
name|x509
expr_stmt|;
if|if
condition|(
operator|!
name|peer_cert
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|pkey_ctx
operator|=
name|EVP_PKEY_CTX_new
argument_list|(
name|pub_key
operator|=
name|X509_get_pubkey
argument_list|(
name|peer_cert
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_ctx
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/*              * If we have send a certificate, and certificate key              *              * * parameters match those of server certificate, use              * certificate key for key exchange              */
comment|/* Otherwise, generate ephemeral key pair */
if|if
condition|(
name|pkey_ctx
operator|==
name|NULL
operator|||
name|EVP_PKEY_encrypt_init
argument_list|(
name|pkey_ctx
argument_list|)
operator|<=
literal|0
comment|/* Generate session key */
operator|||
name|RAND_bytes
argument_list|(
name|premaster_secret
argument_list|,
literal|32
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|EVP_PKEY_CTX_free
argument_list|(
name|pkey_ctx
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/*              * Compute shared IV and store it in algorithm-specific context              * data              */
name|ukm_hash
operator|=
name|EVP_MD_CTX_create
argument_list|()
expr_stmt|;
if|if
condition|(
name|EVP_DigestInit
argument_list|(
name|ukm_hash
argument_list|,
name|EVP_get_digestbynid
argument_list|(
name|NID_id_GostR3411_94
argument_list|)
argument_list|)
operator|<=
literal|0
operator|||
name|EVP_DigestUpdate
argument_list|(
name|ukm_hash
argument_list|,
name|s
operator|->
name|s3
operator|->
name|client_random
argument_list|,
name|SSL3_RANDOM_SIZE
argument_list|)
operator|<=
literal|0
operator|||
name|EVP_DigestUpdate
argument_list|(
name|ukm_hash
argument_list|,
name|s
operator|->
name|s3
operator|->
name|server_random
argument_list|,
name|SSL3_RANDOM_SIZE
argument_list|)
operator|<=
literal|0
operator|||
name|EVP_DigestFinal_ex
argument_list|(
name|ukm_hash
argument_list|,
name|shared_ukm
argument_list|,
operator|&
name|md_len
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|EVP_MD_CTX_destroy
argument_list|(
name|ukm_hash
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|EVP_MD_CTX_destroy
argument_list|(
name|ukm_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_PKEY_CTX_ctrl
argument_list|(
name|pkey_ctx
argument_list|,
operator|-
literal|1
argument_list|,
name|EVP_PKEY_OP_ENCRYPT
argument_list|,
name|EVP_PKEY_CTRL_SET_IV
argument_list|,
literal|8
argument_list|,
name|shared_ukm
argument_list|)
operator|<
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|SSL_R_LIBRARY_BUG
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Make GOST keytransport blob message */
comment|/*              * Encapsulate it into sequence              */
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|V_ASN1_SEQUENCE
operator||
name|V_ASN1_CONSTRUCTED
expr_stmt|;
name|msglen
operator|=
literal|255
expr_stmt|;
if|if
condition|(
name|EVP_PKEY_encrypt
argument_list|(
name|pkey_ctx
argument_list|,
name|tmp
argument_list|,
operator|&
name|msglen
argument_list|,
name|premaster_secret
argument_list|,
literal|32
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|SSL_R_LIBRARY_BUG
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|msglen
operator|>=
literal|0x80
condition|)
block|{
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|0x81
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|msglen
operator|&
literal|0xff
expr_stmt|;
name|n
operator|=
name|msglen
operator|+
literal|3
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|msglen
operator|&
literal|0xff
expr_stmt|;
name|n
operator|=
name|msglen
operator|+
literal|2
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|tmp
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|EVP_PKEY_CTX_free
argument_list|(
name|pkey_ctx
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|master_key_length
operator|=
name|s
operator|->
name|method
operator|->
name|ssl3_enc
operator|->
name|generate_master_secret
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|session
operator|->
name|master_key
argument_list|,
name|premaster_secret
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|pub_key
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRP
elseif|else
if|if
condition|(
name|alg_k
operator|&
name|SSL_kSRP
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|srp_ctx
operator|.
name|A
operator|!=
name|NULL
condition|)
block|{
comment|/* send off the data */
name|n
operator|=
name|BN_num_bytes
argument_list|(
name|s
operator|->
name|srp_ctx
operator|.
name|A
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|s
operator|->
name|srp_ctx
operator|.
name|A
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|srp_username
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|srp_username
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|srp_username
operator|=
name|BUF_strdup
argument_list|(
name|s
operator|->
name|srp_ctx
operator|.
name|login
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|srp_username
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|session
operator|->
name|master_key_length
operator|=
name|SRP_generate_client_master_secret
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|session
operator|->
name|master_key
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_PSK
elseif|else
if|if
condition|(
name|alg_k
operator|&
name|SSL_kPSK
condition|)
block|{
comment|/*              * The callback needs PSK_MAX_IDENTITY_LEN + 1 bytes to return a              * \0-terminated identity. The last byte is for us for simulating              * strnlen.              */
name|char
name|identity
index|[
name|PSK_MAX_IDENTITY_LEN
operator|+
literal|2
index|]
decl_stmt|;
name|size_t
name|identity_len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|psk_or_pre_ms
index|[
name|PSK_MAX_PSK_LEN
operator|*
literal|2
operator|+
literal|4
index|]
decl_stmt|;
name|unsigned
name|int
name|pre_ms_len
init|=
literal|0
decl_stmt|,
name|psk_len
init|=
literal|0
decl_stmt|;
name|int
name|psk_err
init|=
literal|1
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|psk_client_callback
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|SSL_R_PSK_NO_CLIENT_CB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|memset
argument_list|(
name|identity
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|identity
argument_list|)
argument_list|)
expr_stmt|;
name|psk_len
operator|=
name|s
operator|->
name|psk_client_callback
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|session
operator|->
name|psk_identity_hint
argument_list|,
name|identity
argument_list|,
sizeof|sizeof
argument_list|(
name|identity
argument_list|)
operator|-
literal|1
argument_list|,
name|psk_or_pre_ms
argument_list|,
sizeof|sizeof
argument_list|(
name|psk_or_pre_ms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|psk_len
operator|>
name|PSK_MAX_PSK_LEN
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|psk_err
goto|;
block|}
elseif|else
if|if
condition|(
name|psk_len
operator|==
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|SSL_R_PSK_IDENTITY_NOT_FOUND
argument_list|)
expr_stmt|;
goto|goto
name|psk_err
goto|;
block|}
name|identity
index|[
name|PSK_MAX_IDENTITY_LEN
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|identity_len
operator|=
name|strlen
argument_list|(
name|identity
argument_list|)
expr_stmt|;
if|if
condition|(
name|identity_len
operator|>
name|PSK_MAX_IDENTITY_LEN
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|psk_err
goto|;
block|}
comment|/* create PSK pre_master_secret */
name|pre_ms_len
operator|=
literal|2
operator|+
name|psk_len
operator|+
literal|2
operator|+
name|psk_len
expr_stmt|;
name|t
operator|=
name|psk_or_pre_ms
expr_stmt|;
name|memmove
argument_list|(
name|psk_or_pre_ms
operator|+
name|psk_len
operator|+
literal|4
argument_list|,
name|psk_or_pre_ms
argument_list|,
name|psk_len
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|psk_len
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|psk_len
argument_list|)
expr_stmt|;
name|t
operator|+=
name|psk_len
expr_stmt|;
name|s2n
argument_list|(
name|psk_len
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|psk_identity_hint
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|psk_identity_hint
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|psk_identity_hint
operator|=
name|BUF_strdup
argument_list|(
name|s
operator|->
name|ctx
operator|->
name|psk_identity_hint
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|psk_identity_hint
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|session
operator|->
name|psk_identity_hint
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|psk_err
goto|;
block|}
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|psk_identity
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|psk_identity
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|psk_identity
operator|=
name|BUF_strdup
argument_list|(
name|identity
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|psk_identity
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|psk_err
goto|;
block|}
name|s
operator|->
name|session
operator|->
name|master_key_length
operator|=
name|s
operator|->
name|method
operator|->
name|ssl3_enc
operator|->
name|generate_master_secret
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|session
operator|->
name|master_key
argument_list|,
name|psk_or_pre_ms
argument_list|,
name|pre_ms_len
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|identity_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
name|n
operator|=
literal|2
operator|+
name|identity_len
expr_stmt|;
name|psk_err
operator|=
literal|0
expr_stmt|;
name|psk_err
label|:
name|OPENSSL_cleanse
argument_list|(
name|identity
argument_list|,
sizeof|sizeof
argument_list|(
name|identity
argument_list|)
argument_list|)
expr_stmt|;
name|OPENSSL_cleanse
argument_list|(
name|psk_or_pre_ms
argument_list|,
sizeof|sizeof
argument_list|(
name|psk_or_pre_ms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|psk_err
operator|!=
literal|0
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_HANDSHAKE_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
endif|#
directive|endif
else|else
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_HANDSHAKE_FAILURE
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ssl_set_handshake_header
argument_list|(
name|s
argument_list|,
name|SSL3_MT_CLIENT_KEY_EXCHANGE
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_KEY_EXCH_B
expr_stmt|;
block|}
comment|/* SSL3_ST_CW_KEY_EXCH_B */
return|return
name|ssl_do_write
argument_list|(
name|s
argument_list|)
return|;
name|err
label|:
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDH
name|BN_CTX_free
argument_list|(
name|bn_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|encodedPoint
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|encodedPoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|clnt_ecdh
operator|!=
name|NULL
condition|)
name|EC_KEY_free
argument_list|(
name|clnt_ecdh
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|srvr_pub_pkey
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ssl3_send_client_verify
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|data
index|[
name|MD5_DIGEST_LENGTH
operator|+
name|SHA_DIGEST_LENGTH
index|]
decl_stmt|;
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
name|EVP_PKEY_CTX
modifier|*
name|pctx
init|=
name|NULL
decl_stmt|;
name|EVP_MD_CTX
name|mctx
decl_stmt|;
name|unsigned
name|u
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|n
decl_stmt|;
name|int
name|j
decl_stmt|;
name|EVP_MD_CTX_init
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL3_ST_CW_CERT_VRFY_A
condition|)
block|{
name|p
operator|=
name|ssl_handshake_start
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|s
operator|->
name|cert
operator|->
name|key
operator|->
name|privatekey
expr_stmt|;
comment|/* Create context from key and test if sha1 is allowed as digest */
name|pctx
operator|=
name|EVP_PKEY_CTX_new
argument_list|(
name|pkey
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|==
name|NULL
operator|||
name|EVP_PKEY_sign_init
argument_list|(
name|pctx
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_VERIFY
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|EVP_PKEY_CTX_set_signature_md
argument_list|(
name|pctx
argument_list|,
name|EVP_sha1
argument_list|()
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|SSL_USE_SIGALGS
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|->
name|method
operator|->
name|ssl3_enc
operator|->
name|cert_verify_mac
argument_list|(
name|s
argument_list|,
name|NID_sha1
argument_list|,
operator|&
operator|(
name|data
index|[
name|MD5_DIGEST_LENGTH
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ERR_clear_error
argument_list|()
expr_stmt|;
block|}
comment|/*          * For TLS v1.2 send signature algorithm and signature using agreed          * digest and cached handshake records.          */
if|if
condition|(
name|SSL_USE_SIGALGS
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|long
name|hdatalen
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|hdata
decl_stmt|;
specifier|const
name|EVP_MD
modifier|*
name|md
init|=
name|s
operator|->
name|cert
operator|->
name|key
operator|->
name|digest
decl_stmt|;
name|hdatalen
operator|=
name|BIO_get_mem_data
argument_list|(
name|s
operator|->
name|s3
operator|->
name|handshake_buffer
argument_list|,
operator|&
name|hdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdatalen
operator|<=
literal|0
operator|||
operator|!
name|tls12_get_sigandhash
argument_list|(
name|p
argument_list|,
name|pkey
argument_list|,
name|md
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_VERIFY
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|SSL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using TLS 1.2 with client alg %s\n"
argument_list|,
name|EVP_MD_name
argument_list|(
name|md
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|EVP_SignInit_ex
argument_list|(
operator|&
name|mctx
argument_list|,
name|md
argument_list|,
name|NULL
argument_list|)
operator|||
operator|!
name|EVP_SignUpdate
argument_list|(
operator|&
name|mctx
argument_list|,
name|hdata
argument_list|,
name|hdatalen
argument_list|)
operator|||
operator|!
name|EVP_SignFinal
argument_list|(
operator|&
name|mctx
argument_list|,
name|p
operator|+
literal|2
argument_list|,
operator|&
name|u
argument_list|,
name|pkey
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_VERIFY
argument_list|,
name|ERR_R_EVP_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|s2n
argument_list|(
name|u
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|u
operator|+
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|ssl3_digest_cached_records
argument_list|(
name|s
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
elseif|else
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|pkey
operator|->
name|type
operator|==
name|EVP_PKEY_RSA
condition|)
block|{
name|s
operator|->
name|method
operator|->
name|ssl3_enc
operator|->
name|cert_verify_mac
argument_list|(
name|s
argument_list|,
name|NID_md5
argument_list|,
operator|&
operator|(
name|data
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RSA_sign
argument_list|(
name|NID_md5_sha1
argument_list|,
name|data
argument_list|,
name|MD5_DIGEST_LENGTH
operator|+
name|SHA_DIGEST_LENGTH
argument_list|,
operator|&
operator|(
name|p
index|[
literal|2
index|]
operator|)
argument_list|,
operator|&
name|u
argument_list|,
name|pkey
operator|->
name|pkey
operator|.
name|rsa
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_VERIFY
argument_list|,
name|ERR_R_RSA_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|s2n
argument_list|(
name|u
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|u
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
if|if
condition|(
name|pkey
operator|->
name|type
operator|==
name|EVP_PKEY_DSA
condition|)
block|{
if|if
condition|(
operator|!
name|DSA_sign
argument_list|(
name|pkey
operator|->
name|save_type
argument_list|,
operator|&
operator|(
name|data
index|[
name|MD5_DIGEST_LENGTH
index|]
operator|)
argument_list|,
name|SHA_DIGEST_LENGTH
argument_list|,
operator|&
operator|(
name|p
index|[
literal|2
index|]
operator|)
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|j
argument_list|,
name|pkey
operator|->
name|pkey
operator|.
name|dsa
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_VERIFY
argument_list|,
name|ERR_R_DSA_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|s2n
argument_list|(
name|j
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|j
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDSA
if|if
condition|(
name|pkey
operator|->
name|type
operator|==
name|EVP_PKEY_EC
condition|)
block|{
if|if
condition|(
operator|!
name|ECDSA_sign
argument_list|(
name|pkey
operator|->
name|save_type
argument_list|,
operator|&
operator|(
name|data
index|[
name|MD5_DIGEST_LENGTH
index|]
operator|)
argument_list|,
name|SHA_DIGEST_LENGTH
argument_list|,
operator|&
operator|(
name|p
index|[
literal|2
index|]
operator|)
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|j
argument_list|,
name|pkey
operator|->
name|pkey
operator|.
name|ec
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_VERIFY
argument_list|,
name|ERR_R_ECDSA_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|s2n
argument_list|(
name|j
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|j
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|pkey
operator|->
name|type
operator|==
name|NID_id_GostR3410_94
operator|||
name|pkey
operator|->
name|type
operator|==
name|NID_id_GostR3410_2001
condition|)
block|{
name|unsigned
name|char
name|signbuf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|sigsize
init|=
literal|64
decl_stmt|;
name|s
operator|->
name|method
operator|->
name|ssl3_enc
operator|->
name|cert_verify_mac
argument_list|(
name|s
argument_list|,
name|NID_id_GostR3411_94
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_PKEY_sign
argument_list|(
name|pctx
argument_list|,
name|signbuf
argument_list|,
operator|&
name|sigsize
argument_list|,
name|data
argument_list|,
literal|32
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_VERIFY
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|63
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|>=
literal|0
condition|;
name|j
operator|++
operator|,
name|i
operator|--
control|)
block|{
name|p
index|[
literal|2
operator|+
name|j
index|]
operator|=
name|signbuf
index|[
name|i
index|]
expr_stmt|;
block|}
name|s2n
argument_list|(
name|j
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|j
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_VERIFY
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ssl_set_handshake_header
argument_list|(
name|s
argument_list|,
name|SSL3_MT_CERTIFICATE_VERIFY
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_CERT_VRFY_B
expr_stmt|;
block|}
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
name|EVP_PKEY_CTX_free
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
return|return
name|ssl_do_write
argument_list|(
name|s
argument_list|)
return|;
name|err
label|:
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
name|EVP_PKEY_CTX_free
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check a certificate can be used for client authentication. Currently check  * cert exists, if we have a suitable digest for TLS 1.2 if static DH client  * certificates can be used and optionally checks suitability for Suite B.  */
end_comment

begin_function
specifier|static
name|int
name|ssl3_check_client_certificate
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|long
name|alg_k
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|cert
operator|||
operator|!
name|s
operator|->
name|cert
operator|->
name|key
operator|->
name|x509
operator|||
operator|!
name|s
operator|->
name|cert
operator|->
name|key
operator|->
name|privatekey
condition|)
return|return
literal|0
return|;
comment|/* If no suitable signature algorithm can't use certificate */
if|if
condition|(
name|SSL_USE_SIGALGS
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|s
operator|->
name|cert
operator|->
name|key
operator|->
name|digest
condition|)
return|return
literal|0
return|;
comment|/*      * If strict mode check suitability of chain before using it. This also      * adjusts suite B digest if necessary.      */
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|cert_flags
operator|&
name|SSL_CERT_FLAGS_CHECK_TLS_STRICT
operator|&&
operator|!
name|tls1_check_chain
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|-
literal|2
argument_list|)
condition|)
return|return
literal|0
return|;
name|alg_k
operator|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_mkey
expr_stmt|;
comment|/* See if we can use client certificate for fixed DH */
if|if
condition|(
name|alg_k
operator|&
operator|(
name|SSL_kDHr
operator||
name|SSL_kDHd
operator|)
condition|)
block|{
name|SESS_CERT
modifier|*
name|scert
init|=
name|s
operator|->
name|session
operator|->
name|sess_cert
decl_stmt|;
name|int
name|i
init|=
name|scert
operator|->
name|peer_cert_type
decl_stmt|;
name|EVP_PKEY
modifier|*
name|clkey
init|=
name|NULL
decl_stmt|,
modifier|*
name|spkey
init|=
name|NULL
decl_stmt|;
name|clkey
operator|=
name|s
operator|->
name|cert
operator|->
name|key
operator|->
name|privatekey
expr_stmt|;
comment|/* If client key not DH assume it can be used */
if|if
condition|(
name|EVP_PKEY_id
argument_list|(
name|clkey
argument_list|)
operator|!=
name|EVP_PKEY_DH
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|spkey
operator|=
name|X509_get_pubkey
argument_list|(
name|scert
operator|->
name|peer_pkeys
index|[
name|i
index|]
operator|.
name|x509
argument_list|)
expr_stmt|;
if|if
condition|(
name|spkey
condition|)
block|{
comment|/* Compare server and client parameters */
name|i
operator|=
name|EVP_PKEY_cmp_parameters
argument_list|(
name|clkey
argument_list|,
name|spkey
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|spkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
block|}
name|s
operator|->
name|s3
operator|->
name|flags
operator||=
name|TLS1_FLAGS_SKIP_CERT_VERIFY
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ssl3_send_client_certificate
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|X509
modifier|*
name|x509
init|=
name|NULL
decl_stmt|;
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL3_ST_CW_CERT_A
condition|)
block|{
comment|/* Let cert callback update client certificates if required */
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|cert_cb
condition|)
block|{
name|i
operator|=
name|s
operator|->
name|cert
operator|->
name|cert_cb
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|cert
operator|->
name|cert_cb_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|s
operator|->
name|rwstate
operator|=
name|SSL_X509_LOOKUP
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_INTERNAL_ERROR
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|->
name|rwstate
operator|=
name|SSL_NOTHING
expr_stmt|;
block|}
if|if
condition|(
name|ssl3_check_client_certificate
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_CERT_C
expr_stmt|;
else|else
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_CERT_B
expr_stmt|;
block|}
comment|/* We need to get a client cert */
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL3_ST_CW_CERT_B
condition|)
block|{
comment|/*          * If we get an error, we need to ssl->rwstate=SSL_X509_LOOKUP;          * return(-1); We then get retied later          */
name|i
operator|=
name|ssl_do_client_cert_cb
argument_list|(
name|s
argument_list|,
operator|&
name|x509
argument_list|,
operator|&
name|pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|s
operator|->
name|rwstate
operator|=
name|SSL_X509_LOOKUP
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|s
operator|->
name|rwstate
operator|=
name|SSL_NOTHING
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|1
operator|)
operator|&&
operator|(
name|pkey
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|x509
operator|!=
name|NULL
operator|)
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_CERT_B
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_use_certificate
argument_list|(
name|s
argument_list|,
name|x509
argument_list|)
operator|||
operator|!
name|SSL_use_PrivateKey
argument_list|(
name|s
argument_list|,
name|pkey
argument_list|)
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_CERTIFICATE
argument_list|,
name|SSL_R_BAD_DATA_RETURNED_BY_CALLBACK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x509
operator|!=
name|NULL
condition|)
name|X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey
operator|!=
name|NULL
condition|)
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
operator|!
name|ssl3_check_client_certificate
argument_list|(
name|s
argument_list|)
condition|)
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|version
operator|==
name|SSL3_VERSION
condition|)
block|{
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|cert_req
operator|=
literal|0
expr_stmt|;
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_WARNING
argument_list|,
name|SSL_AD_NO_CERTIFICATE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|cert_req
operator|=
literal|2
expr_stmt|;
block|}
block|}
comment|/* Ok, we have a cert */
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_CERT_C
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL3_ST_CW_CERT_C
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_CERT_D
expr_stmt|;
if|if
condition|(
operator|!
name|ssl3_output_cert_chain
argument_list|(
name|s
argument_list|,
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|cert_req
operator|==
literal|2
operator|)
condition|?
name|NULL
else|:
name|s
operator|->
name|cert
operator|->
name|key
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_SEND_CLIENT_CERTIFICATE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_INTERNAL_ERROR
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_ERR
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* SSL3_ST_CW_CERT_D */
return|return
name|ssl_do_write
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|has_bits
parameter_list|(
name|i
parameter_list|,
name|m
parameter_list|)
value|(((i)&(m)) == (m))
end_define

begin_function
name|int
name|ssl3_check_cert_and_algorithm
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|;
name|long
name|alg_k
decl_stmt|,
name|alg_a
decl_stmt|;
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
name|int
name|pkey_bits
decl_stmt|;
name|SESS_CERT
modifier|*
name|sc
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|RSA
modifier|*
name|rsa
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
name|DH
modifier|*
name|dh
decl_stmt|;
endif|#
directive|endif
name|int
name|al
init|=
name|SSL_AD_HANDSHAKE_FAILURE
decl_stmt|;
name|alg_k
operator|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_mkey
expr_stmt|;
name|alg_a
operator|=
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
operator|->
name|algorithm_auth
expr_stmt|;
comment|/* we don't have a certificate */
if|if
condition|(
operator|(
name|alg_a
operator|&
operator|(
name|SSL_aNULL
operator||
name|SSL_aKRB5
operator|)
operator|)
operator|||
operator|(
name|alg_k
operator|&
name|SSL_kPSK
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sc
operator|=
name|s
operator|->
name|session
operator|->
name|sess_cert
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|rsa
operator|=
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_rsa_tmp
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
name|dh
operator|=
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|->
name|peer_dh_tmp
expr_stmt|;
endif|#
directive|endif
comment|/* This is the passed certificate */
name|idx
operator|=
name|sc
operator|->
name|peer_cert_type
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDH
if|if
condition|(
name|idx
operator|==
name|SSL_PKEY_ECC
condition|)
block|{
if|if
condition|(
name|ssl_check_srvr_ecc_cert_and_alg
argument_list|(
name|sc
operator|->
name|peer_pkeys
index|[
name|idx
index|]
operator|.
name|x509
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* check failed */
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|SSL_R_BAD_ECC_CERT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
else|else
block|{
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|alg_a
operator|&
name|SSL_aECDSA
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|SSL_R_MISSING_ECDSA_SIGNING_CERT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
elseif|else
if|if
condition|(
name|alg_k
operator|&
operator|(
name|SSL_kECDHr
operator||
name|SSL_kECDHe
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|SSL_R_MISSING_ECDH_CERT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
endif|#
directive|endif
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|sc
operator|->
name|peer_pkeys
index|[
name|idx
index|]
operator|.
name|x509
argument_list|)
expr_stmt|;
name|pkey_bits
operator|=
name|EVP_PKEY_bits
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|i
operator|=
name|X509_certificate_type
argument_list|(
name|sc
operator|->
name|peer_pkeys
index|[
name|idx
index|]
operator|.
name|x509
argument_list|,
name|pkey
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
comment|/* Check that we have a certificate if we require one */
if|if
condition|(
operator|(
name|alg_a
operator|&
name|SSL_aRSA
operator|)
operator|&&
operator|!
name|has_bits
argument_list|(
name|i
argument_list|,
name|EVP_PK_RSA
operator||
name|EVP_PKT_SIGN
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|SSL_R_MISSING_RSA_SIGNING_CERT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
elseif|else
if|if
condition|(
operator|(
name|alg_a
operator|&
name|SSL_aDSS
operator|)
operator|&&
operator|!
name|has_bits
argument_list|(
name|i
argument_list|,
name|EVP_PK_DSA
operator||
name|EVP_PKT_SIGN
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|SSL_R_MISSING_DSA_SIGNING_CERT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|alg_k
operator|&
name|SSL_kRSA
condition|)
block|{
if|if
condition|(
operator|!
name|SSL_C_IS_EXPORT
argument_list|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
argument_list|)
operator|&&
operator|!
name|has_bits
argument_list|(
name|i
argument_list|,
name|EVP_PK_RSA
operator||
name|EVP_PKT_ENC
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|SSL_R_MISSING_RSA_ENCRYPTING_CERT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
elseif|else
if|if
condition|(
name|SSL_C_IS_EXPORT
argument_list|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
argument_list|)
condition|)
block|{
if|if
condition|(
name|pkey_bits
operator|<=
name|SSL_C_EXPORT_PKEYLENGTH
argument_list|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|has_bits
argument_list|(
name|i
argument_list|,
name|EVP_PK_RSA
operator||
name|EVP_PKT_ENC
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|SSL_R_MISSING_RSA_ENCRYPTING_CERT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
if|if
condition|(
name|rsa
operator|!=
name|NULL
condition|)
block|{
comment|/* server key exchange is not allowed. */
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
if|if
condition|(
operator|(
name|alg_k
operator|&
name|SSL_kEDH
operator|)
operator|&&
name|dh
operator|==
name|NULL
condition|)
block|{
name|al
operator|=
name|SSL_AD_INTERNAL_ERROR
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
if|if
condition|(
operator|(
name|alg_k
operator|&
name|SSL_kDHr
operator|)
operator|&&
operator|!
name|SSL_USE_SIGALGS
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|has_bits
argument_list|(
name|i
argument_list|,
name|EVP_PK_DH
operator||
name|EVP_PKS_RSA
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|SSL_R_MISSING_DH_RSA_CERT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
if|if
condition|(
operator|(
name|alg_k
operator|&
name|SSL_kDHd
operator|)
operator|&&
operator|!
name|SSL_USE_SIGALGS
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|has_bits
argument_list|(
name|i
argument_list|,
name|EVP_PK_DH
operator||
name|EVP_PKS_DSA
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|SSL_R_MISSING_DH_DSA_CERT
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|alg_k
operator|&
operator|(
name|SSL_kDHE
operator||
name|SSL_kDHr
operator||
name|SSL_kDHd
operator|)
condition|)
block|{
name|int
name|dh_size
decl_stmt|;
if|if
condition|(
name|alg_k
operator|&
name|SSL_kDHE
condition|)
block|{
name|dh_size
operator|=
name|BN_num_bits
argument_list|(
name|dh
operator|->
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DH
modifier|*
name|dh_srvr
init|=
name|get_server_static_dh_key
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|if
condition|(
name|dh_srvr
operator|==
name|NULL
condition|)
goto|goto
name|f_err
goto|;
name|dh_size
operator|=
name|BN_num_bits
argument_list|(
name|dh_srvr
operator|->
name|p
argument_list|)
expr_stmt|;
name|DH_free
argument_list|(
name|dh_srvr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|SSL_C_IS_EXPORT
argument_list|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
argument_list|)
operator|&&
name|dh_size
operator|<
literal|1024
operator|)
operator|||
operator|(
name|SSL_C_IS_EXPORT
argument_list|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
argument_list|)
operator|&&
name|dh_size
operator|<
literal|512
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|SSL_R_DH_KEY_TOO_SMALL
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* !OPENSSL_NO_DH */
if|if
condition|(
name|SSL_C_IS_EXPORT
argument_list|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
argument_list|)
operator|&&
name|pkey_bits
operator|>
name|SSL_C_EXPORT_PKEYLENGTH
argument_list|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|alg_k
operator|&
name|SSL_kRSA
condition|)
block|{
if|if
condition|(
name|rsa
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|SSL_R_MISSING_EXPORT_TMP_RSA_KEY
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
elseif|else
if|if
condition|(
name|BN_num_bits
argument_list|(
name|rsa
operator|->
name|n
argument_list|)
operator|>
name|SSL_C_EXPORT_PKEYLENGTH
argument_list|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
argument_list|)
condition|)
block|{
comment|/* We have a temporary RSA key but it's too large. */
name|al
operator|=
name|SSL_AD_EXPORT_RESTRICTION
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|SSL_R_MISSING_EXPORT_TMP_RSA_KEY
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
block|}
elseif|else
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
if|if
condition|(
name|alg_k
operator|&
name|SSL_kDHE
condition|)
block|{
if|if
condition|(
name|BN_num_bits
argument_list|(
name|dh
operator|->
name|p
argument_list|)
operator|>
name|SSL_C_EXPORT_PKEYLENGTH
argument_list|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|new_cipher
argument_list|)
condition|)
block|{
comment|/* We have a temporary DH key but it's too large. */
name|al
operator|=
name|SSL_AD_EXPORT_RESTRICTION
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|SSL_R_MISSING_EXPORT_TMP_DH_KEY
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|alg_k
operator|&
operator|(
name|SSL_kDHr
operator||
name|SSL_kDHd
operator|)
condition|)
block|{
comment|/* The cert should have had an export DH key. */
name|al
operator|=
name|SSL_AD_EXPORT_RESTRICTION
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|SSL_R_MISSING_EXPORT_TMP_DH_KEY
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
else|else
endif|#
directive|endif
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM
argument_list|,
name|SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|f_err
label|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|err
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
end_ifndef

begin_comment
comment|/*  * Normally, we can tell if the server is resuming the session from  * the session ID. EAP-FAST (RFC 4851), however, relies on the next server  * message after the ServerHello to determine if the server is resuming.  * Therefore, we allow EAP-FAST to peek ahead.  * ssl3_check_finished returns 1 if we are resuming from an external  * pre-shared secret, we have a "ticket" and the next server handshake message  * is Finished; and 0 otherwise. It returns -1 upon an error.  */
end_comment

begin_function
specifier|static
name|int
name|ssl3_check_finished
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|version
operator|<
name|TLS1_VERSION
operator|||
operator|!
name|s
operator|->
name|tls_session_secret_cb
operator|||
operator|!
name|s
operator|->
name|session
operator|->
name|tlsext_tick
condition|)
return|return
literal|0
return|;
comment|/* Need to permit this temporarily, in case the next message is Finished. */
name|s
operator|->
name|s3
operator|->
name|flags
operator||=
name|SSL3_FLAGS_CCS_OK
expr_stmt|;
comment|/*      * This function is called when we might get a Certificate message instead,      * so permit appropriate message length.      * We ignore the return value as we're only interested in the message type      * and not its length.      */
name|s
operator|->
name|method
operator|->
name|ssl_get_message
argument_list|(
name|s
argument_list|,
name|SSL3_ST_CR_CERT_A
argument_list|,
name|SSL3_ST_CR_CERT_B
argument_list|,
operator|-
literal|1
argument_list|,
name|s
operator|->
name|max_cert_list
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|flags
operator|&=
operator|~
name|SSL3_FLAGS_CCS_OK
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
operator|-
literal|1
return|;
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|reuse_message
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|==
name|SSL3_MT_FINISHED
condition|)
return|return
literal|1
return|;
comment|/* If we're not done, then the CCS arrived early and we should bail. */
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|change_cipher_spec
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL3_CHECK_FINISHED
argument_list|,
name|SSL_R_CCS_RECEIVED_EARLY
argument_list|)
expr_stmt|;
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|SSL_AD_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_NEXTPROTONEG
end_ifndef

begin_function
name|int
name|ssl3_send_next_proto
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|int
name|len
decl_stmt|,
name|padding_len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL3_ST_CW_NEXT_PROTO_A
condition|)
block|{
name|len
operator|=
name|s
operator|->
name|next_proto_negotiated_len
expr_stmt|;
name|padding_len
operator|=
literal|32
operator|-
operator|(
operator|(
name|len
operator|+
literal|2
operator|)
operator|%
literal|32
operator|)
expr_stmt|;
name|d
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
name|d
index|[
literal|4
index|]
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|+
literal|5
argument_list|,
name|s
operator|->
name|next_proto_negotiated
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|d
index|[
literal|5
operator|+
name|len
index|]
operator|=
name|padding_len
expr_stmt|;
name|memset
argument_list|(
name|d
operator|+
literal|6
operator|+
name|len
argument_list|,
literal|0
argument_list|,
name|padding_len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|d
operator|++
operator|)
operator|=
name|SSL3_MT_NEXT_PROTO
expr_stmt|;
name|l2n3
argument_list|(
literal|2
operator|+
name|len
operator|+
name|padding_len
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL3_ST_CW_NEXT_PROTO_B
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|4
operator|+
literal|2
operator|+
name|len
operator|+
name|padding_len
expr_stmt|;
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ssl3_do_write
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_NEXTPROTONEG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_TLSEXT */
end_comment

begin_function
name|int
name|ssl_do_client_cert_cb
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|X509
modifier|*
modifier|*
name|px509
parameter_list|,
name|EVP_PKEY
modifier|*
modifier|*
name|ppkey
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_ENGINE
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|client_cert_engine
condition|)
block|{
name|i
operator|=
name|ENGINE_load_ssl_client_cert
argument_list|(
name|s
operator|->
name|ctx
operator|->
name|client_cert_engine
argument_list|,
name|s
argument_list|,
name|SSL_get_client_CA_list
argument_list|(
name|s
argument_list|)
argument_list|,
name|px509
argument_list|,
name|ppkey
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|i
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|client_cert_cb
condition|)
name|i
operator|=
name|s
operator|->
name|ctx
operator|->
name|client_cert_cb
argument_list|(
name|s
argument_list|,
name|px509
argument_list|,
name|ppkey
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

end_unit

