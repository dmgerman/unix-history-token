begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ssl/ssl_sess.c */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *  * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *  * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from  *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright 2005 Nokia. All rights reserved.  *  * The portions of the attached software ("Contribution") is developed by  * Nokia Corporation and is licensed pursuant to the OpenSSL open source  * license.  *  * The Contribution, originally written by Mika Kousa and Pasi Eronen of  * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites  * support (see RFC 4279) to OpenSSL.  *  * No patent licenses or other rights except those expressly stated in  * the OpenSSL open source license shall be deemed granted or received  * expressly, by implication, estoppel, or otherwise.  *  * No assurances are provided by Nokia that the Contribution does not  * infringe the patent or other intellectual property rights of any third  * party or that the license provides you with all the necessary rights  * to make use of the Contribution.  *  * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN  * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA  * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY  * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR  * OTHERWISE.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/lhash.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_ENGINE
end_ifndef

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ssl_locl.h"
end_include

begin_function_decl
specifier|static
name|void
name|SSL_SESSION_list_remove
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|SSL_SESSION
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SSL_SESSION_list_add
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|SSL_SESSION
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|remove_session_lock
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|SSL_SESSION
modifier|*
name|c
parameter_list|,
name|int
name|lck
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|SSL_SESSION
modifier|*
name|SSL_get_session
parameter_list|(
specifier|const
name|SSL
modifier|*
name|ssl
parameter_list|)
comment|/* aka SSL_get0_session; gets 0 objects, just returns a copy of the pointer */
block|{
return|return
operator|(
name|ssl
operator|->
name|session
operator|)
return|;
block|}
end_function

begin_function
name|SSL_SESSION
modifier|*
name|SSL_get1_session
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|)
comment|/* variant of SSL_get_session: caller really gets something */
block|{
name|SSL_SESSION
modifier|*
name|sess
decl_stmt|;
comment|/*      * Need to lock this all up rather than just use CRYPTO_add so that      * somebody doesn't free ssl->session between when we check it's non-null      * and when we up the reference count.      */
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_SSL_SESSION
argument_list|)
expr_stmt|;
name|sess
operator|=
name|ssl
operator|->
name|session
expr_stmt|;
if|if
condition|(
name|sess
condition|)
name|sess
operator|->
name|references
operator|++
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_SSL_SESSION
argument_list|)
expr_stmt|;
return|return
operator|(
name|sess
operator|)
return|;
block|}
end_function

begin_function
name|int
name|SSL_SESSION_get_ex_new_index
parameter_list|(
name|long
name|argl
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|,
name|CRYPTO_EX_new
modifier|*
name|new_func
parameter_list|,
name|CRYPTO_EX_dup
modifier|*
name|dup_func
parameter_list|,
name|CRYPTO_EX_free
modifier|*
name|free_func
parameter_list|)
block|{
return|return
name|CRYPTO_get_ex_new_index
argument_list|(
name|CRYPTO_EX_INDEX_SSL_SESSION
argument_list|,
name|argl
argument_list|,
name|argp
argument_list|,
name|new_func
argument_list|,
name|dup_func
argument_list|,
name|free_func
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|SSL_SESSION_set_ex_data
parameter_list|(
name|SSL_SESSION
modifier|*
name|s
parameter_list|,
name|int
name|idx
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|CRYPTO_set_ex_data
argument_list|(
operator|&
name|s
operator|->
name|ex_data
argument_list|,
name|idx
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|SSL_SESSION_get_ex_data
parameter_list|(
specifier|const
name|SSL_SESSION
modifier|*
name|s
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
return|return
operator|(
name|CRYPTO_get_ex_data
argument_list|(
operator|&
name|s
operator|->
name|ex_data
argument_list|,
name|idx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|SSL_SESSION
modifier|*
name|SSL_SESSION_new
parameter_list|(
name|void
parameter_list|)
block|{
name|SSL_SESSION
modifier|*
name|ss
decl_stmt|;
name|ss
operator|=
operator|(
name|SSL_SESSION
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SSL_SESSION
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_SESSION_NEW
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
name|ss
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SSL_SESSION
argument_list|)
argument_list|)
expr_stmt|;
name|ss
operator|->
name|verify_result
operator|=
literal|1
expr_stmt|;
comment|/* avoid 0 (= X509_V_OK) just in case */
name|ss
operator|->
name|references
operator|=
literal|1
expr_stmt|;
name|ss
operator|->
name|timeout
operator|=
literal|60
operator|*
literal|5
operator|+
literal|4
expr_stmt|;
comment|/* 5 minute timeout by default */
name|ss
operator|->
name|time
operator|=
operator|(
name|unsigned
name|long
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ss
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|ss
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ss
operator|->
name|compress_meth
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
name|ss
operator|->
name|tlsext_hostname
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
name|ss
operator|->
name|tlsext_ecpointformatlist_length
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|tlsext_ecpointformatlist
operator|=
name|NULL
expr_stmt|;
name|ss
operator|->
name|tlsext_ellipticcurvelist_length
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|tlsext_ellipticcurvelist
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|CRYPTO_new_ex_data
argument_list|(
name|CRYPTO_EX_INDEX_SSL_SESSION
argument_list|,
name|ss
argument_list|,
operator|&
name|ss
operator|->
name|ex_data
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_PSK
name|ss
operator|->
name|psk_identity_hint
operator|=
name|NULL
expr_stmt|;
name|ss
operator|->
name|psk_identity
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRP
name|ss
operator|->
name|srp_username
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ss
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new SSL_SESSION and duplicate the contents of |src| into it. If  * ticket == 0 then no ticket information is duplicated, otherwise it is.  */
end_comment

begin_function
name|SSL_SESSION
modifier|*
name|ssl_session_dup
parameter_list|(
name|SSL_SESSION
modifier|*
name|src
parameter_list|,
name|int
name|ticket
parameter_list|)
block|{
name|SSL_SESSION
modifier|*
name|dest
decl_stmt|;
name|dest
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
block|{
goto|goto
name|err
goto|;
block|}
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Set the various pointers to NULL so that we can call SSL_SESSION_free in      * the case of an error whilst halfway through constructing dest      */
ifndef|#
directive|ifndef
name|OPENSSL_NO_PSK
name|dest
operator|->
name|psk_identity_hint
operator|=
name|NULL
expr_stmt|;
name|dest
operator|->
name|psk_identity
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|dest
operator|->
name|ciphers
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
name|dest
operator|->
name|tlsext_hostname
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
name|dest
operator|->
name|tlsext_ecpointformatlist
operator|=
name|NULL
expr_stmt|;
name|dest
operator|->
name|tlsext_ellipticcurvelist
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|dest
operator|->
name|tlsext_tick
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRP
name|dest
operator|->
name|srp_username
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|dest
operator|->
name|ex_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dest
operator|->
name|ex_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We deliberately don't copy the prev and next pointers */
name|dest
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|dest
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|dest
operator|->
name|references
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|sess_cert
operator|!=
name|NULL
condition|)
name|CRYPTO_add
argument_list|(
operator|&
name|src
operator|->
name|sess_cert
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_SSL_SESS_CERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|peer
operator|!=
name|NULL
condition|)
name|CRYPTO_add
argument_list|(
operator|&
name|src
operator|->
name|peer
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_X509
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_PSK
if|if
condition|(
name|src
operator|->
name|psk_identity_hint
condition|)
block|{
name|dest
operator|->
name|psk_identity_hint
operator|=
name|BUF_strdup
argument_list|(
name|src
operator|->
name|psk_identity_hint
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|psk_identity_hint
operator|==
name|NULL
condition|)
block|{
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|src
operator|->
name|psk_identity
condition|)
block|{
name|dest
operator|->
name|psk_identity
operator|=
name|BUF_strdup
argument_list|(
name|src
operator|->
name|psk_identity
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|psk_identity
operator|==
name|NULL
condition|)
block|{
goto|goto
name|err
goto|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|src
operator|->
name|ciphers
operator|!=
name|NULL
condition|)
block|{
name|dest
operator|->
name|ciphers
operator|=
name|sk_SSL_CIPHER_dup
argument_list|(
name|src
operator|->
name|ciphers
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|ciphers
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|CRYPTO_dup_ex_data
argument_list|(
name|CRYPTO_EX_INDEX_SSL_SESSION
argument_list|,
operator|&
name|dest
operator|->
name|ex_data
argument_list|,
operator|&
name|src
operator|->
name|ex_data
argument_list|)
condition|)
block|{
goto|goto
name|err
goto|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
if|if
condition|(
name|src
operator|->
name|tlsext_hostname
condition|)
block|{
name|dest
operator|->
name|tlsext_hostname
operator|=
name|BUF_strdup
argument_list|(
name|src
operator|->
name|tlsext_hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|tlsext_hostname
operator|==
name|NULL
condition|)
block|{
goto|goto
name|err
goto|;
block|}
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
if|if
condition|(
name|src
operator|->
name|tlsext_ecpointformatlist
condition|)
block|{
name|dest
operator|->
name|tlsext_ecpointformatlist
operator|=
name|BUF_memdup
argument_list|(
name|src
operator|->
name|tlsext_ecpointformatlist
argument_list|,
name|src
operator|->
name|tlsext_ecpointformatlist_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|tlsext_ecpointformatlist
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|src
operator|->
name|tlsext_ellipticcurvelist
condition|)
block|{
name|dest
operator|->
name|tlsext_ellipticcurvelist
operator|=
name|BUF_memdup
argument_list|(
name|src
operator|->
name|tlsext_ellipticcurvelist
argument_list|,
name|src
operator|->
name|tlsext_ellipticcurvelist_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|tlsext_ellipticcurvelist
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ticket
operator|!=
literal|0
condition|)
block|{
name|dest
operator|->
name|tlsext_tick
operator|=
name|BUF_memdup
argument_list|(
name|src
operator|->
name|tlsext_tick
argument_list|,
name|src
operator|->
name|tlsext_ticklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|tlsext_tick
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|dest
operator|->
name|tlsext_tick_lifetime_hint
operator|=
literal|0
expr_stmt|;
name|dest
operator|->
name|tlsext_ticklen
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRP
if|if
condition|(
name|src
operator|->
name|srp_username
condition|)
block|{
name|dest
operator|->
name|srp_username
operator|=
name|BUF_strdup
argument_list|(
name|src
operator|->
name|srp_username
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|srp_username
operator|==
name|NULL
condition|)
block|{
goto|goto
name|err
goto|;
block|}
block|}
endif|#
directive|endif
return|return
name|dest
return|;
name|err
label|:
name|SSLerr
argument_list|(
name|SSL_F_SSL_SESSION_DUP
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
name|SSL_SESSION_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|unsigned
name|char
modifier|*
name|SSL_SESSION_get_id
parameter_list|(
specifier|const
name|SSL_SESSION
modifier|*
name|s
parameter_list|,
name|unsigned
name|int
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
condition|)
operator|*
name|len
operator|=
name|s
operator|->
name|session_id_length
expr_stmt|;
return|return
name|s
operator|->
name|session_id
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|SSL_SESSION_get_compress_id
parameter_list|(
specifier|const
name|SSL_SESSION
modifier|*
name|s
parameter_list|)
block|{
return|return
name|s
operator|->
name|compress_meth
return|;
block|}
end_function

begin_comment
comment|/*  * Even with SSLv2, we have 16 bytes (128 bits) of session ID space.  * SSLv3/TLSv1 has 32 bytes (256 bits). As such, filling the ID with random  * gunk repeatedly until we have no conflict is going to complete in one  * iteration pretty much "most" of the time (btw: understatement). So, if it  * takes us 10 iterations and we still can't avoid a conflict - well that's a  * reasonable point to call it quits. Either the RAND code is broken or  * someone is trying to open roughly very close to 2^128 (or 2^256) SSL  * sessions to our server. How you might store that many sessions is perhaps  * a more interesting question ...  */
end_comment

begin_define
define|#
directive|define
name|MAX_SESS_ID_ATTEMPTS
value|10
end_define

begin_function
specifier|static
name|int
name|def_generate_session_id
parameter_list|(
specifier|const
name|SSL
modifier|*
name|ssl
parameter_list|,
name|unsigned
name|char
modifier|*
name|id
parameter_list|,
name|unsigned
name|int
modifier|*
name|id_len
parameter_list|)
block|{
name|unsigned
name|int
name|retry
init|=
literal|0
decl_stmt|;
do|do
if|if
condition|(
name|RAND_pseudo_bytes
argument_list|(
name|id
argument_list|,
operator|*
name|id_len
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
do|while
condition|(
name|SSL_has_matching_session_id
argument_list|(
name|ssl
argument_list|,
name|id
argument_list|,
operator|*
name|id_len
argument_list|)
operator|&&
operator|(
operator|++
name|retry
operator|<
name|MAX_SESS_ID_ATTEMPTS
operator|)
condition|)
do|;
if|if
condition|(
name|retry
operator|<
name|MAX_SESS_ID_ATTEMPTS
condition|)
return|return
literal|1
return|;
comment|/* else - woops a session_id match */
comment|/*      * XXX We should also check the external cache -- but the probability of      * a collision is negligible, and we could not prevent the concurrent      * creation of sessions with identical IDs since we currently don't have      * means to atomically check whether a session ID already exists and make      * a reservation for it if it does not (this problem applies to the      * internal cache as well).      */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ssl_get_new_session
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|session
parameter_list|)
block|{
comment|/* This gets used by clients and servers. */
name|unsigned
name|int
name|tmp
decl_stmt|;
name|SSL_SESSION
modifier|*
name|ss
init|=
name|NULL
decl_stmt|;
name|GEN_SESSION_CB
name|cb
init|=
name|def_generate_session_id
decl_stmt|;
if|if
condition|(
operator|(
name|ss
operator|=
name|SSL_SESSION_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If the context has a default timeout, use it */
if|if
condition|(
name|s
operator|->
name|session_ctx
operator|->
name|session_timeout
operator|==
literal|0
condition|)
name|ss
operator|->
name|timeout
operator|=
name|SSL_get_default_timeout
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|ss
operator|->
name|timeout
operator|=
name|s
operator|->
name|session_ctx
operator|->
name|session_timeout
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|!=
name|NULL
condition|)
block|{
name|SSL_SESSION_free
argument_list|(
name|s
operator|->
name|session
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|session
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|version
operator|==
name|SSL2_VERSION
condition|)
block|{
name|ss
operator|->
name|ssl_version
operator|=
name|SSL2_VERSION
expr_stmt|;
name|ss
operator|->
name|session_id_length
operator|=
name|SSL2_SSL_SESSION_ID_LENGTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|version
operator|==
name|SSL3_VERSION
condition|)
block|{
name|ss
operator|->
name|ssl_version
operator|=
name|SSL3_VERSION
expr_stmt|;
name|ss
operator|->
name|session_id_length
operator|=
name|SSL3_SSL_SESSION_ID_LENGTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|version
operator|==
name|TLS1_VERSION
condition|)
block|{
name|ss
operator|->
name|ssl_version
operator|=
name|TLS1_VERSION
expr_stmt|;
name|ss
operator|->
name|session_id_length
operator|=
name|SSL3_SSL_SESSION_ID_LENGTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|version
operator|==
name|TLS1_1_VERSION
condition|)
block|{
name|ss
operator|->
name|ssl_version
operator|=
name|TLS1_1_VERSION
expr_stmt|;
name|ss
operator|->
name|session_id_length
operator|=
name|SSL3_SSL_SESSION_ID_LENGTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|version
operator|==
name|TLS1_2_VERSION
condition|)
block|{
name|ss
operator|->
name|ssl_version
operator|=
name|TLS1_2_VERSION
expr_stmt|;
name|ss
operator|->
name|session_id_length
operator|=
name|SSL3_SSL_SESSION_ID_LENGTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|version
operator|==
name|DTLS1_BAD_VER
condition|)
block|{
name|ss
operator|->
name|ssl_version
operator|=
name|DTLS1_BAD_VER
expr_stmt|;
name|ss
operator|->
name|session_id_length
operator|=
name|SSL3_SSL_SESSION_ID_LENGTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|version
operator|==
name|DTLS1_VERSION
condition|)
block|{
name|ss
operator|->
name|ssl_version
operator|=
name|DTLS1_VERSION
expr_stmt|;
name|ss
operator|->
name|session_id_length
operator|=
name|SSL3_SSL_SESSION_ID_LENGTH
expr_stmt|;
block|}
else|else
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_GET_NEW_SESSION
argument_list|,
name|SSL_R_UNSUPPORTED_SSL_VERSION
argument_list|)
expr_stmt|;
name|SSL_SESSION_free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
comment|/*-          * If RFC5077 ticket, use empty session ID (as server).          * Note that:          * (a) ssl_get_prev_session() does lookahead into the          *     ClientHello extensions to find the session ticket.          *     When ssl_get_prev_session() fails, s3_srvr.c calls          *     ssl_get_new_session() in ssl3_get_client_hello().          *     At that point, it has not yet parsed the extensions,          *     however, because of the lookahead, it already knows          *     whether a ticket is expected or not.          *          * (b) s3_clnt.c calls ssl_get_new_session() before parsing          *     ServerHello extensions, and before recording the session          *     ID received from the server, so this block is a noop.          */
if|if
condition|(
name|s
operator|->
name|tlsext_ticket_expected
condition|)
block|{
name|ss
operator|->
name|session_id_length
operator|=
literal|0
expr_stmt|;
goto|goto
name|sess_id_done
goto|;
block|}
endif|#
directive|endif
comment|/* Choose which callback will set the session ID */
name|CRYPTO_r_lock
argument_list|(
name|CRYPTO_LOCK_SSL_CTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|generate_session_id
condition|)
name|cb
operator|=
name|s
operator|->
name|generate_session_id
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|session_ctx
operator|->
name|generate_session_id
condition|)
name|cb
operator|=
name|s
operator|->
name|session_ctx
operator|->
name|generate_session_id
expr_stmt|;
name|CRYPTO_r_unlock
argument_list|(
name|CRYPTO_LOCK_SSL_CTX
argument_list|)
expr_stmt|;
comment|/* Choose a session ID */
name|tmp
operator|=
name|ss
operator|->
name|session_id_length
expr_stmt|;
if|if
condition|(
operator|!
name|cb
argument_list|(
name|s
argument_list|,
name|ss
operator|->
name|session_id
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
block|{
comment|/* The callback failed */
name|SSLerr
argument_list|(
name|SSL_F_SSL_GET_NEW_SESSION
argument_list|,
name|SSL_R_SSL_SESSION_ID_CALLBACK_FAILED
argument_list|)
expr_stmt|;
name|SSL_SESSION_free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*          * Don't allow the callback to set the session length to zero. nor          * set it higher than it was.          */
if|if
condition|(
operator|!
name|tmp
operator|||
operator|(
name|tmp
operator|>
name|ss
operator|->
name|session_id_length
operator|)
condition|)
block|{
comment|/* The callback set an illegal length */
name|SSLerr
argument_list|(
name|SSL_F_SSL_GET_NEW_SESSION
argument_list|,
name|SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH
argument_list|)
expr_stmt|;
name|SSL_SESSION_free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* If the session length was shrunk and we're SSLv2, pad it */
if|if
condition|(
operator|(
name|tmp
operator|<
name|ss
operator|->
name|session_id_length
operator|)
operator|&&
operator|(
name|s
operator|->
name|version
operator|==
name|SSL2_VERSION
operator|)
condition|)
name|memset
argument_list|(
name|ss
operator|->
name|session_id
operator|+
name|tmp
argument_list|,
literal|0
argument_list|,
name|ss
operator|->
name|session_id_length
operator|-
name|tmp
argument_list|)
expr_stmt|;
else|else
name|ss
operator|->
name|session_id_length
operator|=
name|tmp
expr_stmt|;
comment|/* Finally, check for a conflict */
if|if
condition|(
name|SSL_has_matching_session_id
argument_list|(
name|s
argument_list|,
name|ss
operator|->
name|session_id
argument_list|,
name|ss
operator|->
name|session_id_length
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_GET_NEW_SESSION
argument_list|,
name|SSL_R_SSL_SESSION_ID_CONFLICT
argument_list|)
expr_stmt|;
name|SSL_SESSION_free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
name|sess_id_done
label|:
if|if
condition|(
name|s
operator|->
name|tlsext_hostname
condition|)
block|{
name|ss
operator|->
name|tlsext_hostname
operator|=
name|BUF_strdup
argument_list|(
name|s
operator|->
name|tlsext_hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|tlsext_hostname
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_GET_NEW_SESSION
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
name|SSL_SESSION_free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
if|if
condition|(
name|s
operator|->
name|tlsext_ecpointformatlist
condition|)
block|{
if|if
condition|(
name|ss
operator|->
name|tlsext_ecpointformatlist
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|ss
operator|->
name|tlsext_ecpointformatlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ss
operator|->
name|tlsext_ecpointformatlist
operator|=
name|OPENSSL_malloc
argument_list|(
name|s
operator|->
name|tlsext_ecpointformatlist_length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_GET_NEW_SESSION
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
name|SSL_SESSION_free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ss
operator|->
name|tlsext_ecpointformatlist_length
operator|=
name|s
operator|->
name|tlsext_ecpointformatlist_length
expr_stmt|;
name|memcpy
argument_list|(
name|ss
operator|->
name|tlsext_ecpointformatlist
argument_list|,
name|s
operator|->
name|tlsext_ecpointformatlist
argument_list|,
name|s
operator|->
name|tlsext_ecpointformatlist_length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|tlsext_ellipticcurvelist
condition|)
block|{
if|if
condition|(
name|ss
operator|->
name|tlsext_ellipticcurvelist
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|ss
operator|->
name|tlsext_ellipticcurvelist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ss
operator|->
name|tlsext_ellipticcurvelist
operator|=
name|OPENSSL_malloc
argument_list|(
name|s
operator|->
name|tlsext_ellipticcurvelist_length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_GET_NEW_SESSION
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
name|SSL_SESSION_free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ss
operator|->
name|tlsext_ellipticcurvelist_length
operator|=
name|s
operator|->
name|tlsext_ellipticcurvelist_length
expr_stmt|;
name|memcpy
argument_list|(
name|ss
operator|->
name|tlsext_ellipticcurvelist
argument_list|,
name|s
operator|->
name|tlsext_ellipticcurvelist
argument_list|,
name|s
operator|->
name|tlsext_ellipticcurvelist_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
block|}
else|else
block|{
name|ss
operator|->
name|session_id_length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|sid_ctx_length
operator|>
sizeof|sizeof
name|ss
operator|->
name|sid_ctx
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_GET_NEW_SESSION
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
name|SSL_SESSION_free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|ss
operator|->
name|sid_ctx
argument_list|,
name|s
operator|->
name|sid_ctx
argument_list|,
name|s
operator|->
name|sid_ctx_length
argument_list|)
expr_stmt|;
name|ss
operator|->
name|sid_ctx_length
operator|=
name|s
operator|->
name|sid_ctx_length
expr_stmt|;
name|s
operator|->
name|session
operator|=
name|ss
expr_stmt|;
name|ss
operator|->
name|ssl_version
operator|=
name|s
operator|->
name|version
expr_stmt|;
name|ss
operator|->
name|verify_result
operator|=
name|X509_V_OK
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * ssl_get_prev attempts to find an SSL_SESSION to be used to resume this  * connection. It is only called by servers.  *  *   session_id: points at the session ID in the ClientHello. This code will  *       read past the end of this in order to parse out the session ticket  *       extension, if any.  *   len: the length of the session ID.  *   limit: a pointer to the first byte after the ClientHello.  *  * Returns:  *   -1: error  *    0: a session may have been found.  *  * Side effects:  *   - If a session is found then s->session is pointed at it (after freeing an  *     existing session if need be) and s->verify_result is set from the session.  *   - Both for new and resumed sessions, s->tlsext_ticket_expected is set to 1  *     if the server should issue a new session ticket (to 0 otherwise).  */
end_comment

begin_function
name|int
name|ssl_get_prev_session
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|session_id
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|limit
parameter_list|)
block|{
comment|/* This is used only by servers. */
name|SSL_SESSION
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|int
name|fatal
init|=
literal|0
decl_stmt|;
name|int
name|try_session_cache
init|=
literal|1
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
name|int
name|r
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|session_id
operator|+
name|len
operator|>
name|limit
condition|)
block|{
name|fatal
operator|=
literal|1
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|try_session_cache
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
comment|/* sets s->tlsext_ticket_expected */
name|r
operator|=
name|tls1_process_ticket
argument_list|(
name|s
argument_list|,
name|session_id
argument_list|,
name|len
argument_list|,
name|limit
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* Error during processing */
name|fatal
operator|=
literal|1
expr_stmt|;
goto|goto
name|err
goto|;
case|case
literal|0
case|:
comment|/* No ticket found */
case|case
literal|1
case|:
comment|/* Zero length ticket found */
break|break;
comment|/* Ok to carry on processing session id. */
case|case
literal|2
case|:
comment|/* Ticket found but not decrypted. */
case|case
literal|3
case|:
comment|/* Ticket decrypted, *ret has been set. */
name|try_session_cache
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|try_session_cache
operator|&&
name|ret
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|s
operator|->
name|session_ctx
operator|->
name|session_cache_mode
operator|&
name|SSL_SESS_CACHE_NO_INTERNAL_LOOKUP
operator|)
condition|)
block|{
name|SSL_SESSION
name|data
decl_stmt|;
name|data
operator|.
name|ssl_version
operator|=
name|s
operator|->
name|version
expr_stmt|;
name|data
operator|.
name|session_id_length
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|data
operator|.
name|session_id
argument_list|,
name|session_id
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|CRYPTO_r_lock
argument_list|(
name|CRYPTO_LOCK_SSL_CTX
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lh_SSL_SESSION_retrieve
argument_list|(
name|s
operator|->
name|session_ctx
operator|->
name|sessions
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
comment|/* don't allow other threads to steal it: */
name|CRYPTO_add
argument_list|(
operator|&
name|ret
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_SSL_SESSION
argument_list|)
expr_stmt|;
block|}
name|CRYPTO_r_unlock
argument_list|(
name|CRYPTO_LOCK_SSL_CTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|s
operator|->
name|session_ctx
operator|->
name|stats
operator|.
name|sess_miss
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|try_session_cache
operator|&&
name|ret
operator|==
name|NULL
operator|&&
name|s
operator|->
name|session_ctx
operator|->
name|get_session_cb
operator|!=
name|NULL
condition|)
block|{
name|int
name|copy
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|s
operator|->
name|session_ctx
operator|->
name|get_session_cb
argument_list|(
name|s
argument_list|,
name|session_id
argument_list|,
name|len
argument_list|,
operator|&
name|copy
argument_list|)
operator|)
condition|)
block|{
name|s
operator|->
name|session_ctx
operator|->
name|stats
operator|.
name|sess_cb_hit
operator|++
expr_stmt|;
comment|/*              * Increment reference count now if the session callback asks us              * to do so (note that if the session structures returned by the              * callback are shared between threads, it must handle the              * reference count itself [i.e. copy == 0], or things won't be              * thread-safe).              */
if|if
condition|(
name|copy
condition|)
name|CRYPTO_add
argument_list|(
operator|&
name|ret
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_SSL_SESSION
argument_list|)
expr_stmt|;
comment|/*              * Add the externally cached session to the internal cache as              * well if and only if we are supposed to.              */
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|session_ctx
operator|->
name|session_cache_mode
operator|&
name|SSL_SESS_CACHE_NO_INTERNAL_STORE
operator|)
condition|)
comment|/*                  * The following should not return 1, otherwise, things are                  * very strange                  */
name|SSL_CTX_add_session
argument_list|(
name|s
operator|->
name|session_ctx
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* Now ret is non-NULL and we own one of its reference counts. */
if|if
condition|(
name|ret
operator|->
name|sid_ctx_length
operator|!=
name|s
operator|->
name|sid_ctx_length
operator|||
name|memcmp
argument_list|(
name|ret
operator|->
name|sid_ctx
argument_list|,
name|s
operator|->
name|sid_ctx
argument_list|,
name|ret
operator|->
name|sid_ctx_length
argument_list|)
condition|)
block|{
comment|/*          * We have the session requested by the client, but we don't want to          * use it in this context.          */
goto|goto
name|err
goto|;
comment|/* treat like cache miss */
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|verify_mode
operator|&
name|SSL_VERIFY_PEER
operator|)
operator|&&
name|s
operator|->
name|sid_ctx_length
operator|==
literal|0
condition|)
block|{
comment|/*          * We can't be sure if this session is being used out of context,          * which is especially important for SSL_VERIFY_PEER. The application          * should have used SSL[_CTX]_set_session_id_context. For this error          * case, we generate an error instead of treating the event like a          * cache miss (otherwise it would be easy for applications to          * effectively disable the session cache by accident without anyone          * noticing).          */
name|SSLerr
argument_list|(
name|SSL_F_SSL_GET_PREV_SESSION
argument_list|,
name|SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED
argument_list|)
expr_stmt|;
name|fatal
operator|=
literal|1
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|ret
operator|->
name|cipher
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|l
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|l
operator|=
name|ret
operator|->
name|cipher_id
expr_stmt|;
name|l2n
argument_list|(
name|l
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|->
name|ssl_version
operator|>>
literal|8
operator|)
operator|>=
name|SSL3_VERSION_MAJOR
condition|)
name|ret
operator|->
name|cipher
operator|=
name|ssl_get_cipher_by_char
argument_list|(
name|s
argument_list|,
operator|&
operator|(
name|buf
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
else|else
name|ret
operator|->
name|cipher
operator|=
name|ssl_get_cipher_by_char
argument_list|(
name|s
argument_list|,
operator|&
operator|(
name|buf
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|cipher
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|ret
operator|->
name|timeout
operator|<
call|(
name|long
call|)
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|ret
operator|->
name|time
argument_list|)
condition|)
block|{
comment|/* timeout */
name|s
operator|->
name|session_ctx
operator|->
name|stats
operator|.
name|sess_timeout
operator|++
expr_stmt|;
if|if
condition|(
name|try_session_cache
condition|)
block|{
comment|/* session was from the cache, so remove it */
name|SSL_CTX_remove_session
argument_list|(
name|s
operator|->
name|session_ctx
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
goto|goto
name|err
goto|;
block|}
name|s
operator|->
name|session_ctx
operator|->
name|stats
operator|.
name|sess_hit
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|!=
name|NULL
condition|)
name|SSL_SESSION_free
argument_list|(
name|s
operator|->
name|session
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|=
name|ret
expr_stmt|;
name|s
operator|->
name|verify_result
operator|=
name|s
operator|->
name|session
operator|->
name|verify_result
expr_stmt|;
return|return
literal|1
return|;
name|err
label|:
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
name|SSL_SESSION_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
if|if
condition|(
operator|!
name|try_session_cache
condition|)
block|{
comment|/*              * The session was from a ticket, so we should issue a ticket for              * the new session              */
name|s
operator|->
name|tlsext_ticket_expected
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|fatal
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|SSL_CTX_add_session
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|SSL_SESSION
modifier|*
name|c
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|SSL_SESSION
modifier|*
name|s
decl_stmt|;
comment|/*      * add just 1 reference count for the SSL_CTX's session cache even though      * it has two ways of access: each session is in a doubly linked list and      * an lhash      */
name|CRYPTO_add
argument_list|(
operator|&
name|c
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_SSL_SESSION
argument_list|)
expr_stmt|;
comment|/*      * if session c is in already in cache, we take back the increment later      */
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_SSL_CTX
argument_list|)
expr_stmt|;
name|s
operator|=
name|lh_SSL_SESSION_insert
argument_list|(
name|ctx
operator|->
name|sessions
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/*      * s != NULL iff we already had a session with the given PID. In this      * case, s == c should hold (then we did not really modify      * ctx->sessions), or we're in trouble.      */
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|!=
name|c
condition|)
block|{
comment|/* We *are* in trouble ... */
name|SSL_SESSION_list_remove
argument_list|(
name|ctx
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|SSL_SESSION_free
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*          * ... so pretend the other session did not exist in cache (we cannot          * handle two SSL_SESSION structures with identical session ID in the          * same cache, which could happen e.g. when two threads concurrently          * obtain the same session from an external cache)          */
name|s
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Put at the head of the queue unless it is already in the cache */
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|SSL_SESSION_list_add
argument_list|(
name|ctx
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
comment|/*          * existing cache entry -- decrement previously incremented reference          * count because it already takes into account the cache          */
name|SSL_SESSION_free
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* s == c */
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/*          * new cache entry -- remove old ones if cache has become too large          */
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SSL_CTX_sess_get_cache_size
argument_list|(
name|ctx
argument_list|)
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|SSL_CTX_sess_number
argument_list|(
name|ctx
argument_list|)
operator|>
name|SSL_CTX_sess_get_cache_size
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|remove_session_lock
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|session_cache_tail
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
else|else
name|ctx
operator|->
name|stats
operator|.
name|sess_cache_full
operator|++
expr_stmt|;
block|}
block|}
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_SSL_CTX
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|SSL_CTX_remove_session
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|SSL_SESSION
modifier|*
name|c
parameter_list|)
block|{
return|return
name|remove_session_lock
argument_list|(
name|ctx
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_session_lock
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|SSL_SESSION
modifier|*
name|c
parameter_list|,
name|int
name|lck
parameter_list|)
block|{
name|SSL_SESSION
modifier|*
name|r
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|c
operator|->
name|session_id_length
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|lck
condition|)
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_SSL_CTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|lh_SSL_SESSION_retrieve
argument_list|(
name|ctx
operator|->
name|sessions
argument_list|,
name|c
argument_list|)
operator|)
operator|==
name|c
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
name|r
operator|=
name|lh_SSL_SESSION_delete
argument_list|(
name|ctx
operator|->
name|sessions
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|SSL_SESSION_list_remove
argument_list|(
name|ctx
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lck
condition|)
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_SSL_CTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|r
operator|->
name|not_resumable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|remove_session_cb
operator|!=
name|NULL
condition|)
name|ctx
operator|->
name|remove_session_cb
argument_list|(
name|ctx
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|SSL_SESSION_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ret
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|SSL_SESSION_free
parameter_list|(
name|SSL_SESSION
modifier|*
name|ss
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
condition|)
return|return;
name|i
operator|=
name|CRYPTO_add
argument_list|(
operator|&
name|ss
operator|->
name|references
argument_list|,
operator|-
literal|1
argument_list|,
name|CRYPTO_LOCK_SSL_SESSION
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REF_PRINT
name|REF_PRINT
argument_list|(
literal|"SSL_SESSION"
argument_list|,
name|ss
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|REF_CHECK
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SSL_SESSION_free, bad reference count\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* ok */
block|}
endif|#
directive|endif
name|CRYPTO_free_ex_data
argument_list|(
name|CRYPTO_EX_INDEX_SSL_SESSION
argument_list|,
name|ss
argument_list|,
operator|&
name|ss
operator|->
name|ex_data
argument_list|)
expr_stmt|;
name|OPENSSL_cleanse
argument_list|(
name|ss
operator|->
name|key_arg
argument_list|,
sizeof|sizeof
name|ss
operator|->
name|key_arg
argument_list|)
expr_stmt|;
name|OPENSSL_cleanse
argument_list|(
name|ss
operator|->
name|master_key
argument_list|,
sizeof|sizeof
name|ss
operator|->
name|master_key
argument_list|)
expr_stmt|;
name|OPENSSL_cleanse
argument_list|(
name|ss
operator|->
name|session_id
argument_list|,
sizeof|sizeof
name|ss
operator|->
name|session_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|sess_cert
operator|!=
name|NULL
condition|)
name|ssl_sess_cert_free
argument_list|(
name|ss
operator|->
name|sess_cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|peer
operator|!=
name|NULL
condition|)
name|X509_free
argument_list|(
name|ss
operator|->
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ciphers
operator|!=
name|NULL
condition|)
name|sk_SSL_CIPHER_free
argument_list|(
name|ss
operator|->
name|ciphers
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
if|if
condition|(
name|ss
operator|->
name|tlsext_hostname
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|ss
operator|->
name|tlsext_hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|tlsext_tick
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|ss
operator|->
name|tlsext_tick
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
name|ss
operator|->
name|tlsext_ecpointformatlist_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|tlsext_ecpointformatlist
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|ss
operator|->
name|tlsext_ecpointformatlist
argument_list|)
expr_stmt|;
name|ss
operator|->
name|tlsext_ellipticcurvelist_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|tlsext_ellipticcurvelist
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|ss
operator|->
name|tlsext_ellipticcurvelist
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL_NO_EC */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_PSK
if|if
condition|(
name|ss
operator|->
name|psk_identity_hint
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|ss
operator|->
name|psk_identity_hint
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|psk_identity
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|ss
operator|->
name|psk_identity
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SRP
if|if
condition|(
name|ss
operator|->
name|srp_username
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|ss
operator|->
name|srp_username
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OPENSSL_cleanse
argument_list|(
name|ss
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ss
argument_list|)
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|SSL_set_session
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|SSL_SESSION
modifier|*
name|session
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|SSL_METHOD
modifier|*
name|meth
decl_stmt|;
if|if
condition|(
name|session
operator|!=
name|NULL
condition|)
block|{
name|meth
operator|=
name|s
operator|->
name|ctx
operator|->
name|method
operator|->
name|get_ssl_method
argument_list|(
name|session
operator|->
name|ssl_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|meth
operator|==
name|NULL
condition|)
name|meth
operator|=
name|s
operator|->
name|method
operator|->
name|get_ssl_method
argument_list|(
name|session
operator|->
name|ssl_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|meth
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_SET_SESSION
argument_list|,
name|SSL_R_UNABLE_TO_FIND_SSL_METHOD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|meth
operator|!=
name|s
operator|->
name|method
condition|)
block|{
if|if
condition|(
operator|!
name|SSL_set_ssl_method
argument_list|(
name|s
argument_list|,
name|meth
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_KRB5
if|if
condition|(
name|s
operator|->
name|kssl_ctx
operator|&&
operator|!
name|s
operator|->
name|kssl_ctx
operator|->
name|client_princ
operator|&&
name|session
operator|->
name|krb5_client_princ_len
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|kssl_ctx
operator|->
name|client_princ
operator|=
operator|(
name|char
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
name|session
operator|->
name|krb5_client_princ_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|kssl_ctx
operator|->
name|client_princ
argument_list|,
name|session
operator|->
name|krb5_client_princ
argument_list|,
name|session
operator|->
name|krb5_client_princ_len
argument_list|)
expr_stmt|;
name|s
operator|->
name|kssl_ctx
operator|->
name|client_princ
index|[
name|session
operator|->
name|krb5_client_princ_len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OPENSSL_NO_KRB5 */
comment|/* CRYPTO_w_lock(CRYPTO_LOCK_SSL); */
name|CRYPTO_add
argument_list|(
operator|&
name|session
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_SSL_SESSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|!=
name|NULL
condition|)
name|SSL_SESSION_free
argument_list|(
name|s
operator|->
name|session
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|=
name|session
expr_stmt|;
name|s
operator|->
name|verify_result
operator|=
name|s
operator|->
name|session
operator|->
name|verify_result
expr_stmt|;
comment|/* CRYPTO_w_unlock(CRYPTO_LOCK_SSL); */
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|s
operator|->
name|session
operator|!=
name|NULL
condition|)
block|{
name|SSL_SESSION_free
argument_list|(
name|s
operator|->
name|session
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|=
name|NULL
expr_stmt|;
block|}
name|meth
operator|=
name|s
operator|->
name|ctx
operator|->
name|method
expr_stmt|;
if|if
condition|(
name|meth
operator|!=
name|s
operator|->
name|method
condition|)
block|{
if|if
condition|(
operator|!
name|SSL_set_ssl_method
argument_list|(
name|s
argument_list|,
name|meth
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|long
name|SSL_SESSION_set_timeout
parameter_list|(
name|SSL_SESSION
modifier|*
name|s
parameter_list|,
name|long
name|t
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|->
name|timeout
operator|=
name|t
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|long
name|SSL_SESSION_get_timeout
parameter_list|(
specifier|const
name|SSL_SESSION
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|s
operator|->
name|timeout
operator|)
return|;
block|}
end_function

begin_function
name|long
name|SSL_SESSION_get_time
parameter_list|(
specifier|const
name|SSL_SESSION
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|s
operator|->
name|time
operator|)
return|;
block|}
end_function

begin_function
name|long
name|SSL_SESSION_set_time
parameter_list|(
name|SSL_SESSION
modifier|*
name|s
parameter_list|,
name|long
name|t
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|->
name|time
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|X509
modifier|*
name|SSL_SESSION_get0_peer
parameter_list|(
name|SSL_SESSION
modifier|*
name|s
parameter_list|)
block|{
return|return
name|s
operator|->
name|peer
return|;
block|}
end_function

begin_function
name|int
name|SSL_SESSION_set1_id_context
parameter_list|(
name|SSL_SESSION
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sid_ctx
parameter_list|,
name|unsigned
name|int
name|sid_ctx_len
parameter_list|)
block|{
if|if
condition|(
name|sid_ctx_len
operator|>
name|SSL_MAX_SID_CTX_LENGTH
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_SESSION_SET1_ID_CONTEXT
argument_list|,
name|SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|->
name|sid_ctx_length
operator|=
name|sid_ctx_len
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|sid_ctx
argument_list|,
name|sid_ctx
argument_list|,
name|sid_ctx_len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|long
name|SSL_CTX_set_timeout
parameter_list|(
name|SSL_CTX
modifier|*
name|s
parameter_list|,
name|long
name|t
parameter_list|)
block|{
name|long
name|l
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|l
operator|=
name|s
operator|->
name|session_timeout
expr_stmt|;
name|s
operator|->
name|session_timeout
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_function
name|long
name|SSL_CTX_get_timeout
parameter_list|(
specifier|const
name|SSL_CTX
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|s
operator|->
name|session_timeout
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_TLSEXT
end_ifndef

begin_decl_stmt
name|int
name|SSL_set_session_secret_cb
argument_list|(
name|SSL
operator|*
name|s
argument_list|,
name|int
argument_list|(
operator|*
name|tls_session_secret_cb
argument_list|)
argument_list|(
name|SSL
operator|*
name|s
argument_list|,
name|void
operator|*
name|secret
argument_list|,
name|int
operator|*
name|secret_len
argument_list|,
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|peer_ciphers
argument_list|,
name|SSL_CIPHER
operator|*
operator|*
name|cipher
argument_list|,
name|void
operator|*
name|arg
argument_list|)
argument_list|,
name|void
operator|*
name|arg
argument_list|)
block|{
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|->
name|tls_session_secret_cb
operator|=
name|tls_session_secret_cb
expr_stmt|;
name|s
operator|->
name|tls_session_secret_cb_arg
operator|=
name|arg
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|int
name|SSL_set_session_ticket_ext_cb
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|tls_session_ticket_ext_cb_fn
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|->
name|tls_session_ticket_ext_cb
operator|=
name|cb
expr_stmt|;
name|s
operator|->
name|tls_session_ticket_ext_cb_arg
operator|=
name|arg
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|SSL_set_session_ticket_ext
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|void
modifier|*
name|ext_data
parameter_list|,
name|int
name|ext_len
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|version
operator|>=
name|TLS1_VERSION
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|tlsext_session_ticket
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|s
operator|->
name|tlsext_session_ticket
argument_list|)
expr_stmt|;
name|s
operator|->
name|tlsext_session_ticket
operator|=
name|NULL
expr_stmt|;
block|}
name|s
operator|->
name|tlsext_session_ticket
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TLS_SESSION_TICKET_EXT
argument_list|)
operator|+
name|ext_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|tlsext_session_ticket
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_SET_SESSION_TICKET_EXT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ext_data
condition|)
block|{
name|s
operator|->
name|tlsext_session_ticket
operator|->
name|length
operator|=
name|ext_len
expr_stmt|;
name|s
operator|->
name|tlsext_session_ticket
operator|->
name|data
operator|=
name|s
operator|->
name|tlsext_session_ticket
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|tlsext_session_ticket
operator|->
name|data
argument_list|,
name|ext_data
argument_list|,
name|ext_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|tlsext_session_ticket
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|tlsext_session_ticket
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL_NO_TLSEXT */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|timeout_param_st
block|{
name|SSL_CTX
modifier|*
name|ctx
decl_stmt|;
name|long
name|time
decl_stmt|;
name|LHASH_OF
argument_list|(
name|SSL_SESSION
argument_list|)
operator|*
name|cache
expr_stmt|;
block|}
name|TIMEOUT_PARAM
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|timeout_doall_arg
parameter_list|(
name|SSL_SESSION
modifier|*
name|s
parameter_list|,
name|TIMEOUT_PARAM
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|time
operator|==
literal|0
operator|)
operator|||
operator|(
name|p
operator|->
name|time
operator|>
operator|(
name|s
operator|->
name|time
operator|+
name|s
operator|->
name|timeout
operator|)
operator|)
condition|)
block|{
comment|/* timeout */
comment|/*          * The reason we don't call SSL_CTX_remove_session() is to save on          * locking overhead          */
operator|(
name|void
operator|)
name|lh_SSL_SESSION_delete
argument_list|(
name|p
operator|->
name|cache
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|SSL_SESSION_list_remove
argument_list|(
name|p
operator|->
name|ctx
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|not_resumable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ctx
operator|->
name|remove_session_cb
operator|!=
name|NULL
condition|)
name|p
operator|->
name|ctx
operator|->
name|remove_session_cb
argument_list|(
name|p
operator|->
name|ctx
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|SSL_SESSION_free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|IMPLEMENT_LHASH_DOALL_ARG_FN
argument_list|(
argument|timeout
argument_list|,
argument|SSL_SESSION
argument_list|,
argument|TIMEOUT_PARAM
argument_list|)
name|void
name|SSL_CTX_flush_sessions
argument_list|(
argument|SSL_CTX *s
argument_list|,
argument|long t
argument_list|)
block|{
name|unsigned
name|long
name|i
block|;
name|TIMEOUT_PARAM
name|tp
block|;
name|tp
operator|.
name|ctx
operator|=
name|s
block|;
name|tp
operator|.
name|cache
operator|=
name|s
operator|->
name|sessions
block|;
if|if
condition|(
name|tp
operator|.
name|cache
operator|==
name|NULL
condition|)
return|return;
name|tp
operator|.
name|time
operator|=
name|t
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_SSL_CTX
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|i
operator|=
name|CHECKED_LHASH_OF
argument_list|(
name|SSL_SESSION
argument_list|,
name|tp
operator|.
name|cache
argument_list|)
operator|->
name|down_load
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CHECKED_LHASH_OF
argument_list|(
name|SSL_SESSION
argument_list|,
name|tp
operator|.
name|cache
argument_list|)
operator|->
name|down_load
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|lh_SSL_SESSION_doall_arg
argument_list|(
name|tp
operator|.
name|cache
argument_list|,
name|LHASH_DOALL_ARG_FN
argument_list|(
name|timeout
argument_list|)
argument_list|,
name|TIMEOUT_PARAM
argument_list|,
operator|&
name|tp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CHECKED_LHASH_OF
argument_list|(
name|SSL_SESSION
argument_list|,
name|tp
operator|.
name|cache
argument_list|)
operator|->
name|down_load
operator|=
name|i
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_SSL_CTX
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
unit|}  int
name|ssl_clear_bad_session
argument_list|(
argument|SSL *s
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|session
operator|!=
name|NULL
operator|)
operator|&&
operator|!
operator|(
name|s
operator|->
name|shutdown
operator|&
name|SSL_SENT_SHUTDOWN
operator|)
operator|&&
operator|!
operator|(
name|SSL_in_init
argument_list|(
name|s
argument_list|)
operator|||
name|SSL_in_before
argument_list|(
name|s
argument_list|)
operator|)
condition|)
block|{
name|SSL_CTX_remove_session
argument_list|(
name|s
operator|->
name|ctx
argument_list|,
name|s
operator|->
name|session
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* locked by SSL_CTX in the calling function */
end_comment

begin_function
specifier|static
name|void
name|SSL_SESSION_list_remove
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|SSL_SESSION
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|next
operator|==
name|NULL
operator|)
operator|||
operator|(
name|s
operator|->
name|prev
operator|==
name|NULL
operator|)
condition|)
return|return;
if|if
condition|(
name|s
operator|->
name|next
operator|==
operator|(
name|SSL_SESSION
operator|*
operator|)
operator|&
operator|(
name|ctx
operator|->
name|session_cache_tail
operator|)
condition|)
block|{
comment|/* last element in list */
if|if
condition|(
name|s
operator|->
name|prev
operator|==
operator|(
name|SSL_SESSION
operator|*
operator|)
operator|&
operator|(
name|ctx
operator|->
name|session_cache_head
operator|)
condition|)
block|{
comment|/* only one element in list */
name|ctx
operator|->
name|session_cache_head
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|session_cache_tail
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|session_cache_tail
operator|=
name|s
operator|->
name|prev
expr_stmt|;
name|s
operator|->
name|prev
operator|->
name|next
operator|=
operator|(
name|SSL_SESSION
operator|*
operator|)
operator|&
operator|(
name|ctx
operator|->
name|session_cache_tail
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|s
operator|->
name|prev
operator|==
operator|(
name|SSL_SESSION
operator|*
operator|)
operator|&
operator|(
name|ctx
operator|->
name|session_cache_head
operator|)
condition|)
block|{
comment|/* first element in list */
name|ctx
operator|->
name|session_cache_head
operator|=
name|s
operator|->
name|next
expr_stmt|;
name|s
operator|->
name|next
operator|->
name|prev
operator|=
operator|(
name|SSL_SESSION
operator|*
operator|)
operator|&
operator|(
name|ctx
operator|->
name|session_cache_head
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* middle of list */
name|s
operator|->
name|next
operator|->
name|prev
operator|=
name|s
operator|->
name|prev
expr_stmt|;
name|s
operator|->
name|prev
operator|->
name|next
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
block|}
name|s
operator|->
name|prev
operator|=
name|s
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|SSL_SESSION_list_add
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|SSL_SESSION
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|next
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|s
operator|->
name|prev
operator|!=
name|NULL
operator|)
condition|)
name|SSL_SESSION_list_remove
argument_list|(
name|ctx
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|session_cache_head
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|->
name|session_cache_head
operator|=
name|s
expr_stmt|;
name|ctx
operator|->
name|session_cache_tail
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|prev
operator|=
operator|(
name|SSL_SESSION
operator|*
operator|)
operator|&
operator|(
name|ctx
operator|->
name|session_cache_head
operator|)
expr_stmt|;
name|s
operator|->
name|next
operator|=
operator|(
name|SSL_SESSION
operator|*
operator|)
operator|&
operator|(
name|ctx
operator|->
name|session_cache_tail
operator|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|next
operator|=
name|ctx
operator|->
name|session_cache_head
expr_stmt|;
name|s
operator|->
name|next
operator|->
name|prev
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|prev
operator|=
operator|(
name|SSL_SESSION
operator|*
operator|)
operator|&
operator|(
name|ctx
operator|->
name|session_cache_head
operator|)
expr_stmt|;
name|ctx
operator|->
name|session_cache_head
operator|=
name|s
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|SSL_CTX_sess_set_new_cb
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|int
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|ssl_st
modifier|*
name|ssl
parameter_list|,
name|SSL_SESSION
modifier|*
name|sess
parameter_list|)
parameter_list|)
block|{
name|ctx
operator|->
name|new_session_cb
operator|=
name|cb
expr_stmt|;
block|}
end_function

begin_macro
name|int
argument_list|(
argument|*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx)
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|SSL
operator|*
name|ssl
operator|,
name|SSL_SESSION
operator|*
name|sess
operator|)
block|{
return|return
name|ctx
operator|->
name|new_session_cb
return|;
block|}
end_expr_stmt

begin_function
name|void
name|SSL_CTX_sess_set_remove_cb
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|SSL_SESSION
modifier|*
name|sess
parameter_list|)
parameter_list|)
block|{
name|ctx
operator|->
name|remove_session_cb
operator|=
name|cb
expr_stmt|;
block|}
end_function

begin_macro
name|void
argument_list|(
argument|*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx)
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|SSL_CTX
operator|*
name|ctx
operator|,
name|SSL_SESSION
operator|*
name|sess
operator|)
block|{
return|return
name|ctx
operator|->
name|remove_session_cb
return|;
block|}
end_expr_stmt

begin_function
name|void
name|SSL_CTX_sess_set_get_cb
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|SSL_SESSION
modifier|*
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|ssl_st
modifier|*
name|ssl
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|copy
parameter_list|)
parameter_list|)
block|{
name|ctx
operator|->
name|get_session_cb
operator|=
name|cb
expr_stmt|;
block|}
end_function

begin_macro
name|SSL_SESSION
end_macro

begin_expr_stmt
operator|*
operator|(
operator|*
name|SSL_CTX_sess_get_get_cb
argument_list|(
name|SSL_CTX
operator|*
name|ctx
argument_list|)
operator|)
operator|(
name|SSL
operator|*
name|ssl
operator|,
name|unsigned
name|char
operator|*
name|data
operator|,
name|int
name|len
operator|,
name|int
operator|*
name|copy
operator|)
block|{
return|return
name|ctx
operator|->
name|get_session_cb
return|;
block|}
end_expr_stmt

begin_function
name|void
name|SSL_CTX_set_info_callback
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
specifier|const
name|SSL
modifier|*
name|ssl
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|val
parameter_list|)
parameter_list|)
block|{
name|ctx
operator|->
name|info_callback
operator|=
name|cb
expr_stmt|;
block|}
end_function

begin_macro
name|void
argument_list|(
argument|*SSL_CTX_get_info_callback(SSL_CTX *ctx)
argument_list|)
end_macro

begin_expr_stmt
operator|(
specifier|const
name|SSL
operator|*
name|ssl
operator|,
name|int
name|type
operator|,
name|int
name|val
operator|)
block|{
return|return
name|ctx
operator|->
name|info_callback
return|;
block|}
end_expr_stmt

begin_function
name|void
name|SSL_CTX_set_client_cert_cb
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|int
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|X509
modifier|*
modifier|*
name|x509
parameter_list|,
name|EVP_PKEY
modifier|*
modifier|*
name|pkey
parameter_list|)
parameter_list|)
block|{
name|ctx
operator|->
name|client_cert_cb
operator|=
name|cb
expr_stmt|;
block|}
end_function

begin_macro
name|int
argument_list|(
argument|*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx)
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|SSL
operator|*
name|ssl
operator|,
name|X509
operator|*
operator|*
name|x509
operator|,
name|EVP_PKEY
operator|*
operator|*
name|pkey
operator|)
block|{
return|return
name|ctx
operator|->
name|client_cert_cb
return|;
block|}
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_ENGINE
end_ifndef

begin_function
name|int
name|SSL_CTX_set_client_cert_engine
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ENGINE_init
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE
argument_list|,
name|ERR_R_ENGINE_LIB
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|ENGINE_get_ssl_client_cert_function
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE
argument_list|,
name|SSL_R_NO_CLIENT_CERT_METHOD
argument_list|)
expr_stmt|;
name|ENGINE_finish
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ctx
operator|->
name|client_cert_engine
operator|=
name|e
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|SSL_CTX_set_cookie_generate_cb
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|int
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|unsigned
name|char
modifier|*
name|cookie
parameter_list|,
name|unsigned
name|int
modifier|*
name|cookie_len
parameter_list|)
parameter_list|)
block|{
name|ctx
operator|->
name|app_gen_cookie_cb
operator|=
name|cb
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SSL_CTX_set_cookie_verify_cb
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|int
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|unsigned
name|char
modifier|*
name|cookie
parameter_list|,
name|unsigned
name|int
name|cookie_len
parameter_list|)
parameter_list|)
block|{
name|ctx
operator|->
name|app_verify_cookie_cb
operator|=
name|cb
expr_stmt|;
block|}
end_function

begin_macro
name|IMPLEMENT_PEM_rw
argument_list|(
argument|SSL_SESSION
argument_list|,
argument|SSL_SESSION
argument_list|,
argument|PEM_STRING_SSL_SESSION
argument_list|,
argument|SSL_SESSION
argument_list|)
end_macro

end_unit

