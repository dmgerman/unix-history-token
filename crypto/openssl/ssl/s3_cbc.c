begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ssl/s3_cbc.c */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2012 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|"../crypto/constant_time_locl.h"
end_include

begin_include
include|#
directive|include
file|"ssl_locl.h"
end_include

begin_include
include|#
directive|include
file|<openssl/md5.h>
end_include

begin_include
include|#
directive|include
file|<openssl/sha.h>
end_include

begin_comment
comment|/* MAX_HASH_BIT_COUNT_BYTES is the maximum number of bytes in the hash's length  * field. (SHA-384/512 have 128-bit length.) */
end_comment

begin_define
define|#
directive|define
name|MAX_HASH_BIT_COUNT_BYTES
value|16
end_define

begin_comment
comment|/* MAX_HASH_BLOCK_SIZE is the maximum hash block size that we'll support.  * Currently SHA-384/512 has a 128-byte block size and that's the largest  * supported by TLS.) */
end_comment

begin_define
define|#
directive|define
name|MAX_HASH_BLOCK_SIZE
value|128
end_define

begin_comment
comment|/* ssl3_cbc_remove_padding removes padding from the decrypted, SSLv3, CBC  * record in |rec| by updating |rec->length| in constant time.  *  * block_size: the block size of the cipher used to encrypt the record.  * returns:  *   0: (in non-constant time) if the record is publicly invalid.  *   1: if the padding was valid  *  -1: otherwise. */
end_comment

begin_function
name|int
name|ssl3_cbc_remove_padding
parameter_list|(
specifier|const
name|SSL
modifier|*
name|s
parameter_list|,
name|SSL3_RECORD
modifier|*
name|rec
parameter_list|,
name|unsigned
name|block_size
parameter_list|,
name|unsigned
name|mac_size
parameter_list|)
block|{
name|unsigned
name|padding_length
decl_stmt|,
name|good
decl_stmt|;
specifier|const
name|unsigned
name|overhead
init|=
literal|1
comment|/* padding length byte */
operator|+
name|mac_size
decl_stmt|;
comment|/* These lengths are all public so we can test them in non-constant 	 * time. */
if|if
condition|(
name|overhead
operator|>
name|rec
operator|->
name|length
condition|)
return|return
literal|0
return|;
name|padding_length
operator|=
name|rec
operator|->
name|data
index|[
name|rec
operator|->
name|length
operator|-
literal|1
index|]
expr_stmt|;
name|good
operator|=
name|constant_time_ge
argument_list|(
name|rec
operator|->
name|length
argument_list|,
name|padding_length
operator|+
name|overhead
argument_list|)
expr_stmt|;
comment|/* SSLv3 requires that the padding is minimal. */
name|good
operator|&=
name|constant_time_ge
argument_list|(
name|block_size
argument_list|,
name|padding_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|padding_length
operator|=
name|good
operator|&
operator|(
name|padding_length
operator|+
literal|1
operator|)
expr_stmt|;
name|rec
operator|->
name|length
operator|-=
name|padding_length
expr_stmt|;
name|rec
operator|->
name|type
operator||=
name|padding_length
operator|<<
literal|8
expr_stmt|;
comment|/* kludge: pass padding length */
return|return
name|constant_time_select_int
argument_list|(
name|good
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* tls1_cbc_remove_padding removes the CBC padding from the decrypted, TLS, CBC  * record in |rec| in constant time and returns 1 if the padding is valid and  * -1 otherwise. It also removes any explicit IV from the start of the record  * without leaking any timing about whether there was enough space after the  * padding was removed.  *  * block_size: the block size of the cipher used to encrypt the record.  * returns:  *   0: (in non-constant time) if the record is publicly invalid.  *   1: if the padding was valid  *  -1: otherwise. */
end_comment

begin_function
name|int
name|tls1_cbc_remove_padding
parameter_list|(
specifier|const
name|SSL
modifier|*
name|s
parameter_list|,
name|SSL3_RECORD
modifier|*
name|rec
parameter_list|,
name|unsigned
name|block_size
parameter_list|,
name|unsigned
name|mac_size
parameter_list|)
block|{
name|unsigned
name|padding_length
decl_stmt|,
name|good
decl_stmt|,
name|to_check
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|unsigned
name|overhead
init|=
literal|1
comment|/* padding length byte */
operator|+
name|mac_size
decl_stmt|;
comment|/* Check if version requires explicit IV */
if|if
condition|(
name|s
operator|->
name|version
operator|==
name|DTLS1_VERSION
operator|||
name|s
operator|->
name|version
operator|==
name|DTLS1_BAD_VER
condition|)
block|{
comment|/* These lengths are all public so we can test them in 		 * non-constant time. 		 */
if|if
condition|(
name|overhead
operator|+
name|block_size
operator|>
name|rec
operator|->
name|length
condition|)
return|return
literal|0
return|;
comment|/* We can now safely skip explicit IV */
name|rec
operator|->
name|data
operator|+=
name|block_size
expr_stmt|;
name|rec
operator|->
name|input
operator|+=
name|block_size
expr_stmt|;
name|rec
operator|->
name|length
operator|-=
name|block_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|overhead
operator|>
name|rec
operator|->
name|length
condition|)
return|return
literal|0
return|;
name|padding_length
operator|=
name|rec
operator|->
name|data
index|[
name|rec
operator|->
name|length
operator|-
literal|1
index|]
expr_stmt|;
comment|/* NB: if compression is in operation the first packet may not be of 	 * even length so the padding bug check cannot be performed. This bug 	 * workaround has been around since SSLeay so hopefully it is either 	 * fixed now or no buggy implementation supports compression [steve] 	 */
if|if
condition|(
operator|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_TLS_BLOCK_PADDING_BUG
operator|)
operator|&&
operator|!
name|s
operator|->
name|expand
condition|)
block|{
comment|/* First packet is even in size, so check */
if|if
condition|(
operator|(
name|memcmp
argument_list|(
name|s
operator|->
name|s3
operator|->
name|read_sequence
argument_list|,
literal|"\0\0\0\0\0\0\0\0"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|padding_length
operator|&
literal|1
operator|)
condition|)
block|{
name|s
operator|->
name|s3
operator|->
name|flags
operator||=
name|TLS1_FLAGS_TLS_PADDING_BUG
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|s3
operator|->
name|flags
operator|&
name|TLS1_FLAGS_TLS_PADDING_BUG
operator|)
operator|&&
name|padding_length
operator|>
literal|0
condition|)
block|{
name|padding_length
operator|--
expr_stmt|;
block|}
block|}
name|good
operator|=
name|constant_time_ge
argument_list|(
name|rec
operator|->
name|length
argument_list|,
name|overhead
operator|+
name|padding_length
argument_list|)
expr_stmt|;
comment|/* The padding consists of a length byte at the end of the record and 	 * then that many bytes of padding, all with the same value as the 	 * length byte. Thus, with the length byte included, there are i+1 	 * bytes of padding. 	 * 	 * We can't check just |padding_length+1| bytes because that leaks 	 * decrypted information. Therefore we always have to check the maximum 	 * amount of padding possible. (Again, the length of the record is 	 * public information so we can use it.) */
name|to_check
operator|=
literal|255
expr_stmt|;
comment|/* maximum amount of padding. */
if|if
condition|(
name|to_check
operator|>
name|rec
operator|->
name|length
operator|-
literal|1
condition|)
name|to_check
operator|=
name|rec
operator|->
name|length
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|to_check
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|mask
init|=
name|constant_time_ge_8
argument_list|(
name|padding_length
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|b
init|=
name|rec
operator|->
name|data
index|[
name|rec
operator|->
name|length
operator|-
literal|1
operator|-
name|i
index|]
decl_stmt|;
comment|/* The final |padding_length+1| bytes should all have the value 		 * |padding_length|. Therefore the XOR should be zero. */
name|good
operator|&=
operator|~
operator|(
name|mask
operator|&
operator|(
name|padding_length
operator|^
name|b
operator|)
operator|)
expr_stmt|;
block|}
comment|/* If any of the final |padding_length+1| bytes had the wrong value, 	 * one or more of the lower eight bits of |good| will be cleared. 	 */
name|good
operator|=
name|constant_time_eq
argument_list|(
literal|0xff
argument_list|,
name|good
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|padding_length
operator|=
name|good
operator|&
operator|(
name|padding_length
operator|+
literal|1
operator|)
expr_stmt|;
name|rec
operator|->
name|length
operator|-=
name|padding_length
expr_stmt|;
name|rec
operator|->
name|type
operator||=
name|padding_length
operator|<<
literal|8
expr_stmt|;
comment|/* kludge: pass padding length */
return|return
name|constant_time_select_int
argument_list|(
name|good
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ssl3_cbc_copy_mac copies |md_size| bytes from the end of |rec| to |out| in  * constant time (independent of the concrete value of rec->length, which may  * vary within a 256-byte window).  *  * ssl3_cbc_remove_padding or tls1_cbc_remove_padding must be called prior to  * this function.  *  * On entry:  *   rec->orig_len>= md_size  *   md_size<= EVP_MAX_MD_SIZE  *  * If CBC_MAC_ROTATE_IN_PLACE is defined then the rotation is performed with  * variable accesses in a 64-byte-aligned buffer. Assuming that this fits into  * a single or pair of cache-lines, then the variable memory accesses don't  * actually affect the timing. CPUs with smaller cache-lines [if any] are  * not multi-core and are not considered vulnerable to cache-timing attacks.  */
end_comment

begin_define
define|#
directive|define
name|CBC_MAC_ROTATE_IN_PLACE
end_define

begin_function
name|void
name|ssl3_cbc_copy_mac
parameter_list|(
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|SSL3_RECORD
modifier|*
name|rec
parameter_list|,
name|unsigned
name|md_size
parameter_list|,
name|unsigned
name|orig_len
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CBC_MAC_ROTATE_IN_PLACE
argument_list|)
name|unsigned
name|char
name|rotated_mac_buf
index|[
literal|64
operator|+
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|rotated_mac
decl_stmt|;
else|#
directive|else
name|unsigned
name|char
name|rotated_mac
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* mac_end is the index of |rec->data| just after the end of the MAC. */
name|unsigned
name|mac_end
init|=
name|rec
operator|->
name|length
decl_stmt|;
name|unsigned
name|mac_start
init|=
name|mac_end
operator|-
name|md_size
decl_stmt|;
comment|/* scan_start contains the number of bytes that we can ignore because 	 * the MAC's position can only vary by 255 bytes. */
name|unsigned
name|scan_start
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|div_spoiler
decl_stmt|;
name|unsigned
name|rotate_offset
decl_stmt|;
name|OPENSSL_assert
argument_list|(
name|orig_len
operator|>=
name|md_size
argument_list|)
expr_stmt|;
name|OPENSSL_assert
argument_list|(
name|md_size
operator|<=
name|EVP_MAX_MD_SIZE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CBC_MAC_ROTATE_IN_PLACE
argument_list|)
name|rotated_mac
operator|=
name|rotated_mac_buf
operator|+
operator|(
operator|(
literal|0
operator|-
operator|(
name|size_t
operator|)
name|rotated_mac_buf
operator|)
operator|&
literal|63
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* This information is public so it's safe to branch based on it. */
if|if
condition|(
name|orig_len
operator|>
name|md_size
operator|+
literal|255
operator|+
literal|1
condition|)
name|scan_start
operator|=
name|orig_len
operator|-
operator|(
name|md_size
operator|+
literal|255
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* div_spoiler contains a multiple of md_size that is used to cause the 	 * modulo operation to be constant time. Without this, the time varies 	 * based on the amount of padding when running on Intel chips at least. 	 * 	 * The aim of right-shifting md_size is so that the compiler doesn't 	 * figure out that it can remove div_spoiler as that would require it 	 * to prove that md_size is always even, which I hope is beyond it. */
name|div_spoiler
operator|=
name|md_size
operator|>>
literal|1
expr_stmt|;
name|div_spoiler
operator|<<=
operator|(
sizeof|sizeof
argument_list|(
name|div_spoiler
argument_list|)
operator|-
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
name|rotate_offset
operator|=
operator|(
name|div_spoiler
operator|+
name|mac_start
operator|-
name|scan_start
operator|)
operator|%
name|md_size
expr_stmt|;
name|memset
argument_list|(
name|rotated_mac
argument_list|,
literal|0
argument_list|,
name|md_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|scan_start
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|orig_len
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|mac_started
init|=
name|constant_time_ge_8
argument_list|(
name|i
argument_list|,
name|mac_start
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|mac_ended
init|=
name|constant_time_ge_8
argument_list|(
name|i
argument_list|,
name|mac_end
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|b
init|=
name|rec
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
name|rotated_mac
index|[
name|j
operator|++
index|]
operator||=
name|b
operator|&
name|mac_started
operator|&
operator|~
name|mac_ended
expr_stmt|;
name|j
operator|&=
name|constant_time_lt
argument_list|(
name|j
argument_list|,
name|md_size
argument_list|)
expr_stmt|;
block|}
comment|/* Now rotate the MAC */
if|#
directive|if
name|defined
argument_list|(
name|CBC_MAC_ROTATE_IN_PLACE
argument_list|)
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|md_size
condition|;
name|i
operator|++
control|)
block|{
comment|/* in case cache-line is 32 bytes, touch second line */
operator|(
operator|(
specifier|volatile
name|unsigned
name|char
operator|*
operator|)
name|rotated_mac
operator|)
index|[
name|rotate_offset
operator|^
literal|32
index|]
expr_stmt|;
name|out
index|[
name|j
operator|++
index|]
operator|=
name|rotated_mac
index|[
name|rotate_offset
operator|++
index|]
expr_stmt|;
name|rotate_offset
operator|&=
name|constant_time_lt
argument_list|(
name|rotate_offset
argument_list|,
name|md_size
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|memset
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
name|md_size
argument_list|)
expr_stmt|;
name|rotate_offset
operator|=
name|md_size
operator|-
name|rotate_offset
expr_stmt|;
name|rotate_offset
operator|&=
name|constant_time_lt
argument_list|(
name|rotate_offset
argument_list|,
name|md_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|md_size
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|md_size
condition|;
name|j
operator|++
control|)
name|out
index|[
name|j
index|]
operator||=
name|rotated_mac
index|[
name|i
index|]
operator|&
name|constant_time_eq_8
argument_list|(
name|j
argument_list|,
name|rotate_offset
argument_list|)
expr_stmt|;
name|rotate_offset
operator|++
expr_stmt|;
name|rotate_offset
operator|&=
name|constant_time_lt
argument_list|(
name|rotate_offset
argument_list|,
name|md_size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* u32toLE serialises an unsigned, 32-bit number (n) as four bytes at (p) in  * little-endian order. The value of p is advanced by four. */
end_comment

begin_define
define|#
directive|define
name|u32toLE
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
define|\
value|(*((p)++)=(unsigned char)(n), \ 	 *((p)++)=(unsigned char)(n>>8), \ 	 *((p)++)=(unsigned char)(n>>16), \ 	 *((p)++)=(unsigned char)(n>>24))
end_define

begin_comment
comment|/* These functions serialize the state of a hash and thus perform the standard  * "final" operation without adding the padding and length that such a function  * typically does. */
end_comment

begin_function
specifier|static
name|void
name|tls1_md5_final_raw
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|md_out
parameter_list|)
block|{
name|MD5_CTX
modifier|*
name|md5
init|=
name|ctx
decl_stmt|;
name|u32toLE
argument_list|(
name|md5
operator|->
name|A
argument_list|,
name|md_out
argument_list|)
expr_stmt|;
name|u32toLE
argument_list|(
name|md5
operator|->
name|B
argument_list|,
name|md_out
argument_list|)
expr_stmt|;
name|u32toLE
argument_list|(
name|md5
operator|->
name|C
argument_list|,
name|md_out
argument_list|)
expr_stmt|;
name|u32toLE
argument_list|(
name|md5
operator|->
name|D
argument_list|,
name|md_out
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tls1_sha1_final_raw
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|md_out
parameter_list|)
block|{
name|SHA_CTX
modifier|*
name|sha1
init|=
name|ctx
decl_stmt|;
name|l2n
argument_list|(
name|sha1
operator|->
name|h0
argument_list|,
name|md_out
argument_list|)
expr_stmt|;
name|l2n
argument_list|(
name|sha1
operator|->
name|h1
argument_list|,
name|md_out
argument_list|)
expr_stmt|;
name|l2n
argument_list|(
name|sha1
operator|->
name|h2
argument_list|,
name|md_out
argument_list|)
expr_stmt|;
name|l2n
argument_list|(
name|sha1
operator|->
name|h3
argument_list|,
name|md_out
argument_list|)
expr_stmt|;
name|l2n
argument_list|(
name|sha1
operator|->
name|h4
argument_list|,
name|md_out
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|LARGEST_DIGEST_CTX
value|SHA_CTX
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA256
end_ifndef

begin_function
specifier|static
name|void
name|tls1_sha256_final_raw
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|md_out
parameter_list|)
block|{
name|SHA256_CTX
modifier|*
name|sha256
init|=
name|ctx
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|l2n
argument_list|(
name|sha256
operator|->
name|h
index|[
name|i
index|]
argument_list|,
name|md_out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|LARGEST_DIGEST_CTX
end_undef

begin_define
define|#
directive|define
name|LARGEST_DIGEST_CTX
value|SHA256_CTX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA512
end_ifndef

begin_function
specifier|static
name|void
name|tls1_sha512_final_raw
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|md_out
parameter_list|)
block|{
name|SHA512_CTX
modifier|*
name|sha512
init|=
name|ctx
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|l2n8
argument_list|(
name|sha512
operator|->
name|h
index|[
name|i
index|]
argument_list|,
name|md_out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|LARGEST_DIGEST_CTX
end_undef

begin_define
define|#
directive|define
name|LARGEST_DIGEST_CTX
value|SHA512_CTX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ssl3_cbc_record_digest_supported returns 1 iff |ctx| uses a hash function  * which ssl3_cbc_digest_record supports. */
end_comment

begin_function
name|char
name|ssl3_cbc_record_digest_supported
parameter_list|(
specifier|const
name|EVP_MD
modifier|*
name|digest
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
if|if
condition|(
name|FIPS_mode
argument_list|()
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
switch|switch
condition|(
name|EVP_MD_type
argument_list|(
name|digest
argument_list|)
condition|)
block|{
case|case
name|NID_md5
case|:
case|case
name|NID_sha1
case|:
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA256
case|case
name|NID_sha224
case|:
case|case
name|NID_sha256
case|:
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA512
case|case
name|NID_sha384
case|:
case|case
name|NID_sha512
case|:
endif|#
directive|endif
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* ssl3_cbc_digest_record computes the MAC of a decrypted, padded SSLv3/TLS  * record.  *  *   ctx: the EVP_MD_CTX from which we take the hash function.  *     ssl3_cbc_record_digest_supported must return true for this EVP_MD_CTX.  *   md_out: the digest output. At most EVP_MAX_MD_SIZE bytes will be written.  *   md_out_size: if non-NULL, the number of output bytes is written here.  *   header: the 13-byte, TLS record header.  *   data: the record data itself, less any preceeding explicit IV.  *   data_plus_mac_size: the secret, reported length of the data and MAC  *     once the padding has been removed.  *   data_plus_mac_plus_padding_size: the public length of the whole  *     record, including padding.  *   is_sslv3: non-zero if we are to use SSLv3. Otherwise, TLS.  *  * On entry: by virtue of having been through one of the remove_padding  * functions, above, we know that data_plus_mac_size is large enough to contain  * a padding byte and MAC. (If the padding was invalid, it might contain the  * padding too. ) */
end_comment

begin_function
name|void
name|ssl3_cbc_digest_record
parameter_list|(
specifier|const
name|EVP_MD
modifier|*
name|digest
parameter_list|,
name|unsigned
name|char
modifier|*
name|md_out
parameter_list|,
name|size_t
modifier|*
name|md_out_size
parameter_list|,
specifier|const
name|unsigned
name|char
name|header
index|[
literal|13
index|]
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|data_plus_mac_size
parameter_list|,
name|size_t
name|data_plus_mac_plus_padding_size
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|mac_secret
parameter_list|,
name|unsigned
name|mac_secret_length
parameter_list|,
name|char
name|is_sslv3
parameter_list|)
block|{
union|union
block|{
name|double
name|align
decl_stmt|;
name|unsigned
name|char
name|c
index|[
sizeof|sizeof
argument_list|(
name|LARGEST_DIGEST_CTX
argument_list|)
index|]
decl_stmt|;
block|}
name|md_state
union|;
name|void
function_decl|(
modifier|*
name|md_final_raw
function_decl|)
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|md_out
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|md_transform
function_decl|)
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|block
parameter_list|)
function_decl|;
name|unsigned
name|md_size
decl_stmt|,
name|md_block_size
init|=
literal|64
decl_stmt|;
name|unsigned
name|sslv3_pad_length
init|=
literal|40
decl_stmt|,
name|header_length
decl_stmt|,
name|variance_blocks
decl_stmt|,
name|len
decl_stmt|,
name|max_mac_bytes
decl_stmt|,
name|num_blocks
decl_stmt|,
name|num_starting_blocks
decl_stmt|,
name|k
decl_stmt|,
name|mac_end_offset
decl_stmt|,
name|c
decl_stmt|,
name|index_a
decl_stmt|,
name|index_b
decl_stmt|;
name|unsigned
name|int
name|bits
decl_stmt|;
comment|/* at most 18 bits */
name|unsigned
name|char
name|length_bytes
index|[
name|MAX_HASH_BIT_COUNT_BYTES
index|]
decl_stmt|;
comment|/* hmac_pad is the masked HMAC key. */
name|unsigned
name|char
name|hmac_pad
index|[
name|MAX_HASH_BLOCK_SIZE
index|]
decl_stmt|;
name|unsigned
name|char
name|first_block
index|[
name|MAX_HASH_BLOCK_SIZE
index|]
decl_stmt|;
name|unsigned
name|char
name|mac_out
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|md_out_size_u
decl_stmt|;
name|EVP_MD_CTX
name|md_ctx
decl_stmt|;
comment|/* mdLengthSize is the number of bytes in the length field that terminates 	* the hash. */
name|unsigned
name|md_length_size
init|=
literal|8
decl_stmt|;
name|char
name|length_is_big_endian
init|=
literal|1
decl_stmt|;
comment|/* This is a, hopefully redundant, check that allows us to forget about 	 * many possible overflows later in this function. */
name|OPENSSL_assert
argument_list|(
name|data_plus_mac_plus_padding_size
operator|<
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|EVP_MD_type
argument_list|(
name|digest
argument_list|)
condition|)
block|{
case|case
name|NID_md5
case|:
name|MD5_Init
argument_list|(
operator|(
name|MD5_CTX
operator|*
operator|)
name|md_state
operator|.
name|c
argument_list|)
expr_stmt|;
name|md_final_raw
operator|=
name|tls1_md5_final_raw
expr_stmt|;
name|md_transform
operator|=
operator|(
name|void
argument_list|(
argument|*
argument_list|)
operator|(
name|void
operator|*
name|ctx
operator|,
specifier|const
name|unsigned
name|char
operator|*
name|block
operator|)
operator|)
name|MD5_Transform
expr_stmt|;
name|md_size
operator|=
literal|16
expr_stmt|;
name|sslv3_pad_length
operator|=
literal|48
expr_stmt|;
name|length_is_big_endian
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NID_sha1
case|:
name|SHA1_Init
argument_list|(
operator|(
name|SHA_CTX
operator|*
operator|)
name|md_state
operator|.
name|c
argument_list|)
expr_stmt|;
name|md_final_raw
operator|=
name|tls1_sha1_final_raw
expr_stmt|;
name|md_transform
operator|=
operator|(
name|void
argument_list|(
argument|*
argument_list|)
operator|(
name|void
operator|*
name|ctx
operator|,
specifier|const
name|unsigned
name|char
operator|*
name|block
operator|)
operator|)
name|SHA1_Transform
expr_stmt|;
name|md_size
operator|=
literal|20
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA256
case|case
name|NID_sha224
case|:
name|SHA224_Init
argument_list|(
operator|(
name|SHA256_CTX
operator|*
operator|)
name|md_state
operator|.
name|c
argument_list|)
expr_stmt|;
name|md_final_raw
operator|=
name|tls1_sha256_final_raw
expr_stmt|;
name|md_transform
operator|=
operator|(
name|void
argument_list|(
argument|*
argument_list|)
operator|(
name|void
operator|*
name|ctx
operator|,
specifier|const
name|unsigned
name|char
operator|*
name|block
operator|)
operator|)
name|SHA256_Transform
expr_stmt|;
name|md_size
operator|=
literal|224
operator|/
literal|8
expr_stmt|;
break|break;
case|case
name|NID_sha256
case|:
name|SHA256_Init
argument_list|(
operator|(
name|SHA256_CTX
operator|*
operator|)
name|md_state
operator|.
name|c
argument_list|)
expr_stmt|;
name|md_final_raw
operator|=
name|tls1_sha256_final_raw
expr_stmt|;
name|md_transform
operator|=
operator|(
name|void
argument_list|(
argument|*
argument_list|)
operator|(
name|void
operator|*
name|ctx
operator|,
specifier|const
name|unsigned
name|char
operator|*
name|block
operator|)
operator|)
name|SHA256_Transform
expr_stmt|;
name|md_size
operator|=
literal|32
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SHA512
case|case
name|NID_sha384
case|:
name|SHA384_Init
argument_list|(
operator|(
name|SHA512_CTX
operator|*
operator|)
name|md_state
operator|.
name|c
argument_list|)
expr_stmt|;
name|md_final_raw
operator|=
name|tls1_sha512_final_raw
expr_stmt|;
name|md_transform
operator|=
operator|(
name|void
argument_list|(
argument|*
argument_list|)
operator|(
name|void
operator|*
name|ctx
operator|,
specifier|const
name|unsigned
name|char
operator|*
name|block
operator|)
operator|)
name|SHA512_Transform
expr_stmt|;
name|md_size
operator|=
literal|384
operator|/
literal|8
expr_stmt|;
name|md_block_size
operator|=
literal|128
expr_stmt|;
name|md_length_size
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|NID_sha512
case|:
name|SHA512_Init
argument_list|(
operator|(
name|SHA512_CTX
operator|*
operator|)
name|md_state
operator|.
name|c
argument_list|)
expr_stmt|;
name|md_final_raw
operator|=
name|tls1_sha512_final_raw
expr_stmt|;
name|md_transform
operator|=
operator|(
name|void
argument_list|(
argument|*
argument_list|)
operator|(
name|void
operator|*
name|ctx
operator|,
specifier|const
name|unsigned
name|char
operator|*
name|block
operator|)
operator|)
name|SHA512_Transform
expr_stmt|;
name|md_size
operator|=
literal|64
expr_stmt|;
name|md_block_size
operator|=
literal|128
expr_stmt|;
name|md_length_size
operator|=
literal|16
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* ssl3_cbc_record_digest_supported should have been 			 * called first to check that the hash function is 			 * supported. */
name|OPENSSL_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|md_out_size
condition|)
operator|*
name|md_out_size
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|OPENSSL_assert
argument_list|(
name|md_length_size
operator|<=
name|MAX_HASH_BIT_COUNT_BYTES
argument_list|)
expr_stmt|;
name|OPENSSL_assert
argument_list|(
name|md_block_size
operator|<=
name|MAX_HASH_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|OPENSSL_assert
argument_list|(
name|md_size
operator|<=
name|EVP_MAX_MD_SIZE
argument_list|)
expr_stmt|;
name|header_length
operator|=
literal|13
expr_stmt|;
if|if
condition|(
name|is_sslv3
condition|)
block|{
name|header_length
operator|=
name|mac_secret_length
operator|+
name|sslv3_pad_length
operator|+
literal|8
comment|/* sequence number */
operator|+
literal|1
comment|/* record type */
operator|+
literal|2
comment|/* record length */
expr_stmt|;
block|}
comment|/* variance_blocks is the number of blocks of the hash that we have to 	 * calculate in constant time because they could be altered by the 	 * padding value. 	 * 	 * In SSLv3, the padding must be minimal so the end of the plaintext 	 * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that 	 * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash 	 * termination (0x80 + 64-bit length) don't fit in the final block, we 	 * say that the final two blocks can vary based on the padding. 	 * 	 * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not 	 * required to be minimal. Therefore we say that the final six blocks 	 * can vary based on the padding. 	 * 	 * Later in the function, if the message is short and there obviously 	 * cannot be this many blocks then variance_blocks can be reduced. */
name|variance_blocks
operator|=
name|is_sslv3
condition|?
literal|2
else|:
literal|6
expr_stmt|;
comment|/* From now on we're dealing with the MAC, which conceptually has 13 	 * bytes of `header' before the start of the data (TLS) or 71/75 bytes 	 * (SSLv3) */
name|len
operator|=
name|data_plus_mac_plus_padding_size
operator|+
name|header_length
expr_stmt|;
comment|/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including 	* |header|, assuming that there's no padding. */
name|max_mac_bytes
operator|=
name|len
operator|-
name|md_size
operator|-
literal|1
expr_stmt|;
comment|/* num_blocks is the maximum number of hash blocks. */
name|num_blocks
operator|=
operator|(
name|max_mac_bytes
operator|+
literal|1
operator|+
name|md_length_size
operator|+
name|md_block_size
operator|-
literal|1
operator|)
operator|/
name|md_block_size
expr_stmt|;
comment|/* In order to calculate the MAC in constant time we have to handle 	 * the final blocks specially because the padding value could cause the 	 * end to appear somewhere in the final |variance_blocks| blocks and we 	 * can't leak where. However, |num_starting_blocks| worth of data can 	 * be hashed right away because no padding value can affect whether 	 * they are plaintext. */
name|num_starting_blocks
operator|=
literal|0
expr_stmt|;
comment|/* k is the starting byte offset into the conceptual header||data where 	 * we start processing. */
name|k
operator|=
literal|0
expr_stmt|;
comment|/* mac_end_offset is the index just past the end of the data to be 	 * MACed. */
name|mac_end_offset
operator|=
name|data_plus_mac_size
operator|+
name|header_length
operator|-
name|md_size
expr_stmt|;
comment|/* c is the index of the 0x80 byte in the final hash block that 	 * contains application data. */
name|c
operator|=
name|mac_end_offset
operator|%
name|md_block_size
expr_stmt|;
comment|/* index_a is the hash block number that contains the 0x80 terminating 	 * value. */
name|index_a
operator|=
name|mac_end_offset
operator|/
name|md_block_size
expr_stmt|;
comment|/* index_b is the hash block number that contains the 64-bit hash 	 * length, in bits. */
name|index_b
operator|=
operator|(
name|mac_end_offset
operator|+
name|md_length_size
operator|)
operator|/
name|md_block_size
expr_stmt|;
comment|/* bits is the hash-length in bits. It includes the additional hash 	 * block for the masked HMAC key, or whole of |header| in the case of 	 * SSLv3. */
comment|/* For SSLv3, if we're going to have any starting blocks then we need 	 * at least two because the header is larger than a single block. */
if|if
condition|(
name|num_blocks
operator|>
name|variance_blocks
operator|+
operator|(
name|is_sslv3
condition|?
literal|1
else|:
literal|0
operator|)
condition|)
block|{
name|num_starting_blocks
operator|=
name|num_blocks
operator|-
name|variance_blocks
expr_stmt|;
name|k
operator|=
name|md_block_size
operator|*
name|num_starting_blocks
expr_stmt|;
block|}
name|bits
operator|=
literal|8
operator|*
name|mac_end_offset
expr_stmt|;
if|if
condition|(
operator|!
name|is_sslv3
condition|)
block|{
comment|/* Compute the initial HMAC block. For SSLv3, the padding and 		 * secret bytes are included in |header| because they take more 		 * than a single block. */
name|bits
operator|+=
literal|8
operator|*
name|md_block_size
expr_stmt|;
name|memset
argument_list|(
name|hmac_pad
argument_list|,
literal|0
argument_list|,
name|md_block_size
argument_list|)
expr_stmt|;
name|OPENSSL_assert
argument_list|(
name|mac_secret_length
operator|<=
sizeof|sizeof
argument_list|(
name|hmac_pad
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hmac_pad
argument_list|,
name|mac_secret
argument_list|,
name|mac_secret_length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|md_block_size
condition|;
name|i
operator|++
control|)
name|hmac_pad
index|[
name|i
index|]
operator|^=
literal|0x36
expr_stmt|;
name|md_transform
argument_list|(
name|md_state
operator|.
name|c
argument_list|,
name|hmac_pad
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length_is_big_endian
condition|)
block|{
name|memset
argument_list|(
name|length_bytes
argument_list|,
literal|0
argument_list|,
name|md_length_size
operator|-
literal|4
argument_list|)
expr_stmt|;
name|length_bytes
index|[
name|md_length_size
operator|-
literal|4
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|bits
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|length_bytes
index|[
name|md_length_size
operator|-
literal|3
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|bits
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|length_bytes
index|[
name|md_length_size
operator|-
literal|2
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|bits
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|length_bytes
index|[
name|md_length_size
operator|-
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|bits
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|length_bytes
argument_list|,
literal|0
argument_list|,
name|md_length_size
argument_list|)
expr_stmt|;
name|length_bytes
index|[
name|md_length_size
operator|-
literal|5
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|bits
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|length_bytes
index|[
name|md_length_size
operator|-
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|bits
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|length_bytes
index|[
name|md_length_size
operator|-
literal|7
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|bits
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|length_bytes
index|[
name|md_length_size
operator|-
literal|8
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|bits
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|is_sslv3
condition|)
block|{
comment|/* The SSLv3 header is larger than a single block. 			 * overhang is the number of bytes beyond a single 			 * block that the header consumes: either 7 bytes 			 * (SHA1) or 11 bytes (MD5). */
name|unsigned
name|overhang
init|=
name|header_length
operator|-
name|md_block_size
decl_stmt|;
name|md_transform
argument_list|(
name|md_state
operator|.
name|c
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|first_block
argument_list|,
name|header
operator|+
name|md_block_size
argument_list|,
name|overhang
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|first_block
operator|+
name|overhang
argument_list|,
name|data
argument_list|,
name|md_block_size
operator|-
name|overhang
argument_list|)
expr_stmt|;
name|md_transform
argument_list|(
name|md_state
operator|.
name|c
argument_list|,
name|first_block
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|k
operator|/
name|md_block_size
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|md_transform
argument_list|(
name|md_state
operator|.
name|c
argument_list|,
name|data
operator|+
name|md_block_size
operator|*
name|i
operator|-
name|overhang
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* k is a multiple of md_block_size. */
name|memcpy
argument_list|(
name|first_block
argument_list|,
name|header
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|first_block
operator|+
literal|13
argument_list|,
name|data
argument_list|,
name|md_block_size
operator|-
literal|13
argument_list|)
expr_stmt|;
name|md_transform
argument_list|(
name|md_state
operator|.
name|c
argument_list|,
name|first_block
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|k
operator|/
name|md_block_size
condition|;
name|i
operator|++
control|)
name|md_transform
argument_list|(
name|md_state
operator|.
name|c
argument_list|,
name|data
operator|+
name|md_block_size
operator|*
name|i
operator|-
literal|13
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
name|mac_out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mac_out
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We now process the final hash blocks. For each block, we construct 	 * it in constant time. If the |i==index_a| then we'll include the 0x80 	 * bytes and zero pad etc. For each block we selectively copy it, in 	 * constant time, to |mac_out|. */
for|for
control|(
name|i
operator|=
name|num_starting_blocks
init|;
name|i
operator|<=
name|num_starting_blocks
operator|+
name|variance_blocks
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|block
index|[
name|MAX_HASH_BLOCK_SIZE
index|]
decl_stmt|;
name|unsigned
name|char
name|is_block_a
init|=
name|constant_time_eq_8
argument_list|(
name|i
argument_list|,
name|index_a
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|is_block_b
init|=
name|constant_time_eq_8
argument_list|(
name|i
argument_list|,
name|index_b
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|md_block_size
condition|;
name|j
operator|++
control|)
block|{
name|unsigned
name|char
name|b
init|=
literal|0
decl_stmt|,
name|is_past_c
decl_stmt|,
name|is_past_cp1
decl_stmt|;
if|if
condition|(
name|k
operator|<
name|header_length
condition|)
name|b
operator|=
name|header
index|[
name|k
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|<
name|data_plus_mac_plus_padding_size
operator|+
name|header_length
condition|)
name|b
operator|=
name|data
index|[
name|k
operator|-
name|header_length
index|]
expr_stmt|;
name|k
operator|++
expr_stmt|;
name|is_past_c
operator|=
name|is_block_a
operator|&
name|constant_time_ge_8
argument_list|(
name|j
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|is_past_cp1
operator|=
name|is_block_a
operator|&
name|constant_time_ge_8
argument_list|(
name|j
argument_list|,
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* If this is the block containing the end of the 			 * application data, and we are at the offset for the 			 * 0x80 value, then overwrite b with 0x80. */
name|b
operator|=
name|constant_time_select_8
argument_list|(
name|is_past_c
argument_list|,
literal|0x80
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* If this the the block containing the end of the 			 * application data and we're past the 0x80 value then 			 * just write zero. */
name|b
operator|=
name|b
operator|&
operator|~
name|is_past_cp1
expr_stmt|;
comment|/* If this is index_b (the final block), but not 			 * index_a (the end of the data), then the 64-bit 			 * length didn't fit into index_a and we're having to 			 * add an extra block of zeros. */
name|b
operator|&=
operator|~
name|is_block_b
operator||
name|is_block_a
expr_stmt|;
comment|/* The final bytes of one of the blocks contains the 			 * length. */
if|if
condition|(
name|j
operator|>=
name|md_block_size
operator|-
name|md_length_size
condition|)
block|{
comment|/* If this is index_b, write a length byte. */
name|b
operator|=
name|constant_time_select_8
argument_list|(
name|is_block_b
argument_list|,
name|length_bytes
index|[
name|j
operator|-
operator|(
name|md_block_size
operator|-
name|md_length_size
operator|)
index|]
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|block
index|[
name|j
index|]
operator|=
name|b
expr_stmt|;
block|}
name|md_transform
argument_list|(
name|md_state
operator|.
name|c
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|md_final_raw
argument_list|(
name|md_state
operator|.
name|c
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* If this is index_b, copy the hash value to |mac_out|. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|md_size
condition|;
name|j
operator|++
control|)
name|mac_out
index|[
name|j
index|]
operator||=
name|block
index|[
name|j
index|]
operator|&
name|is_block_b
expr_stmt|;
block|}
name|EVP_MD_CTX_init
argument_list|(
operator|&
name|md_ctx
argument_list|)
expr_stmt|;
name|EVP_DigestInit_ex
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|digest
argument_list|,
name|NULL
comment|/* engine */
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_sslv3
condition|)
block|{
comment|/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */
name|memset
argument_list|(
name|hmac_pad
argument_list|,
literal|0x5c
argument_list|,
name|sslv3_pad_length
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|mac_secret
argument_list|,
name|mac_secret_length
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|hmac_pad
argument_list|,
name|sslv3_pad_length
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|mac_out
argument_list|,
name|md_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Complete the HMAC in the standard manner. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|md_block_size
condition|;
name|i
operator|++
control|)
name|hmac_pad
index|[
name|i
index|]
operator|^=
literal|0x6a
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|hmac_pad
argument_list|,
name|md_block_size
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|mac_out
argument_list|,
name|md_size
argument_list|)
expr_stmt|;
block|}
name|EVP_DigestFinal
argument_list|(
operator|&
name|md_ctx
argument_list|,
name|md_out
argument_list|,
operator|&
name|md_out_size_u
argument_list|)
expr_stmt|;
if|if
condition|(
name|md_out_size
condition|)
operator|*
name|md_out_size
operator|=
name|md_out_size_u
expr_stmt|;
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|md_ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
end_ifdef

begin_comment
comment|/* Due to the need to use EVP in FIPS mode we can't reimplement digests but  * we can ensure the number of blocks processed is equal for all cases  * by digesting additional data.  */
end_comment

begin_function
name|void
name|tls_fips_digest_extra
parameter_list|(
specifier|const
name|EVP_CIPHER_CTX
modifier|*
name|cipher_ctx
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
name|hash
parameter_list|,
name|HMAC_CTX
modifier|*
name|hctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|data_len
parameter_list|,
name|size_t
name|orig_len
parameter_list|)
block|{
name|size_t
name|block_size
decl_stmt|,
name|digest_pad
decl_stmt|,
name|blocks_data
decl_stmt|,
name|blocks_orig
decl_stmt|;
if|if
condition|(
name|EVP_CIPHER_CTX_mode
argument_list|(
name|cipher_ctx
argument_list|)
operator|!=
name|EVP_CIPH_CBC_MODE
condition|)
return|return;
name|block_size
operator|=
name|EVP_MD_block_size
argument_list|(
name|hash
argument_list|)
expr_stmt|;
comment|/* We are in FIPS mode if we get this far so we know we have only SHA* 	 * digests and TLS to deal with. 	 * Minimum digest padding length is 17 for SHA384/SHA512 and 9 	 * otherwise. 	 * Additional header is 13 bytes. To get the number of digest blocks 	 * processed round up the amount of data plus padding to the nearest 	 * block length. Block length is 128 for SHA384/SHA512 and 64 otherwise. 	 * So we have: 	 * blocks = (payload_len + digest_pad + 13 + block_size - 1)/block_size 	 * equivalently: 	 * blocks = (payload_len + digest_pad + 12)/block_size + 1 	 * HMAC adds a constant overhead. 	 * We're ultimately only interested in differences so this becomes 	 * blocks = (payload_len + 29)/128 	 * for SHA384/SHA512 and 	 * blocks = (payload_len + 21)/64 	 * otherwise. 	 */
name|digest_pad
operator|=
name|block_size
operator|==
literal|64
condition|?
literal|21
else|:
literal|29
expr_stmt|;
name|blocks_orig
operator|=
operator|(
name|orig_len
operator|+
name|digest_pad
operator|)
operator|/
name|block_size
expr_stmt|;
name|blocks_data
operator|=
operator|(
name|data_len
operator|+
name|digest_pad
operator|)
operator|/
name|block_size
expr_stmt|;
comment|/* MAC enough blocks to make up the difference between the original 	 * and actual lengths plus one extra block to ensure this is never a 	 * no op. The "data" pointer should always have enough space to 	 * perform this operation as it is large enough for a maximum 	 * length TLS buffer.  	 */
name|HMAC_Update
argument_list|(
name|hctx
argument_list|,
name|data
argument_list|,
operator|(
name|blocks_orig
operator|-
name|blocks_data
operator|+
literal|1
operator|)
operator|*
name|block_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

