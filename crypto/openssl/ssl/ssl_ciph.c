begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ssl/ssl_ciph.c */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *   * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *   * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from   *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *   * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/comp.h>
end_include

begin_include
include|#
directive|include
file|"ssl_locl.h"
end_include

begin_define
define|#
directive|define
name|SSL_ENC_DES_IDX
value|0
end_define

begin_define
define|#
directive|define
name|SSL_ENC_3DES_IDX
value|1
end_define

begin_define
define|#
directive|define
name|SSL_ENC_RC4_IDX
value|2
end_define

begin_define
define|#
directive|define
name|SSL_ENC_RC2_IDX
value|3
end_define

begin_define
define|#
directive|define
name|SSL_ENC_IDEA_IDX
value|4
end_define

begin_define
define|#
directive|define
name|SSL_ENC_eFZA_IDX
value|5
end_define

begin_define
define|#
directive|define
name|SSL_ENC_NULL_IDX
value|6
end_define

begin_define
define|#
directive|define
name|SSL_ENC_NUM_IDX
value|7
end_define

begin_decl_stmt
specifier|static
specifier|const
name|EVP_CIPHER
modifier|*
name|ssl_cipher_methods
index|[
name|SSL_ENC_NUM_IDX
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|, 	}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|STACK_OF
argument_list|(
name|SSL_COMP
argument_list|)
operator|*
name|ssl_comp_methods
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SSL_MD_MD5_IDX
value|0
end_define

begin_define
define|#
directive|define
name|SSL_MD_SHA1_IDX
value|1
end_define

begin_define
define|#
directive|define
name|SSL_MD_NUM_IDX
value|2
end_define

begin_decl_stmt
specifier|static
specifier|const
name|EVP_MD
modifier|*
name|ssl_digest_methods
index|[
name|SSL_MD_NUM_IDX
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|, 	}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|cipher_sort_st
block|{
name|SSL_CIPHER
modifier|*
name|cipher
decl_stmt|;
name|int
name|pref
decl_stmt|;
block|}
name|CIPHER_SORT
typedef|;
end_typedef

begin_define
define|#
directive|define
name|CIPHER_ADD
value|1
end_define

begin_define
define|#
directive|define
name|CIPHER_KILL
value|2
end_define

begin_define
define|#
directive|define
name|CIPHER_DEL
value|3
end_define

begin_define
define|#
directive|define
name|CIPHER_ORD
value|4
end_define

begin_typedef
typedef|typedef
struct|struct
name|cipher_choice_st
block|{
name|int
name|type
decl_stmt|;
name|unsigned
name|long
name|algorithms
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|long
name|top
decl_stmt|;
block|}
name|CIPHER_CHOICE
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|cipher_order_st
block|{
name|SSL_CIPHER
modifier|*
name|cipher
decl_stmt|;
name|int
name|active
decl_stmt|;
name|int
name|dead
decl_stmt|;
name|struct
name|cipher_order_st
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
block|}
name|CIPHER_ORDER
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|SSL_CIPHER
name|cipher_aliases
index|[]
init|=
block|{
comment|/* Don't include eNULL unless specifically enabled */
block|{
literal|0
block|,
name|SSL_TXT_ALL
block|,
literal|0
block|,
name|SSL_ALL
operator|&
operator|~
name|SSL_eNULL
block|,
literal|0
block|,
name|SSL_ALL
block|}
block|,
comment|/* must be first */
block|{
literal|0
block|,
name|SSL_TXT_kRSA
block|,
literal|0
block|,
name|SSL_kRSA
block|,
literal|0
block|,
name|SSL_MKEY_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kDHr
block|,
literal|0
block|,
name|SSL_kDHr
block|,
literal|0
block|,
name|SSL_MKEY_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kDHd
block|,
literal|0
block|,
name|SSL_kDHd
block|,
literal|0
block|,
name|SSL_MKEY_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kEDH
block|,
literal|0
block|,
name|SSL_kEDH
block|,
literal|0
block|,
name|SSL_MKEY_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kFZA
block|,
literal|0
block|,
name|SSL_kFZA
block|,
literal|0
block|,
name|SSL_MKEY_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_DH
block|,
literal|0
block|,
name|SSL_DH
block|,
literal|0
block|,
name|SSL_MKEY_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_EDH
block|,
literal|0
block|,
name|SSL_EDH
block|,
literal|0
block|,
name|SSL_MKEY_MASK
operator||
name|SSL_AUTH_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aRSA
block|,
literal|0
block|,
name|SSL_aRSA
block|,
literal|0
block|,
name|SSL_AUTH_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aDSS
block|,
literal|0
block|,
name|SSL_aDSS
block|,
literal|0
block|,
name|SSL_AUTH_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aFZA
block|,
literal|0
block|,
name|SSL_aFZA
block|,
literal|0
block|,
name|SSL_AUTH_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aNULL
block|,
literal|0
block|,
name|SSL_aNULL
block|,
literal|0
block|,
name|SSL_AUTH_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aDH
block|,
literal|0
block|,
name|SSL_aDH
block|,
literal|0
block|,
name|SSL_AUTH_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_DSS
block|,
literal|0
block|,
name|SSL_DSS
block|,
literal|0
block|,
name|SSL_AUTH_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_DES
block|,
literal|0
block|,
name|SSL_DES
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_3DES
block|,
literal|0
block|,
name|SSL_3DES
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_RC4
block|,
literal|0
block|,
name|SSL_RC4
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_RC2
block|,
literal|0
block|,
name|SSL_RC2
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_IDEA
block|,
literal|0
block|,
name|SSL_IDEA
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_eNULL
block|,
literal|0
block|,
name|SSL_eNULL
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_eFZA
block|,
literal|0
block|,
name|SSL_eFZA
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_MD5
block|,
literal|0
block|,
name|SSL_MD5
block|,
literal|0
block|,
name|SSL_MAC_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_SHA1
block|,
literal|0
block|,
name|SSL_SHA1
block|,
literal|0
block|,
name|SSL_MAC_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_SHA
block|,
literal|0
block|,
name|SSL_SHA
block|,
literal|0
block|,
name|SSL_MAC_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_NULL
block|,
literal|0
block|,
name|SSL_NULL
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_RSA
block|,
literal|0
block|,
name|SSL_RSA
block|,
literal|0
block|,
name|SSL_AUTH_MASK
operator||
name|SSL_MKEY_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_ADH
block|,
literal|0
block|,
name|SSL_ADH
block|,
literal|0
block|,
name|SSL_AUTH_MASK
operator||
name|SSL_MKEY_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_FZA
block|,
literal|0
block|,
name|SSL_FZA
block|,
literal|0
block|,
name|SSL_AUTH_MASK
operator||
name|SSL_MKEY_MASK
operator||
name|SSL_ENC_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_EXP40
block|,
literal|0
block|,
name|SSL_EXP40
block|,
literal|0
block|,
name|SSL_EXP_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_EXPORT
block|,
literal|0
block|,
name|SSL_EXP40
block|,
literal|0
block|,
name|SSL_EXP_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_EXP56
block|,
literal|0
block|,
name|SSL_EXP56
block|,
literal|0
block|,
name|SSL_EXP_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_SSLV2
block|,
literal|0
block|,
name|SSL_SSLV2
block|,
literal|0
block|,
name|SSL_SSL_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_SSLV3
block|,
literal|0
block|,
name|SSL_SSLV3
block|,
literal|0
block|,
name|SSL_SSL_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_TLSV1
block|,
literal|0
block|,
name|SSL_TLSV1
block|,
literal|0
block|,
name|SSL_SSL_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_LOW
block|,
literal|0
block|,
name|SSL_LOW
block|,
literal|0
block|,
name|SSL_STRONG_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_MEDIUM
block|,
literal|0
block|,
name|SSL_MEDIUM
block|,
literal|0
block|,
name|SSL_STRONG_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_HIGH
block|,
literal|0
block|,
name|SSL_HIGH
block|,
literal|0
block|,
name|SSL_STRONG_MASK
block|}
block|, 	}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_ciphers
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|load_ciphers
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|cmp_by_name
parameter_list|(
name|SSL_CIPHER
modifier|*
modifier|*
name|a
parameter_list|,
name|SSL_CIPHER
modifier|*
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|strcmp
argument_list|(
operator|(
operator|*
name|a
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|load_ciphers
parameter_list|(
name|void
parameter_list|)
block|{
name|init_ciphers
operator|=
literal|0
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_DES_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_des_cbc
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_3DES_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_des_ede3_cbc
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_RC4_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_rc4
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_RC2_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_rc2_cbc
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_IDEA_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_idea_cbc
argument_list|)
expr_stmt|;
name|ssl_digest_methods
index|[
name|SSL_MD_MD5_IDX
index|]
operator|=
name|EVP_get_digestbyname
argument_list|(
name|SN_md5
argument_list|)
expr_stmt|;
name|ssl_digest_methods
index|[
name|SSL_MD_SHA1_IDX
index|]
operator|=
name|EVP_get_digestbyname
argument_list|(
name|SN_sha1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ssl_cipher_get_evp
parameter_list|(
name|SSL_SESSION
modifier|*
name|s
parameter_list|,
specifier|const
name|EVP_CIPHER
modifier|*
modifier|*
name|enc
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
modifier|*
name|md
parameter_list|,
name|SSL_COMP
modifier|*
modifier|*
name|comp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|SSL_CIPHER
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|s
operator|->
name|cipher
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|comp
operator|!=
name|NULL
condition|)
block|{
name|SSL_COMP
name|ctmp
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|compress_meth
operator|==
literal|0
condition|)
operator|*
name|comp
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|ssl_comp_methods
operator|==
name|NULL
condition|)
block|{
comment|/* bad */
operator|*
name|comp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ctmp
operator|.
name|id
operator|=
name|s
operator|->
name|compress_meth
expr_stmt|;
name|i
operator|=
name|sk_SSL_COMP_find
argument_list|(
name|ssl_comp_methods
argument_list|,
operator|&
name|ctmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
operator|*
name|comp
operator|=
name|sk_SSL_COMP_value
argument_list|(
name|ssl_comp_methods
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
operator|*
name|comp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|enc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|md
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|c
operator|->
name|algorithms
operator|&
name|SSL_ENC_MASK
condition|)
block|{
case|case
name|SSL_DES
case|:
name|i
operator|=
name|SSL_ENC_DES_IDX
expr_stmt|;
break|break;
case|case
name|SSL_3DES
case|:
name|i
operator|=
name|SSL_ENC_3DES_IDX
expr_stmt|;
break|break;
case|case
name|SSL_RC4
case|:
name|i
operator|=
name|SSL_ENC_RC4_IDX
expr_stmt|;
break|break;
case|case
name|SSL_RC2
case|:
name|i
operator|=
name|SSL_ENC_RC2_IDX
expr_stmt|;
break|break;
case|case
name|SSL_IDEA
case|:
name|i
operator|=
name|SSL_ENC_IDEA_IDX
expr_stmt|;
break|break;
case|case
name|SSL_eNULL
case|:
name|i
operator|=
name|SSL_ENC_NULL_IDX
expr_stmt|;
break|break;
default|default:
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|>
name|SSL_ENC_NUM_IDX
operator|)
condition|)
operator|*
name|enc
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|i
operator|==
name|SSL_ENC_NULL_IDX
condition|)
operator|*
name|enc
operator|=
name|EVP_enc_null
argument_list|()
expr_stmt|;
else|else
operator|*
name|enc
operator|=
name|ssl_cipher_methods
index|[
name|i
index|]
expr_stmt|;
block|}
switch|switch
condition|(
name|c
operator|->
name|algorithms
operator|&
name|SSL_MAC_MASK
condition|)
block|{
case|case
name|SSL_MD5
case|:
name|i
operator|=
name|SSL_MD_MD5_IDX
expr_stmt|;
break|break;
case|case
name|SSL_SHA1
case|:
name|i
operator|=
name|SSL_MD_SHA1_IDX
expr_stmt|;
break|break;
default|default:
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|>
name|SSL_MD_NUM_IDX
operator|)
condition|)
operator|*
name|md
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|md
operator|=
name|ssl_digest_methods
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|enc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|md
operator|!=
name|NULL
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ITEM_SEP
parameter_list|(
name|a
parameter_list|)
define|\
value|(((a) == ':') || ((a) == ' ') || ((a) == ';') || ((a) == ','))
end_define

begin_function
specifier|static
name|void
name|ll_append_tail
parameter_list|(
name|CIPHER_ORDER
modifier|*
modifier|*
name|head
parameter_list|,
name|CIPHER_ORDER
modifier|*
name|curr
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
if|if
condition|(
name|curr
operator|==
operator|*
name|tail
condition|)
return|return;
if|if
condition|(
name|curr
operator|==
operator|*
name|head
condition|)
operator|*
name|head
operator|=
name|curr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|curr
operator|->
name|prev
operator|->
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|next
operator|!=
name|NULL
condition|)
comment|/* should always be true */
name|curr
operator|->
name|next
operator|->
name|prev
operator|=
name|curr
operator|->
name|prev
expr_stmt|;
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|curr
expr_stmt|;
name|curr
operator|->
name|prev
operator|=
operator|*
name|tail
expr_stmt|;
name|curr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|tail
operator|=
name|curr
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|ssl_create_cipher_list
argument_list|(
argument|SSL_METHOD *ssl_method
argument_list|,
argument|STACK_OF(SSL_CIPHER) **cipher_list
argument_list|,
argument|STACK_OF(SSL_CIPHER) **cipher_list_by_id
argument_list|,
argument|char *str
argument_list|)
block|{
name|SSL_CIPHER
operator|*
name|c
block|;
name|char
operator|*
name|l
block|;
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|ret
operator|=
name|NULL
block|,
operator|*
name|ok
operator|=
name|NULL
block|;
define|#
directive|define
name|CL_BUF
value|40
name|char
name|buf
index|[
name|CL_BUF
index|]
block|;
name|char
operator|*
name|tmp_str
operator|=
name|NULL
block|;
name|unsigned
name|long
name|mask
block|,
name|algorithms
block|,
name|ma
block|;
name|char
operator|*
name|start
block|;
name|int
name|i
block|,
name|j
block|,
name|k
block|,
name|num
operator|=
literal|0
block|,
name|ch
block|,
name|multi
block|;
name|unsigned
name|long
name|al
block|;
name|STACK
operator|*
name|ca_list
operator|=
name|NULL
block|;
name|int
name|current_x
block|,
name|num_x
block|;
name|CIPHER_CHOICE
operator|*
name|ops
operator|=
name|NULL
block|;
name|CIPHER_ORDER
operator|*
name|list
operator|=
name|NULL
block|,
operator|*
name|head
operator|=
name|NULL
block|,
operator|*
name|tail
operator|=
name|NULL
block|,
operator|*
name|curr
block|,
operator|*
name|tail2
block|,
operator|*
name|curr2
block|;
name|int
name|list_num
block|;
name|int
name|type
block|;
name|SSL_CIPHER
name|c_tmp
block|,
operator|*
name|cp
block|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"DEFAULT"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|SSL_DEFAULT_CIPHER_LIST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp_str
operator|=
name|Malloc
argument_list|(
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_CREATE_CIPHER_LIST
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|strcpy
argument_list|(
name|tmp_str
argument_list|,
name|SSL_DEFAULT_CIPHER_LIST
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_str
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_str
argument_list|,
operator|&
operator|(
name|str
index|[
literal|7
index|]
operator|)
argument_list|)
expr_stmt|;
name|str
operator|=
name|tmp_str
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|init_ciphers
condition|)
name|load_ciphers
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
name|num
operator|=
name|ssl_method
operator|->
name|num_ciphers
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|ret
operator|=
name|sk_SSL_CIPHER_new
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
end_if

begin_if
if|if
condition|(
operator|(
name|ca_list
operator|=
operator|(
name|STACK
operator|*
operator|)
name|sk_new
argument_list|(
name|cmp_by_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
end_if

begin_expr_stmt
name|mask
operator|=
name|SSL_kFZA
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NO_RSA
end_ifdef

begin_expr_stmt
name|mask
operator||=
name|SSL_aRSA
operator||
name|SSL_kRSA
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_DSA
end_ifdef

begin_expr_stmt
name|mask
operator||=
name|SSL_aDSS
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_DH
end_ifdef

begin_expr_stmt
name|mask
operator||=
name|SSL_kDHr
operator||
name|SSL_kDHd
operator||
name|SSL_kEDH
operator||
name|SSL_aDH
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SSL_FORBID_ENULL
end_ifdef

begin_expr_stmt
name|mask
operator||=
name|SSL_eNULL
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|mask
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_DES_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_DES
else|:
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mask
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_3DES_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_3DES
else|:
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mask
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_RC4_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_RC4
else|:
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mask
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_RC2_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_RC2
else|:
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mask
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_IDEA_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_IDEA
else|:
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mask
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_eFZA_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_eFZA
else|:
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mask
operator||=
operator|(
name|ssl_digest_methods
index|[
name|SSL_MD_MD5_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_MD5
else|:
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mask
operator||=
operator|(
name|ssl_digest_methods
index|[
name|SSL_MD_SHA1_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_SHA1
else|:
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|list
operator|=
operator|(
name|CIPHER_ORDER
operator|*
operator|)
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CIPHER_ORDER
argument_list|)
operator|*
name|num
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
end_if

begin_comment
comment|/* Get the initial list of ciphers */
end_comment

begin_expr_stmt
name|list_num
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|ssl_method
operator|->
name|get_cipher
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
comment|/* drop those that use any of that is not available */
if|if
condition|(
operator|(
name|c
operator|!=
name|NULL
operator|)
operator|&&
name|c
operator|->
name|valid
operator|&&
operator|!
operator|(
name|c
operator|->
name|algorithms
operator|&
name|mask
operator|)
condition|)
block|{
name|list
index|[
name|list_num
index|]
operator|.
name|cipher
operator|=
name|c
expr_stmt|;
name|list
index|[
name|list_num
index|]
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|list
index|[
name|list_num
index|]
operator|.
name|prev
operator|=
name|NULL
expr_stmt|;
name|list
index|[
name|list_num
index|]
operator|.
name|active
operator|=
literal|0
expr_stmt|;
name|list_num
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|sk_push
argument_list|(
name|ca_list
argument_list|,
operator|(
name|char
operator|*
operator|)
name|c
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
block|}
end_for

begin_for
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|list_num
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|list
index|[
name|i
index|]
operator|.
name|prev
operator|=
operator|&
operator|(
name|list
index|[
name|i
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|list
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|&
operator|(
name|list
index|[
name|i
operator|+
literal|1
index|]
operator|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
name|list_num
operator|>
literal|0
condition|)
block|{
name|head
operator|=
operator|&
operator|(
name|list
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|head
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|head
operator|->
name|next
operator|=
operator|&
operator|(
name|list
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|tail
operator|=
operator|&
operator|(
name|list
index|[
name|list_num
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|tail
operator|->
name|prev
operator|=
operator|&
operator|(
name|list
index|[
name|list_num
operator|-
literal|2
index|]
operator|)
expr_stmt|;
name|tail
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_if

begin_comment
comment|/* special case */
end_comment

begin_expr_stmt
name|cipher_aliases
index|[
literal|0
index|]
operator|.
name|algorithms
operator|&=
operator|~
name|mask
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* get the aliases */
end_comment

begin_expr_stmt
name|k
operator|=
sizeof|sizeof
argument_list|(
name|cipher_aliases
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|SSL_CIPHER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
name|al
operator|=
name|cipher_aliases
index|[
name|j
index|]
operator|.
name|algorithms
expr_stmt|;
comment|/* Drop those that are not relevent */
if|if
condition|(
operator|(
name|al
operator|&
name|mask
operator|)
operator|==
name|al
condition|)
continue|continue;
if|if
condition|(
operator|!
name|sk_push
argument_list|(
name|ca_list
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|cipher_aliases
index|[
name|j
index|]
operator|)
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
end_for

begin_comment
comment|/* ca_list now holds a 'stack' of SSL_CIPHERS, some real, some 	 * 'aliases' */
end_comment

begin_comment
comment|/* how many parameters are there? */
end_comment

begin_expr_stmt
name|num
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|l
operator|=
name|str
init|;
operator|*
name|l
condition|;
name|l
operator|++
control|)
if|if
condition|(
name|ITEM_SEP
argument_list|(
operator|*
name|l
argument_list|)
condition|)
name|num
operator|++
expr_stmt|;
end_for

begin_expr_stmt
name|ops
operator|=
operator|(
name|CIPHER_CHOICE
operator|*
operator|)
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CIPHER_CHOICE
argument_list|)
operator|*
name|num
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ops
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
end_if

begin_expr_stmt
name|memset
argument_list|(
name|ops
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|CIPHER_CHOICE
argument_list|)
operator|*
name|num
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* we now parse the input string and create our operations */
end_comment

begin_expr_stmt
name|l
operator|=
name|str
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|i
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|current_x
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
operator|*
name|l
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|ch
operator|==
literal|'-'
condition|)
block|{
name|j
operator|=
name|CIPHER_DEL
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
name|j
operator|=
name|CIPHER_ORD
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'!'
condition|)
block|{
name|j
operator|=
name|CIPHER_KILL
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
else|else
block|{
name|j
operator|=
name|CIPHER_ADD
expr_stmt|;
block|}
if|if
condition|(
name|ITEM_SEP
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|l
operator|++
expr_stmt|;
continue|continue;
block|}
name|ops
index|[
name|current_x
index|]
operator|.
name|type
operator|=
name|j
expr_stmt|;
name|ops
index|[
name|current_x
index|]
operator|.
name|algorithms
operator|=
literal|0
expr_stmt|;
name|ops
index|[
name|current_x
index|]
operator|.
name|mask
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|l
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
operator|*
name|l
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|CHARSET_EBCDIC
while|while
condition|(
operator|(
operator|(
name|ch
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'Z'
operator|)
operator|)
operator|||
operator|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'z'
operator|)
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'-'
operator|)
condition|)
else|#
directive|else
while|while
condition|(
name|isalnum
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|ch
operator|==
literal|'-'
operator|)
condition|)
endif|#
directive|endif
block|{
name|buf
index|[
name|i
index|]
operator|=
name|ch
expr_stmt|;
name|ch
operator|=
operator|*
operator|(
operator|++
name|l
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
operator|(
name|CL_BUF
operator|-
literal|2
operator|)
condition|)
break|break;
block|}
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* check for multi-part specification */
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
name|multi
operator|=
literal|1
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
else|else
name|multi
operator|=
literal|0
expr_stmt|;
name|c_tmp
operator|.
name|name
operator|=
name|buf
expr_stmt|;
name|j
operator|=
name|sk_find
argument_list|(
name|ca_list
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|c_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
goto|goto
name|end_loop
goto|;
name|cp
operator|=
operator|(
name|SSL_CIPHER
operator|*
operator|)
name|sk_value
argument_list|(
name|ca_list
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ops
index|[
name|current_x
index|]
operator|.
name|algorithms
operator||=
name|cp
operator|->
name|algorithms
expr_stmt|;
comment|/* We add the SSL_SSL_MASK so we can match the 			 * SSLv2 and SSLv3 versions of RC4-MD5 */
name|ops
index|[
name|current_x
index|]
operator|.
name|mask
operator||=
name|cp
operator|->
name|mask
expr_stmt|;
if|if
condition|(
operator|!
name|multi
condition|)
break|break;
block|}
name|current_x
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
break|break;
name|end_loop
label|:
comment|/* Make sure we scan until the next valid start point */
while|while
condition|(
operator|(
operator|*
name|l
operator|!=
literal|'\0'
operator|)
operator|&&
name|ITEM_SEP
argument_list|(
operator|*
name|l
argument_list|)
condition|)
name|l
operator|++
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|num_x
operator|=
name|current_x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|current_x
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* We will now process the list of ciphers, once for each category, to 	 * decide what we should do with it. */
end_comment

begin_for
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_x
condition|;
name|j
operator|++
control|)
block|{
name|algorithms
operator|=
name|ops
index|[
name|j
index|]
operator|.
name|algorithms
expr_stmt|;
name|type
operator|=
name|ops
index|[
name|j
index|]
operator|.
name|type
expr_stmt|;
name|mask
operator|=
name|ops
index|[
name|j
index|]
operator|.
name|mask
expr_stmt|;
name|curr
operator|=
name|head
expr_stmt|;
name|curr2
operator|=
name|head
expr_stmt|;
name|tail2
operator|=
name|tail
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|curr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|curr
operator|==
name|tail2
operator|)
condition|)
break|break;
name|curr
operator|=
name|curr2
expr_stmt|;
name|curr2
operator|=
name|curr
operator|->
name|next
expr_stmt|;
name|cp
operator|=
name|curr
operator|->
name|cipher
expr_stmt|;
name|ma
operator|=
name|mask
operator|&
name|cp
operator|->
name|algorithms
expr_stmt|;
if|if
condition|(
operator|(
name|ma
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|ma
operator|&
name|algorithms
operator|)
operator|!=
name|ma
operator|)
condition|)
block|{
comment|/* does not apply */
continue|continue;
block|}
comment|/* add the cipher if it has not been added yet. */
if|if
condition|(
name|type
operator|==
name|CIPHER_ADD
condition|)
block|{
if|if
condition|(
operator|!
name|curr
operator|->
name|active
condition|)
block|{
name|ll_append_tail
argument_list|(
operator|&
name|head
argument_list|,
name|curr
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|curr
operator|->
name|active
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Move the added cipher to this location */
elseif|else
if|if
condition|(
name|type
operator|==
name|CIPHER_ORD
condition|)
block|{
if|if
condition|(
name|curr
operator|->
name|active
condition|)
block|{
name|ll_append_tail
argument_list|(
operator|&
name|head
argument_list|,
name|curr
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|CIPHER_DEL
condition|)
name|curr
operator|->
name|active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CIPHER_KILL
condition|)
block|{
if|if
condition|(
name|head
operator|==
name|curr
condition|)
name|head
operator|=
name|curr
operator|->
name|next
expr_stmt|;
else|else
name|curr
operator|->
name|prev
operator|->
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|curr
condition|)
name|tail
operator|=
name|curr
operator|->
name|prev
expr_stmt|;
name|curr
operator|->
name|active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|next
operator|!=
name|NULL
condition|)
name|curr
operator|->
name|next
operator|->
name|prev
operator|=
name|curr
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|curr
operator|->
name|prev
operator|->
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
name|curr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|curr
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_for

begin_for
for|for
control|(
name|curr
operator|=
name|head
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|curr
operator|->
name|active
condition|)
block|{
name|sk_SSL_CIPHER_push
argument_list|(
name|ret
argument_list|,
name|curr
operator|->
name|cipher
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CIPHER_DEBUG
name|printf
argument_list|(
literal|"<%s>\n"
argument_list|,
name|curr
operator|->
name|cipher
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_for

begin_if
if|if
condition|(
name|cipher_list
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|cipher_list
operator|!=
name|NULL
condition|)
name|sk_SSL_CIPHER_free
argument_list|(
operator|*
name|cipher_list
argument_list|)
expr_stmt|;
operator|*
name|cipher_list
operator|=
name|ret
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|cipher_list_by_id
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|cipher_list_by_id
operator|!=
name|NULL
condition|)
name|sk_SSL_CIPHER_free
argument_list|(
operator|*
name|cipher_list_by_id
argument_list|)
expr_stmt|;
operator|*
name|cipher_list_by_id
operator|=
name|sk_SSL_CIPHER_dup
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|(
name|cipher_list_by_id
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|cipher_list_by_id
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cipher_list
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|cipher_list
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|err
goto|;
end_if

begin_expr_stmt
name|sk_SSL_CIPHER_set_cmp_func
argument_list|(
operator|*
name|cipher_list_by_id
argument_list|,
name|ssl_cipher_ptr_id_cmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ok
operator|=
name|ret
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ret
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_label
name|err
label|:
end_label

begin_if
if|if
condition|(
name|tmp_str
condition|)
name|Free
argument_list|(
name|tmp_str
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|ops
operator|!=
name|NULL
condition|)
name|Free
argument_list|(
name|ops
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|sk_SSL_CIPHER_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|ca_list
operator|!=
name|NULL
condition|)
name|sk_free
argument_list|(
name|ca_list
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
name|Free
argument_list|(
name|list
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
operator|(
name|ok
operator|)
return|;
end_return

begin_expr_stmt
unit|}  char
operator|*
name|SSL_CIPHER_description
argument_list|(
argument|SSL_CIPHER *cipher
argument_list|,
argument|char *buf
argument_list|,
argument|int len
argument_list|)
block|{
name|int
name|is_export
block|,
name|pkl
block|,
name|kl
block|;
name|char
operator|*
name|ver
block|,
operator|*
name|exp
block|;
name|char
operator|*
name|kx
block|,
operator|*
name|au
block|,
operator|*
name|enc
block|,
operator|*
name|mac
block|;
name|unsigned
name|long
name|alg
block|,
name|alg2
block|;
specifier|static
name|char
operator|*
name|format
operator|=
literal|"%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s%s\n"
block|;
name|alg
operator|=
name|cipher
operator|->
name|algorithms
block|;
name|alg2
operator|=
name|cipher
operator|->
name|algorithm2
block|;
name|is_export
operator|=
name|SSL_IS_EXPORT
argument_list|(
name|alg
argument_list|)
block|;
name|pkl
operator|=
name|SSL_EXPORT_PKEYLENGTH
argument_list|(
name|alg
argument_list|)
block|;
name|kl
operator|=
name|SSL_EXPORT_KEYLENGTH
argument_list|(
name|alg
argument_list|)
block|;
name|exp
operator|=
name|is_export
condition|?
literal|" export"
else|:
literal|""
block|;
if|if
condition|(
name|alg
operator|&
name|SSL_SSLV2
condition|)
name|ver
operator|=
literal|"SSLv2"
expr_stmt|;
elseif|else
if|if
condition|(
name|alg
operator|&
name|SSL_SSLV3
condition|)
name|ver
operator|=
literal|"SSLv3"
expr_stmt|;
else|else
name|ver
operator|=
literal|"unknown"
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|alg
operator|&
name|SSL_MKEY_MASK
condition|)
block|{
case|case
name|SSL_kRSA
case|:
name|kx
operator|=
name|is_export
condition|?
operator|(
name|pkl
operator|==
literal|512
condition|?
literal|"RSA(512)"
else|:
literal|"RSA(1024)"
operator|)
else|:
literal|"RSA"
expr_stmt|;
break|break;
case|case
name|SSL_kDHr
case|:
name|kx
operator|=
literal|"DH/RSA"
expr_stmt|;
break|break;
case|case
name|SSL_kDHd
case|:
name|kx
operator|=
literal|"DH/DSS"
expr_stmt|;
break|break;
case|case
name|SSL_kFZA
case|:
name|kx
operator|=
literal|"Fortezza"
expr_stmt|;
break|break;
case|case
name|SSL_kEDH
case|:
name|kx
operator|=
name|is_export
condition|?
operator|(
name|pkl
operator|==
literal|512
condition|?
literal|"DH(512)"
else|:
literal|"DH(1024)"
operator|)
else|:
literal|"DH"
expr_stmt|;
break|break;
default|default:
name|kx
operator|=
literal|"unknown"
expr_stmt|;
block|}
end_switch

begin_switch
switch|switch
condition|(
name|alg
operator|&
name|SSL_AUTH_MASK
condition|)
block|{
case|case
name|SSL_aRSA
case|:
name|au
operator|=
literal|"RSA"
expr_stmt|;
break|break;
case|case
name|SSL_aDSS
case|:
name|au
operator|=
literal|"DSS"
expr_stmt|;
break|break;
case|case
name|SSL_aDH
case|:
name|au
operator|=
literal|"DH"
expr_stmt|;
break|break;
case|case
name|SSL_aFZA
case|:
case|case
name|SSL_aNULL
case|:
name|au
operator|=
literal|"None"
expr_stmt|;
break|break;
default|default:
name|au
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
end_switch

begin_switch
switch|switch
condition|(
name|alg
operator|&
name|SSL_ENC_MASK
condition|)
block|{
case|case
name|SSL_DES
case|:
name|enc
operator|=
operator|(
name|is_export
operator|&&
name|kl
operator|==
literal|5
operator|)
condition|?
literal|"DES(40)"
else|:
literal|"DES(56)"
expr_stmt|;
break|break;
case|case
name|SSL_3DES
case|:
name|enc
operator|=
literal|"3DES(168)"
expr_stmt|;
break|break;
case|case
name|SSL_RC4
case|:
name|enc
operator|=
name|is_export
condition|?
operator|(
name|kl
operator|==
literal|5
condition|?
literal|"RC4(40)"
else|:
literal|"RC4(56)"
operator|)
else|:
operator|(
operator|(
name|alg2
operator|&
name|SSL2_CF_8_BYTE_ENC
operator|)
condition|?
literal|"RC4(64)"
else|:
literal|"RC4(128)"
operator|)
expr_stmt|;
break|break;
case|case
name|SSL_RC2
case|:
name|enc
operator|=
name|is_export
condition|?
operator|(
name|kl
operator|==
literal|5
condition|?
literal|"RC2(40)"
else|:
literal|"RC2(56)"
operator|)
else|:
literal|"RC2(128)"
expr_stmt|;
break|break;
case|case
name|SSL_IDEA
case|:
name|enc
operator|=
literal|"IDEA(128)"
expr_stmt|;
break|break;
case|case
name|SSL_eFZA
case|:
name|enc
operator|=
literal|"Fortezza"
expr_stmt|;
break|break;
case|case
name|SSL_eNULL
case|:
name|enc
operator|=
literal|"None"
expr_stmt|;
break|break;
default|default:
name|enc
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
end_switch

begin_switch
switch|switch
condition|(
name|alg
operator|&
name|SSL_MAC_MASK
condition|)
block|{
case|case
name|SSL_MD5
case|:
name|mac
operator|=
literal|"MD5"
expr_stmt|;
break|break;
case|case
name|SSL_SHA1
case|:
name|mac
operator|=
literal|"SHA1"
expr_stmt|;
break|break;
default|default:
name|mac
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
end_switch

begin_if
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|buf
operator|=
name|Malloc
argument_list|(
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"Malloc Error"
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<
literal|128
condition|)
return|return
operator|(
literal|"Buffer too small"
operator|)
return|;
end_if

begin_expr_stmt
name|sprintf
argument_list|(
name|buf
argument_list|,
name|format
argument_list|,
name|cipher
operator|->
name|name
argument_list|,
name|ver
argument_list|,
name|kx
argument_list|,
name|au
argument_list|,
name|enc
argument_list|,
name|mac
argument_list|,
name|exp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|buf
operator|)
return|;
end_return

begin_expr_stmt
unit|}  char
operator|*
name|SSL_CIPHER_get_version
argument_list|(
argument|SSL_CIPHER *c
argument_list|)
block|{
name|int
name|i
block|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"(NONE)"
operator|)
return|;
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|c
operator|->
name|id
operator|>>
literal|24L
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|i
operator|==
literal|3
condition|)
return|return
operator|(
literal|"TLSv1/SSLv3"
operator|)
return|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|2
condition|)
return|return
operator|(
literal|"SSLv2"
operator|)
return|;
else|else
return|return
operator|(
literal|"unknown"
operator|)
return|;
end_if

begin_comment
unit|}
comment|/* return the actual cipher being used */
end_comment

begin_function
unit|const
name|char
modifier|*
name|SSL_CIPHER_get_name
parameter_list|(
name|SSL_CIPHER
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
return|return
operator|(
name|c
operator|->
name|name
operator|)
return|;
return|return
operator|(
literal|"(NONE)"
operator|)
return|;
block|}
end_function

begin_comment
comment|/* number of bits for symetric cipher */
end_comment

begin_function
name|int
name|SSL_CIPHER_get_bits
parameter_list|(
name|SSL_CIPHER
modifier|*
name|c
parameter_list|,
name|int
modifier|*
name|alg_bits
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|a
init|=
literal|0
decl_stmt|;
specifier|const
name|EVP_CIPHER
modifier|*
name|enc
decl_stmt|;
specifier|const
name|EVP_MD
modifier|*
name|md
decl_stmt|;
name|SSL_SESSION
name|ss
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
name|ss
operator|.
name|cipher
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_cipher_get_evp
argument_list|(
operator|&
name|ss
argument_list|,
operator|&
name|enc
argument_list|,
operator|&
name|md
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|a
operator|=
name|EVP_CIPHER_key_length
argument_list|(
name|enc
argument_list|)
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|SSL_C_IS_EXPORT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|ret
operator|=
name|SSL_C_EXPORT_KEYLENGTH
argument_list|(
name|c
argument_list|)
operator|*
literal|8
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|algorithm2
operator|&
name|SSL2_CF_8_BYTE_ENC
condition|)
name|ret
operator|=
literal|64
expr_stmt|;
else|else
name|ret
operator|=
name|a
expr_stmt|;
block|}
block|}
if|if
condition|(
name|alg_bits
operator|!=
name|NULL
condition|)
operator|*
name|alg_bits
operator|=
name|a
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|SSL_COMP
modifier|*
name|ssl3_comp_find
argument_list|(
name|STACK_OF
argument_list|(
name|SSL_COMP
argument_list|)
operator|*
name|sk
argument_list|,
name|int
name|n
argument_list|)
block|{
name|SSL_COMP
modifier|*
name|ctmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nn
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|==
literal|0
operator|)
operator|||
operator|(
name|sk
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|nn
operator|=
name|sk_SSL_COMP_num
argument_list|(
name|sk
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nn
condition|;
name|i
operator|++
control|)
block|{
name|ctmp
operator|=
name|sk_SSL_COMP_value
argument_list|(
name|sk
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctmp
operator|->
name|id
operator|==
name|n
condition|)
return|return
operator|(
name|ctmp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|sk_comp_cmp
parameter_list|(
name|SSL_COMP
modifier|*
modifier|*
name|a
parameter_list|,
name|SSL_COMP
modifier|*
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|*
name|a
operator|)
operator|->
name|id
operator|-
operator|(
operator|*
name|b
operator|)
operator|->
name|id
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|STACK_OF
argument_list|(
name|SSL_COMP
argument_list|)
operator|*
name|SSL_COMP_get_compression_methods
argument_list|(
argument|void
argument_list|)
block|{
return|return
operator|(
name|ssl_comp_methods
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|int
name|SSL_COMP_add_compression_method
parameter_list|(
name|int
name|id
parameter_list|,
name|COMP_METHOD
modifier|*
name|cm
parameter_list|)
block|{
name|SSL_COMP
modifier|*
name|comp
decl_stmt|;
name|STACK_OF
argument_list|(
name|SSL_COMP
argument_list|)
operator|*
name|sk
expr_stmt|;
name|comp
operator|=
operator|(
name|SSL_COMP
operator|*
operator|)
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SSL_COMP
argument_list|)
argument_list|)
expr_stmt|;
name|comp
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|comp
operator|->
name|method
operator|=
name|cm
expr_stmt|;
if|if
condition|(
name|ssl_comp_methods
operator|==
name|NULL
condition|)
name|sk
operator|=
name|ssl_comp_methods
operator|=
name|sk_SSL_COMP_new
argument_list|(
name|sk_comp_cmp
argument_list|)
expr_stmt|;
else|else
name|sk
operator|=
name|ssl_comp_methods
expr_stmt|;
if|if
condition|(
operator|(
name|sk
operator|==
name|NULL
operator|)
operator|||
operator|!
name|sk_SSL_COMP_push
argument_list|(
name|sk
argument_list|,
name|comp
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

