begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ssl/ssl_ciph.c */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *   * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *   * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from   *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *   * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.  * ECC cipher suite support in OpenSSL originally developed by   * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/comp.h>
end_include

begin_include
include|#
directive|include
file|"ssl_locl.h"
end_include

begin_define
define|#
directive|define
name|SSL_ENC_DES_IDX
value|0
end_define

begin_define
define|#
directive|define
name|SSL_ENC_3DES_IDX
value|1
end_define

begin_define
define|#
directive|define
name|SSL_ENC_RC4_IDX
value|2
end_define

begin_define
define|#
directive|define
name|SSL_ENC_RC2_IDX
value|3
end_define

begin_define
define|#
directive|define
name|SSL_ENC_IDEA_IDX
value|4
end_define

begin_define
define|#
directive|define
name|SSL_ENC_eFZA_IDX
value|5
end_define

begin_define
define|#
directive|define
name|SSL_ENC_NULL_IDX
value|6
end_define

begin_define
define|#
directive|define
name|SSL_ENC_AES128_IDX
value|7
end_define

begin_define
define|#
directive|define
name|SSL_ENC_AES256_IDX
value|8
end_define

begin_define
define|#
directive|define
name|SSL_ENC_NUM_IDX
value|9
end_define

begin_define
define|#
directive|define
name|SSL_ENC_CAMELLIA128_IDX
value|9
end_define

begin_define
define|#
directive|define
name|SSL_ENC_CAMELLIA256_IDX
value|10
end_define

begin_undef
undef|#
directive|undef
name|SSL_ENC_NUM_IDX
end_undef

begin_define
define|#
directive|define
name|SSL_ENC_NUM_IDX
value|11
end_define

begin_decl_stmt
specifier|static
specifier|const
name|EVP_CIPHER
modifier|*
name|ssl_cipher_methods
index|[
name|SSL_ENC_NUM_IDX
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|, 	}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SSL_COMP_NULL_IDX
value|0
end_define

begin_define
define|#
directive|define
name|SSL_COMP_ZLIB_IDX
value|1
end_define

begin_define
define|#
directive|define
name|SSL_COMP_NUM_IDX
value|2
end_define

begin_expr_stmt
specifier|static
name|STACK_OF
argument_list|(
name|SSL_COMP
argument_list|)
operator|*
name|ssl_comp_methods
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SSL_MD_MD5_IDX
value|0
end_define

begin_define
define|#
directive|define
name|SSL_MD_SHA1_IDX
value|1
end_define

begin_define
define|#
directive|define
name|SSL_MD_NUM_IDX
value|2
end_define

begin_decl_stmt
specifier|static
specifier|const
name|EVP_MD
modifier|*
name|ssl_digest_methods
index|[
name|SSL_MD_NUM_IDX
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|, 	}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CIPHER_ADD
value|1
end_define

begin_define
define|#
directive|define
name|CIPHER_KILL
value|2
end_define

begin_define
define|#
directive|define
name|CIPHER_DEL
value|3
end_define

begin_define
define|#
directive|define
name|CIPHER_ORD
value|4
end_define

begin_define
define|#
directive|define
name|CIPHER_SPECIAL
value|5
end_define

begin_typedef
typedef|typedef
struct|struct
name|cipher_order_st
block|{
name|SSL_CIPHER
modifier|*
name|cipher
decl_stmt|;
name|int
name|active
decl_stmt|;
name|int
name|dead
decl_stmt|;
name|struct
name|cipher_order_st
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
block|}
name|CIPHER_ORDER
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|SSL_CIPHER
name|cipher_aliases
index|[]
init|=
block|{
comment|/* Don't include eNULL unless specifically enabled. */
comment|/* Don't include ECC in ALL because these ciphers are not yet official. */
block|{
literal|0
block|,
name|SSL_TXT_ALL
block|,
literal|0
block|,
name|SSL_ALL
operator|&
operator|~
name|SSL_eNULL
operator|&
operator|~
name|SSL_kECDH
operator|&
operator|~
name|SSL_kECDHE
block|,
name|SSL_ALL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_ALL
block|,
name|SSL_ALL
block|}
block|,
comment|/* must be first */
comment|/* TODO: COMPLEMENT OF ALL and COMPLEMENT OF DEFAULT do not have ECC cipher suites handled properly. */
block|{
literal|0
block|,
name|SSL_TXT_CMPALL
block|,
literal|0
block|,
name|SSL_eNULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|,
literal|0
block|}
block|,
comment|/* COMPLEMENT OF ALL */
block|{
literal|0
block|,
name|SSL_TXT_CMPDEF
block|,
literal|0
block|,
name|SSL_ADH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AUTH_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kKRB5
block|,
literal|0
block|,
name|SSL_kKRB5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_MKEY_MASK
block|,
literal|0
block|}
block|,
comment|/* VRS Kerberos5 */
block|{
literal|0
block|,
name|SSL_TXT_kRSA
block|,
literal|0
block|,
name|SSL_kRSA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_MKEY_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kDHr
block|,
literal|0
block|,
name|SSL_kDHr
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_MKEY_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kDHd
block|,
literal|0
block|,
name|SSL_kDHd
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_MKEY_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kEDH
block|,
literal|0
block|,
name|SSL_kEDH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_MKEY_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kFZA
block|,
literal|0
block|,
name|SSL_kFZA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_MKEY_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_DH
block|,
literal|0
block|,
name|SSL_DH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_MKEY_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_ECC
block|,
literal|0
block|,
operator|(
name|SSL_kECDH
operator||
name|SSL_kECDHE
operator|)
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_MKEY_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_EDH
block|,
literal|0
block|,
name|SSL_EDH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_MKEY_MASK
operator||
name|SSL_AUTH_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aKRB5
block|,
literal|0
block|,
name|SSL_aKRB5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AUTH_MASK
block|,
literal|0
block|}
block|,
comment|/* VRS Kerberos5 */
block|{
literal|0
block|,
name|SSL_TXT_aRSA
block|,
literal|0
block|,
name|SSL_aRSA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AUTH_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aDSS
block|,
literal|0
block|,
name|SSL_aDSS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AUTH_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aFZA
block|,
literal|0
block|,
name|SSL_aFZA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AUTH_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aNULL
block|,
literal|0
block|,
name|SSL_aNULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AUTH_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aDH
block|,
literal|0
block|,
name|SSL_aDH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AUTH_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_DSS
block|,
literal|0
block|,
name|SSL_DSS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AUTH_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_DES
block|,
literal|0
block|,
name|SSL_DES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_3DES
block|,
literal|0
block|,
name|SSL_3DES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_RC4
block|,
literal|0
block|,
name|SSL_RC4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_RC2
block|,
literal|0
block|,
name|SSL_RC2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|,
literal|0
block|}
block|,
ifndef|#
directive|ifndef
name|OPENSSL_NO_IDEA
block|{
literal|0
block|,
name|SSL_TXT_IDEA
block|,
literal|0
block|,
name|SSL_IDEA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
name|SSL_TXT_eNULL
block|,
literal|0
block|,
name|SSL_eNULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_eFZA
block|,
literal|0
block|,
name|SSL_eFZA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_AES
block|,
literal|0
block|,
name|SSL_AES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_CAMELLIA
block|,
literal|0
block|,
name|SSL_CAMELLIA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_MD5
block|,
literal|0
block|,
name|SSL_MD5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_MAC_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_SHA1
block|,
literal|0
block|,
name|SSL_SHA1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_MAC_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_SHA
block|,
literal|0
block|,
name|SSL_SHA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_MAC_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_NULL
block|,
literal|0
block|,
name|SSL_NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_ENC_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_KRB5
block|,
literal|0
block|,
name|SSL_KRB5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AUTH_MASK
operator||
name|SSL_MKEY_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_RSA
block|,
literal|0
block|,
name|SSL_RSA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AUTH_MASK
operator||
name|SSL_MKEY_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_ADH
block|,
literal|0
block|,
name|SSL_ADH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AUTH_MASK
operator||
name|SSL_MKEY_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_FZA
block|,
literal|0
block|,
name|SSL_FZA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AUTH_MASK
operator||
name|SSL_MKEY_MASK
operator||
name|SSL_ENC_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_SSLV2
block|,
literal|0
block|,
name|SSL_SSLV2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_SSL_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_SSLV3
block|,
literal|0
block|,
name|SSL_SSLV3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_SSL_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_TLSV1
block|,
literal|0
block|,
name|SSL_TLSV1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_SSL_MASK
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_EXP
block|,
literal|0
block|,
literal|0
block|,
name|SSL_EXPORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_EXP_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_EXPORT
block|,
literal|0
block|,
literal|0
block|,
name|SSL_EXPORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_EXP_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_EXP40
block|,
literal|0
block|,
literal|0
block|,
name|SSL_EXP40
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_STRONG_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_EXP56
block|,
literal|0
block|,
literal|0
block|,
name|SSL_EXP56
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_STRONG_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_LOW
block|,
literal|0
block|,
literal|0
block|,
name|SSL_LOW
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_STRONG_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_MEDIUM
block|,
literal|0
block|,
literal|0
block|,
name|SSL_MEDIUM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_STRONG_MASK
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_HIGH
block|,
literal|0
block|,
literal|0
block|,
name|SSL_HIGH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_STRONG_MASK
block|}
block|, 	}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ssl_load_ciphers
parameter_list|(
name|void
parameter_list|)
block|{
name|ssl_cipher_methods
index|[
name|SSL_ENC_DES_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_des_cbc
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_3DES_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_des_ede3_cbc
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_RC4_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_rc4
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_RC2_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_rc2_cbc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_IDEA
name|ssl_cipher_methods
index|[
name|SSL_ENC_IDEA_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_idea_cbc
argument_list|)
expr_stmt|;
else|#
directive|else
name|ssl_cipher_methods
index|[
name|SSL_ENC_IDEA_IDX
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|ssl_cipher_methods
index|[
name|SSL_ENC_AES128_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_aes_128_cbc
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_AES256_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_aes_256_cbc
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_CAMELLIA128_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_camellia_128_cbc
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_CAMELLIA256_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_camellia_256_cbc
argument_list|)
expr_stmt|;
name|ssl_digest_methods
index|[
name|SSL_MD_MD5_IDX
index|]
operator|=
name|EVP_get_digestbyname
argument_list|(
name|SN_md5
argument_list|)
expr_stmt|;
name|ssl_digest_methods
index|[
name|SSL_MD_SHA1_IDX
index|]
operator|=
name|EVP_get_digestbyname
argument_list|(
name|SN_sha1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_COMP
end_ifndef

begin_function
specifier|static
name|int
name|sk_comp_cmp
parameter_list|(
specifier|const
name|SSL_COMP
modifier|*
specifier|const
modifier|*
name|a
parameter_list|,
specifier|const
name|SSL_COMP
modifier|*
specifier|const
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|*
name|a
operator|)
operator|->
name|id
operator|-
operator|(
operator|*
name|b
operator|)
operator|->
name|id
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|load_builtin_compressions
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|got_write_lock
init|=
literal|0
decl_stmt|;
name|CRYPTO_r_lock
argument_list|(
name|CRYPTO_LOCK_SSL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl_comp_methods
operator|==
name|NULL
condition|)
block|{
name|CRYPTO_r_unlock
argument_list|(
name|CRYPTO_LOCK_SSL
argument_list|)
expr_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_SSL
argument_list|)
expr_stmt|;
name|got_write_lock
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ssl_comp_methods
operator|==
name|NULL
condition|)
block|{
name|SSL_COMP
modifier|*
name|comp
init|=
name|NULL
decl_stmt|;
name|MemCheck_off
argument_list|()
expr_stmt|;
name|ssl_comp_methods
operator|=
name|sk_SSL_COMP_new
argument_list|(
name|sk_comp_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl_comp_methods
operator|!=
name|NULL
condition|)
block|{
name|comp
operator|=
operator|(
name|SSL_COMP
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SSL_COMP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|!=
name|NULL
condition|)
block|{
name|comp
operator|->
name|method
operator|=
name|COMP_zlib
argument_list|()
expr_stmt|;
if|if
condition|(
name|comp
operator|->
name|method
operator|&&
name|comp
operator|->
name|method
operator|->
name|type
operator|==
name|NID_undef
condition|)
name|OPENSSL_free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
else|else
block|{
name|comp
operator|->
name|id
operator|=
name|SSL_COMP_ZLIB_IDX
expr_stmt|;
name|comp
operator|->
name|name
operator|=
name|comp
operator|->
name|method
operator|->
name|name
expr_stmt|;
name|sk_SSL_COMP_push
argument_list|(
name|ssl_comp_methods
argument_list|,
name|comp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|MemCheck_on
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|got_write_lock
condition|)
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_SSL
argument_list|)
expr_stmt|;
else|else
name|CRYPTO_r_unlock
argument_list|(
name|CRYPTO_LOCK_SSL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ssl_cipher_get_evp
parameter_list|(
specifier|const
name|SSL_SESSION
modifier|*
name|s
parameter_list|,
specifier|const
name|EVP_CIPHER
modifier|*
modifier|*
name|enc
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
modifier|*
name|md
parameter_list|,
name|SSL_COMP
modifier|*
modifier|*
name|comp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|SSL_CIPHER
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|s
operator|->
name|cipher
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|comp
operator|!=
name|NULL
condition|)
block|{
name|SSL_COMP
name|ctmp
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_COMP
name|load_builtin_compressions
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|*
name|comp
operator|=
name|NULL
expr_stmt|;
name|ctmp
operator|.
name|id
operator|=
name|s
operator|->
name|compress_meth
expr_stmt|;
if|if
condition|(
name|ssl_comp_methods
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
name|sk_SSL_COMP_find
argument_list|(
name|ssl_comp_methods
argument_list|,
operator|&
name|ctmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
operator|*
name|comp
operator|=
name|sk_SSL_COMP_value
argument_list|(
name|ssl_comp_methods
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
operator|*
name|comp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|enc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|md
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|c
operator|->
name|algorithms
operator|&
name|SSL_ENC_MASK
condition|)
block|{
case|case
name|SSL_DES
case|:
name|i
operator|=
name|SSL_ENC_DES_IDX
expr_stmt|;
break|break;
case|case
name|SSL_3DES
case|:
name|i
operator|=
name|SSL_ENC_3DES_IDX
expr_stmt|;
break|break;
case|case
name|SSL_RC4
case|:
name|i
operator|=
name|SSL_ENC_RC4_IDX
expr_stmt|;
break|break;
case|case
name|SSL_RC2
case|:
name|i
operator|=
name|SSL_ENC_RC2_IDX
expr_stmt|;
break|break;
case|case
name|SSL_IDEA
case|:
name|i
operator|=
name|SSL_ENC_IDEA_IDX
expr_stmt|;
break|break;
case|case
name|SSL_eNULL
case|:
name|i
operator|=
name|SSL_ENC_NULL_IDX
expr_stmt|;
break|break;
case|case
name|SSL_AES
case|:
switch|switch
condition|(
name|c
operator|->
name|alg_bits
condition|)
block|{
case|case
literal|128
case|:
name|i
operator|=
name|SSL_ENC_AES128_IDX
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|i
operator|=
name|SSL_ENC_AES256_IDX
expr_stmt|;
break|break;
default|default:
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SSL_CAMELLIA
case|:
switch|switch
condition|(
name|c
operator|->
name|alg_bits
condition|)
block|{
case|case
literal|128
case|:
name|i
operator|=
name|SSL_ENC_CAMELLIA128_IDX
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|i
operator|=
name|SSL_ENC_CAMELLIA256_IDX
expr_stmt|;
break|break;
default|default:
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|>
name|SSL_ENC_NUM_IDX
operator|)
condition|)
operator|*
name|enc
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|i
operator|==
name|SSL_ENC_NULL_IDX
condition|)
operator|*
name|enc
operator|=
name|EVP_enc_null
argument_list|()
expr_stmt|;
else|else
operator|*
name|enc
operator|=
name|ssl_cipher_methods
index|[
name|i
index|]
expr_stmt|;
block|}
switch|switch
condition|(
name|c
operator|->
name|algorithms
operator|&
name|SSL_MAC_MASK
condition|)
block|{
case|case
name|SSL_MD5
case|:
name|i
operator|=
name|SSL_MD_MD5_IDX
expr_stmt|;
break|break;
case|case
name|SSL_SHA1
case|:
name|i
operator|=
name|SSL_MD_SHA1_IDX
expr_stmt|;
break|break;
default|default:
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|>
name|SSL_MD_NUM_IDX
operator|)
condition|)
operator|*
name|md
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|md
operator|=
name|ssl_digest_methods
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|enc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|md
operator|!=
name|NULL
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ITEM_SEP
parameter_list|(
name|a
parameter_list|)
define|\
value|(((a) == ':') || ((a) == ' ') || ((a) == ';') || ((a) == ','))
end_define

begin_function
specifier|static
name|void
name|ll_append_tail
parameter_list|(
name|CIPHER_ORDER
modifier|*
modifier|*
name|head
parameter_list|,
name|CIPHER_ORDER
modifier|*
name|curr
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
if|if
condition|(
name|curr
operator|==
operator|*
name|tail
condition|)
return|return;
if|if
condition|(
name|curr
operator|==
operator|*
name|head
condition|)
operator|*
name|head
operator|=
name|curr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|curr
operator|->
name|prev
operator|->
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|next
operator|!=
name|NULL
condition|)
comment|/* should always be true */
name|curr
operator|->
name|next
operator|->
name|prev
operator|=
name|curr
operator|->
name|prev
expr_stmt|;
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|curr
expr_stmt|;
name|curr
operator|->
name|prev
operator|=
operator|*
name|tail
expr_stmt|;
name|curr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|tail
operator|=
name|curr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|ssl_cipher_get_disabled
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|mask
decl_stmt|;
name|mask
operator|=
name|SSL_kFZA
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL_NO_RSA
name|mask
operator||=
name|SSL_aRSA
operator||
name|SSL_kRSA
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL_NO_DSA
name|mask
operator||=
name|SSL_aDSS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL_NO_DH
name|mask
operator||=
name|SSL_kDHr
operator||
name|SSL_kDHd
operator||
name|SSL_kEDH
operator||
name|SSL_aDH
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL_NO_KRB5
name|mask
operator||=
name|SSL_kKRB5
operator||
name|SSL_aKRB5
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL_NO_ECDH
name|mask
operator||=
name|SSL_kECDH
operator||
name|SSL_kECDHE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SSL_FORBID_ENULL
name|mask
operator||=
name|SSL_eNULL
expr_stmt|;
endif|#
directive|endif
name|mask
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_DES_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_DES
else|:
literal|0
expr_stmt|;
name|mask
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_3DES_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_3DES
else|:
literal|0
expr_stmt|;
name|mask
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_RC4_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_RC4
else|:
literal|0
expr_stmt|;
name|mask
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_RC2_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_RC2
else|:
literal|0
expr_stmt|;
name|mask
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_IDEA_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_IDEA
else|:
literal|0
expr_stmt|;
name|mask
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_eFZA_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_eFZA
else|:
literal|0
expr_stmt|;
name|mask
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_AES128_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_AES
else|:
literal|0
expr_stmt|;
name|mask
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_CAMELLIA128_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_CAMELLIA
else|:
literal|0
expr_stmt|;
name|mask
operator||=
operator|(
name|ssl_digest_methods
index|[
name|SSL_MD_MD5_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_MD5
else|:
literal|0
expr_stmt|;
name|mask
operator||=
operator|(
name|ssl_digest_methods
index|[
name|SSL_MD_SHA1_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_SHA1
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ssl_cipher_collect_ciphers
parameter_list|(
specifier|const
name|SSL_METHOD
modifier|*
name|ssl_method
parameter_list|,
name|int
name|num_of_ciphers
parameter_list|,
name|unsigned
name|long
name|mask
parameter_list|,
name|CIPHER_ORDER
modifier|*
name|co_list
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|head_p
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|tail_p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|co_list_num
decl_stmt|;
name|SSL_CIPHER
modifier|*
name|c
decl_stmt|;
comment|/* 	 * We have num_of_ciphers descriptions compiled in, depending on the 	 * method selected (SSLv2 and/or SSLv3, TLSv1 etc). 	 * These will later be sorted in a linked list with at most num 	 * entries. 	 */
comment|/* Get the initial list of ciphers */
name|co_list_num
operator|=
literal|0
expr_stmt|;
comment|/* actual count of ciphers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_of_ciphers
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|ssl_method
operator|->
name|get_cipher
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* drop those that use any of that is not available */
if|if
condition|(
operator|(
name|c
operator|!=
name|NULL
operator|)
operator|&&
name|c
operator|->
name|valid
operator|&&
operator|!
operator|(
name|c
operator|->
name|algorithms
operator|&
name|mask
operator|)
condition|)
block|{
name|co_list
index|[
name|co_list_num
index|]
operator|.
name|cipher
operator|=
name|c
expr_stmt|;
name|co_list
index|[
name|co_list_num
index|]
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|co_list
index|[
name|co_list_num
index|]
operator|.
name|prev
operator|=
name|NULL
expr_stmt|;
name|co_list
index|[
name|co_list_num
index|]
operator|.
name|active
operator|=
literal|0
expr_stmt|;
name|co_list_num
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|KSSL_DEBUG
name|printf
argument_list|(
literal|"\t%d: %s %lx %lx\n"
argument_list|,
name|i
argument_list|,
name|c
operator|->
name|name
argument_list|,
name|c
operator|->
name|id
argument_list|,
name|c
operator|->
name|algorithms
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KSSL_DEBUG */
comment|/* 			if (!sk_push(ca_list,(char *)c)) goto err; 			*/
block|}
block|}
comment|/* 	 * Prepare linked list from list entries 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|co_list_num
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|co_list
index|[
name|i
index|]
operator|.
name|prev
operator|=
operator|&
operator|(
name|co_list
index|[
name|i
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|co_list
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|&
operator|(
name|co_list
index|[
name|i
operator|+
literal|1
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|co_list_num
operator|>
literal|0
condition|)
block|{
operator|(
operator|*
name|head_p
operator|)
operator|=
operator|&
operator|(
name|co_list
index|[
literal|0
index|]
operator|)
expr_stmt|;
operator|(
operator|*
name|head_p
operator|)
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|head_p
operator|)
operator|->
name|next
operator|=
operator|&
operator|(
name|co_list
index|[
literal|1
index|]
operator|)
expr_stmt|;
operator|(
operator|*
name|tail_p
operator|)
operator|=
operator|&
operator|(
name|co_list
index|[
name|co_list_num
operator|-
literal|1
index|]
operator|)
expr_stmt|;
operator|(
operator|*
name|tail_p
operator|)
operator|->
name|prev
operator|=
operator|&
operator|(
name|co_list
index|[
name|co_list_num
operator|-
literal|2
index|]
operator|)
expr_stmt|;
operator|(
operator|*
name|tail_p
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ssl_cipher_collect_aliases
parameter_list|(
name|SSL_CIPHER
modifier|*
modifier|*
name|ca_list
parameter_list|,
name|int
name|num_of_group_aliases
parameter_list|,
name|unsigned
name|long
name|mask
parameter_list|,
name|CIPHER_ORDER
modifier|*
name|head
parameter_list|)
block|{
name|CIPHER_ORDER
modifier|*
name|ciph_curr
decl_stmt|;
name|SSL_CIPHER
modifier|*
modifier|*
name|ca_curr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * First, add the real ciphers as already collected 	 */
name|ciph_curr
operator|=
name|head
expr_stmt|;
name|ca_curr
operator|=
name|ca_list
expr_stmt|;
while|while
condition|(
name|ciph_curr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ca_curr
operator|=
name|ciph_curr
operator|->
name|cipher
expr_stmt|;
name|ca_curr
operator|++
expr_stmt|;
name|ciph_curr
operator|=
name|ciph_curr
operator|->
name|next
expr_stmt|;
block|}
comment|/* 	 * Now we add the available ones from the cipher_aliases[] table. 	 * They represent either an algorithm, that must be fully 	 * supported (not match any bit in mask) or represent a cipher 	 * strength value (will be added in any case because algorithms=0). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_of_group_aliases
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
comment|/* always fetch "ALL" */
operator|!
operator|(
name|cipher_aliases
index|[
name|i
index|]
operator|.
name|algorithms
operator|&
name|mask
operator|)
condition|)
block|{
operator|*
name|ca_curr
operator|=
operator|(
name|SSL_CIPHER
operator|*
operator|)
operator|(
name|cipher_aliases
operator|+
name|i
operator|)
expr_stmt|;
name|ca_curr
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|ca_curr
operator|=
name|NULL
expr_stmt|;
comment|/* end of list */
block|}
end_function

begin_function
specifier|static
name|void
name|ssl_cipher_apply_rule
parameter_list|(
name|unsigned
name|long
name|cipher_id
parameter_list|,
name|unsigned
name|long
name|ssl_version
parameter_list|,
name|unsigned
name|long
name|algorithms
parameter_list|,
name|unsigned
name|long
name|mask
parameter_list|,
name|unsigned
name|long
name|algo_strength
parameter_list|,
name|unsigned
name|long
name|mask_strength
parameter_list|,
name|int
name|rule
parameter_list|,
name|int
name|strength_bits
parameter_list|,
name|CIPHER_ORDER
modifier|*
name|co_list
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|head_p
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|tail_p
parameter_list|)
block|{
name|CIPHER_ORDER
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|,
modifier|*
name|curr
decl_stmt|,
modifier|*
name|curr2
decl_stmt|,
modifier|*
name|tail2
decl_stmt|;
name|SSL_CIPHER
modifier|*
name|cp
decl_stmt|;
name|unsigned
name|long
name|ma
decl_stmt|,
name|ma_s
decl_stmt|;
ifdef|#
directive|ifdef
name|CIPHER_DEBUG
name|printf
argument_list|(
literal|"Applying rule %d with %08lx %08lx %08lx %08lx (%d)\n"
argument_list|,
name|rule
argument_list|,
name|algorithms
argument_list|,
name|mask
argument_list|,
name|algo_strength
argument_list|,
name|mask_strength
argument_list|,
name|strength_bits
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|curr
operator|=
name|head
operator|=
operator|*
name|head_p
expr_stmt|;
name|curr2
operator|=
name|head
expr_stmt|;
name|tail2
operator|=
name|tail
operator|=
operator|*
name|tail_p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|curr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|curr
operator|==
name|tail2
operator|)
condition|)
break|break;
name|curr
operator|=
name|curr2
expr_stmt|;
name|curr2
operator|=
name|curr
operator|->
name|next
expr_stmt|;
name|cp
operator|=
name|curr
operator|->
name|cipher
expr_stmt|;
comment|/* If explicit cipher suite, match only that one for its own protocol version. 		 * Usual selection criteria will be used for similar ciphersuites from other version! */
if|if
condition|(
name|cipher_id
operator|&&
operator|(
name|cp
operator|->
name|algorithms
operator|&
name|SSL_SSL_MASK
operator|)
operator|==
name|ssl_version
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|id
operator|!=
name|cipher_id
condition|)
continue|continue;
block|}
comment|/* 		 * Selection criteria is either the number of strength_bits 		 * or the algorithm used. 		 */
elseif|else
if|if
condition|(
name|strength_bits
operator|==
operator|-
literal|1
condition|)
block|{
name|ma
operator|=
name|mask
operator|&
name|cp
operator|->
name|algorithms
expr_stmt|;
name|ma_s
operator|=
name|mask_strength
operator|&
name|cp
operator|->
name|algo_strength
expr_stmt|;
ifdef|#
directive|ifdef
name|CIPHER_DEBUG
name|printf
argument_list|(
literal|"\nName: %s:\nAlgo = %08lx Algo_strength = %08lx\nMask = %08lx Mask_strength %08lx\n"
argument_list|,
name|cp
operator|->
name|name
argument_list|,
name|cp
operator|->
name|algorithms
argument_list|,
name|cp
operator|->
name|algo_strength
argument_list|,
name|mask
argument_list|,
name|mask_strength
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ma = %08lx ma_s %08lx, ma&algo=%08lx, ma_s&algos=%08lx\n"
argument_list|,
name|ma
argument_list|,
name|ma_s
argument_list|,
name|ma
operator|&
name|algorithms
argument_list|,
name|ma_s
operator|&
name|algo_strength
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Select: if none of the mask bit was met from the 			 * cipher or not all of the bits were met, the 			 * selection does not apply. 			 */
if|if
condition|(
operator|(
operator|(
name|ma
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ma_s
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|ma
operator|&
name|algorithms
operator|)
operator|!=
name|ma
operator|)
operator|||
operator|(
operator|(
name|ma_s
operator|&
name|algo_strength
operator|)
operator|!=
name|ma_s
operator|)
condition|)
continue|continue;
comment|/* does not apply */
block|}
elseif|else
if|if
condition|(
name|strength_bits
operator|!=
name|cp
operator|->
name|strength_bits
condition|)
continue|continue;
comment|/* does not apply */
ifdef|#
directive|ifdef
name|CIPHER_DEBUG
name|printf
argument_list|(
literal|"Action = %d\n"
argument_list|,
name|rule
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* add the cipher if it has not been added yet. */
if|if
condition|(
name|rule
operator|==
name|CIPHER_ADD
condition|)
block|{
if|if
condition|(
operator|!
name|curr
operator|->
name|active
condition|)
block|{
name|int
name|add_this_cipher
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|cp
operator|->
name|algorithms
operator|&
operator|(
name|SSL_kECDHE
operator||
name|SSL_kECDH
operator||
name|SSL_aECDSA
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Make sure "ECCdraft" ciphersuites are activated only if 					 * *explicitly* requested, but not implicitly (such as 					 * as part of the "AES" alias). */
name|add_this_cipher
operator|=
operator|(
name|mask
operator|&
operator|(
name|SSL_kECDHE
operator||
name|SSL_kECDH
operator||
name|SSL_aECDSA
operator|)
operator|)
operator|!=
literal|0
operator|||
name|cipher_id
operator|!=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|add_this_cipher
condition|)
block|{
name|ll_append_tail
argument_list|(
operator|&
name|head
argument_list|,
name|curr
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|curr
operator|->
name|active
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Move the added cipher to this location */
elseif|else
if|if
condition|(
name|rule
operator|==
name|CIPHER_ORD
condition|)
block|{
if|if
condition|(
name|curr
operator|->
name|active
condition|)
block|{
name|ll_append_tail
argument_list|(
operator|&
name|head
argument_list|,
name|curr
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rule
operator|==
name|CIPHER_DEL
condition|)
name|curr
operator|->
name|active
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|rule
operator|==
name|CIPHER_KILL
condition|)
block|{
if|if
condition|(
name|head
operator|==
name|curr
condition|)
name|head
operator|=
name|curr
operator|->
name|next
expr_stmt|;
else|else
name|curr
operator|->
name|prev
operator|->
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|curr
condition|)
name|tail
operator|=
name|curr
operator|->
name|prev
expr_stmt|;
name|curr
operator|->
name|active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|next
operator|!=
name|NULL
condition|)
name|curr
operator|->
name|next
operator|->
name|prev
operator|=
name|curr
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|curr
operator|->
name|prev
operator|->
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
name|curr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|curr
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
operator|*
name|head_p
operator|=
name|head
expr_stmt|;
operator|*
name|tail_p
operator|=
name|tail
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ssl_cipher_strength_sort
parameter_list|(
name|CIPHER_ORDER
modifier|*
name|co_list
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|head_p
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|tail_p
parameter_list|)
block|{
name|int
name|max_strength_bits
decl_stmt|,
name|i
decl_stmt|,
modifier|*
name|number_uses
decl_stmt|;
name|CIPHER_ORDER
modifier|*
name|curr
decl_stmt|;
comment|/* 	 * This routine sorts the ciphers with descending strength. The sorting 	 * must keep the pre-sorted sequence, so we apply the normal sorting 	 * routine as '+' movement to the end of the list. 	 */
name|max_strength_bits
operator|=
literal|0
expr_stmt|;
name|curr
operator|=
operator|*
name|head_p
expr_stmt|;
while|while
condition|(
name|curr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|curr
operator|->
name|active
operator|&&
operator|(
name|curr
operator|->
name|cipher
operator|->
name|strength_bits
operator|>
name|max_strength_bits
operator|)
condition|)
name|max_strength_bits
operator|=
name|curr
operator|->
name|cipher
operator|->
name|strength_bits
expr_stmt|;
name|curr
operator|=
name|curr
operator|->
name|next
expr_stmt|;
block|}
name|number_uses
operator|=
name|OPENSSL_malloc
argument_list|(
operator|(
name|max_strength_bits
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|number_uses
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_CIPHER_STRENGTH_SORT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
name|number_uses
argument_list|,
literal|0
argument_list|,
operator|(
name|max_strength_bits
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now find the strength_bits values actually used 	 */
name|curr
operator|=
operator|*
name|head_p
expr_stmt|;
while|while
condition|(
name|curr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|curr
operator|->
name|active
condition|)
name|number_uses
index|[
name|curr
operator|->
name|cipher
operator|->
name|strength_bits
index|]
operator|++
expr_stmt|;
name|curr
operator|=
name|curr
operator|->
name|next
expr_stmt|;
block|}
comment|/* 	 * Go through the list of used strength_bits values in descending 	 * order. 	 */
for|for
control|(
name|i
operator|=
name|max_strength_bits
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|number_uses
index|[
name|i
index|]
operator|>
literal|0
condition|)
name|ssl_cipher_apply_rule
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CIPHER_ORD
argument_list|,
name|i
argument_list|,
name|co_list
argument_list|,
name|head_p
argument_list|,
name|tail_p
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|number_uses
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ssl_cipher_process_rulestr
parameter_list|(
specifier|const
name|char
modifier|*
name|rule_str
parameter_list|,
name|CIPHER_ORDER
modifier|*
name|co_list
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|head_p
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|tail_p
parameter_list|,
name|SSL_CIPHER
modifier|*
modifier|*
name|ca_list
parameter_list|)
block|{
name|unsigned
name|long
name|algorithms
decl_stmt|,
name|mask
decl_stmt|,
name|algo_strength
decl_stmt|,
name|mask_strength
decl_stmt|;
specifier|const
name|char
modifier|*
name|l
decl_stmt|,
modifier|*
name|start
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|int
name|j
decl_stmt|,
name|multi
decl_stmt|,
name|found
decl_stmt|,
name|rule
decl_stmt|,
name|retval
decl_stmt|,
name|ok
decl_stmt|,
name|buflen
decl_stmt|;
name|unsigned
name|long
name|cipher_id
init|=
literal|0
decl_stmt|,
name|ssl_version
init|=
literal|0
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
name|l
operator|=
name|rule_str
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
operator|*
name|l
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
break|break;
comment|/* done */
if|if
condition|(
name|ch
operator|==
literal|'-'
condition|)
block|{
name|rule
operator|=
name|CIPHER_DEL
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
name|rule
operator|=
name|CIPHER_ORD
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'!'
condition|)
block|{
name|rule
operator|=
name|CIPHER_KILL
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'@'
condition|)
block|{
name|rule
operator|=
name|CIPHER_SPECIAL
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
else|else
block|{
name|rule
operator|=
name|CIPHER_ADD
expr_stmt|;
block|}
if|if
condition|(
name|ITEM_SEP
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|l
operator|++
expr_stmt|;
continue|continue;
block|}
name|algorithms
operator|=
name|mask
operator|=
name|algo_strength
operator|=
name|mask_strength
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|l
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
operator|*
name|l
expr_stmt|;
name|buf
operator|=
name|l
expr_stmt|;
name|buflen
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|CHARSET_EBCDIC
while|while
condition|(
operator|(
operator|(
name|ch
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'Z'
operator|)
operator|)
operator|||
operator|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'z'
operator|)
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'-'
operator|)
condition|)
else|#
directive|else
while|while
condition|(
name|isalnum
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|ch
operator|==
literal|'-'
operator|)
condition|)
endif|#
directive|endif
block|{
name|ch
operator|=
operator|*
operator|(
operator|++
name|l
operator|)
expr_stmt|;
name|buflen
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|buflen
operator|==
literal|0
condition|)
block|{
comment|/* 				 * We hit something we cannot deal with, 				 * it is no command or separator nor 				 * alphanumeric, so we call this an error. 				 */
name|SSLerr
argument_list|(
name|SSL_F_SSL_CIPHER_PROCESS_RULESTR
argument_list|,
name|SSL_R_INVALID_COMMAND
argument_list|)
expr_stmt|;
name|retval
operator|=
name|found
operator|=
literal|0
expr_stmt|;
name|l
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rule
operator|==
name|CIPHER_SPECIAL
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
comment|/* unused -- avoid compiler warning */
break|break;
comment|/* special treatment */
block|}
comment|/* check for multi-part specification */
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
name|multi
operator|=
literal|1
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
else|else
name|multi
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Now search for the cipher alias in the ca_list. Be careful 			 * with the strncmp, because the "buflen" limitation 			 * will make the rule "ADH:SOME" and the cipher 			 * "ADH-MY-CIPHER" look like a match for buflen=3. 			 * So additionally check whether the cipher name found 			 * has the correct length. We can save a strlen() call: 			 * just checking for the '\0' at the right place is 			 * sufficient, we have to strncmp() anyway. (We cannot 			 * use strcmp(), because buf is not '\0' terminated.) 			 */
name|j
operator|=
name|found
operator|=
literal|0
expr_stmt|;
name|cipher_id
operator|=
literal|0
expr_stmt|;
name|ssl_version
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ca_list
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
name|ca_list
index|[
name|j
index|]
operator|->
name|name
argument_list|,
name|buflen
argument_list|)
operator|&&
operator|(
name|ca_list
index|[
name|j
index|]
operator|->
name|name
index|[
name|buflen
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
break|break;
comment|/* ignore this entry */
comment|/* New algorithms: 			 *  1 - any old restrictions apply outside new mask 			 *  2 - any new restrictions apply outside old mask 			 *  3 - enforce old& new where masks intersect 			 */
name|algorithms
operator|=
operator|(
name|algorithms
operator|&
operator|~
name|ca_list
index|[
name|j
index|]
operator|->
name|mask
operator|)
operator||
comment|/* 1 */
operator|(
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithms
operator|&
operator|~
name|mask
operator|)
operator||
comment|/* 2 */
operator|(
name|algorithms
operator|&
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithms
operator|)
expr_stmt|;
comment|/* 3 */
name|mask
operator||=
name|ca_list
index|[
name|j
index|]
operator|->
name|mask
expr_stmt|;
name|algo_strength
operator|=
operator|(
name|algo_strength
operator|&
operator|~
name|ca_list
index|[
name|j
index|]
operator|->
name|mask_strength
operator|)
operator||
operator|(
name|ca_list
index|[
name|j
index|]
operator|->
name|algo_strength
operator|&
operator|~
name|mask_strength
operator|)
operator||
operator|(
name|algo_strength
operator|&
name|ca_list
index|[
name|j
index|]
operator|->
name|algo_strength
operator|)
expr_stmt|;
name|mask_strength
operator||=
name|ca_list
index|[
name|j
index|]
operator|->
name|mask_strength
expr_stmt|;
comment|/* explicit ciphersuite found */
if|if
condition|(
name|ca_list
index|[
name|j
index|]
operator|->
name|valid
condition|)
block|{
name|cipher_id
operator|=
name|ca_list
index|[
name|j
index|]
operator|->
name|id
expr_stmt|;
name|ssl_version
operator|=
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithms
operator|&
name|SSL_SSL_MASK
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|multi
condition|)
break|break;
block|}
comment|/* 		 * Ok, we have the rule, now apply it 		 */
if|if
condition|(
name|rule
operator|==
name|CIPHER_SPECIAL
condition|)
block|{
comment|/* special command */
name|ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|buflen
operator|==
literal|8
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"STRENGTH"
argument_list|,
literal|8
argument_list|)
condition|)
name|ok
operator|=
name|ssl_cipher_strength_sort
argument_list|(
name|co_list
argument_list|,
name|head_p
argument_list|,
name|tail_p
argument_list|)
expr_stmt|;
else|else
name|SSLerr
argument_list|(
name|SSL_F_SSL_CIPHER_PROCESS_RULESTR
argument_list|,
name|SSL_R_INVALID_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* 			 * We do not support any "multi" options 			 * together with "@", so throw away the 			 * rest of the command, if any left, until 			 * end or ':' is found. 			 */
while|while
condition|(
operator|(
operator|*
name|l
operator|!=
literal|'\0'
operator|)
operator|&&
name|ITEM_SEP
argument_list|(
operator|*
name|l
argument_list|)
condition|)
name|l
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found
condition|)
block|{
name|ssl_cipher_apply_rule
argument_list|(
name|cipher_id
argument_list|,
name|ssl_version
argument_list|,
name|algorithms
argument_list|,
name|mask
argument_list|,
name|algo_strength
argument_list|,
name|mask_strength
argument_list|,
name|rule
argument_list|,
operator|-
literal|1
argument_list|,
name|co_list
argument_list|,
name|head_p
argument_list|,
name|tail_p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
operator|*
name|l
operator|!=
literal|'\0'
operator|)
operator|&&
name|ITEM_SEP
argument_list|(
operator|*
name|l
argument_list|)
condition|)
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|l
operator|==
literal|'\0'
condition|)
break|break;
comment|/* done */
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|ssl_create_cipher_list
argument_list|(
argument|const SSL_METHOD *ssl_method
argument_list|,
argument|STACK_OF(SSL_CIPHER) **cipher_list
argument_list|,
argument|STACK_OF(SSL_CIPHER) **cipher_list_by_id
argument_list|,
argument|const char *rule_str
argument_list|)
block|{
name|int
name|ok
block|,
name|num_of_ciphers
block|,
name|num_of_alias_max
block|,
name|num_of_group_aliases
block|;
name|unsigned
name|long
name|disabled_mask
block|;
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|cipherstack
block|,
operator|*
name|tmp_cipher_list
block|;
specifier|const
name|char
operator|*
name|rule_p
block|;
name|CIPHER_ORDER
operator|*
name|co_list
operator|=
name|NULL
block|,
operator|*
name|head
operator|=
name|NULL
block|,
operator|*
name|tail
operator|=
name|NULL
block|,
operator|*
name|curr
block|;
name|SSL_CIPHER
operator|*
operator|*
name|ca_list
operator|=
name|NULL
block|;
comment|/* 	 * Return with error if nothing to do. 	 */
if|if
condition|(
name|rule_str
operator|==
name|NULL
operator|||
name|cipher_list
operator|==
name|NULL
operator|||
name|cipher_list_by_id
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* 	 * To reduce the work to do we only want to process the compiled 	 * in algorithms, so we first get the mask of disabled ciphers. 	 */
name|disabled_mask
operator|=
name|ssl_cipher_get_disabled
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Now we have to collect the available ciphers from the compiled 	 * in ciphers. We cannot get more than the number compiled in, so 	 * it is used for allocation. 	 */
end_comment

begin_expr_stmt
name|num_of_ciphers
operator|=
name|ssl_method
operator|->
name|num_ciphers
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KSSL_DEBUG
end_ifdef

begin_expr_stmt
name|printf
argument_list|(
literal|"ssl_create_cipher_list() for %d ciphers\n"
argument_list|,
name|num_of_ciphers
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KSSL_DEBUG */
end_comment

begin_expr_stmt
name|co_list
operator|=
operator|(
name|CIPHER_ORDER
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CIPHER_ORDER
argument_list|)
operator|*
name|num_of_ciphers
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|co_list
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_CREATE_CIPHER_LIST
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Failure */
block|}
end_if

begin_expr_stmt
name|ssl_cipher_collect_ciphers
argument_list|(
name|ssl_method
argument_list|,
name|num_of_ciphers
argument_list|,
name|disabled_mask
argument_list|,
name|co_list
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * We also need cipher aliases for selecting based on the rule_str. 	 * There might be two types of entries in the rule_str: 1) names 	 * of ciphers themselves 2) aliases for groups of ciphers. 	 * For 1) we need the available ciphers and for 2) the cipher 	 * groups of cipher_aliases added together in one list (otherwise 	 * we would be happy with just the cipher_aliases table). 	 */
end_comment

begin_expr_stmt
name|num_of_group_aliases
operator|=
sizeof|sizeof
argument_list|(
name|cipher_aliases
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|SSL_CIPHER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|num_of_alias_max
operator|=
name|num_of_ciphers
operator|+
name|num_of_group_aliases
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ca_list
operator|=
operator|(
name|SSL_CIPHER
operator|*
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SSL_CIPHER
operator|*
argument_list|)
operator|*
name|num_of_alias_max
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ca_list
operator|==
name|NULL
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|co_list
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL_CREATE_CIPHER_LIST
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Failure */
block|}
end_if

begin_expr_stmt
name|ssl_cipher_collect_aliases
argument_list|(
name|ca_list
argument_list|,
name|num_of_group_aliases
argument_list|,
name|disabled_mask
argument_list|,
name|head
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * If the rule_string begins with DEFAULT, apply the default rule 	 * before using the (possibly available) additional rules. 	 */
end_comment

begin_expr_stmt
name|ok
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rule_p
operator|=
name|rule_str
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|strncmp
argument_list|(
name|rule_str
argument_list|,
literal|"DEFAULT"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ok
operator|=
name|ssl_cipher_process_rulestr
argument_list|(
name|SSL_DEFAULT_CIPHER_LIST
argument_list|,
name|co_list
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|,
name|ca_list
argument_list|)
expr_stmt|;
name|rule_p
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
operator|*
name|rule_p
operator|==
literal|':'
condition|)
name|rule_p
operator|++
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|ok
operator|&&
operator|(
name|strlen
argument_list|(
name|rule_p
argument_list|)
operator|>
literal|0
operator|)
condition|)
name|ok
operator|=
name|ssl_cipher_process_rulestr
argument_list|(
name|rule_p
argument_list|,
name|co_list
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|,
name|ca_list
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|OPENSSL_free
argument_list|(
name|ca_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Not needed anymore */
end_comment

begin_if
if|if
condition|(
operator|!
name|ok
condition|)
block|{
comment|/* Rule processing failure */
name|OPENSSL_free
argument_list|(
name|co_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_if

begin_comment
comment|/* 	 * Allocate new "cipherstack" for the result, return with error 	 * if we cannot get one. 	 */
end_comment

begin_if
if|if
condition|(
operator|(
name|cipherstack
operator|=
name|sk_SSL_CIPHER_new_null
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|co_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_if

begin_comment
comment|/* 	 * The cipher selection for the list is done. The ciphers are added 	 * to the resulting precedence to the STACK_OF(SSL_CIPHER). 	 */
end_comment

begin_for
for|for
control|(
name|curr
operator|=
name|head
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|curr
operator|->
name|active
condition|)
block|{
name|sk_SSL_CIPHER_push
argument_list|(
name|cipherstack
argument_list|,
name|curr
operator|->
name|cipher
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CIPHER_DEBUG
name|printf
argument_list|(
literal|"<%s>\n"
argument_list|,
name|curr
operator|->
name|cipher
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_for

begin_expr_stmt
name|OPENSSL_free
argument_list|(
name|co_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Not needed any longer */
end_comment

begin_expr_stmt
name|tmp_cipher_list
operator|=
name|sk_SSL_CIPHER_dup
argument_list|(
name|cipherstack
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|tmp_cipher_list
operator|==
name|NULL
condition|)
block|{
name|sk_SSL_CIPHER_free
argument_list|(
name|cipherstack
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|*
name|cipher_list
operator|!=
name|NULL
condition|)
name|sk_SSL_CIPHER_free
argument_list|(
operator|*
name|cipher_list
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
operator|*
name|cipher_list
operator|=
name|cipherstack
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|cipher_list_by_id
operator|!=
name|NULL
condition|)
name|sk_SSL_CIPHER_free
argument_list|(
operator|*
name|cipher_list_by_id
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
operator|*
name|cipher_list_by_id
operator|=
name|tmp_cipher_list
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sk_SSL_CIPHER_set_cmp_func
argument_list|(
operator|*
name|cipher_list_by_id
argument_list|,
name|ssl_cipher_ptr_id_cmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|cipherstack
operator|)
return|;
end_return

begin_expr_stmt
unit|}  char
operator|*
name|SSL_CIPHER_description
argument_list|(
argument|SSL_CIPHER *cipher
argument_list|,
argument|char *buf
argument_list|,
argument|int len
argument_list|)
block|{
name|int
name|is_export
block|,
name|pkl
block|,
name|kl
block|;
specifier|const
name|char
operator|*
name|ver
block|,
operator|*
name|exp_str
block|;
specifier|const
name|char
operator|*
name|kx
block|,
operator|*
name|au
block|,
operator|*
name|enc
block|,
operator|*
name|mac
block|;
name|unsigned
name|long
name|alg
block|,
name|alg2
block|,
name|alg_s
block|;
ifdef|#
directive|ifdef
name|KSSL_DEBUG
specifier|static
specifier|const
name|char
operator|*
name|format
operator|=
literal|"%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s%s AL=%lx\n"
block|;
else|#
directive|else
specifier|static
specifier|const
name|char
operator|*
name|format
operator|=
literal|"%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s%s\n"
block|;
endif|#
directive|endif
comment|/* KSSL_DEBUG */
name|alg
operator|=
name|cipher
operator|->
name|algorithms
block|;
name|alg_s
operator|=
name|cipher
operator|->
name|algo_strength
block|;
name|alg2
operator|=
name|cipher
operator|->
name|algorithm2
block|;
name|is_export
operator|=
name|SSL_C_IS_EXPORT
argument_list|(
name|cipher
argument_list|)
block|;
name|pkl
operator|=
name|SSL_C_EXPORT_PKEYLENGTH
argument_list|(
name|cipher
argument_list|)
block|;
name|kl
operator|=
name|SSL_C_EXPORT_KEYLENGTH
argument_list|(
name|cipher
argument_list|)
block|;
name|exp_str
operator|=
name|is_export
condition|?
literal|" export"
else|:
literal|""
block|;
if|if
condition|(
name|alg
operator|&
name|SSL_SSLV2
condition|)
name|ver
operator|=
literal|"SSLv2"
expr_stmt|;
elseif|else
if|if
condition|(
name|alg
operator|&
name|SSL_SSLV3
condition|)
name|ver
operator|=
literal|"SSLv3"
expr_stmt|;
else|else
name|ver
operator|=
literal|"unknown"
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|alg
operator|&
name|SSL_MKEY_MASK
condition|)
block|{
case|case
name|SSL_kRSA
case|:
name|kx
operator|=
name|is_export
condition|?
operator|(
name|pkl
operator|==
literal|512
condition|?
literal|"RSA(512)"
else|:
literal|"RSA(1024)"
operator|)
else|:
literal|"RSA"
expr_stmt|;
break|break;
case|case
name|SSL_kDHr
case|:
name|kx
operator|=
literal|"DH/RSA"
expr_stmt|;
break|break;
case|case
name|SSL_kDHd
case|:
name|kx
operator|=
literal|"DH/DSS"
expr_stmt|;
break|break;
case|case
name|SSL_kKRB5
case|:
comment|/* VRS */
case|case
name|SSL_KRB5
case|:
comment|/* VRS */
name|kx
operator|=
literal|"KRB5"
expr_stmt|;
break|break;
case|case
name|SSL_kFZA
case|:
name|kx
operator|=
literal|"Fortezza"
expr_stmt|;
break|break;
case|case
name|SSL_kEDH
case|:
name|kx
operator|=
name|is_export
condition|?
operator|(
name|pkl
operator|==
literal|512
condition|?
literal|"DH(512)"
else|:
literal|"DH(1024)"
operator|)
else|:
literal|"DH"
expr_stmt|;
break|break;
case|case
name|SSL_kECDH
case|:
case|case
name|SSL_kECDHE
case|:
name|kx
operator|=
name|is_export
condition|?
literal|"ECDH(<=163)"
else|:
literal|"ECDH"
expr_stmt|;
break|break;
default|default:
name|kx
operator|=
literal|"unknown"
expr_stmt|;
block|}
end_switch

begin_switch
switch|switch
condition|(
name|alg
operator|&
name|SSL_AUTH_MASK
condition|)
block|{
case|case
name|SSL_aRSA
case|:
name|au
operator|=
literal|"RSA"
expr_stmt|;
break|break;
case|case
name|SSL_aDSS
case|:
name|au
operator|=
literal|"DSS"
expr_stmt|;
break|break;
case|case
name|SSL_aDH
case|:
name|au
operator|=
literal|"DH"
expr_stmt|;
break|break;
case|case
name|SSL_aKRB5
case|:
comment|/* VRS */
case|case
name|SSL_KRB5
case|:
comment|/* VRS */
name|au
operator|=
literal|"KRB5"
expr_stmt|;
break|break;
case|case
name|SSL_aFZA
case|:
case|case
name|SSL_aNULL
case|:
name|au
operator|=
literal|"None"
expr_stmt|;
break|break;
case|case
name|SSL_aECDSA
case|:
name|au
operator|=
literal|"ECDSA"
expr_stmt|;
break|break;
default|default:
name|au
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
end_switch

begin_switch
switch|switch
condition|(
name|alg
operator|&
name|SSL_ENC_MASK
condition|)
block|{
case|case
name|SSL_DES
case|:
name|enc
operator|=
operator|(
name|is_export
operator|&&
name|kl
operator|==
literal|5
operator|)
condition|?
literal|"DES(40)"
else|:
literal|"DES(56)"
expr_stmt|;
break|break;
case|case
name|SSL_3DES
case|:
name|enc
operator|=
literal|"3DES(168)"
expr_stmt|;
break|break;
case|case
name|SSL_RC4
case|:
name|enc
operator|=
name|is_export
condition|?
operator|(
name|kl
operator|==
literal|5
condition|?
literal|"RC4(40)"
else|:
literal|"RC4(56)"
operator|)
else|:
operator|(
operator|(
name|alg2
operator|&
name|SSL2_CF_8_BYTE_ENC
operator|)
condition|?
literal|"RC4(64)"
else|:
literal|"RC4(128)"
operator|)
expr_stmt|;
break|break;
case|case
name|SSL_RC2
case|:
name|enc
operator|=
name|is_export
condition|?
operator|(
name|kl
operator|==
literal|5
condition|?
literal|"RC2(40)"
else|:
literal|"RC2(56)"
operator|)
else|:
literal|"RC2(128)"
expr_stmt|;
break|break;
case|case
name|SSL_IDEA
case|:
name|enc
operator|=
literal|"IDEA(128)"
expr_stmt|;
break|break;
case|case
name|SSL_eFZA
case|:
name|enc
operator|=
literal|"Fortezza"
expr_stmt|;
break|break;
case|case
name|SSL_eNULL
case|:
name|enc
operator|=
literal|"None"
expr_stmt|;
break|break;
case|case
name|SSL_AES
case|:
switch|switch
condition|(
name|cipher
operator|->
name|strength_bits
condition|)
block|{
case|case
literal|128
case|:
name|enc
operator|=
literal|"AES(128)"
expr_stmt|;
break|break;
case|case
literal|192
case|:
name|enc
operator|=
literal|"AES(192)"
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|enc
operator|=
literal|"AES(256)"
expr_stmt|;
break|break;
default|default:
name|enc
operator|=
literal|"AES(?"
literal|"?"
literal|"?)"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SSL_CAMELLIA
case|:
switch|switch
condition|(
name|cipher
operator|->
name|strength_bits
condition|)
block|{
case|case
literal|128
case|:
name|enc
operator|=
literal|"Camellia(128)"
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|enc
operator|=
literal|"Camellia(256)"
expr_stmt|;
break|break;
default|default:
name|enc
operator|=
literal|"Camellia(?"
literal|"?"
literal|"?)"
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|enc
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
end_switch

begin_switch
switch|switch
condition|(
name|alg
operator|&
name|SSL_MAC_MASK
condition|)
block|{
case|case
name|SSL_MD5
case|:
name|mac
operator|=
literal|"MD5"
expr_stmt|;
break|break;
case|case
name|SSL_SHA1
case|:
name|mac
operator|=
literal|"SHA1"
expr_stmt|;
break|break;
default|default:
name|mac
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
end_switch

begin_if
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|len
operator|=
literal|128
expr_stmt|;
name|buf
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"OPENSSL_malloc Error"
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<
literal|128
condition|)
return|return
operator|(
literal|"Buffer too small"
operator|)
return|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|KSSL_DEBUG
end_ifdef

begin_expr_stmt
name|BIO_snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|format
argument_list|,
name|cipher
operator|->
name|name
argument_list|,
name|ver
argument_list|,
name|kx
argument_list|,
name|au
argument_list|,
name|enc
argument_list|,
name|mac
argument_list|,
name|exp_str
argument_list|,
name|alg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|BIO_snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|format
argument_list|,
name|cipher
operator|->
name|name
argument_list|,
name|ver
argument_list|,
name|kx
argument_list|,
name|au
argument_list|,
name|enc
argument_list|,
name|mac
argument_list|,
name|exp_str
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KSSL_DEBUG */
end_comment

begin_return
return|return
operator|(
name|buf
operator|)
return|;
end_return

begin_expr_stmt
unit|}  char
operator|*
name|SSL_CIPHER_get_version
argument_list|(
argument|const SSL_CIPHER *c
argument_list|)
block|{
name|int
name|i
block|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"(NONE)"
operator|)
return|;
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|c
operator|->
name|id
operator|>>
literal|24L
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|i
operator|==
literal|3
condition|)
return|return
operator|(
literal|"TLSv1/SSLv3"
operator|)
return|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|2
condition|)
return|return
operator|(
literal|"SSLv2"
operator|)
return|;
else|else
return|return
operator|(
literal|"unknown"
operator|)
return|;
end_if

begin_comment
unit|}
comment|/* return the actual cipher being used */
end_comment

begin_function
unit|const
name|char
modifier|*
name|SSL_CIPHER_get_name
parameter_list|(
specifier|const
name|SSL_CIPHER
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
return|return
operator|(
name|c
operator|->
name|name
operator|)
return|;
return|return
operator|(
literal|"(NONE)"
operator|)
return|;
block|}
end_function

begin_comment
comment|/* number of bits for symmetric cipher */
end_comment

begin_function
name|int
name|SSL_CIPHER_get_bits
parameter_list|(
specifier|const
name|SSL_CIPHER
modifier|*
name|c
parameter_list|,
name|int
modifier|*
name|alg_bits
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|alg_bits
operator|!=
name|NULL
condition|)
operator|*
name|alg_bits
operator|=
name|c
operator|->
name|alg_bits
expr_stmt|;
name|ret
operator|=
name|c
operator|->
name|strength_bits
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|SSL_COMP
modifier|*
name|ssl3_comp_find
argument_list|(
name|STACK_OF
argument_list|(
name|SSL_COMP
argument_list|)
operator|*
name|sk
argument_list|,
name|int
name|n
argument_list|)
block|{
name|SSL_COMP
modifier|*
name|ctmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nn
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|==
literal|0
operator|)
operator|||
operator|(
name|sk
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|nn
operator|=
name|sk_SSL_COMP_num
argument_list|(
name|sk
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nn
condition|;
name|i
operator|++
control|)
block|{
name|ctmp
operator|=
name|sk_SSL_COMP_value
argument_list|(
name|sk
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctmp
operator|->
name|id
operator|==
name|n
condition|)
return|return
operator|(
name|ctmp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_NO_COMP
end_ifdef

begin_function
name|void
modifier|*
name|SSL_COMP_get_compression_methods
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|SSL_COMP_add_compression_method
parameter_list|(
name|int
name|id
parameter_list|,
name|void
modifier|*
name|cm
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|SSL_COMP_get_name
parameter_list|(
specifier|const
name|void
modifier|*
name|comp
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|STACK_OF
argument_list|(
name|SSL_COMP
argument_list|)
operator|*
name|SSL_COMP_get_compression_methods
argument_list|(
argument|void
argument_list|)
block|{
name|load_builtin_compressions
argument_list|()
block|;
return|return
operator|(
name|ssl_comp_methods
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|int
name|SSL_COMP_add_compression_method
parameter_list|(
name|int
name|id
parameter_list|,
name|COMP_METHOD
modifier|*
name|cm
parameter_list|)
block|{
name|SSL_COMP
modifier|*
name|comp
decl_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
operator|||
name|cm
operator|->
name|type
operator|==
name|NID_undef
condition|)
return|return
literal|1
return|;
comment|/* According to draft-ietf-tls-compression-04.txt, the 	   compression number ranges should be the following:  	   0 to 63:    methods defined by the IETF 	   64 to 192:  external party methods assigned by IANA 	   193 to 255: reserved for private use */
if|if
condition|(
name|id
operator|<
literal|193
operator|||
name|id
operator|>
literal|255
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD
argument_list|,
name|SSL_R_COMPRESSION_ID_NOT_WITHIN_PRIVATE_RANGE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|MemCheck_off
argument_list|()
expr_stmt|;
name|comp
operator|=
operator|(
name|SSL_COMP
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SSL_COMP
argument_list|)
argument_list|)
expr_stmt|;
name|comp
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|comp
operator|->
name|method
operator|=
name|cm
expr_stmt|;
name|load_builtin_compressions
argument_list|()
expr_stmt|;
if|if
condition|(
name|ssl_comp_methods
operator|&&
operator|!
name|sk_SSL_COMP_find
argument_list|(
name|ssl_comp_methods
argument_list|,
name|comp
argument_list|)
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
name|MemCheck_on
argument_list|()
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD
argument_list|,
name|SSL_R_DUPLICATE_COMPRESSION_ID
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ssl_comp_methods
operator|==
name|NULL
operator|)
operator|||
operator|!
name|sk_SSL_COMP_push
argument_list|(
name|ssl_comp_methods
argument_list|,
name|comp
argument_list|)
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
name|MemCheck_on
argument_list|()
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|MemCheck_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|SSL_COMP_get_name
parameter_list|(
specifier|const
name|COMP_METHOD
modifier|*
name|comp
parameter_list|)
block|{
if|if
condition|(
name|comp
condition|)
return|return
name|comp
operator|->
name|name
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

