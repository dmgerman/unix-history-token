begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ssl/ssl_ciph.c */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *  * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *  * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from  *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.  * ECC cipher suite support in OpenSSL originally developed by  * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright 2005 Nokia. All rights reserved.  *  * The portions of the attached software ("Contribution") is developed by  * Nokia Corporation and is licensed pursuant to the OpenSSL open source  * license.  *  * The Contribution, originally written by Mika Kousa and Pasi Eronen of  * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites  * support (see RFC 4279) to OpenSSL.  *  * No patent licenses or other rights except those expressly stated in  * the OpenSSL open source license shall be deemed granted or received  * expressly, by implication, estoppel, or otherwise.  *  * No assurances are provided by Nokia that the Contribution does not  * infringe the patent or other intellectual property rights of any third  * party or that the license provides you with all the necessary rights  * to make use of the Contribution.  *  * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN  * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA  * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY  * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR  * OTHERWISE.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_COMP
end_ifndef

begin_include
include|#
directive|include
file|<openssl/comp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_ENGINE
end_ifndef

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ssl_locl.h"
end_include

begin_define
define|#
directive|define
name|SSL_ENC_DES_IDX
value|0
end_define

begin_define
define|#
directive|define
name|SSL_ENC_3DES_IDX
value|1
end_define

begin_define
define|#
directive|define
name|SSL_ENC_RC4_IDX
value|2
end_define

begin_define
define|#
directive|define
name|SSL_ENC_RC2_IDX
value|3
end_define

begin_define
define|#
directive|define
name|SSL_ENC_IDEA_IDX
value|4
end_define

begin_define
define|#
directive|define
name|SSL_ENC_NULL_IDX
value|5
end_define

begin_define
define|#
directive|define
name|SSL_ENC_AES128_IDX
value|6
end_define

begin_define
define|#
directive|define
name|SSL_ENC_AES256_IDX
value|7
end_define

begin_define
define|#
directive|define
name|SSL_ENC_CAMELLIA128_IDX
value|8
end_define

begin_define
define|#
directive|define
name|SSL_ENC_CAMELLIA256_IDX
value|9
end_define

begin_define
define|#
directive|define
name|SSL_ENC_GOST89_IDX
value|10
end_define

begin_define
define|#
directive|define
name|SSL_ENC_SEED_IDX
value|11
end_define

begin_define
define|#
directive|define
name|SSL_ENC_AES128GCM_IDX
value|12
end_define

begin_define
define|#
directive|define
name|SSL_ENC_AES256GCM_IDX
value|13
end_define

begin_define
define|#
directive|define
name|SSL_ENC_NUM_IDX
value|14
end_define

begin_decl_stmt
specifier|static
specifier|const
name|EVP_CIPHER
modifier|*
name|ssl_cipher_methods
index|[
name|SSL_ENC_NUM_IDX
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SSL_COMP_NULL_IDX
value|0
end_define

begin_define
define|#
directive|define
name|SSL_COMP_ZLIB_IDX
value|1
end_define

begin_define
define|#
directive|define
name|SSL_COMP_NUM_IDX
value|2
end_define

begin_expr_stmt
specifier|static
name|STACK_OF
argument_list|(
name|SSL_COMP
argument_list|)
operator|*
name|ssl_comp_methods
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SSL_MD_MD5_IDX
value|0
end_define

begin_define
define|#
directive|define
name|SSL_MD_SHA1_IDX
value|1
end_define

begin_define
define|#
directive|define
name|SSL_MD_GOST94_IDX
value|2
end_define

begin_define
define|#
directive|define
name|SSL_MD_GOST89MAC_IDX
value|3
end_define

begin_define
define|#
directive|define
name|SSL_MD_SHA256_IDX
value|4
end_define

begin_define
define|#
directive|define
name|SSL_MD_SHA384_IDX
value|5
end_define

begin_comment
comment|/*  * Constant SSL_MAX_DIGEST equal to size of digests array should be defined  * in the ssl_locl.h  */
end_comment

begin_define
define|#
directive|define
name|SSL_MD_NUM_IDX
value|SSL_MAX_DIGEST
end_define

begin_decl_stmt
specifier|static
specifier|const
name|EVP_MD
modifier|*
name|ssl_digest_methods
index|[
name|SSL_MD_NUM_IDX
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PKEY_TYPE for GOST89MAC is known in advance, but, because implementation  * is engine-provided, we'll fill it only if corresponding EVP_PKEY_METHOD is  * found  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ssl_mac_pkey_id
index|[
name|SSL_MD_NUM_IDX
index|]
init|=
block|{
name|EVP_PKEY_HMAC
block|,
name|EVP_PKEY_HMAC
block|,
name|EVP_PKEY_HMAC
block|,
name|NID_undef
block|,
name|EVP_PKEY_HMAC
block|,
name|EVP_PKEY_HMAC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ssl_mac_secret_size
index|[
name|SSL_MD_NUM_IDX
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ssl_handshake_digest_flag
index|[
name|SSL_MD_NUM_IDX
index|]
init|=
block|{
name|SSL_HANDSHAKE_MAC_MD5
block|,
name|SSL_HANDSHAKE_MAC_SHA
block|,
name|SSL_HANDSHAKE_MAC_GOST94
block|,
literal|0
block|,
name|SSL_HANDSHAKE_MAC_SHA256
block|,
name|SSL_HANDSHAKE_MAC_SHA384
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CIPHER_ADD
value|1
end_define

begin_define
define|#
directive|define
name|CIPHER_KILL
value|2
end_define

begin_define
define|#
directive|define
name|CIPHER_DEL
value|3
end_define

begin_define
define|#
directive|define
name|CIPHER_ORD
value|4
end_define

begin_define
define|#
directive|define
name|CIPHER_SPECIAL
value|5
end_define

begin_typedef
typedef|typedef
struct|struct
name|cipher_order_st
block|{
specifier|const
name|SSL_CIPHER
modifier|*
name|cipher
decl_stmt|;
name|int
name|active
decl_stmt|;
name|int
name|dead
decl_stmt|;
name|struct
name|cipher_order_st
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
block|}
name|CIPHER_ORDER
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|SSL_CIPHER
name|cipher_aliases
index|[]
init|=
block|{
comment|/* "ALL" doesn't include eNULL (must be specifically enabled) */
block|{
literal|0
block|,
name|SSL_TXT_ALL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|~
name|SSL_eNULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* "COMPLEMENTOFALL" */
block|{
literal|0
block|,
name|SSL_TXT_CMPALL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_eNULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*      * "COMPLEMENTOFDEFAULT" (does *not* include ciphersuites not found in      * ALL!)      */
block|{
literal|0
block|,
name|SSL_TXT_CMPDEF
block|,
literal|0
block|,
literal|0
block|,
name|SSL_aNULL
block|,
operator|~
name|SSL_eNULL
block|,
literal|0
block|,
operator|~
name|SSL_SSLV2
block|,
name|SSL_EXP_MASK
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/*      * key exchange aliases (some of those using only a single bit here      * combine multiple key exchange algs according to the RFCs, e.g. kEDH      * combines DHE_DSS and DHE_RSA)      */
block|{
literal|0
block|,
name|SSL_TXT_kRSA
block|,
literal|0
block|,
name|SSL_kRSA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kDHr
block|,
literal|0
block|,
name|SSL_kDHr
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kDHd
block|,
literal|0
block|,
name|SSL_kDHd
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kDH
block|,
literal|0
block|,
name|SSL_kDHr
operator||
name|SSL_kDHd
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kEDH
block|,
literal|0
block|,
name|SSL_kEDH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kDHE
block|,
literal|0
block|,
name|SSL_kEDH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_DH
block|,
literal|0
block|,
name|SSL_kDHr
operator||
name|SSL_kDHd
operator||
name|SSL_kEDH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kKRB5
block|,
literal|0
block|,
name|SSL_kKRB5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kECDHr
block|,
literal|0
block|,
name|SSL_kECDHr
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kECDHe
block|,
literal|0
block|,
name|SSL_kECDHe
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kECDH
block|,
literal|0
block|,
name|SSL_kECDHr
operator||
name|SSL_kECDHe
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kEECDH
block|,
literal|0
block|,
name|SSL_kEECDH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kECDHE
block|,
literal|0
block|,
name|SSL_kEECDH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_ECDH
block|,
literal|0
block|,
name|SSL_kECDHr
operator||
name|SSL_kECDHe
operator||
name|SSL_kEECDH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kPSK
block|,
literal|0
block|,
name|SSL_kPSK
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kSRP
block|,
literal|0
block|,
name|SSL_kSRP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_kGOST
block|,
literal|0
block|,
name|SSL_kGOST
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* server authentication aliases */
block|{
literal|0
block|,
name|SSL_TXT_aRSA
block|,
literal|0
block|,
literal|0
block|,
name|SSL_aRSA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aDSS
block|,
literal|0
block|,
literal|0
block|,
name|SSL_aDSS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_DSS
block|,
literal|0
block|,
literal|0
block|,
name|SSL_aDSS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aKRB5
block|,
literal|0
block|,
literal|0
block|,
name|SSL_aKRB5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aNULL
block|,
literal|0
block|,
literal|0
block|,
name|SSL_aNULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* no such ciphersuites supported! */
block|{
literal|0
block|,
name|SSL_TXT_aDH
block|,
literal|0
block|,
literal|0
block|,
name|SSL_aDH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aECDH
block|,
literal|0
block|,
literal|0
block|,
name|SSL_aECDH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aECDSA
block|,
literal|0
block|,
literal|0
block|,
name|SSL_aECDSA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_ECDSA
block|,
literal|0
block|,
literal|0
block|,
name|SSL_aECDSA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aPSK
block|,
literal|0
block|,
literal|0
block|,
name|SSL_aPSK
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aGOST94
block|,
literal|0
block|,
literal|0
block|,
name|SSL_aGOST94
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aGOST01
block|,
literal|0
block|,
literal|0
block|,
name|SSL_aGOST01
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aGOST
block|,
literal|0
block|,
literal|0
block|,
name|SSL_aGOST94
operator||
name|SSL_aGOST01
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_aSRP
block|,
literal|0
block|,
literal|0
block|,
name|SSL_aSRP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* aliases combining key exchange and server authentication */
block|{
literal|0
block|,
name|SSL_TXT_EDH
block|,
literal|0
block|,
name|SSL_kEDH
block|,
operator|~
name|SSL_aNULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_DHE
block|,
literal|0
block|,
name|SSL_kEDH
block|,
operator|~
name|SSL_aNULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_EECDH
block|,
literal|0
block|,
name|SSL_kEECDH
block|,
operator|~
name|SSL_aNULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_ECDHE
block|,
literal|0
block|,
name|SSL_kEECDH
block|,
operator|~
name|SSL_aNULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_eNULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_KRB5
block|,
literal|0
block|,
name|SSL_kKRB5
block|,
name|SSL_aKRB5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_RSA
block|,
literal|0
block|,
name|SSL_kRSA
block|,
name|SSL_aRSA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_ADH
block|,
literal|0
block|,
name|SSL_kEDH
block|,
name|SSL_aNULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_AECDH
block|,
literal|0
block|,
name|SSL_kEECDH
block|,
name|SSL_aNULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_PSK
block|,
literal|0
block|,
name|SSL_kPSK
block|,
name|SSL_aPSK
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_SRP
block|,
literal|0
block|,
name|SSL_kSRP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* symmetric encryption aliases */
block|{
literal|0
block|,
name|SSL_TXT_DES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_DES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_3DES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_3DES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_RC4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_RC4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_RC2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_RC2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_IDEA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_IDEA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_SEED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_SEED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_eNULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_eNULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_AES128
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AES128
operator||
name|SSL_AES128GCM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_AES256
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AES256
operator||
name|SSL_AES256GCM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_AES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_AES_GCM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_AES128GCM
operator||
name|SSL_AES256GCM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_CAMELLIA128
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_CAMELLIA128
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_CAMELLIA256
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_CAMELLIA256
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_CAMELLIA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_CAMELLIA128
operator||
name|SSL_CAMELLIA256
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* MAC aliases */
block|{
literal|0
block|,
name|SSL_TXT_MD5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_MD5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_SHA1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_SHA1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_SHA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_SHA1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_GOST94
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_GOST94
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_GOST89MAC
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_GOST89MAC
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_SHA256
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_SHA256
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_SHA384
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_SHA384
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* protocol version aliases */
block|{
literal|0
block|,
name|SSL_TXT_SSLV2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_SSLV2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_SSLV3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_SSLV3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_TLSV1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_TLSV1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_TLSV1_2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_TLSV1_2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* export flag */
block|{
literal|0
block|,
name|SSL_TXT_EXP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_EXPORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_EXPORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_EXPORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* strength classes */
block|{
literal|0
block|,
name|SSL_TXT_EXP40
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_EXP40
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_EXP56
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_EXP56
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_LOW
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_LOW
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_MEDIUM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_MEDIUM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|SSL_TXT_HIGH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SSL_HIGH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* FIPS 140-2 approved ciphersuite */
block|{
literal|0
block|,
name|SSL_TXT_FIPS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|~
name|SSL_eNULL
block|,
literal|0
block|,
literal|0
block|,
name|SSL_FIPS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* "DHE-" aliases to "EDH-" labels (for forward compatibility) */
block|{
literal|0
block|,
name|SSL3_TXT_DHE_DSS_DES_40_CBC_SHA
block|,
literal|0
block|,
name|SSL_kDHE
block|,
name|SSL_aDSS
block|,
name|SSL_DES
block|,
name|SSL_SHA1
block|,
name|SSL_SSLV3
block|,
name|SSL_EXPORT
operator||
name|SSL_EXP40
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,}
block|,
block|{
literal|0
block|,
name|SSL3_TXT_DHE_DSS_DES_64_CBC_SHA
block|,
literal|0
block|,
name|SSL_kDHE
block|,
name|SSL_aDSS
block|,
name|SSL_DES
block|,
name|SSL_SHA1
block|,
name|SSL_SSLV3
block|,
name|SSL_NOT_EXP
operator||
name|SSL_LOW
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,}
block|,
block|{
literal|0
block|,
name|SSL3_TXT_DHE_DSS_DES_192_CBC3_SHA
block|,
literal|0
block|,
name|SSL_kDHE
block|,
name|SSL_aDSS
block|,
name|SSL_3DES
block|,
name|SSL_SHA1
block|,
name|SSL_SSLV3
block|,
name|SSL_NOT_EXP
operator||
name|SSL_HIGH
operator||
name|SSL_FIPS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,}
block|,
block|{
literal|0
block|,
name|SSL3_TXT_DHE_RSA_DES_40_CBC_SHA
block|,
literal|0
block|,
name|SSL_kDHE
block|,
name|SSL_aRSA
block|,
name|SSL_DES
block|,
name|SSL_SHA1
block|,
name|SSL_SSLV3
block|,
name|SSL_EXPORT
operator||
name|SSL_EXP40
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,}
block|,
block|{
literal|0
block|,
name|SSL3_TXT_DHE_RSA_DES_64_CBC_SHA
block|,
literal|0
block|,
name|SSL_kDHE
block|,
name|SSL_aRSA
block|,
name|SSL_DES
block|,
name|SSL_SHA1
block|,
name|SSL_SSLV3
block|,
name|SSL_NOT_EXP
operator||
name|SSL_LOW
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,}
block|,
block|{
literal|0
block|,
name|SSL3_TXT_DHE_RSA_DES_192_CBC3_SHA
block|,
literal|0
block|,
name|SSL_kDHE
block|,
name|SSL_aRSA
block|,
name|SSL_3DES
block|,
name|SSL_SHA1
block|,
name|SSL_SSLV3
block|,
name|SSL_NOT_EXP
operator||
name|SSL_HIGH
operator||
name|SSL_FIPS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Search for public key algorithm with given name and return its pkey_id if  * it is available. Otherwise return 0  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_NO_ENGINE
end_ifdef

begin_function
specifier|static
name|int
name|get_optional_pkey_id
parameter_list|(
specifier|const
name|char
modifier|*
name|pkey_name
parameter_list|)
block|{
specifier|const
name|EVP_PKEY_ASN1_METHOD
modifier|*
name|ameth
decl_stmt|;
name|int
name|pkey_id
init|=
literal|0
decl_stmt|;
name|ameth
operator|=
name|EVP_PKEY_asn1_find_str
argument_list|(
name|NULL
argument_list|,
name|pkey_name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ameth
operator|&&
name|EVP_PKEY_asn1_get0_info
argument_list|(
operator|&
name|pkey_id
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ameth
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
name|pkey_id
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|get_optional_pkey_id
parameter_list|(
specifier|const
name|char
modifier|*
name|pkey_name
parameter_list|)
block|{
specifier|const
name|EVP_PKEY_ASN1_METHOD
modifier|*
name|ameth
decl_stmt|;
name|ENGINE
modifier|*
name|tmpeng
init|=
name|NULL
decl_stmt|;
name|int
name|pkey_id
init|=
literal|0
decl_stmt|;
name|ameth
operator|=
name|EVP_PKEY_asn1_find_str
argument_list|(
operator|&
name|tmpeng
argument_list|,
name|pkey_name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ameth
condition|)
block|{
if|if
condition|(
name|EVP_PKEY_asn1_get0_info
argument_list|(
operator|&
name|pkey_id
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ameth
argument_list|)
operator|<=
literal|0
condition|)
name|pkey_id
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tmpeng
condition|)
name|ENGINE_finish
argument_list|(
name|tmpeng
argument_list|)
expr_stmt|;
return|return
name|pkey_id
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|ssl_load_ciphers
parameter_list|(
name|void
parameter_list|)
block|{
name|ssl_cipher_methods
index|[
name|SSL_ENC_DES_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_des_cbc
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_3DES_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_des_ede3_cbc
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_RC4_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_rc4
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_RC2_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_rc2_cbc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_IDEA
name|ssl_cipher_methods
index|[
name|SSL_ENC_IDEA_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_idea_cbc
argument_list|)
expr_stmt|;
else|#
directive|else
name|ssl_cipher_methods
index|[
name|SSL_ENC_IDEA_IDX
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|ssl_cipher_methods
index|[
name|SSL_ENC_AES128_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_aes_128_cbc
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_AES256_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_aes_256_cbc
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_CAMELLIA128_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_camellia_128_cbc
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_CAMELLIA256_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_camellia_256_cbc
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_GOST89_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_gost89_cnt
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_SEED_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_seed_cbc
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_AES128GCM_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_aes_128_gcm
argument_list|)
expr_stmt|;
name|ssl_cipher_methods
index|[
name|SSL_ENC_AES256GCM_IDX
index|]
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|SN_aes_256_gcm
argument_list|)
expr_stmt|;
name|ssl_digest_methods
index|[
name|SSL_MD_MD5_IDX
index|]
operator|=
name|EVP_get_digestbyname
argument_list|(
name|SN_md5
argument_list|)
expr_stmt|;
name|ssl_mac_secret_size
index|[
name|SSL_MD_MD5_IDX
index|]
operator|=
name|EVP_MD_size
argument_list|(
name|ssl_digest_methods
index|[
name|SSL_MD_MD5_IDX
index|]
argument_list|)
expr_stmt|;
name|OPENSSL_assert
argument_list|(
name|ssl_mac_secret_size
index|[
name|SSL_MD_MD5_IDX
index|]
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ssl_digest_methods
index|[
name|SSL_MD_SHA1_IDX
index|]
operator|=
name|EVP_get_digestbyname
argument_list|(
name|SN_sha1
argument_list|)
expr_stmt|;
name|ssl_mac_secret_size
index|[
name|SSL_MD_SHA1_IDX
index|]
operator|=
name|EVP_MD_size
argument_list|(
name|ssl_digest_methods
index|[
name|SSL_MD_SHA1_IDX
index|]
argument_list|)
expr_stmt|;
name|OPENSSL_assert
argument_list|(
name|ssl_mac_secret_size
index|[
name|SSL_MD_SHA1_IDX
index|]
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ssl_digest_methods
index|[
name|SSL_MD_GOST94_IDX
index|]
operator|=
name|EVP_get_digestbyname
argument_list|(
name|SN_id_GostR3411_94
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl_digest_methods
index|[
name|SSL_MD_GOST94_IDX
index|]
condition|)
block|{
name|ssl_mac_secret_size
index|[
name|SSL_MD_GOST94_IDX
index|]
operator|=
name|EVP_MD_size
argument_list|(
name|ssl_digest_methods
index|[
name|SSL_MD_GOST94_IDX
index|]
argument_list|)
expr_stmt|;
name|OPENSSL_assert
argument_list|(
name|ssl_mac_secret_size
index|[
name|SSL_MD_GOST94_IDX
index|]
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
name|ssl_digest_methods
index|[
name|SSL_MD_GOST89MAC_IDX
index|]
operator|=
name|EVP_get_digestbyname
argument_list|(
name|SN_id_Gost28147_89_MAC
argument_list|)
expr_stmt|;
name|ssl_mac_pkey_id
index|[
name|SSL_MD_GOST89MAC_IDX
index|]
operator|=
name|get_optional_pkey_id
argument_list|(
literal|"gost-mac"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl_mac_pkey_id
index|[
name|SSL_MD_GOST89MAC_IDX
index|]
condition|)
block|{
name|ssl_mac_secret_size
index|[
name|SSL_MD_GOST89MAC_IDX
index|]
operator|=
literal|32
expr_stmt|;
block|}
name|ssl_digest_methods
index|[
name|SSL_MD_SHA256_IDX
index|]
operator|=
name|EVP_get_digestbyname
argument_list|(
name|SN_sha256
argument_list|)
expr_stmt|;
name|ssl_mac_secret_size
index|[
name|SSL_MD_SHA256_IDX
index|]
operator|=
name|EVP_MD_size
argument_list|(
name|ssl_digest_methods
index|[
name|SSL_MD_SHA256_IDX
index|]
argument_list|)
expr_stmt|;
name|ssl_digest_methods
index|[
name|SSL_MD_SHA384_IDX
index|]
operator|=
name|EVP_get_digestbyname
argument_list|(
name|SN_sha384
argument_list|)
expr_stmt|;
name|ssl_mac_secret_size
index|[
name|SSL_MD_SHA384_IDX
index|]
operator|=
name|EVP_MD_size
argument_list|(
name|ssl_digest_methods
index|[
name|SSL_MD_SHA384_IDX
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_COMP
end_ifndef

begin_function
specifier|static
name|int
name|sk_comp_cmp
parameter_list|(
specifier|const
name|SSL_COMP
modifier|*
specifier|const
modifier|*
name|a
parameter_list|,
specifier|const
name|SSL_COMP
modifier|*
specifier|const
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|*
name|a
operator|)
operator|->
name|id
operator|-
operator|(
operator|*
name|b
operator|)
operator|->
name|id
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|load_builtin_compressions
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|got_write_lock
init|=
literal|0
decl_stmt|;
name|CRYPTO_r_lock
argument_list|(
name|CRYPTO_LOCK_SSL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl_comp_methods
operator|==
name|NULL
condition|)
block|{
name|CRYPTO_r_unlock
argument_list|(
name|CRYPTO_LOCK_SSL
argument_list|)
expr_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_SSL
argument_list|)
expr_stmt|;
name|got_write_lock
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ssl_comp_methods
operator|==
name|NULL
condition|)
block|{
name|SSL_COMP
modifier|*
name|comp
init|=
name|NULL
decl_stmt|;
name|MemCheck_off
argument_list|()
expr_stmt|;
name|ssl_comp_methods
operator|=
name|sk_SSL_COMP_new
argument_list|(
name|sk_comp_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl_comp_methods
operator|!=
name|NULL
condition|)
block|{
name|comp
operator|=
operator|(
name|SSL_COMP
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SSL_COMP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|!=
name|NULL
condition|)
block|{
name|comp
operator|->
name|method
operator|=
name|COMP_zlib
argument_list|()
expr_stmt|;
if|if
condition|(
name|comp
operator|->
name|method
operator|&&
name|comp
operator|->
name|method
operator|->
name|type
operator|==
name|NID_undef
condition|)
name|OPENSSL_free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
else|else
block|{
name|comp
operator|->
name|id
operator|=
name|SSL_COMP_ZLIB_IDX
expr_stmt|;
name|comp
operator|->
name|name
operator|=
name|comp
operator|->
name|method
operator|->
name|name
expr_stmt|;
name|sk_SSL_COMP_push
argument_list|(
name|ssl_comp_methods
argument_list|,
name|comp
argument_list|)
expr_stmt|;
block|}
block|}
name|sk_SSL_COMP_sort
argument_list|(
name|ssl_comp_methods
argument_list|)
expr_stmt|;
block|}
name|MemCheck_on
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|got_write_lock
condition|)
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_SSL
argument_list|)
expr_stmt|;
else|else
name|CRYPTO_r_unlock
argument_list|(
name|CRYPTO_LOCK_SSL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ssl_cipher_get_evp
parameter_list|(
specifier|const
name|SSL_SESSION
modifier|*
name|s
parameter_list|,
specifier|const
name|EVP_CIPHER
modifier|*
modifier|*
name|enc
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
modifier|*
name|md
parameter_list|,
name|int
modifier|*
name|mac_pkey_type
parameter_list|,
name|int
modifier|*
name|mac_secret_size
parameter_list|,
name|SSL_COMP
modifier|*
modifier|*
name|comp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|SSL_CIPHER
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|s
operator|->
name|cipher
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|comp
operator|!=
name|NULL
condition|)
block|{
name|SSL_COMP
name|ctmp
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_COMP
name|load_builtin_compressions
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|*
name|comp
operator|=
name|NULL
expr_stmt|;
name|ctmp
operator|.
name|id
operator|=
name|s
operator|->
name|compress_meth
expr_stmt|;
if|if
condition|(
name|ssl_comp_methods
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
name|sk_SSL_COMP_find
argument_list|(
name|ssl_comp_methods
argument_list|,
operator|&
name|ctmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
operator|*
name|comp
operator|=
name|sk_SSL_COMP_value
argument_list|(
name|ssl_comp_methods
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
operator|*
name|comp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|enc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|md
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|c
operator|->
name|algorithm_enc
condition|)
block|{
case|case
name|SSL_DES
case|:
name|i
operator|=
name|SSL_ENC_DES_IDX
expr_stmt|;
break|break;
case|case
name|SSL_3DES
case|:
name|i
operator|=
name|SSL_ENC_3DES_IDX
expr_stmt|;
break|break;
case|case
name|SSL_RC4
case|:
name|i
operator|=
name|SSL_ENC_RC4_IDX
expr_stmt|;
break|break;
case|case
name|SSL_RC2
case|:
name|i
operator|=
name|SSL_ENC_RC2_IDX
expr_stmt|;
break|break;
case|case
name|SSL_IDEA
case|:
name|i
operator|=
name|SSL_ENC_IDEA_IDX
expr_stmt|;
break|break;
case|case
name|SSL_eNULL
case|:
name|i
operator|=
name|SSL_ENC_NULL_IDX
expr_stmt|;
break|break;
case|case
name|SSL_AES128
case|:
name|i
operator|=
name|SSL_ENC_AES128_IDX
expr_stmt|;
break|break;
case|case
name|SSL_AES256
case|:
name|i
operator|=
name|SSL_ENC_AES256_IDX
expr_stmt|;
break|break;
case|case
name|SSL_CAMELLIA128
case|:
name|i
operator|=
name|SSL_ENC_CAMELLIA128_IDX
expr_stmt|;
break|break;
case|case
name|SSL_CAMELLIA256
case|:
name|i
operator|=
name|SSL_ENC_CAMELLIA256_IDX
expr_stmt|;
break|break;
case|case
name|SSL_eGOST2814789CNT
case|:
name|i
operator|=
name|SSL_ENC_GOST89_IDX
expr_stmt|;
break|break;
case|case
name|SSL_SEED
case|:
name|i
operator|=
name|SSL_ENC_SEED_IDX
expr_stmt|;
break|break;
case|case
name|SSL_AES128GCM
case|:
name|i
operator|=
name|SSL_ENC_AES128GCM_IDX
expr_stmt|;
break|break;
case|case
name|SSL_AES256GCM
case|:
name|i
operator|=
name|SSL_ENC_AES256GCM_IDX
expr_stmt|;
break|break;
default|default:
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|>=
name|SSL_ENC_NUM_IDX
operator|)
condition|)
operator|*
name|enc
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|i
operator|==
name|SSL_ENC_NULL_IDX
condition|)
operator|*
name|enc
operator|=
name|EVP_enc_null
argument_list|()
expr_stmt|;
else|else
operator|*
name|enc
operator|=
name|ssl_cipher_methods
index|[
name|i
index|]
expr_stmt|;
block|}
switch|switch
condition|(
name|c
operator|->
name|algorithm_mac
condition|)
block|{
case|case
name|SSL_MD5
case|:
name|i
operator|=
name|SSL_MD_MD5_IDX
expr_stmt|;
break|break;
case|case
name|SSL_SHA1
case|:
name|i
operator|=
name|SSL_MD_SHA1_IDX
expr_stmt|;
break|break;
case|case
name|SSL_SHA256
case|:
name|i
operator|=
name|SSL_MD_SHA256_IDX
expr_stmt|;
break|break;
case|case
name|SSL_SHA384
case|:
name|i
operator|=
name|SSL_MD_SHA384_IDX
expr_stmt|;
break|break;
case|case
name|SSL_GOST94
case|:
name|i
operator|=
name|SSL_MD_GOST94_IDX
expr_stmt|;
break|break;
case|case
name|SSL_GOST89MAC
case|:
name|i
operator|=
name|SSL_MD_GOST89MAC_IDX
expr_stmt|;
break|break;
default|default:
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|>=
name|SSL_MD_NUM_IDX
operator|)
condition|)
block|{
operator|*
name|md
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mac_pkey_type
operator|!=
name|NULL
condition|)
operator|*
name|mac_pkey_type
operator|=
name|NID_undef
expr_stmt|;
if|if
condition|(
name|mac_secret_size
operator|!=
name|NULL
condition|)
operator|*
name|mac_secret_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|algorithm_mac
operator|==
name|SSL_AEAD
condition|)
name|mac_pkey_type
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|md
operator|=
name|ssl_digest_methods
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mac_pkey_type
operator|!=
name|NULL
condition|)
operator|*
name|mac_pkey_type
operator|=
name|ssl_mac_pkey_id
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mac_secret_size
operator|!=
name|NULL
condition|)
operator|*
name|mac_secret_size
operator|=
name|ssl_mac_secret_size
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|enc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|md
operator|!=
name|NULL
operator|||
operator|(
name|EVP_CIPHER_flags
argument_list|(
operator|*
name|enc
argument_list|)
operator|&
name|EVP_CIPH_FLAG_AEAD_CIPHER
operator|)
operator|)
operator|&&
operator|(
operator|!
name|mac_pkey_type
operator|||
operator|*
name|mac_pkey_type
operator|!=
name|NID_undef
operator|)
condition|)
block|{
specifier|const
name|EVP_CIPHER
modifier|*
name|evp
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|ssl_version
operator|>>
literal|8
operator|!=
name|TLS1_VERSION_MAJOR
operator|||
name|s
operator|->
name|ssl_version
operator|<
name|TLS1_VERSION
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
if|if
condition|(
name|FIPS_mode
argument_list|()
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|->
name|algorithm_enc
operator|==
name|SSL_RC4
operator|&&
name|c
operator|->
name|algorithm_mac
operator|==
name|SSL_MD5
operator|&&
operator|(
name|evp
operator|=
name|EVP_get_cipherbyname
argument_list|(
literal|"RC4-HMAC-MD5"
argument_list|)
operator|)
condition|)
operator|*
name|enc
operator|=
name|evp
operator|,
operator|*
name|md
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|algorithm_enc
operator|==
name|SSL_AES128
operator|&&
name|c
operator|->
name|algorithm_mac
operator|==
name|SSL_SHA1
operator|&&
operator|(
name|evp
operator|=
name|EVP_get_cipherbyname
argument_list|(
literal|"AES-128-CBC-HMAC-SHA1"
argument_list|)
operator|)
condition|)
operator|*
name|enc
operator|=
name|evp
operator|,
operator|*
name|md
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|algorithm_enc
operator|==
name|SSL_AES256
operator|&&
name|c
operator|->
name|algorithm_mac
operator|==
name|SSL_SHA1
operator|&&
operator|(
name|evp
operator|=
name|EVP_get_cipherbyname
argument_list|(
literal|"AES-256-CBC-HMAC-SHA1"
argument_list|)
operator|)
condition|)
operator|*
name|enc
operator|=
name|evp
operator|,
operator|*
name|md
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|algorithm_enc
operator|==
name|SSL_AES128
operator|&&
name|c
operator|->
name|algorithm_mac
operator|==
name|SSL_SHA256
operator|&&
operator|(
name|evp
operator|=
name|EVP_get_cipherbyname
argument_list|(
literal|"AES-128-CBC-HMAC-SHA256"
argument_list|)
operator|)
condition|)
operator|*
name|enc
operator|=
name|evp
operator|,
operator|*
name|md
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|algorithm_enc
operator|==
name|SSL_AES256
operator|&&
name|c
operator|->
name|algorithm_mac
operator|==
name|SSL_SHA256
operator|&&
operator|(
name|evp
operator|=
name|EVP_get_cipherbyname
argument_list|(
literal|"AES-256-CBC-HMAC-SHA256"
argument_list|)
operator|)
condition|)
operator|*
name|enc
operator|=
name|evp
operator|,
operator|*
name|md
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ssl_get_handshake_digest
parameter_list|(
name|int
name|idx
parameter_list|,
name|long
modifier|*
name|mask
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
modifier|*
name|md
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|SSL_MD_NUM_IDX
condition|)
block|{
return|return
literal|0
return|;
block|}
operator|*
name|mask
operator|=
name|ssl_handshake_digest_flag
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|mask
condition|)
operator|*
name|md
operator|=
name|ssl_digest_methods
index|[
name|idx
index|]
expr_stmt|;
else|else
operator|*
name|md
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ITEM_SEP
parameter_list|(
name|a
parameter_list|)
define|\
value|(((a) == ':') || ((a) == ' ') || ((a) == ';') || ((a) == ','))
end_define

begin_function
specifier|static
name|void
name|ll_append_tail
parameter_list|(
name|CIPHER_ORDER
modifier|*
modifier|*
name|head
parameter_list|,
name|CIPHER_ORDER
modifier|*
name|curr
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
if|if
condition|(
name|curr
operator|==
operator|*
name|tail
condition|)
return|return;
if|if
condition|(
name|curr
operator|==
operator|*
name|head
condition|)
operator|*
name|head
operator|=
name|curr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|curr
operator|->
name|prev
operator|->
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|next
operator|!=
name|NULL
condition|)
name|curr
operator|->
name|next
operator|->
name|prev
operator|=
name|curr
operator|->
name|prev
expr_stmt|;
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|curr
expr_stmt|;
name|curr
operator|->
name|prev
operator|=
operator|*
name|tail
expr_stmt|;
name|curr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|tail
operator|=
name|curr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ll_append_head
parameter_list|(
name|CIPHER_ORDER
modifier|*
modifier|*
name|head
parameter_list|,
name|CIPHER_ORDER
modifier|*
name|curr
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
if|if
condition|(
name|curr
operator|==
operator|*
name|head
condition|)
return|return;
if|if
condition|(
name|curr
operator|==
operator|*
name|tail
condition|)
operator|*
name|tail
operator|=
name|curr
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|next
operator|!=
name|NULL
condition|)
name|curr
operator|->
name|next
operator|->
name|prev
operator|=
name|curr
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|curr
operator|->
name|prev
operator|->
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
operator|=
name|curr
expr_stmt|;
name|curr
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
name|curr
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
operator|*
name|head
operator|=
name|curr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ssl_cipher_get_disabled
parameter_list|(
name|unsigned
name|long
modifier|*
name|mkey
parameter_list|,
name|unsigned
name|long
modifier|*
name|auth
parameter_list|,
name|unsigned
name|long
modifier|*
name|enc
parameter_list|,
name|unsigned
name|long
modifier|*
name|mac
parameter_list|,
name|unsigned
name|long
modifier|*
name|ssl
parameter_list|)
block|{
operator|*
name|mkey
operator|=
literal|0
expr_stmt|;
operator|*
name|auth
operator|=
literal|0
expr_stmt|;
operator|*
name|enc
operator|=
literal|0
expr_stmt|;
operator|*
name|mac
operator|=
literal|0
expr_stmt|;
operator|*
name|ssl
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL_NO_RSA
operator|*
name|mkey
operator||=
name|SSL_kRSA
expr_stmt|;
operator|*
name|auth
operator||=
name|SSL_aRSA
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL_NO_DSA
operator|*
name|auth
operator||=
name|SSL_aDSS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL_NO_DH
operator|*
name|mkey
operator||=
name|SSL_kDHr
operator||
name|SSL_kDHd
operator||
name|SSL_kEDH
expr_stmt|;
operator|*
name|auth
operator||=
name|SSL_aDH
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL_NO_KRB5
operator|*
name|mkey
operator||=
name|SSL_kKRB5
expr_stmt|;
operator|*
name|auth
operator||=
name|SSL_aKRB5
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL_NO_ECDSA
operator|*
name|auth
operator||=
name|SSL_aECDSA
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL_NO_ECDH
operator|*
name|mkey
operator||=
name|SSL_kECDHe
operator||
name|SSL_kECDHr
expr_stmt|;
operator|*
name|auth
operator||=
name|SSL_aECDH
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL_NO_PSK
operator|*
name|mkey
operator||=
name|SSL_kPSK
expr_stmt|;
operator|*
name|auth
operator||=
name|SSL_aPSK
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL_NO_SRP
operator|*
name|mkey
operator||=
name|SSL_kSRP
expr_stmt|;
endif|#
directive|endif
comment|/*      * Check for presence of GOST 34.10 algorithms, and if they do not      * present, disable appropriate auth and key exchange      */
if|if
condition|(
operator|!
name|get_optional_pkey_id
argument_list|(
literal|"gost94"
argument_list|)
condition|)
block|{
operator|*
name|auth
operator||=
name|SSL_aGOST94
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|get_optional_pkey_id
argument_list|(
literal|"gost2001"
argument_list|)
condition|)
block|{
operator|*
name|auth
operator||=
name|SSL_aGOST01
expr_stmt|;
block|}
comment|/*      * Disable GOST key exchange if no GOST signature algs are available *      */
if|if
condition|(
operator|(
operator|*
name|auth
operator|&
operator|(
name|SSL_aGOST94
operator||
name|SSL_aGOST01
operator|)
operator|)
operator|==
operator|(
name|SSL_aGOST94
operator||
name|SSL_aGOST01
operator|)
condition|)
block|{
operator|*
name|mkey
operator||=
name|SSL_kGOST
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SSL_FORBID_ENULL
operator|*
name|enc
operator||=
name|SSL_eNULL
expr_stmt|;
endif|#
directive|endif
operator|*
name|enc
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_DES_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_DES
else|:
literal|0
expr_stmt|;
operator|*
name|enc
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_3DES_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_3DES
else|:
literal|0
expr_stmt|;
operator|*
name|enc
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_RC4_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_RC4
else|:
literal|0
expr_stmt|;
operator|*
name|enc
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_RC2_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_RC2
else|:
literal|0
expr_stmt|;
operator|*
name|enc
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_IDEA_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_IDEA
else|:
literal|0
expr_stmt|;
operator|*
name|enc
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_AES128_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_AES128
else|:
literal|0
expr_stmt|;
operator|*
name|enc
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_AES256_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_AES256
else|:
literal|0
expr_stmt|;
operator|*
name|enc
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_AES128GCM_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_AES128GCM
else|:
literal|0
expr_stmt|;
operator|*
name|enc
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_AES256GCM_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_AES256GCM
else|:
literal|0
expr_stmt|;
operator|*
name|enc
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_CAMELLIA128_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_CAMELLIA128
else|:
literal|0
expr_stmt|;
operator|*
name|enc
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_CAMELLIA256_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_CAMELLIA256
else|:
literal|0
expr_stmt|;
operator|*
name|enc
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_GOST89_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_eGOST2814789CNT
else|:
literal|0
expr_stmt|;
operator|*
name|enc
operator||=
operator|(
name|ssl_cipher_methods
index|[
name|SSL_ENC_SEED_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_SEED
else|:
literal|0
expr_stmt|;
operator|*
name|mac
operator||=
operator|(
name|ssl_digest_methods
index|[
name|SSL_MD_MD5_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_MD5
else|:
literal|0
expr_stmt|;
operator|*
name|mac
operator||=
operator|(
name|ssl_digest_methods
index|[
name|SSL_MD_SHA1_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_SHA1
else|:
literal|0
expr_stmt|;
operator|*
name|mac
operator||=
operator|(
name|ssl_digest_methods
index|[
name|SSL_MD_SHA256_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_SHA256
else|:
literal|0
expr_stmt|;
operator|*
name|mac
operator||=
operator|(
name|ssl_digest_methods
index|[
name|SSL_MD_SHA384_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_SHA384
else|:
literal|0
expr_stmt|;
operator|*
name|mac
operator||=
operator|(
name|ssl_digest_methods
index|[
name|SSL_MD_GOST94_IDX
index|]
operator|==
name|NULL
operator|)
condition|?
name|SSL_GOST94
else|:
literal|0
expr_stmt|;
operator|*
name|mac
operator||=
operator|(
name|ssl_digest_methods
index|[
name|SSL_MD_GOST89MAC_IDX
index|]
operator|==
name|NULL
operator|||
name|ssl_mac_pkey_id
index|[
name|SSL_MD_GOST89MAC_IDX
index|]
operator|==
name|NID_undef
operator|)
condition|?
name|SSL_GOST89MAC
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ssl_cipher_collect_ciphers
parameter_list|(
specifier|const
name|SSL_METHOD
modifier|*
name|ssl_method
parameter_list|,
name|int
name|num_of_ciphers
parameter_list|,
name|unsigned
name|long
name|disabled_mkey
parameter_list|,
name|unsigned
name|long
name|disabled_auth
parameter_list|,
name|unsigned
name|long
name|disabled_enc
parameter_list|,
name|unsigned
name|long
name|disabled_mac
parameter_list|,
name|unsigned
name|long
name|disabled_ssl
parameter_list|,
name|CIPHER_ORDER
modifier|*
name|co_list
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|head_p
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|tail_p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|co_list_num
decl_stmt|;
specifier|const
name|SSL_CIPHER
modifier|*
name|c
decl_stmt|;
comment|/*      * We have num_of_ciphers descriptions compiled in, depending on the      * method selected (SSLv2 and/or SSLv3, TLSv1 etc).      * These will later be sorted in a linked list with at most num      * entries.      */
comment|/* Get the initial list of ciphers */
name|co_list_num
operator|=
literal|0
expr_stmt|;
comment|/* actual count of ciphers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_of_ciphers
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|ssl_method
operator|->
name|get_cipher
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* drop those that use any of that is not available */
if|if
condition|(
operator|(
name|c
operator|!=
name|NULL
operator|)
operator|&&
name|c
operator|->
name|valid
operator|&&
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
operator|(
operator|!
name|FIPS_mode
argument_list|()
operator|||
operator|(
name|c
operator|->
name|algo_strength
operator|&
name|SSL_FIPS
operator|)
operator|)
operator|&&
endif|#
directive|endif
operator|!
operator|(
name|c
operator|->
name|algorithm_mkey
operator|&
name|disabled_mkey
operator|)
operator|&&
operator|!
operator|(
name|c
operator|->
name|algorithm_auth
operator|&
name|disabled_auth
operator|)
operator|&&
operator|!
operator|(
name|c
operator|->
name|algorithm_enc
operator|&
name|disabled_enc
operator|)
operator|&&
operator|!
operator|(
name|c
operator|->
name|algorithm_mac
operator|&
name|disabled_mac
operator|)
operator|&&
operator|!
operator|(
name|c
operator|->
name|algorithm_ssl
operator|&
name|disabled_ssl
operator|)
condition|)
block|{
name|co_list
index|[
name|co_list_num
index|]
operator|.
name|cipher
operator|=
name|c
expr_stmt|;
name|co_list
index|[
name|co_list_num
index|]
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|co_list
index|[
name|co_list_num
index|]
operator|.
name|prev
operator|=
name|NULL
expr_stmt|;
name|co_list
index|[
name|co_list_num
index|]
operator|.
name|active
operator|=
literal|0
expr_stmt|;
name|co_list_num
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|KSSL_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%d: %s %lx %lx %lx\n"
argument_list|,
name|i
argument_list|,
name|c
operator|->
name|name
argument_list|,
name|c
operator|->
name|id
argument_list|,
name|c
operator|->
name|algorithm_mkey
argument_list|,
name|c
operator|->
name|algorithm_auth
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KSSL_DEBUG */
comment|/*              * if (!sk_push(ca_list,(char *)c)) goto err;              */
block|}
block|}
comment|/*      * Prepare linked list from list entries      */
if|if
condition|(
name|co_list_num
operator|>
literal|0
condition|)
block|{
name|co_list
index|[
literal|0
index|]
operator|.
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|co_list_num
operator|>
literal|1
condition|)
block|{
name|co_list
index|[
literal|0
index|]
operator|.
name|next
operator|=
operator|&
name|co_list
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|co_list_num
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|co_list
index|[
name|i
index|]
operator|.
name|prev
operator|=
operator|&
name|co_list
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|co_list
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|&
name|co_list
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|co_list
index|[
name|co_list_num
operator|-
literal|1
index|]
operator|.
name|prev
operator|=
operator|&
name|co_list
index|[
name|co_list_num
operator|-
literal|2
index|]
expr_stmt|;
block|}
name|co_list
index|[
name|co_list_num
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|head_p
operator|=
operator|&
name|co_list
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tail_p
operator|=
operator|&
name|co_list
index|[
name|co_list_num
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ssl_cipher_collect_aliases
parameter_list|(
specifier|const
name|SSL_CIPHER
modifier|*
modifier|*
name|ca_list
parameter_list|,
name|int
name|num_of_group_aliases
parameter_list|,
name|unsigned
name|long
name|disabled_mkey
parameter_list|,
name|unsigned
name|long
name|disabled_auth
parameter_list|,
name|unsigned
name|long
name|disabled_enc
parameter_list|,
name|unsigned
name|long
name|disabled_mac
parameter_list|,
name|unsigned
name|long
name|disabled_ssl
parameter_list|,
name|CIPHER_ORDER
modifier|*
name|head
parameter_list|)
block|{
name|CIPHER_ORDER
modifier|*
name|ciph_curr
decl_stmt|;
specifier|const
name|SSL_CIPHER
modifier|*
modifier|*
name|ca_curr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|mask_mkey
init|=
operator|~
name|disabled_mkey
decl_stmt|;
name|unsigned
name|long
name|mask_auth
init|=
operator|~
name|disabled_auth
decl_stmt|;
name|unsigned
name|long
name|mask_enc
init|=
operator|~
name|disabled_enc
decl_stmt|;
name|unsigned
name|long
name|mask_mac
init|=
operator|~
name|disabled_mac
decl_stmt|;
name|unsigned
name|long
name|mask_ssl
init|=
operator|~
name|disabled_ssl
decl_stmt|;
comment|/*      * First, add the real ciphers as already collected      */
name|ciph_curr
operator|=
name|head
expr_stmt|;
name|ca_curr
operator|=
name|ca_list
expr_stmt|;
while|while
condition|(
name|ciph_curr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ca_curr
operator|=
name|ciph_curr
operator|->
name|cipher
expr_stmt|;
name|ca_curr
operator|++
expr_stmt|;
name|ciph_curr
operator|=
name|ciph_curr
operator|->
name|next
expr_stmt|;
block|}
comment|/*      * Now we add the available ones from the cipher_aliases[] table.      * They represent either one or more algorithms, some of which      * in any affected category must be supported (set in enabled_mask),      * or represent a cipher strength value (will be added in any case because algorithms=0).      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_of_group_aliases
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|algorithm_mkey
init|=
name|cipher_aliases
index|[
name|i
index|]
operator|.
name|algorithm_mkey
decl_stmt|;
name|unsigned
name|long
name|algorithm_auth
init|=
name|cipher_aliases
index|[
name|i
index|]
operator|.
name|algorithm_auth
decl_stmt|;
name|unsigned
name|long
name|algorithm_enc
init|=
name|cipher_aliases
index|[
name|i
index|]
operator|.
name|algorithm_enc
decl_stmt|;
name|unsigned
name|long
name|algorithm_mac
init|=
name|cipher_aliases
index|[
name|i
index|]
operator|.
name|algorithm_mac
decl_stmt|;
name|unsigned
name|long
name|algorithm_ssl
init|=
name|cipher_aliases
index|[
name|i
index|]
operator|.
name|algorithm_ssl
decl_stmt|;
if|if
condition|(
name|algorithm_mkey
condition|)
if|if
condition|(
operator|(
name|algorithm_mkey
operator|&
name|mask_mkey
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|algorithm_auth
condition|)
if|if
condition|(
operator|(
name|algorithm_auth
operator|&
name|mask_auth
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|algorithm_enc
condition|)
if|if
condition|(
operator|(
name|algorithm_enc
operator|&
name|mask_enc
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|algorithm_mac
condition|)
if|if
condition|(
operator|(
name|algorithm_mac
operator|&
name|mask_mac
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|algorithm_ssl
condition|)
if|if
condition|(
operator|(
name|algorithm_ssl
operator|&
name|mask_ssl
operator|)
operator|==
literal|0
condition|)
continue|continue;
operator|*
name|ca_curr
operator|=
operator|(
name|SSL_CIPHER
operator|*
operator|)
operator|(
name|cipher_aliases
operator|+
name|i
operator|)
expr_stmt|;
name|ca_curr
operator|++
expr_stmt|;
block|}
operator|*
name|ca_curr
operator|=
name|NULL
expr_stmt|;
comment|/* end of list */
block|}
end_function

begin_function
specifier|static
name|void
name|ssl_cipher_apply_rule
parameter_list|(
name|unsigned
name|long
name|cipher_id
parameter_list|,
name|unsigned
name|long
name|alg_mkey
parameter_list|,
name|unsigned
name|long
name|alg_auth
parameter_list|,
name|unsigned
name|long
name|alg_enc
parameter_list|,
name|unsigned
name|long
name|alg_mac
parameter_list|,
name|unsigned
name|long
name|alg_ssl
parameter_list|,
name|unsigned
name|long
name|algo_strength
parameter_list|,
name|int
name|rule
parameter_list|,
name|int
name|strength_bits
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|head_p
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|tail_p
parameter_list|)
block|{
name|CIPHER_ORDER
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|,
modifier|*
name|curr
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|last
decl_stmt|;
specifier|const
name|SSL_CIPHER
modifier|*
name|cp
decl_stmt|;
name|int
name|reverse
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|CIPHER_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Applying rule %d with %08lx/%08lx/%08lx/%08lx/%08lx %08lx (%d)\n"
argument_list|,
name|rule
argument_list|,
name|alg_mkey
argument_list|,
name|alg_auth
argument_list|,
name|alg_enc
argument_list|,
name|alg_mac
argument_list|,
name|alg_ssl
argument_list|,
name|algo_strength
argument_list|,
name|strength_bits
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rule
operator|==
name|CIPHER_DEL
condition|)
name|reverse
operator|=
literal|1
expr_stmt|;
comment|/* needed to maintain sorting between                                  * currently deleted ciphers */
name|head
operator|=
operator|*
name|head_p
expr_stmt|;
name|tail
operator|=
operator|*
name|tail_p
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
block|{
name|next
operator|=
name|tail
expr_stmt|;
name|last
operator|=
name|head
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|head
expr_stmt|;
name|last
operator|=
name|tail
expr_stmt|;
block|}
name|curr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|curr
operator|==
name|last
condition|)
break|break;
name|curr
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|curr
operator|==
name|NULL
condition|)
break|break;
name|next
operator|=
name|reverse
condition|?
name|curr
operator|->
name|prev
else|:
name|curr
operator|->
name|next
expr_stmt|;
name|cp
operator|=
name|curr
operator|->
name|cipher
expr_stmt|;
comment|/*          * Selection criteria is either the value of strength_bits          * or the algorithms used.          */
if|if
condition|(
name|strength_bits
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strength_bits
operator|!=
name|cp
operator|->
name|strength_bits
condition|)
continue|continue;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|CIPHER_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nName: %s:\nAlgo = %08lx/%08lx/%08lx/%08lx/%08lx Algo_strength = %08lx\n"
argument_list|,
name|cp
operator|->
name|name
argument_list|,
name|cp
operator|->
name|algorithm_mkey
argument_list|,
name|cp
operator|->
name|algorithm_auth
argument_list|,
name|cp
operator|->
name|algorithm_enc
argument_list|,
name|cp
operator|->
name|algorithm_mac
argument_list|,
name|cp
operator|->
name|algorithm_ssl
argument_list|,
name|cp
operator|->
name|algo_strength
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL
if|if
condition|(
name|cipher_id
operator|&&
name|cipher_id
operator|!=
name|cp
operator|->
name|id
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|algo_strength
operator|==
name|SSL_EXP_MASK
operator|&&
name|SSL_C_IS_EXPORT
argument_list|(
name|cp
argument_list|)
condition|)
goto|goto
name|ok
goto|;
if|if
condition|(
name|alg_ssl
operator|==
operator|~
name|SSL_SSLV2
operator|&&
name|cp
operator|->
name|algorithm_ssl
operator|==
name|SSL_SSLV2
condition|)
goto|goto
name|ok
goto|;
if|if
condition|(
name|alg_mkey
operator|&&
operator|!
operator|(
name|alg_mkey
operator|&
name|cp
operator|->
name|algorithm_mkey
operator|)
condition|)
continue|continue;
if|if
condition|(
name|alg_auth
operator|&&
operator|!
operator|(
name|alg_auth
operator|&
name|cp
operator|->
name|algorithm_auth
operator|)
condition|)
continue|continue;
if|if
condition|(
name|alg_enc
operator|&&
operator|!
operator|(
name|alg_enc
operator|&
name|cp
operator|->
name|algorithm_enc
operator|)
condition|)
continue|continue;
if|if
condition|(
name|alg_mac
operator|&&
operator|!
operator|(
name|alg_mac
operator|&
name|cp
operator|->
name|algorithm_mac
operator|)
condition|)
continue|continue;
if|if
condition|(
name|alg_ssl
operator|&&
operator|!
operator|(
name|alg_ssl
operator|&
name|cp
operator|->
name|algorithm_ssl
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|algo_strength
operator|&
name|SSL_EXP_MASK
operator|)
operator|&&
operator|!
operator|(
name|algo_strength
operator|&
name|SSL_EXP_MASK
operator|&
name|cp
operator|->
name|algo_strength
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|algo_strength
operator|&
name|SSL_STRONG_MASK
operator|)
operator|&&
operator|!
operator|(
name|algo_strength
operator|&
name|SSL_STRONG_MASK
operator|&
name|cp
operator|->
name|algo_strength
operator|)
condition|)
continue|continue;
block|}
name|ok
label|:
ifdef|#
directive|ifdef
name|CIPHER_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Action = %d\n"
argument_list|,
name|rule
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* add the cipher if it has not been added yet. */
if|if
condition|(
name|rule
operator|==
name|CIPHER_ADD
condition|)
block|{
comment|/* reverse == 0 */
if|if
condition|(
operator|!
name|curr
operator|->
name|active
condition|)
block|{
name|ll_append_tail
argument_list|(
operator|&
name|head
argument_list|,
name|curr
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|curr
operator|->
name|active
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Move the added cipher to this location */
elseif|else
if|if
condition|(
name|rule
operator|==
name|CIPHER_ORD
condition|)
block|{
comment|/* reverse == 0 */
if|if
condition|(
name|curr
operator|->
name|active
condition|)
block|{
name|ll_append_tail
argument_list|(
operator|&
name|head
argument_list|,
name|curr
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rule
operator|==
name|CIPHER_DEL
condition|)
block|{
comment|/* reverse == 1 */
if|if
condition|(
name|curr
operator|->
name|active
condition|)
block|{
comment|/*                  * most recently deleted ciphersuites get best positions for                  * any future CIPHER_ADD (note that the CIPHER_DEL loop works                  * in reverse to maintain the order)                  */
name|ll_append_head
argument_list|(
operator|&
name|head
argument_list|,
name|curr
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|curr
operator|->
name|active
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rule
operator|==
name|CIPHER_KILL
condition|)
block|{
comment|/* reverse == 0 */
if|if
condition|(
name|head
operator|==
name|curr
condition|)
name|head
operator|=
name|curr
operator|->
name|next
expr_stmt|;
else|else
name|curr
operator|->
name|prev
operator|->
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|curr
condition|)
name|tail
operator|=
name|curr
operator|->
name|prev
expr_stmt|;
name|curr
operator|->
name|active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|next
operator|!=
name|NULL
condition|)
name|curr
operator|->
name|next
operator|->
name|prev
operator|=
name|curr
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|curr
operator|->
name|prev
operator|->
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
name|curr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|curr
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
operator|*
name|head_p
operator|=
name|head
expr_stmt|;
operator|*
name|tail_p
operator|=
name|tail
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ssl_cipher_strength_sort
parameter_list|(
name|CIPHER_ORDER
modifier|*
modifier|*
name|head_p
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|tail_p
parameter_list|)
block|{
name|int
name|max_strength_bits
decl_stmt|,
name|i
decl_stmt|,
modifier|*
name|number_uses
decl_stmt|;
name|CIPHER_ORDER
modifier|*
name|curr
decl_stmt|;
comment|/*      * This routine sorts the ciphers with descending strength. The sorting      * must keep the pre-sorted sequence, so we apply the normal sorting      * routine as '+' movement to the end of the list.      */
name|max_strength_bits
operator|=
literal|0
expr_stmt|;
name|curr
operator|=
operator|*
name|head_p
expr_stmt|;
while|while
condition|(
name|curr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|curr
operator|->
name|active
operator|&&
operator|(
name|curr
operator|->
name|cipher
operator|->
name|strength_bits
operator|>
name|max_strength_bits
operator|)
condition|)
name|max_strength_bits
operator|=
name|curr
operator|->
name|cipher
operator|->
name|strength_bits
expr_stmt|;
name|curr
operator|=
name|curr
operator|->
name|next
expr_stmt|;
block|}
name|number_uses
operator|=
name|OPENSSL_malloc
argument_list|(
operator|(
name|max_strength_bits
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|number_uses
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_CIPHER_STRENGTH_SORT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
name|number_uses
argument_list|,
literal|0
argument_list|,
operator|(
name|max_strength_bits
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Now find the strength_bits values actually used      */
name|curr
operator|=
operator|*
name|head_p
expr_stmt|;
while|while
condition|(
name|curr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|curr
operator|->
name|active
condition|)
name|number_uses
index|[
name|curr
operator|->
name|cipher
operator|->
name|strength_bits
index|]
operator|++
expr_stmt|;
name|curr
operator|=
name|curr
operator|->
name|next
expr_stmt|;
block|}
comment|/*      * Go through the list of used strength_bits values in descending      * order.      */
for|for
control|(
name|i
operator|=
name|max_strength_bits
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|number_uses
index|[
name|i
index|]
operator|>
literal|0
condition|)
name|ssl_cipher_apply_rule
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CIPHER_ORD
argument_list|,
name|i
argument_list|,
name|head_p
argument_list|,
name|tail_p
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|number_uses
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ssl_cipher_process_rulestr
parameter_list|(
specifier|const
name|char
modifier|*
name|rule_str
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|head_p
parameter_list|,
name|CIPHER_ORDER
modifier|*
modifier|*
name|tail_p
parameter_list|,
specifier|const
name|SSL_CIPHER
modifier|*
modifier|*
name|ca_list
parameter_list|)
block|{
name|unsigned
name|long
name|alg_mkey
decl_stmt|,
name|alg_auth
decl_stmt|,
name|alg_enc
decl_stmt|,
name|alg_mac
decl_stmt|,
name|alg_ssl
decl_stmt|,
name|algo_strength
decl_stmt|;
specifier|const
name|char
modifier|*
name|l
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|int
name|j
decl_stmt|,
name|multi
decl_stmt|,
name|found
decl_stmt|,
name|rule
decl_stmt|,
name|retval
decl_stmt|,
name|ok
decl_stmt|,
name|buflen
decl_stmt|;
name|unsigned
name|long
name|cipher_id
init|=
literal|0
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
name|l
operator|=
name|rule_str
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
operator|*
name|l
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
break|break;
comment|/* done */
if|if
condition|(
name|ch
operator|==
literal|'-'
condition|)
block|{
name|rule
operator|=
name|CIPHER_DEL
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
name|rule
operator|=
name|CIPHER_ORD
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'!'
condition|)
block|{
name|rule
operator|=
name|CIPHER_KILL
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'@'
condition|)
block|{
name|rule
operator|=
name|CIPHER_SPECIAL
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
else|else
block|{
name|rule
operator|=
name|CIPHER_ADD
expr_stmt|;
block|}
if|if
condition|(
name|ITEM_SEP
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|l
operator|++
expr_stmt|;
continue|continue;
block|}
name|alg_mkey
operator|=
literal|0
expr_stmt|;
name|alg_auth
operator|=
literal|0
expr_stmt|;
name|alg_enc
operator|=
literal|0
expr_stmt|;
name|alg_mac
operator|=
literal|0
expr_stmt|;
name|alg_ssl
operator|=
literal|0
expr_stmt|;
name|algo_strength
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
operator|*
name|l
expr_stmt|;
name|buf
operator|=
name|l
expr_stmt|;
name|buflen
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|CHARSET_EBCDIC
while|while
condition|(
operator|(
operator|(
name|ch
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'Z'
operator|)
operator|)
operator|||
operator|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'z'
operator|)
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'-'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'.'
operator|)
condition|)
else|#
directive|else
while|while
condition|(
name|isalnum
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|ch
operator|==
literal|'-'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'.'
operator|)
condition|)
endif|#
directive|endif
block|{
name|ch
operator|=
operator|*
operator|(
operator|++
name|l
operator|)
expr_stmt|;
name|buflen
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|buflen
operator|==
literal|0
condition|)
block|{
comment|/*                  * We hit something we cannot deal with,                  * it is no command or separator nor                  * alphanumeric, so we call this an error.                  */
name|SSLerr
argument_list|(
name|SSL_F_SSL_CIPHER_PROCESS_RULESTR
argument_list|,
name|SSL_R_INVALID_COMMAND
argument_list|)
expr_stmt|;
name|retval
operator|=
name|found
operator|=
literal|0
expr_stmt|;
name|l
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rule
operator|==
name|CIPHER_SPECIAL
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
comment|/* unused -- avoid compiler warning */
break|break;
comment|/* special treatment */
block|}
comment|/* check for multi-part specification */
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
name|multi
operator|=
literal|1
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
else|else
name|multi
operator|=
literal|0
expr_stmt|;
comment|/*              * Now search for the cipher alias in the ca_list. Be careful              * with the strncmp, because the "buflen" limitation              * will make the rule "ADH:SOME" and the cipher              * "ADH-MY-CIPHER" look like a match for buflen=3.              * So additionally check whether the cipher name found              * has the correct length. We can save a strlen() call:              * just checking for the '\0' at the right place is              * sufficient, we have to strncmp() anyway. (We cannot              * use strcmp(), because buf is not '\0' terminated.)              */
name|j
operator|=
name|found
operator|=
literal|0
expr_stmt|;
name|cipher_id
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ca_list
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
name|ca_list
index|[
name|j
index|]
operator|->
name|name
argument_list|,
name|buflen
argument_list|)
operator|&&
operator|(
name|ca_list
index|[
name|j
index|]
operator|->
name|name
index|[
name|buflen
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
break|break;
comment|/* ignore this entry */
if|if
condition|(
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithm_mkey
condition|)
block|{
if|if
condition|(
name|alg_mkey
condition|)
block|{
name|alg_mkey
operator|&=
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithm_mkey
expr_stmt|;
if|if
condition|(
operator|!
name|alg_mkey
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
name|alg_mkey
operator|=
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithm_mkey
expr_stmt|;
block|}
if|if
condition|(
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithm_auth
condition|)
block|{
if|if
condition|(
name|alg_auth
condition|)
block|{
name|alg_auth
operator|&=
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithm_auth
expr_stmt|;
if|if
condition|(
operator|!
name|alg_auth
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
name|alg_auth
operator|=
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithm_auth
expr_stmt|;
block|}
if|if
condition|(
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithm_enc
condition|)
block|{
if|if
condition|(
name|alg_enc
condition|)
block|{
name|alg_enc
operator|&=
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithm_enc
expr_stmt|;
if|if
condition|(
operator|!
name|alg_enc
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
name|alg_enc
operator|=
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithm_enc
expr_stmt|;
block|}
if|if
condition|(
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithm_mac
condition|)
block|{
if|if
condition|(
name|alg_mac
condition|)
block|{
name|alg_mac
operator|&=
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithm_mac
expr_stmt|;
if|if
condition|(
operator|!
name|alg_mac
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
name|alg_mac
operator|=
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithm_mac
expr_stmt|;
block|}
if|if
condition|(
name|ca_list
index|[
name|j
index|]
operator|->
name|algo_strength
operator|&
name|SSL_EXP_MASK
condition|)
block|{
if|if
condition|(
name|algo_strength
operator|&
name|SSL_EXP_MASK
condition|)
block|{
name|algo_strength
operator|&=
operator|(
name|ca_list
index|[
name|j
index|]
operator|->
name|algo_strength
operator|&
name|SSL_EXP_MASK
operator|)
operator||
operator|~
name|SSL_EXP_MASK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|algo_strength
operator|&
name|SSL_EXP_MASK
operator|)
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
name|algo_strength
operator||=
name|ca_list
index|[
name|j
index|]
operator|->
name|algo_strength
operator|&
name|SSL_EXP_MASK
expr_stmt|;
block|}
if|if
condition|(
name|ca_list
index|[
name|j
index|]
operator|->
name|algo_strength
operator|&
name|SSL_STRONG_MASK
condition|)
block|{
if|if
condition|(
name|algo_strength
operator|&
name|SSL_STRONG_MASK
condition|)
block|{
name|algo_strength
operator|&=
operator|(
name|ca_list
index|[
name|j
index|]
operator|->
name|algo_strength
operator|&
name|SSL_STRONG_MASK
operator|)
operator||
operator|~
name|SSL_STRONG_MASK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|algo_strength
operator|&
name|SSL_STRONG_MASK
operator|)
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
name|algo_strength
operator||=
name|ca_list
index|[
name|j
index|]
operator|->
name|algo_strength
operator|&
name|SSL_STRONG_MASK
expr_stmt|;
block|}
if|if
condition|(
name|ca_list
index|[
name|j
index|]
operator|->
name|valid
condition|)
block|{
comment|/*                  * explicit ciphersuite found; its protocol version does not                  * become part of the search pattern!                  */
name|cipher_id
operator|=
name|ca_list
index|[
name|j
index|]
operator|->
name|id
expr_stmt|;
block|}
else|else
block|{
comment|/*                  * not an explicit ciphersuite; only in this case, the                  * protocol version is considered part of the search pattern                  */
if|if
condition|(
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithm_ssl
condition|)
block|{
if|if
condition|(
name|alg_ssl
condition|)
block|{
name|alg_ssl
operator|&=
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithm_ssl
expr_stmt|;
if|if
condition|(
operator|!
name|alg_ssl
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
name|alg_ssl
operator|=
name|ca_list
index|[
name|j
index|]
operator|->
name|algorithm_ssl
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|multi
condition|)
break|break;
block|}
comment|/*          * Ok, we have the rule, now apply it          */
if|if
condition|(
name|rule
operator|==
name|CIPHER_SPECIAL
condition|)
block|{
comment|/* special command */
name|ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|buflen
operator|==
literal|8
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"STRENGTH"
argument_list|,
literal|8
argument_list|)
condition|)
name|ok
operator|=
name|ssl_cipher_strength_sort
argument_list|(
name|head_p
argument_list|,
name|tail_p
argument_list|)
expr_stmt|;
else|else
name|SSLerr
argument_list|(
name|SSL_F_SSL_CIPHER_PROCESS_RULESTR
argument_list|,
name|SSL_R_INVALID_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
comment|/*              * We do not support any "multi" options              * together with "@", so throw away the              * rest of the command, if any left, until              * end or ':' is found.              */
while|while
condition|(
operator|(
operator|*
name|l
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|ITEM_SEP
argument_list|(
operator|*
name|l
argument_list|)
condition|)
name|l
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found
condition|)
block|{
name|ssl_cipher_apply_rule
argument_list|(
name|cipher_id
argument_list|,
name|alg_mkey
argument_list|,
name|alg_auth
argument_list|,
name|alg_enc
argument_list|,
name|alg_mac
argument_list|,
name|alg_ssl
argument_list|,
name|algo_strength
argument_list|,
name|rule
argument_list|,
operator|-
literal|1
argument_list|,
name|head_p
argument_list|,
name|tail_p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
operator|*
name|l
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|ITEM_SEP
argument_list|(
operator|*
name|l
argument_list|)
condition|)
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|l
operator|==
literal|'\0'
condition|)
break|break;
comment|/* done */
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
end_ifndef

begin_function
specifier|static
name|int
name|check_suiteb_cipher_list
parameter_list|(
specifier|const
name|SSL_METHOD
modifier|*
name|meth
parameter_list|,
name|CERT
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|prule_str
parameter_list|)
block|{
name|unsigned
name|int
name|suiteb_flags
init|=
literal|0
decl_stmt|,
name|suiteb_comb2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|prule_str
argument_list|,
literal|"SUITEB128ONLY"
argument_list|,
literal|13
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suiteb_flags
operator|=
name|SSL_CERT_FLAG_SUITEB_128_LOS_ONLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|prule_str
argument_list|,
literal|"SUITEB128C2"
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suiteb_comb2
operator|=
literal|1
expr_stmt|;
name|suiteb_flags
operator|=
name|SSL_CERT_FLAG_SUITEB_128_LOS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|prule_str
argument_list|,
literal|"SUITEB128"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suiteb_flags
operator|=
name|SSL_CERT_FLAG_SUITEB_128_LOS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|prule_str
argument_list|,
literal|"SUITEB192"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suiteb_flags
operator|=
name|SSL_CERT_FLAG_SUITEB_192_LOS
expr_stmt|;
block|}
if|if
condition|(
name|suiteb_flags
condition|)
block|{
name|c
operator|->
name|cert_flags
operator|&=
operator|~
name|SSL_CERT_FLAG_SUITEB_128_LOS
expr_stmt|;
name|c
operator|->
name|cert_flags
operator||=
name|suiteb_flags
expr_stmt|;
block|}
else|else
name|suiteb_flags
operator|=
name|c
operator|->
name|cert_flags
operator|&
name|SSL_CERT_FLAG_SUITEB_128_LOS
expr_stmt|;
if|if
condition|(
operator|!
name|suiteb_flags
condition|)
return|return
literal|1
return|;
comment|/* Check version: if TLS 1.2 ciphers allowed we can use Suite B */
if|if
condition|(
operator|!
operator|(
name|meth
operator|->
name|ssl3_enc
operator|->
name|enc_flags
operator|&
name|SSL_ENC_FLAG_TLS1_2_CIPHERS
operator|)
condition|)
block|{
if|if
condition|(
name|meth
operator|->
name|ssl3_enc
operator|->
name|enc_flags
operator|&
name|SSL_ENC_FLAG_DTLS
condition|)
name|SSLerr
argument_list|(
name|SSL_F_CHECK_SUITEB_CIPHER_LIST
argument_list|,
name|SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE
argument_list|)
expr_stmt|;
else|else
name|SSLerr
argument_list|(
name|SSL_F_CHECK_SUITEB_CIPHER_LIST
argument_list|,
name|SSL_R_ONLY_TLS_1_2_ALLOWED_IN_SUITEB_MODE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_ECDH
switch|switch
condition|(
name|suiteb_flags
condition|)
block|{
case|case
name|SSL_CERT_FLAG_SUITEB_128_LOS
case|:
if|if
condition|(
name|suiteb_comb2
condition|)
operator|*
name|prule_str
operator|=
literal|"ECDHE-ECDSA-AES256-GCM-SHA384"
expr_stmt|;
else|else
operator|*
name|prule_str
operator|=
literal|"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384"
expr_stmt|;
break|break;
case|case
name|SSL_CERT_FLAG_SUITEB_128_LOS_ONLY
case|:
operator|*
name|prule_str
operator|=
literal|"ECDHE-ECDSA-AES128-GCM-SHA256"
expr_stmt|;
break|break;
case|case
name|SSL_CERT_FLAG_SUITEB_192_LOS
case|:
operator|*
name|prule_str
operator|=
literal|"ECDHE-ECDSA-AES256-GCM-SHA384"
expr_stmt|;
break|break;
block|}
comment|/* Set auto ECDH parameter determination */
name|c
operator|->
name|ecdh_tmp_auto
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
else|#
directive|else
name|SSLerr
argument_list|(
name|SSL_F_CHECK_SUITEB_CIPHER_LIST
argument_list|,
name|SSL_R_ECDH_REQUIRED_FOR_SUITEB_MODE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|ssl_create_cipher_list
argument_list|(
argument|const SSL_METHOD *ssl_method
argument_list|,
argument|STACK_OF(SSL_CIPHER)                                              **cipher_list
argument_list|,
argument|STACK_OF(SSL_CIPHER)                                              **cipher_list_by_id
argument_list|,
argument|const char *rule_str
argument_list|,
argument|CERT *c
argument_list|)
block|{
name|int
name|ok
block|,
name|num_of_ciphers
block|,
name|num_of_alias_max
block|,
name|num_of_group_aliases
block|;
name|unsigned
name|long
name|disabled_mkey
block|,
name|disabled_auth
block|,
name|disabled_enc
block|,
name|disabled_mac
block|,
name|disabled_ssl
block|;
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|cipherstack
block|,
operator|*
name|tmp_cipher_list
block|;
specifier|const
name|char
operator|*
name|rule_p
block|;
name|CIPHER_ORDER
operator|*
name|co_list
operator|=
name|NULL
block|,
operator|*
name|head
operator|=
name|NULL
block|,
operator|*
name|tail
operator|=
name|NULL
block|,
operator|*
name|curr
block|;
specifier|const
name|SSL_CIPHER
operator|*
operator|*
name|ca_list
operator|=
name|NULL
block|;
comment|/*      * Return with error if nothing to do.      */
if|if
condition|(
name|rule_str
operator|==
name|NULL
operator|||
name|cipher_list
operator|==
name|NULL
operator|||
name|cipher_list_by_id
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
end_ifndef

begin_if
if|if
condition|(
operator|!
name|check_suiteb_cipher_list
argument_list|(
name|ssl_method
argument_list|,
name|c
argument_list|,
operator|&
name|rule_str
argument_list|)
condition|)
return|return
name|NULL
return|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*      * To reduce the work to do we only want to process the compiled      * in algorithms, so we first get the mask of disabled ciphers.      */
end_comment

begin_expr_stmt
name|ssl_cipher_get_disabled
argument_list|(
operator|&
name|disabled_mkey
argument_list|,
operator|&
name|disabled_auth
argument_list|,
operator|&
name|disabled_enc
argument_list|,
operator|&
name|disabled_mac
argument_list|,
operator|&
name|disabled_ssl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*      * Now we have to collect the available ciphers from the compiled      * in ciphers. We cannot get more than the number compiled in, so      * it is used for allocation.      */
end_comment

begin_expr_stmt
name|num_of_ciphers
operator|=
name|ssl_method
operator|->
name|num_ciphers
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KSSL_DEBUG
end_ifdef

begin_expr_stmt
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ssl_create_cipher_list() for %d ciphers\n"
argument_list|,
name|num_of_ciphers
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KSSL_DEBUG */
end_comment

begin_expr_stmt
name|co_list
operator|=
operator|(
name|CIPHER_ORDER
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CIPHER_ORDER
argument_list|)
operator|*
name|num_of_ciphers
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|co_list
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_CREATE_CIPHER_LIST
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Failure */
block|}
end_if

begin_expr_stmt
name|ssl_cipher_collect_ciphers
argument_list|(
name|ssl_method
argument_list|,
name|num_of_ciphers
argument_list|,
name|disabled_mkey
argument_list|,
name|disabled_auth
argument_list|,
name|disabled_enc
argument_list|,
name|disabled_mac
argument_list|,
name|disabled_ssl
argument_list|,
name|co_list
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Now arrange all ciphers by preference: */
end_comment

begin_comment
comment|/*      * Everything else being equal, prefer ephemeral ECDH over other key      * exchange mechanisms      */
end_comment

begin_expr_stmt
name|ssl_cipher_apply_rule
argument_list|(
literal|0
argument_list|,
name|SSL_kEECDH
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CIPHER_ADD
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ssl_cipher_apply_rule
argument_list|(
literal|0
argument_list|,
name|SSL_kEECDH
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CIPHER_DEL
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* AES is our preferred symmetric cipher */
end_comment

begin_expr_stmt
name|ssl_cipher_apply_rule
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SSL_AES
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CIPHER_ADD
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Temporarily enable everything else for sorting */
end_comment

begin_expr_stmt
name|ssl_cipher_apply_rule
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CIPHER_ADD
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Low priority for MD5 */
end_comment

begin_expr_stmt
name|ssl_cipher_apply_rule
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SSL_MD5
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CIPHER_ORD
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*      * Move anonymous ciphers to the end.  Usually, these will remain      * disabled. (For applications that allow them, they aren't too bad, but      * we prefer authenticated ciphers.)      */
end_comment

begin_expr_stmt
name|ssl_cipher_apply_rule
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|SSL_aNULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CIPHER_ORD
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Move ciphers without forward secrecy to the end */
end_comment

begin_expr_stmt
name|ssl_cipher_apply_rule
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|SSL_aECDH
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CIPHER_ORD
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*      * ssl_cipher_apply_rule(0, 0, SSL_aDH, 0, 0, 0, 0, CIPHER_ORD, -1,      *&head,&tail);      */
end_comment

begin_expr_stmt
name|ssl_cipher_apply_rule
argument_list|(
literal|0
argument_list|,
name|SSL_kRSA
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CIPHER_ORD
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ssl_cipher_apply_rule
argument_list|(
literal|0
argument_list|,
name|SSL_kPSK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CIPHER_ORD
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ssl_cipher_apply_rule
argument_list|(
literal|0
argument_list|,
name|SSL_kKRB5
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CIPHER_ORD
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* RC4 is sort-of broken -- move the the end */
end_comment

begin_expr_stmt
name|ssl_cipher_apply_rule
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SSL_RC4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CIPHER_ORD
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*      * Now sort by symmetric encryption strength.  The above ordering remains      * in force within each class      */
end_comment

begin_if
if|if
condition|(
operator|!
name|ssl_cipher_strength_sort
argument_list|(
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|co_list
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_if

begin_comment
comment|/* Now disable everything (maintaining the ordering!) */
end_comment

begin_expr_stmt
name|ssl_cipher_apply_rule
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CIPHER_DEL
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*      * We also need cipher aliases for selecting based on the rule_str.      * There might be two types of entries in the rule_str: 1) names      * of ciphers themselves 2) aliases for groups of ciphers.      * For 1) we need the available ciphers and for 2) the cipher      * groups of cipher_aliases added together in one list (otherwise      * we would be happy with just the cipher_aliases table).      */
end_comment

begin_expr_stmt
name|num_of_group_aliases
operator|=
sizeof|sizeof
argument_list|(
name|cipher_aliases
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|SSL_CIPHER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|num_of_alias_max
operator|=
name|num_of_ciphers
operator|+
name|num_of_group_aliases
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ca_list
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SSL_CIPHER
operator|*
argument_list|)
operator|*
name|num_of_alias_max
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ca_list
operator|==
name|NULL
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|co_list
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL_CREATE_CIPHER_LIST
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Failure */
block|}
end_if

begin_expr_stmt
name|ssl_cipher_collect_aliases
argument_list|(
name|ca_list
argument_list|,
name|num_of_group_aliases
argument_list|,
name|disabled_mkey
argument_list|,
name|disabled_auth
argument_list|,
name|disabled_enc
argument_list|,
name|disabled_mac
argument_list|,
name|disabled_ssl
argument_list|,
name|head
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*      * If the rule_string begins with DEFAULT, apply the default rule      * before using the (possibly available) additional rules.      */
end_comment

begin_expr_stmt
name|ok
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rule_p
operator|=
name|rule_str
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|strncmp
argument_list|(
name|rule_str
argument_list|,
literal|"DEFAULT"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ok
operator|=
name|ssl_cipher_process_rulestr
argument_list|(
name|SSL_DEFAULT_CIPHER_LIST
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|,
name|ca_list
argument_list|)
expr_stmt|;
name|rule_p
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
operator|*
name|rule_p
operator|==
literal|':'
condition|)
name|rule_p
operator|++
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|ok
operator|&&
operator|(
name|strlen
argument_list|(
name|rule_p
argument_list|)
operator|>
literal|0
operator|)
condition|)
name|ok
operator|=
name|ssl_cipher_process_rulestr
argument_list|(
name|rule_p
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|,
name|ca_list
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|OPENSSL_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ca_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Not needed anymore */
end_comment

begin_if
if|if
condition|(
operator|!
name|ok
condition|)
block|{
comment|/* Rule processing failure */
name|OPENSSL_free
argument_list|(
name|co_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_if

begin_comment
comment|/*      * Allocate new "cipherstack" for the result, return with error      * if we cannot get one.      */
end_comment

begin_if
if|if
condition|(
operator|(
name|cipherstack
operator|=
name|sk_SSL_CIPHER_new_null
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|co_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_if

begin_comment
comment|/*      * The cipher selection for the list is done. The ciphers are added      * to the resulting precedence to the STACK_OF(SSL_CIPHER).      */
end_comment

begin_for
for|for
control|(
name|curr
operator|=
name|head
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
if|if
condition|(
name|curr
operator|->
name|active
operator|&&
operator|(
operator|!
name|FIPS_mode
argument_list|()
operator|||
name|curr
operator|->
name|cipher
operator|->
name|algo_strength
operator|&
name|SSL_FIPS
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|curr
operator|->
name|active
condition|)
endif|#
directive|endif
block|{
name|sk_SSL_CIPHER_push
argument_list|(
name|cipherstack
argument_list|,
name|curr
operator|->
name|cipher
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CIPHER_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%s>\n"
argument_list|,
name|curr
operator|->
name|cipher
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_for

begin_expr_stmt
name|OPENSSL_free
argument_list|(
name|co_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Not needed any longer */
end_comment

begin_expr_stmt
name|tmp_cipher_list
operator|=
name|sk_SSL_CIPHER_dup
argument_list|(
name|cipherstack
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|tmp_cipher_list
operator|==
name|NULL
condition|)
block|{
name|sk_SSL_CIPHER_free
argument_list|(
name|cipherstack
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|*
name|cipher_list
operator|!=
name|NULL
condition|)
name|sk_SSL_CIPHER_free
argument_list|(
operator|*
name|cipher_list
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
operator|*
name|cipher_list
operator|=
name|cipherstack
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|cipher_list_by_id
operator|!=
name|NULL
condition|)
name|sk_SSL_CIPHER_free
argument_list|(
operator|*
name|cipher_list_by_id
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
operator|*
name|cipher_list_by_id
operator|=
name|tmp_cipher_list
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|sk_SSL_CIPHER_set_cmp_func
argument_list|(
operator|*
name|cipher_list_by_id
argument_list|,
name|ssl_cipher_ptr_id_cmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sk_SSL_CIPHER_sort
argument_list|(
operator|*
name|cipher_list_by_id
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|cipherstack
operator|)
return|;
end_return

begin_expr_stmt
unit|}  char
operator|*
name|SSL_CIPHER_description
argument_list|(
argument|const SSL_CIPHER *cipher
argument_list|,
argument|char *buf
argument_list|,
argument|int len
argument_list|)
block|{
name|int
name|is_export
block|,
name|pkl
block|,
name|kl
block|;
specifier|const
name|char
operator|*
name|ver
block|,
operator|*
name|exp_str
block|;
specifier|const
name|char
operator|*
name|kx
block|,
operator|*
name|au
block|,
operator|*
name|enc
block|,
operator|*
name|mac
block|;
name|unsigned
name|long
name|alg_mkey
block|,
name|alg_auth
block|,
name|alg_enc
block|,
name|alg_mac
block|,
name|alg_ssl
block|,
name|alg2
block|;
ifdef|#
directive|ifdef
name|KSSL_DEBUG
specifier|static
specifier|const
name|char
operator|*
name|format
operator|=
literal|"%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s%s AL=%lx/%lx/%lx/%lx/%lx\n"
block|;
else|#
directive|else
specifier|static
specifier|const
name|char
operator|*
name|format
operator|=
literal|"%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s%s\n"
block|;
endif|#
directive|endif
comment|/* KSSL_DEBUG */
name|alg_mkey
operator|=
name|cipher
operator|->
name|algorithm_mkey
block|;
name|alg_auth
operator|=
name|cipher
operator|->
name|algorithm_auth
block|;
name|alg_enc
operator|=
name|cipher
operator|->
name|algorithm_enc
block|;
name|alg_mac
operator|=
name|cipher
operator|->
name|algorithm_mac
block|;
name|alg_ssl
operator|=
name|cipher
operator|->
name|algorithm_ssl
block|;
name|alg2
operator|=
name|cipher
operator|->
name|algorithm2
block|;
name|is_export
operator|=
name|SSL_C_IS_EXPORT
argument_list|(
name|cipher
argument_list|)
block|;
name|pkl
operator|=
name|SSL_C_EXPORT_PKEYLENGTH
argument_list|(
name|cipher
argument_list|)
block|;
name|kl
operator|=
name|SSL_C_EXPORT_KEYLENGTH
argument_list|(
name|cipher
argument_list|)
block|;
name|exp_str
operator|=
name|is_export
condition|?
literal|" export"
else|:
literal|""
block|;
if|if
condition|(
name|alg_ssl
operator|&
name|SSL_SSLV2
condition|)
name|ver
operator|=
literal|"SSLv2"
expr_stmt|;
elseif|else
if|if
condition|(
name|alg_ssl
operator|&
name|SSL_SSLV3
condition|)
name|ver
operator|=
literal|"SSLv3"
expr_stmt|;
elseif|else
if|if
condition|(
name|alg_ssl
operator|&
name|SSL_TLSV1_2
condition|)
name|ver
operator|=
literal|"TLSv1.2"
expr_stmt|;
else|else
name|ver
operator|=
literal|"unknown"
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|alg_mkey
condition|)
block|{
case|case
name|SSL_kRSA
case|:
name|kx
operator|=
name|is_export
condition|?
operator|(
name|pkl
operator|==
literal|512
condition|?
literal|"RSA(512)"
else|:
literal|"RSA(1024)"
operator|)
else|:
literal|"RSA"
expr_stmt|;
break|break;
case|case
name|SSL_kDHr
case|:
name|kx
operator|=
literal|"DH/RSA"
expr_stmt|;
break|break;
case|case
name|SSL_kDHd
case|:
name|kx
operator|=
literal|"DH/DSS"
expr_stmt|;
break|break;
case|case
name|SSL_kKRB5
case|:
name|kx
operator|=
literal|"KRB5"
expr_stmt|;
break|break;
case|case
name|SSL_kEDH
case|:
name|kx
operator|=
name|is_export
condition|?
operator|(
name|pkl
operator|==
literal|512
condition|?
literal|"DH(512)"
else|:
literal|"DH(1024)"
operator|)
else|:
literal|"DH"
expr_stmt|;
break|break;
case|case
name|SSL_kECDHr
case|:
name|kx
operator|=
literal|"ECDH/RSA"
expr_stmt|;
break|break;
case|case
name|SSL_kECDHe
case|:
name|kx
operator|=
literal|"ECDH/ECDSA"
expr_stmt|;
break|break;
case|case
name|SSL_kEECDH
case|:
name|kx
operator|=
literal|"ECDH"
expr_stmt|;
break|break;
case|case
name|SSL_kPSK
case|:
name|kx
operator|=
literal|"PSK"
expr_stmt|;
break|break;
case|case
name|SSL_kSRP
case|:
name|kx
operator|=
literal|"SRP"
expr_stmt|;
break|break;
case|case
name|SSL_kGOST
case|:
name|kx
operator|=
literal|"GOST"
expr_stmt|;
break|break;
default|default:
name|kx
operator|=
literal|"unknown"
expr_stmt|;
block|}
end_switch

begin_switch
switch|switch
condition|(
name|alg_auth
condition|)
block|{
case|case
name|SSL_aRSA
case|:
name|au
operator|=
literal|"RSA"
expr_stmt|;
break|break;
case|case
name|SSL_aDSS
case|:
name|au
operator|=
literal|"DSS"
expr_stmt|;
break|break;
case|case
name|SSL_aDH
case|:
name|au
operator|=
literal|"DH"
expr_stmt|;
break|break;
case|case
name|SSL_aKRB5
case|:
name|au
operator|=
literal|"KRB5"
expr_stmt|;
break|break;
case|case
name|SSL_aECDH
case|:
name|au
operator|=
literal|"ECDH"
expr_stmt|;
break|break;
case|case
name|SSL_aNULL
case|:
name|au
operator|=
literal|"None"
expr_stmt|;
break|break;
case|case
name|SSL_aECDSA
case|:
name|au
operator|=
literal|"ECDSA"
expr_stmt|;
break|break;
case|case
name|SSL_aPSK
case|:
name|au
operator|=
literal|"PSK"
expr_stmt|;
break|break;
case|case
name|SSL_aSRP
case|:
name|au
operator|=
literal|"SRP"
expr_stmt|;
break|break;
case|case
name|SSL_aGOST94
case|:
name|au
operator|=
literal|"GOST94"
expr_stmt|;
break|break;
case|case
name|SSL_aGOST01
case|:
name|au
operator|=
literal|"GOST01"
expr_stmt|;
break|break;
default|default:
name|au
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
end_switch

begin_switch
switch|switch
condition|(
name|alg_enc
condition|)
block|{
case|case
name|SSL_DES
case|:
name|enc
operator|=
operator|(
name|is_export
operator|&&
name|kl
operator|==
literal|5
operator|)
condition|?
literal|"DES(40)"
else|:
literal|"DES(56)"
expr_stmt|;
break|break;
case|case
name|SSL_3DES
case|:
name|enc
operator|=
literal|"3DES(168)"
expr_stmt|;
break|break;
case|case
name|SSL_RC4
case|:
name|enc
operator|=
name|is_export
condition|?
operator|(
name|kl
operator|==
literal|5
condition|?
literal|"RC4(40)"
else|:
literal|"RC4(56)"
operator|)
else|:
operator|(
operator|(
name|alg2
operator|&
name|SSL2_CF_8_BYTE_ENC
operator|)
condition|?
literal|"RC4(64)"
else|:
literal|"RC4(128)"
operator|)
expr_stmt|;
break|break;
case|case
name|SSL_RC2
case|:
name|enc
operator|=
name|is_export
condition|?
operator|(
name|kl
operator|==
literal|5
condition|?
literal|"RC2(40)"
else|:
literal|"RC2(56)"
operator|)
else|:
literal|"RC2(128)"
expr_stmt|;
break|break;
case|case
name|SSL_IDEA
case|:
name|enc
operator|=
literal|"IDEA(128)"
expr_stmt|;
break|break;
case|case
name|SSL_eNULL
case|:
name|enc
operator|=
literal|"None"
expr_stmt|;
break|break;
case|case
name|SSL_AES128
case|:
name|enc
operator|=
literal|"AES(128)"
expr_stmt|;
break|break;
case|case
name|SSL_AES256
case|:
name|enc
operator|=
literal|"AES(256)"
expr_stmt|;
break|break;
case|case
name|SSL_AES128GCM
case|:
name|enc
operator|=
literal|"AESGCM(128)"
expr_stmt|;
break|break;
case|case
name|SSL_AES256GCM
case|:
name|enc
operator|=
literal|"AESGCM(256)"
expr_stmt|;
break|break;
case|case
name|SSL_CAMELLIA128
case|:
name|enc
operator|=
literal|"Camellia(128)"
expr_stmt|;
break|break;
case|case
name|SSL_CAMELLIA256
case|:
name|enc
operator|=
literal|"Camellia(256)"
expr_stmt|;
break|break;
case|case
name|SSL_SEED
case|:
name|enc
operator|=
literal|"SEED(128)"
expr_stmt|;
break|break;
case|case
name|SSL_eGOST2814789CNT
case|:
name|enc
operator|=
literal|"GOST89(256)"
expr_stmt|;
break|break;
default|default:
name|enc
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
end_switch

begin_switch
switch|switch
condition|(
name|alg_mac
condition|)
block|{
case|case
name|SSL_MD5
case|:
name|mac
operator|=
literal|"MD5"
expr_stmt|;
break|break;
case|case
name|SSL_SHA1
case|:
name|mac
operator|=
literal|"SHA1"
expr_stmt|;
break|break;
case|case
name|SSL_SHA256
case|:
name|mac
operator|=
literal|"SHA256"
expr_stmt|;
break|break;
case|case
name|SSL_SHA384
case|:
name|mac
operator|=
literal|"SHA384"
expr_stmt|;
break|break;
case|case
name|SSL_AEAD
case|:
name|mac
operator|=
literal|"AEAD"
expr_stmt|;
break|break;
case|case
name|SSL_GOST89MAC
case|:
name|mac
operator|=
literal|"GOST89"
expr_stmt|;
break|break;
case|case
name|SSL_GOST94
case|:
name|mac
operator|=
literal|"GOST94"
expr_stmt|;
break|break;
default|default:
name|mac
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
end_switch

begin_if
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|len
operator|=
literal|128
expr_stmt|;
name|buf
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"OPENSSL_malloc Error"
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<
literal|128
condition|)
return|return
operator|(
literal|"Buffer too small"
operator|)
return|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|KSSL_DEBUG
end_ifdef

begin_expr_stmt
name|BIO_snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|format
argument_list|,
name|cipher
operator|->
name|name
argument_list|,
name|ver
argument_list|,
name|kx
argument_list|,
name|au
argument_list|,
name|enc
argument_list|,
name|mac
argument_list|,
name|exp_str
argument_list|,
name|alg_mkey
argument_list|,
name|alg_auth
argument_list|,
name|alg_enc
argument_list|,
name|alg_mac
argument_list|,
name|alg_ssl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|BIO_snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|format
argument_list|,
name|cipher
operator|->
name|name
argument_list|,
name|ver
argument_list|,
name|kx
argument_list|,
name|au
argument_list|,
name|enc
argument_list|,
name|mac
argument_list|,
name|exp_str
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KSSL_DEBUG */
end_comment

begin_return
return|return
operator|(
name|buf
operator|)
return|;
end_return

begin_expr_stmt
unit|}  char
operator|*
name|SSL_CIPHER_get_version
argument_list|(
argument|const SSL_CIPHER *c
argument_list|)
block|{
name|int
name|i
block|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"(NONE)"
operator|)
return|;
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|c
operator|->
name|id
operator|>>
literal|24L
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|i
operator|==
literal|3
condition|)
return|return
operator|(
literal|"TLSv1/SSLv3"
operator|)
return|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|2
condition|)
return|return
operator|(
literal|"SSLv2"
operator|)
return|;
else|else
return|return
operator|(
literal|"unknown"
operator|)
return|;
end_if

begin_comment
unit|}
comment|/* return the actual cipher being used */
end_comment

begin_function
unit|const
name|char
modifier|*
name|SSL_CIPHER_get_name
parameter_list|(
specifier|const
name|SSL_CIPHER
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
return|return
operator|(
name|c
operator|->
name|name
operator|)
return|;
return|return
operator|(
literal|"(NONE)"
operator|)
return|;
block|}
end_function

begin_comment
comment|/* number of bits for symmetric cipher */
end_comment

begin_function
name|int
name|SSL_CIPHER_get_bits
parameter_list|(
specifier|const
name|SSL_CIPHER
modifier|*
name|c
parameter_list|,
name|int
modifier|*
name|alg_bits
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|alg_bits
operator|!=
name|NULL
condition|)
operator|*
name|alg_bits
operator|=
name|c
operator|->
name|alg_bits
expr_stmt|;
name|ret
operator|=
name|c
operator|->
name|strength_bits
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|SSL_CIPHER_get_id
parameter_list|(
specifier|const
name|SSL_CIPHER
modifier|*
name|c
parameter_list|)
block|{
return|return
name|c
operator|->
name|id
return|;
block|}
end_function

begin_decl_stmt
name|SSL_COMP
modifier|*
name|ssl3_comp_find
argument_list|(
name|STACK_OF
argument_list|(
name|SSL_COMP
argument_list|)
operator|*
name|sk
argument_list|,
name|int
name|n
argument_list|)
block|{
name|SSL_COMP
modifier|*
name|ctmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nn
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|==
literal|0
operator|)
operator|||
operator|(
name|sk
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|nn
operator|=
name|sk_SSL_COMP_num
argument_list|(
name|sk
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nn
condition|;
name|i
operator|++
control|)
block|{
name|ctmp
operator|=
name|sk_SSL_COMP_value
argument_list|(
name|sk
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctmp
operator|->
name|id
operator|==
name|n
condition|)
return|return
operator|(
name|ctmp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_NO_COMP
end_ifdef

begin_function
name|void
modifier|*
name|SSL_COMP_get_compression_methods
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|SSL_COMP_add_compression_method
parameter_list|(
name|int
name|id
parameter_list|,
name|void
modifier|*
name|cm
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|SSL_COMP_get_name
parameter_list|(
specifier|const
name|void
modifier|*
name|comp
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|STACK_OF
argument_list|(
name|SSL_COMP
argument_list|)
operator|*
name|SSL_COMP_get_compression_methods
argument_list|(
argument|void
argument_list|)
block|{
name|load_builtin_compressions
argument_list|()
block|;
return|return
operator|(
name|ssl_comp_methods
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|STACK_OF
argument_list|(
name|SSL_COMP
argument_list|)
operator|*
name|SSL_COMP_set0_compression_methods
argument_list|(
argument|STACK_OF(SSL_COMP)                                                       *meths
argument_list|)
block|{
name|STACK_OF
argument_list|(
name|SSL_COMP
argument_list|)
operator|*
name|old_meths
operator|=
name|ssl_comp_methods
block|;
name|ssl_comp_methods
operator|=
name|meths
block|;
return|return
name|old_meths
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|void
name|cmeth_free
parameter_list|(
name|SSL_COMP
modifier|*
name|cm
parameter_list|)
block|{
name|OPENSSL_free
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SSL_COMP_free_compression_methods
parameter_list|(
name|void
parameter_list|)
block|{
name|STACK_OF
argument_list|(
name|SSL_COMP
argument_list|)
operator|*
name|old_meths
operator|=
name|ssl_comp_methods
expr_stmt|;
name|ssl_comp_methods
operator|=
name|NULL
expr_stmt|;
name|sk_SSL_COMP_pop_free
argument_list|(
name|old_meths
argument_list|,
name|cmeth_free
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|SSL_COMP_add_compression_method
parameter_list|(
name|int
name|id
parameter_list|,
name|COMP_METHOD
modifier|*
name|cm
parameter_list|)
block|{
name|SSL_COMP
modifier|*
name|comp
decl_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
operator|||
name|cm
operator|->
name|type
operator|==
name|NID_undef
condition|)
return|return
literal|1
return|;
comment|/*-      * According to draft-ietf-tls-compression-04.txt, the      * compression number ranges should be the following:      *      *   0 to  63:  methods defined by the IETF      *  64 to 192:  external party methods assigned by IANA      * 193 to 255:  reserved for private use      */
if|if
condition|(
name|id
operator|<
literal|193
operator|||
name|id
operator|>
literal|255
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD
argument_list|,
name|SSL_R_COMPRESSION_ID_NOT_WITHIN_PRIVATE_RANGE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|MemCheck_off
argument_list|()
expr_stmt|;
name|comp
operator|=
operator|(
name|SSL_COMP
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SSL_COMP
argument_list|)
argument_list|)
expr_stmt|;
name|comp
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|comp
operator|->
name|method
operator|=
name|cm
expr_stmt|;
name|load_builtin_compressions
argument_list|()
expr_stmt|;
if|if
condition|(
name|ssl_comp_methods
operator|&&
name|sk_SSL_COMP_find
argument_list|(
name|ssl_comp_methods
argument_list|,
name|comp
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
name|MemCheck_on
argument_list|()
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD
argument_list|,
name|SSL_R_DUPLICATE_COMPRESSION_ID
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ssl_comp_methods
operator|==
name|NULL
operator|)
operator|||
operator|!
name|sk_SSL_COMP_push
argument_list|(
name|ssl_comp_methods
argument_list|,
name|comp
argument_list|)
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
name|MemCheck_on
argument_list|()
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|MemCheck_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|SSL_COMP_get_name
parameter_list|(
specifier|const
name|COMP_METHOD
modifier|*
name|comp
parameter_list|)
block|{
if|if
condition|(
name|comp
condition|)
return|return
name|comp
operator|->
name|name
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For a cipher return the index corresponding to the certificate type */
end_comment

begin_function
name|int
name|ssl_cipher_get_cert_index
parameter_list|(
specifier|const
name|SSL_CIPHER
modifier|*
name|c
parameter_list|)
block|{
name|unsigned
name|long
name|alg_k
decl_stmt|,
name|alg_a
decl_stmt|;
name|alg_k
operator|=
name|c
operator|->
name|algorithm_mkey
expr_stmt|;
name|alg_a
operator|=
name|c
operator|->
name|algorithm_auth
expr_stmt|;
if|if
condition|(
name|alg_k
operator|&
operator|(
name|SSL_kECDHr
operator||
name|SSL_kECDHe
operator|)
condition|)
block|{
comment|/*          * we don't need to look at SSL_kEECDH since no certificate is needed          * for anon ECDH and for authenticated EECDH, the check for the auth          * algorithm will set i correctly NOTE: For ECDH-RSA, we need an ECC          * not an RSA cert but for EECDH-RSA we need an RSA cert. Placing the          * checks for SSL_kECDH before RSA checks ensures the correct cert is          * chosen.          */
return|return
name|SSL_PKEY_ECC
return|;
block|}
elseif|else
if|if
condition|(
name|alg_a
operator|&
name|SSL_aECDSA
condition|)
return|return
name|SSL_PKEY_ECC
return|;
elseif|else
if|if
condition|(
name|alg_k
operator|&
name|SSL_kDHr
condition|)
return|return
name|SSL_PKEY_DH_RSA
return|;
elseif|else
if|if
condition|(
name|alg_k
operator|&
name|SSL_kDHd
condition|)
return|return
name|SSL_PKEY_DH_DSA
return|;
elseif|else
if|if
condition|(
name|alg_a
operator|&
name|SSL_aDSS
condition|)
return|return
name|SSL_PKEY_DSA_SIGN
return|;
elseif|else
if|if
condition|(
name|alg_a
operator|&
name|SSL_aRSA
condition|)
return|return
name|SSL_PKEY_RSA_ENC
return|;
elseif|else
if|if
condition|(
name|alg_a
operator|&
name|SSL_aKRB5
condition|)
comment|/* VRS something else here? */
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|alg_a
operator|&
name|SSL_aGOST94
condition|)
return|return
name|SSL_PKEY_GOST94
return|;
elseif|else
if|if
condition|(
name|alg_a
operator|&
name|SSL_aGOST01
condition|)
return|return
name|SSL_PKEY_GOST01
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|const
name|SSL_CIPHER
modifier|*
name|ssl_get_cipher_by_char
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|SSL_CIPHER
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|ssl
operator|->
name|method
operator|->
name|get_cipher_by_char
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|valid
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|const
name|SSL_CIPHER
modifier|*
name|SSL_CIPHER_find
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|)
block|{
return|return
name|ssl
operator|->
name|method
operator|->
name|get_cipher_by_char
argument_list|(
name|ptr
argument_list|)
return|;
block|}
end_function

end_unit

