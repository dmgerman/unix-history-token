begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ssl/s2_srvr.c */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *   * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *   * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from   *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *   * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|"ssl_locl.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_SSL2
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_function_decl
specifier|static
name|SSL_METHOD
modifier|*
name|ssl2_get_server_method
parameter_list|(
name|int
name|ver
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_client_master_key
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_client_hello
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|server_hello
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_client_finished
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|server_verify
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|server_finish
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|request_certificate
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ssl_rsa_private_decrypt
parameter_list|(
name|CERT
modifier|*
name|c
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|from
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
name|int
name|padding
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BREAK
value|break
end_define

begin_function
specifier|static
name|SSL_METHOD
modifier|*
name|ssl2_get_server_method
parameter_list|(
name|int
name|ver
parameter_list|)
block|{
if|if
condition|(
name|ver
operator|==
name|SSL2_VERSION
condition|)
return|return
operator|(
name|SSLv2_server_method
argument_list|()
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_macro
name|IMPLEMENT_ssl2_meth_func
argument_list|(
argument|SSLv2_server_method
argument_list|,
argument|ssl2_accept
argument_list|,
argument|ssl_undefined_function
argument_list|,
argument|ssl2_get_server_method
argument_list|)
end_macro

begin_function
name|int
name|ssl2_accept
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|long
name|l
init|=
operator|(
name|unsigned
name|long
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|BUF_MEM
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|num1
decl_stmt|;
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
specifier|const
name|SSL
modifier|*
name|ssl
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|val
parameter_list|)
init|=
name|NULL
function_decl|;
name|int
name|new_state
decl_stmt|,
name|state
decl_stmt|;
name|RAND_add
argument_list|(
operator|&
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
name|clear_sys_error
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|info_callback
operator|!=
name|NULL
condition|)
name|cb
operator|=
name|s
operator|->
name|info_callback
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|info_callback
operator|!=
name|NULL
condition|)
name|cb
operator|=
name|s
operator|->
name|ctx
operator|->
name|info_callback
expr_stmt|;
comment|/* init things to blank */
name|s
operator|->
name|in_handshake
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_in_init
argument_list|(
name|s
argument_list|)
operator|||
name|SSL_in_before
argument_list|(
name|s
argument_list|)
condition|)
name|SSL_clear
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|cert
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL2_ACCEPT
argument_list|,
name|SSL_R_NO_CERTIFICATE_SET
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|clear_sys_error
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|state
operator|=
name|s
operator|->
name|state
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|state
condition|)
block|{
case|case
name|SSL_ST_BEFORE
case|:
case|case
name|SSL_ST_ACCEPT
case|:
case|case
name|SSL_ST_BEFORE
operator||
name|SSL_ST_ACCEPT
case|:
case|case
name|SSL_ST_OK
operator||
name|SSL_ST_ACCEPT
case|:
name|s
operator|->
name|server
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cb
operator|!=
name|NULL
condition|)
name|cb
argument_list|(
name|s
argument_list|,
name|SSL_CB_HANDSHAKE_START
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|->
name|version
operator|=
name|SSL2_VERSION
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|SSL_ST_ACCEPT
expr_stmt|;
name|buf
operator|=
name|s
operator|->
name|init_buf
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|buf
operator|=
name|BUF_MEM_new
argument_list|()
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|!
name|BUF_MEM_grow
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|s
operator|->
name|init_buf
operator|=
name|buf
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|ctx
operator|->
name|stats
operator|.
name|sess_accept
operator|++
expr_stmt|;
name|s
operator|->
name|handshake_func
operator|=
name|ssl2_accept
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_GET_CLIENT_HELLO_A
expr_stmt|;
name|BREAK
expr_stmt|;
case|case
name|SSL2_ST_GET_CLIENT_HELLO_A
case|:
case|case
name|SSL2_ST_GET_CLIENT_HELLO_B
case|:
case|case
name|SSL2_ST_GET_CLIENT_HELLO_C
case|:
name|s
operator|->
name|shutdown
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|get_client_hello
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_SERVER_HELLO_A
expr_stmt|;
name|BREAK
expr_stmt|;
case|case
name|SSL2_ST_SEND_SERVER_HELLO_A
case|:
case|case
name|SSL2_ST_SEND_SERVER_HELLO_B
case|:
name|ret
operator|=
name|server_hello
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|hit
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|SSL2_ST_GET_CLIENT_MASTER_KEY_A
expr_stmt|;
name|BREAK
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SERVER_START_ENCRYPTION
expr_stmt|;
name|BREAK
expr_stmt|;
block|}
case|case
name|SSL2_ST_GET_CLIENT_MASTER_KEY_A
case|:
case|case
name|SSL2_ST_GET_CLIENT_MASTER_KEY_B
case|:
name|ret
operator|=
name|get_client_master_key
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SERVER_START_ENCRYPTION
expr_stmt|;
name|BREAK
expr_stmt|;
case|case
name|SSL2_ST_SERVER_START_ENCRYPTION
case|:
comment|/* Ok we how have sent all the stuff needed to 			 * start encrypting, the next packet back will 			 * be encrypted. */
if|if
condition|(
operator|!
name|ssl2_enc_init
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|s
operator|->
name|s2
operator|->
name|clear_text
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_SERVER_VERIFY_A
expr_stmt|;
name|BREAK
expr_stmt|;
case|case
name|SSL2_ST_SEND_SERVER_VERIFY_A
case|:
case|case
name|SSL2_ST_SEND_SERVER_VERIFY_B
case|:
name|ret
operator|=
name|server_verify
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|hit
condition|)
block|{
comment|/* If we are in here, we have been 				 * buffering the output, so we need to 				 * flush it and remove buffering from 				 * future traffic */
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_SERVER_VERIFY_C
expr_stmt|;
name|BREAK
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|state
operator|=
name|SSL2_ST_GET_CLIENT_FINISHED_A
expr_stmt|;
break|break;
block|}
case|case
name|SSL2_ST_SEND_SERVER_VERIFY_C
case|:
comment|/* get the number of bytes to write */
name|num1
operator|=
name|BIO_ctrl
argument_list|(
name|s
operator|->
name|wbio
argument_list|,
name|BIO_CTRL_INFO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|num1
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|rwstate
operator|=
name|SSL_WRITING
expr_stmt|;
name|num1
operator|=
name|BIO_flush
argument_list|(
name|s
operator|->
name|wbio
argument_list|)
expr_stmt|;
if|if
condition|(
name|num1
operator|<=
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|s
operator|->
name|rwstate
operator|=
name|SSL_NOTHING
expr_stmt|;
block|}
comment|/* flushed and now remove buffering */
name|s
operator|->
name|wbio
operator|=
name|BIO_pop
argument_list|(
name|s
operator|->
name|wbio
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_GET_CLIENT_FINISHED_A
expr_stmt|;
name|BREAK
expr_stmt|;
case|case
name|SSL2_ST_GET_CLIENT_FINISHED_A
case|:
case|case
name|SSL2_ST_GET_CLIENT_FINISHED_B
case|:
name|ret
operator|=
name|get_client_finished
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_REQUEST_CERTIFICATE_A
expr_stmt|;
name|BREAK
expr_stmt|;
case|case
name|SSL2_ST_SEND_REQUEST_CERTIFICATE_A
case|:
case|case
name|SSL2_ST_SEND_REQUEST_CERTIFICATE_B
case|:
case|case
name|SSL2_ST_SEND_REQUEST_CERTIFICATE_C
case|:
case|case
name|SSL2_ST_SEND_REQUEST_CERTIFICATE_D
case|:
comment|/* don't do a 'request certificate' if we 			 * don't want to, or we already have one, and 			 * we only want to do it once. */
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|verify_mode
operator|&
name|SSL_VERIFY_PEER
operator|)
operator|||
operator|(
operator|(
name|s
operator|->
name|session
operator|->
name|peer
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|s
operator|->
name|verify_mode
operator|&
name|SSL_VERIFY_CLIENT_ONCE
operator|)
operator|)
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_SERVER_FINISHED_A
expr_stmt|;
break|break;
block|}
else|else
block|{
name|ret
operator|=
name|request_certificate
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_SERVER_FINISHED_A
expr_stmt|;
block|}
name|BREAK
expr_stmt|;
case|case
name|SSL2_ST_SEND_SERVER_FINISHED_A
case|:
case|case
name|SSL2_ST_SEND_SERVER_FINISHED_B
case|:
name|ret
operator|=
name|server_finish
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|end
goto|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL_ST_OK
expr_stmt|;
break|break;
case|case
name|SSL_ST_OK
case|:
name|BUF_MEM_free
argument_list|(
name|s
operator|->
name|init_buf
argument_list|)
expr_stmt|;
name|ssl_free_wbio_buffer
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_buf
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
comment|/*	ERR_clear_error();*/
name|ssl_update_cache
argument_list|(
name|s
argument_list|,
name|SSL_SESS_CACHE_SERVER
argument_list|)
expr_stmt|;
name|s
operator|->
name|ctx
operator|->
name|stats
operator|.
name|sess_accept_good
operator|++
expr_stmt|;
comment|/* s->server=1; */
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cb
operator|!=
name|NULL
condition|)
name|cb
argument_list|(
name|s
argument_list|,
name|SSL_CB_HANDSHAKE_DONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
comment|/* BREAK; */
default|default:
name|SSLerr
argument_list|(
name|SSL_F_SSL2_ACCEPT
argument_list|,
name|SSL_R_UNKNOWN_STATE
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
comment|/* BREAK; */
block|}
if|if
condition|(
operator|(
name|cb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|s
operator|->
name|state
operator|!=
name|state
operator|)
condition|)
block|{
name|new_state
operator|=
name|s
operator|->
name|state
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|cb
argument_list|(
name|s
argument_list|,
name|SSL_CB_ACCEPT_LOOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|new_state
expr_stmt|;
block|}
block|}
name|end
label|:
name|s
operator|->
name|in_handshake
operator|--
expr_stmt|;
if|if
condition|(
name|cb
operator|!=
name|NULL
condition|)
name|cb
argument_list|(
name|s
argument_list|,
name|SSL_CB_ACCEPT_EXIT
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_client_master_key
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|is_export
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|keya
decl_stmt|,
name|ek
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|SSL_CIPHER
modifier|*
name|cp
decl_stmt|;
specifier|const
name|EVP_CIPHER
modifier|*
name|c
decl_stmt|;
specifier|const
name|EVP_MD
modifier|*
name|md
decl_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_GET_CLIENT_MASTER_KEY_A
condition|)
block|{
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
literal|10
operator|-
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
literal|10
operator|-
name|s
operator|->
name|init_num
operator|)
condition|)
return|return
operator|(
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_GET_CLIENT_MASTER_KEY
argument_list|,
name|i
argument_list|)
operator|)
return|;
name|s
operator|->
name|init_num
operator|=
literal|10
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
operator|++
operator|)
operator|!=
name|SSL2_MT_CLIENT_MASTER_KEY
condition|)
block|{
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|SSL2_MT_ERROR
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_MASTER_KEY
argument_list|,
name|SSL_R_READ_WRONG_PACKET_TYPE
argument_list|)
expr_stmt|;
block|}
else|else
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_MASTER_KEY
argument_list|,
name|SSL_R_PEER_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|=
name|ssl2_get_cipher_by_char
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_NO_CIPHER
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_MASTER_KEY
argument_list|,
name|SSL_R_NO_CIPHER_MATCH
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|s
operator|->
name|session
operator|->
name|cipher
operator|=
name|cp
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|clear
operator|=
name|i
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|enc
operator|=
name|i
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|key_arg_length
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|key_arg_length
operator|>
name|SSL_MAX_KEY_ARG_LENGTH
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_MASTER_KEY
argument_list|,
name|SSL_R_KEY_ARG_TOO_LONG
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|s
operator|->
name|state
operator|=
name|SSL2_ST_GET_CLIENT_MASTER_KEY_B
expr_stmt|;
block|}
comment|/* SSL2_ST_GET_CLIENT_MASTER_KEY_B */
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|init_buf
operator|->
name|length
operator|<
name|SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_MASTER_KEY
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|keya
operator|=
name|s
operator|->
name|session
operator|->
name|key_arg_length
expr_stmt|;
name|len
operator|=
literal|10
operator|+
operator|(
name|unsigned
name|long
operator|)
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|clear
operator|+
operator|(
name|unsigned
name|long
operator|)
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|enc
operator|+
operator|(
name|unsigned
name|long
operator|)
name|keya
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_MASTER_KEY
argument_list|,
name|SSL_R_MESSAGE_TOO_LONG
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|n
operator|=
operator|(
name|int
operator|)
name|len
operator|-
name|s
operator|->
name|init_num
expr_stmt|;
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|n
condition|)
return|return
operator|(
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_GET_CLIENT_MASTER_KEY
argument_list|,
name|i
argument_list|)
operator|)
return|;
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|0
argument_list|,
name|s
operator|->
name|version
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
comment|/* CLIENT-MASTER-KEY */
name|p
operator|+=
literal|10
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|session
operator|->
name|key_arg
argument_list|,
operator|&
operator|(
name|p
index|[
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|clear
operator|+
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|enc
index|]
operator|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|keya
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|cert
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|privatekey
operator|==
name|NULL
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_MASTER_KEY
argument_list|,
name|SSL_R_NO_PRIVATEKEY
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|i
operator|=
name|ssl_rsa_private_decrypt
argument_list|(
name|s
operator|->
name|cert
argument_list|,
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|enc
argument_list|,
operator|&
operator|(
name|p
index|[
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|clear
index|]
operator|)
argument_list|,
operator|&
operator|(
name|p
index|[
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|clear
index|]
operator|)
argument_list|,
operator|(
name|s
operator|->
name|s2
operator|->
name|ssl2_rollback
operator|)
condition|?
name|RSA_SSLV23_PADDING
else|:
name|RSA_PKCS1_PADDING
argument_list|)
expr_stmt|;
name|is_export
operator|=
name|SSL_C_IS_EXPORT
argument_list|(
name|s
operator|->
name|session
operator|->
name|cipher
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_cipher_get_evp
argument_list|(
name|s
operator|->
name|session
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|md
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_NO_CIPHER
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_MASTER_KEY
argument_list|,
name|SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|cipher
operator|->
name|algorithm2
operator|&
name|SSL2_CF_8_BYTE_ENC
condition|)
block|{
name|is_export
operator|=
literal|1
expr_stmt|;
name|ek
operator|=
literal|8
expr_stmt|;
block|}
else|else
name|ek
operator|=
literal|5
expr_stmt|;
comment|/* bad decrypt */
if|#
directive|if
literal|1
comment|/* If a bad decrypt, continue with protocol but with a 	 * random master secret (Bleichenbacher attack) */
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
operator|!
name|is_export
operator|&&
operator|(
name|i
operator|!=
name|EVP_CIPHER_key_length
argument_list|(
name|c
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|is_export
operator|&&
operator|(
operator|(
name|i
operator|!=
name|ek
operator|)
operator|||
operator|(
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|clear
operator|+
operator|(
name|unsigned
name|int
operator|)
name|i
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|EVP_CIPHER_key_length
argument_list|(
name|c
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|ERR_clear_error
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_export
condition|)
name|i
operator|=
name|ek
expr_stmt|;
else|else
name|i
operator|=
name|EVP_CIPHER_key_length
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|RAND_pseudo_bytes
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|#
directive|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_MASTER_KEY
argument_list|,
name|SSL_R_BAD_RSA_DECRYPT
argument_list|)
expr_stmt|;
block|}
comment|/* incorrect number of key bytes for non export cipher */
elseif|else
if|if
condition|(
operator|(
operator|!
name|is_export
operator|&&
operator|(
name|i
operator|!=
name|EVP_CIPHER_key_length
argument_list|(
name|c
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|is_export
operator|&&
operator|(
operator|(
name|i
operator|!=
name|ek
operator|)
operator|||
operator|(
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|clear
operator|+
name|i
operator|!=
name|EVP_CIPHER_key_length
argument_list|(
name|c
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_MASTER_KEY
argument_list|,
name|SSL_R_WRONG_NUMBER_OF_KEY_BITS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|is_export
condition|)
name|i
operator|+=
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|clear
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|SSL_MAX_MASTER_KEY_LENGTH
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_MASTER_KEY
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|s
operator|->
name|session
operator|->
name|master_key_length
operator|=
name|i
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|session
operator|->
name|master_key
argument_list|,
name|p
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_client_hello
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|cs
expr_stmt|;
comment|/* a stack of SSL_CIPHERS */
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|cl
expr_stmt|;
comment|/* the ones we want to use */
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|prio
operator|,
operator|*
name|allow
expr_stmt|;
name|int
name|z
decl_stmt|;
comment|/* This is a bit of a hack to check for the correct packet 	 * type the first time round. */
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_GET_CLIENT_HELLO_A
condition|)
block|{
name|s
operator|->
name|first_packet
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_GET_CLIENT_HELLO_B
expr_stmt|;
block|}
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_GET_CLIENT_HELLO_B
condition|)
block|{
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
literal|9
operator|-
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
literal|9
operator|-
name|s
operator|->
name|init_num
operator|)
condition|)
return|return
operator|(
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_GET_CLIENT_HELLO
argument_list|,
name|i
argument_list|)
operator|)
return|;
name|s
operator|->
name|init_num
operator|=
literal|9
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
operator|++
operator|)
operator|!=
name|SSL2_MT_CLIENT_HELLO
condition|)
block|{
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|SSL2_MT_ERROR
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_HELLO
argument_list|,
name|SSL_R_READ_WRONG_PACKET_TYPE
argument_list|)
expr_stmt|;
block|}
else|else
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_HELLO
argument_list|,
name|SSL_R_PEER_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|s
operator|->
name|version
condition|)
name|s
operator|->
name|version
operator|=
name|i
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|cipher_spec_length
operator|=
name|i
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|session_id_length
operator|=
name|i
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|->
name|s2
operator|->
name|challenge_length
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
name|SSL2_MIN_CHALLENGE_LENGTH
operator|)
operator|||
operator|(
name|i
operator|>
name|SSL2_MAX_CHALLENGE_LENGTH
operator|)
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_HELLO
argument_list|,
name|SSL_R_INVALID_CHALLENGE_LENGTH
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|s
operator|->
name|state
operator|=
name|SSL2_ST_GET_CLIENT_HELLO_C
expr_stmt|;
block|}
comment|/* SSL2_ST_GET_CLIENT_HELLO_C */
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
name|len
operator|=
literal|9
operator|+
operator|(
name|unsigned
name|long
operator|)
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|cipher_spec_length
operator|+
operator|(
name|unsigned
name|long
operator|)
name|s
operator|->
name|s2
operator|->
name|challenge_length
operator|+
operator|(
name|unsigned
name|long
operator|)
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|session_id_length
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_HELLO
argument_list|,
name|SSL_R_MESSAGE_TOO_LONG
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|n
operator|=
operator|(
name|int
operator|)
name|len
operator|-
name|s
operator|->
name|init_num
expr_stmt|;
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|n
condition|)
return|return
operator|(
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_GET_CLIENT_HELLO
argument_list|,
name|i
argument_list|)
operator|)
return|;
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|0
argument_list|,
name|s
operator|->
name|version
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
comment|/* CLIENT-HELLO */
name|p
operator|+=
literal|9
expr_stmt|;
comment|/* get session-id before cipher stuff so we can get out session 	 * structure if it is cached */
comment|/* session-id */
if|if
condition|(
operator|(
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|session_id_length
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|session_id_length
operator|!=
name|SSL2_SSL_SESSION_ID_LENGTH
operator|)
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_HELLO
argument_list|,
name|SSL_R_BAD_SSL_SESSION_ID_LENGTH
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|session_id_length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_get_new_session
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|i
operator|=
name|ssl_get_prev_session
argument_list|(
name|s
argument_list|,
operator|&
operator|(
name|p
index|[
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|cipher_spec_length
index|]
operator|)
argument_list|,
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|session_id_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
comment|/* previous session */
name|s
operator|->
name|hit
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|s
operator|->
name|cert
operator|==
name|NULL
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_NO_CERTIFICATE
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_HELLO
argument_list|,
name|SSL_R_NO_CERTIFICATE_SET
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ssl_get_new_session
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|hit
condition|)
block|{
name|cs
operator|=
name|ssl_bytes_to_cipher_list
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|cipher_spec_length
argument_list|,
operator|&
name|s
operator|->
name|session
operator|->
name|ciphers
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|==
name|NULL
condition|)
goto|goto
name|mem_err
goto|;
name|cl
operator|=
name|SSL_get_ciphers
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_CIPHER_SERVER_PREFERENCE
condition|)
block|{
name|prio
operator|=
name|sk_SSL_CIPHER_dup
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|prio
operator|==
name|NULL
condition|)
goto|goto
name|mem_err
goto|;
name|allow
operator|=
name|cs
expr_stmt|;
block|}
else|else
block|{
name|prio
operator|=
name|cs
expr_stmt|;
name|allow
operator|=
name|cl
expr_stmt|;
block|}
for|for
control|(
name|z
operator|=
literal|0
init|;
name|z
operator|<
name|sk_SSL_CIPHER_num
argument_list|(
name|prio
argument_list|)
condition|;
name|z
operator|++
control|)
block|{
if|if
condition|(
name|sk_SSL_CIPHER_find
argument_list|(
name|allow
argument_list|,
name|sk_SSL_CIPHER_value
argument_list|(
name|prio
argument_list|,
name|z
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sk_SSL_CIPHER_delete
argument_list|(
name|prio
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|z
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|->
name|options
operator|&
name|SSL_OP_CIPHER_SERVER_PREFERENCE
condition|)
block|{
name|sk_SSL_CIPHER_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|ciphers
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|ciphers
operator|=
name|prio
expr_stmt|;
block|}
comment|/* s->session->ciphers should now have a list of 		 * ciphers that are on both the client and server. 		 * This list is ordered by the order the client sent 		 * the ciphers or in the order of the server's preference 		 * if SSL_OP_CIPHER_SERVER_PREFERENCE was set. 		 */
block|}
name|p
operator|+=
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|cipher_spec_length
expr_stmt|;
comment|/* done cipher selection */
comment|/* session id extracted already */
name|p
operator|+=
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|session_id_length
expr_stmt|;
comment|/* challenge */
if|if
condition|(
name|s
operator|->
name|s2
operator|->
name|challenge_length
operator|>
sizeof|sizeof
name|s
operator|->
name|s2
operator|->
name|challenge
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_HELLO
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|s
operator|->
name|s2
operator|->
name|challenge
argument_list|,
name|p
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|s2
operator|->
name|challenge_length
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|mem_err
label|:
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_HELLO
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|server_hello
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|int
name|n
decl_stmt|,
name|hit
decl_stmt|;
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|sk
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_SEND_SERVER_HELLO_A
condition|)
block|{
name|d
operator|=
name|p
operator|+
literal|11
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|SSL2_MT_SERVER_HELLO
expr_stmt|;
comment|/* type */
name|hit
operator|=
name|s
operator|->
name|hit
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
operator|(
name|unsigned
name|char
operator|)
name|hit
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
operator|!
name|hit
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|!=
name|NULL
condition|)
comment|/* This can't really happen because get_client_hello 				 * has called ssl_get_new_session, which does not set 				 * sess_cert. */
name|ssl_sess_cert_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|=
name|ssl_sess_cert_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SERVER_HELLO
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* If 'hit' is set, then s->sess_cert may be non-NULL or NULL, 		 * depending on whether it survived in the internal cache 		 * or was retrieved from an external cache. 		 * If it is NULL, we cannot put any useful data in it anyway, 		 * so we don't touch it. 		 */
else|#
directive|else
comment|/* That's what used to be done when cert_st and sess_cert_st were 	   * the same. */
if|if
condition|(
operator|!
name|hit
condition|)
block|{
comment|/* else add cert to session */
name|CRYPTO_add
argument_list|(
operator|&
name|s
operator|->
name|cert
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_SSL_CERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|!=
name|NULL
condition|)
name|ssl_cert_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|sess_cert
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|=
name|s
operator|->
name|cert
expr_stmt|;
block|}
else|else
comment|/* We have a session id-cache hit, if the 			 * session-id has no certificate listed against 			 * the 'cert' structure, grab the 'old' one 			 * listed against the SSL connection */
block|{
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|==
name|NULL
condition|)
block|{
name|CRYPTO_add
argument_list|(
operator|&
name|s
operator|->
name|cert
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_SSL_CERT
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|sess_cert
operator|=
name|s
operator|->
name|cert
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|cert
operator|==
name|NULL
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_NO_CERTIFICATE
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_SERVER_HELLO
argument_list|,
name|SSL_R_NO_CERTIFICATE_SPECIFIED
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|hit
condition|)
block|{
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* no certificate type */
name|s2n
argument_list|(
name|s
operator|->
name|version
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* version */
name|s2n
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* cert len */
name|s2n
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* ciphers len */
block|}
else|else
block|{
comment|/* EAY EAY */
comment|/* put certificate type */
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|SSL2_CT_X509_CERTIFICATE
expr_stmt|;
name|s2n
argument_list|(
name|s
operator|->
name|version
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* version */
name|n
operator|=
name|i2d_X509
argument_list|(
name|s
operator|->
name|cert
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|x509
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* certificate length */
name|i2d_X509
argument_list|(
name|s
operator|->
name|cert
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|x509
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
comment|/* lets send out the ciphers we like in the 			 * prefered order */
name|sk
operator|=
name|s
operator|->
name|session
operator|->
name|ciphers
expr_stmt|;
name|n
operator|=
name|ssl_cipher_list_to_bytes
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|session
operator|->
name|ciphers
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|+=
name|n
expr_stmt|;
name|s2n
argument_list|(
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* add cipher length */
block|}
comment|/* make and send conn_id */
name|s2n
argument_list|(
name|SSL2_CONNECTION_ID_LENGTH
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* add conn_id length */
name|s
operator|->
name|s2
operator|->
name|conn_id_length
operator|=
name|SSL2_CONNECTION_ID_LENGTH
expr_stmt|;
if|if
condition|(
name|RAND_pseudo_bytes
argument_list|(
name|s
operator|->
name|s2
operator|->
name|conn_id
argument_list|,
operator|(
name|int
operator|)
name|s
operator|->
name|s2
operator|->
name|conn_id_length
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
operator|->
name|s2
operator|->
name|conn_id
argument_list|,
name|SSL2_CONNECTION_ID_LENGTH
argument_list|)
expr_stmt|;
name|d
operator|+=
name|SSL2_CONNECTION_ID_LENGTH
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_SERVER_HELLO_B
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
name|d
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
block|}
comment|/* SSL2_ST_SEND_SERVER_HELLO_B */
comment|/* If we are using TCP/IP, the performance is bad if we do 2  	 * writes without a read between them.  This occurs when  	 * Session-id reuse is used, so I will put in a buffering module  	 */
if|if
condition|(
name|s
operator|->
name|hit
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_init_wbio_buffer
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|ssl2_do_write
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_client_finished
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_GET_CLIENT_FINISHED_A
condition|)
block|{
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
literal|1
operator|-
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
operator|-
name|s
operator|->
name|init_num
condition|)
return|return
operator|(
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_GET_CLIENT_FINISHED
argument_list|,
name|i
argument_list|)
operator|)
return|;
name|s
operator|->
name|init_num
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
name|SSL2_MT_CLIENT_FINISHED
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
name|SSL2_MT_ERROR
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_FINISHED
argument_list|,
name|SSL_R_READ_WRONG_PACKET_TYPE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_FINISHED
argument_list|,
name|SSL_R_PEER_ERROR
argument_list|)
expr_stmt|;
comment|/* try to read the error message */
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
literal|3
operator|-
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
return|return
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_GET_SERVER_VERIFY
argument_list|,
name|i
argument_list|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|s
operator|->
name|state
operator|=
name|SSL2_ST_GET_CLIENT_FINISHED_B
expr_stmt|;
block|}
comment|/* SSL2_ST_GET_CLIENT_FINISHED_B */
if|if
condition|(
name|s
operator|->
name|s2
operator|->
name|conn_id_length
operator|>
sizeof|sizeof
name|s
operator|->
name|s2
operator|->
name|conn_id
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_FINISHED
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|len
operator|=
literal|1
operator|+
operator|(
name|unsigned
name|long
operator|)
name|s
operator|->
name|s2
operator|->
name|conn_id_length
expr_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|len
operator|-
name|s
operator|->
name|init_num
expr_stmt|;
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|n
condition|)
block|{
return|return
operator|(
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_GET_CLIENT_FINISHED
argument_list|,
name|i
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|0
argument_list|,
name|s
operator|->
name|version
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
comment|/* CLIENT-FINISHED */
name|p
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|s2
operator|->
name|conn_id
argument_list|,
name|s
operator|->
name|s2
operator|->
name|conn_id_length
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_GET_CLIENT_FINISHED
argument_list|,
name|SSL_R_CONNECTION_ID_IS_DIFFERENT
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|server_verify
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_SEND_SERVER_VERIFY_A
condition|)
block|{
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|SSL2_MT_SERVER_VERIFY
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s2
operator|->
name|challenge_length
operator|>
sizeof|sizeof
name|s
operator|->
name|s2
operator|->
name|challenge
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SERVER_VERIFY
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|s2
operator|->
name|challenge
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|s2
operator|->
name|challenge_length
argument_list|)
expr_stmt|;
comment|/* p+=s->s2->challenge_length; */
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_SERVER_VERIFY_B
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
name|s
operator|->
name|s2
operator|->
name|challenge_length
operator|+
literal|1
expr_stmt|;
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ssl2_do_write
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|server_finish
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_SEND_SERVER_FINISHED_A
condition|)
block|{
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|SSL2_MT_SERVER_FINISHED
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|session_id_length
operator|>
sizeof|sizeof
name|s
operator|->
name|session
operator|->
name|session_id
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SERVER_FINISH
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|session
operator|->
name|session_id
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|session
operator|->
name|session_id_length
argument_list|)
expr_stmt|;
comment|/* p+=s->session->session_id_length; */
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_SERVER_FINISHED_B
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
name|s
operator|->
name|session
operator|->
name|session_id_length
operator|+
literal|1
expr_stmt|;
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
block|}
comment|/* SSL2_ST_SEND_SERVER_FINISHED_B */
return|return
operator|(
name|ssl2_do_write
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* send the request and check the response */
end_comment

begin_function
specifier|static
name|int
name|request_certificate
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ccd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ctype
decl_stmt|,
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
name|X509
modifier|*
name|x509
init|=
name|NULL
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|sk
operator|=
name|NULL
expr_stmt|;
name|ccd
operator|=
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|ccl
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_SEND_REQUEST_CERTIFICATE_A
condition|)
block|{
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|SSL2_MT_REQUEST_CERTIFICATE
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|SSL2_AT_MD5_WITH_RSA_ENCRYPTION
expr_stmt|;
if|if
condition|(
name|RAND_pseudo_bytes
argument_list|(
name|ccd
argument_list|,
name|SSL2_MIN_CERT_CHALLENGE_LENGTH
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|ccd
argument_list|,
name|SSL2_MIN_CERT_CHALLENGE_LENGTH
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_REQUEST_CERTIFICATE_B
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
name|SSL2_MIN_CERT_CHALLENGE_LENGTH
operator|+
literal|2
expr_stmt|;
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_SEND_REQUEST_CERTIFICATE_B
condition|)
block|{
name|i
operator|=
name|ssl2_do_write
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|ret
operator|=
name|i
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_REQUEST_CERTIFICATE_C
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|SSL2_ST_SEND_REQUEST_CERTIFICATE_C
condition|)
block|{
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
literal|6
operator|-
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
comment|/* try to read 6 octets ... */
if|if
condition|(
name|i
operator|<
literal|3
operator|-
name|s
operator|->
name|init_num
condition|)
comment|/* ... but don't call ssl2_part_read now if we got at least 3 		                        * (probably NO-CERTIFICATE-ERROR) */
block|{
name|ret
operator|=
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_REQUEST_CERTIFICATE
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|s
operator|->
name|init_num
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|init_num
operator|>=
literal|3
operator|)
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|==
name|SSL2_MT_ERROR
operator|)
condition|)
block|{
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|SSL2_PE_NO_CERTIFICATE
condition|)
block|{
comment|/* not the error message we expected -- let ssl2_part_read handle it */
name|s
operator|->
name|init_num
operator|-=
literal|3
expr_stmt|;
name|ret
operator|=
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_REQUEST_CERTIFICATE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|0
argument_list|,
name|s
operator|->
name|version
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
literal|3
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
comment|/* ERROR */
comment|/* this is the one place where we can recover from an SSL 2.0 error */
if|if
condition|(
name|s
operator|->
name|verify_mode
operator|&
name|SSL_VERIFY_FAIL_IF_NO_PEER_CERT
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_BAD_CERTIFICATE
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_REQUEST_CERTIFICATE
argument_list|,
name|SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|(
operator|*
operator|(
name|p
operator|++
operator|)
operator|!=
name|SSL2_MT_CLIENT_CERTIFICATE
operator|)
operator|||
operator|(
name|s
operator|->
name|init_num
operator|<
literal|6
operator|)
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNDEFINED_ERROR
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_REQUEST_CERTIFICATE
argument_list|,
name|SSL_R_SHORT_READ
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|s
operator|->
name|init_num
operator|!=
literal|6
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_REQUEST_CERTIFICATE
argument_list|,
name|ERR_R_INTERNAL_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* ok we have a response */
comment|/* certificate type, there is only one right now. */
name|ctype
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|SSL2_AT_MD5_WITH_RSA_ENCRYPTION
condition|)
block|{
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_UNSUPPORTED_CERTIFICATE_TYPE
argument_list|)
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_REQUEST_CERTIFICATE
argument_list|,
name|SSL_R_BAD_RESPONSE_ARGUMENT
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|clen
operator|=
name|i
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|rlen
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|SSL2_ST_SEND_REQUEST_CERTIFICATE_D
expr_stmt|;
block|}
comment|/* SSL2_ST_SEND_REQUEST_CERTIFICATE_D */
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
name|len
operator|=
literal|6
operator|+
operator|(
name|unsigned
name|long
operator|)
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|clen
operator|+
operator|(
name|unsigned
name|long
operator|)
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|rlen
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_REQUEST_CERTIFICATE
argument_list|,
name|SSL_R_MESSAGE_TOO_LONG
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|j
operator|=
operator|(
name|int
operator|)
name|len
operator|-
name|s
operator|->
name|init_num
expr_stmt|;
name|i
operator|=
name|ssl2_read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
index|[
name|s
operator|->
name|init_num
index|]
operator|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|j
condition|)
block|{
name|ret
operator|=
name|ssl2_part_read
argument_list|(
name|s
argument_list|,
name|SSL_F_REQUEST_CERTIFICATE
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|0
argument_list|,
name|s
operator|->
name|version
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
comment|/* CLIENT-CERTIFICATE */
name|p
operator|+=
literal|6
expr_stmt|;
name|cp
operator|=
name|p
expr_stmt|;
name|x509
operator|=
operator|(
name|X509
operator|*
operator|)
name|d2i_X509
argument_list|(
name|NULL
argument_list|,
operator|&
name|cp
argument_list|,
operator|(
name|long
operator|)
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|clen
argument_list|)
expr_stmt|;
if|if
condition|(
name|x509
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_REQUEST_CERTIFICATE
argument_list|,
name|ERR_R_X509_LIB
argument_list|)
expr_stmt|;
goto|goto
name|msg_end
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|sk
operator|=
name|sk_X509_new_null
argument_list|()
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|!
name|sk_X509_push
argument_list|(
name|sk
argument_list|,
name|x509
argument_list|)
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_REQUEST_CERTIFICATE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|msg_end
goto|;
block|}
name|i
operator|=
name|ssl_verify_cert_chain
argument_list|(
name|s
argument_list|,
name|sk
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
comment|/* we like the packet, now check the chksum */
block|{
name|EVP_MD_CTX
name|ctx
decl_stmt|;
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
name|EVP_MD_CTX_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|EVP_VerifyInit_ex
argument_list|(
operator|&
name|ctx
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|rsa_md5
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|EVP_VerifyUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|s
operator|->
name|s2
operator|->
name|key_material
argument_list|,
name|s
operator|->
name|s2
operator|->
name|key_material_length
argument_list|)
expr_stmt|;
name|EVP_VerifyUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|ccd
argument_list|,
name|SSL2_MIN_CERT_CHALLENGE_LENGTH
argument_list|)
expr_stmt|;
name|i
operator|=
name|i2d_X509
argument_list|(
name|s
operator|->
name|cert
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|x509
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|buf2
operator|=
name|OPENSSL_malloc
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf2
operator|==
name|NULL
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_REQUEST_CERTIFICATE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|msg_end
goto|;
block|}
name|p2
operator|=
name|buf2
expr_stmt|;
name|i
operator|=
name|i2d_X509
argument_list|(
name|s
operator|->
name|cert
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|x509
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
name|EVP_VerifyUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf2
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|x509
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
name|i
operator|=
name|EVP_VerifyFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|cp
argument_list|,
name|s
operator|->
name|s2
operator|->
name|tmp
operator|.
name|rlen
argument_list|,
name|pkey
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|session
operator|->
name|peer
operator|!=
name|NULL
condition|)
name|X509_free
argument_list|(
name|s
operator|->
name|session
operator|->
name|peer
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|peer
operator|=
name|x509
expr_stmt|;
name|CRYPTO_add
argument_list|(
operator|&
name|x509
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_X509
argument_list|)
expr_stmt|;
name|s
operator|->
name|session
operator|->
name|verify_result
operator|=
name|s
operator|->
name|verify_result
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
else|else
block|{
name|SSLerr
argument_list|(
name|SSL_F_REQUEST_CERTIFICATE
argument_list|,
name|SSL_R_BAD_CHECKSUM
argument_list|)
expr_stmt|;
goto|goto
name|msg_end
goto|;
block|}
block|}
else|else
block|{
name|msg_end
label|:
name|ssl2_return_error
argument_list|(
name|s
argument_list|,
name|SSL2_PE_BAD_CERTIFICATE
argument_list|)
expr_stmt|;
block|}
name|end
label|:
name|sk_X509_free
argument_list|(
name|sk
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ssl_rsa_private_decrypt
parameter_list|(
name|CERT
modifier|*
name|c
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|from
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
name|int
name|padding
parameter_list|)
block|{
name|RSA
modifier|*
name|rsa
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|NULL
operator|)
operator|||
operator|(
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|privatekey
operator|==
name|NULL
operator|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_RSA_PRIVATE_DECRYPT
argument_list|,
name|SSL_R_NO_PRIVATEKEY
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|privatekey
operator|->
name|type
operator|!=
name|EVP_PKEY_RSA
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_SSL_RSA_PRIVATE_DECRYPT
argument_list|,
name|SSL_R_PUBLIC_KEY_IS_NOT_RSA
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rsa
operator|=
name|c
operator|->
name|pkeys
index|[
name|SSL_PKEY_RSA_ENC
index|]
operator|.
name|privatekey
operator|->
name|pkey
operator|.
name|rsa
expr_stmt|;
comment|/* we have the public key */
name|i
operator|=
name|RSA_private_decrypt
argument_list|(
name|len
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|rsa
argument_list|,
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|SSLerr
argument_list|(
name|SSL_F_SSL_RSA_PRIVATE_DECRYPT
argument_list|,
name|ERR_R_RSA_LIB
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !OPENSSL_NO_SSL2 */
end_comment

begin_if
if|#
directive|if
name|PEDANTIC
end_if

begin_decl_stmt
specifier|static
name|void
modifier|*
name|dummy
init|=
operator|&
name|dummy
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

