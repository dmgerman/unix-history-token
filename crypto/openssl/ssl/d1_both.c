begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ssl/d1_both.c */
end_comment

begin_comment
comment|/*   * DTLS implementation written by Nagendra Modadugu  * (nagendra@cs.stanford.edu) for the OpenSSL project 2005.    */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *   * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *   * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from   *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *   * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ssl_locl.h"
end_include

begin_include
include|#
directive|include
file|<openssl/buffer.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509.h>
end_include

begin_define
define|#
directive|define
name|RSMBLY_BITMASK_SIZE
parameter_list|(
name|msg_len
parameter_list|)
value|(((msg_len) + 7) / 8)
end_define

begin_define
define|#
directive|define
name|RSMBLY_BITMASK_MARK
parameter_list|(
name|bitmask
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
value|{ \ 			if ((end) - (start)<= 8) { \ 				long ii; \ 				for (ii = (start); ii< (end); ii++) bitmask[((ii)>> 3)] |= (1<< ((ii)& 7)); \ 			} else { \ 				long ii; \ 				bitmask[((start)>> 3)] |= bitmask_start_values[((start)& 7)]; \ 				for (ii = (((start)>> 3) + 1); ii< ((((end) - 1))>> 3); ii++) bitmask[ii] = 0xff; \ 				bitmask[(((end) - 1)>> 3)] |= bitmask_end_values[((end)& 7)]; \ 			} }
end_define

begin_define
define|#
directive|define
name|RSMBLY_BITMASK_IS_COMPLETE
parameter_list|(
name|bitmask
parameter_list|,
name|msg_len
parameter_list|,
name|is_complete
parameter_list|)
value|{ \ 			long ii; \ 			OPENSSL_assert((msg_len)> 0); \ 			is_complete = 1; \ 			if (bitmask[(((msg_len) - 1)>> 3)] != bitmask_end_values[((msg_len)& 7)]) is_complete = 0; \ 			if (is_complete) for (ii = (((msg_len) - 1)>> 3) - 1; ii>= 0 ; ii--) \ 				if (bitmask[ii] != 0xff) { is_complete = 0; break; } }
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|RSMBLY_BITMASK_PRINT
parameter_list|(
name|bitmask
parameter_list|,
name|msg_len
parameter_list|)
value|{ \ 			long ii; \ 			printf("bitmask: "); for (ii = 0; ii< (msg_len); ii++) \ 			printf("%d ", (bitmask[ii>> 3]& (1<< (ii& 7)))>> (ii& 7)); \ 			printf("\n"); }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|bitmask_start_values
index|[]
init|=
block|{
literal|0xff
block|,
literal|0xfe
block|,
literal|0xfc
block|,
literal|0xf8
block|,
literal|0xf0
block|,
literal|0xe0
block|,
literal|0xc0
block|,
literal|0x80
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|bitmask_end_values
index|[]
init|=
block|{
literal|0xff
block|,
literal|0x01
block|,
literal|0x03
block|,
literal|0x07
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x3f
block|,
literal|0x7f
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XDTLS:  figure out the right values */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|g_probable_mtu
index|[]
init|=
block|{
literal|1500
operator|-
literal|28
block|,
literal|512
operator|-
literal|28
block|,
literal|256
operator|-
literal|28
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|unsigned
name|int
name|dtls1_guess_mtu
parameter_list|(
name|unsigned
name|int
name|curr_mtu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtls1_fix_message_header
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|unsigned
name|long
name|frag_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|dtls1_write_message_header
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtls1_set_message_header_int
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
name|mt
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|unsigned
name|short
name|seq_num
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|unsigned
name|long
name|frag_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|dtls1_get_message_fragment
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|st1
parameter_list|,
name|int
name|stn
parameter_list|,
name|long
name|max
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|hm_fragment
modifier|*
name|dtls1_hm_fragment_new
parameter_list|(
name|unsigned
name|long
name|frag_len
parameter_list|,
name|int
name|reassembly
parameter_list|)
block|{
name|hm_fragment
modifier|*
name|frag
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bitmask
init|=
name|NULL
decl_stmt|;
name|frag
operator|=
operator|(
name|hm_fragment
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hm_fragment
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|frag_len
condition|)
block|{
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
name|frag_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* zero length fragment gets zero frag->fragment */
name|frag
operator|->
name|fragment
operator|=
name|buf
expr_stmt|;
comment|/* Initialize reassembly bitmask if necessary */
if|if
condition|(
name|reassembly
condition|)
block|{
name|bitmask
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
name|RSMBLY_BITMASK_SIZE
argument_list|(
name|frag_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmask
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|bitmask
argument_list|,
literal|0
argument_list|,
name|RSMBLY_BITMASK_SIZE
argument_list|(
name|frag_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|frag
operator|->
name|reassembly
operator|=
name|bitmask
expr_stmt|;
return|return
name|frag
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtls1_hm_fragment_free
parameter_list|(
name|hm_fragment
modifier|*
name|frag
parameter_list|)
block|{
if|if
condition|(
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
condition|)
block|{
name|EVP_CIPHER_CTX_free
argument_list|(
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|enc_write_ctx
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_destroy
argument_list|(
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|write_hash
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frag
operator|->
name|fragment
condition|)
name|OPENSSL_free
argument_list|(
name|frag
operator|->
name|fragment
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|reassembly
condition|)
name|OPENSSL_free
argument_list|(
name|frag
operator|->
name|reassembly
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* send s->init_buf in records of type 'type' (SSL3_RT_HANDSHAKE or SSL3_RT_CHANGE_CIPHER_SPEC) */
end_comment

begin_function
name|int
name|dtls1_do_write
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|curr_mtu
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|,
name|frag_off
decl_stmt|,
name|mac_size
decl_stmt|,
name|blocksize
decl_stmt|;
comment|/* AHA!  Figure out the MTU, and stick to the right size */
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|mtu
operator|<
name|dtls1_min_mtu
argument_list|()
operator|&&
operator|!
operator|(
name|SSL_get_options
argument_list|(
name|s
argument_list|)
operator|&
name|SSL_OP_NO_QUERY_MTU
operator|)
condition|)
block|{
name|s
operator|->
name|d1
operator|->
name|mtu
operator|=
name|BIO_ctrl
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_CTRL_DGRAM_QUERY_MTU
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* I've seen the kernel return bogus numbers when it doesn't know 		 * (initial write), so just make sure we have a reasonable number */
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|mtu
operator|<
name|dtls1_min_mtu
argument_list|()
condition|)
block|{
name|s
operator|->
name|d1
operator|->
name|mtu
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|mtu
operator|=
name|dtls1_guess_mtu
argument_list|(
name|s
operator|->
name|d1
operator|->
name|mtu
argument_list|)
expr_stmt|;
name|BIO_ctrl
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_CTRL_DGRAM_SET_MTU
argument_list|,
name|s
operator|->
name|d1
operator|->
name|mtu
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|mtu = s->d1->mtu;  	fprintf(stderr, "using MTU = %d\n", mtu);  	mtu -= (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH);  	curr_mtu = mtu - BIO_wpending(SSL_get_wbio(s));  	if ( curr_mtu> 0) 		mtu = curr_mtu; 	else if ( ( ret = BIO_flush(SSL_get_wbio(s)))<= 0) 		return ret;  	if ( BIO_wpending(SSL_get_wbio(s)) + s->init_num>= mtu) 		{ 		ret = BIO_flush(SSL_get_wbio(s)); 		if ( ret<= 0) 			return ret; 		mtu = s->d1->mtu - (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH); 		}
endif|#
directive|endif
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|mtu
operator|>=
name|dtls1_min_mtu
argument_list|()
argument_list|)
expr_stmt|;
comment|/* should have something reasonable now */
if|if
condition|(
name|s
operator|->
name|init_off
operator|==
literal|0
operator|&&
name|type
operator|==
name|SSL3_RT_HANDSHAKE
condition|)
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|init_num
operator|==
operator|(
name|int
operator|)
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|msg_len
operator|+
name|DTLS1_HM_HEADER_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|write_hash
condition|)
name|mac_size
operator|=
name|EVP_MD_CTX_size
argument_list|(
name|s
operator|->
name|write_hash
argument_list|)
expr_stmt|;
else|else
name|mac_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|enc_write_ctx
operator|&&
operator|(
name|EVP_CIPHER_mode
argument_list|(
name|s
operator|->
name|enc_write_ctx
operator|->
name|cipher
argument_list|)
operator|&
name|EVP_CIPH_CBC_MODE
operator|)
condition|)
name|blocksize
operator|=
literal|2
operator|*
name|EVP_CIPHER_block_size
argument_list|(
name|s
operator|->
name|enc_write_ctx
operator|->
name|cipher
argument_list|)
expr_stmt|;
else|else
name|blocksize
operator|=
literal|0
expr_stmt|;
name|frag_off
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|s
operator|->
name|init_num
condition|)
block|{
name|curr_mtu
operator|=
name|s
operator|->
name|d1
operator|->
name|mtu
operator|-
name|BIO_wpending
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|)
operator|-
name|DTLS1_RT_HEADER_LENGTH
operator|-
name|mac_size
operator|-
name|blocksize
expr_stmt|;
if|if
condition|(
name|curr_mtu
operator|<=
name|DTLS1_HM_HEADER_LENGTH
condition|)
block|{
comment|/* grr.. we could get an error if MTU picked was wrong */
name|ret
operator|=
name|BIO_flush
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
return|return
name|ret
return|;
name|curr_mtu
operator|=
name|s
operator|->
name|d1
operator|->
name|mtu
operator|-
name|DTLS1_RT_HEADER_LENGTH
operator|-
name|mac_size
operator|-
name|blocksize
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|init_num
operator|>
name|curr_mtu
condition|)
name|len
operator|=
name|curr_mtu
expr_stmt|;
else|else
name|len
operator|=
name|s
operator|->
name|init_num
expr_stmt|;
comment|/* XDTLS: this function is too long.  split out the CCS part */
if|if
condition|(
name|type
operator|==
name|SSL3_RT_HANDSHAKE
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|init_off
operator|!=
literal|0
condition|)
block|{
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|init_off
operator|>
name|DTLS1_HM_HEADER_LENGTH
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_off
operator|-=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|s
operator|->
name|init_num
operator|+=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|init_num
operator|>
name|curr_mtu
condition|)
name|len
operator|=
name|curr_mtu
expr_stmt|;
else|else
name|len
operator|=
name|s
operator|->
name|init_num
expr_stmt|;
block|}
name|dtls1_fix_message_header
argument_list|(
name|s
argument_list|,
name|frag_off
argument_list|,
name|len
operator|-
name|DTLS1_HM_HEADER_LENGTH
argument_list|)
expr_stmt|;
name|dtls1_write_message_header
argument_list|(
name|s
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|s
operator|->
name|init_buf
operator|->
name|data
index|[
name|s
operator|->
name|init_off
index|]
argument_list|)
expr_stmt|;
name|OPENSSL_assert
argument_list|(
name|len
operator|>=
name|DTLS1_HM_HEADER_LENGTH
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|dtls1_write_bytes
argument_list|(
name|s
argument_list|,
name|type
argument_list|,
operator|&
name|s
operator|->
name|init_buf
operator|->
name|data
index|[
name|s
operator|->
name|init_off
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* might need to update MTU here, but we don't know 			 * which previous packet caused the failure -- so can't 			 * really retransmit anything.  continue as if everything 			 * is fine and wait for an alert to handle the 			 * retransmit  			 */
if|if
condition|(
name|BIO_ctrl
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_CTRL_DGRAM_MTU_EXCEEDED
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|>
literal|0
condition|)
name|s
operator|->
name|d1
operator|->
name|mtu
operator|=
name|BIO_ctrl
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_CTRL_DGRAM_QUERY_MTU
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* bad if this assert fails, only part of the handshake 			 * message got sent.  but why would this happen? */
name|OPENSSL_assert
argument_list|(
name|len
operator|==
operator|(
name|unsigned
name|int
operator|)
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SSL3_RT_HANDSHAKE
operator|&&
operator|!
name|s
operator|->
name|d1
operator|->
name|retransmitting
condition|)
block|{
comment|/* should not be done for 'Hello Request's, but in that case 				 * we'll ignore the result anyway */
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|s
operator|->
name|init_buf
operator|->
name|data
index|[
name|s
operator|->
name|init_off
index|]
decl_stmt|;
specifier|const
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
init|=
operator|&
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
decl_stmt|;
name|int
name|xlen
decl_stmt|;
if|if
condition|(
name|frag_off
operator|==
literal|0
operator|&&
name|s
operator|->
name|version
operator|!=
name|DTLS1_BAD_VER
condition|)
block|{
comment|/* reconstruct message header is if it 					 * is being sent in single fragment */
operator|*
name|p
operator|++
operator|=
name|msg_hdr
operator|->
name|type
expr_stmt|;
name|l2n3
argument_list|(
name|msg_hdr
operator|->
name|msg_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|msg_hdr
operator|->
name|seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
name|msg_hdr
operator|->
name|msg_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|-=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|xlen
operator|=
name|ret
expr_stmt|;
block|}
else|else
block|{
name|p
operator|+=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|xlen
operator|=
name|ret
operator|-
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
block|}
name|ssl3_finish_mac
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|xlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|s
operator|->
name|init_num
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|1
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|type
argument_list|,
name|s
operator|->
name|init_buf
operator|->
name|data
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|s
operator|->
name|init_off
operator|+
name|s
operator|->
name|init_num
argument_list|)
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
comment|/* done writing this message */
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|s
operator|->
name|init_off
operator|+=
name|ret
expr_stmt|;
name|s
operator|->
name|init_num
operator|-=
name|ret
expr_stmt|;
name|frag_off
operator|+=
operator|(
name|ret
operator|-=
name|DTLS1_HM_HEADER_LENGTH
operator|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Obtain handshake message of message type 'mt' (any if mt == -1),  * maximum acceptable body length 'max'.  * Read an entire handshake message.  Handshake messages arrive in  * fragments.  */
end_comment

begin_function
name|long
name|dtls1_get_message
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|st1
parameter_list|,
name|int
name|stn
parameter_list|,
name|int
name|mt
parameter_list|,
name|long
name|max
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|al
decl_stmt|;
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|msg_len
decl_stmt|;
comment|/* s3->tmp is used to store messages that are unexpected, caused 	 * by the absence of an optional handshake message */
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|reuse_message
condition|)
block|{
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|reuse_message
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|mt
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|!=
name|mt
operator|)
condition|)
block|{
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_GET_MESSAGE
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
operator|*
name|ok
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|init_msg
operator|=
name|s
operator|->
name|init_buf
operator|->
name|data
operator|+
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
operator|(
name|int
operator|)
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_size
expr_stmt|;
return|return
name|s
operator|->
name|init_num
return|;
block|}
name|msg_hdr
operator|=
operator|&
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
expr_stmt|;
name|memset
argument_list|(
name|msg_hdr
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hm_header_st
argument_list|)
argument_list|)
expr_stmt|;
name|again
label|:
name|i
operator|=
name|dtls1_get_message_fragment
argument_list|(
name|s
argument_list|,
name|st1
argument_list|,
name|stn
argument_list|,
name|max
argument_list|,
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|DTLS1_HM_BAD_FRAGMENT
operator|||
name|i
operator|==
name|DTLS1_HM_FRAGMENT_RETRY
condition|)
comment|/* bad fragment received */
goto|goto
name|again
goto|;
elseif|else
if|if
condition|(
name|i
operator|<=
literal|0
operator|&&
operator|!
operator|*
name|ok
condition|)
return|return
name|i
return|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
name|msg_len
operator|=
name|msg_hdr
operator|->
name|msg_len
expr_stmt|;
comment|/* reconstruct message header */
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|msg_hdr
operator|->
name|type
expr_stmt|;
name|l2n3
argument_list|(
name|msg_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|msg_hdr
operator|->
name|seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
name|msg_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|version
operator|!=
name|DTLS1_BAD_VER
condition|)
block|{
name|p
operator|-=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|msg_len
operator|+=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
block|}
name|ssl3_finish_mac
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|0
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|p
argument_list|,
name|msg_len
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|msg_hdr
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hm_header_st
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't change sequence numbers while listening */
if|if
condition|(
operator|!
name|s
operator|->
name|d1
operator|->
name|listen
condition|)
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
operator|++
expr_stmt|;
name|s
operator|->
name|init_msg
operator|=
name|s
operator|->
name|init_buf
operator|->
name|data
operator|+
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
return|return
name|s
operator|->
name|init_num
return|;
name|f_err
label|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtls1_preprocess_fragment
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|size_t
name|frag_off
decl_stmt|,
name|frag_len
decl_stmt|,
name|msg_len
decl_stmt|;
name|msg_len
operator|=
name|msg_hdr
operator|->
name|msg_len
expr_stmt|;
name|frag_off
operator|=
name|msg_hdr
operator|->
name|frag_off
expr_stmt|;
name|frag_len
operator|=
name|msg_hdr
operator|->
name|frag_len
expr_stmt|;
comment|/* sanity checking */
if|if
condition|(
operator|(
name|frag_off
operator|+
name|frag_len
operator|)
operator|>
name|msg_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_PREPROCESS_FRAGMENT
argument_list|,
name|SSL_R_EXCESSIVE_MESSAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|SSL_AD_ILLEGAL_PARAMETER
return|;
block|}
if|if
condition|(
operator|(
name|frag_off
operator|+
name|frag_len
operator|)
operator|>
operator|(
name|unsigned
name|long
operator|)
name|max
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_PREPROCESS_FRAGMENT
argument_list|,
name|SSL_R_EXCESSIVE_MESSAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|SSL_AD_ILLEGAL_PARAMETER
return|;
block|}
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|frag_off
operator|==
literal|0
condition|)
comment|/* first fragment */
block|{
comment|/* msg_len is limited to 2^24, but is effectively checked 		 * against max above */
if|if
condition|(
operator|!
name|BUF_MEM_grow_clean
argument_list|(
name|s
operator|->
name|init_buf
argument_list|,
name|msg_len
operator|+
name|DTLS1_HM_HEADER_LENGTH
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_PREPROCESS_FRAGMENT
argument_list|,
name|ERR_R_BUF_LIB
argument_list|)
expr_stmt|;
return|return
name|SSL_AD_INTERNAL_ERROR
return|;
block|}
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_size
operator|=
name|msg_len
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|msg_len
operator|=
name|msg_len
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|=
name|msg_hdr
operator|->
name|type
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|type
operator|=
name|msg_hdr
operator|->
name|type
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|seq
operator|=
name|msg_hdr
operator|->
name|seq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msg_len
operator|!=
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|msg_len
condition|)
block|{
comment|/* They must be playing with us! BTW, failure to enforce 		 * upper limit would open possibility for buffer overrun. */
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_PREPROCESS_FRAGMENT
argument_list|,
name|SSL_R_EXCESSIVE_MESSAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|SSL_AD_ILLEGAL_PARAMETER
return|;
block|}
return|return
literal|0
return|;
comment|/* no error */
block|}
end_function

begin_function
specifier|static
name|int
name|dtls1_retrieve_buffered_fragment
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|long
name|max
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
block|{
comment|/* (0) check whether the desired fragment is available 	 * if so: 	 * (1) copy over the fragment to s->init_buf->data[] 	 * (2) update s->init_num 	 */
name|pitem
modifier|*
name|item
decl_stmt|;
name|hm_fragment
modifier|*
name|frag
decl_stmt|;
name|int
name|al
decl_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
name|item
operator|=
name|pqueue_peek
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|frag
operator|=
operator|(
name|hm_fragment
operator|*
operator|)
name|item
operator|->
name|data
expr_stmt|;
comment|/* Don't return if reassembly still in progress */
if|if
condition|(
name|frag
operator|->
name|reassembly
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
operator|==
name|frag
operator|->
name|msg_header
operator|.
name|seq
condition|)
block|{
name|unsigned
name|long
name|frag_len
init|=
name|frag
operator|->
name|msg_header
operator|.
name|frag_len
decl_stmt|;
name|pqueue_pop
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|)
expr_stmt|;
name|al
operator|=
name|dtls1_preprocess_fragment
argument_list|(
name|s
argument_list|,
operator|&
name|frag
operator|->
name|msg_header
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
literal|0
condition|)
comment|/* no alert */
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
operator|+
name|DTLS1_HM_HEADER_LENGTH
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|p
index|[
name|frag
operator|->
name|msg_header
operator|.
name|frag_off
index|]
argument_list|,
name|frag
operator|->
name|fragment
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|frag_len
argument_list|)
expr_stmt|;
block|}
name|dtls1_hm_fragment_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
name|pitem_free
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
literal|0
condition|)
block|{
operator|*
name|ok
operator|=
literal|1
expr_stmt|;
return|return
name|frag_len
return|;
block|}
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* dtls1_max_handshake_message_len returns the maximum number of bytes  * permitted in a DTLS handshake message for |s|. The minimum is 16KB, but may  * be greater if the maximum certificate list size requires it. */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|dtls1_max_handshake_message_len
parameter_list|(
specifier|const
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|long
name|max_len
init|=
name|DTLS1_HM_HEADER_LENGTH
operator|+
name|SSL3_RT_MAX_ENCRYPTED_LENGTH
decl_stmt|;
if|if
condition|(
name|max_len
operator|<
operator|(
name|unsigned
name|long
operator|)
name|s
operator|->
name|max_cert_list
condition|)
return|return
name|s
operator|->
name|max_cert_list
return|;
return|return
name|max_len
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtls1_reassemble_fragment
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
block|{
name|hm_fragment
modifier|*
name|frag
init|=
name|NULL
decl_stmt|;
name|pitem
modifier|*
name|item
init|=
name|NULL
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|,
name|is_complete
decl_stmt|;
name|unsigned
name|char
name|seq64be
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|long
name|frag_len
init|=
name|msg_hdr
operator|->
name|frag_len
decl_stmt|;
if|if
condition|(
operator|(
name|msg_hdr
operator|->
name|frag_off
operator|+
name|frag_len
operator|)
operator|>
name|msg_hdr
operator|->
name|msg_len
operator|||
name|msg_hdr
operator|->
name|msg_len
operator|>
name|dtls1_max_handshake_message_len
argument_list|(
name|s
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|frag_len
operator|==
literal|0
condition|)
return|return
name|DTLS1_HM_FRAGMENT_RETRY
return|;
comment|/* Try to find item in queue */
name|memset
argument_list|(
name|seq64be
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|seq64be
argument_list|)
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|msg_hdr
operator|->
name|seq
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|7
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|msg_hdr
operator|->
name|seq
expr_stmt|;
name|item
operator|=
name|pqueue_find
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|,
name|seq64be
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|frag
operator|=
name|dtls1_hm_fragment_new
argument_list|(
name|msg_hdr
operator|->
name|msg_len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|memcpy
argument_list|(
operator|&
operator|(
name|frag
operator|->
name|msg_header
operator|)
argument_list|,
name|msg_hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|frag_len
operator|=
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|frag_off
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|frag
operator|=
operator|(
name|hm_fragment
operator|*
operator|)
name|item
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
operator|!=
name|msg_hdr
operator|->
name|msg_len
condition|)
block|{
name|item
operator|=
name|NULL
expr_stmt|;
name|frag
operator|=
name|NULL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
comment|/* If message is already reassembled, this must be a 	 * retransmit and can be dropped. In this case item != NULL and so frag 	 * does not need to be freed. 	 */
if|if
condition|(
name|frag
operator|->
name|reassembly
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|char
name|devnull
index|[
literal|256
index|]
decl_stmt|;
while|while
condition|(
name|frag_len
condition|)
block|{
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|devnull
argument_list|,
name|frag_len
operator|>
sizeof|sizeof
argument_list|(
name|devnull
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|devnull
argument_list|)
else|:
name|frag_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
name|frag_len
operator|-=
name|i
expr_stmt|;
block|}
return|return
name|DTLS1_HM_FRAGMENT_RETRY
return|;
block|}
comment|/* read the body of the fragment (header has already been read */
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|frag
operator|->
name|fragment
operator|+
name|msg_hdr
operator|->
name|frag_off
argument_list|,
name|frag_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|i
operator|!=
name|frag_len
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
name|RSMBLY_BITMASK_MARK
argument_list|(
name|frag
operator|->
name|reassembly
argument_list|,
operator|(
name|long
operator|)
name|msg_hdr
operator|->
name|frag_off
argument_list|,
call|(
name|long
call|)
argument_list|(
name|msg_hdr
operator|->
name|frag_off
operator|+
name|frag_len
argument_list|)
argument_list|)
expr_stmt|;
name|RSMBLY_BITMASK_IS_COMPLETE
argument_list|(
name|frag
operator|->
name|reassembly
argument_list|,
operator|(
name|long
operator|)
name|msg_hdr
operator|->
name|msg_len
argument_list|,
name|is_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_complete
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|frag
operator|->
name|reassembly
argument_list|)
expr_stmt|;
name|frag
operator|->
name|reassembly
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|item
operator|=
name|pitem_new
argument_list|(
name|seq64be
argument_list|,
name|frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|item
operator|=
name|pqueue_insert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|,
name|item
argument_list|)
expr_stmt|;
comment|/* pqueue_insert fails iff a duplicate item is inserted. 		 * However, |item| cannot be a duplicate. If it were, 		 * |pqueue_find|, above, would have returned it and control 		 * would never have reached this branch. */
name|OPENSSL_assert
argument_list|(
name|item
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|DTLS1_HM_FRAGMENT_RETRY
return|;
name|err
label|:
if|if
condition|(
name|frag
operator|!=
name|NULL
operator|&&
name|item
operator|==
name|NULL
condition|)
name|dtls1_hm_fragment_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtls1_process_out_of_seq_message
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|hm_fragment
modifier|*
name|frag
init|=
name|NULL
decl_stmt|;
name|pitem
modifier|*
name|item
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|seq64be
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|long
name|frag_len
init|=
name|msg_hdr
operator|->
name|frag_len
decl_stmt|;
if|if
condition|(
operator|(
name|msg_hdr
operator|->
name|frag_off
operator|+
name|frag_len
operator|)
operator|>
name|msg_hdr
operator|->
name|msg_len
condition|)
goto|goto
name|err
goto|;
comment|/* Try to find item in queue, to prevent duplicate entries */
name|memset
argument_list|(
name|seq64be
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|seq64be
argument_list|)
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|msg_hdr
operator|->
name|seq
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|7
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|msg_hdr
operator|->
name|seq
expr_stmt|;
name|item
operator|=
name|pqueue_find
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|,
name|seq64be
argument_list|)
expr_stmt|;
comment|/* If we already have an entry and this one is a fragment, 	 * don't discard it and rather try to reassemble it. 	 */
if|if
condition|(
name|item
operator|!=
name|NULL
operator|&&
name|frag_len
operator|!=
name|msg_hdr
operator|->
name|msg_len
condition|)
name|item
operator|=
name|NULL
expr_stmt|;
comment|/* Discard the message if sequence number was already there, is 	 * too far in the future, already in the queue or if we received 	 * a FINISHED before the SERVER_HELLO, which then must be a stale 	 * retransmit. 	 */
if|if
condition|(
name|msg_hdr
operator|->
name|seq
operator|<=
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
operator|||
name|msg_hdr
operator|->
name|seq
operator|>
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
operator|+
literal|10
operator|||
name|item
operator|!=
name|NULL
operator|||
operator|(
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
operator|==
literal|0
operator|&&
name|msg_hdr
operator|->
name|type
operator|==
name|SSL3_MT_FINISHED
operator|)
condition|)
block|{
name|unsigned
name|char
name|devnull
index|[
literal|256
index|]
decl_stmt|;
while|while
condition|(
name|frag_len
condition|)
block|{
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|devnull
argument_list|,
name|frag_len
operator|>
sizeof|sizeof
argument_list|(
name|devnull
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|devnull
argument_list|)
else|:
name|frag_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
name|frag_len
operator|-=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|frag_len
operator|!=
name|msg_hdr
operator|->
name|msg_len
condition|)
return|return
name|dtls1_reassemble_fragment
argument_list|(
name|s
argument_list|,
name|msg_hdr
argument_list|,
name|ok
argument_list|)
return|;
if|if
condition|(
name|frag_len
operator|>
name|dtls1_max_handshake_message_len
argument_list|(
name|s
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|frag
operator|=
name|dtls1_hm_fragment_new
argument_list|(
name|frag_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|memcpy
argument_list|(
operator|&
operator|(
name|frag
operator|->
name|msg_header
operator|)
argument_list|,
name|msg_hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag_len
condition|)
block|{
comment|/* read the body of the fragment (header has already been read */
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|frag
operator|->
name|fragment
argument_list|,
name|frag_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|i
operator|!=
name|frag_len
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
name|item
operator|=
name|pitem_new
argument_list|(
name|seq64be
argument_list|,
name|frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|item
operator|=
name|pqueue_insert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|,
name|item
argument_list|)
expr_stmt|;
comment|/* pqueue_insert fails iff a duplicate item is inserted. 		 * However, |item| cannot be a duplicate. If it were, 		 * |pqueue_find|, above, would have returned it. Then, either 		 * |frag_len| != |msg_hdr->msg_len| in which case |item| is set 		 * to NULL and it will have been processed with 		 * |dtls1_reassemble_fragment|, above, or the record will have 		 * been discarded. */
name|OPENSSL_assert
argument_list|(
name|item
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|DTLS1_HM_FRAGMENT_RETRY
return|;
name|err
label|:
if|if
condition|(
name|frag
operator|!=
name|NULL
operator|&&
name|item
operator|==
name|NULL
condition|)
name|dtls1_hm_fragment_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|dtls1_get_message_fragment
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|st1
parameter_list|,
name|int
name|stn
parameter_list|,
name|long
name|max
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
block|{
name|unsigned
name|char
name|wire
index|[
name|DTLS1_HM_HEADER_LENGTH
index|]
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|,
name|frag_off
decl_stmt|,
name|frag_len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|al
decl_stmt|;
name|struct
name|hm_header_st
name|msg_hdr
decl_stmt|;
name|redo
label|:
comment|/* see if we have the required fragment already */
if|if
condition|(
operator|(
name|frag_len
operator|=
name|dtls1_retrieve_buffered_fragment
argument_list|(
name|s
argument_list|,
name|max
argument_list|,
name|ok
argument_list|)
operator|)
operator|||
operator|*
name|ok
condition|)
block|{
if|if
condition|(
operator|*
name|ok
condition|)
name|s
operator|->
name|init_num
operator|=
name|frag_len
expr_stmt|;
return|return
name|frag_len
return|;
block|}
comment|/* read handshake message header */
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|wire
argument_list|,
name|DTLS1_HM_HEADER_LENGTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
comment|/* nbio, or an error */
block|{
name|s
operator|->
name|rwstate
operator|=
name|SSL_READING
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
comment|/* Handshake fails if message header is incomplete */
if|if
condition|(
name|i
operator|!=
name|DTLS1_HM_HEADER_LENGTH
condition|)
block|{
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_GET_MESSAGE_FRAGMENT
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
comment|/* parse the message fragment header */
name|dtls1_get_message_header
argument_list|(
name|wire
argument_list|,
operator|&
name|msg_hdr
argument_list|)
expr_stmt|;
comment|/*  	 * if this is a future (or stale) message it gets buffered 	 * (or dropped)--no further processing at this time 	 * While listening, we accept seq 1 (ClientHello with cookie) 	 * although we're still expecting seq 0 (ClientHello) 	 */
if|if
condition|(
name|msg_hdr
operator|.
name|seq
operator|!=
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
operator|&&
operator|!
operator|(
name|s
operator|->
name|d1
operator|->
name|listen
operator|&&
name|msg_hdr
operator|.
name|seq
operator|==
literal|1
operator|)
condition|)
return|return
name|dtls1_process_out_of_seq_message
argument_list|(
name|s
argument_list|,
operator|&
name|msg_hdr
argument_list|,
name|ok
argument_list|)
return|;
name|len
operator|=
name|msg_hdr
operator|.
name|msg_len
expr_stmt|;
name|frag_off
operator|=
name|msg_hdr
operator|.
name|frag_off
expr_stmt|;
name|frag_len
operator|=
name|msg_hdr
operator|.
name|frag_len
expr_stmt|;
if|if
condition|(
name|frag_len
operator|&&
name|frag_len
operator|<
name|len
condition|)
return|return
name|dtls1_reassemble_fragment
argument_list|(
name|s
argument_list|,
operator|&
name|msg_hdr
argument_list|,
name|ok
argument_list|)
return|;
if|if
condition|(
operator|!
name|s
operator|->
name|server
operator|&&
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|frag_off
operator|==
literal|0
operator|&&
name|wire
index|[
literal|0
index|]
operator|==
name|SSL3_MT_HELLO_REQUEST
condition|)
block|{
comment|/* The server may always send 'Hello Request' messages -- 		 * we are doing a handshake anyway now, so ignore them 		 * if their format is correct. Does not count for 		 * 'Finished' MAC. */
if|if
condition|(
name|wire
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|wire
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|wire
index|[
literal|3
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|0
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|wire
argument_list|,
name|DTLS1_HM_HEADER_LENGTH
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
goto|goto
name|redo
goto|;
block|}
else|else
comment|/* Incorrectly formated Hello request */
block|{
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_GET_MESSAGE_FRAGMENT
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|al
operator|=
name|dtls1_preprocess_fragment
argument_list|(
name|s
argument_list|,
operator|&
name|msg_hdr
argument_list|,
name|max
argument_list|)
operator|)
condition|)
goto|goto
name|f_err
goto|;
comment|/* XDTLS:  ressurect this when restart is in place */
name|s
operator|->
name|state
operator|=
name|stn
expr_stmt|;
if|if
condition|(
name|frag_len
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
operator|+
name|DTLS1_HM_HEADER_LENGTH
decl_stmt|;
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
operator|&
name|p
index|[
name|frag_off
index|]
argument_list|,
name|frag_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XDTLS:  fix this--message fragments cannot span multiple packets */
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|s
operator|->
name|rwstate
operator|=
name|SSL_READING
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
comment|/* XDTLS:  an incorrectly formatted fragment should cause the  	 * handshake to fail */
if|if
condition|(
name|i
operator|!=
operator|(
name|int
operator|)
name|frag_len
condition|)
block|{
name|al
operator|=
name|SSL3_AD_ILLEGAL_PARAMETER
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_GET_MESSAGE_FRAGMENT
argument_list|,
name|SSL3_AD_ILLEGAL_PARAMETER
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
operator|*
name|ok
operator|=
literal|1
expr_stmt|;
comment|/* Note that s->init_num is *not* used as current offset in 	 * s->init_buf->data, but as a counter summing up fragments' 	 * lengths: as soon as they sum up to handshake packet 	 * length, we assume we have got all the fragments. */
name|s
operator|->
name|init_num
operator|=
name|frag_len
expr_stmt|;
return|return
name|frag_len
return|;
name|f_err
label|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtls1_send_finished
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|sender
parameter_list|,
name|int
name|slen
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|l
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|a
condition|)
block|{
name|d
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
name|p
operator|=
operator|&
operator|(
name|d
index|[
name|DTLS1_HM_HEADER_LENGTH
index|]
operator|)
expr_stmt|;
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl3_enc
operator|->
name|final_finish_mac
argument_list|(
name|s
argument_list|,
name|sender
argument_list|,
name|slen
argument_list|,
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md
argument_list|)
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md_len
operator|=
name|i
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
name|l
operator|=
name|i
expr_stmt|;
comment|/* Copy the finished so we can use it for 	 * renegotiation checks 	 */
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SSL_ST_CONNECT
condition|)
block|{
name|OPENSSL_assert
argument_list|(
name|i
operator|<=
name|EVP_MAX_MD_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|s3
operator|->
name|previous_client_finished
argument_list|,
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|previous_client_finished_len
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|OPENSSL_assert
argument_list|(
name|i
operator|<=
name|EVP_MAX_MD_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|s3
operator|->
name|previous_server_finished
argument_list|,
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|previous_server_finished_len
operator|=
name|i
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OPENSSL_SYS_WIN16
comment|/* MSVC 1.5 does not clear the top bytes of the word unless 		 * I do this. 		 */
name|l
operator|&=
literal|0xffff
expr_stmt|;
endif|#
directive|endif
name|d
operator|=
name|dtls1_set_message_header
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|SSL3_MT_FINISHED
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
operator|(
name|int
operator|)
name|l
operator|+
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
comment|/* buffer the message to handle re-xmits */
name|dtls1_buffer_message
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|b
expr_stmt|;
block|}
comment|/* SSL3_ST_SEND_xxxxxx_HELLO_B */
return|return
operator|(
name|dtls1_do_write
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* for these 2 messages, we need to  * ssl->enc_read_ctx			re-init  * ssl->s3->read_sequence		zero  * ssl->s3->read_mac_secret		re-init  * ssl->session->read_sym_enc		assign  * ssl->session->read_compression	assign  * ssl->session->read_hash		assign  */
end_comment

begin_function
name|int
name|dtls1_send_change_cipher_spec
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|a
condition|)
block|{
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SSL3_MT_CCS
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|handshake_write_seq
operator|=
name|s
operator|->
name|d1
operator|->
name|next_handshake_write_seq
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
name|DTLS1_CCS_HEADER_LENGTH
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|version
operator|==
name|DTLS1_BAD_VER
condition|)
block|{
name|s
operator|->
name|d1
operator|->
name|next_handshake_write_seq
operator|++
expr_stmt|;
name|s2n
argument_list|(
name|s
operator|->
name|d1
operator|->
name|handshake_write_seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|+=
literal|2
expr_stmt|;
block|}
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
name|dtls1_set_message_header_int
argument_list|(
name|s
argument_list|,
name|SSL3_MT_CCS
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|d1
operator|->
name|handshake_write_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* buffer the message to handle re-xmits */
name|dtls1_buffer_message
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|b
expr_stmt|;
block|}
comment|/* SSL3_ST_CW_CHANGE_B */
return|return
operator|(
name|dtls1_do_write
argument_list|(
name|s
argument_list|,
name|SSL3_RT_CHANGE_CIPHER_SPEC
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtls1_add_cert_to_buf
parameter_list|(
name|BUF_MEM
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
modifier|*
name|l
parameter_list|,
name|X509
modifier|*
name|x
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|n
operator|=
name|i2d_X509
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BUF_MEM_grow_clean
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|n
operator|+
operator|(
operator|*
name|l
operator|)
operator|+
literal|3
argument_list|)
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_ADD_CERT_TO_BUF
argument_list|,
name|ERR_R_BUF_LIB
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
name|buf
operator|->
name|data
index|[
operator|*
name|l
index|]
operator|)
expr_stmt|;
name|l2n3
argument_list|(
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|i2d_X509
argument_list|(
name|x
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
operator|*
name|l
operator|+=
name|n
operator|+
literal|3
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|dtls1_output_cert_chain
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|X509
modifier|*
name|x
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|l
init|=
literal|3
operator|+
name|DTLS1_HM_HEADER_LENGTH
decl_stmt|;
name|BUF_MEM
modifier|*
name|buf
decl_stmt|;
comment|/* TLSv1 sends a chain with nothing in it, instead of an alert */
name|buf
operator|=
name|s
operator|->
name|init_buf
expr_stmt|;
if|if
condition|(
operator|!
name|BUF_MEM_grow_clean
argument_list|(
name|buf
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_OUTPUT_CERT_CHAIN
argument_list|,
name|ERR_R_BUF_LIB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
block|{
name|X509_STORE_CTX
name|xs_ctx
decl_stmt|;
if|if
condition|(
operator|!
name|X509_STORE_CTX_init
argument_list|(
operator|&
name|xs_ctx
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|cert_store
argument_list|,
name|x
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_OUTPUT_CERT_CHAIN
argument_list|,
name|ERR_R_X509_LIB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|X509_verify_cert
argument_list|(
operator|&
name|xs_ctx
argument_list|)
expr_stmt|;
comment|/* Don't leave errors in the queue */
name|ERR_clear_error
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_num
argument_list|(
name|xs_ctx
operator|.
name|chain
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|sk_X509_value
argument_list|(
name|xs_ctx
operator|.
name|chain
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dtls1_add_cert_to_buf
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|X509_STORE_CTX_cleanup
argument_list|(
operator|&
name|xs_ctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|X509_STORE_CTX_cleanup
argument_list|(
operator|&
name|xs_ctx
argument_list|)
expr_stmt|;
block|}
comment|/* Thawte special :-) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_num
argument_list|(
name|s
operator|->
name|ctx
operator|->
name|extra_certs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|sk_X509_value
argument_list|(
name|s
operator|->
name|ctx
operator|->
name|extra_certs
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dtls1_add_cert_to_buf
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|l
operator|-=
operator|(
literal|3
operator|+
name|DTLS1_HM_HEADER_LENGTH
operator|)
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
name|buf
operator|->
name|data
index|[
name|DTLS1_HM_HEADER_LENGTH
index|]
operator|)
expr_stmt|;
name|l2n3
argument_list|(
name|l
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l
operator|+=
literal|3
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
name|buf
operator|->
name|data
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|p
operator|=
name|dtls1_set_message_header
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|SSL3_MT_CERTIFICATE
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|l
operator|+=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtls1_read_failed
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|code
parameter_list|)
block|{
if|if
condition|(
name|code
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid state reached %s:%d"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|dtls1_is_timer_expired
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/* not a timeout, none of our business,  		   let higher layers handle this.  in fact it's probably an error */
return|return
name|code
return|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
if|if
condition|(
operator|!
name|SSL_in_init
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|s
operator|->
name|tlsext_hb_pending
condition|)
comment|/* done, no need to send a retransmit */
else|#
directive|else
if|if
condition|(
operator|!
name|SSL_in_init
argument_list|(
name|s
argument_list|)
condition|)
comment|/* done, no need to send a retransmit */
endif|#
directive|endif
block|{
name|BIO_set_flags
argument_list|(
name|SSL_get_rbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_FLAGS_READ
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
if|#
directive|if
literal|0
comment|/* for now, each alert contains only one record number */
block|item = pqueue_peek(state->rcvd_records); 	if ( item ) 		{
comment|/* send an alert immediately for all the missing records */
block|} 	else
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* no more alert sending, just retransmit the last set of messages */
block|if ( state->timeout.read_timeouts>= DTLS1_TMO_READ_COUNT) 		ssl3_send_alert(s,SSL3_AL_WARNING, 			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
endif|#
directive|endif
return|return
name|dtls1_handle_timeout
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|dtls1_get_queue_priority
parameter_list|(
name|unsigned
name|short
name|seq
parameter_list|,
name|int
name|is_ccs
parameter_list|)
block|{
comment|/* The index of the retransmission queue actually is the message sequence number, 	 * since the queue only contains messages of a single handshake. However, the 	 * ChangeCipherSpec has no message sequence number and so using only the sequence 	 * will result in the CCS and Finished having the same index. To prevent this, 	 * the sequence number is multiplied by 2. In case of a CCS 1 is subtracted. 	 * This does not only differ CSS and Finished, it also maintains the order of the 	 * index (important for priority queues) and fits in the unsigned short variable. 	 */
return|return
name|seq
operator|*
literal|2
operator|-
name|is_ccs
return|;
block|}
end_function

begin_function
name|int
name|dtls1_retransmit_buffered_messages
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|pqueue
name|sent
init|=
name|s
operator|->
name|d1
operator|->
name|sent_messages
decl_stmt|;
name|piterator
name|iter
decl_stmt|;
name|pitem
modifier|*
name|item
decl_stmt|;
name|hm_fragment
modifier|*
name|frag
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|iter
operator|=
name|pqueue_iterator
argument_list|(
name|sent
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|pqueue_next
argument_list|(
operator|&
name|iter
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|pqueue_next
argument_list|(
operator|&
name|iter
argument_list|)
control|)
block|{
name|frag
operator|=
operator|(
name|hm_fragment
operator|*
operator|)
name|item
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|dtls1_retransmit_message
argument_list|(
name|s
argument_list|,
operator|(
name|unsigned
name|short
operator|)
name|dtls1_get_queue_priority
argument_list|(
name|frag
operator|->
name|msg_header
operator|.
name|seq
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|found
argument_list|)
operator|<=
literal|0
operator|&&
name|found
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dtls1_retransmit_message() failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|dtls1_buffer_message
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|is_ccs
parameter_list|)
block|{
name|pitem
modifier|*
name|item
decl_stmt|;
name|hm_fragment
modifier|*
name|frag
decl_stmt|;
name|unsigned
name|char
name|seq64be
index|[
literal|8
index|]
decl_stmt|;
comment|/* this function is called immediately after a message has  	 * been serialized */
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|init_off
operator|==
literal|0
argument_list|)
expr_stmt|;
name|frag
operator|=
name|dtls1_hm_fragment_new
argument_list|(
name|s
operator|->
name|init_num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frag
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|frag
operator|->
name|fragment
argument_list|,
name|s
operator|->
name|init_buf
operator|->
name|data
argument_list|,
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ccs
condition|)
block|{
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|msg_len
operator|+
operator|(
operator|(
name|s
operator|->
name|version
operator|==
name|DTLS1_VERSION
operator|)
condition|?
name|DTLS1_CCS_HEADER_LENGTH
else|:
literal|3
operator|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|msg_len
operator|+
name|DTLS1_HM_HEADER_LENGTH
operator|==
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
block|}
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
operator|=
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|msg_len
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|seq
operator|=
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|seq
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|type
operator|=
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|type
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|frag_off
operator|=
literal|0
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|frag_len
operator|=
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|msg_len
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
operator|=
name|is_ccs
expr_stmt|;
comment|/* save current state*/
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|enc_write_ctx
operator|=
name|s
operator|->
name|enc_write_ctx
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|write_hash
operator|=
name|s
operator|->
name|write_hash
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|compress
operator|=
name|s
operator|->
name|compress
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|session
operator|=
name|s
operator|->
name|session
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|epoch
operator|=
name|s
operator|->
name|d1
operator|->
name|w_epoch
expr_stmt|;
name|memset
argument_list|(
name|seq64be
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|seq64be
argument_list|)
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|dtls1_get_queue_priority
argument_list|(
name|frag
operator|->
name|msg_header
operator|.
name|seq
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
argument_list|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|7
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|dtls1_get_queue_priority
argument_list|(
name|frag
operator|->
name|msg_header
operator|.
name|seq
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|pitem_new
argument_list|(
name|seq64be
argument_list|,
name|frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|dtls1_hm_fragment_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
literal|0
block|fprintf( stderr, "buffered messge: \ttype = %xx\n", msg_buf->type); 	fprintf( stderr, "\t\t\t\t\tlen = %d\n", msg_buf->len); 	fprintf( stderr, "\t\t\t\t\tseq_num = %d\n", msg_buf->seq_num);
endif|#
directive|endif
name|pqueue_insert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|sent_messages
argument_list|,
name|item
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|dtls1_retransmit_message
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|short
name|seq
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|int
modifier|*
name|found
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* XDTLS: for now assuming that read/writes are blocking */
name|pitem
modifier|*
name|item
decl_stmt|;
name|hm_fragment
modifier|*
name|frag
decl_stmt|;
name|unsigned
name|long
name|header_length
decl_stmt|;
name|unsigned
name|char
name|seq64be
index|[
literal|8
index|]
decl_stmt|;
name|struct
name|dtls1_retransmit_state
name|saved_state
decl_stmt|;
name|unsigned
name|char
name|save_write_sequence
index|[
literal|8
index|]
decl_stmt|;
comment|/* 	  OPENSSL_assert(s->init_num == 0); 	  OPENSSL_assert(s->init_off == 0); 	 */
comment|/* XDTLS:  the requested message ought to be found, otherwise error */
name|memset
argument_list|(
name|seq64be
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|seq64be
argument_list|)
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|seq
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|7
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|seq
expr_stmt|;
name|item
operator|=
name|pqueue_find
argument_list|(
name|s
operator|->
name|d1
operator|->
name|sent_messages
argument_list|,
name|seq64be
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"retransmit:  message %d non-existant\n"
argument_list|,
name|seq
argument_list|)
expr_stmt|;
operator|*
name|found
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|found
operator|=
literal|1
expr_stmt|;
name|frag
operator|=
operator|(
name|hm_fragment
operator|*
operator|)
name|item
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
condition|)
name|header_length
operator|=
name|DTLS1_CCS_HEADER_LENGTH
expr_stmt|;
else|else
name|header_length
operator|=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|init_buf
operator|->
name|data
argument_list|,
name|frag
operator|->
name|fragment
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
operator|+
name|header_length
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
operator|+
name|header_length
expr_stmt|;
name|dtls1_set_message_header_int
argument_list|(
name|s
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|type
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|seq
argument_list|,
literal|0
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|frag_len
argument_list|)
expr_stmt|;
comment|/* save current state */
name|saved_state
operator|.
name|enc_write_ctx
operator|=
name|s
operator|->
name|enc_write_ctx
expr_stmt|;
name|saved_state
operator|.
name|write_hash
operator|=
name|s
operator|->
name|write_hash
expr_stmt|;
name|saved_state
operator|.
name|compress
operator|=
name|s
operator|->
name|compress
expr_stmt|;
name|saved_state
operator|.
name|session
operator|=
name|s
operator|->
name|session
expr_stmt|;
name|saved_state
operator|.
name|epoch
operator|=
name|s
operator|->
name|d1
operator|->
name|w_epoch
expr_stmt|;
name|saved_state
operator|.
name|epoch
operator|=
name|s
operator|->
name|d1
operator|->
name|w_epoch
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|retransmitting
operator|=
literal|1
expr_stmt|;
comment|/* restore state in which the message was originally sent */
name|s
operator|->
name|enc_write_ctx
operator|=
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|enc_write_ctx
expr_stmt|;
name|s
operator|->
name|write_hash
operator|=
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|write_hash
expr_stmt|;
name|s
operator|->
name|compress
operator|=
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|compress
expr_stmt|;
name|s
operator|->
name|session
operator|=
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|session
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|w_epoch
operator|=
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|epoch
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|epoch
operator|==
name|saved_state
operator|.
name|epoch
operator|-
literal|1
condition|)
block|{
name|memcpy
argument_list|(
name|save_write_sequence
argument_list|,
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|,
name|s
operator|->
name|d1
operator|->
name|last_write_sequence
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|dtls1_do_write
argument_list|(
name|s
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
condition|?
name|SSL3_RT_CHANGE_CIPHER_SPEC
else|:
name|SSL3_RT_HANDSHAKE
argument_list|)
expr_stmt|;
comment|/* restore current state */
name|s
operator|->
name|enc_write_ctx
operator|=
name|saved_state
operator|.
name|enc_write_ctx
expr_stmt|;
name|s
operator|->
name|write_hash
operator|=
name|saved_state
operator|.
name|write_hash
expr_stmt|;
name|s
operator|->
name|compress
operator|=
name|saved_state
operator|.
name|compress
expr_stmt|;
name|s
operator|->
name|session
operator|=
name|saved_state
operator|.
name|session
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|w_epoch
operator|=
name|saved_state
operator|.
name|epoch
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|epoch
operator|==
name|saved_state
operator|.
name|epoch
operator|-
literal|1
condition|)
block|{
name|memcpy
argument_list|(
name|s
operator|->
name|d1
operator|->
name|last_write_sequence
argument_list|,
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|,
name|save_write_sequence
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|d1
operator|->
name|retransmitting
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_flush
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* call this function when the buffered messages are no longer needed */
end_comment

begin_function
name|void
name|dtls1_clear_record_buffer
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|pitem
modifier|*
name|item
decl_stmt|;
for|for
control|(
name|item
operator|=
name|pqueue_pop
argument_list|(
name|s
operator|->
name|d1
operator|->
name|sent_messages
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|pqueue_pop
argument_list|(
name|s
operator|->
name|d1
operator|->
name|sent_messages
argument_list|)
control|)
block|{
name|dtls1_hm_fragment_free
argument_list|(
operator|(
name|hm_fragment
operator|*
operator|)
name|item
operator|->
name|data
argument_list|)
expr_stmt|;
name|pitem_free
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
name|dtls1_set_message_header
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
name|mt
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|unsigned
name|long
name|frag_len
parameter_list|)
block|{
comment|/* Don't change sequence numbers while listening */
if|if
condition|(
name|frag_off
operator|==
literal|0
operator|&&
operator|!
name|s
operator|->
name|d1
operator|->
name|listen
condition|)
block|{
name|s
operator|->
name|d1
operator|->
name|handshake_write_seq
operator|=
name|s
operator|->
name|d1
operator|->
name|next_handshake_write_seq
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|next_handshake_write_seq
operator|++
expr_stmt|;
block|}
name|dtls1_set_message_header_int
argument_list|(
name|s
argument_list|,
name|mt
argument_list|,
name|len
argument_list|,
name|s
operator|->
name|d1
operator|->
name|handshake_write_seq
argument_list|,
name|frag_off
argument_list|,
name|frag_len
argument_list|)
expr_stmt|;
return|return
name|p
operator|+=
name|DTLS1_HM_HEADER_LENGTH
return|;
block|}
end_function

begin_comment
comment|/* don't actually do the writing, wait till the MTU has been retrieved */
end_comment

begin_function
specifier|static
name|void
name|dtls1_set_message_header_int
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
name|mt
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|unsigned
name|short
name|seq_num
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|unsigned
name|long
name|frag_len
parameter_list|)
block|{
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
init|=
operator|&
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
decl_stmt|;
name|msg_hdr
operator|->
name|type
operator|=
name|mt
expr_stmt|;
name|msg_hdr
operator|->
name|msg_len
operator|=
name|len
expr_stmt|;
name|msg_hdr
operator|->
name|seq
operator|=
name|seq_num
expr_stmt|;
name|msg_hdr
operator|->
name|frag_off
operator|=
name|frag_off
expr_stmt|;
name|msg_hdr
operator|->
name|frag_len
operator|=
name|frag_len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtls1_fix_message_header
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|unsigned
name|long
name|frag_len
parameter_list|)
block|{
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
init|=
operator|&
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
decl_stmt|;
name|msg_hdr
operator|->
name|frag_off
operator|=
name|frag_off
expr_stmt|;
name|msg_hdr
operator|->
name|frag_len
operator|=
name|frag_len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|dtls1_write_message_header
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
init|=
operator|&
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
decl_stmt|;
operator|*
name|p
operator|++
operator|=
name|msg_hdr
operator|->
name|type
expr_stmt|;
name|l2n3
argument_list|(
name|msg_hdr
operator|->
name|msg_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|msg_hdr
operator|->
name|seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
name|msg_hdr
operator|->
name|frag_off
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
name|msg_hdr
operator|->
name|frag_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dtls1_min_mtu
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|g_probable_mtu
index|[
operator|(
sizeof|sizeof
argument_list|(
name|g_probable_mtu
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|g_probable_mtu
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|dtls1_guess_mtu
parameter_list|(
name|unsigned
name|int
name|curr_mtu
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|curr_mtu
operator|==
literal|0
condition|)
return|return
name|g_probable_mtu
index|[
literal|0
index|]
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|g_probable_mtu
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|g_probable_mtu
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|curr_mtu
operator|>
name|g_probable_mtu
index|[
name|i
index|]
condition|)
return|return
name|g_probable_mtu
index|[
name|i
index|]
return|;
return|return
name|curr_mtu
return|;
block|}
end_function

begin_function
name|void
name|dtls1_get_message_header
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
parameter_list|)
block|{
name|memset
argument_list|(
name|msg_hdr
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hm_header_st
argument_list|)
argument_list|)
expr_stmt|;
name|msg_hdr
operator|->
name|type
operator|=
operator|*
operator|(
name|data
operator|++
operator|)
expr_stmt|;
name|n2l3
argument_list|(
name|data
argument_list|,
name|msg_hdr
operator|->
name|msg_len
argument_list|)
expr_stmt|;
name|n2s
argument_list|(
name|data
argument_list|,
name|msg_hdr
operator|->
name|seq
argument_list|)
expr_stmt|;
name|n2l3
argument_list|(
name|data
argument_list|,
name|msg_hdr
operator|->
name|frag_off
argument_list|)
expr_stmt|;
name|n2l3
argument_list|(
name|data
argument_list|,
name|msg_hdr
operator|->
name|frag_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dtls1_get_ccs_header
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|ccs_header_st
modifier|*
name|ccs_hdr
parameter_list|)
block|{
name|memset
argument_list|(
name|ccs_hdr
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccs_header_st
argument_list|)
argument_list|)
expr_stmt|;
name|ccs_hdr
operator|->
name|type
operator|=
operator|*
operator|(
name|data
operator|++
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dtls1_shutdown
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_SCTP
if|if
condition|(
name|BIO_dgram_is_sctp
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|s
operator|->
name|shutdown
operator|&
name|SSL_SENT_SHUTDOWN
operator|)
condition|)
block|{
name|ret
operator|=
name|BIO_dgram_sctp_wait_for_dry
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|BIO_ctrl
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ret
operator|=
name|ssl3_shutdown
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_SCTP
name|BIO_ctrl
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
end_ifndef

begin_function
name|int
name|dtls1_process_heartbeat
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|&
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|data
index|[
literal|0
index|]
decl_stmt|,
modifier|*
name|pl
decl_stmt|;
name|unsigned
name|short
name|hbtype
decl_stmt|;
name|unsigned
name|int
name|payload
decl_stmt|;
name|unsigned
name|int
name|padding
init|=
literal|16
decl_stmt|;
comment|/* Use minimum padding */
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|0
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
operator|&
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|data
index|[
literal|0
index|]
argument_list|,
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|length
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
comment|/* Read type and payload length first */
if|if
condition|(
literal|1
operator|+
literal|2
operator|+
literal|16
operator|>
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|length
condition|)
return|return
literal|0
return|;
comment|/* silently discard */
name|hbtype
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|payload
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|+
literal|2
operator|+
name|payload
operator|+
literal|16
operator|>
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|length
condition|)
return|return
literal|0
return|;
comment|/* silently discard per RFC 6520 sec. 4 */
name|pl
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|hbtype
operator|==
name|TLS1_HB_REQUEST
condition|)
block|{
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|unsigned
name|int
name|write_length
init|=
literal|1
comment|/* heartbeat type */
operator|+
literal|2
comment|/* heartbeat length */
operator|+
name|payload
operator|+
name|padding
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|write_length
operator|>
name|SSL3_RT_MAX_PLAIN_LENGTH
condition|)
return|return
literal|0
return|;
comment|/* Allocate memory for the response, size is 1 byte 		 * message type, plus 2 bytes payload length, plus 		 * payload, plus padding 		 */
name|buffer
operator|=
name|OPENSSL_malloc
argument_list|(
name|write_length
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
comment|/* Enter response type, length and copy payload */
operator|*
name|bp
operator|++
operator|=
name|TLS1_HB_RESPONSE
expr_stmt|;
name|s2n
argument_list|(
name|payload
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|pl
argument_list|,
name|payload
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|payload
expr_stmt|;
comment|/* Random padding */
name|RAND_pseudo_bytes
argument_list|(
name|bp
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|r
operator|=
name|dtls1_write_bytes
argument_list|(
name|s
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buffer
argument_list|,
name|write_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
operator|&&
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|1
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buffer
argument_list|,
name|write_length
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|hbtype
operator|==
name|TLS1_HB_RESPONSE
condition|)
block|{
name|unsigned
name|int
name|seq
decl_stmt|;
comment|/* We only send sequence numbers (2 bytes unsigned int), 		 * and 16 random bytes, so we just try to read the 		 * sequence number */
name|n2s
argument_list|(
name|pl
argument_list|,
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|payload
operator|==
literal|18
operator|&&
name|seq
operator|==
name|s
operator|->
name|tlsext_hb_seq
condition|)
block|{
name|dtls1_stop_timer
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|tlsext_hb_seq
operator|++
expr_stmt|;
name|s
operator|->
name|tlsext_hb_pending
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dtls1_heartbeat
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|int
name|payload
init|=
literal|18
decl_stmt|;
comment|/* Sequence number + random bytes */
name|unsigned
name|int
name|padding
init|=
literal|16
decl_stmt|;
comment|/* Use minimum padding */
comment|/* Only send if peer supports and accepts HB requests... */
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|tlsext_heartbeat
operator|&
name|SSL_TLSEXT_HB_ENABLED
operator|)
operator|||
name|s
operator|->
name|tlsext_heartbeat
operator|&
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_HEARTBEAT
argument_list|,
name|SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* ...and there is none in flight yet... */
if|if
condition|(
name|s
operator|->
name|tlsext_hb_pending
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_HEARTBEAT
argument_list|,
name|SSL_R_TLS_HEARTBEAT_PENDING
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* ...and no handshake in progress. */
if|if
condition|(
name|SSL_in_init
argument_list|(
name|s
argument_list|)
operator|||
name|s
operator|->
name|in_handshake
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_HEARTBEAT
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check if padding is too long, payload and padding 	 * must not exceed 2^14 - 3 = 16381 bytes in total. 	 */
name|OPENSSL_assert
argument_list|(
name|payload
operator|+
name|padding
operator|<=
literal|16381
argument_list|)
expr_stmt|;
comment|/* Create HeartBeat message, we just use a sequence number 	 * as payload to distuingish different messages and add 	 * some random stuff. 	 *  - Message Type, 1 byte 	 *  - Payload Length, 2 bytes (unsigned int) 	 *  - Payload, the sequence number (2 bytes uint) 	 *  - Payload, random bytes (16 bytes uint) 	 *  - Padding 	 */
name|buf
operator|=
name|OPENSSL_malloc
argument_list|(
literal|1
operator|+
literal|2
operator|+
name|payload
operator|+
name|padding
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
comment|/* Message Type */
operator|*
name|p
operator|++
operator|=
name|TLS1_HB_REQUEST
expr_stmt|;
comment|/* Payload length (18 bytes here) */
name|s2n
argument_list|(
name|payload
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Sequence number */
name|s2n
argument_list|(
name|s
operator|->
name|tlsext_hb_seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 16 random bytes */
name|RAND_pseudo_bytes
argument_list|(
name|p
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|16
expr_stmt|;
comment|/* Random padding */
name|RAND_pseudo_bytes
argument_list|(
name|p
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dtls1_write_bytes
argument_list|(
name|s
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buf
argument_list|,
literal|3
operator|+
name|payload
operator|+
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|1
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buf
argument_list|,
literal|3
operator|+
name|payload
operator|+
name|padding
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|dtls1_start_timer
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|tlsext_hb_pending
operator|=
literal|1
expr_stmt|;
block|}
name|OPENSSL_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

