begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ssl/d1_both.c */
end_comment

begin_comment
comment|/*   * DTLS implementation written by Nagendra Modadugu  * (nagendra@cs.stanford.edu) for the OpenSSL project 2005.    */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *   * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *   * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from   *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *   * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ssl_locl.h"
end_include

begin_include
include|#
directive|include
file|<openssl/buffer.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509.h>
end_include

begin_comment
comment|/* XDTLS:  figure out the right values */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|g_probable_mtu
index|[]
init|=
block|{
literal|1500
operator|-
literal|28
block|,
literal|512
operator|-
literal|28
block|,
literal|256
operator|-
literal|28
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|unsigned
name|int
name|dtls1_min_mtu
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|dtls1_guess_mtu
parameter_list|(
name|unsigned
name|int
name|curr_mtu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtls1_fix_message_header
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|unsigned
name|long
name|frag_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|dtls1_write_message_header
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtls1_set_message_header_int
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
name|mt
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|unsigned
name|short
name|seq_num
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|unsigned
name|long
name|frag_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dtls1_retransmit_buffered_messages
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|dtls1_get_message_fragment
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|st1
parameter_list|,
name|int
name|stn
parameter_list|,
name|long
name|max
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|hm_fragment
modifier|*
name|dtls1_hm_fragment_new
parameter_list|(
name|unsigned
name|long
name|frag_len
parameter_list|)
block|{
name|hm_fragment
modifier|*
name|frag
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|frag
operator|=
operator|(
name|hm_fragment
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hm_fragment
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|frag_len
condition|)
block|{
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
name|frag_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* zero length fragment gets zero frag->fragment */
name|frag
operator|->
name|fragment
operator|=
name|buf
expr_stmt|;
return|return
name|frag
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtls1_hm_fragment_free
parameter_list|(
name|hm_fragment
modifier|*
name|frag
parameter_list|)
block|{
if|if
condition|(
name|frag
operator|->
name|fragment
condition|)
name|OPENSSL_free
argument_list|(
name|frag
operator|->
name|fragment
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* send s->init_buf in records of type 'type' (SSL3_RT_HANDSHAKE or SSL3_RT_CHANGE_CIPHER_SPEC) */
end_comment

begin_function
name|int
name|dtls1_do_write
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|curr_mtu
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|,
name|frag_off
decl_stmt|;
comment|/* AHA!  Figure out the MTU, and stick to the right size */
if|if
condition|(
operator|!
operator|(
name|SSL_get_options
argument_list|(
name|s
argument_list|)
operator|&
name|SSL_OP_NO_QUERY_MTU
operator|)
condition|)
block|{
name|s
operator|->
name|d1
operator|->
name|mtu
operator|=
name|BIO_ctrl
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_CTRL_DGRAM_QUERY_MTU
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* I've seen the kernel return bogus numbers when it doesn't know 		 * (initial write), so just make sure we have a reasonable number */
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|mtu
operator|<
name|dtls1_min_mtu
argument_list|()
condition|)
block|{
name|s
operator|->
name|d1
operator|->
name|mtu
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|mtu
operator|=
name|dtls1_guess_mtu
argument_list|(
name|s
operator|->
name|d1
operator|->
name|mtu
argument_list|)
expr_stmt|;
name|BIO_ctrl
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_CTRL_DGRAM_SET_MTU
argument_list|,
name|s
operator|->
name|d1
operator|->
name|mtu
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|mtu = s->d1->mtu;  	fprintf(stderr, "using MTU = %d\n", mtu);  	mtu -= (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH);  	curr_mtu = mtu - BIO_wpending(SSL_get_wbio(s));  	if ( curr_mtu> 0) 		mtu = curr_mtu; 	else if ( ( ret = BIO_flush(SSL_get_wbio(s)))<= 0) 		return ret;  	if ( BIO_wpending(SSL_get_wbio(s)) + s->init_num>= mtu) 		{ 		ret = BIO_flush(SSL_get_wbio(s)); 		if ( ret<= 0) 			return ret; 		mtu = s->d1->mtu - (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH); 		}  	OPENSSL_assert(mtu> 0);
comment|/* should have something reasonable now */
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|init_off
operator|==
literal|0
operator|&&
name|type
operator|==
name|SSL3_RT_HANDSHAKE
condition|)
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|init_num
operator|==
operator|(
name|int
operator|)
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|msg_len
operator|+
name|DTLS1_HM_HEADER_LENGTH
argument_list|)
expr_stmt|;
name|frag_off
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|s
operator|->
name|init_num
condition|)
block|{
name|curr_mtu
operator|=
name|s
operator|->
name|d1
operator|->
name|mtu
operator|-
name|BIO_wpending
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|)
operator|-
name|DTLS1_RT_HEADER_LENGTH
expr_stmt|;
if|if
condition|(
name|curr_mtu
operator|<=
name|DTLS1_HM_HEADER_LENGTH
condition|)
block|{
comment|/* grr.. we could get an error if MTU picked was wrong */
name|ret
operator|=
name|BIO_flush
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
return|return
name|ret
return|;
name|curr_mtu
operator|=
name|s
operator|->
name|d1
operator|->
name|mtu
operator|-
name|DTLS1_RT_HEADER_LENGTH
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|init_num
operator|>
name|curr_mtu
condition|)
name|len
operator|=
name|curr_mtu
expr_stmt|;
else|else
name|len
operator|=
name|s
operator|->
name|init_num
expr_stmt|;
comment|/* XDTLS: this function is too long.  split out the CCS part */
if|if
condition|(
name|type
operator|==
name|SSL3_RT_HANDSHAKE
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|init_off
operator|!=
literal|0
condition|)
block|{
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|init_off
operator|>
name|DTLS1_HM_HEADER_LENGTH
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_off
operator|-=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|s
operator|->
name|init_num
operator|+=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
comment|/* write atleast DTLS1_HM_HEADER_LENGTH bytes */
if|if
condition|(
name|len
operator|<=
name|DTLS1_HM_HEADER_LENGTH
condition|)
name|len
operator|+=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
block|}
name|dtls1_fix_message_header
argument_list|(
name|s
argument_list|,
name|frag_off
argument_list|,
name|len
operator|-
name|DTLS1_HM_HEADER_LENGTH
argument_list|)
expr_stmt|;
name|dtls1_write_message_header
argument_list|(
name|s
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|s
operator|->
name|init_buf
operator|->
name|data
index|[
name|s
operator|->
name|init_off
index|]
argument_list|)
expr_stmt|;
name|OPENSSL_assert
argument_list|(
name|len
operator|>=
name|DTLS1_HM_HEADER_LENGTH
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|dtls1_write_bytes
argument_list|(
name|s
argument_list|,
name|type
argument_list|,
operator|&
name|s
operator|->
name|init_buf
operator|->
name|data
index|[
name|s
operator|->
name|init_off
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* might need to update MTU here, but we don't know 			 * which previous packet caused the failure -- so can't 			 * really retransmit anything.  continue as if everything 			 * is fine and wait for an alert to handle the 			 * retransmit  			 */
if|if
condition|(
name|BIO_ctrl
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_CTRL_DGRAM_MTU_EXCEEDED
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
name|s
operator|->
name|d1
operator|->
name|mtu
operator|=
name|BIO_ctrl
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_CTRL_DGRAM_QUERY_MTU
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* bad if this assert fails, only part of the handshake 			 * message got sent.  but why would this happen? */
name|OPENSSL_assert
argument_list|(
name|len
operator|==
operator|(
name|unsigned
name|int
operator|)
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SSL3_RT_HANDSHAKE
operator|&&
operator|!
name|s
operator|->
name|d1
operator|->
name|retransmitting
condition|)
block|{
comment|/* should not be done for 'Hello Request's, but in that case 				 * we'll ignore the result anyway */
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|s
operator|->
name|init_buf
operator|->
name|data
index|[
name|s
operator|->
name|init_off
index|]
decl_stmt|;
specifier|const
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
init|=
operator|&
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
decl_stmt|;
name|int
name|xlen
decl_stmt|;
if|if
condition|(
name|frag_off
operator|==
literal|0
operator|&&
name|s
operator|->
name|client_version
operator|!=
name|DTLS1_BAD_VER
condition|)
block|{
comment|/* reconstruct message header is if it 					 * is being sent in single fragment */
operator|*
name|p
operator|++
operator|=
name|msg_hdr
operator|->
name|type
expr_stmt|;
name|l2n3
argument_list|(
name|msg_hdr
operator|->
name|msg_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|msg_hdr
operator|->
name|seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
name|msg_hdr
operator|->
name|msg_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|-=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|xlen
operator|=
name|ret
expr_stmt|;
block|}
else|else
block|{
name|p
operator|+=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|xlen
operator|=
name|ret
operator|-
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
block|}
name|ssl3_finish_mac
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|xlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|s
operator|->
name|init_num
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|1
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|type
argument_list|,
name|s
operator|->
name|init_buf
operator|->
name|data
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|s
operator|->
name|init_off
operator|+
name|s
operator|->
name|init_num
argument_list|)
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
comment|/* done writing this message */
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|s
operator|->
name|init_off
operator|+=
name|ret
expr_stmt|;
name|s
operator|->
name|init_num
operator|-=
name|ret
expr_stmt|;
name|frag_off
operator|+=
operator|(
name|ret
operator|-=
name|DTLS1_HM_HEADER_LENGTH
operator|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Obtain handshake message of message type 'mt' (any if mt == -1),  * maximum acceptable body length 'max'.  * Read an entire handshake message.  Handshake messages arrive in  * fragments.  */
end_comment

begin_function
name|long
name|dtls1_get_message
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|st1
parameter_list|,
name|int
name|stn
parameter_list|,
name|int
name|mt
parameter_list|,
name|long
name|max
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|al
decl_stmt|;
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
decl_stmt|;
comment|/* s3->tmp is used to store messages that are unexpected, caused 	 * by the absence of an optional handshake message */
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|reuse_message
condition|)
block|{
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|reuse_message
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|mt
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|!=
name|mt
operator|)
condition|)
block|{
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_GET_MESSAGE
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
operator|*
name|ok
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|init_msg
operator|=
name|s
operator|->
name|init_buf
operator|->
name|data
operator|+
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
operator|(
name|int
operator|)
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_size
expr_stmt|;
return|return
name|s
operator|->
name|init_num
return|;
block|}
name|msg_hdr
operator|=
operator|&
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
expr_stmt|;
do|do
block|{
if|if
condition|(
name|msg_hdr
operator|->
name|frag_off
operator|==
literal|0
condition|)
block|{
comment|/* s->d1->r_message_header.msg_len = 0; */
name|memset
argument_list|(
name|msg_hdr
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hm_header_st
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|dtls1_get_message_fragment
argument_list|(
name|s
argument_list|,
name|st1
argument_list|,
name|stn
argument_list|,
name|max
argument_list|,
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|DTLS1_HM_BAD_FRAGMENT
operator|||
name|i
operator|==
name|DTLS1_HM_FRAGMENT_RETRY
condition|)
comment|/* bad fragment received */
continue|continue;
elseif|else
if|if
condition|(
name|i
operator|<=
literal|0
operator|&&
operator|!
operator|*
name|ok
condition|)
return|return
name|i
return|;
comment|/* Note that s->init_sum is used as a counter summing 		 * up fragments' lengths: as soon as they sum up to 		 * handshake packet length, we assume we have got all 		 * the fragments. Overlapping fragments would cause 		 * premature termination, so we don't expect overlaps. 		 * Well, handling overlaps would require something more 		 * drastic. Indeed, as it is now there is no way to 		 * tell if out-of-order fragment from the middle was 		 * the last. '>=' is the best/least we can do to control 		 * the potential damage caused by malformed overlaps. */
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|init_num
operator|>=
name|msg_hdr
operator|->
name|msg_len
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
decl_stmt|;
name|unsigned
name|long
name|msg_len
init|=
name|msg_hdr
operator|->
name|msg_len
decl_stmt|;
comment|/* reconstruct message header as if it was 			 * sent in single fragment */
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|msg_hdr
operator|->
name|type
expr_stmt|;
name|l2n3
argument_list|(
name|msg_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|msg_hdr
operator|->
name|seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
name|msg_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|client_version
operator|!=
name|DTLS1_BAD_VER
condition|)
name|p
operator|-=
name|DTLS1_HM_HEADER_LENGTH
operator|,
name|msg_len
operator|+=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|ssl3_finish_mac
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|0
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|p
argument_list|,
name|msg_len
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|msg_hdr
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hm_header_st
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
operator|++
expr_stmt|;
comment|/* we just read a handshake message from the other side: 			 * this means that we don't need to retransmit of the 			 * buffered messages.   			 * XDTLS: may be able clear out this 			 * buffer a little sooner (i.e if an out-of-order 			 * handshake message/record is received at the record 			 * layer.   			 * XDTLS: exception is that the server needs to 			 * know that change cipher spec and finished messages 			 * have been received by the client before clearing this 			 * buffer.  this can simply be done by waiting for the 			 * first data  segment, but is there a better way?  */
name|dtls1_clear_record_buffer
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_msg
operator|=
name|s
operator|->
name|init_buf
operator|->
name|data
operator|+
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
return|return
name|s
operator|->
name|init_num
return|;
block|}
else|else
name|msg_hdr
operator|->
name|frag_off
operator|=
name|i
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|f_err
label|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtls1_preprocess_fragment
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|size_t
name|frag_off
decl_stmt|,
name|frag_len
decl_stmt|,
name|msg_len
decl_stmt|;
name|msg_len
operator|=
name|msg_hdr
operator|->
name|msg_len
expr_stmt|;
name|frag_off
operator|=
name|msg_hdr
operator|->
name|frag_off
expr_stmt|;
name|frag_len
operator|=
name|msg_hdr
operator|->
name|frag_len
expr_stmt|;
comment|/* sanity checking */
if|if
condition|(
operator|(
name|frag_off
operator|+
name|frag_len
operator|)
operator|>
name|msg_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_PREPROCESS_FRAGMENT
argument_list|,
name|SSL_R_EXCESSIVE_MESSAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|SSL_AD_ILLEGAL_PARAMETER
return|;
block|}
if|if
condition|(
operator|(
name|frag_off
operator|+
name|frag_len
operator|)
operator|>
operator|(
name|unsigned
name|long
operator|)
name|max
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_PREPROCESS_FRAGMENT
argument_list|,
name|SSL_R_EXCESSIVE_MESSAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|SSL_AD_ILLEGAL_PARAMETER
return|;
block|}
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|frag_off
operator|==
literal|0
condition|)
comment|/* first fragment */
block|{
comment|/* msg_len is limited to 2^24, but is effectively checked 		 * against max above */
if|if
condition|(
operator|!
name|BUF_MEM_grow_clean
argument_list|(
name|s
operator|->
name|init_buf
argument_list|,
operator|(
name|int
operator|)
name|msg_len
operator|+
name|DTLS1_HM_HEADER_LENGTH
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_PREPROCESS_FRAGMENT
argument_list|,
name|ERR_R_BUF_LIB
argument_list|)
expr_stmt|;
return|return
name|SSL_AD_INTERNAL_ERROR
return|;
block|}
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_size
operator|=
name|msg_len
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|msg_len
operator|=
name|msg_len
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|=
name|msg_hdr
operator|->
name|type
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|type
operator|=
name|msg_hdr
operator|->
name|type
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|seq
operator|=
name|msg_hdr
operator|->
name|seq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msg_len
operator|!=
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|msg_len
condition|)
block|{
comment|/* They must be playing with us! BTW, failure to enforce 		 * upper limit would open possibility for buffer overrun. */
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_PREPROCESS_FRAGMENT
argument_list|,
name|SSL_R_EXCESSIVE_MESSAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|SSL_AD_ILLEGAL_PARAMETER
return|;
block|}
return|return
literal|0
return|;
comment|/* no error */
block|}
end_function

begin_function
specifier|static
name|int
name|dtls1_retrieve_buffered_fragment
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|long
name|max
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
block|{
comment|/* (0) check whether the desired fragment is available 	 * if so: 	 * (1) copy over the fragment to s->init_buf->data[] 	 * (2) update s->init_num 	 */
name|pitem
modifier|*
name|item
decl_stmt|;
name|hm_fragment
modifier|*
name|frag
decl_stmt|;
name|int
name|al
decl_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
name|item
operator|=
name|pqueue_peek
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|frag
operator|=
operator|(
name|hm_fragment
operator|*
operator|)
name|item
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
operator|==
name|frag
operator|->
name|msg_header
operator|.
name|seq
condition|)
block|{
name|pqueue_pop
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|)
expr_stmt|;
name|al
operator|=
name|dtls1_preprocess_fragment
argument_list|(
name|s
argument_list|,
operator|&
name|frag
operator|->
name|msg_header
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
literal|0
condition|)
comment|/* no alert */
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
operator|+
name|DTLS1_HM_HEADER_LENGTH
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|p
index|[
name|frag
operator|->
name|msg_header
operator|.
name|frag_off
index|]
argument_list|,
name|frag
operator|->
name|fragment
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|frag_len
argument_list|)
expr_stmt|;
block|}
name|dtls1_hm_fragment_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
name|pitem_free
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
literal|0
condition|)
block|{
operator|*
name|ok
operator|=
literal|1
expr_stmt|;
return|return
name|frag
operator|->
name|msg_header
operator|.
name|frag_len
return|;
block|}
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtls1_process_out_of_seq_message
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|hm_fragment
modifier|*
name|frag
init|=
name|NULL
decl_stmt|;
name|pitem
modifier|*
name|item
init|=
name|NULL
decl_stmt|;
name|PQ_64BIT
name|seq64
decl_stmt|;
name|unsigned
name|long
name|frag_len
init|=
name|msg_hdr
operator|->
name|frag_len
decl_stmt|;
if|if
condition|(
operator|(
name|msg_hdr
operator|->
name|frag_off
operator|+
name|frag_len
operator|)
operator|>
name|msg_hdr
operator|->
name|msg_len
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|msg_hdr
operator|->
name|seq
operator|<=
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
condition|)
block|{
name|unsigned
name|char
name|devnull
index|[
literal|256
index|]
decl_stmt|;
while|while
condition|(
name|frag_len
condition|)
block|{
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|devnull
argument_list|,
name|frag_len
operator|>
sizeof|sizeof
argument_list|(
name|devnull
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|devnull
argument_list|)
else|:
name|frag_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
name|frag_len
operator|-=
name|i
expr_stmt|;
block|}
block|}
name|frag
operator|=
name|dtls1_hm_fragment_new
argument_list|(
name|frag_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|memcpy
argument_list|(
operator|&
operator|(
name|frag
operator|->
name|msg_header
operator|)
argument_list|,
name|msg_hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag_len
condition|)
block|{
comment|/* read the body of the fragment (header has already been read */
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|frag
operator|->
name|fragment
argument_list|,
name|frag_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
operator|(
name|unsigned
name|long
operator|)
name|i
operator|!=
name|frag_len
condition|)
goto|goto
name|err
goto|;
block|}
name|pq_64bit_init
argument_list|(
operator|&
name|seq64
argument_list|)
expr_stmt|;
name|pq_64bit_assign_word
argument_list|(
operator|&
name|seq64
argument_list|,
name|msg_hdr
operator|->
name|seq
argument_list|)
expr_stmt|;
name|item
operator|=
name|pitem_new
argument_list|(
name|seq64
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|pq_64bit_free
argument_list|(
operator|&
name|seq64
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|pqueue_insert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|,
name|item
argument_list|)
expr_stmt|;
return|return
name|DTLS1_HM_FRAGMENT_RETRY
return|;
name|err
label|:
if|if
condition|(
name|frag
operator|!=
name|NULL
condition|)
name|dtls1_hm_fragment_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|item
argument_list|)
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|dtls1_get_message_fragment
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|st1
parameter_list|,
name|int
name|stn
parameter_list|,
name|long
name|max
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
block|{
name|unsigned
name|char
name|wire
index|[
name|DTLS1_HM_HEADER_LENGTH
index|]
decl_stmt|;
name|unsigned
name|long
name|l
decl_stmt|,
name|frag_off
decl_stmt|,
name|frag_len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|al
decl_stmt|;
name|struct
name|hm_header_st
name|msg_hdr
decl_stmt|;
comment|/* see if we have the required fragment already */
if|if
condition|(
operator|(
name|frag_len
operator|=
name|dtls1_retrieve_buffered_fragment
argument_list|(
name|s
argument_list|,
name|max
argument_list|,
name|ok
argument_list|)
operator|)
operator|||
operator|*
name|ok
condition|)
block|{
if|if
condition|(
operator|*
name|ok
condition|)
name|s
operator|->
name|init_num
operator|+=
name|frag_len
expr_stmt|;
return|return
name|frag_len
return|;
block|}
comment|/* read handshake message header */
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|wire
argument_list|,
name|DTLS1_HM_HEADER_LENGTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
comment|/* nbio, or an error */
block|{
name|s
operator|->
name|rwstate
operator|=
name|SSL_READING
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
name|OPENSSL_assert
argument_list|(
name|i
operator|==
name|DTLS1_HM_HEADER_LENGTH
argument_list|)
expr_stmt|;
comment|/* parse the message fragment header */
name|dtls1_get_message_header
argument_list|(
name|wire
argument_list|,
operator|&
name|msg_hdr
argument_list|)
expr_stmt|;
comment|/*  	 * if this is a future (or stale) message it gets buffered 	 * (or dropped)--no further processing at this time  	 */
if|if
condition|(
name|msg_hdr
operator|.
name|seq
operator|!=
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
condition|)
return|return
name|dtls1_process_out_of_seq_message
argument_list|(
name|s
argument_list|,
operator|&
name|msg_hdr
argument_list|,
name|ok
argument_list|)
return|;
name|l
operator|=
name|msg_hdr
operator|.
name|msg_len
expr_stmt|;
name|frag_off
operator|=
name|msg_hdr
operator|.
name|frag_off
expr_stmt|;
name|frag_len
operator|=
name|msg_hdr
operator|.
name|frag_len
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|server
operator|&&
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|frag_off
operator|==
literal|0
operator|&&
name|wire
index|[
literal|0
index|]
operator|==
name|SSL3_MT_HELLO_REQUEST
condition|)
block|{
comment|/* The server may always send 'Hello Request' messages -- 		 * we are doing a handshake anyway now, so ignore them 		 * if their format is correct. Does not count for 		 * 'Finished' MAC. */
if|if
condition|(
name|wire
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|wire
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|wire
index|[
literal|3
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|0
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|wire
argument_list|,
name|DTLS1_HM_HEADER_LENGTH
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
return|return
name|dtls1_get_message_fragment
argument_list|(
name|s
argument_list|,
name|st1
argument_list|,
name|stn
argument_list|,
name|max
argument_list|,
name|ok
argument_list|)
return|;
block|}
else|else
comment|/* Incorrectly formated Hello request */
block|{
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_GET_MESSAGE_FRAGMENT
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|al
operator|=
name|dtls1_preprocess_fragment
argument_list|(
name|s
argument_list|,
operator|&
name|msg_hdr
argument_list|,
name|max
argument_list|)
operator|)
condition|)
goto|goto
name|f_err
goto|;
comment|/* XDTLS:  ressurect this when restart is in place */
name|s
operator|->
name|state
operator|=
name|stn
expr_stmt|;
if|if
condition|(
name|frag_len
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
operator|+
name|DTLS1_HM_HEADER_LENGTH
decl_stmt|;
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
operator|&
name|p
index|[
name|frag_off
index|]
argument_list|,
name|frag_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XDTLS:  fix this--message fragments cannot span multiple packets */
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|s
operator|->
name|rwstate
operator|=
name|SSL_READING
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
comment|/* XDTLS:  an incorrectly formatted fragment should cause the  	 * handshake to fail */
name|OPENSSL_assert
argument_list|(
name|i
operator|==
operator|(
name|int
operator|)
name|frag_len
argument_list|)
expr_stmt|;
operator|*
name|ok
operator|=
literal|1
expr_stmt|;
comment|/* Note that s->init_num is *not* used as current offset in 	 * s->init_buf->data, but as a counter summing up fragments' 	 * lengths: as soon as they sum up to handshake packet 	 * length, we assume we have got all the fragments. */
name|s
operator|->
name|init_num
operator|+=
name|frag_len
expr_stmt|;
return|return
name|frag_len
return|;
name|f_err
label|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtls1_send_finished
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|sender
parameter_list|,
name|int
name|slen
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|l
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|a
condition|)
block|{
name|d
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
name|p
operator|=
operator|&
operator|(
name|d
index|[
name|DTLS1_HM_HEADER_LENGTH
index|]
operator|)
expr_stmt|;
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl3_enc
operator|->
name|final_finish_mac
argument_list|(
name|s
argument_list|,
operator|&
operator|(
name|s
operator|->
name|s3
operator|->
name|finish_dgst1
operator|)
argument_list|,
operator|&
operator|(
name|s
operator|->
name|s3
operator|->
name|finish_dgst2
operator|)
argument_list|,
name|sender
argument_list|,
name|slen
argument_list|,
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md
argument_list|)
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md_len
operator|=
name|i
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|finish_md
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
name|l
operator|=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL_SYS_WIN16
comment|/* MSVC 1.5 does not clear the top bytes of the word unless 		 * I do this. 		 */
name|l
operator|&=
literal|0xffff
expr_stmt|;
endif|#
directive|endif
name|d
operator|=
name|dtls1_set_message_header
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|SSL3_MT_FINISHED
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
operator|(
name|int
operator|)
name|l
operator|+
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
comment|/* buffer the message to handle re-xmits */
name|dtls1_buffer_message
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|b
expr_stmt|;
block|}
comment|/* SSL3_ST_SEND_xxxxxx_HELLO_B */
return|return
operator|(
name|dtls1_do_write
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* for these 2 messages, we need to  * ssl->enc_read_ctx			re-init  * ssl->s3->read_sequence		zero  * ssl->s3->read_mac_secret		re-init  * ssl->session->read_sym_enc		assign  * ssl->session->read_compression	assign  * ssl->session->read_hash		assign  */
end_comment

begin_function
name|int
name|dtls1_send_change_cipher_spec
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|a
condition|)
block|{
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SSL3_MT_CCS
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|handshake_write_seq
operator|=
name|s
operator|->
name|d1
operator|->
name|next_handshake_write_seq
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
name|DTLS1_CCS_HEADER_LENGTH
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|client_version
operator|==
name|DTLS1_BAD_VER
condition|)
block|{
name|s
operator|->
name|d1
operator|->
name|next_handshake_write_seq
operator|++
expr_stmt|;
name|s2n
argument_list|(
name|s
operator|->
name|d1
operator|->
name|handshake_write_seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|+=
literal|2
expr_stmt|;
block|}
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
name|dtls1_set_message_header_int
argument_list|(
name|s
argument_list|,
name|SSL3_MT_CCS
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|d1
operator|->
name|handshake_write_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* buffer the message to handle re-xmits */
name|dtls1_buffer_message
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|b
expr_stmt|;
block|}
comment|/* SSL3_ST_CW_CHANGE_B */
return|return
operator|(
name|dtls1_do_write
argument_list|(
name|s
argument_list|,
name|SSL3_RT_CHANGE_CIPHER_SPEC
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|dtls1_output_cert_chain
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|X509
modifier|*
name|x
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|long
name|l
init|=
literal|3
operator|+
name|DTLS1_HM_HEADER_LENGTH
decl_stmt|;
name|BUF_MEM
modifier|*
name|buf
decl_stmt|;
name|X509_STORE_CTX
name|xs_ctx
decl_stmt|;
name|X509_OBJECT
name|obj
decl_stmt|;
comment|/* TLSv1 sends a chain with nothing in it, instead of an alert */
name|buf
operator|=
name|s
operator|->
name|init_buf
expr_stmt|;
if|if
condition|(
operator|!
name|BUF_MEM_grow_clean
argument_list|(
name|buf
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_OUTPUT_CERT_CHAIN
argument_list|,
name|ERR_R_BUF_LIB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|X509_STORE_CTX_init
argument_list|(
operator|&
name|xs_ctx
argument_list|,
name|s
operator|->
name|ctx
operator|->
name|cert_store
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_OUTPUT_CERT_CHAIN
argument_list|,
name|ERR_R_X509_LIB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|=
name|i2d_X509
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BUF_MEM_grow_clean
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|n
operator|+
name|l
operator|+
literal|3
argument_list|)
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_OUTPUT_CERT_CHAIN
argument_list|,
name|ERR_R_BUF_LIB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
name|buf
operator|->
name|data
index|[
name|l
index|]
operator|)
expr_stmt|;
name|l2n3
argument_list|(
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|i2d_X509
argument_list|(
name|x
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|l
operator|+=
name|n
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|X509_NAME_cmp
argument_list|(
name|X509_get_subject_name
argument_list|(
name|x
argument_list|)
argument_list|,
name|X509_get_issuer_name
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|i
operator|=
name|X509_STORE_get_by_subject
argument_list|(
operator|&
name|xs_ctx
argument_list|,
name|X509_LU_X509
argument_list|,
name|X509_get_issuer_name
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
name|x
operator|=
name|obj
operator|.
name|data
operator|.
name|x509
expr_stmt|;
comment|/* Count is one too high since the X509_STORE_get uped the 			 * ref count */
name|X509_free
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|X509_STORE_CTX_cleanup
argument_list|(
operator|&
name|xs_ctx
argument_list|)
expr_stmt|;
block|}
comment|/* Thawte special :-) */
if|if
condition|(
name|s
operator|->
name|ctx
operator|->
name|extra_certs
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_num
argument_list|(
name|s
operator|->
name|ctx
operator|->
name|extra_certs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|sk_X509_value
argument_list|(
name|s
operator|->
name|ctx
operator|->
name|extra_certs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|n
operator|=
name|i2d_X509
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BUF_MEM_grow_clean
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|n
operator|+
name|l
operator|+
literal|3
argument_list|)
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_OUTPUT_CERT_CHAIN
argument_list|,
name|ERR_R_BUF_LIB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
name|buf
operator|->
name|data
index|[
name|l
index|]
operator|)
expr_stmt|;
name|l2n3
argument_list|(
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|i2d_X509
argument_list|(
name|x
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|l
operator|+=
name|n
operator|+
literal|3
expr_stmt|;
block|}
name|l
operator|-=
operator|(
literal|3
operator|+
name|DTLS1_HM_HEADER_LENGTH
operator|)
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
name|buf
operator|->
name|data
index|[
name|DTLS1_HM_HEADER_LENGTH
index|]
operator|)
expr_stmt|;
name|l2n3
argument_list|(
name|l
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l
operator|+=
literal|3
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
name|buf
operator|->
name|data
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|p
operator|=
name|dtls1_set_message_header
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|SSL3_MT_CERTIFICATE
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|l
operator|+=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtls1_read_failed
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|DTLS1_STATE
modifier|*
name|state
decl_stmt|;
name|BIO
modifier|*
name|bio
decl_stmt|;
name|int
name|send_alert
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|code
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid state reached %s:%d"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bio
operator|=
name|SSL_get_rbio
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BIO_dgram_recv_timedout
argument_list|(
name|bio
argument_list|)
condition|)
block|{
comment|/* not a timeout, none of our business,  		   let higher layers handle this.  in fact it's probably an error */
return|return
name|code
return|;
block|}
if|if
condition|(
operator|!
name|SSL_in_init
argument_list|(
name|s
argument_list|)
condition|)
comment|/* done, no need to send a retransmit */
block|{
name|BIO_set_flags
argument_list|(
name|SSL_get_rbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_FLAGS_READ
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
name|state
operator|=
name|s
operator|->
name|d1
expr_stmt|;
name|state
operator|->
name|timeout
operator|.
name|num_alerts
operator|++
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|timeout
operator|.
name|num_alerts
operator|>
name|DTLS1_TMO_ALERT_COUNT
condition|)
block|{
comment|/* fail the connection, enough alerts have been sent */
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_READ_FAILED
argument_list|,
name|SSL_R_READ_TIMEOUT_EXPIRED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|state
operator|->
name|timeout
operator|.
name|read_timeouts
operator|++
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|timeout
operator|.
name|read_timeouts
operator|>
name|DTLS1_TMO_READ_COUNT
condition|)
block|{
name|send_alert
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|timeout
operator|.
name|read_timeouts
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* for now, each alert contains only one record number */
block|item = pqueue_peek(state->rcvd_records); 	if ( item ) 		{
comment|/* send an alert immediately for all the missing records */
block|} 	else
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* no more alert sending, just retransmit the last set of messages */
block|if ( send_alert) 			ssl3_send_alert(s,SSL3_AL_WARNING, 				DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
endif|#
directive|endif
return|return
name|dtls1_retransmit_buffered_messages
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtls1_retransmit_buffered_messages
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|pqueue
name|sent
init|=
name|s
operator|->
name|d1
operator|->
name|sent_messages
decl_stmt|;
name|piterator
name|iter
decl_stmt|;
name|pitem
modifier|*
name|item
decl_stmt|;
name|hm_fragment
modifier|*
name|frag
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|iter
operator|=
name|pqueue_iterator
argument_list|(
name|sent
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|pqueue_next
argument_list|(
operator|&
name|iter
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|pqueue_next
argument_list|(
operator|&
name|iter
argument_list|)
control|)
block|{
name|frag
operator|=
operator|(
name|hm_fragment
operator|*
operator|)
name|item
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|dtls1_retransmit_message
argument_list|(
name|s
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|seq
argument_list|,
literal|0
argument_list|,
operator|&
name|found
argument_list|)
operator|<=
literal|0
operator|&&
name|found
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dtls1_retransmit_message() failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|dtls1_buffer_message
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|is_ccs
parameter_list|)
block|{
name|pitem
modifier|*
name|item
decl_stmt|;
name|hm_fragment
modifier|*
name|frag
decl_stmt|;
name|PQ_64BIT
name|seq64
decl_stmt|;
name|unsigned
name|int
name|epoch
init|=
name|s
operator|->
name|d1
operator|->
name|w_epoch
decl_stmt|;
comment|/* this function is called immediately after a message has  	 * been serialized */
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|init_off
operator|==
literal|0
argument_list|)
expr_stmt|;
name|frag
operator|=
name|dtls1_hm_fragment_new
argument_list|(
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|frag
operator|->
name|fragment
argument_list|,
name|s
operator|->
name|init_buf
operator|->
name|data
argument_list|,
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ccs
condition|)
block|{
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|msg_len
operator|+
name|DTLS1_CCS_HEADER_LENGTH
operator|<=
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
name|epoch
operator|++
expr_stmt|;
block|}
else|else
block|{
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|msg_len
operator|+
name|DTLS1_HM_HEADER_LENGTH
operator|==
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
block|}
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
operator|=
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|msg_len
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|seq
operator|=
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|seq
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|type
operator|=
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|type
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|frag_off
operator|=
literal|0
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|frag_len
operator|=
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|msg_len
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
operator|=
name|is_ccs
expr_stmt|;
name|pq_64bit_init
argument_list|(
operator|&
name|seq64
argument_list|)
expr_stmt|;
name|pq_64bit_assign_word
argument_list|(
operator|&
name|seq64
argument_list|,
name|epoch
operator|<<
literal|16
operator||
name|frag
operator|->
name|msg_header
operator|.
name|seq
argument_list|)
expr_stmt|;
name|item
operator|=
name|pitem_new
argument_list|(
name|seq64
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|pq_64bit_free
argument_list|(
operator|&
name|seq64
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|dtls1_hm_fragment_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
literal|0
block|fprintf( stderr, "buffered messge: \ttype = %xx\n", msg_buf->type); 	fprintf( stderr, "\t\t\t\t\tlen = %d\n", msg_buf->len); 	fprintf( stderr, "\t\t\t\t\tseq_num = %d\n", msg_buf->seq_num);
endif|#
directive|endif
name|pqueue_insert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|sent_messages
argument_list|,
name|item
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|dtls1_retransmit_message
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|short
name|seq
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|int
modifier|*
name|found
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* XDTLS: for now assuming that read/writes are blocking */
name|pitem
modifier|*
name|item
decl_stmt|;
name|hm_fragment
modifier|*
name|frag
decl_stmt|;
name|unsigned
name|long
name|header_length
decl_stmt|;
name|PQ_64BIT
name|seq64
decl_stmt|;
comment|/* 	  OPENSSL_assert(s->init_num == 0); 	  OPENSSL_assert(s->init_off == 0); 	 */
comment|/* XDTLS:  the requested message ought to be found, otherwise error */
name|pq_64bit_init
argument_list|(
operator|&
name|seq64
argument_list|)
expr_stmt|;
name|pq_64bit_assign_word
argument_list|(
operator|&
name|seq64
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|item
operator|=
name|pqueue_find
argument_list|(
name|s
operator|->
name|d1
operator|->
name|sent_messages
argument_list|,
name|seq64
argument_list|)
expr_stmt|;
name|pq_64bit_free
argument_list|(
operator|&
name|seq64
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"retransmit:  message %d non-existant\n"
argument_list|,
name|seq
argument_list|)
expr_stmt|;
operator|*
name|found
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|found
operator|=
literal|1
expr_stmt|;
name|frag
operator|=
operator|(
name|hm_fragment
operator|*
operator|)
name|item
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
condition|)
name|header_length
operator|=
name|DTLS1_CCS_HEADER_LENGTH
expr_stmt|;
else|else
name|header_length
operator|=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|init_buf
operator|->
name|data
argument_list|,
name|frag
operator|->
name|fragment
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
operator|+
name|header_length
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
operator|+
name|header_length
expr_stmt|;
name|dtls1_set_message_header_int
argument_list|(
name|s
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|type
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|seq
argument_list|,
literal|0
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|frag_len
argument_list|)
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|retransmitting
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|dtls1_do_write
argument_list|(
name|s
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
condition|?
name|SSL3_RT_CHANGE_CIPHER_SPEC
else|:
name|SSL3_RT_HANDSHAKE
argument_list|)
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|retransmitting
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_flush
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* call this function when the buffered messages are no longer needed */
end_comment

begin_function
name|void
name|dtls1_clear_record_buffer
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|pitem
modifier|*
name|item
decl_stmt|;
for|for
control|(
name|item
operator|=
name|pqueue_pop
argument_list|(
name|s
operator|->
name|d1
operator|->
name|sent_messages
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|pqueue_pop
argument_list|(
name|s
operator|->
name|d1
operator|->
name|sent_messages
argument_list|)
control|)
block|{
name|dtls1_hm_fragment_free
argument_list|(
operator|(
name|hm_fragment
operator|*
operator|)
name|item
operator|->
name|data
argument_list|)
expr_stmt|;
name|pitem_free
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
name|dtls1_set_message_header
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
name|mt
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|unsigned
name|long
name|frag_len
parameter_list|)
block|{
if|if
condition|(
name|frag_off
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|d1
operator|->
name|handshake_write_seq
operator|=
name|s
operator|->
name|d1
operator|->
name|next_handshake_write_seq
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|next_handshake_write_seq
operator|++
expr_stmt|;
block|}
name|dtls1_set_message_header_int
argument_list|(
name|s
argument_list|,
name|mt
argument_list|,
name|len
argument_list|,
name|s
operator|->
name|d1
operator|->
name|handshake_write_seq
argument_list|,
name|frag_off
argument_list|,
name|frag_len
argument_list|)
expr_stmt|;
return|return
name|p
operator|+=
name|DTLS1_HM_HEADER_LENGTH
return|;
block|}
end_function

begin_comment
comment|/* don't actually do the writing, wait till the MTU has been retrieved */
end_comment

begin_function
specifier|static
name|void
name|dtls1_set_message_header_int
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
name|mt
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|unsigned
name|short
name|seq_num
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|unsigned
name|long
name|frag_len
parameter_list|)
block|{
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
init|=
operator|&
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
decl_stmt|;
name|msg_hdr
operator|->
name|type
operator|=
name|mt
expr_stmt|;
name|msg_hdr
operator|->
name|msg_len
operator|=
name|len
expr_stmt|;
name|msg_hdr
operator|->
name|seq
operator|=
name|seq_num
expr_stmt|;
name|msg_hdr
operator|->
name|frag_off
operator|=
name|frag_off
expr_stmt|;
name|msg_hdr
operator|->
name|frag_len
operator|=
name|frag_len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtls1_fix_message_header
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|unsigned
name|long
name|frag_len
parameter_list|)
block|{
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
init|=
operator|&
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
decl_stmt|;
name|msg_hdr
operator|->
name|frag_off
operator|=
name|frag_off
expr_stmt|;
name|msg_hdr
operator|->
name|frag_len
operator|=
name|frag_len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|dtls1_write_message_header
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
init|=
operator|&
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
decl_stmt|;
operator|*
name|p
operator|++
operator|=
name|msg_hdr
operator|->
name|type
expr_stmt|;
name|l2n3
argument_list|(
name|msg_hdr
operator|->
name|msg_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|msg_hdr
operator|->
name|seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
name|msg_hdr
operator|->
name|frag_off
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
name|msg_hdr
operator|->
name|frag_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|dtls1_min_mtu
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|g_probable_mtu
index|[
operator|(
sizeof|sizeof
argument_list|(
name|g_probable_mtu
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|g_probable_mtu
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|dtls1_guess_mtu
parameter_list|(
name|unsigned
name|int
name|curr_mtu
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|curr_mtu
operator|==
literal|0
condition|)
return|return
name|g_probable_mtu
index|[
literal|0
index|]
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|g_probable_mtu
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|g_probable_mtu
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|curr_mtu
operator|>
name|g_probable_mtu
index|[
name|i
index|]
condition|)
return|return
name|g_probable_mtu
index|[
name|i
index|]
return|;
return|return
name|curr_mtu
return|;
block|}
end_function

begin_function
name|void
name|dtls1_get_message_header
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
parameter_list|)
block|{
name|memset
argument_list|(
name|msg_hdr
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hm_header_st
argument_list|)
argument_list|)
expr_stmt|;
name|msg_hdr
operator|->
name|type
operator|=
operator|*
operator|(
name|data
operator|++
operator|)
expr_stmt|;
name|n2l3
argument_list|(
name|data
argument_list|,
name|msg_hdr
operator|->
name|msg_len
argument_list|)
expr_stmt|;
name|n2s
argument_list|(
name|data
argument_list|,
name|msg_hdr
operator|->
name|seq
argument_list|)
expr_stmt|;
name|n2l3
argument_list|(
name|data
argument_list|,
name|msg_hdr
operator|->
name|frag_off
argument_list|)
expr_stmt|;
name|n2l3
argument_list|(
name|data
argument_list|,
name|msg_hdr
operator|->
name|frag_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dtls1_get_ccs_header
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|ccs_header_st
modifier|*
name|ccs_hdr
parameter_list|)
block|{
name|memset
argument_list|(
name|ccs_hdr
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccs_header_st
argument_list|)
argument_list|)
expr_stmt|;
name|ccs_hdr
operator|->
name|type
operator|=
operator|*
operator|(
name|data
operator|++
operator|)
expr_stmt|;
block|}
end_function

end_unit

