begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ssl/d1_both.c */
end_comment

begin_comment
comment|/*  * DTLS implementation written by Nagendra Modadugu  * (nagendra@cs.stanford.edu) for the OpenSSL project 2005.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *  * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *  * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from  *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ssl_locl.h"
end_include

begin_include
include|#
directive|include
file|<openssl/buffer.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509.h>
end_include

begin_define
define|#
directive|define
name|RSMBLY_BITMASK_SIZE
parameter_list|(
name|msg_len
parameter_list|)
value|(((msg_len) + 7) / 8)
end_define

begin_define
define|#
directive|define
name|RSMBLY_BITMASK_MARK
parameter_list|(
name|bitmask
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
value|{ \                         if ((end) - (start)<= 8) { \                                 long ii; \                                 for (ii = (start); ii< (end); ii++) bitmask[((ii)>> 3)] |= (1<< ((ii)& 7)); \                         } else { \                                 long ii; \                                 bitmask[((start)>> 3)] |= bitmask_start_values[((start)& 7)]; \                                 for (ii = (((start)>> 3) + 1); ii< ((((end) - 1))>> 3); ii++) bitmask[ii] = 0xff; \                                 bitmask[(((end) - 1)>> 3)] |= bitmask_end_values[((end)& 7)]; \                         } }
end_define

begin_define
define|#
directive|define
name|RSMBLY_BITMASK_IS_COMPLETE
parameter_list|(
name|bitmask
parameter_list|,
name|msg_len
parameter_list|,
name|is_complete
parameter_list|)
value|{ \                         long ii; \                         OPENSSL_assert((msg_len)> 0); \                         is_complete = 1; \                         if (bitmask[(((msg_len) - 1)>> 3)] != bitmask_end_values[((msg_len)& 7)]) is_complete = 0; \                         if (is_complete) for (ii = (((msg_len) - 1)>> 3) - 1; ii>= 0 ; ii--) \                                 if (bitmask[ii] != 0xff) { is_complete = 0; break; } }
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|RSMBLY_BITMASK_PRINT
parameter_list|(
name|bitmask
parameter_list|,
name|msg_len
parameter_list|)
value|{ \                         long ii; \                         printf("bitmask: "); for (ii = 0; ii< (msg_len); ii++) \                         printf("%d ", (bitmask[ii>> 3]& (1<< (ii& 7)))>> (ii& 7)); \                         printf("\n"); }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|bitmask_start_values
index|[]
init|=
block|{
literal|0xff
block|,
literal|0xfe
block|,
literal|0xfc
block|,
literal|0xf8
block|,
literal|0xf0
block|,
literal|0xe0
block|,
literal|0xc0
block|,
literal|0x80
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|bitmask_end_values
index|[]
init|=
block|{
literal|0xff
block|,
literal|0x01
block|,
literal|0x03
block|,
literal|0x07
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x3f
block|,
literal|0x7f
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XDTLS:  figure out the right values */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|g_probable_mtu
index|[]
init|=
block|{
literal|1500
block|,
literal|512
block|,
literal|256
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|dtls1_fix_message_header
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|unsigned
name|long
name|frag_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|dtls1_write_message_header
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtls1_set_message_header_int
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
name|mt
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|unsigned
name|short
name|seq_num
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|unsigned
name|long
name|frag_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|dtls1_get_message_fragment
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|st1
parameter_list|,
name|int
name|stn
parameter_list|,
name|long
name|max
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|hm_fragment
modifier|*
name|dtls1_hm_fragment_new
parameter_list|(
name|unsigned
name|long
name|frag_len
parameter_list|,
name|int
name|reassembly
parameter_list|)
block|{
name|hm_fragment
modifier|*
name|frag
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bitmask
init|=
name|NULL
decl_stmt|;
name|frag
operator|=
operator|(
name|hm_fragment
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hm_fragment
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|frag_len
condition|)
block|{
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
name|frag_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* zero length fragment gets zero frag->fragment */
name|frag
operator|->
name|fragment
operator|=
name|buf
expr_stmt|;
comment|/* Initialize reassembly bitmask if necessary */
if|if
condition|(
name|reassembly
condition|)
block|{
name|bitmask
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
name|RSMBLY_BITMASK_SIZE
argument_list|(
name|frag_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmask
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|bitmask
argument_list|,
literal|0
argument_list|,
name|RSMBLY_BITMASK_SIZE
argument_list|(
name|frag_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|frag
operator|->
name|reassembly
operator|=
name|bitmask
expr_stmt|;
return|return
name|frag
return|;
block|}
end_function

begin_function
name|void
name|dtls1_hm_fragment_free
parameter_list|(
name|hm_fragment
modifier|*
name|frag
parameter_list|)
block|{
if|if
condition|(
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
condition|)
block|{
name|EVP_CIPHER_CTX_free
argument_list|(
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|enc_write_ctx
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_destroy
argument_list|(
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|write_hash
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frag
operator|->
name|fragment
condition|)
name|OPENSSL_free
argument_list|(
name|frag
operator|->
name|fragment
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|reassembly
condition|)
name|OPENSSL_free
argument_list|(
name|frag
operator|->
name|reassembly
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtls1_query_mtu
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|link_mtu
condition|)
block|{
name|s
operator|->
name|d1
operator|->
name|mtu
operator|=
name|s
operator|->
name|d1
operator|->
name|link_mtu
operator|-
name|BIO_dgram_get_mtu_overhead
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|link_mtu
operator|=
literal|0
expr_stmt|;
block|}
comment|/* AHA!  Figure out the MTU, and stick to the right size */
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|mtu
operator|<
name|dtls1_min_mtu
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|SSL_get_options
argument_list|(
name|s
argument_list|)
operator|&
name|SSL_OP_NO_QUERY_MTU
operator|)
condition|)
block|{
name|s
operator|->
name|d1
operator|->
name|mtu
operator|=
name|BIO_ctrl
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_CTRL_DGRAM_QUERY_MTU
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*              * I've seen the kernel return bogus numbers when it doesn't know              * (initial write), so just make sure we have a reasonable number              */
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|mtu
operator|<
name|dtls1_min_mtu
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/* Set to min mtu */
name|s
operator|->
name|d1
operator|->
name|mtu
operator|=
name|dtls1_min_mtu
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|BIO_ctrl
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_CTRL_DGRAM_SET_MTU
argument_list|,
name|s
operator|->
name|d1
operator|->
name|mtu
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * send s->init_buf in records of type 'type' (SSL3_RT_HANDSHAKE or  * SSL3_RT_CHANGE_CIPHER_SPEC)  */
end_comment

begin_function
name|int
name|dtls1_do_write
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|int
name|curr_mtu
decl_stmt|;
name|int
name|retry
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|,
name|frag_off
decl_stmt|,
name|mac_size
decl_stmt|,
name|blocksize
decl_stmt|,
name|used_len
decl_stmt|;
if|if
condition|(
operator|!
name|dtls1_query_mtu
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|mtu
operator|>=
name|dtls1_min_mtu
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* should have something                                                      * reasonable now */
if|if
condition|(
name|s
operator|->
name|init_off
operator|==
literal|0
operator|&&
name|type
operator|==
name|SSL3_RT_HANDSHAKE
condition|)
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|init_num
operator|==
operator|(
name|int
operator|)
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|msg_len
operator|+
name|DTLS1_HM_HEADER_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|write_hash
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|enc_write_ctx
operator|&&
name|EVP_CIPHER_CTX_mode
argument_list|(
name|s
operator|->
name|enc_write_ctx
argument_list|)
operator|==
name|EVP_CIPH_GCM_MODE
condition|)
name|mac_size
operator|=
literal|0
expr_stmt|;
else|else
name|mac_size
operator|=
name|EVP_MD_CTX_size
argument_list|(
name|s
operator|->
name|write_hash
argument_list|)
expr_stmt|;
block|}
else|else
name|mac_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|enc_write_ctx
operator|&&
operator|(
name|EVP_CIPHER_CTX_mode
argument_list|(
name|s
operator|->
name|enc_write_ctx
argument_list|)
operator|==
name|EVP_CIPH_CBC_MODE
operator|)
condition|)
name|blocksize
operator|=
literal|2
operator|*
name|EVP_CIPHER_block_size
argument_list|(
name|s
operator|->
name|enc_write_ctx
operator|->
name|cipher
argument_list|)
expr_stmt|;
else|else
name|blocksize
operator|=
literal|0
expr_stmt|;
name|frag_off
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|rwstate
operator|=
name|SSL_NOTHING
expr_stmt|;
comment|/* s->init_num shouldn't ever be< 0...but just in case */
while|while
condition|(
name|s
operator|->
name|init_num
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|SSL3_RT_HANDSHAKE
operator|&&
name|s
operator|->
name|init_off
operator|!=
literal|0
condition|)
block|{
comment|/* We must be writing a fragment other than the first one */
if|if
condition|(
name|frag_off
operator|>
literal|0
condition|)
block|{
comment|/* This is the first attempt at writing out this fragment */
if|if
condition|(
name|s
operator|->
name|init_off
operator|<=
name|DTLS1_HM_HEADER_LENGTH
condition|)
block|{
comment|/*                      * Each fragment that was already sent must at least have                      * contained the message header plus one other byte.                      * Therefore |init_off| must have progressed by at least                      * |DTLS1_HM_HEADER_LENGTH + 1| bytes. If not something went                      * wrong.                      */
return|return
operator|-
literal|1
return|;
block|}
comment|/*                  * Adjust |init_off| and |init_num| to allow room for a new                  * message header for this fragment.                  */
name|s
operator|->
name|init_off
operator|-=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|s
operator|->
name|init_num
operator|+=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
block|}
else|else
block|{
comment|/*                  * We must have been called again after a retry so use the                  * fragment offset from our last attempt. We do not need                  * to adjust |init_off| and |init_num| as above, because                  * that should already have been done before the retry.                  */
name|frag_off
operator|=
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|frag_off
expr_stmt|;
block|}
block|}
name|used_len
operator|=
name|BIO_wpending
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|)
operator|+
name|DTLS1_RT_HEADER_LENGTH
operator|+
name|mac_size
operator|+
name|blocksize
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|mtu
operator|>
name|used_len
condition|)
name|curr_mtu
operator|=
name|s
operator|->
name|d1
operator|->
name|mtu
operator|-
name|used_len
expr_stmt|;
else|else
name|curr_mtu
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curr_mtu
operator|<=
name|DTLS1_HM_HEADER_LENGTH
condition|)
block|{
comment|/*              * grr.. we could get an error if MTU picked was wrong              */
name|ret
operator|=
name|BIO_flush
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
block|{
name|s
operator|->
name|rwstate
operator|=
name|SSL_WRITING
expr_stmt|;
return|return
name|ret
return|;
block|}
name|used_len
operator|=
name|DTLS1_RT_HEADER_LENGTH
operator|+
name|mac_size
operator|+
name|blocksize
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|mtu
operator|>
name|used_len
operator|+
name|DTLS1_HM_HEADER_LENGTH
condition|)
block|{
name|curr_mtu
operator|=
name|s
operator|->
name|d1
operator|->
name|mtu
operator|-
name|used_len
expr_stmt|;
block|}
else|else
block|{
comment|/* Shouldn't happen */
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/*          * We just checked that s->init_num> 0 so this cast should be safe          */
if|if
condition|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|init_num
operator|)
operator|>
name|curr_mtu
condition|)
name|len
operator|=
name|curr_mtu
expr_stmt|;
else|else
name|len
operator|=
name|s
operator|->
name|init_num
expr_stmt|;
comment|/* Shouldn't ever happen */
if|if
condition|(
name|len
operator|>
name|INT_MAX
condition|)
name|len
operator|=
name|INT_MAX
expr_stmt|;
comment|/*          * XDTLS: this function is too long.  split out the CCS part          */
if|if
condition|(
name|type
operator|==
name|SSL3_RT_HANDSHAKE
condition|)
block|{
if|if
condition|(
name|len
operator|<
name|DTLS1_HM_HEADER_LENGTH
condition|)
block|{
comment|/*                  * len is so small that we really can't do anything sensible                  * so fail                  */
return|return
operator|-
literal|1
return|;
block|}
name|dtls1_fix_message_header
argument_list|(
name|s
argument_list|,
name|frag_off
argument_list|,
name|len
operator|-
name|DTLS1_HM_HEADER_LENGTH
argument_list|)
expr_stmt|;
name|dtls1_write_message_header
argument_list|(
name|s
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|s
operator|->
name|init_buf
operator|->
name|data
index|[
name|s
operator|->
name|init_off
index|]
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|dtls1_write_bytes
argument_list|(
name|s
argument_list|,
name|type
argument_list|,
operator|&
name|s
operator|->
name|init_buf
operator|->
name|data
index|[
name|s
operator|->
name|init_off
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/*              * might need to update MTU here, but we don't know which              * previous packet caused the failure -- so can't really              * retransmit anything.  continue as if everything is fine and              * wait for an alert to handle the retransmit              */
if|if
condition|(
name|retry
operator|&&
name|BIO_ctrl
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_CTRL_DGRAM_MTU_EXCEEDED
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|SSL_get_options
argument_list|(
name|s
argument_list|)
operator|&
name|SSL_OP_NO_QUERY_MTU
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|dtls1_query_mtu
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Have one more go */
name|retry
operator|=
literal|0
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/*              * bad if this assert fails, only part of the handshake message              * got sent.  but why would this happen?              */
name|OPENSSL_assert
argument_list|(
name|len
operator|==
operator|(
name|unsigned
name|int
operator|)
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SSL3_RT_HANDSHAKE
operator|&&
operator|!
name|s
operator|->
name|d1
operator|->
name|retransmitting
condition|)
block|{
comment|/*                  * should not be done for 'Hello Request's, but in that case                  * we'll ignore the result anyway                  */
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|s
operator|->
name|init_buf
operator|->
name|data
index|[
name|s
operator|->
name|init_off
index|]
decl_stmt|;
specifier|const
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
init|=
operator|&
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
decl_stmt|;
name|int
name|xlen
decl_stmt|;
if|if
condition|(
name|frag_off
operator|==
literal|0
operator|&&
name|s
operator|->
name|version
operator|!=
name|DTLS1_BAD_VER
condition|)
block|{
comment|/*                      * reconstruct message header is if it is being sent in                      * single fragment                      */
operator|*
name|p
operator|++
operator|=
name|msg_hdr
operator|->
name|type
expr_stmt|;
name|l2n3
argument_list|(
name|msg_hdr
operator|->
name|msg_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|msg_hdr
operator|->
name|seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
name|msg_hdr
operator|->
name|msg_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|-=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|xlen
operator|=
name|ret
expr_stmt|;
block|}
else|else
block|{
name|p
operator|+=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|xlen
operator|=
name|ret
operator|-
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
block|}
name|ssl3_finish_mac
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|xlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|s
operator|->
name|init_num
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|1
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|type
argument_list|,
name|s
operator|->
name|init_buf
operator|->
name|data
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|s
operator|->
name|init_off
operator|+
name|s
operator|->
name|init_num
argument_list|)
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
comment|/* done writing this message */
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|s
operator|->
name|init_off
operator|+=
name|ret
expr_stmt|;
name|s
operator|->
name|init_num
operator|-=
name|ret
expr_stmt|;
name|ret
operator|-=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|frag_off
operator|+=
name|ret
expr_stmt|;
comment|/*              * We save the fragment offset for the next fragment so we have it              * available in case of an IO retry. We don't know the length of the              * next fragment yet so just set that to 0 for now. It will be              * updated again later.              */
name|dtls1_fix_message_header
argument_list|(
name|s
argument_list|,
name|frag_off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Obtain handshake message of message type 'mt' (any if mt == -1), maximum  * acceptable body length 'max'. Read an entire handshake message.  Handshake  * messages arrive in fragments.  */
end_comment

begin_function
name|long
name|dtls1_get_message
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|st1
parameter_list|,
name|int
name|stn
parameter_list|,
name|int
name|mt
parameter_list|,
name|long
name|max
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|al
decl_stmt|;
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|msg_len
decl_stmt|;
comment|/*      * s3->tmp is used to store messages that are unexpected, caused by the      * absence of an optional handshake message      */
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|reuse_message
condition|)
block|{
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|reuse_message
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|mt
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|!=
name|mt
operator|)
condition|)
block|{
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_GET_MESSAGE
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
operator|*
name|ok
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|init_msg
operator|=
name|s
operator|->
name|init_buf
operator|->
name|data
operator|+
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
operator|(
name|int
operator|)
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_size
expr_stmt|;
return|return
name|s
operator|->
name|init_num
return|;
block|}
name|msg_hdr
operator|=
operator|&
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
expr_stmt|;
name|memset
argument_list|(
name|msg_hdr
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hm_header_st
argument_list|)
argument_list|)
expr_stmt|;
name|again
label|:
name|i
operator|=
name|dtls1_get_message_fragment
argument_list|(
name|s
argument_list|,
name|st1
argument_list|,
name|stn
argument_list|,
name|max
argument_list|,
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|DTLS1_HM_BAD_FRAGMENT
operator|||
name|i
operator|==
name|DTLS1_HM_FRAGMENT_RETRY
condition|)
block|{
comment|/* bad fragment received */
goto|goto
name|again
goto|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<=
literal|0
operator|&&
operator|!
operator|*
name|ok
condition|)
block|{
return|return
name|i
return|;
block|}
comment|/*      * Don't change the *message* read sequence number while listening. For      * the *record* write sequence we reflect the ClientHello sequence number      * when listening.      */
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|listen
condition|)
name|memcpy
argument_list|(
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|,
name|s
operator|->
name|s3
operator|->
name|read_sequence
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
operator|++
expr_stmt|;
if|if
condition|(
name|mt
operator|>=
literal|0
operator|&&
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|!=
name|mt
condition|)
block|{
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_GET_MESSAGE
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
name|msg_len
operator|=
name|msg_hdr
operator|->
name|msg_len
expr_stmt|;
comment|/* reconstruct message header */
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|msg_hdr
operator|->
name|type
expr_stmt|;
name|l2n3
argument_list|(
name|msg_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|msg_hdr
operator|->
name|seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
name|msg_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|version
operator|!=
name|DTLS1_BAD_VER
condition|)
block|{
name|p
operator|-=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|msg_len
operator|+=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
block|}
name|ssl3_finish_mac
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|0
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|p
argument_list|,
name|msg_len
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|msg_hdr
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hm_header_st
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_msg
operator|=
name|s
operator|->
name|init_buf
operator|->
name|data
operator|+
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
return|return
name|s
operator|->
name|init_num
return|;
name|f_err
label|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtls1_preprocess_fragment
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|size_t
name|frag_off
decl_stmt|,
name|frag_len
decl_stmt|,
name|msg_len
decl_stmt|;
name|msg_len
operator|=
name|msg_hdr
operator|->
name|msg_len
expr_stmt|;
name|frag_off
operator|=
name|msg_hdr
operator|->
name|frag_off
expr_stmt|;
name|frag_len
operator|=
name|msg_hdr
operator|->
name|frag_len
expr_stmt|;
comment|/* sanity checking */
if|if
condition|(
operator|(
name|frag_off
operator|+
name|frag_len
operator|)
operator|>
name|msg_len
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_PREPROCESS_FRAGMENT
argument_list|,
name|SSL_R_EXCESSIVE_MESSAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|SSL_AD_ILLEGAL_PARAMETER
return|;
block|}
if|if
condition|(
operator|(
name|frag_off
operator|+
name|frag_len
operator|)
operator|>
operator|(
name|unsigned
name|long
operator|)
name|max
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_PREPROCESS_FRAGMENT
argument_list|,
name|SSL_R_EXCESSIVE_MESSAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|SSL_AD_ILLEGAL_PARAMETER
return|;
block|}
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|frag_off
operator|==
literal|0
condition|)
block|{
comment|/* first fragment */
comment|/*          * msg_len is limited to 2^24, but is effectively checked against max          * above          *          * Make buffer slightly larger than message length as a precaution          * against small OOB reads e.g. CVE-2016-6306          */
if|if
condition|(
operator|!
name|BUF_MEM_grow_clean
argument_list|(
name|s
operator|->
name|init_buf
argument_list|,
name|msg_len
operator|+
name|DTLS1_HM_HEADER_LENGTH
operator|+
literal|16
argument_list|)
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_PREPROCESS_FRAGMENT
argument_list|,
name|ERR_R_BUF_LIB
argument_list|)
expr_stmt|;
return|return
name|SSL_AD_INTERNAL_ERROR
return|;
block|}
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_size
operator|=
name|msg_len
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|msg_len
operator|=
name|msg_len
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|tmp
operator|.
name|message_type
operator|=
name|msg_hdr
operator|->
name|type
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|type
operator|=
name|msg_hdr
operator|->
name|type
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|seq
operator|=
name|msg_hdr
operator|->
name|seq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msg_len
operator|!=
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|msg_len
condition|)
block|{
comment|/*          * They must be playing with us! BTW, failure to enforce upper limit          * would open possibility for buffer overrun.          */
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_PREPROCESS_FRAGMENT
argument_list|,
name|SSL_R_EXCESSIVE_MESSAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|SSL_AD_ILLEGAL_PARAMETER
return|;
block|}
return|return
literal|0
return|;
comment|/* no error */
block|}
end_function

begin_function
specifier|static
name|int
name|dtls1_retrieve_buffered_fragment
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|long
name|max
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
block|{
comment|/*-      * (0) check whether the desired fragment is available      * if so:      * (1) copy over the fragment to s->init_buf->data[]      * (2) update s->init_num      */
name|pitem
modifier|*
name|item
decl_stmt|;
name|hm_fragment
modifier|*
name|frag
decl_stmt|;
name|int
name|al
decl_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|item
operator|=
name|pqueue_peek
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|frag
operator|=
operator|(
name|hm_fragment
operator|*
operator|)
name|item
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|msg_header
operator|.
name|seq
operator|<
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
condition|)
block|{
comment|/* This is a stale message that has been buffered so clear it */
name|pqueue_pop
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|)
expr_stmt|;
name|dtls1_hm_fragment_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
name|pitem_free
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item
operator|=
name|NULL
expr_stmt|;
name|frag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
do|while
condition|(
name|item
operator|==
name|NULL
condition|)
do|;
comment|/* Don't return if reassembly still in progress */
if|if
condition|(
name|frag
operator|->
name|reassembly
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
operator|==
name|frag
operator|->
name|msg_header
operator|.
name|seq
condition|)
block|{
name|unsigned
name|long
name|frag_len
init|=
name|frag
operator|->
name|msg_header
operator|.
name|frag_len
decl_stmt|;
name|pqueue_pop
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|)
expr_stmt|;
name|al
operator|=
name|dtls1_preprocess_fragment
argument_list|(
name|s
argument_list|,
operator|&
name|frag
operator|->
name|msg_header
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
literal|0
condition|)
block|{
comment|/* no alert */
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
operator|+
name|DTLS1_HM_HEADER_LENGTH
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|p
index|[
name|frag
operator|->
name|msg_header
operator|.
name|frag_off
index|]
argument_list|,
name|frag
operator|->
name|fragment
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|frag_len
argument_list|)
expr_stmt|;
block|}
name|dtls1_hm_fragment_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
name|pitem_free
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
literal|0
condition|)
block|{
operator|*
name|ok
operator|=
literal|1
expr_stmt|;
return|return
name|frag_len
return|;
block|}
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * dtls1_max_handshake_message_len returns the maximum number of bytes  * permitted in a DTLS handshake message for |s|. The minimum is 16KB, but  * may be greater if the maximum certificate list size requires it.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|dtls1_max_handshake_message_len
parameter_list|(
specifier|const
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|long
name|max_len
init|=
name|DTLS1_HM_HEADER_LENGTH
operator|+
name|SSL3_RT_MAX_ENCRYPTED_LENGTH
decl_stmt|;
if|if
condition|(
name|max_len
operator|<
operator|(
name|unsigned
name|long
operator|)
name|s
operator|->
name|max_cert_list
condition|)
return|return
name|s
operator|->
name|max_cert_list
return|;
return|return
name|max_len
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtls1_reassemble_fragment
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
block|{
name|hm_fragment
modifier|*
name|frag
init|=
name|NULL
decl_stmt|;
name|pitem
modifier|*
name|item
init|=
name|NULL
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|,
name|is_complete
decl_stmt|;
name|unsigned
name|char
name|seq64be
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|long
name|frag_len
init|=
name|msg_hdr
operator|->
name|frag_len
decl_stmt|;
if|if
condition|(
operator|(
name|msg_hdr
operator|->
name|frag_off
operator|+
name|frag_len
operator|)
operator|>
name|msg_hdr
operator|->
name|msg_len
operator|||
name|msg_hdr
operator|->
name|msg_len
operator|>
name|dtls1_max_handshake_message_len
argument_list|(
name|s
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|frag_len
operator|==
literal|0
condition|)
return|return
name|DTLS1_HM_FRAGMENT_RETRY
return|;
comment|/* Try to find item in queue */
name|memset
argument_list|(
name|seq64be
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|seq64be
argument_list|)
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|msg_hdr
operator|->
name|seq
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|7
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|msg_hdr
operator|->
name|seq
expr_stmt|;
name|item
operator|=
name|pqueue_find
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|,
name|seq64be
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|frag
operator|=
name|dtls1_hm_fragment_new
argument_list|(
name|msg_hdr
operator|->
name|msg_len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|memcpy
argument_list|(
operator|&
operator|(
name|frag
operator|->
name|msg_header
operator|)
argument_list|,
name|msg_hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|frag_len
operator|=
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|frag_off
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|frag
operator|=
operator|(
name|hm_fragment
operator|*
operator|)
name|item
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
operator|!=
name|msg_hdr
operator|->
name|msg_len
condition|)
block|{
name|item
operator|=
name|NULL
expr_stmt|;
name|frag
operator|=
name|NULL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
comment|/*      * If message is already reassembled, this must be a retransmit and can      * be dropped. In this case item != NULL and so frag does not need to be      * freed.      */
if|if
condition|(
name|frag
operator|->
name|reassembly
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|char
name|devnull
index|[
literal|256
index|]
decl_stmt|;
while|while
condition|(
name|frag_len
condition|)
block|{
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|devnull
argument_list|,
name|frag_len
operator|>
sizeof|sizeof
argument_list|(
name|devnull
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|devnull
argument_list|)
else|:
name|frag_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
name|frag_len
operator|-=
name|i
expr_stmt|;
block|}
return|return
name|DTLS1_HM_FRAGMENT_RETRY
return|;
block|}
comment|/* read the body of the fragment (header has already been read */
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|frag
operator|->
name|fragment
operator|+
name|msg_hdr
operator|->
name|frag_off
argument_list|,
name|frag_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|i
operator|!=
name|frag_len
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
name|RSMBLY_BITMASK_MARK
argument_list|(
name|frag
operator|->
name|reassembly
argument_list|,
operator|(
name|long
operator|)
name|msg_hdr
operator|->
name|frag_off
argument_list|,
call|(
name|long
call|)
argument_list|(
name|msg_hdr
operator|->
name|frag_off
operator|+
name|frag_len
argument_list|)
argument_list|)
expr_stmt|;
name|RSMBLY_BITMASK_IS_COMPLETE
argument_list|(
name|frag
operator|->
name|reassembly
argument_list|,
operator|(
name|long
operator|)
name|msg_hdr
operator|->
name|msg_len
argument_list|,
name|is_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_complete
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|frag
operator|->
name|reassembly
argument_list|)
expr_stmt|;
name|frag
operator|->
name|reassembly
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|item
operator|=
name|pitem_new
argument_list|(
name|seq64be
argument_list|,
name|frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|item
operator|=
name|pqueue_insert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|,
name|item
argument_list|)
expr_stmt|;
comment|/*          * pqueue_insert fails iff a duplicate item is inserted. However,          * |item| cannot be a duplicate. If it were, |pqueue_find|, above,          * would have returned it and control would never have reached this          * branch.          */
name|OPENSSL_assert
argument_list|(
name|item
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|DTLS1_HM_FRAGMENT_RETRY
return|;
name|err
label|:
if|if
condition|(
name|frag
operator|!=
name|NULL
operator|&&
name|item
operator|==
name|NULL
condition|)
name|dtls1_hm_fragment_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtls1_process_out_of_seq_message
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
specifier|const
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|hm_fragment
modifier|*
name|frag
init|=
name|NULL
decl_stmt|;
name|pitem
modifier|*
name|item
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|seq64be
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|long
name|frag_len
init|=
name|msg_hdr
operator|->
name|frag_len
decl_stmt|;
if|if
condition|(
operator|(
name|msg_hdr
operator|->
name|frag_off
operator|+
name|frag_len
operator|)
operator|>
name|msg_hdr
operator|->
name|msg_len
condition|)
goto|goto
name|err
goto|;
comment|/* Try to find item in queue, to prevent duplicate entries */
name|memset
argument_list|(
name|seq64be
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|seq64be
argument_list|)
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|msg_hdr
operator|->
name|seq
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|7
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|msg_hdr
operator|->
name|seq
expr_stmt|;
name|item
operator|=
name|pqueue_find
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|,
name|seq64be
argument_list|)
expr_stmt|;
comment|/*      * If we already have an entry and this one is a fragment, don't discard      * it and rather try to reassemble it.      */
if|if
condition|(
name|item
operator|!=
name|NULL
operator|&&
name|frag_len
operator|!=
name|msg_hdr
operator|->
name|msg_len
condition|)
name|item
operator|=
name|NULL
expr_stmt|;
comment|/*      * Discard the message if sequence number was already there, is too far      * in the future, already in the queue or if we received a FINISHED      * before the SERVER_HELLO, which then must be a stale retransmit.      */
if|if
condition|(
name|msg_hdr
operator|->
name|seq
operator|<=
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
operator|||
name|msg_hdr
operator|->
name|seq
operator|>
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
operator|+
literal|10
operator|||
name|item
operator|!=
name|NULL
operator|||
operator|(
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
operator|==
literal|0
operator|&&
name|msg_hdr
operator|->
name|type
operator|==
name|SSL3_MT_FINISHED
operator|)
condition|)
block|{
name|unsigned
name|char
name|devnull
index|[
literal|256
index|]
decl_stmt|;
while|while
condition|(
name|frag_len
condition|)
block|{
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|devnull
argument_list|,
name|frag_len
operator|>
sizeof|sizeof
argument_list|(
name|devnull
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|devnull
argument_list|)
else|:
name|frag_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
name|frag_len
operator|-=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|frag_len
operator|!=
name|msg_hdr
operator|->
name|msg_len
condition|)
return|return
name|dtls1_reassemble_fragment
argument_list|(
name|s
argument_list|,
name|msg_hdr
argument_list|,
name|ok
argument_list|)
return|;
if|if
condition|(
name|frag_len
operator|>
name|dtls1_max_handshake_message_len
argument_list|(
name|s
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|frag
operator|=
name|dtls1_hm_fragment_new
argument_list|(
name|frag_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|memcpy
argument_list|(
operator|&
operator|(
name|frag
operator|->
name|msg_header
operator|)
argument_list|,
name|msg_hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag_len
condition|)
block|{
comment|/*              * read the body of the fragment (header has already been read              */
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|frag
operator|->
name|fragment
argument_list|,
name|frag_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|i
operator|!=
name|frag_len
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
name|item
operator|=
name|pitem_new
argument_list|(
name|seq64be
argument_list|,
name|frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|item
operator|=
name|pqueue_insert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|buffered_messages
argument_list|,
name|item
argument_list|)
expr_stmt|;
comment|/*          * pqueue_insert fails iff a duplicate item is inserted. However,          * |item| cannot be a duplicate. If it were, |pqueue_find|, above,          * would have returned it. Then, either |frag_len| !=          * |msg_hdr->msg_len| in which case |item| is set to NULL and it will          * have been processed with |dtls1_reassemble_fragment|, above, or          * the record will have been discarded.          */
name|OPENSSL_assert
argument_list|(
name|item
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|DTLS1_HM_FRAGMENT_RETRY
return|;
name|err
label|:
if|if
condition|(
name|frag
operator|!=
name|NULL
operator|&&
name|item
operator|==
name|NULL
condition|)
name|dtls1_hm_fragment_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|dtls1_get_message_fragment
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|st1
parameter_list|,
name|int
name|stn
parameter_list|,
name|long
name|max
parameter_list|,
name|int
modifier|*
name|ok
parameter_list|)
block|{
name|unsigned
name|char
name|wire
index|[
name|DTLS1_HM_HEADER_LENGTH
index|]
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|,
name|frag_off
decl_stmt|,
name|frag_len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|al
decl_stmt|;
name|struct
name|hm_header_st
name|msg_hdr
decl_stmt|;
name|redo
label|:
comment|/* see if we have the required fragment already */
if|if
condition|(
operator|(
name|frag_len
operator|=
name|dtls1_retrieve_buffered_fragment
argument_list|(
name|s
argument_list|,
name|max
argument_list|,
name|ok
argument_list|)
operator|)
operator|||
operator|*
name|ok
condition|)
block|{
if|if
condition|(
operator|*
name|ok
condition|)
name|s
operator|->
name|init_num
operator|=
name|frag_len
expr_stmt|;
return|return
name|frag_len
return|;
block|}
comment|/* read handshake message header */
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|wire
argument_list|,
name|DTLS1_HM_HEADER_LENGTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
comment|/* nbio, or an error */
name|s
operator|->
name|rwstate
operator|=
name|SSL_READING
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
comment|/* Handshake fails if message header is incomplete */
if|if
condition|(
name|i
operator|!=
name|DTLS1_HM_HEADER_LENGTH
condition|)
block|{
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_GET_MESSAGE_FRAGMENT
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
comment|/* parse the message fragment header */
name|dtls1_get_message_header
argument_list|(
name|wire
argument_list|,
operator|&
name|msg_hdr
argument_list|)
expr_stmt|;
name|len
operator|=
name|msg_hdr
operator|.
name|msg_len
expr_stmt|;
name|frag_off
operator|=
name|msg_hdr
operator|.
name|frag_off
expr_stmt|;
name|frag_len
operator|=
name|msg_hdr
operator|.
name|frag_len
expr_stmt|;
comment|/*      * We must have at least frag_len bytes left in the record to be read.      * Fragments must not span records.      */
if|if
condition|(
name|frag_len
operator|>
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|length
condition|)
block|{
name|al
operator|=
name|SSL3_AD_ILLEGAL_PARAMETER
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_GET_MESSAGE_FRAGMENT
argument_list|,
name|SSL_R_BAD_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
comment|/*      * if this is a future (or stale) message it gets buffered      * (or dropped)--no further processing at this time      * While listening, we accept seq 1 (ClientHello with cookie)      * although we're still expecting seq 0 (ClientHello)      */
if|if
condition|(
name|msg_hdr
operator|.
name|seq
operator|!=
name|s
operator|->
name|d1
operator|->
name|handshake_read_seq
operator|&&
operator|!
operator|(
name|s
operator|->
name|d1
operator|->
name|listen
operator|&&
name|msg_hdr
operator|.
name|seq
operator|==
literal|1
operator|)
condition|)
return|return
name|dtls1_process_out_of_seq_message
argument_list|(
name|s
argument_list|,
operator|&
name|msg_hdr
argument_list|,
name|ok
argument_list|)
return|;
if|if
condition|(
name|frag_len
operator|&&
name|frag_len
operator|<
name|len
condition|)
return|return
name|dtls1_reassemble_fragment
argument_list|(
name|s
argument_list|,
operator|&
name|msg_hdr
argument_list|,
name|ok
argument_list|)
return|;
if|if
condition|(
operator|!
name|s
operator|->
name|server
operator|&&
name|s
operator|->
name|d1
operator|->
name|r_msg_hdr
operator|.
name|frag_off
operator|==
literal|0
operator|&&
name|wire
index|[
literal|0
index|]
operator|==
name|SSL3_MT_HELLO_REQUEST
condition|)
block|{
comment|/*          * The server may always send 'Hello Request' messages -- we are          * doing a handshake anyway now, so ignore them if their format is          * correct. Does not count for 'Finished' MAC.          */
if|if
condition|(
name|wire
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|wire
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|wire
index|[
literal|3
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|0
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
name|wire
argument_list|,
name|DTLS1_HM_HEADER_LENGTH
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
goto|goto
name|redo
goto|;
block|}
else|else
block|{
comment|/* Incorrectly formated Hello request */
name|al
operator|=
name|SSL_AD_UNEXPECTED_MESSAGE
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_GET_MESSAGE_FRAGMENT
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|al
operator|=
name|dtls1_preprocess_fragment
argument_list|(
name|s
argument_list|,
operator|&
name|msg_hdr
argument_list|,
name|max
argument_list|)
operator|)
condition|)
goto|goto
name|f_err
goto|;
if|if
condition|(
name|frag_len
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
operator|+
name|DTLS1_HM_HEADER_LENGTH
decl_stmt|;
name|i
operator|=
name|s
operator|->
name|method
operator|->
name|ssl_read_bytes
argument_list|(
name|s
argument_list|,
name|SSL3_RT_HANDSHAKE
argument_list|,
operator|&
name|p
index|[
name|frag_off
index|]
argument_list|,
name|frag_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*          * This shouldn't ever fail due to NBIO because we already checked          * that we have enough data in the record          */
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|s
operator|->
name|rwstate
operator|=
name|SSL_READING
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
comment|/*      * XDTLS: an incorrectly formatted fragment should cause the handshake      * to fail      */
if|if
condition|(
name|i
operator|!=
operator|(
name|int
operator|)
name|frag_len
condition|)
block|{
name|al
operator|=
name|SSL3_AD_ILLEGAL_PARAMETER
expr_stmt|;
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_GET_MESSAGE_FRAGMENT
argument_list|,
name|SSL3_AD_ILLEGAL_PARAMETER
argument_list|)
expr_stmt|;
goto|goto
name|f_err
goto|;
block|}
operator|*
name|ok
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|stn
expr_stmt|;
comment|/*      * Note that s->init_num is *not* used as current offset in      * s->init_buf->data, but as a counter summing up fragments' lengths: as      * soon as they sum up to handshake packet length, we assume we have got      * all the fragments.      */
name|s
operator|->
name|init_num
operator|=
name|frag_len
expr_stmt|;
return|return
name|frag_len
return|;
name|f_err
label|:
name|ssl3_send_alert
argument_list|(
name|s
argument_list|,
name|SSL3_AL_FATAL
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
literal|0
expr_stmt|;
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * for these 2 messages, we need to  * ssl->enc_read_ctx                    re-init  * ssl->s3->read_sequence               zero  * ssl->s3->read_mac_secret             re-init  * ssl->session->read_sym_enc           assign  * ssl->session->read_compression       assign  * ssl->session->read_hash              assign  */
end_comment

begin_function
name|int
name|dtls1_send_change_cipher_spec
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|a
condition|)
block|{
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|->
name|init_buf
operator|->
name|data
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SSL3_MT_CCS
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|handshake_write_seq
operator|=
name|s
operator|->
name|d1
operator|->
name|next_handshake_write_seq
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
name|DTLS1_CCS_HEADER_LENGTH
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|version
operator|==
name|DTLS1_BAD_VER
condition|)
block|{
name|s
operator|->
name|d1
operator|->
name|next_handshake_write_seq
operator|++
expr_stmt|;
name|s2n
argument_list|(
name|s
operator|->
name|d1
operator|->
name|handshake_write_seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|+=
literal|2
expr_stmt|;
block|}
name|s
operator|->
name|init_off
operator|=
literal|0
expr_stmt|;
name|dtls1_set_message_header_int
argument_list|(
name|s
argument_list|,
name|SSL3_MT_CCS
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|d1
operator|->
name|handshake_write_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* buffer the message to handle re-xmits */
name|dtls1_buffer_message
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|b
expr_stmt|;
block|}
comment|/* SSL3_ST_CW_CHANGE_B */
return|return
operator|(
name|dtls1_do_write
argument_list|(
name|s
argument_list|,
name|SSL3_RT_CHANGE_CIPHER_SPEC
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtls1_read_failed
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|code
parameter_list|)
block|{
if|if
condition|(
name|code
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TLS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid state reached %s:%d"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|dtls1_is_timer_expired
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/*          * not a timeout, none of our business, let higher layers handle          * this.  in fact it's probably an error          */
return|return
name|code
return|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
comment|/* done, no need to send a retransmit */
if|if
condition|(
operator|!
name|SSL_in_init
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|s
operator|->
name|tlsext_hb_pending
condition|)
else|#
directive|else
comment|/* done, no need to send a retransmit */
if|if
condition|(
operator|!
name|SSL_in_init
argument_list|(
name|s
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|BIO_set_flags
argument_list|(
name|SSL_get_rbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_FLAGS_READ
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
if|#
directive|if
literal|0
comment|/* for now, each alert contains only one                                  * record number */
block|item = pqueue_peek(state->rcvd_records);     if (item) {
comment|/* send an alert immediately for all the missing records */
block|} else
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* no more alert sending, just retransmit the                                  * last set of messages */
block|if (state->timeout.read_timeouts>= DTLS1_TMO_READ_COUNT)         ssl3_send_alert(s, SSL3_AL_WARNING,                         DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
endif|#
directive|endif
return|return
name|dtls1_handle_timeout
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|dtls1_get_queue_priority
parameter_list|(
name|unsigned
name|short
name|seq
parameter_list|,
name|int
name|is_ccs
parameter_list|)
block|{
comment|/*      * The index of the retransmission queue actually is the message sequence      * number, since the queue only contains messages of a single handshake.      * However, the ChangeCipherSpec has no message sequence number and so      * using only the sequence will result in the CCS and Finished having the      * same index. To prevent this, the sequence number is multiplied by 2.      * In case of a CCS 1 is subtracted. This does not only differ CSS and      * Finished, it also maintains the order of the index (important for      * priority queues) and fits in the unsigned short variable.      */
return|return
name|seq
operator|*
literal|2
operator|-
name|is_ccs
return|;
block|}
end_function

begin_function
name|int
name|dtls1_retransmit_buffered_messages
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|pqueue
name|sent
init|=
name|s
operator|->
name|d1
operator|->
name|sent_messages
decl_stmt|;
name|piterator
name|iter
decl_stmt|;
name|pitem
modifier|*
name|item
decl_stmt|;
name|hm_fragment
modifier|*
name|frag
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|iter
operator|=
name|pqueue_iterator
argument_list|(
name|sent
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|pqueue_next
argument_list|(
operator|&
name|iter
argument_list|)
init|;
name|item
operator|!=
name|NULL
condition|;
name|item
operator|=
name|pqueue_next
argument_list|(
operator|&
name|iter
argument_list|)
control|)
block|{
name|frag
operator|=
operator|(
name|hm_fragment
operator|*
operator|)
name|item
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|dtls1_retransmit_message
argument_list|(
name|s
argument_list|,
operator|(
name|unsigned
name|short
operator|)
name|dtls1_get_queue_priority
argument_list|(
name|frag
operator|->
name|msg_header
operator|.
name|seq
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|found
argument_list|)
operator|<=
literal|0
operator|&&
name|found
condition|)
block|{
ifdef|#
directive|ifdef
name|TLS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dtls1_retransmit_message() failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|dtls1_buffer_message
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|is_ccs
parameter_list|)
block|{
name|pitem
modifier|*
name|item
decl_stmt|;
name|hm_fragment
modifier|*
name|frag
decl_stmt|;
name|unsigned
name|char
name|seq64be
index|[
literal|8
index|]
decl_stmt|;
comment|/*      * this function is called immediately after a message has been      * serialized      */
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|init_off
operator|==
literal|0
argument_list|)
expr_stmt|;
name|frag
operator|=
name|dtls1_hm_fragment_new
argument_list|(
name|s
operator|->
name|init_num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frag
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|frag
operator|->
name|fragment
argument_list|,
name|s
operator|->
name|init_buf
operator|->
name|data
argument_list|,
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ccs
condition|)
block|{
comment|/* For DTLS1_BAD_VER the header length is non-standard */
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|msg_len
operator|+
operator|(
operator|(
name|s
operator|->
name|version
operator|==
name|DTLS1_BAD_VER
operator|)
condition|?
literal|3
else|:
name|DTLS1_CCS_HEADER_LENGTH
operator|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OPENSSL_assert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|msg_len
operator|+
name|DTLS1_HM_HEADER_LENGTH
operator|==
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|init_num
argument_list|)
expr_stmt|;
block|}
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
operator|=
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|msg_len
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|seq
operator|=
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|seq
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|type
operator|=
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|type
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|frag_off
operator|=
literal|0
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|frag_len
operator|=
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
operator|.
name|msg_len
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
operator|=
name|is_ccs
expr_stmt|;
comment|/* save current state */
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|enc_write_ctx
operator|=
name|s
operator|->
name|enc_write_ctx
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|write_hash
operator|=
name|s
operator|->
name|write_hash
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|compress
operator|=
name|s
operator|->
name|compress
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|session
operator|=
name|s
operator|->
name|session
expr_stmt|;
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|epoch
operator|=
name|s
operator|->
name|d1
operator|->
name|w_epoch
expr_stmt|;
name|memset
argument_list|(
name|seq64be
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|seq64be
argument_list|)
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|dtls1_get_queue_priority
argument_list|(
name|frag
operator|->
name|msg_header
operator|.
name|seq
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
argument_list|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|7
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|dtls1_get_queue_priority
argument_list|(
name|frag
operator|->
name|msg_header
operator|.
name|seq
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|pitem_new
argument_list|(
name|seq64be
argument_list|,
name|frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|dtls1_hm_fragment_free
argument_list|(
name|frag
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
literal|0
block|fprintf(stderr, "buffered messge: \ttype = %xx\n", msg_buf->type);     fprintf(stderr, "\t\t\t\t\tlen = %d\n", msg_buf->len);     fprintf(stderr, "\t\t\t\t\tseq_num = %d\n", msg_buf->seq_num);
endif|#
directive|endif
name|pqueue_insert
argument_list|(
name|s
operator|->
name|d1
operator|->
name|sent_messages
argument_list|,
name|item
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|dtls1_retransmit_message
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|short
name|seq
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|int
modifier|*
name|found
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* XDTLS: for now assuming that read/writes are blocking */
name|pitem
modifier|*
name|item
decl_stmt|;
name|hm_fragment
modifier|*
name|frag
decl_stmt|;
name|unsigned
name|long
name|header_length
decl_stmt|;
name|unsigned
name|char
name|seq64be
index|[
literal|8
index|]
decl_stmt|;
name|struct
name|dtls1_retransmit_state
name|saved_state
decl_stmt|;
name|unsigned
name|char
name|save_write_sequence
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/*-       OPENSSL_assert(s->init_num == 0);       OPENSSL_assert(s->init_off == 0);      */
comment|/* XDTLS:  the requested message ought to be found, otherwise error */
name|memset
argument_list|(
name|seq64be
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|seq64be
argument_list|)
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|seq
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|seq64be
index|[
literal|7
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|seq
expr_stmt|;
name|item
operator|=
name|pqueue_find
argument_list|(
name|s
operator|->
name|d1
operator|->
name|sent_messages
argument_list|,
name|seq64be
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|TLS_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"retransmit:  message %d non-existant\n"
argument_list|,
name|seq
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|found
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|found
operator|=
literal|1
expr_stmt|;
name|frag
operator|=
operator|(
name|hm_fragment
operator|*
operator|)
name|item
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
condition|)
name|header_length
operator|=
name|DTLS1_CCS_HEADER_LENGTH
expr_stmt|;
else|else
name|header_length
operator|=
name|DTLS1_HM_HEADER_LENGTH
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|init_buf
operator|->
name|data
argument_list|,
name|frag
operator|->
name|fragment
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
operator|+
name|header_length
argument_list|)
expr_stmt|;
name|s
operator|->
name|init_num
operator|=
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
operator|+
name|header_length
expr_stmt|;
name|dtls1_set_message_header_int
argument_list|(
name|s
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|type
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|msg_len
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|seq
argument_list|,
literal|0
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|frag_len
argument_list|)
expr_stmt|;
comment|/* save current state */
name|saved_state
operator|.
name|enc_write_ctx
operator|=
name|s
operator|->
name|enc_write_ctx
expr_stmt|;
name|saved_state
operator|.
name|write_hash
operator|=
name|s
operator|->
name|write_hash
expr_stmt|;
name|saved_state
operator|.
name|compress
operator|=
name|s
operator|->
name|compress
expr_stmt|;
name|saved_state
operator|.
name|session
operator|=
name|s
operator|->
name|session
expr_stmt|;
name|saved_state
operator|.
name|epoch
operator|=
name|s
operator|->
name|d1
operator|->
name|w_epoch
expr_stmt|;
name|saved_state
operator|.
name|epoch
operator|=
name|s
operator|->
name|d1
operator|->
name|w_epoch
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|retransmitting
operator|=
literal|1
expr_stmt|;
comment|/* restore state in which the message was originally sent */
name|s
operator|->
name|enc_write_ctx
operator|=
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|enc_write_ctx
expr_stmt|;
name|s
operator|->
name|write_hash
operator|=
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|write_hash
expr_stmt|;
name|s
operator|->
name|compress
operator|=
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|compress
expr_stmt|;
name|s
operator|->
name|session
operator|=
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|session
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|w_epoch
operator|=
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|epoch
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|epoch
operator|==
name|saved_state
operator|.
name|epoch
operator|-
literal|1
condition|)
block|{
name|memcpy
argument_list|(
name|save_write_sequence
argument_list|,
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|,
name|s
operator|->
name|d1
operator|->
name|last_write_sequence
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|dtls1_do_write
argument_list|(
name|s
argument_list|,
name|frag
operator|->
name|msg_header
operator|.
name|is_ccs
condition|?
name|SSL3_RT_CHANGE_CIPHER_SPEC
else|:
name|SSL3_RT_HANDSHAKE
argument_list|)
expr_stmt|;
comment|/* restore current state */
name|s
operator|->
name|enc_write_ctx
operator|=
name|saved_state
operator|.
name|enc_write_ctx
expr_stmt|;
name|s
operator|->
name|write_hash
operator|=
name|saved_state
operator|.
name|write_hash
expr_stmt|;
name|s
operator|->
name|compress
operator|=
name|saved_state
operator|.
name|compress
expr_stmt|;
name|s
operator|->
name|session
operator|=
name|saved_state
operator|.
name|session
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|w_epoch
operator|=
name|saved_state
operator|.
name|epoch
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|msg_header
operator|.
name|saved_retransmit_state
operator|.
name|epoch
operator|==
name|saved_state
operator|.
name|epoch
operator|-
literal|1
condition|)
block|{
name|memcpy
argument_list|(
name|s
operator|->
name|d1
operator|->
name|last_write_sequence
argument_list|,
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|,
name|save_write_sequence
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|s3
operator|->
name|write_sequence
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|d1
operator|->
name|retransmitting
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|BIO_flush
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
name|dtls1_set_message_header
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
name|mt
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|unsigned
name|long
name|frag_len
parameter_list|)
block|{
comment|/* Don't change sequence numbers while listening */
if|if
condition|(
name|frag_off
operator|==
literal|0
operator|&&
operator|!
name|s
operator|->
name|d1
operator|->
name|listen
condition|)
block|{
name|s
operator|->
name|d1
operator|->
name|handshake_write_seq
operator|=
name|s
operator|->
name|d1
operator|->
name|next_handshake_write_seq
expr_stmt|;
name|s
operator|->
name|d1
operator|->
name|next_handshake_write_seq
operator|++
expr_stmt|;
block|}
name|dtls1_set_message_header_int
argument_list|(
name|s
argument_list|,
name|mt
argument_list|,
name|len
argument_list|,
name|s
operator|->
name|d1
operator|->
name|handshake_write_seq
argument_list|,
name|frag_off
argument_list|,
name|frag_len
argument_list|)
expr_stmt|;
return|return
name|p
operator|+=
name|DTLS1_HM_HEADER_LENGTH
return|;
block|}
end_function

begin_comment
comment|/* don't actually do the writing, wait till the MTU has been retrieved */
end_comment

begin_function
specifier|static
name|void
name|dtls1_set_message_header_int
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
name|mt
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|unsigned
name|short
name|seq_num
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|unsigned
name|long
name|frag_len
parameter_list|)
block|{
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
init|=
operator|&
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
decl_stmt|;
name|msg_hdr
operator|->
name|type
operator|=
name|mt
expr_stmt|;
name|msg_hdr
operator|->
name|msg_len
operator|=
name|len
expr_stmt|;
name|msg_hdr
operator|->
name|seq
operator|=
name|seq_num
expr_stmt|;
name|msg_hdr
operator|->
name|frag_off
operator|=
name|frag_off
expr_stmt|;
name|msg_hdr
operator|->
name|frag_len
operator|=
name|frag_len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtls1_fix_message_header
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|long
name|frag_off
parameter_list|,
name|unsigned
name|long
name|frag_len
parameter_list|)
block|{
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
init|=
operator|&
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
decl_stmt|;
name|msg_hdr
operator|->
name|frag_off
operator|=
name|frag_off
expr_stmt|;
name|msg_hdr
operator|->
name|frag_len
operator|=
name|frag_len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|dtls1_write_message_header
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
init|=
operator|&
name|s
operator|->
name|d1
operator|->
name|w_msg_hdr
decl_stmt|;
operator|*
name|p
operator|++
operator|=
name|msg_hdr
operator|->
name|type
expr_stmt|;
name|l2n3
argument_list|(
name|msg_hdr
operator|->
name|msg_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s2n
argument_list|(
name|msg_hdr
operator|->
name|seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
name|msg_hdr
operator|->
name|frag_off
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l2n3
argument_list|(
name|msg_hdr
operator|->
name|frag_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dtls1_link_min_mtu
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|g_probable_mtu
index|[
operator|(
sizeof|sizeof
argument_list|(
name|g_probable_mtu
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|g_probable_mtu
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dtls1_min_mtu
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
return|return
name|dtls1_link_min_mtu
argument_list|()
operator|-
name|BIO_dgram_get_mtu_overhead
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|dtls1_get_message_header
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|hm_header_st
modifier|*
name|msg_hdr
parameter_list|)
block|{
name|memset
argument_list|(
name|msg_hdr
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hm_header_st
argument_list|)
argument_list|)
expr_stmt|;
name|msg_hdr
operator|->
name|type
operator|=
operator|*
operator|(
name|data
operator|++
operator|)
expr_stmt|;
name|n2l3
argument_list|(
name|data
argument_list|,
name|msg_hdr
operator|->
name|msg_len
argument_list|)
expr_stmt|;
name|n2s
argument_list|(
name|data
argument_list|,
name|msg_hdr
operator|->
name|seq
argument_list|)
expr_stmt|;
name|n2l3
argument_list|(
name|data
argument_list|,
name|msg_hdr
operator|->
name|frag_off
argument_list|)
expr_stmt|;
name|n2l3
argument_list|(
name|data
argument_list|,
name|msg_hdr
operator|->
name|frag_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dtls1_get_ccs_header
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|ccs_header_st
modifier|*
name|ccs_hdr
parameter_list|)
block|{
name|memset
argument_list|(
name|ccs_hdr
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccs_header_st
argument_list|)
argument_list|)
expr_stmt|;
name|ccs_hdr
operator|->
name|type
operator|=
operator|*
operator|(
name|data
operator|++
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dtls1_shutdown
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_SCTP
name|BIO
modifier|*
name|wbio
decl_stmt|;
name|wbio
operator|=
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|wbio
operator|!=
name|NULL
operator|&&
name|BIO_dgram_is_sctp
argument_list|(
name|wbio
argument_list|)
operator|&&
operator|!
operator|(
name|s
operator|->
name|shutdown
operator|&
name|SSL_SENT_SHUTDOWN
operator|)
condition|)
block|{
name|ret
operator|=
name|BIO_dgram_sctp_wait_for_dry
argument_list|(
name|wbio
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|BIO_ctrl
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ret
operator|=
name|ssl3_shutdown
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_SCTP
name|BIO_ctrl
argument_list|(
name|SSL_get_wbio
argument_list|(
name|s
argument_list|)
argument_list|,
name|BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HEARTBEATS
end_ifndef

begin_function
name|int
name|dtls1_process_heartbeat
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|&
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|data
index|[
literal|0
index|]
decl_stmt|,
modifier|*
name|pl
decl_stmt|;
name|unsigned
name|short
name|hbtype
decl_stmt|;
name|unsigned
name|int
name|payload
decl_stmt|;
name|unsigned
name|int
name|padding
init|=
literal|16
decl_stmt|;
comment|/* Use minimum padding */
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|0
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
operator|&
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|data
index|[
literal|0
index|]
argument_list|,
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|length
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
comment|/* Read type and payload length first */
if|if
condition|(
literal|1
operator|+
literal|2
operator|+
literal|16
operator|>
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|length
condition|)
return|return
literal|0
return|;
comment|/* silently discard */
if|if
condition|(
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|length
operator|>
name|SSL3_RT_MAX_PLAIN_LENGTH
condition|)
return|return
literal|0
return|;
comment|/* silently discard per RFC 6520 sec. 4 */
name|hbtype
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|payload
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|+
literal|2
operator|+
name|payload
operator|+
literal|16
operator|>
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|length
condition|)
return|return
literal|0
return|;
comment|/* silently discard per RFC 6520 sec. 4 */
name|pl
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|hbtype
operator|==
name|TLS1_HB_REQUEST
condition|)
block|{
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|unsigned
name|int
name|write_length
init|=
literal|1
comment|/* heartbeat type */
operator|+
literal|2
comment|/* heartbeat length */
operator|+
name|payload
operator|+
name|padding
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|write_length
operator|>
name|SSL3_RT_MAX_PLAIN_LENGTH
condition|)
return|return
literal|0
return|;
comment|/*          * Allocate memory for the response, size is 1 byte message type,          * plus 2 bytes payload length, plus payload, plus padding          */
name|buffer
operator|=
name|OPENSSL_malloc
argument_list|(
name|write_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|bp
operator|=
name|buffer
expr_stmt|;
comment|/* Enter response type, length and copy payload */
operator|*
name|bp
operator|++
operator|=
name|TLS1_HB_RESPONSE
expr_stmt|;
name|s2n
argument_list|(
name|payload
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|pl
argument_list|,
name|payload
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|payload
expr_stmt|;
comment|/* Random padding */
if|if
condition|(
name|RAND_bytes
argument_list|(
name|bp
argument_list|,
name|padding
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|r
operator|=
name|dtls1_write_bytes
argument_list|(
name|s
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buffer
argument_list|,
name|write_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
operator|&&
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|1
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buffer
argument_list|,
name|write_length
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|hbtype
operator|==
name|TLS1_HB_RESPONSE
condition|)
block|{
name|unsigned
name|int
name|seq
decl_stmt|;
comment|/*          * We only send sequence numbers (2 bytes unsigned int), and 16          * random bytes, so we just try to read the sequence number          */
name|n2s
argument_list|(
name|pl
argument_list|,
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|payload
operator|==
literal|18
operator|&&
name|seq
operator|==
name|s
operator|->
name|tlsext_hb_seq
condition|)
block|{
name|dtls1_stop_timer
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|tlsext_hb_seq
operator|++
expr_stmt|;
name|s
operator|->
name|tlsext_hb_pending
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dtls1_heartbeat
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|payload
init|=
literal|18
decl_stmt|;
comment|/* Sequence number + random bytes */
name|unsigned
name|int
name|padding
init|=
literal|16
decl_stmt|;
comment|/* Use minimum padding */
comment|/* Only send if peer supports and accepts HB requests... */
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|tlsext_heartbeat
operator|&
name|SSL_TLSEXT_HB_ENABLED
operator|)
operator|||
name|s
operator|->
name|tlsext_heartbeat
operator|&
name|SSL_TLSEXT_HB_DONT_SEND_REQUESTS
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_HEARTBEAT
argument_list|,
name|SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* ...and there is none in flight yet... */
if|if
condition|(
name|s
operator|->
name|tlsext_hb_pending
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_HEARTBEAT
argument_list|,
name|SSL_R_TLS_HEARTBEAT_PENDING
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* ...and no handshake in progress. */
if|if
condition|(
name|SSL_in_init
argument_list|(
name|s
argument_list|)
operator|||
name|s
operator|->
name|in_handshake
condition|)
block|{
name|SSLerr
argument_list|(
name|SSL_F_DTLS1_HEARTBEAT
argument_list|,
name|SSL_R_UNEXPECTED_MESSAGE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Check if padding is too long, payload and padding must not exceed 2^14      * - 3 = 16381 bytes in total.      */
name|OPENSSL_assert
argument_list|(
name|payload
operator|+
name|padding
operator|<=
literal|16381
argument_list|)
expr_stmt|;
comment|/*-      * Create HeartBeat message, we just use a sequence number      * as payload to distuingish different messages and add      * some random stuff.      *  - Message Type, 1 byte      *  - Payload Length, 2 bytes (unsigned int)      *  - Payload, the sequence number (2 bytes uint)      *  - Payload, random bytes (16 bytes uint)      *  - Padding      */
name|buf
operator|=
name|OPENSSL_malloc
argument_list|(
literal|1
operator|+
literal|2
operator|+
name|payload
operator|+
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|p
operator|=
name|buf
expr_stmt|;
comment|/* Message Type */
operator|*
name|p
operator|++
operator|=
name|TLS1_HB_REQUEST
expr_stmt|;
comment|/* Payload length (18 bytes here) */
name|s2n
argument_list|(
name|payload
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Sequence number */
name|s2n
argument_list|(
name|s
operator|->
name|tlsext_hb_seq
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 16 random bytes */
if|if
condition|(
name|RAND_bytes
argument_list|(
name|p
argument_list|,
literal|16
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
name|p
operator|+=
literal|16
expr_stmt|;
comment|/* Random padding */
if|if
condition|(
name|RAND_bytes
argument_list|(
name|p
argument_list|,
name|padding
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
name|ret
operator|=
name|dtls1_write_bytes
argument_list|(
name|s
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buf
argument_list|,
literal|3
operator|+
name|payload
operator|+
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|msg_callback
condition|)
name|s
operator|->
name|msg_callback
argument_list|(
literal|1
argument_list|,
name|s
operator|->
name|version
argument_list|,
name|TLS1_RT_HEARTBEAT
argument_list|,
name|buf
argument_list|,
literal|3
operator|+
name|payload
operator|+
name|padding
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|msg_callback_arg
argument_list|)
expr_stmt|;
name|dtls1_start_timer
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|tlsext_hb_pending
operator|=
literal|1
expr_stmt|;
block|}
name|err
label|:
name|OPENSSL_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

