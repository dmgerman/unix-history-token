begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/engine/e_gmp.c */
end_comment

begin_comment
comment|/*  * Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL project  * 2003.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1999-2001 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/*  * This engine is not (currently) compiled in by default. Do enable it,  * reconfigure OpenSSL with "enable-gmp -lgmp". The GMP libraries and headers  * must reside in one of the paths searched by the compiler/linker, otherwise  * paths must be specified - eg. try configuring with "enable-gmp  * -I<includepath> -L<libpath> -lgmp". YMMV.  */
end_comment

begin_comment
comment|/*-  * As for what this does - it's a largely unoptimised implementation of an  * ENGINE that uses the GMP library to perform RSA private key operations. To  * obtain more information about what "unoptimised" means, see my original mail  * on the subject (though ignore the build instructions which have since  * changed);  *  *    http://www.mail-archive.com/openssl-dev@openssl.org/msg12227.html  *  * On my athlon system at least, it appears the builtin OpenSSL code is now  * slightly faster, which is to say that the RSA-related MPI performance  * between OpenSSL's BIGNUM and GMP's mpz implementations is probably pretty  * balanced for this chip, and so the performance degradation in this ENGINE by  * having to convert to/from GMP formats (and not being able to cache  * montgomery forms) is probably the difference. However, if some unconfirmed  * reports from users is anything to go by, the situation on some other  * chipsets might be a good deal more favourable to the GMP version (eg. PPC).  * Feedback welcome. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/buffer.h>
end_include

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_include
include|#
directive|include
file|<openssl/rsa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HW
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_GMP
end_ifndef

begin_include
include|#
directive|include
file|<gmp.h>
end_include

begin_define
define|#
directive|define
name|E_GMP_LIB_NAME
value|"gmp engine"
end_define

begin_include
include|#
directive|include
file|"e_gmp_err.c"
end_include

begin_function_decl
specifier|static
name|int
name|e_gmp_destroy
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|e_gmp_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|e_gmp_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|e_gmp_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_comment
comment|/* RSA stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|e_gmp_rsa_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|I
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|e_gmp_rsa_finish
parameter_list|(
name|RSA
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The definitions for control commands specific to this engine */
end_comment

begin_comment
comment|/* #define E_GMP_CMD_SO_PATH            ENGINE_CMD_BASE */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|ENGINE_CMD_DEFN
name|e_gmp_cmd_defns
index|[]
init|=
block|{
if|#
directive|if
literal|0
block|{E_GMP_CMD_SO_PATH,      "SO_PATH",      "Specifies the path to the 'e_gmp' shared library",      ENGINE_CMD_FLAG_STRING},
endif|#
directive|endif
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_comment
comment|/* Our internal RSA_METHOD that we provide pointers to */
end_comment

begin_decl_stmt
specifier|static
name|RSA_METHOD
name|e_gmp_rsa
init|=
block|{
literal|"GMP RSA method"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|e_gmp_rsa_mod_exp
block|,
name|NULL
block|,
name|NULL
block|,
name|e_gmp_rsa_finish
block|,
comment|/*      * These flags initialise montgomery crud that GMP ignores, however it      * makes sure the public key ops (which are done in openssl) don't seem      * *slower* than usual :-)      */
name|RSA_FLAG_CACHE_PUBLIC
operator||
name|RSA_FLAG_CACHE_PRIVATE
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Constants used when creating the ENGINE */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_e_gmp_id
init|=
literal|"gmp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_e_gmp_name
init|=
literal|"GMP engine support"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This internal function is used by ENGINE_gmp() and possibly by the  * "dynamic" ENGINE support too  */
end_comment

begin_function
specifier|static
name|int
name|bind_helper
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
specifier|const
name|RSA_METHOD
modifier|*
name|meth1
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ENGINE_set_id
argument_list|(
name|e
argument_list|,
name|engine_e_gmp_id
argument_list|)
operator|||
operator|!
name|ENGINE_set_name
argument_list|(
name|e
argument_list|,
name|engine_e_gmp_name
argument_list|)
operator|||
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
operator|!
name|ENGINE_set_RSA
argument_list|(
name|e
argument_list|,
operator|&
name|e_gmp_rsa
argument_list|)
operator|||
endif|#
directive|endif
operator|!
name|ENGINE_set_destroy_function
argument_list|(
name|e
argument_list|,
name|e_gmp_destroy
argument_list|)
operator|||
operator|!
name|ENGINE_set_init_function
argument_list|(
name|e
argument_list|,
name|e_gmp_init
argument_list|)
operator|||
operator|!
name|ENGINE_set_finish_function
argument_list|(
name|e
argument_list|,
name|e_gmp_finish
argument_list|)
operator|||
operator|!
name|ENGINE_set_ctrl_function
argument_list|(
name|e
argument_list|,
name|e_gmp_ctrl
argument_list|)
operator|||
operator|!
name|ENGINE_set_cmd_defns
argument_list|(
name|e
argument_list|,
name|e_gmp_cmd_defns
argument_list|)
condition|)
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|meth1
operator|=
name|RSA_PKCS1_SSLeay
argument_list|()
expr_stmt|;
name|e_gmp_rsa
operator|.
name|rsa_pub_enc
operator|=
name|meth1
operator|->
name|rsa_pub_enc
expr_stmt|;
name|e_gmp_rsa
operator|.
name|rsa_pub_dec
operator|=
name|meth1
operator|->
name|rsa_pub_dec
expr_stmt|;
name|e_gmp_rsa
operator|.
name|rsa_priv_enc
operator|=
name|meth1
operator|->
name|rsa_priv_enc
expr_stmt|;
name|e_gmp_rsa
operator|.
name|rsa_priv_dec
operator|=
name|meth1
operator|->
name|rsa_priv_dec
expr_stmt|;
name|e_gmp_rsa
operator|.
name|bn_mod_exp
operator|=
name|meth1
operator|->
name|bn_mod_exp
expr_stmt|;
endif|#
directive|endif
comment|/* Ensure the e_gmp error handling is set up */
name|ERR_load_GMP_strings
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|ENGINE
modifier|*
name|engine_gmp
parameter_list|(
name|void
parameter_list|)
block|{
name|ENGINE
modifier|*
name|ret
init|=
name|ENGINE_new
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|bind_helper
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ENGINE_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|ENGINE_load_gmp
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Copied from eng_[openssl|dyn].c */
name|ENGINE
modifier|*
name|toadd
init|=
name|engine_gmp
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|toadd
condition|)
return|return;
name|ENGINE_add
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ENGINE_free
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_comment
comment|/* Used to attach our own key-data to an RSA structure */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hndidx_rsa
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|e_gmp_destroy
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|ERR_unload_GMP_strings
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* (de)initialisation functions. */
end_comment

begin_function
specifier|static
name|int
name|e_gmp_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|hndidx_rsa
operator|==
operator|-
literal|1
condition|)
name|hndidx_rsa
operator|=
name|RSA_get_ex_new_index
argument_list|(
literal|0
argument_list|,
literal|"GMP-based RSA key handle"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hndidx_rsa
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|e_gmp_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|e_gmp_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
name|int
name|to_return
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
if|#
directive|if
literal|0
block|case E_GMP_CMD_SO_PATH:
comment|/* ... */
endif|#
directive|endif
comment|/* The command isn't understood by this engine */
default|default:
name|GMPerr
argument_list|(
name|GMP_F_E_GMP_CTRL
argument_list|,
name|GMP_R_CTRL_COMMAND_NOT_IMPLEMENTED
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|to_return
return|;
block|}
end_function

begin_comment
comment|/*  * Most often limb sizes will be the same. If not, we use hex conversion  * which is neat, but extremely inefficient.  */
end_comment

begin_function
specifier|static
name|int
name|bn2gmp
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|bn
parameter_list|,
name|mpz_t
name|g
parameter_list|)
block|{
name|bn_check_top
argument_list|(
name|bn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|bn
operator|->
name|d
index|[
literal|0
index|]
argument_list|)
operator|*
literal|8
operator|)
operator|==
name|GMP_NUMB_BITS
operator|)
operator|&&
operator|(
name|BN_BITS2
operator|==
name|GMP_NUMB_BITS
operator|)
condition|)
block|{
comment|/* The common case */
if|if
condition|(
operator|!
name|_mpz_realloc
argument_list|(
name|g
argument_list|,
name|bn
operator|->
name|top
argument_list|)
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
operator|&
name|g
operator|->
name|_mp_d
index|[
literal|0
index|]
argument_list|,
operator|&
name|bn
operator|->
name|d
index|[
literal|0
index|]
argument_list|,
name|bn
operator|->
name|top
operator|*
sizeof|sizeof
argument_list|(
name|bn
operator|->
name|d
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|_mp_size
operator|=
name|bn
operator|->
name|top
expr_stmt|;
if|if
condition|(
name|bn
operator|->
name|neg
condition|)
name|g
operator|->
name|_mp_size
operator|=
operator|-
name|g
operator|->
name|_mp_size
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|int
name|toret
decl_stmt|;
name|char
modifier|*
name|tmpchar
init|=
name|BN_bn2hex
argument_list|(
name|bn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmpchar
condition|)
return|return
literal|0
return|;
name|toret
operator|=
operator|(
name|mpz_set_str
argument_list|(
name|g
argument_list|,
name|tmpchar
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|tmpchar
argument_list|)
expr_stmt|;
return|return
name|toret
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|gmp2bn
parameter_list|(
name|mpz_t
name|g
parameter_list|,
name|BIGNUM
modifier|*
name|bn
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|bn
operator|->
name|d
index|[
literal|0
index|]
argument_list|)
operator|*
literal|8
operator|)
operator|==
name|GMP_NUMB_BITS
operator|)
operator|&&
operator|(
name|BN_BITS2
operator|==
name|GMP_NUMB_BITS
operator|)
condition|)
block|{
comment|/* The common case */
name|int
name|s
init|=
operator|(
name|g
operator|->
name|_mp_size
operator|>=
literal|0
operator|)
condition|?
name|g
operator|->
name|_mp_size
else|:
operator|-
name|g
operator|->
name|_mp_size
decl_stmt|;
name|BN_zero
argument_list|(
name|bn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bn_expand2
argument_list|(
name|bn
argument_list|,
name|s
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|bn
operator|->
name|top
operator|=
name|s
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|bn
operator|->
name|d
index|[
literal|0
index|]
argument_list|,
operator|&
name|g
operator|->
name|_mp_d
index|[
literal|0
index|]
argument_list|,
name|s
operator|*
sizeof|sizeof
argument_list|(
name|bn
operator|->
name|d
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|bn_correct_top
argument_list|(
name|bn
argument_list|)
expr_stmt|;
name|bn
operator|->
name|neg
operator|=
name|g
operator|->
name|_mp_size
operator|>=
literal|0
condition|?
literal|0
else|:
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|int
name|toret
decl_stmt|;
name|char
modifier|*
name|tmpchar
init|=
name|OPENSSL_malloc
argument_list|(
name|mpz_sizeinbase
argument_list|(
name|g
argument_list|,
literal|16
argument_list|)
operator|+
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmpchar
condition|)
return|return
literal|0
return|;
name|mpz_get_str
argument_list|(
name|tmpchar
argument_list|,
literal|16
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|toret
operator|=
name|BN_hex2bn
argument_list|(
operator|&
name|bn
argument_list|,
name|tmpchar
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|tmpchar
argument_list|)
expr_stmt|;
return|return
name|toret
return|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_typedef
typedef|typedef
struct|struct
name|st_e_gmp_rsa_ctx
block|{
name|int
name|public_only
decl_stmt|;
name|mpz_t
name|n
decl_stmt|;
name|mpz_t
name|d
decl_stmt|;
name|mpz_t
name|e
decl_stmt|;
name|mpz_t
name|p
decl_stmt|;
name|mpz_t
name|q
decl_stmt|;
name|mpz_t
name|dmp1
decl_stmt|;
name|mpz_t
name|dmq1
decl_stmt|;
name|mpz_t
name|iqmp
decl_stmt|;
name|mpz_t
name|r0
decl_stmt|,
name|r1
decl_stmt|,
name|I0
decl_stmt|,
name|m1
decl_stmt|;
block|}
name|E_GMP_RSA_CTX
typedef|;
end_typedef

begin_function
specifier|static
name|E_GMP_RSA_CTX
modifier|*
name|e_gmp_get_rsa
parameter_list|(
name|RSA
modifier|*
name|rsa
parameter_list|)
block|{
name|E_GMP_RSA_CTX
modifier|*
name|hptr
init|=
name|RSA_get_ex_data
argument_list|(
name|rsa
argument_list|,
name|hndidx_rsa
argument_list|)
decl_stmt|;
if|if
condition|(
name|hptr
condition|)
return|return
name|hptr
return|;
name|hptr
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|E_GMP_RSA_CTX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hptr
condition|)
return|return
name|NULL
return|;
comment|/*      * These inits could probably be replaced by more intelligent mpz_init2()      * versions, to reduce malloc-thrashing.      */
name|mpz_init
argument_list|(
name|hptr
operator|->
name|n
argument_list|)
expr_stmt|;
name|mpz_init
argument_list|(
name|hptr
operator|->
name|d
argument_list|)
expr_stmt|;
name|mpz_init
argument_list|(
name|hptr
operator|->
name|e
argument_list|)
expr_stmt|;
name|mpz_init
argument_list|(
name|hptr
operator|->
name|p
argument_list|)
expr_stmt|;
name|mpz_init
argument_list|(
name|hptr
operator|->
name|q
argument_list|)
expr_stmt|;
name|mpz_init
argument_list|(
name|hptr
operator|->
name|dmp1
argument_list|)
expr_stmt|;
name|mpz_init
argument_list|(
name|hptr
operator|->
name|dmq1
argument_list|)
expr_stmt|;
name|mpz_init
argument_list|(
name|hptr
operator|->
name|iqmp
argument_list|)
expr_stmt|;
name|mpz_init
argument_list|(
name|hptr
operator|->
name|r0
argument_list|)
expr_stmt|;
name|mpz_init
argument_list|(
name|hptr
operator|->
name|r1
argument_list|)
expr_stmt|;
name|mpz_init
argument_list|(
name|hptr
operator|->
name|I0
argument_list|)
expr_stmt|;
name|mpz_init
argument_list|(
name|hptr
operator|->
name|m1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bn2gmp
argument_list|(
name|rsa
operator|->
name|n
argument_list|,
name|hptr
operator|->
name|n
argument_list|)
operator|||
operator|!
name|bn2gmp
argument_list|(
name|rsa
operator|->
name|e
argument_list|,
name|hptr
operator|->
name|e
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|rsa
operator|->
name|p
operator|||
operator|!
name|rsa
operator|->
name|q
operator|||
operator|!
name|rsa
operator|->
name|d
operator|||
operator|!
name|rsa
operator|->
name|dmp1
operator|||
operator|!
name|rsa
operator|->
name|dmq1
operator|||
operator|!
name|rsa
operator|->
name|iqmp
condition|)
block|{
name|hptr
operator|->
name|public_only
operator|=
literal|1
expr_stmt|;
return|return
name|hptr
return|;
block|}
if|if
condition|(
operator|!
name|bn2gmp
argument_list|(
name|rsa
operator|->
name|d
argument_list|,
name|hptr
operator|->
name|d
argument_list|)
operator|||
operator|!
name|bn2gmp
argument_list|(
name|rsa
operator|->
name|p
argument_list|,
name|hptr
operator|->
name|p
argument_list|)
operator|||
operator|!
name|bn2gmp
argument_list|(
name|rsa
operator|->
name|q
argument_list|,
name|hptr
operator|->
name|q
argument_list|)
operator|||
operator|!
name|bn2gmp
argument_list|(
name|rsa
operator|->
name|dmp1
argument_list|,
name|hptr
operator|->
name|dmp1
argument_list|)
operator|||
operator|!
name|bn2gmp
argument_list|(
name|rsa
operator|->
name|dmq1
argument_list|,
name|hptr
operator|->
name|dmq1
argument_list|)
operator|||
operator|!
name|bn2gmp
argument_list|(
name|rsa
operator|->
name|iqmp
argument_list|,
name|hptr
operator|->
name|iqmp
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|hptr
operator|->
name|public_only
operator|=
literal|0
expr_stmt|;
name|RSA_set_ex_data
argument_list|(
name|rsa
argument_list|,
name|hndidx_rsa
argument_list|,
name|hptr
argument_list|)
expr_stmt|;
return|return
name|hptr
return|;
name|err
label|:
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|n
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|d
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|e
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|p
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|q
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|dmp1
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|dmq1
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|iqmp
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|r0
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|r1
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|I0
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|m1
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|hptr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|e_gmp_rsa_finish
parameter_list|(
name|RSA
modifier|*
name|rsa
parameter_list|)
block|{
name|E_GMP_RSA_CTX
modifier|*
name|hptr
init|=
name|RSA_get_ex_data
argument_list|(
name|rsa
argument_list|,
name|hndidx_rsa
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hptr
condition|)
return|return
literal|0
return|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|n
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|d
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|e
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|p
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|q
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|dmp1
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|dmq1
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|iqmp
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|r0
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|r1
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|I0
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|hptr
operator|->
name|m1
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|hptr
argument_list|)
expr_stmt|;
name|RSA_set_ex_data
argument_list|(
name|rsa
argument_list|,
name|hndidx_rsa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|e_gmp_rsa_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|I
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|E_GMP_RSA_CTX
modifier|*
name|hptr
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
name|hptr
operator|=
name|e_gmp_get_rsa
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hptr
condition|)
block|{
name|GMPerr
argument_list|(
name|GMP_F_E_GMP_RSA_MOD_EXP
argument_list|,
name|GMP_R_KEY_CONTEXT_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|hptr
operator|->
name|public_only
condition|)
block|{
name|GMPerr
argument_list|(
name|GMP_F_E_GMP_RSA_MOD_EXP
argument_list|,
name|GMP_R_MISSING_KEY_COMPONENTS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* ugh!!! */
if|if
condition|(
operator|!
name|bn2gmp
argument_list|(
name|I
argument_list|,
name|hptr
operator|->
name|I0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/*      * This is basically the CRT logic in crypto/rsa/rsa_eay.c reworded into      * GMP-speak. It may be that GMP's API facilitates cleaner formulations      * of this stuff, eg. better handling of negatives, or functions that      * combine operations.      */
name|mpz_mod
argument_list|(
name|hptr
operator|->
name|r1
argument_list|,
name|hptr
operator|->
name|I0
argument_list|,
name|hptr
operator|->
name|q
argument_list|)
expr_stmt|;
name|mpz_powm
argument_list|(
name|hptr
operator|->
name|m1
argument_list|,
name|hptr
operator|->
name|r1
argument_list|,
name|hptr
operator|->
name|dmq1
argument_list|,
name|hptr
operator|->
name|q
argument_list|)
expr_stmt|;
name|mpz_mod
argument_list|(
name|hptr
operator|->
name|r1
argument_list|,
name|hptr
operator|->
name|I0
argument_list|,
name|hptr
operator|->
name|p
argument_list|)
expr_stmt|;
name|mpz_powm
argument_list|(
name|hptr
operator|->
name|r0
argument_list|,
name|hptr
operator|->
name|r1
argument_list|,
name|hptr
operator|->
name|dmp1
argument_list|,
name|hptr
operator|->
name|p
argument_list|)
expr_stmt|;
name|mpz_sub
argument_list|(
name|hptr
operator|->
name|r0
argument_list|,
name|hptr
operator|->
name|r0
argument_list|,
name|hptr
operator|->
name|m1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpz_sgn
argument_list|(
name|hptr
operator|->
name|r0
argument_list|)
operator|<
literal|0
condition|)
name|mpz_add
argument_list|(
name|hptr
operator|->
name|r0
argument_list|,
name|hptr
operator|->
name|r0
argument_list|,
name|hptr
operator|->
name|p
argument_list|)
expr_stmt|;
name|mpz_mul
argument_list|(
name|hptr
operator|->
name|r1
argument_list|,
name|hptr
operator|->
name|r0
argument_list|,
name|hptr
operator|->
name|iqmp
argument_list|)
expr_stmt|;
name|mpz_mod
argument_list|(
name|hptr
operator|->
name|r0
argument_list|,
name|hptr
operator|->
name|r1
argument_list|,
name|hptr
operator|->
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpz_sgn
argument_list|(
name|hptr
operator|->
name|r0
argument_list|)
operator|<
literal|0
condition|)
name|mpz_add
argument_list|(
name|hptr
operator|->
name|r0
argument_list|,
name|hptr
operator|->
name|r0
argument_list|,
name|hptr
operator|->
name|p
argument_list|)
expr_stmt|;
name|mpz_mul
argument_list|(
name|hptr
operator|->
name|r1
argument_list|,
name|hptr
operator|->
name|r0
argument_list|,
name|hptr
operator|->
name|q
argument_list|)
expr_stmt|;
name|mpz_add
argument_list|(
name|hptr
operator|->
name|r0
argument_list|,
name|hptr
operator|->
name|r1
argument_list|,
name|hptr
operator|->
name|m1
argument_list|)
expr_stmt|;
comment|/* ugh!!! */
if|if
condition|(
name|gmp2bn
argument_list|(
name|hptr
operator|->
name|r0
argument_list|,
name|r
argument_list|)
condition|)
name|to_return
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_GMP */
end_comment

begin_comment
comment|/*  * This stuff is needed if this ENGINE is being compiled into a  * self-contained shared-library.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DYNAMIC_ENGINE
end_ifndef

begin_macro
name|IMPLEMENT_DYNAMIC_CHECK_FN
argument_list|()
end_macro

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_GMP
end_ifndef

begin_function
specifier|static
name|int
name|bind_fn
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|&&
operator|(
name|strcmp
argument_list|(
name|id
argument_list|,
name|engine_e_gmp_id
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|bind_helper
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_macro
name|IMPLEMENT_DYNAMIC_BIND_FN
argument_list|(
argument|bind_fn
argument_list|)
end_macro

begin_else
else|#
directive|else
end_else

begin_function_decl
name|OPENSSL_EXPORT
name|int
name|bind_engine
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|,
specifier|const
name|dynamic_fns
modifier|*
name|fns
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|OPENSSL_EXPORT
name|int
name|bind_engine
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|,
specifier|const
name|dynamic_fns
modifier|*
name|fns
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_DYNAMIC_ENGINE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_HW */
end_comment

end_unit

