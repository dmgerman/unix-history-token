begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/engine/e_chil.c -*- mode: C; c-file-style: "eay" -*- */
end_comment

begin_comment
comment|/*  * Written by Richard Levitte (richard@levitte.org), Geoff Thorpe  * (geoff@geoffthorpe.net) and Dr Stephen N Henson (steve@openssl.org) for  * the OpenSSL project 2000.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1999-2001 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_include
include|#
directive|include
file|<openssl/dso.h>
end_include

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ui.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_include
include|#
directive|include
file|<openssl/rsa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_include
include|#
directive|include
file|<openssl/dh.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HW
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HW_CHIL
end_ifndef

begin_comment
comment|/*-  * Attribution notice: nCipher have said several times that it's OK for  * us to implement a general interface to their boxes, and recently declared  * their HWCryptoHook to be public, and therefore available for us to use.  * Thanks, nCipher.  *  * The hwcryptohook.h included here is from May 2000.  * [Richard Levitte]  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FLAT_INC
end_ifdef

begin_include
include|#
directive|include
file|"hwcryptohook.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"vendor_defns/hwcryptohook.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HWCRHK_LIB_NAME
value|"CHIL engine"
end_define

begin_include
include|#
directive|include
file|"e_chil_err.c"
end_include

begin_function_decl
specifier|static
name|int
name|hwcrhk_destroy
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwcrhk_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwcrhk_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwcrhk_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions to handle mutexes */
end_comment

begin_function_decl
specifier|static
name|int
name|hwcrhk_mutex_init
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwcrhk_mutex_lock
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hwcrhk_mutex_unlock
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hwcrhk_mutex_destroy
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* BIGNUM stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|hwcrhk_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_comment
comment|/* RSA stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|hwcrhk_rsa_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|I
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This function is aliased to mod_exp (with the mont stuff dropped). */
end_comment

begin_function_decl
specifier|static
name|int
name|hwcrhk_mod_exp_mont
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwcrhk_rsa_finish
parameter_list|(
name|RSA
modifier|*
name|rsa
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_comment
comment|/* DH stuff */
end_comment

begin_comment
comment|/* This function is alised to mod_exp (with the DH and mont dropped). */
end_comment

begin_function_decl
specifier|static
name|int
name|hwcrhk_mod_exp_dh
parameter_list|(
specifier|const
name|DH
modifier|*
name|dh
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAND stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|hwcrhk_rand_bytes
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwcrhk_rand_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* KM stuff */
end_comment

begin_function_decl
specifier|static
name|EVP_PKEY
modifier|*
name|hwcrhk_load_privkey
parameter_list|(
name|ENGINE
modifier|*
name|eng
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|EVP_PKEY
modifier|*
name|hwcrhk_load_pubkey
parameter_list|(
name|ENGINE
modifier|*
name|eng
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Interaction stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|hwcrhk_insert_card
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt_info
parameter_list|,
specifier|const
name|char
modifier|*
name|wrong_info
parameter_list|,
name|HWCryptoHook_PassphraseContext
modifier|*
name|ppctx
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
name|cactx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwcrhk_get_pass
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt_info
parameter_list|,
name|int
modifier|*
name|len_io
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|HWCryptoHook_PassphraseContext
modifier|*
name|ppctx
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
name|cactx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hwcrhk_log_message
parameter_list|(
name|void
modifier|*
name|logstr
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The definitions for control commands specific to this engine */
end_comment

begin_define
define|#
directive|define
name|HWCRHK_CMD_SO_PATH
value|ENGINE_CMD_BASE
end_define

begin_define
define|#
directive|define
name|HWCRHK_CMD_FORK_CHECK
value|(ENGINE_CMD_BASE + 1)
end_define

begin_define
define|#
directive|define
name|HWCRHK_CMD_THREAD_LOCKING
value|(ENGINE_CMD_BASE + 2)
end_define

begin_define
define|#
directive|define
name|HWCRHK_CMD_SET_USER_INTERFACE
value|(ENGINE_CMD_BASE + 3)
end_define

begin_define
define|#
directive|define
name|HWCRHK_CMD_SET_CALLBACK_DATA
value|(ENGINE_CMD_BASE + 4)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|ENGINE_CMD_DEFN
name|hwcrhk_cmd_defns
index|[]
init|=
block|{
block|{
name|HWCRHK_CMD_SO_PATH
block|,
literal|"SO_PATH"
block|,
literal|"Specifies the path to the 'hwcrhk' shared library"
block|,
name|ENGINE_CMD_FLAG_STRING
block|}
block|,
block|{
name|HWCRHK_CMD_FORK_CHECK
block|,
literal|"FORK_CHECK"
block|,
literal|"Turns fork() checking on (non-zero) or off (zero)"
block|,
name|ENGINE_CMD_FLAG_NUMERIC
block|}
block|,
block|{
name|HWCRHK_CMD_THREAD_LOCKING
block|,
literal|"THREAD_LOCKING"
block|,
literal|"Turns thread-safe locking on (zero) or off (non-zero)"
block|,
name|ENGINE_CMD_FLAG_NUMERIC
block|}
block|,
block|{
name|HWCRHK_CMD_SET_USER_INTERFACE
block|,
literal|"SET_USER_INTERFACE"
block|,
literal|"Set the global user interface (internal)"
block|,
name|ENGINE_CMD_FLAG_INTERNAL
block|}
block|,
block|{
name|HWCRHK_CMD_SET_CALLBACK_DATA
block|,
literal|"SET_CALLBACK_DATA"
block|,
literal|"Set the global user interface extra data (internal)"
block|,
name|ENGINE_CMD_FLAG_INTERNAL
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_comment
comment|/* Our internal RSA_METHOD that we provide pointers to */
end_comment

begin_decl_stmt
specifier|static
name|RSA_METHOD
name|hwcrhk_rsa
init|=
block|{
literal|"CHIL RSA method"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|hwcrhk_rsa_mod_exp
block|,
name|hwcrhk_mod_exp_mont
block|,
name|NULL
block|,
name|hwcrhk_rsa_finish
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_comment
comment|/* Our internal DH_METHOD that we provide pointers to */
end_comment

begin_decl_stmt
specifier|static
name|DH_METHOD
name|hwcrhk_dh
init|=
block|{
literal|"CHIL DH method"
block|,
name|NULL
block|,
name|NULL
block|,
name|hwcrhk_mod_exp_dh
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|RAND_METHOD
name|hwcrhk_rand
init|=
block|{
comment|/* "CHIL RAND method", */
name|NULL
block|,
name|hwcrhk_rand_bytes
block|,
name|NULL
block|,
name|NULL
block|,
name|hwcrhk_rand_bytes
block|,
name|hwcrhk_rand_status
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Constants used when creating the ENGINE */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_hwcrhk_id
init|=
literal|"chil"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_hwcrhk_name
init|=
literal|"CHIL hardware engine support"
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DYNAMIC_ENGINE
end_ifndef

begin_comment
comment|/* Compatibility hack, the dynamic library uses this form in the path */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_hwcrhk_id_alt
init|=
literal|"ncipher"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Internal stuff for HWCryptoHook */
end_comment

begin_comment
comment|/* Some structures needed for proper use of thread locks */
end_comment

begin_comment
comment|/*  * hwcryptohook.h has some typedefs that turn struct HWCryptoHook_MutexValue  * into HWCryptoHook_Mutex  */
end_comment

begin_struct
struct|struct
name|HWCryptoHook_MutexValue
block|{
name|int
name|lockid
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * hwcryptohook.h has some typedefs that turn struct  * HWCryptoHook_PassphraseContextValue into HWCryptoHook_PassphraseContext  */
end_comment

begin_struct
struct|struct
name|HWCryptoHook_PassphraseContextValue
block|{
name|UI_METHOD
modifier|*
name|ui_method
decl_stmt|;
name|void
modifier|*
name|callback_data
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * hwcryptohook.h has some typedefs that turn struct  * HWCryptoHook_CallerContextValue into HWCryptoHook_CallerContext  */
end_comment

begin_struct
struct|struct
name|HWCryptoHook_CallerContextValue
block|{
name|pem_password_cb
modifier|*
name|password_callback
decl_stmt|;
comment|/* Deprecated! Only present for                                          * backward compatibility! */
name|UI_METHOD
modifier|*
name|ui_method
decl_stmt|;
name|void
modifier|*
name|callback_data
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The MPI structure in HWCryptoHook is pretty compatible with OpenSSL  * BIGNUM's, so lets define a couple of conversion macros  */
end_comment

begin_define
define|#
directive|define
name|BN2MPI
parameter_list|(
name|mp
parameter_list|,
name|bn
parameter_list|)
define|\
value|{mp.size = bn->top * sizeof(BN_ULONG); mp.buf = (unsigned char *)bn->d;}
end_define

begin_define
define|#
directive|define
name|MPI2BN
parameter_list|(
name|bn
parameter_list|,
name|mp
parameter_list|)
define|\
value|{mp.size = bn->dmax * sizeof(BN_ULONG); mp.buf = (unsigned char *)bn->d;}
end_define

begin_decl_stmt
specifier|static
name|BIO
modifier|*
name|logstream
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|disable_mutex_callbacks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * One might wonder why these are needed, since one can pass down at least a  * UI_METHOD and a pointer to callback data to the key-loading functions. The  * thing is that the ModExp and RSAImmed functions can load keys as well, if  * the data they get is in a special, nCipher-defined format (hint: if you  * look at the private exponent of the RSA data as a string, you'll see this  * string: "nCipher KM tool key id", followed by some bytes, followed a key  * identity string, followed by more bytes.  This happens when you use  * "embed" keys instead of "hwcrhk" keys).  Unfortunately, those functions do  * not take any passphrase or caller context, and our functions can't really  * take any callback data either.  Still, the "insert_card" and  * "get_passphrase" callbacks may be called down the line, and will need to  * know what user interface callbacks to call, and having callback data from  * the application may be a nice thing as well, so we need to keep track of  * that globally.  */
end_comment

begin_decl_stmt
specifier|static
name|HWCryptoHook_CallerContext
name|password_context
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stuff to pass to the HWCryptoHook library */
end_comment

begin_decl_stmt
specifier|static
name|HWCryptoHook_InitInfo
name|hwcrhk_globals
init|=
block|{
name|HWCryptoHook_InitFlags_SimpleForkCheck
block|,
comment|/* Flags */
operator|&
name|logstream
block|,
comment|/* logstream */
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
block|,
comment|/* limbsize */
literal|0
block|,
comment|/* mslimb first: false for BNs */
operator|-
literal|1
block|,
comment|/* msbyte first: use native */
literal|0
block|,
comment|/* Max mutexes, 0 = no small limit */
literal|0
block|,
comment|/* Max simultaneous, 0 = default */
comment|/*      * The next few are mutex stuff: we write wrapper functions around the OS      * mutex functions.  We initialise them to 0 here, and change that to      * actual function pointers in hwcrhk_init() if dynamic locks are      * supported (that is, if the application programmer has made sure of      * setting up callbacks bafore starting this engine) *and* if      * disable_mutex_callbacks hasn't been set by a call to      * ENGINE_ctrl(ENGINE_CTRL_CHIL_NO_LOCKING).      */
sizeof|sizeof
argument_list|(
name|HWCryptoHook_Mutex
argument_list|)
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*      * The next few are condvar stuff: we write wrapper functions round the      * OS functions.  Currently not implemented and not and absolute      * necessity even in threaded programs, therefore 0'ed.  Will hopefully      * be implemented some day, since it enhances the efficiency of      * HWCryptoHook.      */
literal|0
block|,
comment|/* sizeof(HWCryptoHook_CondVar), */
literal|0
block|,
comment|/* hwcrhk_cv_init, */
literal|0
block|,
comment|/* hwcrhk_cv_wait, */
literal|0
block|,
comment|/* hwcrhk_cv_signal, */
literal|0
block|,
comment|/* hwcrhk_cv_broadcast, */
literal|0
block|,
comment|/* hwcrhk_cv_destroy, */
name|hwcrhk_get_pass
block|,
comment|/* pass phrase */
name|hwcrhk_insert_card
block|,
comment|/* insert a card */
name|hwcrhk_log_message
comment|/* Log message */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Now, to our own code */
end_comment

begin_comment
comment|/*  * This internal function is used by ENGINE_chil() and possibly by the  * "dynamic" ENGINE support too  */
end_comment

begin_function
specifier|static
name|int
name|bind_helper
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
specifier|const
name|RSA_METHOD
modifier|*
name|meth1
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
specifier|const
name|DH_METHOD
modifier|*
name|meth2
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ENGINE_set_id
argument_list|(
name|e
argument_list|,
name|engine_hwcrhk_id
argument_list|)
operator|||
operator|!
name|ENGINE_set_name
argument_list|(
name|e
argument_list|,
name|engine_hwcrhk_name
argument_list|)
operator|||
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
operator|!
name|ENGINE_set_RSA
argument_list|(
name|e
argument_list|,
operator|&
name|hwcrhk_rsa
argument_list|)
operator|||
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
operator|!
name|ENGINE_set_DH
argument_list|(
name|e
argument_list|,
operator|&
name|hwcrhk_dh
argument_list|)
operator|||
endif|#
directive|endif
operator|!
name|ENGINE_set_RAND
argument_list|(
name|e
argument_list|,
operator|&
name|hwcrhk_rand
argument_list|)
operator|||
operator|!
name|ENGINE_set_destroy_function
argument_list|(
name|e
argument_list|,
name|hwcrhk_destroy
argument_list|)
operator|||
operator|!
name|ENGINE_set_init_function
argument_list|(
name|e
argument_list|,
name|hwcrhk_init
argument_list|)
operator|||
operator|!
name|ENGINE_set_finish_function
argument_list|(
name|e
argument_list|,
name|hwcrhk_finish
argument_list|)
operator|||
operator|!
name|ENGINE_set_ctrl_function
argument_list|(
name|e
argument_list|,
name|hwcrhk_ctrl
argument_list|)
operator|||
operator|!
name|ENGINE_set_load_privkey_function
argument_list|(
name|e
argument_list|,
name|hwcrhk_load_privkey
argument_list|)
operator|||
operator|!
name|ENGINE_set_load_pubkey_function
argument_list|(
name|e
argument_list|,
name|hwcrhk_load_pubkey
argument_list|)
operator|||
operator|!
name|ENGINE_set_cmd_defns
argument_list|(
name|e
argument_list|,
name|hwcrhk_cmd_defns
argument_list|)
condition|)
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
comment|/*      * We know that the "PKCS1_SSLeay()" functions hook properly to the      * cswift-specific mod_exp and mod_exp_crt so we use those functions. NB:      * We don't use ENGINE_openssl() or anything "more generic" because      * something like the RSAref code may not hook properly, and if you own      * one of these cards then you have the right to do RSA operations on it      * anyway!      */
name|meth1
operator|=
name|RSA_PKCS1_SSLeay
argument_list|()
expr_stmt|;
name|hwcrhk_rsa
operator|.
name|rsa_pub_enc
operator|=
name|meth1
operator|->
name|rsa_pub_enc
expr_stmt|;
name|hwcrhk_rsa
operator|.
name|rsa_pub_dec
operator|=
name|meth1
operator|->
name|rsa_pub_dec
expr_stmt|;
name|hwcrhk_rsa
operator|.
name|rsa_priv_enc
operator|=
name|meth1
operator|->
name|rsa_priv_enc
expr_stmt|;
name|hwcrhk_rsa
operator|.
name|rsa_priv_dec
operator|=
name|meth1
operator|->
name|rsa_priv_dec
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
comment|/* Much the same for Diffie-Hellman */
name|meth2
operator|=
name|DH_OpenSSL
argument_list|()
expr_stmt|;
name|hwcrhk_dh
operator|.
name|generate_key
operator|=
name|meth2
operator|->
name|generate_key
expr_stmt|;
name|hwcrhk_dh
operator|.
name|compute_key
operator|=
name|meth2
operator|->
name|compute_key
expr_stmt|;
endif|#
directive|endif
comment|/* Ensure the hwcrhk error handling is set up */
name|ERR_load_HWCRHK_strings
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_NO_DYNAMIC_ENGINE
end_ifdef

begin_function
specifier|static
name|ENGINE
modifier|*
name|engine_chil
parameter_list|(
name|void
parameter_list|)
block|{
name|ENGINE
modifier|*
name|ret
init|=
name|ENGINE_new
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|bind_helper
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ENGINE_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|ENGINE_load_chil
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Copied from eng_[openssl|dyn].c */
name|ENGINE
modifier|*
name|toadd
init|=
name|engine_chil
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|toadd
condition|)
return|return;
name|ENGINE_add
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ENGINE_free
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This is a process-global DSO handle used for loading and unloading the  * HWCryptoHook library. NB: This is only set (or unset) during an init() or  * finish() call (reference counts permitting) and they're operating with  * global locks, so this should be thread-safe implicitly.  */
end_comment

begin_decl_stmt
specifier|static
name|DSO
modifier|*
name|hwcrhk_dso
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HWCryptoHook_ContextHandle
name|hwcrhk_context
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_comment
comment|/* Index for KM handle.  Not really used yet. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hndidx_rsa
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * These are the function pointers that are (un)set when the library has  * successfully (un)loaded.  */
end_comment

begin_decl_stmt
specifier|static
name|HWCryptoHook_Init_t
modifier|*
name|p_hwcrhk_Init
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HWCryptoHook_Finish_t
modifier|*
name|p_hwcrhk_Finish
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HWCryptoHook_ModExp_t
modifier|*
name|p_hwcrhk_ModExp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_decl_stmt
specifier|static
name|HWCryptoHook_RSA_t
modifier|*
name|p_hwcrhk_RSA
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|HWCryptoHook_RandomBytes_t
modifier|*
name|p_hwcrhk_RandomBytes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_decl_stmt
specifier|static
name|HWCryptoHook_RSALoadKey_t
modifier|*
name|p_hwcrhk_RSALoadKey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HWCryptoHook_RSAGetPublicKey_t
modifier|*
name|p_hwcrhk_RSAGetPublicKey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HWCryptoHook_RSAUnloadKey_t
modifier|*
name|p_hwcrhk_RSAUnloadKey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|HWCryptoHook_ModExpCRT_t
modifier|*
name|p_hwcrhk_ModExpCRT
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used in the DSO operations. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|HWCRHK_LIBNAME
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|free_HWCRHK_LIBNAME
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|HWCRHK_LIBNAME
condition|)
name|OPENSSL_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|HWCRHK_LIBNAME
argument_list|)
expr_stmt|;
name|HWCRHK_LIBNAME
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_HWCRHK_LIBNAME
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|HWCRHK_LIBNAME
condition|)
return|return
name|HWCRHK_LIBNAME
return|;
return|return
literal|"nfhwcrhk"
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|set_HWCRHK_LIBNAME
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|free_HWCRHK_LIBNAME
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|HWCRHK_LIBNAME
operator|=
name|BUF_strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_Init
init|=
literal|"HWCryptoHook_Init"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_Finish
init|=
literal|"HWCryptoHook_Finish"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_ModExp
init|=
literal|"HWCryptoHook_ModExp"
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_RSA
init|=
literal|"HWCryptoHook_RSA"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_RandomBytes
init|=
literal|"HWCryptoHook_RandomBytes"
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_RSALoadKey
init|=
literal|"HWCryptoHook_RSALoadKey"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_RSAGetPublicKey
init|=
literal|"HWCryptoHook_RSAGetPublicKey"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_RSAUnloadKey
init|=
literal|"HWCryptoHook_RSAUnloadKey"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|n_hwcrhk_ModExpCRT
init|=
literal|"HWCryptoHook_ModExpCRT"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * HWCryptoHook library functions and mechanics - these are used by the  * higher-level functions further down. NB: As and where there's no error  * checking, take a look lower down where these functions are called, the  * checking and error handling is probably down there.  */
end_comment

begin_comment
comment|/* utility function to obtain a context */
end_comment

begin_function
specifier|static
name|int
name|get_context
parameter_list|(
name|HWCryptoHook_ContextHandle
modifier|*
name|hac
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
name|cac
parameter_list|)
block|{
name|char
name|tempbuf
index|[
literal|1024
index|]
decl_stmt|;
name|HWCryptoHook_ErrMsgBuf
name|rmsg
decl_stmt|;
name|rmsg
operator|.
name|buf
operator|=
name|tempbuf
expr_stmt|;
name|rmsg
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
operator|*
name|hac
operator|=
name|p_hwcrhk_Init
argument_list|(
operator|&
name|hwcrhk_globals
argument_list|,
sizeof|sizeof
argument_list|(
name|hwcrhk_globals
argument_list|)
argument_list|,
operator|&
name|rmsg
argument_list|,
name|cac
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|hac
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* similarly to release one. */
end_comment

begin_function
specifier|static
name|void
name|release_context
parameter_list|(
name|HWCryptoHook_ContextHandle
name|hac
parameter_list|)
block|{
name|p_hwcrhk_Finish
argument_list|(
name|hac
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Destructor (complements the "ENGINE_chil()" constructor) */
end_comment

begin_function
specifier|static
name|int
name|hwcrhk_destroy
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|free_HWCRHK_LIBNAME
argument_list|()
expr_stmt|;
name|ERR_unload_HWCRHK_strings
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* (de)initialisation functions. */
end_comment

begin_function
specifier|static
name|int
name|hwcrhk_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|HWCryptoHook_Init_t
modifier|*
name|p1
decl_stmt|;
name|HWCryptoHook_Finish_t
modifier|*
name|p2
decl_stmt|;
name|HWCryptoHook_ModExp_t
modifier|*
name|p3
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|HWCryptoHook_RSA_t
modifier|*
name|p4
decl_stmt|;
name|HWCryptoHook_RSALoadKey_t
modifier|*
name|p5
decl_stmt|;
name|HWCryptoHook_RSAGetPublicKey_t
modifier|*
name|p6
decl_stmt|;
name|HWCryptoHook_RSAUnloadKey_t
modifier|*
name|p7
decl_stmt|;
endif|#
directive|endif
name|HWCryptoHook_RandomBytes_t
modifier|*
name|p8
decl_stmt|;
name|HWCryptoHook_ModExpCRT_t
modifier|*
name|p9
decl_stmt|;
if|if
condition|(
name|hwcrhk_dso
operator|!=
name|NULL
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_INIT
argument_list|,
name|HWCRHK_R_ALREADY_LOADED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Attempt to load libnfhwcrhk.so/nfhwcrhk.dll/whatever. */
name|hwcrhk_dso
operator|=
name|DSO_load
argument_list|(
name|NULL
argument_list|,
name|get_HWCRHK_LIBNAME
argument_list|()
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwcrhk_dso
operator|==
name|NULL
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_INIT
argument_list|,
name|HWCRHK_R_DSO_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|p1
operator|=
operator|(
name|HWCryptoHook_Init_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_Init
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p2
operator|=
operator|(
name|HWCryptoHook_Finish_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_Finish
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p3
operator|=
operator|(
name|HWCryptoHook_ModExp_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_ModExp
argument_list|)
operator|)
operator|||
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
operator|!
operator|(
name|p4
operator|=
operator|(
name|HWCryptoHook_RSA_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_RSA
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p5
operator|=
operator|(
name|HWCryptoHook_RSALoadKey_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_RSALoadKey
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p6
operator|=
operator|(
name|HWCryptoHook_RSAGetPublicKey_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_RSAGetPublicKey
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p7
operator|=
operator|(
name|HWCryptoHook_RSAUnloadKey_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_RSAUnloadKey
argument_list|)
operator|)
operator|||
endif|#
directive|endif
operator|!
operator|(
name|p8
operator|=
operator|(
name|HWCryptoHook_RandomBytes_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_RandomBytes
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p9
operator|=
operator|(
name|HWCryptoHook_ModExpCRT_t
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|hwcrhk_dso
argument_list|,
name|n_hwcrhk_ModExpCRT
argument_list|)
operator|)
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_INIT
argument_list|,
name|HWCRHK_R_DSO_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Copy the pointers */
name|p_hwcrhk_Init
operator|=
name|p1
expr_stmt|;
name|p_hwcrhk_Finish
operator|=
name|p2
expr_stmt|;
name|p_hwcrhk_ModExp
operator|=
name|p3
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|p_hwcrhk_RSA
operator|=
name|p4
expr_stmt|;
name|p_hwcrhk_RSALoadKey
operator|=
name|p5
expr_stmt|;
name|p_hwcrhk_RSAGetPublicKey
operator|=
name|p6
expr_stmt|;
name|p_hwcrhk_RSAUnloadKey
operator|=
name|p7
expr_stmt|;
endif|#
directive|endif
name|p_hwcrhk_RandomBytes
operator|=
name|p8
expr_stmt|;
name|p_hwcrhk_ModExpCRT
operator|=
name|p9
expr_stmt|;
comment|/*      * Check if the application decided to support dynamic locks, and if it      * does, use them.      */
if|if
condition|(
name|disable_mutex_callbacks
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|CRYPTO_get_dynlock_create_callback
argument_list|()
operator|!=
name|NULL
operator|&&
name|CRYPTO_get_dynlock_lock_callback
argument_list|()
operator|!=
name|NULL
operator|&&
name|CRYPTO_get_dynlock_destroy_callback
argument_list|()
operator|!=
name|NULL
condition|)
block|{
name|hwcrhk_globals
operator|.
name|mutex_init
operator|=
name|hwcrhk_mutex_init
expr_stmt|;
name|hwcrhk_globals
operator|.
name|mutex_acquire
operator|=
name|hwcrhk_mutex_lock
expr_stmt|;
name|hwcrhk_globals
operator|.
name|mutex_release
operator|=
name|hwcrhk_mutex_unlock
expr_stmt|;
name|hwcrhk_globals
operator|.
name|mutex_destroy
operator|=
name|hwcrhk_mutex_destroy
expr_stmt|;
block|}
block|}
comment|/*      * Try and get a context - if not, we may have a DSO but no accelerator!      */
if|if
condition|(
operator|!
name|get_context
argument_list|(
operator|&
name|hwcrhk_context
argument_list|,
operator|&
name|password_context
argument_list|)
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_INIT
argument_list|,
name|HWCRHK_R_UNIT_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Everything's fine. */
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|hndidx_rsa
operator|==
operator|-
literal|1
condition|)
name|hndidx_rsa
operator|=
name|RSA_get_ex_new_index
argument_list|(
literal|0
argument_list|,
literal|"nFast HWCryptoHook RSA key handle"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
name|err
label|:
if|if
condition|(
name|hwcrhk_dso
condition|)
name|DSO_free
argument_list|(
name|hwcrhk_dso
argument_list|)
expr_stmt|;
name|hwcrhk_dso
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_Init
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_Finish
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_ModExp
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|p_hwcrhk_RSA
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RSALoadKey
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RSAGetPublicKey
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RSAUnloadKey
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|p_hwcrhk_ModExpCRT
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RandomBytes
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwcrhk_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|int
name|to_return
init|=
literal|1
decl_stmt|;
name|free_HWCRHK_LIBNAME
argument_list|()
expr_stmt|;
if|if
condition|(
name|hwcrhk_dso
operator|==
name|NULL
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_FINISH
argument_list|,
name|HWCRHK_R_NOT_LOADED
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|0
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|release_context
argument_list|(
name|hwcrhk_context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DSO_free
argument_list|(
name|hwcrhk_dso
argument_list|)
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_FINISH
argument_list|,
name|HWCRHK_R_DSO_FAILURE
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|0
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|err
label|:
if|if
condition|(
name|logstream
condition|)
name|BIO_free
argument_list|(
name|logstream
argument_list|)
expr_stmt|;
name|hwcrhk_dso
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_Init
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_Finish
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_ModExp
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|p_hwcrhk_RSA
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RSALoadKey
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RSAGetPublicKey
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RSAUnloadKey
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|p_hwcrhk_ModExpCRT
operator|=
name|NULL
expr_stmt|;
name|p_hwcrhk_RandomBytes
operator|=
name|NULL
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwcrhk_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
name|int
name|to_return
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|HWCRHK_CMD_SO_PATH
case|:
if|if
condition|(
name|hwcrhk_dso
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_CTRL
argument_list|,
name|HWCRHK_R_ALREADY_LOADED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_CTRL
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|set_HWCRHK_LIBNAME
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|)
return|;
case|case
name|ENGINE_CTRL_SET_LOGSTREAM
case|:
block|{
name|BIO
modifier|*
name|bio
init|=
operator|(
name|BIO
operator|*
operator|)
name|p
decl_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|logstream
condition|)
block|{
name|BIO_free
argument_list|(
name|logstream
argument_list|)
expr_stmt|;
name|logstream
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|CRYPTO_add
argument_list|(
operator|&
name|bio
operator|->
name|references
argument_list|,
literal|1
argument_list|,
name|CRYPTO_LOCK_BIO
argument_list|)
operator|>
literal|1
condition|)
name|logstream
operator|=
name|bio
expr_stmt|;
else|else
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_CTRL
argument_list|,
name|HWCRHK_R_BIO_WAS_FREED
argument_list|)
expr_stmt|;
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENGINE_CTRL_SET_PASSWORD_CALLBACK
case|:
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|password_context
operator|.
name|password_callback
operator|=
operator|(
name|pem_password_cb
operator|*
operator|)
name|f
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENGINE_CTRL_SET_USER_INTERFACE
case|:
case|case
name|HWCRHK_CMD_SET_USER_INTERFACE
case|:
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|password_context
operator|.
name|ui_method
operator|=
operator|(
name|UI_METHOD
operator|*
operator|)
name|p
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENGINE_CTRL_SET_CALLBACK_DATA
case|:
case|case
name|HWCRHK_CMD_SET_CALLBACK_DATA
case|:
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|password_context
operator|.
name|callback_data
operator|=
name|p
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
comment|/*          * this enables or disables the "SimpleForkCheck" flag used in the          * initialisation structure.          */
case|case
name|ENGINE_CTRL_CHIL_SET_FORKCHECK
case|:
case|case
name|HWCRHK_CMD_FORK_CHECK
case|:
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|hwcrhk_globals
operator|.
name|flags
operator||=
name|HWCryptoHook_InitFlags_SimpleForkCheck
expr_stmt|;
else|else
name|hwcrhk_globals
operator|.
name|flags
operator|&=
operator|~
name|HWCryptoHook_InitFlags_SimpleForkCheck
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
comment|/*          * This will prevent the initialisation function from "installing"          * the mutex-handling callbacks, even if they are available from          * within the library (or were provided to the library from the          * calling application). This is to remove any baggage for          * applications not using multithreading.          */
case|case
name|ENGINE_CTRL_CHIL_NO_LOCKING
case|:
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|disable_mutex_callbacks
operator|=
literal|1
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
case|case
name|HWCRHK_CMD_THREAD_LOCKING
case|:
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
name|disable_mutex_callbacks
operator|=
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_ENGINE
argument_list|)
expr_stmt|;
break|break;
comment|/* The command isn't understood by this engine */
default|default:
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_CTRL
argument_list|,
name|HWCRHK_R_CTRL_COMMAND_NOT_IMPLEMENTED
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|EVP_PKEY
modifier|*
name|hwcrhk_load_privkey
parameter_list|(
name|ENGINE
modifier|*
name|eng
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|RSA
modifier|*
name|rtmp
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|EVP_PKEY
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|HWCryptoHook_MPI
name|e
decl_stmt|,
name|n
decl_stmt|;
name|HWCryptoHook_RSAKeyHandle
modifier|*
name|hptr
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_RSA
argument_list|)
name|char
name|tempbuf
index|[
literal|1024
index|]
decl_stmt|;
name|HWCryptoHook_ErrMsgBuf
name|rmsg
decl_stmt|;
name|HWCryptoHook_PassphraseContext
name|ppctx
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_RSA
argument_list|)
name|rmsg
operator|.
name|buf
operator|=
name|tempbuf
expr_stmt|;
name|rmsg
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|hwcrhk_context
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PRIVKEY
argument_list|,
name|HWCRHK_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|hptr
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HWCryptoHook_RSAKeyHandle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hptr
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PRIVKEY
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ppctx
operator|.
name|ui_method
operator|=
name|ui_method
expr_stmt|;
name|ppctx
operator|.
name|callback_data
operator|=
name|callback_data
expr_stmt|;
if|if
condition|(
name|p_hwcrhk_RSALoadKey
argument_list|(
name|hwcrhk_context
argument_list|,
name|key_id
argument_list|,
name|hptr
argument_list|,
operator|&
name|rmsg
argument_list|,
operator|&
name|ppctx
argument_list|)
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PRIVKEY
argument_list|,
name|HWCRHK_R_CHIL_ERROR
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|rmsg
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
operator|*
name|hptr
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PRIVKEY
argument_list|,
name|HWCRHK_R_NO_KEY
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|rtmp
operator|=
name|RSA_new_method
argument_list|(
name|eng
argument_list|)
expr_stmt|;
name|RSA_set_ex_data
argument_list|(
name|rtmp
argument_list|,
name|hndidx_rsa
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hptr
argument_list|)
expr_stmt|;
name|rtmp
operator|->
name|e
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|rtmp
operator|->
name|n
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|rtmp
operator|->
name|flags
operator||=
name|RSA_FLAG_EXT_PKEY
expr_stmt|;
name|MPI2BN
argument_list|(
name|rtmp
operator|->
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|MPI2BN
argument_list|(
name|rtmp
operator|->
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_hwcrhk_RSAGetPublicKey
argument_list|(
operator|*
name|hptr
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|e
argument_list|,
operator|&
name|rmsg
argument_list|)
operator|!=
name|HWCRYPTOHOOK_ERROR_MPISIZE
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PRIVKEY
argument_list|,
name|HWCRHK_R_CHIL_ERROR
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|rmsg
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|bn_expand2
argument_list|(
name|rtmp
operator|->
name|e
argument_list|,
name|e
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
expr_stmt|;
name|bn_expand2
argument_list|(
name|rtmp
operator|->
name|n
argument_list|,
name|n
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
argument_list|)
expr_stmt|;
name|MPI2BN
argument_list|(
name|rtmp
operator|->
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|MPI2BN
argument_list|(
name|rtmp
operator|->
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_hwcrhk_RSAGetPublicKey
argument_list|(
operator|*
name|hptr
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|e
argument_list|,
operator|&
name|rmsg
argument_list|)
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PRIVKEY
argument_list|,
name|HWCRHK_R_CHIL_ERROR
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|rmsg
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|rtmp
operator|->
name|e
operator|->
name|top
operator|=
name|e
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|rtmp
operator|->
name|e
argument_list|)
expr_stmt|;
name|rtmp
operator|->
name|n
operator|->
name|top
operator|=
name|n
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|rtmp
operator|->
name|n
argument_list|)
expr_stmt|;
name|res
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_RSA
argument_list|(
name|res
argument_list|,
name|rtmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|res
condition|)
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PRIVKEY
argument_list|,
name|HWCRHK_R_PRIVATE_KEY_ALGORITHMS_DISABLED
argument_list|)
expr_stmt|;
return|return
name|res
return|;
name|err
label|:
if|if
condition|(
name|res
condition|)
name|EVP_PKEY_free
argument_list|(
name|res
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
if|if
condition|(
name|rtmp
condition|)
name|RSA_free
argument_list|(
name|rtmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|EVP_PKEY
modifier|*
name|hwcrhk_load_pubkey
parameter_list|(
name|ENGINE
modifier|*
name|eng
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
name|res
operator|=
name|hwcrhk_load_privkey
argument_list|(
name|eng
argument_list|,
name|key_id
argument_list|,
name|ui_method
argument_list|,
name|callback_data
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|res
condition|)
switch|switch
condition|(
name|res
operator|->
name|type
condition|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
case|case
name|EVP_PKEY_RSA
case|:
block|{
name|RSA
modifier|*
name|rsa
init|=
name|NULL
decl_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_EVP_PKEY
argument_list|)
expr_stmt|;
name|rsa
operator|=
name|res
operator|->
name|pkey
operator|.
name|rsa
expr_stmt|;
name|res
operator|->
name|pkey
operator|.
name|rsa
operator|=
name|RSA_new
argument_list|()
expr_stmt|;
name|res
operator|->
name|pkey
operator|.
name|rsa
operator|->
name|n
operator|=
name|rsa
operator|->
name|n
expr_stmt|;
name|res
operator|->
name|pkey
operator|.
name|rsa
operator|->
name|e
operator|=
name|rsa
operator|->
name|e
expr_stmt|;
name|rsa
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
name|rsa
operator|->
name|e
operator|=
name|NULL
expr_stmt|;
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_EVP_PKEY
argument_list|)
expr_stmt|;
name|RSA_free
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_LOAD_PUBKEY
argument_list|,
name|HWCRHK_R_CTRL_COMMAND_NOT_IMPLEMENTED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
name|res
return|;
name|err
label|:
if|if
condition|(
name|res
condition|)
name|EVP_PKEY_free
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* A little mod_exp */
end_comment

begin_function
specifier|static
name|int
name|hwcrhk_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|char
name|tempbuf
index|[
literal|1024
index|]
decl_stmt|;
name|HWCryptoHook_ErrMsgBuf
name|rmsg
decl_stmt|;
comment|/*      * Since HWCryptoHook_MPI is pretty compatible with BIGNUM's, we use them      * directly, plus a little macro magic.  We only thing we need to make      * sure of is that enough space is allocated.      */
name|HWCryptoHook_MPI
name|m_a
decl_stmt|,
name|m_p
decl_stmt|,
name|m_n
decl_stmt|,
name|m_r
decl_stmt|;
name|int
name|to_return
decl_stmt|,
name|ret
decl_stmt|;
name|to_return
operator|=
literal|0
expr_stmt|;
comment|/* expect failure */
name|rmsg
operator|.
name|buf
operator|=
name|tempbuf
expr_stmt|;
name|rmsg
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hwcrhk_context
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_MOD_EXP
argument_list|,
name|HWCRHK_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Prepare the params */
name|bn_expand2
argument_list|(
name|r
argument_list|,
name|m
operator|->
name|top
argument_list|)
expr_stmt|;
comment|/* Check for error !! */
name|BN2MPI
argument_list|(
name|m_a
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|BN2MPI
argument_list|(
name|m_p
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|BN2MPI
argument_list|(
name|m_n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|MPI2BN
argument_list|(
name|r
argument_list|,
name|m_r
argument_list|)
expr_stmt|;
comment|/* Perform the operation */
name|ret
operator|=
name|p_hwcrhk_ModExp
argument_list|(
name|hwcrhk_context
argument_list|,
name|m_a
argument_list|,
name|m_p
argument_list|,
name|m_n
argument_list|,
operator|&
name|m_r
argument_list|,
operator|&
name|rmsg
argument_list|)
expr_stmt|;
comment|/* Convert the response */
name|r
operator|->
name|top
operator|=
name|m_r
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/*          * FIXME: When this error is returned, HWCryptoHook is telling us          * that falling back to software computation might be a good thing.          */
if|if
condition|(
name|ret
operator|==
name|HWCRYPTOHOOK_ERROR_FALLBACK
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_MOD_EXP
argument_list|,
name|HWCRHK_R_REQUEST_FALLBACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_MOD_EXP
argument_list|,
name|HWCRHK_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
block|}
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|rmsg
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|to_return
operator|=
literal|1
expr_stmt|;
name|err
label|:
return|return
name|to_return
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_function
specifier|static
name|int
name|hwcrhk_rsa_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|I
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|char
name|tempbuf
index|[
literal|1024
index|]
decl_stmt|;
name|HWCryptoHook_ErrMsgBuf
name|rmsg
decl_stmt|;
name|HWCryptoHook_RSAKeyHandle
modifier|*
name|hptr
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|,
name|ret
decl_stmt|;
name|rmsg
operator|.
name|buf
operator|=
name|tempbuf
expr_stmt|;
name|rmsg
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hwcrhk_context
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RSA_MOD_EXP
argument_list|,
name|HWCRHK_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/*      * This provides support for nForce keys.  Since that's opaque data all      * we do is provide a handle to the proper key and let HWCryptoHook take      * care of the rest.      */
if|if
condition|(
operator|(
name|hptr
operator|=
operator|(
name|HWCryptoHook_RSAKeyHandle
operator|*
operator|)
name|RSA_get_ex_data
argument_list|(
name|rsa
argument_list|,
name|hndidx_rsa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|HWCryptoHook_MPI
name|m_a
decl_stmt|,
name|m_r
decl_stmt|;
if|if
condition|(
operator|!
name|rsa
operator|->
name|n
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RSA_MOD_EXP
argument_list|,
name|HWCRHK_R_MISSING_KEY_COMPONENTS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Prepare the params */
name|bn_expand2
argument_list|(
name|r
argument_list|,
name|rsa
operator|->
name|n
operator|->
name|top
argument_list|)
expr_stmt|;
comment|/* Check for error !! */
name|BN2MPI
argument_list|(
name|m_a
argument_list|,
name|I
argument_list|)
expr_stmt|;
name|MPI2BN
argument_list|(
name|r
argument_list|,
name|m_r
argument_list|)
expr_stmt|;
comment|/* Perform the operation */
name|ret
operator|=
name|p_hwcrhk_RSA
argument_list|(
name|m_a
argument_list|,
operator|*
name|hptr
argument_list|,
operator|&
name|m_r
argument_list|,
operator|&
name|rmsg
argument_list|)
expr_stmt|;
comment|/* Convert the response */
name|r
operator|->
name|top
operator|=
name|m_r
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/*              * FIXME: When this error is returned, HWCryptoHook is telling us              * that falling back to software computation might be a good              * thing.              */
if|if
condition|(
name|ret
operator|==
name|HWCRYPTOHOOK_ERROR_FALLBACK
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RSA_MOD_EXP
argument_list|,
name|HWCRHK_R_REQUEST_FALLBACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RSA_MOD_EXP
argument_list|,
name|HWCRHK_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
block|}
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|rmsg
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
else|else
block|{
name|HWCryptoHook_MPI
name|m_a
decl_stmt|,
name|m_p
decl_stmt|,
name|m_q
decl_stmt|,
name|m_dmp1
decl_stmt|,
name|m_dmq1
decl_stmt|,
name|m_iqmp
decl_stmt|,
name|m_r
decl_stmt|;
if|if
condition|(
operator|!
name|rsa
operator|->
name|p
operator|||
operator|!
name|rsa
operator|->
name|q
operator|||
operator|!
name|rsa
operator|->
name|dmp1
operator|||
operator|!
name|rsa
operator|->
name|dmq1
operator|||
operator|!
name|rsa
operator|->
name|iqmp
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RSA_MOD_EXP
argument_list|,
name|HWCRHK_R_MISSING_KEY_COMPONENTS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Prepare the params */
name|bn_expand2
argument_list|(
name|r
argument_list|,
name|rsa
operator|->
name|n
operator|->
name|top
argument_list|)
expr_stmt|;
comment|/* Check for error !! */
name|BN2MPI
argument_list|(
name|m_a
argument_list|,
name|I
argument_list|)
expr_stmt|;
name|BN2MPI
argument_list|(
name|m_p
argument_list|,
name|rsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|BN2MPI
argument_list|(
name|m_q
argument_list|,
name|rsa
operator|->
name|q
argument_list|)
expr_stmt|;
name|BN2MPI
argument_list|(
name|m_dmp1
argument_list|,
name|rsa
operator|->
name|dmp1
argument_list|)
expr_stmt|;
name|BN2MPI
argument_list|(
name|m_dmq1
argument_list|,
name|rsa
operator|->
name|dmq1
argument_list|)
expr_stmt|;
name|BN2MPI
argument_list|(
name|m_iqmp
argument_list|,
name|rsa
operator|->
name|iqmp
argument_list|)
expr_stmt|;
name|MPI2BN
argument_list|(
name|r
argument_list|,
name|m_r
argument_list|)
expr_stmt|;
comment|/* Perform the operation */
name|ret
operator|=
name|p_hwcrhk_ModExpCRT
argument_list|(
name|hwcrhk_context
argument_list|,
name|m_a
argument_list|,
name|m_p
argument_list|,
name|m_q
argument_list|,
name|m_dmp1
argument_list|,
name|m_dmq1
argument_list|,
name|m_iqmp
argument_list|,
operator|&
name|m_r
argument_list|,
operator|&
name|rmsg
argument_list|)
expr_stmt|;
comment|/* Convert the response */
name|r
operator|->
name|top
operator|=
name|m_r
operator|.
name|size
operator|/
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
expr_stmt|;
name|bn_fix_top
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/*              * FIXME: When this error is returned, HWCryptoHook is telling us              * that falling back to software computation might be a good              * thing.              */
if|if
condition|(
name|ret
operator|==
name|HWCRYPTOHOOK_ERROR_FALLBACK
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RSA_MOD_EXP
argument_list|,
name|HWCRHK_R_REQUEST_FALLBACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RSA_MOD_EXP
argument_list|,
name|HWCRHK_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
block|}
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|rmsg
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
comment|/*      * If we're here, we must be here with some semblance of success :-)      */
name|to_return
operator|=
literal|1
expr_stmt|;
name|err
label|:
return|return
name|to_return
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_comment
comment|/* This function is aliased to mod_exp (with the mont stuff dropped). */
end_comment

begin_function
specifier|static
name|int
name|hwcrhk_mod_exp_mont
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
block|{
return|return
name|hwcrhk_mod_exp
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwcrhk_rsa_finish
parameter_list|(
name|RSA
modifier|*
name|rsa
parameter_list|)
block|{
name|HWCryptoHook_RSAKeyHandle
modifier|*
name|hptr
decl_stmt|;
name|hptr
operator|=
name|RSA_get_ex_data
argument_list|(
name|rsa
argument_list|,
name|hndidx_rsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|hptr
condition|)
block|{
name|p_hwcrhk_RSAUnloadKey
argument_list|(
operator|*
name|hptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|hptr
argument_list|)
expr_stmt|;
name|RSA_set_ex_data
argument_list|(
name|rsa
argument_list|,
name|hndidx_rsa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_comment
comment|/* This function is aliased to mod_exp (with the dh and mont dropped). */
end_comment

begin_function
specifier|static
name|int
name|hwcrhk_mod_exp_dh
parameter_list|(
specifier|const
name|DH
modifier|*
name|dh
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
block|{
return|return
name|hwcrhk_mod_exp
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Random bytes are good */
end_comment

begin_function
specifier|static
name|int
name|hwcrhk_rand_bytes
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|char
name|tempbuf
index|[
literal|1024
index|]
decl_stmt|;
name|HWCryptoHook_ErrMsgBuf
name|rmsg
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
comment|/* assume failure */
name|int
name|ret
decl_stmt|;
name|rmsg
operator|.
name|buf
operator|=
name|tempbuf
expr_stmt|;
name|rmsg
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hwcrhk_context
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RAND_BYTES
argument_list|,
name|HWCRHK_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
name|p_hwcrhk_RandomBytes
argument_list|(
name|hwcrhk_context
argument_list|,
name|buf
argument_list|,
name|num
argument_list|,
operator|&
name|rmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/*          * FIXME: When this error is returned, HWCryptoHook is telling us          * that falling back to software computation might be a good thing.          */
if|if
condition|(
name|ret
operator|==
name|HWCRYPTOHOOK_ERROR_FALLBACK
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RAND_BYTES
argument_list|,
name|HWCRHK_R_REQUEST_FALLBACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_RAND_BYTES
argument_list|,
name|HWCRHK_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
block|}
name|ERR_add_error_data
argument_list|(
literal|1
argument_list|,
name|rmsg
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|to_return
operator|=
literal|1
expr_stmt|;
name|err
label|:
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwcrhk_rand_status
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Mutex calls: since the HWCryptoHook model closely follows the POSIX model  * these just wrap the POSIX functions and add some logging.  */
end_comment

begin_function
specifier|static
name|int
name|hwcrhk_mutex_init
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|mt
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
name|cactx
parameter_list|)
block|{
name|mt
operator|->
name|lockid
operator|=
name|CRYPTO_get_new_dynlockid
argument_list|()
expr_stmt|;
if|if
condition|(
name|mt
operator|->
name|lockid
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* failure */
return|return
literal|0
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|int
name|hwcrhk_mutex_lock
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|mt
parameter_list|)
block|{
name|CRYPTO_w_lock
argument_list|(
name|mt
operator|->
name|lockid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hwcrhk_mutex_unlock
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|mt
parameter_list|)
block|{
name|CRYPTO_w_unlock
argument_list|(
name|mt
operator|->
name|lockid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hwcrhk_mutex_destroy
parameter_list|(
name|HWCryptoHook_Mutex
modifier|*
name|mt
parameter_list|)
block|{
name|CRYPTO_destroy_dynlockid
argument_list|(
name|mt
operator|->
name|lockid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwcrhk_get_pass
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt_info
parameter_list|,
name|int
modifier|*
name|len_io
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|HWCryptoHook_PassphraseContext
modifier|*
name|ppctx
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
name|cactx
parameter_list|)
block|{
name|pem_password_cb
modifier|*
name|callback
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|callback_data
init|=
name|NULL
decl_stmt|;
name|UI_METHOD
modifier|*
name|ui_method
init|=
name|NULL
decl_stmt|;
comment|/*      * Despite what the documentation says prompt_info can be an empty      * string.      */
if|if
condition|(
name|prompt_info
operator|&&
operator|!
operator|*
name|prompt_info
condition|)
name|prompt_info
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cactx
condition|)
block|{
if|if
condition|(
name|cactx
operator|->
name|ui_method
condition|)
name|ui_method
operator|=
name|cactx
operator|->
name|ui_method
expr_stmt|;
if|if
condition|(
name|cactx
operator|->
name|password_callback
condition|)
name|callback
operator|=
name|cactx
operator|->
name|password_callback
expr_stmt|;
if|if
condition|(
name|cactx
operator|->
name|callback_data
condition|)
name|callback_data
operator|=
name|cactx
operator|->
name|callback_data
expr_stmt|;
block|}
if|if
condition|(
name|ppctx
condition|)
block|{
if|if
condition|(
name|ppctx
operator|->
name|ui_method
condition|)
block|{
name|ui_method
operator|=
name|ppctx
operator|->
name|ui_method
expr_stmt|;
name|callback
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ppctx
operator|->
name|callback_data
condition|)
name|callback_data
operator|=
name|ppctx
operator|->
name|callback_data
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|==
name|NULL
operator|&&
name|ui_method
operator|==
name|NULL
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_GET_PASS
argument_list|,
name|HWCRHK_R_NO_CALLBACK
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ui_method
condition|)
block|{
name|UI
modifier|*
name|ui
init|=
name|UI_new_method
argument_list|(
name|ui_method
argument_list|)
decl_stmt|;
if|if
condition|(
name|ui
condition|)
block|{
name|int
name|ok
decl_stmt|;
name|char
modifier|*
name|prompt
init|=
name|UI_construct_prompt
argument_list|(
name|ui
argument_list|,
literal|"pass phrase"
argument_list|,
name|prompt_info
argument_list|)
decl_stmt|;
name|ok
operator|=
name|UI_add_input_string
argument_list|(
name|ui
argument_list|,
name|prompt
argument_list|,
name|UI_INPUT_FLAG_DEFAULT_PWD
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
operator|*
name|len_io
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|UI_add_user_data
argument_list|(
name|ui
argument_list|,
name|callback_data
argument_list|)
expr_stmt|;
name|UI_ctrl
argument_list|(
name|ui
argument_list|,
name|UI_CTRL_PRINT_ERRORS
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|>=
literal|0
condition|)
do|do
block|{
name|ok
operator|=
name|UI_process
argument_list|(
name|ui
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ok
operator|<
literal|0
operator|&&
name|UI_ctrl
argument_list|(
name|ui
argument_list|,
name|UI_CTRL_IS_REDOABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
do|;
if|if
condition|(
name|ok
operator|>=
literal|0
condition|)
operator|*
name|len_io
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|UI_free
argument_list|(
name|ui
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|len_io
operator|=
name|callback
argument_list|(
name|buf
argument_list|,
operator|*
name|len_io
argument_list|,
literal|0
argument_list|,
name|callback_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|len_io
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwcrhk_insert_card
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt_info
parameter_list|,
specifier|const
name|char
modifier|*
name|wrong_info
parameter_list|,
name|HWCryptoHook_PassphraseContext
modifier|*
name|ppctx
parameter_list|,
name|HWCryptoHook_CallerContext
modifier|*
name|cactx
parameter_list|)
block|{
name|int
name|ok
init|=
operator|-
literal|1
decl_stmt|;
name|UI
modifier|*
name|ui
decl_stmt|;
name|void
modifier|*
name|callback_data
init|=
name|NULL
decl_stmt|;
name|UI_METHOD
modifier|*
name|ui_method
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|cactx
condition|)
block|{
if|if
condition|(
name|cactx
operator|->
name|ui_method
condition|)
name|ui_method
operator|=
name|cactx
operator|->
name|ui_method
expr_stmt|;
if|if
condition|(
name|cactx
operator|->
name|callback_data
condition|)
name|callback_data
operator|=
name|cactx
operator|->
name|callback_data
expr_stmt|;
block|}
if|if
condition|(
name|ppctx
condition|)
block|{
if|if
condition|(
name|ppctx
operator|->
name|ui_method
condition|)
name|ui_method
operator|=
name|ppctx
operator|->
name|ui_method
expr_stmt|;
if|if
condition|(
name|ppctx
operator|->
name|callback_data
condition|)
name|callback_data
operator|=
name|ppctx
operator|->
name|callback_data
expr_stmt|;
block|}
if|if
condition|(
name|ui_method
operator|==
name|NULL
condition|)
block|{
name|HWCRHKerr
argument_list|(
name|HWCRHK_F_HWCRHK_INSERT_CARD
argument_list|,
name|HWCRHK_R_NO_CALLBACK
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ui
operator|=
name|UI_new_method
argument_list|(
name|ui_method
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui
condition|)
block|{
name|char
name|answer
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/*          * Despite what the documentation says wrong_info can be an empty          * string.          */
if|if
condition|(
name|wrong_info
operator|&&
operator|*
name|wrong_info
condition|)
name|BIO_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|,
literal|"Current card: \"%s\"\n"
argument_list|,
name|wrong_info
argument_list|)
expr_stmt|;
else|else
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ok
operator|=
name|UI_dup_info_string
argument_list|(
name|ui
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|>=
literal|0
operator|&&
name|prompt_info
condition|)
block|{
name|BIO_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|,
literal|"Insert card \"%s\""
argument_list|,
name|prompt_info
argument_list|)
expr_stmt|;
name|ok
operator|=
name|UI_dup_input_boolean
argument_list|(
name|ui
argument_list|,
name|buf
argument_list|,
literal|"\n then hit<enter> or C<enter> to cancel\n"
argument_list|,
literal|"\r\n"
argument_list|,
literal|"Cc"
argument_list|,
name|UI_INPUT_FLAG_ECHO
argument_list|,
operator|&
name|answer
argument_list|)
expr_stmt|;
block|}
name|UI_add_user_data
argument_list|(
name|ui
argument_list|,
name|callback_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|>=
literal|0
condition|)
name|ok
operator|=
name|UI_process
argument_list|(
name|ui
argument_list|)
expr_stmt|;
name|UI_free
argument_list|(
name|ui
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
operator|-
literal|2
operator|||
operator|(
name|ok
operator|>=
literal|0
operator|&&
name|answer
operator|==
literal|'C'
operator|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ok
operator|<
literal|0
condition|)
name|ok
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|ok
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hwcrhk_log_message
parameter_list|(
name|void
modifier|*
name|logstr
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|BIO
modifier|*
name|lstream
init|=
name|NULL
decl_stmt|;
name|CRYPTO_w_lock
argument_list|(
name|CRYPTO_LOCK_BIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|logstr
condition|)
name|lstream
operator|=
operator|*
operator|(
name|BIO
operator|*
operator|*
operator|)
name|logstr
expr_stmt|;
if|if
condition|(
name|lstream
condition|)
block|{
name|BIO_printf
argument_list|(
name|lstream
argument_list|,
literal|"%s\n"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
name|CRYPTO_w_unlock
argument_list|(
name|CRYPTO_LOCK_BIO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This stuff is needed if this ENGINE is being compiled into a  * self-contained shared-library.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DYNAMIC_ENGINE
end_ifndef

begin_function
specifier|static
name|int
name|bind_fn
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|&&
operator|(
name|strcmp
argument_list|(
name|id
argument_list|,
name|engine_hwcrhk_id
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|id
argument_list|,
name|engine_hwcrhk_id_alt
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|bind_helper
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_macro
name|IMPLEMENT_DYNAMIC_CHECK_FN
argument_list|()
end_macro

begin_macro
name|IMPLEMENT_DYNAMIC_BIND_FN
argument_list|(
argument|bind_fn
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL_NO_DYNAMIC_ENGINE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_HW_CHIL */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_HW */
end_comment

end_unit

