begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**********************************************************************  *                          keywrap.c                                 *  *             Copyright (c) 2005-2006 Cryptocom LTD                  *  *         This file is distributed under the same license as OpenSSL *  *                                                                    *  * Implementation of CryptoPro key wrap algorithm, as defined in      *  *               RFC 4357 p 6.3 and 6.4                               *  *                  Doesn't need OpenSSL                              *  **********************************************************************/
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"gost89.h"
end_include

begin_include
include|#
directive|include
file|"gost_keywrap.h"
end_include

begin_comment
comment|/* Diversifies key using random UserKey Material  * Implements RFC 4357 p 6.5 key diversification algorithm   *   * inputKey - 32byte key to be diversified  * ukm - 8byte user key material  * outputKey - 32byte buffer to store diversified key   *  */
end_comment

begin_function
name|void
name|keyDiversifyCryptoPro
parameter_list|(
name|gost_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|inputKey
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|ukm
parameter_list|,
name|unsigned
name|char
modifier|*
name|outputKey
parameter_list|)
block|{
name|u4
name|k
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|mask
decl_stmt|;
name|unsigned
name|char
name|S
index|[
literal|8
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|outputKey
argument_list|,
name|inputKey
argument_list|,
literal|32
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
comment|/* Make array of integers from key */
comment|/* Compute IV S*/
name|s1
operator|=
literal|0
operator|,
name|s2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|mask
operator|=
literal|1
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
operator|,
name|mask
operator|<<=
literal|1
control|)
block|{
name|k
operator|=
operator|(
operator|(
name|u4
operator|)
name|outputKey
index|[
literal|4
operator|*
name|j
index|]
operator|)
operator||
operator|(
name|outputKey
index|[
literal|4
operator|*
name|j
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|outputKey
index|[
literal|4
operator|*
name|j
operator|+
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|outputKey
index|[
literal|4
operator|*
name|j
operator|+
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|ukm
index|[
name|i
index|]
condition|)
block|{
name|s1
operator|+=
name|k
expr_stmt|;
block|}
else|else
block|{
name|s2
operator|+=
name|k
expr_stmt|;
block|}
block|}
name|S
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|s1
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|S
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|s1
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|S
index|[
literal|2
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|s1
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|S
index|[
literal|3
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|s1
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|S
index|[
literal|4
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|s2
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|S
index|[
literal|5
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|s2
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|S
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|s2
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|S
index|[
literal|7
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|s2
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|gost_key
argument_list|(
name|ctx
argument_list|,
name|outputKey
argument_list|)
expr_stmt|;
name|gost_enc_cfb
argument_list|(
name|ctx
argument_list|,
name|S
argument_list|,
name|outputKey
argument_list|,
name|outputKey
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Wraps key using RFC 4357 6.3  * ctx - gost encryption context, initialized with some S-boxes   * keyExchangeKey (KEK) 32-byte (256-bit) shared key  * ukm - 8 byte (64 bit) user key material,   * sessionKey - 32-byte (256-bit) key to be wrapped  * wrappedKey - 44-byte buffer to store wrapped key  */
end_comment

begin_function
name|int
name|keyWrapCryptoPro
parameter_list|(
name|gost_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|keyExchangeKey
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|ukm
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sessionKey
parameter_list|,
name|unsigned
name|char
modifier|*
name|wrappedKey
parameter_list|)
block|{
name|unsigned
name|char
name|kek_ukm
index|[
literal|32
index|]
decl_stmt|;
name|keyDiversifyCryptoPro
argument_list|(
name|ctx
argument_list|,
name|keyExchangeKey
argument_list|,
name|ukm
argument_list|,
name|kek_ukm
argument_list|)
expr_stmt|;
name|gost_key
argument_list|(
name|ctx
argument_list|,
name|kek_ukm
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|wrappedKey
argument_list|,
name|ukm
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|gost_enc
argument_list|(
name|ctx
argument_list|,
name|sessionKey
argument_list|,
name|wrappedKey
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gost_mac_iv
argument_list|(
name|ctx
argument_list|,
literal|32
argument_list|,
name|ukm
argument_list|,
name|sessionKey
argument_list|,
literal|32
argument_list|,
name|wrappedKey
operator|+
literal|40
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Unwraps key using RFC 4357 6.4  * ctx - gost encryption context, initialized with some S-boxes   * keyExchangeKey 32-byte shared key  * wrappedKey  44 byte key to be unwrapped (concatenation of 8-byte UKM,  * 32 byte  encrypted key and 4 byte MAC    *   * sessionKEy - 32byte buffer to store sessionKey in  * Returns 1 if key is decrypted successfully, and 0 if MAC doesn't match  */
end_comment

begin_function
name|int
name|keyUnwrapCryptoPro
parameter_list|(
name|gost_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|keyExchangeKey
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|wrappedKey
parameter_list|,
name|unsigned
name|char
modifier|*
name|sessionKey
parameter_list|)
block|{
name|unsigned
name|char
name|kek_ukm
index|[
literal|32
index|]
decl_stmt|,
name|cek_mac
index|[
literal|4
index|]
decl_stmt|;
name|keyDiversifyCryptoPro
argument_list|(
name|ctx
argument_list|,
name|keyExchangeKey
argument_list|,
name|wrappedKey
comment|/* First 8 bytes of wrapped Key is ukm */
argument_list|,
name|kek_ukm
argument_list|)
expr_stmt|;
name|gost_key
argument_list|(
name|ctx
argument_list|,
name|kek_ukm
argument_list|)
expr_stmt|;
name|gost_dec
argument_list|(
name|ctx
argument_list|,
name|wrappedKey
operator|+
literal|8
argument_list|,
name|sessionKey
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gost_mac_iv
argument_list|(
name|ctx
argument_list|,
literal|32
argument_list|,
name|wrappedKey
argument_list|,
name|sessionKey
argument_list|,
literal|32
argument_list|,
name|cek_mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|cek_mac
argument_list|,
name|wrappedKey
operator|+
literal|40
argument_list|,
literal|4
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

