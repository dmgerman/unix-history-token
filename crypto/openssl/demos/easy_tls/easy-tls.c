begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* -*- Mode: C; c-file-style: "bsd" -*- */
end_comment

begin_comment
comment|/*-  * easy-tls.c -- generic TLS proxy.  * $Id: easy-tls.c,v 1.4 2002/03/05 09:07:16 bodo Exp $  */
end_comment

begin_comment
comment|/*-  (c) Copyright 1999 Bodo Moeller.  All rights reserved.   This is free software; you can redistributed and/or modify it  unter the terms of either    -  the GNU General Public License as published by the       Free Software Foundation, version 1, or (at your option)       any later version,  or    -  the following license: */
end_comment

begin_comment
comment|/*-  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that each of the following  * conditions is met:  *  * 1. Redistributions qualify as "freeware" or "Open Source Software" under  *    one of the following terms:  *  *    (a) Redistributions are made at no charge beyond the reasonable cost of  *        materials and delivery.  *  *    (b) Redistributions are accompanied by a copy of the Source Code  *        or by an irrevocable offer to provide a copy of the Source Code  *        for up to three years at the cost of materials and delivery.  *        Such redistributions must allow further use, modification, and  *        redistribution of the Source Code under substantially the same  *        terms as this license.  *  * 2. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 3. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 4. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by Bodo Moeller."  *    (If available, substitute umlauted o for oe.)  *  * 5. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by Bodo Moeller."  *  * THIS SOFTWARE IS PROVIDED BY BODO MOELLER ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL BODO MOELLER OR  * HIS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Attribution for OpenSSL library:  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  * This product includes software developed by the OpenSSL Project  * for use in the OpenSSL Toolkit. (http://www.openssl.org/)  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|rcsid
index|[]
init|=
literal|"$Id: easy-tls.c,v 1.4 2002/03/05 09:07:16 bodo Exp $"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/dh.h>
end_include

begin_include
include|#
directive|include
file|<openssl/dsa.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/opensslv.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_RSA
end_ifndef

begin_include
include|#
directive|include
file|<openssl/rsa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509_vfy.h>
end_include

begin_if
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|<
literal|0x00904000L
end_if

begin_comment
comment|/* 0.9.4-dev */
end_comment

begin_error
error|#
directive|error
literal|"This program needs OpenSSL 0.9.4 or later."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"easy-tls.h"
end_include

begin_comment
comment|/* include after<openssl/ssl.h> if both are                                  * needed */
end_comment

begin_if
if|#
directive|if
name|TLS_INFO_SIZE
operator|>
name|PIPE_BUF
end_if

begin_if
if|#
directive|if
name|PIPE_BUF
operator|<
literal|512
end_if

begin_error
error|#
directive|error
literal|"PIPE_BUF< 512"
end_error

begin_comment
comment|/* non-POSIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_error
error|#
directive|error
literal|"TLS_INFO_SIZE> PIPE_BUF"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TLS_APP
end_ifdef

begin_include
include|#
directive|include
include|TLS_APP
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  * Applications can define:  *   TLS_APP_PROCESS_INIT -- void ...(int fd, int client_p, void *apparg)  *   TLS_CUMULATE_ERRORS  *   TLS_ERROR_BUFSIZ  *   TLS_APP_ERRFLUSH -- void ...(int child_p, char *, size_t, void *apparg)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TLS_APP_PROCESS_INIT
end_ifndef

begin_define
define|#
directive|define
name|TLS_APP_PROCESS_INIT
parameter_list|(
name|fd
parameter_list|,
name|client_p
parameter_list|,
name|apparg
parameter_list|)
value|((void) 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TLS_ERROR_BUFSIZ
end_ifndef

begin_define
define|#
directive|define
name|TLS_ERROR_BUFSIZ
value|(10*160)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TLS_ERROR_BUFSIZ
operator|<
literal|2
end_if

begin_comment
comment|/* {'\n',0} */
end_comment

begin_error
error|#
directive|error
literal|"TLS_ERROR_BUFSIZE is too small."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TLS_APP_ERRFLUSH
end_ifndef

begin_define
define|#
directive|define
name|TLS_APP_ERRFLUSH
value|tls_app_errflush
end_define

begin_function
specifier|static
name|void
name|tls_app_errflush
parameter_list|(
name|int
name|child_p
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|size_t
name|num
parameter_list|,
name|void
modifier|*
name|apparg
parameter_list|)
block|{
name|fputs
argument_list|(
name|errbuf
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_TLS
end_ifdef

begin_define
define|#
directive|define
name|DEBUG_MSG
parameter_list|(
name|x
parameter_list|)
value|fprintf(stderr,"  %s\n",x)
end_define

begin_define
define|#
directive|define
name|DEBUG_MSG2
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|fprintf(stderr, "  %s: %d\n",x,y)
end_define

begin_decl_stmt
specifier|static
name|int
name|tls_loop_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tls_select_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEBUG_MSG
parameter_list|(
name|x
parameter_list|)
value|(void)0
end_define

begin_define
define|#
directive|define
name|DEBUG_MSG2
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(void)0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|tls_rand_seed_uniquely
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tls_proxy
parameter_list|(
name|int
name|clear_fd
parameter_list|,
name|int
name|tls_fd
parameter_list|,
name|int
name|info_fd
parameter_list|,
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|int
name|client_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tls_socket_nonblocking
parameter_list|(
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|tls_child_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|tls_child_apparg
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|tls_start_proxy_args
name|tls_start_proxy_defaultargs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tls_start_proxy_args
name|ret
decl_stmt|;
name|ret
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|.
name|client_p
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|.
name|ctx
operator|=
name|NULL
expr_stmt|;
name|ret
operator|.
name|pid
operator|=
name|NULL
expr_stmt|;
name|ret
operator|.
name|infofd
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*-  * Slice in TLS proxy process at fd.  * Return value:  *   0    ok  (*pid is set to child's PID if pid != NULL),  *< 0  look at errno  *> 0  other error  *   (return value encodes place of error)  *  */
end_comment

begin_function
name|int
name|tls_start_proxy
parameter_list|(
name|struct
name|tls_start_proxy_args
name|a
parameter_list|,
name|void
modifier|*
name|apparg
parameter_list|)
block|{
name|int
name|fds
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|int
name|infofds
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|int
name|r
decl_stmt|,
name|getfd
decl_stmt|,
name|getfl
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DEBUG_MSG2
argument_list|(
literal|"tls_start_proxy fd"
argument_list|,
name|a
operator|.
name|fd
argument_list|)
expr_stmt|;
name|DEBUG_MSG2
argument_list|(
literal|"tls_start_proxy client_p"
argument_list|,
name|a
operator|.
name|client_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|.
name|fd
operator|==
operator|-
literal|1
operator|||
name|a
operator|.
name|client_p
operator|==
operator|-
literal|1
operator|||
name|a
operator|.
name|ctx
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|.
name|pid
operator|!=
name|NULL
condition|)
block|{
operator|*
name|a
operator|.
name|pid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|.
name|infofd
operator|!=
name|NULL
condition|)
block|{
operator|*
name|a
operator|.
name|infofd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|r
operator|=
name|socketpair
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|.
name|fd
operator|>=
name|FD_SETSIZE
operator|||
name|fds
index|[
literal|0
index|]
operator|>=
name|FD_SETSIZE
condition|)
block|{
name|ret
operator|=
literal|2
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|a
operator|.
name|infofd
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|pipe
argument_list|(
name|infofds
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
operator|-
literal|3
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|r
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
operator|-
literal|4
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|DEBUG_MSG
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|tls_child_p
operator|=
literal|1
expr_stmt|;
name|tls_child_apparg
operator|=
name|apparg
expr_stmt|;
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|infofds
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|infofds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|TLS_APP_PROCESS_INIT
argument_list|(
name|a
operator|.
name|fd
argument_list|,
name|a
operator|.
name|client_p
argument_list|,
name|apparg
argument_list|)
expr_stmt|;
name|DEBUG_MSG
argument_list|(
literal|"TLS_APP_PROCESS_INIT"
argument_list|)
expr_stmt|;
name|tls_proxy
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|,
name|a
operator|.
name|fd
argument_list|,
name|infofds
index|[
literal|1
index|]
argument_list|,
name|a
operator|.
name|ctx
argument_list|,
name|a
operator|.
name|client_p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|.
name|pid
operator|!=
name|NULL
condition|)
operator|*
name|a
operator|.
name|pid
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|infofds
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|infofds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|infofds
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* install fds[1] in place of fd: */
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fds
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|getfd
operator|=
name|fcntl
argument_list|(
name|a
operator|.
name|fd
argument_list|,
name|F_GETFD
argument_list|)
expr_stmt|;
name|getfl
operator|=
name|fcntl
argument_list|(
name|a
operator|.
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
name|r
operator|=
name|dup2
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|,
name|a
operator|.
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fds
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
operator|-
literal|5
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|getfd
operator|!=
literal|1
condition|)
name|fcntl
argument_list|(
name|a
operator|.
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|getfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|getfl
operator|&
name|O_NONBLOCK
condition|)
operator|(
name|void
operator|)
name|tls_socket_nonblocking
argument_list|(
name|a
operator|.
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|.
name|infofd
operator|!=
name|NULL
condition|)
operator|*
name|a
operator|.
name|infofd
operator|=
name|infofds
index|[
literal|0
index|]
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
if|if
condition|(
name|fds
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|infofds
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|infofds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|infofds
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|infofds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
name|errbuf
index|[
name|TLS_ERROR_BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|errbuf_i
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tls_errflush
parameter_list|(
name|void
modifier|*
name|apparg
parameter_list|)
block|{
if|if
condition|(
name|errbuf_i
operator|==
literal|0
condition|)
return|return;
name|assert
argument_list|(
name|errbuf_i
operator|<
sizeof|sizeof
name|errbuf
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|errbuf
index|[
name|errbuf_i
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errbuf_i
operator|==
sizeof|sizeof
name|errbuf
operator|-
literal|1
condition|)
block|{
comment|/* make sure we have a newline, even if string has been truncated */
name|errbuf
index|[
name|errbuf_i
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
comment|/*      * TLS_APP_ERRFLUSH may modify the string as needed, e.g. substitute      * other characters for \n for convenience      */
name|TLS_APP_ERRFLUSH
argument_list|(
name|tls_child_p
argument_list|,
name|errbuf
argument_list|,
name|errbuf_i
argument_list|,
name|apparg
argument_list|)
expr_stmt|;
name|errbuf_i
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tls_errprintf
parameter_list|(
name|int
name|flush
parameter_list|,
name|void
modifier|*
name|apparg
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|errbuf_i
operator|<
sizeof|sizeof
name|errbuf
operator|-
literal|1
condition|)
block|{
name|size_t
name|n
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
sizeof|sizeof
name|errbuf
operator|)
operator|-
name|errbuf_i
expr_stmt|;
name|r
operator|=
name|vsnprintf
argument_list|(
name|errbuf
operator|+
name|errbuf_i
argument_list|,
name|n
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|n
condition|)
name|r
operator|=
name|n
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
block|{
name|errbuf_i
operator|+=
name|r
expr_stmt|;
block|}
else|else
block|{
name|errbuf_i
operator|=
sizeof|sizeof
name|errbuf
operator|-
literal|1
expr_stmt|;
name|errbuf
index|[
name|errbuf_i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|assert
argument_list|(
name|errbuf_i
operator|<
sizeof|sizeof
name|errbuf
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|errbuf
index|[
name|errbuf_i
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|TLS_CUMULATE_ERRORS
name|tls_errflush
argument_list|(
name|apparg
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|flush
condition|)
name|tls_errflush
argument_list|(
name|apparg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * app_prefix.. are for additional information provided by caller. If OpenSSL  * error queue is empty, print default_text ("???" if NULL).  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|tls_openssl_errors
parameter_list|(
specifier|const
name|char
modifier|*
name|app_prefix_1
parameter_list|,
specifier|const
name|char
modifier|*
name|app_prefix_2
parameter_list|,
specifier|const
name|char
modifier|*
name|default_text
parameter_list|,
name|void
modifier|*
name|apparg
parameter_list|)
block|{
specifier|static
name|char
name|reasons
index|[
literal|255
index|]
decl_stmt|;
name|size_t
name|reasons_i
decl_stmt|;
name|unsigned
name|long
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
modifier|*
name|errstring
decl_stmt|;
name|int
name|printed_something
init|=
literal|0
decl_stmt|;
name|reasons_i
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|app_prefix_1
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|app_prefix_2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_text
operator|==
name|NULL
condition|)
name|default_text
operator|=
literal|"?"
literal|"?"
literal|"?"
expr_stmt|;
while|while
condition|(
operator|(
name|err
operator|=
name|ERR_get_error_line_data
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|flags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|reasons_i
operator|<
sizeof|sizeof
name|reasons
condition|)
block|{
name|size_t
name|n
decl_stmt|;
name|int
name|r
decl_stmt|;
name|n
operator|=
operator|(
sizeof|sizeof
name|reasons
operator|)
operator|-
name|reasons_i
expr_stmt|;
name|r
operator|=
name|snprintf
argument_list|(
name|reasons
operator|+
name|reasons_i
argument_list|,
name|n
argument_list|,
literal|"%s%s"
argument_list|,
operator|(
name|reasons_i
operator|>
literal|0
condition|?
literal|", "
else|:
literal|""
operator|)
argument_list|,
name|ERR_reason_error_string
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|n
condition|)
name|r
operator|=
name|n
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
block|{
name|reasons_i
operator|+=
name|r
expr_stmt|;
block|}
else|else
block|{
name|reasons_i
operator|=
sizeof|sizeof
name|reasons
expr_stmt|;
block|}
name|assert
argument_list|(
name|reasons_i
operator|<=
sizeof|sizeof
name|reasons
argument_list|)
expr_stmt|;
block|}
name|errstring
operator|=
name|ERR_error_string
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|errstring
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tls_errprintf
argument_list|(
literal|0
argument_list|,
name|apparg
argument_list|,
literal|"OpenSSL error%s%s: %s:%s:%d:%s\n"
argument_list|,
name|app_prefix_1
argument_list|,
name|app_prefix_2
argument_list|,
name|errstring
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
operator|(
name|flags
operator|&
name|ERR_TXT_STRING
operator|)
condition|?
name|data
else|:
literal|""
argument_list|)
expr_stmt|;
name|printed_something
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|printed_something
condition|)
block|{
name|assert
argument_list|(
name|reasons_i
operator|==
literal|0
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|reasons
argument_list|,
sizeof|sizeof
name|reasons
argument_list|,
literal|"%s"
argument_list|,
name|default_text
argument_list|)
expr_stmt|;
name|tls_errprintf
argument_list|(
literal|0
argument_list|,
name|apparg
argument_list|,
literal|"OpenSSL error%s%s: %s\n"
argument_list|,
name|app_prefix_1
argument_list|,
name|app_prefix_2
argument_list|,
name|default_text
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TLS_CUMULATE_ERRORS
name|tls_errflush
argument_list|(
name|apparg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|errbuf_i
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|reasons
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|int
name|tls_init_done
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|tls_init
parameter_list|(
name|void
modifier|*
name|apparg
parameter_list|)
block|{
if|if
condition|(
name|tls_init_done
condition|)
return|return
literal|0
return|;
name|SSL_load_error_strings
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_library_init
argument_list|()
comment|/* aka SSLeay_add_ssl_algorithms() */
condition|)
block|{
name|tls_errprintf
argument_list|(
literal|1
argument_list|,
name|apparg
argument_list|,
literal|"SSL_library_init failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|tls_init_done
operator|=
literal|1
expr_stmt|;
name|tls_rand_seed
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|tls_rand_seed_uniquely
parameter_list|(
name|void
parameter_list|)
block|{
struct|struct
block|{
name|pid_t
name|pid
decl_stmt|;
name|time_t
name|time
decl_stmt|;
name|void
modifier|*
name|stack
decl_stmt|;
block|}
name|data
struct|;
name|data
operator|.
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|data
operator|.
name|time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|data
operator|.
name|stack
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|data
expr_stmt|;
name|RAND_seed
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tls_rand_seed
parameter_list|(
name|void
parameter_list|)
block|{
struct|struct
block|{
name|struct
name|utsname
name|uname
decl_stmt|;
name|int
name|uname_1
decl_stmt|;
name|int
name|uname_2
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|uid_t
name|euid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|gid_t
name|egid
decl_stmt|;
block|}
name|data
struct|;
name|data
operator|.
name|uname_1
operator|=
name|uname
argument_list|(
operator|&
name|data
operator|.
name|uname
argument_list|)
expr_stmt|;
name|data
operator|.
name|uname_2
operator|=
name|errno
expr_stmt|;
comment|/* Let's hope that uname fails randomly :-) */
name|data
operator|.
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|data
operator|.
name|euid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|data
operator|.
name|gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|data
operator|.
name|egid
operator|=
name|getegid
argument_list|()
expr_stmt|;
name|RAND_seed
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
name|tls_rand_seed_uniquely
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|tls_rand_seeded_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|my_MIN_SEED_BYTES
value|256
end_define

begin_comment
comment|/* struct stat can be larger than 128 */
end_comment

begin_function
name|int
name|tls_rand_seed_from_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|size_t
name|n
parameter_list|,
name|void
modifier|*
name|apparg
parameter_list|)
block|{
comment|/*      * Seed OpenSSL's random number generator from file. Try to read n bytes      * if n> 0, whole file if n == 0.      */
name|int
name|r
decl_stmt|;
if|if
condition|(
name|tls_init
argument_list|(
name|apparg
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|tls_rand_seed
argument_list|()
expr_stmt|;
name|r
operator|=
name|RAND_load_file
argument_list|(
name|filename
argument_list|,
operator|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|<
name|LONG_MAX
operator|)
condition|?
operator|(
name|long
operator|)
name|n
else|:
name|LONG_MAX
argument_list|)
expr_stmt|;
comment|/*      * r is the number of bytes filled into the random number generator,      * which are taken from "stat(filename, ...)" in addition to the file      * contents.      */
name|assert
argument_list|(
literal|1
operator|<
name|my_MIN_SEED_BYTES
argument_list|)
expr_stmt|;
comment|/*      * We need to detect at least those cases when the file does not exist at      * all.  With current versions of OpenSSL, this should do it:      */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
name|my_MIN_SEED_BYTES
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|n
condition|)
block|{
name|tls_errprintf
argument_list|(
literal|1
argument_list|,
name|apparg
argument_list|,
literal|"rand_seed_from_file: could not read %d bytes from %s.\n"
argument_list|,
name|n
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|tls_rand_seeded_p
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|void
name|tls_rand_seed_from_memory
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|size_t
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|size_t
name|rest
init|=
name|n
operator|-
name|i
decl_stmt|;
name|int
name|chunk
init|=
name|rest
operator|<
name|INT_MAX
condition|?
operator|(
name|int
operator|)
name|rest
else|:
name|INT_MAX
decl_stmt|;
name|RAND_seed
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
operator|+
name|i
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|i
operator|+=
name|chunk
expr_stmt|;
block|}
name|tls_rand_seeded_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_struct
struct|struct
name|tls_x509_name_string
block|{
name|char
name|str
index|[
literal|100
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|tls_get_x509_subject_name_oneline
parameter_list|(
name|X509
modifier|*
name|cert
parameter_list|,
name|struct
name|tls_x509_name_string
modifier|*
name|namestring
parameter_list|)
block|{
name|X509_NAME
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|cert
operator|==
name|NULL
condition|)
block|{
name|namestring
operator|->
name|str
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|X509_get_subject_name
argument_list|(
name|cert
argument_list|)
expr_stmt|;
comment|/* does not increment any reference                                          * counter */
name|assert
argument_list|(
sizeof|sizeof
name|namestring
operator|->
name|str
operator|>=
literal|4
argument_list|)
expr_stmt|;
comment|/* "?" or "...", plus 0 */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|namestring
operator|->
name|str
index|[
literal|0
index|]
operator|=
literal|'?'
expr_stmt|;
name|namestring
operator|->
name|str
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|len
decl_stmt|;
name|X509_NAME_oneline
argument_list|(
name|name
argument_list|,
name|namestring
operator|->
name|str
argument_list|,
sizeof|sizeof
name|namestring
operator|->
name|str
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|namestring
operator|->
name|str
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|namestring
operator|->
name|str
index|[
name|len
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|len
operator|<
sizeof|sizeof
name|namestring
operator|->
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|==
sizeof|sizeof
name|namestring
operator|->
name|str
condition|)
block|{
comment|/*              * (Probably something was cut off.) Does not really work --              * X509_NAME_oneline truncates after name components, we cannot              * tell from the result whether anything is missing.              */
name|assert
argument_list|(
name|namestring
operator|->
name|str
index|[
name|len
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|namestring
operator|->
name|str
index|[
operator|--
name|len
index|]
operator|=
literal|'.'
expr_stmt|;
name|namestring
operator|->
name|str
index|[
operator|--
name|len
index|]
operator|=
literal|'.'
expr_stmt|;
name|namestring
operator|->
name|str
index|[
operator|--
name|len
index|]
operator|=
literal|'.'
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/* to hinder OpenSSL from asking for passphrases */
end_comment

begin_function
specifier|static
name|int
name|no_passphrase_callback
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|w
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x00907000L
end_if

begin_decl_stmt
specifier|static
name|int
name|verify_dont_fail_cb
argument_list|(
name|X509_STORE_CTX
operator|*
name|c
argument_list|,
name|void
operator|*
name|unused_arg
argument_list|)
else|#
directive|else
decl|static
name|int
name|verify_dont_fail_cb
argument_list|(
name|X509_STORE_CTX
operator|*
name|c
argument_list|)
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|X509_verify_cert
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* sets c->error */
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x00905000L
comment|/* don't allow unverified                                            * certificates -- they could                                            * survive session reuse, but                                            * OpenSSL< 0.9.5-dev does not                                            * preserve their verify_result */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
literal|1
return|;
else|else
endif|#
directive|endif
return|return
name|i
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|DH
modifier|*
name|tls_dhe1024
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* generating these takes a while, so do it                                  * just once */
end_comment

begin_function
name|void
name|tls_set_dhe1024
parameter_list|(
name|int
name|i
parameter_list|,
name|void
modifier|*
name|apparg
parameter_list|)
block|{
name|DSA
modifier|*
name|dsaparams
decl_stmt|;
name|DH
modifier|*
name|dhparams
decl_stmt|;
specifier|const
name|char
modifier|*
name|seed
index|[]
init|=
block|{
literal|";-)  :-(  :-)  :-(  "
block|,
literal|";-)  :-(  :-)  :-(  "
block|,
literal|"Random String no. 12"
block|,
literal|";-)  :-(  :-)  :-(  "
block|,
literal|"hackers have even mo"
block|,
comment|/* from jargon file */
block|}
decl_stmt|;
name|unsigned
name|char
name|seedbuf
index|[
literal|20
index|]
decl_stmt|;
name|tls_init
argument_list|(
name|apparg
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|i
operator|%=
sizeof|sizeof
name|seed
operator|/
sizeof|sizeof
name|seed
index|[
literal|0
index|]
expr_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|seed
index|[
name|i
index|]
argument_list|)
operator|==
literal|20
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|seedbuf
argument_list|,
name|seed
index|[
name|i
index|]
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|dsaparams
operator|=
name|DSA_generate_parameters
argument_list|(
literal|1024
argument_list|,
name|seedbuf
argument_list|,
literal|20
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* random parameters (may take a while) */
name|dsaparams
operator|=
name|DSA_generate_parameters
argument_list|(
literal|1024
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dsaparams
operator|==
name|NULL
condition|)
block|{
name|tls_openssl_errors
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|,
name|apparg
argument_list|)
expr_stmt|;
return|return;
block|}
name|dhparams
operator|=
name|DSA_dup_DH
argument_list|(
name|dsaparams
argument_list|)
expr_stmt|;
name|DSA_free
argument_list|(
name|dsaparams
argument_list|)
expr_stmt|;
if|if
condition|(
name|dhparams
operator|==
name|NULL
condition|)
block|{
name|tls_openssl_errors
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|,
name|apparg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tls_dhe1024
operator|!=
name|NULL
condition|)
name|DH_free
argument_list|(
name|tls_dhe1024
argument_list|)
expr_stmt|;
name|tls_dhe1024
operator|=
name|dhparams
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|tls_create_ctx_args
name|tls_create_ctx_defaultargs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tls_create_ctx_args
name|ret
decl_stmt|;
name|ret
operator|.
name|client_p
operator|=
literal|0
expr_stmt|;
name|ret
operator|.
name|certificate_file
operator|=
name|NULL
expr_stmt|;
name|ret
operator|.
name|key_file
operator|=
name|NULL
expr_stmt|;
name|ret
operator|.
name|ca_file
operator|=
name|NULL
expr_stmt|;
name|ret
operator|.
name|verify_depth
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|.
name|fail_unless_verified
operator|=
literal|0
expr_stmt|;
name|ret
operator|.
name|export_p
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|SSL_CTX
modifier|*
name|tls_create_ctx
parameter_list|(
name|struct
name|tls_create_ctx_args
name|a
parameter_list|,
name|void
modifier|*
name|apparg
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
specifier|static
name|long
name|context_num
init|=
literal|0
decl_stmt|;
name|SSL_CTX
modifier|*
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|err_pref_1
init|=
literal|""
decl_stmt|,
modifier|*
name|err_pref_2
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|tls_init
argument_list|(
name|apparg
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
name|SSL_CTX_new
argument_list|(
operator|(
name|a
operator|.
name|client_p
condition|?
name|SSLv23_client_method
else|:
name|SSLv23_server_method
operator|)
operator|(
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|SSL_CTX_set_default_passwd_cb
argument_list|(
name|ret
argument_list|,
name|no_passphrase_callback
argument_list|)
expr_stmt|;
name|SSL_CTX_set_mode
argument_list|(
name|ret
argument_list|,
name|SSL_MODE_ENABLE_PARTIAL_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|.
name|certificate_file
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|a
operator|.
name|key_file
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|a
operator|.
name|key_file
operator|==
name|NULL
condition|)
block|{
name|tls_errprintf
argument_list|(
literal|1
argument_list|,
name|apparg
argument_list|,
literal|"Need a key file.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_return
goto|;
block|}
if|if
condition|(
name|a
operator|.
name|certificate_file
operator|==
name|NULL
condition|)
block|{
name|tls_errprintf
argument_list|(
literal|1
argument_list|,
name|apparg
argument_list|,
literal|"Need a certificate chain file.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_return
goto|;
block|}
if|if
condition|(
operator|!
name|SSL_CTX_use_PrivateKey_file
argument_list|(
name|ret
argument_list|,
name|a
operator|.
name|key_file
argument_list|,
name|SSL_FILETYPE_PEM
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|tls_rand_seeded_p
condition|)
block|{
comment|/*              * particularly paranoid people may not like this -- so provide              * your own random seeding before calling this              */
if|if
condition|(
name|tls_rand_seed_from_file
argument_list|(
name|a
operator|.
name|key_file
argument_list|,
literal|0
argument_list|,
name|apparg
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err_return
goto|;
block|}
if|if
condition|(
operator|!
name|SSL_CTX_use_certificate_chain_file
argument_list|(
name|ret
argument_list|,
name|a
operator|.
name|certificate_file
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|SSL_CTX_check_private_key
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|tls_errprintf
argument_list|(
literal|1
argument_list|,
name|apparg
argument_list|,
literal|"Private key \"%s\" does not match certificate \"%s\".\n"
argument_list|,
name|a
operator|.
name|key_file
argument_list|,
name|a
operator|.
name|certificate_file
argument_list|)
expr_stmt|;
goto|goto
name|err_peek
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|a
operator|.
name|ca_file
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|a
operator|.
name|verify_depth
operator|>
literal|0
operator|)
condition|)
block|{
name|context_num
operator|++
expr_stmt|;
name|r
operator|=
name|SSL_CTX_set_session_id_context
argument_list|(
name|ret
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|context_num
argument_list|,
operator|(
name|unsigned
name|int
operator|)
sizeof|sizeof
name|context_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
goto|goto
name|err
goto|;
name|SSL_CTX_set_verify
argument_list|(
name|ret
argument_list|,
name|SSL_VERIFY_PEER
operator||
operator|(
name|a
operator|.
name|fail_unless_verified
condition|?
name|SSL_VERIFY_FAIL_IF_NO_PEER_CERT
else|:
literal|0
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
operator|.
name|fail_unless_verified
condition|)
name|SSL_CTX_set_cert_verify_callback
argument_list|(
name|ret
argument_list|,
name|verify_dont_fail_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|.
name|verify_depth
operator|>
literal|0
condition|)
name|SSL_CTX_set_verify_depth
argument_list|(
name|ret
argument_list|,
name|a
operator|.
name|verify_depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|.
name|ca_file
operator|!=
name|NULL
condition|)
block|{
comment|/* does not report failure if file does not exist ... */
comment|/* NULL argument means no CA-directory */
name|r
operator|=
name|SSL_CTX_load_verify_locations
argument_list|(
name|ret
argument_list|,
name|a
operator|.
name|ca_file
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|err_pref_1
operator|=
literal|" while processing certificate file "
expr_stmt|;
name|err_pref_2
operator|=
name|a
operator|.
name|ca_file
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|a
operator|.
name|client_p
condition|)
block|{
comment|/*                  * SSL_load_client_CA_file is a misnomer, it just creates a                  * list of CNs.                  */
name|SSL_CTX_set_client_CA_list
argument_list|(
name|ret
argument_list|,
name|SSL_load_client_CA_file
argument_list|(
name|a
operator|.
name|ca_file
argument_list|)
argument_list|)
expr_stmt|;
comment|/*                  * SSL_CTX_set_client_CA_list does not have a return value;                  * it does not really need one, but make sure (we really test                  * if SSL_load_client_CA_file worked)                  */
if|if
condition|(
name|SSL_CTX_get_client_CA_list
argument_list|(
name|ret
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|tls_errprintf
argument_list|(
literal|1
argument_list|,
name|apparg
argument_list|,
literal|"Could not set client CA list from \"%s\".\n"
argument_list|,
name|a
operator|.
name|ca_file
argument_list|)
expr_stmt|;
goto|goto
name|err_peek
goto|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|a
operator|.
name|client_p
condition|)
block|{
if|if
condition|(
name|tls_dhe1024
operator|==
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|RAND_bytes
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
expr_stmt|;
comment|/*              * make sure that i is non-negative -- pick one of the provided              * seeds              */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|tls_set_dhe1024
argument_list|(
name|i
argument_list|,
name|apparg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tls_dhe1024
operator|==
name|NULL
condition|)
goto|goto
name|err_return
goto|;
block|}
if|if
condition|(
operator|!
name|SSL_CTX_set_tmp_dh
argument_list|(
name|ret
argument_list|,
name|tls_dhe1024
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* avoid small subgroup attacks: */
name|SSL_CTX_set_options
argument_list|(
name|ret
argument_list|,
name|SSL_OP_SINGLE_DH_USE
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_RSA
if|if
condition|(
operator|!
name|a
operator|.
name|client_p
operator|&&
name|a
operator|.
name|export_p
condition|)
block|{
name|RSA
modifier|*
name|tmpkey
decl_stmt|;
name|tmpkey
operator|=
name|RSA_generate_key
argument_list|(
literal|512
argument_list|,
name|RSA_F4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpkey
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|SSL_CTX_set_tmp_rsa
argument_list|(
name|ret
argument_list|,
name|tmpkey
argument_list|)
condition|)
block|{
name|RSA_free
argument_list|(
name|tmpkey
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|RSA_free
argument_list|(
name|tmpkey
argument_list|)
expr_stmt|;
comment|/* SSL_CTX_set_tmp_rsa uses a duplicate. */
block|}
endif|#
directive|endif
return|return
name|ret
return|;
name|err_peek
label|:
if|if
condition|(
operator|!
name|ERR_peek_error
argument_list|()
condition|)
goto|goto
name|err_return
goto|;
name|err
label|:
name|tls_openssl_errors
argument_list|(
name|err_pref_1
argument_list|,
name|err_pref_2
argument_list|,
name|NULL
argument_list|,
name|apparg
argument_list|)
expr_stmt|;
name|err_return
label|:
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|SSL_CTX_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|tls_socket_nonblocking
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|v
decl_stmt|,
name|r
decl_stmt|;
name|v
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
return|return
literal|0
return|;
comment|/* already shut down -- ignore */
return|return
operator|-
literal|1
return|;
block|}
name|r
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|v
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
return|return
literal|0
return|;
comment|/* already shut down -- ignore */
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|max
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|>
name|b
condition|?
name|a
else|:
name|b
return|;
block|}
end_function

begin_comment
comment|/* timeout, -1 means no timeout */
end_comment

begin_function
specifier|static
name|void
name|tls_sockets_select
parameter_list|(
name|int
name|read_select_1
parameter_list|,
name|int
name|read_select_2
parameter_list|,
name|int
name|write_select_1
parameter_list|,
name|int
name|write_select_2
parameter_list|,
name|int
name|seconds
parameter_list|)
block|{
name|int
name|maxfd
decl_stmt|,
name|n
decl_stmt|;
name|fd_set
name|reads
decl_stmt|,
name|writes
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|struct
name|timeval
modifier|*
name|timeout_p
decl_stmt|;
name|assert
argument_list|(
name|read_select_1
operator|>=
operator|-
literal|1
operator|&&
name|read_select_2
operator|>=
operator|-
literal|1
operator|&&
name|write_select_1
operator|>=
operator|-
literal|1
operator|&&
name|write_select_2
operator|>=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|read_select_1
operator|<
name|FD_SETSIZE
operator|&&
name|read_select_2
operator|<
name|FD_SETSIZE
operator|-
literal|1
operator|&&
name|write_select_1
operator|<
name|FD_SETSIZE
operator|-
literal|1
operator|&&
name|write_select_2
operator|<
name|FD_SETSIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|maxfd
operator|=
name|max
argument_list|(
name|max
argument_list|(
name|read_select_1
argument_list|,
name|read_select_2
argument_list|)
argument_list|,
name|max
argument_list|(
name|write_select_1
argument_list|,
name|write_select_2
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|maxfd
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|reads
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|writes
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|4
condition|;
operator|++
name|n
control|)
block|{
name|int
name|i
init|=
name|n
operator|%
literal|2
decl_stmt|;
name|int
name|w
init|=
name|n
operator|>=
literal|2
decl_stmt|;
comment|/* loop over all (i, w) in {0,1}x{0,1} */
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|w
operator|==
literal|0
condition|)
name|fd
operator|=
name|read_select_1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
name|w
operator|==
literal|0
condition|)
name|fd
operator|=
name|read_select_2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|w
operator|==
literal|1
condition|)
name|fd
operator|=
name|write_select_1
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|i
operator|==
literal|1
operator|&&
name|w
operator|==
literal|1
argument_list|)
expr_stmt|;
name|fd
operator|=
name|write_select_2
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|w
operator|==
literal|0
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|reads
argument_list|)
expr_stmt|;
else|else
comment|/* w == 1 */
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|writes
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|seconds
operator|>=
literal|0
condition|)
block|{
name|timeout
operator|.
name|tv_sec
operator|=
name|seconds
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|timeout_p
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
else|else
name|timeout_p
operator|=
name|NULL
expr_stmt|;
name|DEBUG_MSG2
argument_list|(
literal|"select no."
argument_list|,
operator|++
name|tls_select_count
argument_list|)
expr_stmt|;
name|select
argument_list|(
name|maxfd
operator|+
literal|1
argument_list|,
operator|&
name|reads
argument_list|,
operator|&
name|writes
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
name|timeout_p
argument_list|)
expr_stmt|;
name|DEBUG_MSG
argument_list|(
literal|"cont."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|TUNNELBUFSIZE
value|(16*1024)
end_define

begin_struct
struct|struct
name|tunnelbuf
block|{
name|char
name|buf
index|[
name|TUNNELBUFSIZE
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|tls_connect_attempt
parameter_list|(
name|SSL
modifier|*
parameter_list|,
name|int
modifier|*
name|write_select
parameter_list|,
name|int
modifier|*
name|read_select
parameter_list|,
name|int
modifier|*
name|closed
parameter_list|,
name|int
modifier|*
name|progress
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|err_pref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tls_accept_attempt
parameter_list|(
name|SSL
modifier|*
parameter_list|,
name|int
modifier|*
name|write_select
parameter_list|,
name|int
modifier|*
name|read_select
parameter_list|,
name|int
modifier|*
name|closed
parameter_list|,
name|int
modifier|*
name|progress
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|err_pref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tls_write_attempt
parameter_list|(
name|SSL
modifier|*
parameter_list|,
name|struct
name|tunnelbuf
modifier|*
parameter_list|,
name|int
modifier|*
name|write_select
parameter_list|,
name|int
modifier|*
name|read_select
parameter_list|,
name|int
modifier|*
name|closed
parameter_list|,
name|int
modifier|*
name|progress
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|err_pref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tls_read_attempt
parameter_list|(
name|SSL
modifier|*
parameter_list|,
name|struct
name|tunnelbuf
modifier|*
parameter_list|,
name|int
modifier|*
name|write_select
parameter_list|,
name|int
modifier|*
name|read_select
parameter_list|,
name|int
modifier|*
name|closed
parameter_list|,
name|int
modifier|*
name|progress
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|err_pref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_attempt
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|tunnelbuf
modifier|*
parameter_list|,
name|int
modifier|*
name|select
parameter_list|,
name|int
modifier|*
name|closed
parameter_list|,
name|int
modifier|*
name|progress
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_attempt
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|tunnelbuf
modifier|*
parameter_list|,
name|int
modifier|*
name|select
parameter_list|,
name|int
modifier|*
name|closed
parameter_list|,
name|int
modifier|*
name|progress
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|write_info
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|int
modifier|*
name|info_fd
parameter_list|)
block|{
if|if
condition|(
operator|*
name|info_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|long
name|v
decl_stmt|;
name|int
name|v_ok
decl_stmt|;
name|struct
name|tls_x509_name_string
name|peer
decl_stmt|;
name|char
name|infobuf
index|[
name|TLS_INFO_SIZE
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
name|DEBUG_MSG
argument_list|(
literal|"write_info"
argument_list|)
expr_stmt|;
name|v
operator|=
name|SSL_get_verify_result
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|v_ok
operator|=
operator|(
name|v
operator|==
name|X509_V_OK
operator|)
condition|?
literal|'A'
else|:
literal|'E'
expr_stmt|;
comment|/* Auth./Error */
block|{
name|X509
modifier|*
name|peercert
decl_stmt|;
name|peercert
operator|=
name|SSL_get_peer_certificate
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|tls_get_x509_subject_name_oneline
argument_list|(
name|peercert
argument_list|,
operator|&
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|peercert
operator|!=
name|NULL
condition|)
name|X509_free
argument_list|(
name|peercert
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|.
name|str
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|v_ok
operator|=
literal|'0'
expr_stmt|;
comment|/* no cert at all */
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|peer
operator|.
name|str
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
comment|/* should not happen, but make sure */
operator|*
name|strchr
argument_list|(
name|peer
operator|.
name|str
argument_list|,
literal|'\n'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
block|}
name|r
operator|=
name|snprintf
argument_list|(
name|infobuf
argument_list|,
sizeof|sizeof
name|infobuf
argument_list|,
literal|"%c:%s\n%s\n"
argument_list|,
name|v_ok
argument_list|,
name|X509_verify_cert_error_string
argument_list|(
name|v
argument_list|)
argument_list|,
name|peer
operator|.
name|str
argument_list|)
expr_stmt|;
name|DEBUG_MSG2
argument_list|(
literal|"snprintf"
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
operator|||
name|r
operator|>=
sizeof|sizeof
name|infobuf
condition|)
name|r
operator|=
sizeof|sizeof
name|infobuf
operator|-
literal|1
expr_stmt|;
name|write
argument_list|(
operator|*
name|info_fd
argument_list|,
name|infobuf
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|close
argument_list|(
operator|*
name|info_fd
argument_list|)
expr_stmt|;
operator|*
name|info_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* tls_proxy expects that all fds are closed after return */
end_comment

begin_function
specifier|static
name|void
name|tls_proxy
parameter_list|(
name|int
name|clear_fd
parameter_list|,
name|int
name|tls_fd
parameter_list|,
name|int
name|info_fd
parameter_list|,
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
name|int
name|client_p
parameter_list|)
block|{
name|struct
name|tunnelbuf
name|clear_to_tls
decl_stmt|,
name|tls_to_clear
decl_stmt|;
name|SSL
modifier|*
name|ssl
decl_stmt|;
name|BIO
modifier|*
name|rbio
decl_stmt|,
modifier|*
name|wbio
decl_stmt|;
name|int
name|closed
decl_stmt|,
name|in_handshake
decl_stmt|;
specifier|const
name|char
modifier|*
name|err_pref_1
init|=
literal|""
decl_stmt|,
modifier|*
name|err_pref_2
init|=
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|err_def
init|=
name|NULL
decl_stmt|;
name|assert
argument_list|(
name|clear_fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tls_fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|clear_fd
operator|<
name|FD_SETSIZE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tls_fd
operator|<
name|FD_SETSIZE
argument_list|)
expr_stmt|;
comment|/* info_fd may be -1 */
name|assert
argument_list|(
name|ctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tls_rand_seed_uniquely
argument_list|()
expr_stmt|;
name|tls_socket_nonblocking
argument_list|(
name|clear_fd
argument_list|)
expr_stmt|;
name|DEBUG_MSG2
argument_list|(
literal|"clear_fd"
argument_list|,
name|clear_fd
argument_list|)
expr_stmt|;
name|tls_socket_nonblocking
argument_list|(
name|tls_fd
argument_list|)
expr_stmt|;
name|DEBUG_MSG2
argument_list|(
literal|"tls_fd"
argument_list|,
name|tls_fd
argument_list|)
expr_stmt|;
name|ssl
operator|=
name|SSL_new
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|DEBUG_MSG
argument_list|(
literal|"SSL_new"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_set_fd
argument_list|(
name|ssl
argument_list|,
name|tls_fd
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|rbio
operator|=
name|SSL_get_rbio
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|wbio
operator|=
name|SSL_get_wbio
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
comment|/* should be the same, but who cares */
name|assert
argument_list|(
name|rbio
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|wbio
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_p
condition|)
name|SSL_set_connect_state
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
else|else
name|SSL_set_accept_state
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|closed
operator|=
literal|0
expr_stmt|;
name|in_handshake
operator|=
literal|1
expr_stmt|;
name|tls_to_clear
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|tls_to_clear
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|clear_to_tls
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|clear_to_tls
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|err_def
operator|=
literal|"I/O error"
expr_stmt|;
comment|/*      * loop finishes as soon as we detect that one side closed; when all      * (program and OS) buffers have enough space, the data from the last      * succesful read in each direction is transferred before close      */
do|do
block|{
name|int
name|clear_read_select
init|=
literal|0
decl_stmt|,
name|clear_write_select
init|=
literal|0
decl_stmt|,
name|tls_read_select
init|=
literal|0
decl_stmt|,
name|tls_write_select
init|=
literal|0
decl_stmt|,
name|progress
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
name|unsigned
name|long
name|num_read
init|=
name|BIO_number_read
argument_list|(
name|rbio
argument_list|)
decl_stmt|,
name|num_written
init|=
name|BIO_number_written
argument_list|(
name|wbio
argument_list|)
decl_stmt|;
name|DEBUG_MSG2
argument_list|(
literal|"loop iteration"
argument_list|,
operator|++
name|tls_loop_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_handshake
condition|)
block|{
name|DEBUG_MSG
argument_list|(
literal|"in_handshake"
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_p
condition|)
name|r
operator|=
name|tls_connect_attempt
argument_list|(
name|ssl
argument_list|,
operator|&
name|tls_write_select
argument_list|,
operator|&
name|tls_read_select
argument_list|,
operator|&
name|closed
argument_list|,
operator|&
name|progress
argument_list|,
operator|&
name|err_pref_1
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|tls_accept_attempt
argument_list|(
name|ssl
argument_list|,
operator|&
name|tls_write_select
argument_list|,
operator|&
name|tls_read_select
argument_list|,
operator|&
name|closed
argument_list|,
operator|&
name|progress
argument_list|,
operator|&
name|err_pref_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|write_info
argument_list|(
name|ssl
argument_list|,
operator|&
name|info_fd
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|closed
condition|)
goto|goto
name|err_return
goto|;
if|if
condition|(
operator|!
name|SSL_in_init
argument_list|(
name|ssl
argument_list|)
condition|)
block|{
name|in_handshake
operator|=
literal|0
expr_stmt|;
name|write_info
argument_list|(
name|ssl
argument_list|,
operator|&
name|info_fd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|clear_to_tls
operator|.
name|len
operator|!=
literal|0
operator|&&
operator|!
name|in_handshake
condition|)
block|{
name|assert
argument_list|(
operator|!
name|closed
argument_list|)
expr_stmt|;
name|r
operator|=
name|tls_write_attempt
argument_list|(
name|ssl
argument_list|,
operator|&
name|clear_to_tls
argument_list|,
operator|&
name|tls_write_select
argument_list|,
operator|&
name|tls_read_select
argument_list|,
operator|&
name|closed
argument_list|,
operator|&
name|progress
argument_list|,
operator|&
name|err_pref_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|closed
condition|)
block|{
name|assert
argument_list|(
name|progress
argument_list|)
expr_stmt|;
name|tls_to_clear
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|tls_to_clear
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tls_to_clear
operator|.
name|len
operator|!=
literal|0
condition|)
block|{
name|assert
argument_list|(
operator|!
name|closed
argument_list|)
expr_stmt|;
name|r
operator|=
name|write_attempt
argument_list|(
name|clear_fd
argument_list|,
operator|&
name|tls_to_clear
argument_list|,
operator|&
name|clear_write_select
argument_list|,
operator|&
name|closed
argument_list|,
operator|&
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
goto|goto
name|err_return
goto|;
if|if
condition|(
name|closed
condition|)
block|{
name|assert
argument_list|(
name|progress
argument_list|)
expr_stmt|;
name|clear_to_tls
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|clear_to_tls
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|closed
condition|)
block|{
if|if
condition|(
name|clear_to_tls
operator|.
name|offset
operator|+
name|clear_to_tls
operator|.
name|len
operator|<
sizeof|sizeof
name|clear_to_tls
operator|.
name|buf
condition|)
block|{
name|r
operator|=
name|read_attempt
argument_list|(
name|clear_fd
argument_list|,
operator|&
name|clear_to_tls
argument_list|,
operator|&
name|clear_read_select
argument_list|,
operator|&
name|closed
argument_list|,
operator|&
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
goto|goto
name|err_return
goto|;
if|if
condition|(
name|closed
condition|)
block|{
name|r
operator|=
name|SSL_shutdown
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|DEBUG_MSG2
argument_list|(
literal|"SSL_shutdown"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|closed
operator|&&
operator|!
name|in_handshake
condition|)
block|{
if|if
condition|(
name|tls_to_clear
operator|.
name|offset
operator|+
name|tls_to_clear
operator|.
name|len
operator|<
sizeof|sizeof
name|tls_to_clear
operator|.
name|buf
condition|)
block|{
name|r
operator|=
name|tls_read_attempt
argument_list|(
name|ssl
argument_list|,
operator|&
name|tls_to_clear
argument_list|,
operator|&
name|tls_write_select
argument_list|,
operator|&
name|tls_read_select
argument_list|,
operator|&
name|closed
argument_list|,
operator|&
name|progress
argument_list|,
operator|&
name|err_pref_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|closed
condition|)
block|{
name|r
operator|=
name|SSL_shutdown
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|DEBUG_MSG2
argument_list|(
literal|"SSL_shutdown"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|progress
condition|)
block|{
name|DEBUG_MSG
argument_list|(
literal|"!progress?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_read
operator|!=
name|BIO_number_read
argument_list|(
name|rbio
argument_list|)
operator|||
name|num_written
operator|!=
name|BIO_number_written
argument_list|(
name|wbio
argument_list|)
condition|)
name|progress
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|progress
condition|)
block|{
name|DEBUG_MSG
argument_list|(
literal|"!progress"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|clear_read_select
operator|||
name|tls_read_select
operator|||
name|clear_write_select
operator|||
name|tls_write_select
argument_list|)
expr_stmt|;
name|tls_sockets_select
argument_list|(
name|clear_read_select
condition|?
name|clear_fd
else|:
operator|-
literal|1
argument_list|,
name|tls_read_select
condition|?
name|tls_fd
else|:
operator|-
literal|1
argument_list|,
name|clear_write_select
condition|?
name|clear_fd
else|:
operator|-
literal|1
argument_list|,
name|tls_write_select
condition|?
name|tls_fd
else|:
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|closed
condition|)
do|;
return|return;
name|err
label|:
name|tls_openssl_errors
argument_list|(
name|err_pref_1
argument_list|,
name|err_pref_2
argument_list|,
name|err_def
argument_list|,
name|tls_child_apparg
argument_list|)
expr_stmt|;
name|err_return
label|:
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|tls_get_error
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|int
name|r
parameter_list|,
name|int
modifier|*
name|write_select
parameter_list|,
name|int
modifier|*
name|read_select
parameter_list|,
name|int
modifier|*
name|closed
parameter_list|,
name|int
modifier|*
name|progress
parameter_list|)
block|{
name|int
name|err
init|=
name|SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|SSL_ERROR_NONE
condition|)
block|{
name|assert
argument_list|(
name|r
operator|>
literal|0
argument_list|)
expr_stmt|;
operator|*
name|progress
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|assert
argument_list|(
name|r
operator|<=
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|SSL_ERROR_ZERO_RETURN
case|:
name|assert
argument_list|(
name|r
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|closed
operator|=
literal|1
expr_stmt|;
operator|*
name|progress
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SSL_ERROR_WANT_WRITE
case|:
operator|*
name|write_select
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SSL_ERROR_WANT_READ
case|:
operator|*
name|read_select
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tls_connect_attempt
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|int
modifier|*
name|write_select
parameter_list|,
name|int
modifier|*
name|read_select
parameter_list|,
name|int
modifier|*
name|closed
parameter_list|,
name|int
modifier|*
name|progress
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|err_pref
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|r
decl_stmt|;
name|DEBUG_MSG
argument_list|(
literal|"tls_connect_attempt"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SSL_connect
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|DEBUG_MSG2
argument_list|(
literal|"SSL_connect"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|r
operator|=
name|tls_get_error
argument_list|(
name|ssl
argument_list|,
name|n
argument_list|,
name|write_select
argument_list|,
name|read_select
argument_list|,
name|closed
argument_list|,
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
operator|*
name|err_pref
operator|=
literal|" during SSL_connect"
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tls_accept_attempt
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|int
modifier|*
name|write_select
parameter_list|,
name|int
modifier|*
name|read_select
parameter_list|,
name|int
modifier|*
name|closed
parameter_list|,
name|int
modifier|*
name|progress
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|err_pref
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|r
decl_stmt|;
name|DEBUG_MSG
argument_list|(
literal|"tls_accept_attempt"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SSL_accept
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|DEBUG_MSG2
argument_list|(
literal|"SSL_accept"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|r
operator|=
name|tls_get_error
argument_list|(
name|ssl
argument_list|,
name|n
argument_list|,
name|write_select
argument_list|,
name|read_select
argument_list|,
name|closed
argument_list|,
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
operator|*
name|err_pref
operator|=
literal|" during SSL_accept"
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tls_write_attempt
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|tunnelbuf
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|write_select
parameter_list|,
name|int
modifier|*
name|read_select
parameter_list|,
name|int
modifier|*
name|closed
parameter_list|,
name|int
modifier|*
name|progress
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|err_pref
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|r
decl_stmt|;
name|DEBUG_MSG
argument_list|(
literal|"tls_write_attempt"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SSL_write
argument_list|(
name|ssl
argument_list|,
name|buf
operator|->
name|buf
operator|+
name|buf
operator|->
name|offset
argument_list|,
name|buf
operator|->
name|len
argument_list|)
expr_stmt|;
name|DEBUG_MSG2
argument_list|(
literal|"SSL_write"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|r
operator|=
name|tls_get_error
argument_list|(
name|ssl
argument_list|,
name|n
argument_list|,
name|write_select
argument_list|,
name|read_select
argument_list|,
name|closed
argument_list|,
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|buf
operator|->
name|len
operator|-=
name|n
expr_stmt|;
name|assert
argument_list|(
name|buf
operator|->
name|len
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|len
operator|==
literal|0
condition|)
name|buf
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
else|else
name|buf
operator|->
name|offset
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
operator|*
name|err_pref
operator|=
literal|" during SSL_write"
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tls_read_attempt
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|tunnelbuf
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|write_select
parameter_list|,
name|int
modifier|*
name|read_select
parameter_list|,
name|int
modifier|*
name|closed
parameter_list|,
name|int
modifier|*
name|progress
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|err_pref
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|r
decl_stmt|;
name|size_t
name|total
decl_stmt|;
name|DEBUG_MSG
argument_list|(
literal|"tls_read_attempt"
argument_list|)
expr_stmt|;
name|total
operator|=
name|buf
operator|->
name|offset
operator|+
name|buf
operator|->
name|len
expr_stmt|;
name|assert
argument_list|(
name|total
operator|<
sizeof|sizeof
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|n
operator|=
name|SSL_read
argument_list|(
name|ssl
argument_list|,
name|buf
operator|->
name|buf
operator|+
name|total
argument_list|,
operator|(
sizeof|sizeof
name|buf
operator|->
name|buf
operator|)
operator|-
name|total
argument_list|)
expr_stmt|;
name|DEBUG_MSG2
argument_list|(
literal|"SSL_read"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|r
operator|=
name|tls_get_error
argument_list|(
name|ssl
argument_list|,
name|n
argument_list|,
name|write_select
argument_list|,
name|read_select
argument_list|,
name|closed
argument_list|,
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|buf
operator|->
name|len
operator|+=
name|n
expr_stmt|;
name|assert
argument_list|(
name|buf
operator|->
name|offset
operator|+
name|buf
operator|->
name|len
operator|<=
sizeof|sizeof
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
operator|*
name|err_pref
operator|=
literal|" during SSL_read"
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_error
parameter_list|(
name|int
name|r
parameter_list|,
name|int
modifier|*
name|select
parameter_list|,
name|int
modifier|*
name|closed
parameter_list|,
name|int
modifier|*
name|progress
parameter_list|)
block|{
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
block|{
operator|*
name|progress
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
operator|*
name|closed
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|assert
argument_list|(
name|r
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
operator|*
name|select
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|EPIPE
condition|)
block|{
operator|*
name|progress
operator|=
literal|1
expr_stmt|;
operator|*
name|closed
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|write_attempt
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|tunnelbuf
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|select
parameter_list|,
name|int
modifier|*
name|closed
parameter_list|,
name|int
modifier|*
name|progress
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|r
decl_stmt|;
name|DEBUG_MSG
argument_list|(
literal|"write_attempt"
argument_list|)
expr_stmt|;
name|n
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
operator|->
name|buf
operator|+
name|buf
operator|->
name|offset
argument_list|,
name|buf
operator|->
name|len
argument_list|)
expr_stmt|;
name|DEBUG_MSG2
argument_list|(
literal|"write"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|r
operator|=
name|get_error
argument_list|(
name|n
argument_list|,
name|select
argument_list|,
name|closed
argument_list|,
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|buf
operator|->
name|len
operator|-=
name|n
expr_stmt|;
name|assert
argument_list|(
name|buf
operator|->
name|len
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|len
operator|==
literal|0
condition|)
name|buf
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
else|else
name|buf
operator|->
name|offset
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
name|tls_errprintf
argument_list|(
literal|1
argument_list|,
name|tls_child_apparg
argument_list|,
literal|"write error: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_attempt
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|tunnelbuf
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|select
parameter_list|,
name|int
modifier|*
name|closed
parameter_list|,
name|int
modifier|*
name|progress
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|r
decl_stmt|;
name|size_t
name|total
decl_stmt|;
name|DEBUG_MSG
argument_list|(
literal|"read_attempt"
argument_list|)
expr_stmt|;
name|total
operator|=
name|buf
operator|->
name|offset
operator|+
name|buf
operator|->
name|len
expr_stmt|;
name|assert
argument_list|(
name|total
operator|<
sizeof|sizeof
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
operator|->
name|buf
operator|+
name|total
argument_list|,
operator|(
sizeof|sizeof
name|buf
operator|->
name|buf
operator|)
operator|-
name|total
argument_list|)
expr_stmt|;
name|DEBUG_MSG2
argument_list|(
literal|"read"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|r
operator|=
name|get_error
argument_list|(
name|n
argument_list|,
name|select
argument_list|,
name|closed
argument_list|,
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|buf
operator|->
name|len
operator|+=
name|n
expr_stmt|;
name|assert
argument_list|(
name|buf
operator|->
name|offset
operator|+
name|buf
operator|->
name|len
operator|<=
sizeof|sizeof
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
name|tls_errprintf
argument_list|(
literal|1
argument_list|,
name|tls_child_apparg
argument_list|,
literal|"read error: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

end_unit

