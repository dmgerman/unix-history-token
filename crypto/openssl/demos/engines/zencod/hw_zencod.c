begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/engine/hw_zencod.c */
end_comment

begin_comment
comment|/* Written by Fred Donnat (frederic.donnat@zencod.com) for "zencod"  * engine integration in order to redirect crypto computing on a crypto  * hardware accelerator zenssl32  ;-)  *  * Date : 25 jun 2002  * Revision : 17 Ju7 2002  * Version : zencod_engine-0.9.7  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1999-2001 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* ENGINE general include */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/dso.h>
end_include

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HW
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HW_ZENCOD
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|FLAT_INC
end_ifdef

begin_include
include|#
directive|include
file|"hw_zencod.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"vendor_defns/hw_zencod.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ZENCOD_LIB_NAME
value|"zencod engine"
end_define

begin_include
include|#
directive|include
file|"hw_zencod_err.c"
end_include

begin_define
define|#
directive|define
name|FAIL_TO_SOFTWARE
value|-15
end_define

begin_define
define|#
directive|define
name|ZEN_LIBRARY
value|"zenbridge"
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|PERROR
parameter_list|(
name|s
parameter_list|)
value|perror(s)
end_define

begin_define
define|#
directive|define
name|CHEESE
parameter_list|()
value|fputs("## [ZenEngine] ## " __FUNCTION__ "\n", stderr)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERROR
parameter_list|(
name|s
parameter_list|)
end_define

begin_define
define|#
directive|define
name|CHEESE
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Sorry ;) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_function
specifier|static
specifier|inline
name|void
name|esrever
parameter_list|(
name|unsigned
name|char
modifier|*
name|d
parameter_list|,
name|int
name|l
parameter_list|)
block|{
for|for
control|(
init|;
operator|--
name|l
operator|>
literal|0
condition|;
operator|--
name|l
operator|,
name|d
operator|++
control|)
block|{
operator|*
name|d
operator|^=
operator|*
operator|(
name|d
operator|+
name|l
operator|)
expr_stmt|;
operator|*
operator|(
name|d
operator|+
name|l
operator|)
operator|^=
operator|*
name|d
expr_stmt|;
operator|*
name|d
operator|^=
operator|*
operator|(
name|d
operator|+
name|l
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ypcmem
parameter_list|(
name|unsigned
name|char
modifier|*
name|d
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|s
parameter_list|,
name|int
name|l
parameter_list|)
block|{
for|for
control|(
name|d
operator|+=
name|l
init|;
name|l
operator|--
condition|;
control|)
operator|*
operator|--
name|d
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|__inline
name|void
name|esrever
parameter_list|(
name|unsigned
name|char
modifier|*
name|d
parameter_list|,
name|int
name|l
parameter_list|)
block|{
for|for
control|(
init|;
operator|--
name|l
operator|>
literal|0
condition|;
operator|--
name|l
operator|,
name|d
operator|++
control|)
block|{
operator|*
name|d
operator|^=
operator|*
operator|(
name|d
operator|+
name|l
operator|)
expr_stmt|;
operator|*
operator|(
name|d
operator|+
name|l
operator|)
operator|^=
operator|*
name|d
expr_stmt|;
operator|*
name|d
operator|^=
operator|*
operator|(
name|d
operator|+
name|l
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ypcmem
parameter_list|(
name|unsigned
name|char
modifier|*
name|d
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|s
parameter_list|,
name|int
name|l
parameter_list|)
block|{
for|for
control|(
name|d
operator|+=
name|l
init|;
name|l
operator|--
condition|;
control|)
operator|*
operator|--
name|d
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BIGNUM2ZEN
parameter_list|(
name|n
parameter_list|,
name|bn
parameter_list|)
value|(ptr_zencod_init_number((n), \ 					(unsigned long) ((bn)->top * BN_BITS2), \ 					(unsigned char *) ((bn)->d)))
end_define

begin_define
define|#
directive|define
name|ZEN_BITS
parameter_list|(
name|n
parameter_list|,
name|bytes
parameter_list|)
value|(ptr_zencod_bytes2bits((unsigned char *) (n), (unsigned long) (bytes)))
end_define

begin_define
define|#
directive|define
name|ZEN_BYTES
parameter_list|(
name|bits
parameter_list|)
value|(ptr_zencod_bits2bytes((unsigned long) (bits)))
end_define

begin_comment
comment|/* Function for ENGINE detection and control */
end_comment

begin_function_decl
specifier|static
name|int
name|zencod_destroy
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zencod_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zencod_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zencod_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* BIGNUM stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|zencod_bn_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* RSA stuff */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_function_decl
specifier|static
name|int
name|RSA_zencod_rsa_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r0
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|I
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|RSA_zencod_bn_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DSA stuff */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
end_ifndef

begin_function_decl
specifier|static
name|int
name|DSA_zencod_bn_mod_exp
parameter_list|(
name|DSA
modifier|*
name|dsa
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|DSA_SIG
modifier|*
name|DSA_zencod_do_sign
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|dgst
parameter_list|,
name|int
name|dlen
parameter_list|,
name|DSA
modifier|*
name|dsa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|DSA_zencod_do_verify
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|dgst
parameter_list|,
name|int
name|dgst_len
parameter_list|,
name|DSA_SIG
modifier|*
name|sig
parameter_list|,
name|DSA
modifier|*
name|dsa
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DH stuff */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_function_decl
specifier|static
name|int
name|DH_zencod_bn_mod_exp
parameter_list|(
specifier|const
name|DH
modifier|*
name|dh
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|DH_zencod_generate_key
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|DH_zencod_compute_key
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|pub_key
parameter_list|,
name|DH
modifier|*
name|dh
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Rand stuff */
end_comment

begin_function_decl
specifier|static
name|void
name|RAND_zencod_seed
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|RAND_zencod_rand_bytes
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|RAND_zencod_rand_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Digest Stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|engine_digests
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
modifier|*
name|digest
parameter_list|,
specifier|const
name|int
modifier|*
modifier|*
name|nids
parameter_list|,
name|int
name|nid
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Cipher Stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|engine_ciphers
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|EVP_CIPHER
modifier|*
modifier|*
name|cipher
parameter_list|,
specifier|const
name|int
modifier|*
modifier|*
name|nids
parameter_list|,
name|int
name|nid
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ZENCOD_CMD_SO_PATH
value|ENGINE_CMD_BASE
end_define

begin_decl_stmt
specifier|static
specifier|const
name|ENGINE_CMD_DEFN
name|zencod_cmd_defns
index|[ ]
init|=
block|{
block|{
name|ZENCOD_CMD_SO_PATH
block|,
literal|"SO_PATH"
block|,
literal|"Specifies the path to the 'zenbridge' shared library"
block|,
name|ENGINE_CMD_FLAG_STRING
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_comment
comment|/* Our internal RSA_METHOD specific to zencod ENGINE providing pointers to our function */
end_comment

begin_decl_stmt
specifier|static
name|RSA_METHOD
name|zencod_rsa
init|=
block|{
literal|"ZENCOD RSA method"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|RSA_zencod_rsa_mod_exp
block|,
name|RSA_zencod_bn_mod_exp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
end_ifndef

begin_comment
comment|/* Our internal DSA_METHOD specific to zencod ENGINE providing pointers to our function */
end_comment

begin_decl_stmt
specifier|static
name|DSA_METHOD
name|zencod_dsa
init|=
block|{
literal|"ZENCOD DSA method"
block|,
name|DSA_zencod_do_sign
block|,
name|NULL
block|,
name|DSA_zencod_do_verify
block|,
name|NULL
block|,
name|DSA_zencod_bn_mod_exp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_comment
comment|/* Our internal DH_METHOD specific to zencod ENGINE providing pointers to our function */
end_comment

begin_decl_stmt
specifier|static
name|DH_METHOD
name|zencod_dh
init|=
block|{
literal|"ZENCOD DH method"
block|,
name|DH_zencod_generate_key
block|,
name|DH_zencod_compute_key
block|,
name|DH_zencod_bn_mod_exp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Our internal RAND_meth specific to zencod ZNGINE providing pointers to  our function */
end_comment

begin_decl_stmt
specifier|static
name|RAND_METHOD
name|zencod_rand
init|=
block|{
name|RAND_zencod_seed
block|,
name|RAND_zencod_rand_bytes
block|,
name|NULL
block|,
name|NULL
block|,
name|RAND_zencod_rand_bytes
block|,
name|RAND_zencod_rand_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Constants used when creating the ENGINE */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_zencod_id
init|=
literal|"zencod"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_zencod_name
init|=
literal|"ZENCOD hardware engine support"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This internal function is used by ENGINE_zencod () and possibly by the  * "dynamic" ENGINE support too   ;-)  */
end_comment

begin_function
specifier|static
name|int
name|bind_helper
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
specifier|const
name|RSA_METHOD
modifier|*
name|meth_rsa
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
specifier|const
name|DSA_METHOD
modifier|*
name|meth_dsa
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
specifier|const
name|DH_METHOD
modifier|*
name|meth_dh
decl_stmt|;
endif|#
directive|endif
specifier|const
name|RAND_METHOD
modifier|*
name|meth_rand
decl_stmt|;
if|if
condition|(
operator|!
name|ENGINE_set_id
argument_list|(
name|e
argument_list|,
name|engine_zencod_id
argument_list|)
operator|||
operator|!
name|ENGINE_set_name
argument_list|(
name|e
argument_list|,
name|engine_zencod_name
argument_list|)
operator|||
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
operator|!
name|ENGINE_set_RSA
argument_list|(
name|e
argument_list|,
operator|&
name|zencod_rsa
argument_list|)
operator|||
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
operator|!
name|ENGINE_set_DSA
argument_list|(
name|e
argument_list|,
operator|&
name|zencod_dsa
argument_list|)
operator|||
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
operator|!
name|ENGINE_set_DH
argument_list|(
name|e
argument_list|,
operator|&
name|zencod_dh
argument_list|)
operator|||
endif|#
directive|endif
operator|!
name|ENGINE_set_RAND
argument_list|(
name|e
argument_list|,
operator|&
name|zencod_rand
argument_list|)
operator|||
operator|!
name|ENGINE_set_destroy_function
argument_list|(
name|e
argument_list|,
name|zencod_destroy
argument_list|)
operator|||
operator|!
name|ENGINE_set_init_function
argument_list|(
name|e
argument_list|,
name|zencod_init
argument_list|)
operator|||
operator|!
name|ENGINE_set_finish_function
argument_list|(
name|e
argument_list|,
name|zencod_finish
argument_list|)
operator|||
operator|!
name|ENGINE_set_ctrl_function
argument_list|(
name|e
argument_list|,
name|zencod_ctrl
argument_list|)
operator|||
operator|!
name|ENGINE_set_cmd_defns
argument_list|(
name|e
argument_list|,
name|zencod_cmd_defns
argument_list|)
operator|||
operator|!
name|ENGINE_set_digests
argument_list|(
name|e
argument_list|,
name|engine_digests
argument_list|)
operator|||
operator|!
name|ENGINE_set_ciphers
argument_list|(
name|e
argument_list|,
name|engine_ciphers
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
comment|/* We know that the "PKCS1_SSLeay()" functions hook properly 	 * to the Zencod-specific mod_exp and mod_exp_crt so we use 	 * those functions. NB: We don't use ENGINE_openssl() or 	 * anything "more generic" because something like the RSAref 	 * code may not hook properly, and if you own one of these 	 * cards then you have the right to do RSA operations on it 	 * anyway! 	 */
name|meth_rsa
operator|=
name|RSA_PKCS1_SSLeay
argument_list|()
expr_stmt|;
name|zencod_rsa
operator|.
name|rsa_pub_enc
operator|=
name|meth_rsa
operator|->
name|rsa_pub_enc
expr_stmt|;
name|zencod_rsa
operator|.
name|rsa_pub_dec
operator|=
name|meth_rsa
operator|->
name|rsa_pub_dec
expr_stmt|;
name|zencod_rsa
operator|.
name|rsa_priv_enc
operator|=
name|meth_rsa
operator|->
name|rsa_priv_enc
expr_stmt|;
name|zencod_rsa
operator|.
name|rsa_priv_dec
operator|=
name|meth_rsa
operator|->
name|rsa_priv_dec
expr_stmt|;
comment|/* meth_rsa->rsa_mod_exp */
comment|/* meth_rsa->bn_mod_exp */
name|zencod_rsa
operator|.
name|init
operator|=
name|meth_rsa
operator|->
name|init
expr_stmt|;
name|zencod_rsa
operator|.
name|finish
operator|=
name|meth_rsa
operator|->
name|finish
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
comment|/* We use OpenSSL meth to supply what we don't provide ;-*) 	 */
name|meth_dsa
operator|=
name|DSA_OpenSSL
argument_list|()
expr_stmt|;
comment|/* meth_dsa->dsa_do_sign */
name|zencod_dsa
operator|.
name|dsa_sign_setup
operator|=
name|meth_dsa
operator|->
name|dsa_sign_setup
expr_stmt|;
comment|/* meth_dsa->dsa_do_verify */
name|zencod_dsa
operator|.
name|dsa_mod_exp
operator|=
name|meth_dsa
operator|->
name|dsa_mod_exp
expr_stmt|;
comment|/* zencod_dsa.bn_mod_exp = meth_dsa->bn_mod_exp ; */
name|zencod_dsa
operator|.
name|init
operator|=
name|meth_dsa
operator|->
name|init
expr_stmt|;
name|zencod_dsa
operator|.
name|finish
operator|=
name|meth_dsa
operator|->
name|finish
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
comment|/* We use OpenSSL meth to supply what we don't provide ;-*) 	 */
name|meth_dh
operator|=
name|DH_OpenSSL
argument_list|()
expr_stmt|;
comment|/* zencod_dh.generate_key = meth_dh->generate_key ; */
comment|/* zencod_dh.compute_key = meth_dh->compute_key ; */
comment|/* zencod_dh.bn_mod_exp = meth_dh->bn_mod_exp ; */
name|zencod_dh
operator|.
name|init
operator|=
name|meth_dh
operator|->
name|init
expr_stmt|;
name|zencod_dh
operator|.
name|finish
operator|=
name|meth_dh
operator|->
name|finish
expr_stmt|;
endif|#
directive|endif
comment|/* We use OpenSSL (SSLeay) meth to supply what we don't provide ;-*) 	 */
name|meth_rand
operator|=
name|RAND_SSLeay
argument_list|()
expr_stmt|;
comment|/* meth_rand->seed ; */
comment|/* zencod_rand.seed = meth_rand->seed ; */
comment|/* meth_rand->bytes ; */
comment|/* zencod_rand.bytes = meth_rand->bytes ; */
name|zencod_rand
operator|.
name|cleanup
operator|=
name|meth_rand
operator|->
name|cleanup
expr_stmt|;
name|zencod_rand
operator|.
name|add
operator|=
name|meth_rand
operator|->
name|add
expr_stmt|;
comment|/* meth_rand->pseudorand ; */
comment|/* zencod_rand.pseudorand = meth_rand->pseudorand ; */
comment|/* zencod_rand.status = meth_rand->status ; */
comment|/* meth_rand->status ; */
comment|/* Ensure the zencod error handling is set up */
name|ERR_load_ZENCOD_strings
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* As this is only ever called once, there's no need for locking  * (indeed - the lock will already be held by our caller!!!)  */
end_comment

begin_function
specifier|static
name|ENGINE
modifier|*
name|ENGINE_zencod
parameter_list|(
name|void
parameter_list|)
block|{
name|ENGINE
modifier|*
name|eng
init|=
name|ENGINE_new
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|eng
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|bind_helper
argument_list|(
name|eng
argument_list|)
condition|)
block|{
name|ENGINE_free
argument_list|(
name|eng
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|eng
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENGINE_DYNAMIC_SUPPORT
end_ifdef

begin_function
specifier|static
endif|#
directive|endif
name|void
name|ENGINE_load_zencod
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Copied from eng_[openssl|dyn].c */
name|ENGINE
modifier|*
name|toadd
init|=
name|ENGINE_zencod
argument_list|( )
decl_stmt|;
if|if
condition|(
operator|!
name|toadd
condition|)
return|return ;
name|ENGINE_add
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ENGINE_free
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ERR_clear_error
argument_list|( )
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a process-global DSO handle used for loading and unloading  * the ZENBRIDGE library.  * NB: This is only set (or unset) during an * init () or finish () call  * (reference counts permitting) and they're  * operating with global locks,  * so this should be thread-safe * implicitly.  */
end_comment

begin_decl_stmt
specifier|static
name|DSO
modifier|*
name|zencod_dso
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_test
modifier|*
name|ptr_zencod_test
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_bytes2bits
modifier|*
name|ptr_zencod_bytes2bits
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_bits2bytes
modifier|*
name|ptr_zencod_bits2bytes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_new_number
modifier|*
name|ptr_zencod_new_number
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_init_number
modifier|*
name|ptr_zencod_init_number
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_rsa_mod_exp
modifier|*
name|ptr_zencod_rsa_mod_exp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_rsa_mod_exp_crt
modifier|*
name|ptr_zencod_rsa_mod_exp_crt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_dsa_do_sign
modifier|*
name|ptr_zencod_dsa_do_sign
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_dsa_do_verify
modifier|*
name|ptr_zencod_dsa_do_verify
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_dh_generate_key
modifier|*
name|ptr_zencod_dh_generate_key
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_dh_compute_key
modifier|*
name|ptr_zencod_dh_compute_key
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_rand_bytes
modifier|*
name|ptr_zencod_rand_bytes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_math_mod_exp
modifier|*
name|ptr_zencod_math_mod_exp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_md5_init
modifier|*
name|ptr_zencod_md5_init
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_md5_update
modifier|*
name|ptr_zencod_md5_update
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_md5_do_final
modifier|*
name|ptr_zencod_md5_do_final
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_sha1_init
modifier|*
name|ptr_zencod_sha1_init
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_sha1_update
modifier|*
name|ptr_zencod_sha1_update
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_sha1_do_final
modifier|*
name|ptr_zencod_sha1_do_final
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_xdes_cipher
modifier|*
name|ptr_zencod_xdes_cipher
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_zencod_rc4_cipher
modifier|*
name|ptr_zencod_rc4_cipher
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the static string constants for the DSO file name and the function  * symbol names to bind to.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_LIBNAME
init|=
name|ZEN_LIBRARY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_0
init|=
literal|"test_device"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_1
init|=
literal|"zenbridge_bytes2bits"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_2
init|=
literal|"zenbridge_bits2bytes"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_3
init|=
literal|"zenbridge_new_number"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_4
init|=
literal|"zenbridge_init_number"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_exp_1
init|=
literal|"zenbridge_rsa_mod_exp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_exp_2
init|=
literal|"zenbridge_rsa_mod_exp_crt"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_dsa_1
init|=
literal|"zenbridge_dsa_do_sign"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_dsa_2
init|=
literal|"zenbridge_dsa_do_verify"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_dh_1
init|=
literal|"zenbridge_dh_generate_key"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_dh_2
init|=
literal|"zenbridge_dh_compute_key"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_rand_1
init|=
literal|"zenbridge_rand_bytes"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_math_1
init|=
literal|"zenbridge_math_mod_exp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_md5_1
init|=
literal|"zenbridge_md5_init"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_md5_2
init|=
literal|"zenbridge_md5_update"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_md5_3
init|=
literal|"zenbridge_md5_do_final"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_sha1_1
init|=
literal|"zenbridge_sha1_init"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_sha1_2
init|=
literal|"zenbridge_sha1_update"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_sha1_3
init|=
literal|"zenbridge_sha1_do_final"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_xdes_1
init|=
literal|"zenbridge_xdes_cipher"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ZENCOD_Fct_rc4_1
init|=
literal|"zenbridge_rc4_cipher"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Destructor (complements the "ENGINE_zencod ()" constructor)  */
end_comment

begin_function
specifier|static
name|int
name|zencod_destroy
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|ERR_unload_ZENCOD_strings
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* (de)initialisation functions. Control Function  */
end_comment

begin_function
specifier|static
name|int
name|zencod_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|t_zencod_test
modifier|*
name|ptr_0
decl_stmt|;
name|t_zencod_bytes2bits
modifier|*
name|ptr_1
decl_stmt|;
name|t_zencod_bits2bytes
modifier|*
name|ptr_2
decl_stmt|;
name|t_zencod_new_number
modifier|*
name|ptr_3
decl_stmt|;
name|t_zencod_init_number
modifier|*
name|ptr_4
decl_stmt|;
name|t_zencod_rsa_mod_exp
modifier|*
name|ptr_exp_1
decl_stmt|;
name|t_zencod_rsa_mod_exp_crt
modifier|*
name|ptr_exp_2
decl_stmt|;
name|t_zencod_dsa_do_sign
modifier|*
name|ptr_dsa_1
decl_stmt|;
name|t_zencod_dsa_do_verify
modifier|*
name|ptr_dsa_2
decl_stmt|;
name|t_zencod_dh_generate_key
modifier|*
name|ptr_dh_1
decl_stmt|;
name|t_zencod_dh_compute_key
modifier|*
name|ptr_dh_2
decl_stmt|;
name|t_zencod_rand_bytes
modifier|*
name|ptr_rand_1
decl_stmt|;
name|t_zencod_math_mod_exp
modifier|*
name|ptr_math_1
decl_stmt|;
name|t_zencod_md5_init
modifier|*
name|ptr_md5_1
decl_stmt|;
name|t_zencod_md5_update
modifier|*
name|ptr_md5_2
decl_stmt|;
name|t_zencod_md5_do_final
modifier|*
name|ptr_md5_3
decl_stmt|;
name|t_zencod_sha1_init
modifier|*
name|ptr_sha1_1
decl_stmt|;
name|t_zencod_sha1_update
modifier|*
name|ptr_sha1_2
decl_stmt|;
name|t_zencod_sha1_do_final
modifier|*
name|ptr_sha1_3
decl_stmt|;
name|t_zencod_xdes_cipher
modifier|*
name|ptr_xdes_1
decl_stmt|;
name|t_zencod_rc4_cipher
modifier|*
name|ptr_rc4_1
decl_stmt|;
name|CHEESE
argument_list|()
expr_stmt|;
comment|/* 	 * We Should add some tests for non NULL parameters or bad value !! 	 * Stuff to be done ... 	 */
if|if
condition|(
name|zencod_dso
operator|!=
name|NULL
condition|)
block|{
name|ZENCODerr
argument_list|(
name|ZENCOD_F_ZENCOD_INIT
argument_list|,
name|ZENCOD_R_ALREADY_LOADED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Trying to load the Library "cryptozen" 	 */
name|zencod_dso
operator|=
name|DSO_load
argument_list|(
name|NULL
argument_list|,
name|ZENCOD_LIBNAME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zencod_dso
operator|==
name|NULL
condition|)
block|{
name|ZENCODerr
argument_list|(
name|ZENCOD_F_ZENCOD_INIT
argument_list|,
name|ZENCOD_R_DSO_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Trying to load Function from the Library 	 */
if|if
condition|(
operator|!
operator|(
name|ptr_1
operator|=
operator|(
name|t_zencod_bytes2bits
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_1
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_2
operator|=
operator|(
name|t_zencod_bits2bytes
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_2
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_3
operator|=
operator|(
name|t_zencod_new_number
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_3
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_4
operator|=
operator|(
name|t_zencod_init_number
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_4
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_exp_1
operator|=
operator|(
name|t_zencod_rsa_mod_exp
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_exp_1
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_exp_2
operator|=
operator|(
name|t_zencod_rsa_mod_exp_crt
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_exp_2
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_dsa_1
operator|=
operator|(
name|t_zencod_dsa_do_sign
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_dsa_1
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_dsa_2
operator|=
operator|(
name|t_zencod_dsa_do_verify
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_dsa_2
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_dh_1
operator|=
operator|(
name|t_zencod_dh_generate_key
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_dh_1
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_dh_2
operator|=
operator|(
name|t_zencod_dh_compute_key
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_dh_2
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_rand_1
operator|=
operator|(
name|t_zencod_rand_bytes
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_rand_1
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_math_1
operator|=
operator|(
name|t_zencod_math_mod_exp
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_math_1
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_0
operator|=
operator|(
name|t_zencod_test
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_0
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_md5_1
operator|=
operator|(
name|t_zencod_md5_init
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_md5_1
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_md5_2
operator|=
operator|(
name|t_zencod_md5_update
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_md5_2
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_md5_3
operator|=
operator|(
name|t_zencod_md5_do_final
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_md5_3
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_sha1_1
operator|=
operator|(
name|t_zencod_sha1_init
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_sha1_1
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_sha1_2
operator|=
operator|(
name|t_zencod_sha1_update
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_sha1_2
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_sha1_3
operator|=
operator|(
name|t_zencod_sha1_do_final
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_sha1_3
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_xdes_1
operator|=
operator|(
name|t_zencod_xdes_cipher
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_xdes_1
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ptr_rc4_1
operator|=
operator|(
name|t_zencod_rc4_cipher
operator|*
operator|)
name|DSO_bind_func
argument_list|(
name|zencod_dso
argument_list|,
name|ZENCOD_Fct_rc4_1
argument_list|)
operator|)
condition|)
block|{
name|ZENCODerr
argument_list|(
name|ZENCOD_F_ZENCOD_INIT
argument_list|,
name|ZENCOD_R_DSO_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* The function from "cryptozen" Library have been correctly loaded so copy them 	 */
name|ptr_zencod_test
operator|=
name|ptr_0
expr_stmt|;
name|ptr_zencod_bytes2bits
operator|=
name|ptr_1
expr_stmt|;
name|ptr_zencod_bits2bytes
operator|=
name|ptr_2
expr_stmt|;
name|ptr_zencod_new_number
operator|=
name|ptr_3
expr_stmt|;
name|ptr_zencod_init_number
operator|=
name|ptr_4
expr_stmt|;
name|ptr_zencod_rsa_mod_exp
operator|=
name|ptr_exp_1
expr_stmt|;
name|ptr_zencod_rsa_mod_exp_crt
operator|=
name|ptr_exp_2
expr_stmt|;
name|ptr_zencod_dsa_do_sign
operator|=
name|ptr_dsa_1
expr_stmt|;
name|ptr_zencod_dsa_do_verify
operator|=
name|ptr_dsa_2
expr_stmt|;
name|ptr_zencod_dh_generate_key
operator|=
name|ptr_dh_1
expr_stmt|;
name|ptr_zencod_dh_compute_key
operator|=
name|ptr_dh_2
expr_stmt|;
name|ptr_zencod_rand_bytes
operator|=
name|ptr_rand_1
expr_stmt|;
name|ptr_zencod_math_mod_exp
operator|=
name|ptr_math_1
expr_stmt|;
name|ptr_zencod_test
operator|=
name|ptr_0
expr_stmt|;
name|ptr_zencod_md5_init
operator|=
name|ptr_md5_1
expr_stmt|;
name|ptr_zencod_md5_update
operator|=
name|ptr_md5_2
expr_stmt|;
name|ptr_zencod_md5_do_final
operator|=
name|ptr_md5_3
expr_stmt|;
name|ptr_zencod_sha1_init
operator|=
name|ptr_sha1_1
expr_stmt|;
name|ptr_zencod_sha1_update
operator|=
name|ptr_sha1_2
expr_stmt|;
name|ptr_zencod_sha1_do_final
operator|=
name|ptr_sha1_3
expr_stmt|;
name|ptr_zencod_xdes_cipher
operator|=
name|ptr_xdes_1
expr_stmt|;
name|ptr_zencod_rc4_cipher
operator|=
name|ptr_rc4_1
expr_stmt|;
comment|/* We should peform a test to see if there is actually any unit runnig on the system ... 	 * Even if the cryptozen library is loaded the module coul not be loaded on the system ... 	 * For now we may just open and close the device !! 	 */
if|if
condition|(
name|ptr_zencod_test
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|ZENCODerr
argument_list|(
name|ZENCOD_F_ZENCOD_INIT
argument_list|,
name|ZENCOD_R_UNIT_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
literal|1
return|;
name|err
label|:
if|if
condition|(
name|zencod_dso
condition|)
block|{
name|DSO_free
argument_list|(
name|zencod_dso
argument_list|)
expr_stmt|;
block|}
name|zencod_dso
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_bytes2bits
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_bits2bytes
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_new_number
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_init_number
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_rsa_mod_exp
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_rsa_mod_exp_crt
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_dsa_do_sign
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_dsa_do_verify
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_dh_generate_key
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_dh_compute_key
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_rand_bytes
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_math_mod_exp
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_test
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_md5_init
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_md5_update
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_md5_do_final
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_sha1_init
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_sha1_update
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_sha1_do_final
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_xdes_cipher
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_rc4_cipher
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zencod_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|CHEESE
argument_list|()
expr_stmt|;
comment|/* 	 * We Should add some tests for non NULL parameters or bad value !! 	 * Stuff to be done ... 	 */
if|if
condition|(
name|zencod_dso
operator|==
name|NULL
condition|)
block|{
name|ZENCODerr
argument_list|(
name|ZENCOD_F_ZENCOD_FINISH
argument_list|,
name|ZENCOD_R_NOT_LOADED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|DSO_free
argument_list|(
name|zencod_dso
argument_list|)
condition|)
block|{
name|ZENCODerr
argument_list|(
name|ZENCOD_F_ZENCOD_FINISH
argument_list|,
name|ZENCOD_R_DSO_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|zencod_dso
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_bytes2bits
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_bits2bytes
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_new_number
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_init_number
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_rsa_mod_exp
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_rsa_mod_exp_crt
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_dsa_do_sign
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_dsa_do_verify
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_dh_generate_key
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_dh_compute_key
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_rand_bytes
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_math_mod_exp
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_test
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_md5_init
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_md5_update
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_md5_do_final
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_sha1_init
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_sha1_update
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_sha1_do_final
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_xdes_cipher
operator|=
name|NULL
expr_stmt|;
name|ptr_zencod_rc4_cipher
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zencod_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
parameter_list|)
block|{
name|int
name|initialised
init|=
operator|(
operator|(
name|zencod_dso
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|CHEESE
argument_list|()
expr_stmt|;
comment|/* 	 * We Should add some tests for non NULL parameters or bad value !! 	 * Stuff to be done ... 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ZENCOD_CMD_SO_PATH
case|:
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|ZENCODerr
argument_list|(
name|ZENCOD_F_ZENCOD_CTRL
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|initialised
condition|)
block|{
name|ZENCODerr
argument_list|(
name|ZENCOD_F_ZENCOD_CTRL
argument_list|,
name|ZENCOD_R_ALREADY_LOADED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ZENCOD_LIBNAME
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
expr_stmt|;
return|return
literal|1
return|;
default|default :
break|break ;
block|}
name|ZENCODerr
argument_list|(
name|ZENCOD_F_ZENCOD_CTRL
argument_list|,
name|ZENCOD_R_CTRL_COMMAND_NOT_IMPLEMENTED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* BIGNUM stuff Functions  */
end_comment

begin_function
specifier|static
name|int
name|zencod_bn_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|zen_nb_t
name|y
decl_stmt|,
name|x
decl_stmt|,
name|e
decl_stmt|,
name|n
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|CHEESE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zencod_dso
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_BN_MOD_EXP
argument_list|,
name|ZENCOD_R_NOT_LOADED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|bn_wexpand
argument_list|(
name|r
argument_list|,
name|m
operator|->
name|top
operator|+
literal|1
argument_list|)
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_BN_MOD_EXP
argument_list|,
name|ZENCOD_R_BN_EXPAND_FAIL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memset
argument_list|(
name|r
operator|->
name|d
argument_list|,
literal|0
argument_list|,
name|BN_num_bytes
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|ptr_zencod_init_number
argument_list|(
operator|&
name|y
argument_list|,
operator|(
name|r
operator|->
name|dmax
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|BN_ULONG
argument_list|)
operator|*
literal|8
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|r
operator|->
name|d
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|x
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|e
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Must invert x and e parameter due to BN mod exp prototype ... */
name|ret
operator|=
name|ptr_zencod_math_mod_exp
argument_list|(
operator|&
name|y
argument_list|,
operator|&
name|e
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|PERROR
argument_list|(
literal|"zenbridge_math_mod_exp"
argument_list|)
expr_stmt|;
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_BN_MOD_EXP
argument_list|,
name|ZENCOD_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|r
operator|->
name|top
operator|=
operator|(
name|BN_num_bits
argument_list|(
name|m
argument_list|)
operator|+
name|BN_BITS2
operator|-
literal|1
operator|)
operator|/
name|BN_BITS2
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* RSA stuff Functions  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_function
specifier|static
name|int
name|RSA_zencod_rsa_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r0
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|i
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|)
block|{
name|CHEESE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zencod_dso
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT
argument_list|,
name|ZENCOD_R_NOT_LOADED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|rsa
operator|->
name|p
operator|||
operator|!
name|rsa
operator|->
name|q
operator|||
operator|!
name|rsa
operator|->
name|dmp1
operator|||
operator|!
name|rsa
operator|->
name|dmq1
operator|||
operator|!
name|rsa
operator|->
name|iqmp
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT
argument_list|,
name|ZENCOD_R_BAD_KEY_COMPONENTS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Do in software if argument is too large for hardware */
if|if
condition|(
name|RSA_size
argument_list|(
name|rsa
argument_list|)
operator|*
literal|8
operator|>
name|ZENBRIDGE_MAX_KEYSIZE_RSA_CRT
condition|)
block|{
specifier|const
name|RSA_METHOD
modifier|*
name|meth
decl_stmt|;
name|meth
operator|=
name|RSA_PKCS1_SSLeay
argument_list|()
expr_stmt|;
return|return
name|meth
operator|->
name|rsa_mod_exp
argument_list|(
name|r0
argument_list|,
name|i
argument_list|,
name|rsa
argument_list|)
return|;
block|}
else|else
block|{
name|zen_nb_t
name|y
decl_stmt|,
name|x
decl_stmt|,
name|p
decl_stmt|,
name|q
decl_stmt|,
name|dmp1
decl_stmt|,
name|dmq1
decl_stmt|,
name|iqmp
decl_stmt|;
if|if
condition|(
operator|!
name|bn_expand
argument_list|(
name|r0
argument_list|,
name|RSA_size
argument_list|(
name|rsa
argument_list|)
operator|*
literal|8
argument_list|)
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT
argument_list|,
name|ZENCOD_R_BN_EXPAND_FAIL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|r0
operator|->
name|top
operator|=
operator|(
name|RSA_size
argument_list|(
name|rsa
argument_list|)
operator|*
literal|8
operator|+
name|BN_BITS2
operator|-
literal|1
operator|)
operator|/
name|BN_BITS2
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|y
argument_list|,
name|r0
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|p
argument_list|,
name|rsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|q
argument_list|,
name|rsa
operator|->
name|q
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|dmp1
argument_list|,
name|rsa
operator|->
name|dmp1
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|dmq1
argument_list|,
name|rsa
operator|->
name|dmq1
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|iqmp
argument_list|,
name|rsa
operator|->
name|iqmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr_zencod_rsa_mod_exp_crt
argument_list|(
operator|&
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|q
argument_list|,
operator|&
name|dmp1
argument_list|,
operator|&
name|dmq1
argument_list|,
operator|&
name|iqmp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"zenbridge_rsa_mod_exp_crt"
argument_list|)
expr_stmt|;
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT
argument_list|,
name|ZENCOD_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function is aliased to RSA_mod_exp (with the mont stuff dropped).  */
end_comment

begin_function
specifier|static
name|int
name|RSA_zencod_bn_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
block|{
name|CHEESE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zencod_dso
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_RSA_MOD_EXP
argument_list|,
name|ZENCOD_R_NOT_LOADED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Do in software if argument is too large for hardware */
if|if
condition|(
name|BN_num_bits
argument_list|(
name|m
argument_list|)
operator|>
name|ZENBRIDGE_MAX_KEYSIZE_RSA
condition|)
block|{
specifier|const
name|RSA_METHOD
modifier|*
name|meth
decl_stmt|;
name|meth
operator|=
name|RSA_PKCS1_SSLeay
argument_list|()
expr_stmt|;
return|return
name|meth
operator|->
name|bn_mod_exp
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|,
name|m_ctx
argument_list|)
return|;
block|}
else|else
block|{
name|zen_nb_t
name|y
decl_stmt|,
name|x
decl_stmt|,
name|e
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|bn_expand
argument_list|(
name|r
argument_list|,
name|BN_num_bits
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_RSA_MOD_EXP
argument_list|,
name|ZENCOD_R_BN_EXPAND_FAIL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|r
operator|->
name|top
operator|=
operator|(
name|BN_num_bits
argument_list|(
name|m
argument_list|)
operator|+
name|BN_BITS2
operator|-
literal|1
operator|)
operator|/
name|BN_BITS2
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|x
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|y
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|e
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr_zencod_rsa_mod_exp
argument_list|(
operator|&
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|e
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"zenbridge_rsa_mod_exp"
argument_list|)
expr_stmt|;
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_RSA_MOD_EXP
argument_list|,
name|ZENCOD_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_RSA */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
end_ifndef

begin_comment
comment|/* DSA stuff Functions  */
end_comment

begin_function
specifier|static
name|DSA_SIG
modifier|*
name|DSA_zencod_do_sign
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|dgst
parameter_list|,
name|int
name|dlen
parameter_list|,
name|DSA
modifier|*
name|dsa
parameter_list|)
block|{
name|zen_nb_t
name|p
decl_stmt|,
name|q
decl_stmt|,
name|g
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|r
decl_stmt|,
name|s
decl_stmt|,
name|data
decl_stmt|;
name|DSA_SIG
modifier|*
name|sig
decl_stmt|;
name|BIGNUM
modifier|*
name|bn_r
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|bn_s
init|=
name|NULL
decl_stmt|;
name|char
name|msg
index|[
literal|20
index|]
decl_stmt|;
name|CHEESE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zencod_dso
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DSA_DO_SIGN
argument_list|,
name|ZENCOD_R_NOT_LOADED
argument_list|)
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
if|if
condition|(
name|dlen
operator|>
literal|160
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DSA_DO_SIGN
argument_list|,
name|ZENCOD_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* Do in software if argument is too large for hardware */
if|if
condition|(
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|p
argument_list|)
operator|>
name|ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN
operator|||
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|g
argument_list|)
operator|>
name|ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN
condition|)
block|{
specifier|const
name|DSA_METHOD
modifier|*
name|meth
decl_stmt|;
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DSA_DO_SIGN
argument_list|,
name|ZENCOD_R_BAD_KEY_COMPONENTS
argument_list|)
expr_stmt|;
name|meth
operator|=
name|DSA_OpenSSL
argument_list|()
expr_stmt|;
return|return
name|meth
operator|->
name|dsa_do_sign
argument_list|(
name|dgst
argument_list|,
name|dlen
argument_list|,
name|dsa
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|bn_s
operator|=
name|BN_new
argument_list|()
operator|)
operator|||
operator|!
operator|(
name|bn_r
operator|=
name|BN_new
argument_list|()
operator|)
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DSA_DO_SIGN
argument_list|,
name|ZENCOD_R_BAD_KEY_COMPONENTS
argument_list|)
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
if|if
condition|(
operator|!
name|bn_expand
argument_list|(
name|bn_r
argument_list|,
literal|160
argument_list|)
operator|||
operator|!
name|bn_expand
argument_list|(
name|bn_s
argument_list|,
literal|160
argument_list|)
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DSA_DO_SIGN
argument_list|,
name|ZENCOD_R_BN_EXPAND_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|bn_r
operator|->
name|top
operator|=
name|bn_s
operator|->
name|top
operator|=
operator|(
literal|160
operator|+
name|BN_BITS2
operator|-
literal|1
operator|)
operator|/
name|BN_BITS2
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|p
argument_list|,
name|dsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|q
argument_list|,
name|dsa
operator|->
name|q
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|g
argument_list|,
name|dsa
operator|->
name|g
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|x
argument_list|,
name|dsa
operator|->
name|priv_key
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|y
argument_list|,
name|dsa
operator|->
name|pub_key
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|r
argument_list|,
name|bn_r
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|s
argument_list|,
name|bn_s
argument_list|)
expr_stmt|;
name|q
operator|.
name|len
operator|=
name|x
operator|.
name|len
operator|=
literal|160
expr_stmt|;
name|ypcmem
argument_list|(
name|msg
argument_list|,
name|dgst
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|ptr_zencod_init_number
argument_list|(
operator|&
name|data
argument_list|,
literal|160
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr_zencod_dsa_do_sign
argument_list|(
literal|0
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|q
argument_list|,
operator|&
name|g
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"zenbridge_dsa_do_sign"
argument_list|)
expr_stmt|;
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DSA_DO_SIGN
argument_list|,
name|ZENCOD_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|sig
operator|=
name|DSA_SIG_new
argument_list|()
operator|)
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DSA_DO_SIGN
argument_list|,
name|ZENCOD_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|sig
operator|->
name|r
operator|=
name|bn_r
expr_stmt|;
name|sig
operator|->
name|s
operator|=
name|bn_s
expr_stmt|;
return|return
name|sig
return|;
name|FAILED
label|:
if|if
condition|(
name|bn_r
condition|)
name|BN_free
argument_list|(
name|bn_r
argument_list|)
expr_stmt|;
if|if
condition|(
name|bn_s
condition|)
name|BN_free
argument_list|(
name|bn_s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|DSA_zencod_do_verify
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|dgst
parameter_list|,
name|int
name|dlen
parameter_list|,
name|DSA_SIG
modifier|*
name|sig
parameter_list|,
name|DSA
modifier|*
name|dsa
parameter_list|)
block|{
name|zen_nb_t
name|data
decl_stmt|,
name|p
decl_stmt|,
name|q
decl_stmt|,
name|g
decl_stmt|,
name|y
decl_stmt|,
name|r
decl_stmt|,
name|s
decl_stmt|,
name|v
decl_stmt|;
name|char
name|msg
index|[
literal|20
index|]
decl_stmt|;
name|char
name|v_data
index|[
literal|20
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|CHEESE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zencod_dso
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DSA_DO_VERIFY
argument_list|,
name|ZENCOD_R_NOT_LOADED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dlen
operator|>
literal|160
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DSA_DO_SIGN
argument_list|,
name|ZENCOD_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Do in software if argument is too large for hardware */
if|if
condition|(
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|p
argument_list|)
operator|>
name|ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN
operator|||
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|g
argument_list|)
operator|>
name|ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN
condition|)
block|{
specifier|const
name|DSA_METHOD
modifier|*
name|meth
decl_stmt|;
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DSA_DO_SIGN
argument_list|,
name|ZENCOD_R_BAD_KEY_COMPONENTS
argument_list|)
expr_stmt|;
name|meth
operator|=
name|DSA_OpenSSL
argument_list|()
expr_stmt|;
return|return
name|meth
operator|->
name|dsa_do_verify
argument_list|(
name|dgst
argument_list|,
name|dlen
argument_list|,
name|sig
argument_list|,
name|dsa
argument_list|)
return|;
block|}
name|BIGNUM2ZEN
argument_list|(
operator|&
name|p
argument_list|,
name|dsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|q
argument_list|,
name|dsa
operator|->
name|q
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|g
argument_list|,
name|dsa
operator|->
name|g
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|y
argument_list|,
name|dsa
operator|->
name|pub_key
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|r
argument_list|,
name|sig
operator|->
name|r
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|s
argument_list|,
name|sig
operator|->
name|s
argument_list|)
expr_stmt|;
name|ptr_zencod_init_number
argument_list|(
operator|&
name|v
argument_list|,
literal|160
argument_list|,
name|v_data
argument_list|)
expr_stmt|;
name|ypcmem
argument_list|(
name|msg
argument_list|,
name|dgst
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|ptr_zencod_init_number
argument_list|(
operator|&
name|data
argument_list|,
literal|160
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|ptr_zencod_dsa_do_verify
argument_list|(
literal|0
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|q
argument_list|,
operator|&
name|g
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|v
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"zenbridge_dsa_do_verify"
argument_list|)
expr_stmt|;
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DSA_DO_VERIFY
argument_list|,
name|ZENCOD_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
operator|(
name|ret
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|DSA_zencod_bn_mod_exp
parameter_list|(
name|DSA
modifier|*
name|dsa
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
block|{
name|CHEESE
argument_list|()
expr_stmt|;
return|return
name|zencod_bn_mod_exp
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_DSA */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSl_NO_DH
end_ifndef

begin_comment
comment|/* DH stuff Functions  */
end_comment

begin_function
specifier|static
name|int
name|DH_zencod_generate_key
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|bn_prv
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|bn_pub
init|=
name|NULL
decl_stmt|;
name|zen_nb_t
name|y
decl_stmt|,
name|x
decl_stmt|,
name|g
decl_stmt|,
name|p
decl_stmt|;
name|int
name|generate_x
decl_stmt|;
name|CHEESE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zencod_dso
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DH_GENERATE
argument_list|,
name|ZENCOD_R_NOT_LOADED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Private key */
if|if
condition|(
name|dh
operator|->
name|priv_key
condition|)
block|{
name|bn_prv
operator|=
name|dh
operator|->
name|priv_key
expr_stmt|;
name|generate_x
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|bn_prv
operator|=
name|BN_new
argument_list|()
operator|)
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DH_GENERATE
argument_list|,
name|ZENCOD_R_BN_EXPAND_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|generate_x
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Public key */
if|if
condition|(
name|dh
operator|->
name|pub_key
condition|)
name|bn_pub
operator|=
name|dh
operator|->
name|pub_key
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|bn_pub
operator|=
name|BN_new
argument_list|()
operator|)
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DH_GENERATE
argument_list|,
name|ZENCOD_R_BN_EXPAND_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* Expand */
if|if
condition|(
operator|!
name|bn_wexpand
argument_list|(
name|bn_prv
argument_list|,
name|dh
operator|->
name|p
operator|->
name|dmax
argument_list|)
operator|||
operator|!
name|bn_wexpand
argument_list|(
name|bn_pub
argument_list|,
name|dh
operator|->
name|p
operator|->
name|dmax
argument_list|)
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DH_GENERATE
argument_list|,
name|ZENCOD_R_BN_EXPAND_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|bn_prv
operator|->
name|top
operator|=
name|dh
operator|->
name|p
operator|->
name|top
expr_stmt|;
name|bn_pub
operator|->
name|top
operator|=
name|dh
operator|->
name|p
operator|->
name|top
expr_stmt|;
comment|/* Convert all keys */
name|BIGNUM2ZEN
argument_list|(
operator|&
name|p
argument_list|,
name|dh
operator|->
name|p
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|g
argument_list|,
name|dh
operator|->
name|g
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|y
argument_list|,
name|bn_pub
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|x
argument_list|,
name|bn_prv
argument_list|)
expr_stmt|;
name|x
operator|.
name|len
operator|=
name|DH_size
argument_list|(
name|dh
argument_list|)
operator|*
literal|8
expr_stmt|;
comment|/* Adjust the lengths of P and G */
name|p
operator|.
name|len
operator|=
name|ptr_zencod_bytes2bits
argument_list|(
name|p
operator|.
name|data
argument_list|,
name|ZEN_BYTES
argument_list|(
name|p
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|.
name|len
operator|=
name|ptr_zencod_bytes2bits
argument_list|(
name|g
operator|.
name|data
argument_list|,
name|ZEN_BYTES
argument_list|(
name|g
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send the request to the driver */
if|if
condition|(
name|ptr_zencod_dh_generate_key
argument_list|(
operator|&
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|g
argument_list|,
operator|&
name|p
argument_list|,
name|generate_x
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"zenbridge_dh_generate_key"
argument_list|)
expr_stmt|;
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DH_GENERATE
argument_list|,
name|ZENCOD_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|dh
operator|->
name|priv_key
operator|=
name|bn_prv
expr_stmt|;
name|dh
operator|->
name|pub_key
operator|=
name|bn_pub
expr_stmt|;
return|return
literal|1
return|;
name|FAILED
label|:
if|if
condition|(
operator|!
name|dh
operator|->
name|priv_key
operator|&&
name|bn_prv
condition|)
name|BN_free
argument_list|(
name|bn_prv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dh
operator|->
name|pub_key
operator|&&
name|bn_pub
condition|)
name|BN_free
argument_list|(
name|bn_pub
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|DH_zencod_compute_key
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|pub_key
parameter_list|,
name|DH
modifier|*
name|dh
parameter_list|)
block|{
name|zen_nb_t
name|y
decl_stmt|,
name|x
decl_stmt|,
name|p
decl_stmt|,
name|k
decl_stmt|;
name|CHEESE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zencod_dso
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DH_COMPUTE
argument_list|,
name|ZENCOD_R_NOT_LOADED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|dh
operator|->
name|priv_key
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DH_COMPUTE
argument_list|,
name|ZENCOD_R_BAD_KEY_COMPONENTS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Convert all keys */
name|BIGNUM2ZEN
argument_list|(
operator|&
name|y
argument_list|,
name|pub_key
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|x
argument_list|,
name|dh
operator|->
name|priv_key
argument_list|)
expr_stmt|;
name|BIGNUM2ZEN
argument_list|(
operator|&
name|p
argument_list|,
name|dh
operator|->
name|p
argument_list|)
expr_stmt|;
name|ptr_zencod_init_number
argument_list|(
operator|&
name|k
argument_list|,
name|p
operator|.
name|len
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/* Adjust the lengths */
name|p
operator|.
name|len
operator|=
name|ptr_zencod_bytes2bits
argument_list|(
name|p
operator|.
name|data
argument_list|,
name|ZEN_BYTES
argument_list|(
name|p
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|y
operator|.
name|len
operator|=
name|ptr_zencod_bytes2bits
argument_list|(
name|y
operator|.
name|data
argument_list|,
name|ZEN_BYTES
argument_list|(
name|y
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|len
operator|=
name|ptr_zencod_bytes2bits
argument_list|(
name|x
operator|.
name|data
argument_list|,
name|ZEN_BYTES
argument_list|(
name|x
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call the hardware */
if|if
condition|(
name|ptr_zencod_dh_compute_key
argument_list|(
operator|&
name|k
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_DH_COMPUTE
argument_list|,
name|ZENCOD_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* The key must be written MSB -> LSB */
name|k
operator|.
name|len
operator|=
name|ptr_zencod_bytes2bits
argument_list|(
name|k
operator|.
name|data
argument_list|,
name|ZEN_BYTES
argument_list|(
name|k
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|esrever
argument_list|(
name|key
argument_list|,
name|ZEN_BYTES
argument_list|(
name|k
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ZEN_BYTES
argument_list|(
name|k
operator|.
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|DH_zencod_bn_mod_exp
parameter_list|(
specifier|const
name|DH
modifier|*
name|dh
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
block|{
name|CHEESE
argument_list|()
expr_stmt|;
return|return
name|zencod_bn_mod_exp
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_DH */
end_comment

begin_comment
comment|/* RAND stuff Functions  */
end_comment

begin_function
specifier|static
name|void
name|RAND_zencod_seed
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
block|{
comment|/* Nothing to do cause our crypto accelerator provide a true random generator */
block|}
end_function

begin_function
specifier|static
name|int
name|RAND_zencod_rand_bytes
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|zen_nb_t
name|r
decl_stmt|;
name|CHEESE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zencod_dso
condition|)
block|{
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_RAND
argument_list|,
name|ZENCOD_R_NOT_LOADED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ptr_zencod_init_number
argument_list|(
operator|&
name|r
argument_list|,
name|num
operator|*
literal|8
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr_zencod_rand_bytes
argument_list|(
operator|&
name|r
argument_list|,
name|ZENBRIDGE_RNG_DIRECT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"zenbridge_rand_bytes"
argument_list|)
expr_stmt|;
name|ENGINEerr
argument_list|(
name|ZENCOD_F_ZENCOD_RAND
argument_list|,
name|ZENCOD_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|RAND_zencod_rand_status
parameter_list|(
name|void
parameter_list|)
block|{
name|CHEESE
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This stuff is needed if this ENGINE is being compiled into a self-contained  * shared-library.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENGINE_DYNAMIC_SUPPORT
end_ifdef

begin_function
specifier|static
name|int
name|bind_fn
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|&&
operator|(
name|strcmp
argument_list|(
name|id
argument_list|,
name|engine_zencod_id
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|bind_helper
argument_list|(
name|e
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_macro
name|IMPLEMENT_DYNAMIC_CHECK_FN
argument_list|()
end_macro

begin_macro
name|IMPLEMENT_DYNAMIC_BIND_FN
argument_list|(
argument|bind_fn
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENGINE_DYNAMIC_SUPPORT */
end_comment

begin_comment
comment|/*  * Adding "Digest" and "Cipher" tools ...  * This is in development ... ;-)  * In orfer to code this, i refer to hw_openbsd_dev_crypto and openssl engine made by Geoff Thorpe (if i'm rigth),  * and evp, sha md5 definitions etc ...  */
end_comment

begin_comment
comment|/* First add some include ... */
end_comment

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/sha.h>
end_include

begin_include
include|#
directive|include
file|<openssl/md5.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rc4.h>
end_include

begin_include
include|#
directive|include
file|<openssl/des.h>
end_include

begin_comment
comment|/* Some variables declaration ... */
end_comment

begin_comment
comment|/* DONS:  * Disable symetric computation except DES and 3DES, but let part of the code  */
end_comment

begin_comment
comment|/* static int engine_digest_nids [ ] = { NID_sha1, NID_md5 } ; */
end_comment

begin_decl_stmt
specifier|static
name|int
name|engine_digest_nids
index|[ ]
init|=
block|{  }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|engine_digest_nids_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static int engine_cipher_nids [ ] = { NID_rc4, NID_rc4_40, NID_des_cbc, NID_des_ede3_cbc } ; */
end_comment

begin_decl_stmt
specifier|static
name|int
name|engine_cipher_nids
index|[ ]
init|=
block|{
name|NID_des_cbc
block|,
name|NID_des_ede3_cbc
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|engine_cipher_nids_num
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function prototype ... */
end_comment

begin_comment
comment|/*  SHA stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|engine_sha1_init
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|engine_sha1_update
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|long
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|engine_sha1_final
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|md
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  MD5 stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|engine_md5_init
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|engine_md5_update
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|long
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|engine_md5_final
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|md
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|engine_md_cleanup
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|engine_md_copy
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|to
parameter_list|,
specifier|const
name|EVP_MD_CTX
modifier|*
name|from
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* RC4 Stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|engine_rc4_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|engine_rc4_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|int
name|inl
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* DES Stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|engine_des_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|engine_des_cbc_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|int
name|inl
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  3DES Stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|engine_des_ede3_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|engine_des_ede3_cbc_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|int
name|inl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|engine_cipher_cleanup
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* cleanup ctx */
end_comment

begin_comment
comment|/* The one for SHA ... */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|EVP_MD
name|engine_sha1_md
init|=
block|{
name|NID_sha1
block|,
name|NID_sha1WithRSAEncryption
block|,
name|SHA_DIGEST_LENGTH
block|,
name|EVP_MD_FLAG_ONESHOT
block|,
comment|/* 0, */
comment|/* EVP_MD_FLAG_ONESHOT = x0001 digest can only handle a single block 				* XXX: set according to device info ... */
name|engine_sha1_init
block|,
name|engine_sha1_update
block|,
name|engine_sha1_final
block|,
name|engine_md_copy
block|,
comment|/* dev_crypto_sha_copy */
name|engine_md_cleanup
block|,
comment|/* dev_crypto_sha_cleanup */
name|EVP_PKEY_RSA_method
block|,
name|SHA_CBLOCK
block|,
comment|/* sizeof ( EVP_MD * ) + sizeof ( SHA_CTX ) */
expr|sizeof
operator|(
name|ZEN_MD_DATA
operator|)
comment|/* sizeof ( MD_CTX_DATA )	The message digest data stucture ... */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The one for MD5 ... */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|EVP_MD
name|engine_md5_md
init|=
block|{
name|NID_md5
block|,
name|NID_md5WithRSAEncryption
block|,
name|MD5_DIGEST_LENGTH
block|,
name|EVP_MD_FLAG_ONESHOT
block|,
comment|/* 0, */
comment|/* EVP_MD_FLAG_ONESHOT = x0001 digest can only handle a single block 				* XXX: set according to device info ... */
name|engine_md5_init
block|,
name|engine_md5_update
block|,
name|engine_md5_final
block|,
name|engine_md_copy
block|,
comment|/* dev_crypto_md5_copy */
name|engine_md_cleanup
block|,
comment|/* dev_crypto_md5_cleanup */
name|EVP_PKEY_RSA_method
block|,
name|MD5_CBLOCK
block|,
comment|/* sizeof ( EVP_MD * ) + sizeof ( MD5_CTX ) */
expr|sizeof
operator|(
name|ZEN_MD_DATA
operator|)
comment|/* sizeof ( MD_CTX_DATA )	The message digest data stucture ... */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The one for RC4 ... */
end_comment

begin_define
define|#
directive|define
name|EVP_RC4_KEY_SIZE
value|16
end_define

begin_comment
comment|/* Try something static ... */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|int
name|len
decl_stmt|;
name|unsigned
name|int
name|first
decl_stmt|;
name|unsigned
name|char
name|rc4_state
index|[
literal|260
index|]
decl_stmt|;
block|}
name|NEW_ZEN_RC4_KEY
typedef|;
end_typedef

begin_define
define|#
directive|define
name|rc4_data
parameter_list|(
name|ctx
parameter_list|)
value|( (EVP_RC4_KEY *) ( ctx )->cipher_data )
end_define

begin_decl_stmt
specifier|static
specifier|const
name|EVP_CIPHER
name|engine_rc4
init|=
block|{
name|NID_rc4
block|,
literal|1
block|,
literal|16
block|,
comment|/* EVP_RC4_KEY_SIZE should be 128 bits */
literal|0
block|,
comment|/* FIXME: key should be up to 256 bytes */
name|EVP_CIPH_VARIABLE_LENGTH
block|,
name|engine_rc4_init_key
block|,
name|engine_rc4_cipher
block|,
name|engine_cipher_cleanup
block|,
sizeof|sizeof
argument_list|(
name|NEW_ZEN_RC4_KEY
argument_list|)
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The one for RC4_40 ... */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|EVP_CIPHER
name|engine_rc4_40
init|=
block|{
name|NID_rc4_40
block|,
literal|1
block|,
literal|5
block|,
comment|/* 40 bits */
literal|0
block|,
name|EVP_CIPH_VARIABLE_LENGTH
block|,
name|engine_rc4_init_key
block|,
name|engine_rc4_cipher
block|,
name|engine_cipher_cleanup
block|,
sizeof|sizeof
argument_list|(
name|NEW_ZEN_RC4_KEY
argument_list|)
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The one for DES ... */
end_comment

begin_comment
comment|/* Try something static ... */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|des_key
index|[
literal|24
index|]
decl_stmt|;
name|unsigned
name|char
name|des_iv
index|[
literal|8
index|]
decl_stmt|;
block|}
name|ZEN_DES_KEY
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|EVP_CIPHER
name|engine_des_cbc
init|=
block|{
name|NID_des_cbc
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|0
operator||
name|EVP_CIPH_CBC_MODE
block|,
name|engine_des_init_key
block|,
name|engine_des_cbc_cipher
block|,
name|engine_cipher_cleanup
block|,
sizeof|sizeof
argument_list|(
name|ZEN_DES_KEY
argument_list|)
block|,
name|EVP_CIPHER_set_asn1_iv
block|,
name|EVP_CIPHER_get_asn1_iv
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The one for 3DES ... */
end_comment

begin_comment
comment|/* Try something static ... */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|des3_key
index|[
literal|24
index|]
decl_stmt|;
name|unsigned
name|char
name|des3_iv
index|[
literal|8
index|]
decl_stmt|;
block|}
name|ZEN_3DES_KEY
typedef|;
end_typedef

begin_define
define|#
directive|define
name|des_data
parameter_list|(
name|ctx
parameter_list|)
value|( (DES_EDE_KEY *) ( ctx )->cipher_data )
end_define

begin_decl_stmt
specifier|static
specifier|const
name|EVP_CIPHER
name|engine_des_ede3_cbc
init|=
block|{
name|NID_des_ede3_cbc
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|0
operator||
name|EVP_CIPH_CBC_MODE
block|,
name|engine_des_ede3_init_key
block|,
name|engine_des_ede3_cbc_cipher
block|,
name|engine_cipher_cleanup
block|,
sizeof|sizeof
argument_list|(
name|ZEN_3DES_KEY
argument_list|)
block|,
name|EVP_CIPHER_set_asn1_iv
block|,
name|EVP_CIPHER_get_asn1_iv
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* General function cloned on hw_openbsd_dev_crypto one ... */
end_comment

begin_function
specifier|static
name|int
name|engine_digests
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
modifier|*
name|digest
parameter_list|,
specifier|const
name|int
modifier|*
modifier|*
name|nids
parameter_list|,
name|int
name|nid
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_ZENCOD_MD
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t=>Function : static int engine_digests () called !\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|digest
condition|)
block|{
comment|/* We are returning a list of supported nids */
operator|*
name|nids
operator|=
name|engine_digest_nids
expr_stmt|;
return|return
name|engine_digest_nids_num
return|;
block|}
comment|/* We are being asked for a specific digest */
if|if
condition|(
name|nid
operator|==
name|NID_md5
condition|)
block|{
operator|*
name|digest
operator|=
operator|&
name|engine_md5_md
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nid
operator|==
name|NID_sha1
condition|)
block|{
operator|*
name|digest
operator|=
operator|&
name|engine_sha1_md
expr_stmt|;
block|}
else|else
block|{
operator|*
name|digest
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* SHA stuff Functions  */
end_comment

begin_function
specifier|static
name|int
name|engine_sha1_init
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|to_return
init|=
literal|0
decl_stmt|;
comment|/* Test with zenbridge library ... */
name|to_return
operator|=
name|ptr_zencod_sha1_init
argument_list|(
operator|(
name|ZEN_MD_DATA
operator|*
operator|)
name|ctx
operator|->
name|md_data
argument_list|)
expr_stmt|;
name|to_return
operator|=
operator|!
name|to_return
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|engine_sha1_update
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|long
name|count
parameter_list|)
block|{
name|zen_nb_t
name|input
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
comment|/* Convert parameters ... */
name|input
operator|.
name|len
operator|=
name|count
expr_stmt|;
name|input
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
expr_stmt|;
comment|/* Test with zenbridge library ... */
name|to_return
operator|=
name|ptr_zencod_sha1_update
argument_list|(
operator|(
name|ZEN_MD_DATA
operator|*
operator|)
name|ctx
operator|->
name|md_data
argument_list|,
operator|(
specifier|const
name|zen_nb_t
operator|*
operator|)
operator|&
name|input
argument_list|)
expr_stmt|;
name|to_return
operator|=
operator|!
name|to_return
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|engine_sha1_final
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|md
parameter_list|)
block|{
name|zen_nb_t
name|output
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
comment|/* Convert parameters ... */
name|output
operator|.
name|len
operator|=
name|SHA_DIGEST_LENGTH
expr_stmt|;
name|output
operator|.
name|data
operator|=
name|md
expr_stmt|;
comment|/* Test with zenbridge library ... */
name|to_return
operator|=
name|ptr_zencod_sha1_do_final
argument_list|(
operator|(
name|ZEN_MD_DATA
operator|*
operator|)
name|ctx
operator|->
name|md_data
argument_list|,
operator|(
name|zen_nb_t
operator|*
operator|)
operator|&
name|output
argument_list|)
expr_stmt|;
name|to_return
operator|=
operator|!
name|to_return
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_comment
comment|/* MD5 stuff Functions  */
end_comment

begin_function
specifier|static
name|int
name|engine_md5_init
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|to_return
init|=
literal|0
decl_stmt|;
comment|/* Test with zenbridge library ... */
name|to_return
operator|=
name|ptr_zencod_md5_init
argument_list|(
operator|(
name|ZEN_MD_DATA
operator|*
operator|)
name|ctx
operator|->
name|md_data
argument_list|)
expr_stmt|;
name|to_return
operator|=
operator|!
name|to_return
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|engine_md5_update
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|long
name|count
parameter_list|)
block|{
name|zen_nb_t
name|input
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
comment|/* Convert parameters ... */
name|input
operator|.
name|len
operator|=
name|count
expr_stmt|;
name|input
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
expr_stmt|;
comment|/* Test with zenbridge library ... */
name|to_return
operator|=
name|ptr_zencod_md5_update
argument_list|(
operator|(
name|ZEN_MD_DATA
operator|*
operator|)
name|ctx
operator|->
name|md_data
argument_list|,
operator|(
specifier|const
name|zen_nb_t
operator|*
operator|)
operator|&
name|input
argument_list|)
expr_stmt|;
name|to_return
operator|=
operator|!
name|to_return
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|engine_md5_final
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|md
parameter_list|)
block|{
name|zen_nb_t
name|output
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
comment|/* Convert parameters ... */
name|output
operator|.
name|len
operator|=
name|MD5_DIGEST_LENGTH
expr_stmt|;
name|output
operator|.
name|data
operator|=
name|md
expr_stmt|;
comment|/* Test with zenbridge library ... */
name|to_return
operator|=
name|ptr_zencod_md5_do_final
argument_list|(
operator|(
name|ZEN_MD_DATA
operator|*
operator|)
name|ctx
operator|->
name|md_data
argument_list|,
operator|(
name|zen_nb_t
operator|*
operator|)
operator|&
name|output
argument_list|)
expr_stmt|;
name|to_return
operator|=
operator|!
name|to_return
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|engine_md_cleanup
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|ZEN_MD_DATA
modifier|*
name|zen_md_data
init|=
operator|(
name|ZEN_MD_DATA
operator|*
operator|)
name|ctx
operator|->
name|md_data
decl_stmt|;
if|if
condition|(
name|zen_md_data
operator|->
name|HashBuffer
operator|!=
name|NULL
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|zen_md_data
operator|->
name|HashBuffer
argument_list|)
expr_stmt|;
name|zen_md_data
operator|->
name|HashBufferSize
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|md_data
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|engine_md_copy
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|to
parameter_list|,
specifier|const
name|EVP_MD_CTX
modifier|*
name|from
parameter_list|)
block|{
specifier|const
name|ZEN_MD_DATA
modifier|*
name|from_md
init|=
operator|(
name|ZEN_MD_DATA
operator|*
operator|)
name|from
operator|->
name|md_data
decl_stmt|;
name|ZEN_MD_DATA
modifier|*
name|to_md
init|=
operator|(
name|ZEN_MD_DATA
operator|*
operator|)
name|to
operator|->
name|md_data
decl_stmt|;
name|to_md
operator|->
name|HashBuffer
operator|=
name|OPENSSL_malloc
argument_list|(
name|from_md
operator|->
name|HashBufferSize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|to_md
operator|->
name|HashBuffer
argument_list|,
name|from_md
operator|->
name|HashBuffer
argument_list|,
name|from_md
operator|->
name|HashBufferSize
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* General function cloned on hw_openbsd_dev_crypto one ... */
end_comment

begin_function
specifier|static
name|int
name|engine_ciphers
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|EVP_CIPHER
modifier|*
modifier|*
name|cipher
parameter_list|,
specifier|const
name|int
modifier|*
modifier|*
name|nids
parameter_list|,
name|int
name|nid
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cipher
condition|)
block|{
comment|/* We are returning a list of supported nids */
operator|*
name|nids
operator|=
name|engine_cipher_nids
expr_stmt|;
return|return
name|engine_cipher_nids_num
return|;
block|}
comment|/* We are being asked for a specific cipher */
if|if
condition|(
name|nid
operator|==
name|NID_rc4
condition|)
block|{
operator|*
name|cipher
operator|=
operator|&
name|engine_rc4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nid
operator|==
name|NID_rc4_40
condition|)
block|{
operator|*
name|cipher
operator|=
operator|&
name|engine_rc4_40
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nid
operator|==
name|NID_des_cbc
condition|)
block|{
operator|*
name|cipher
operator|=
operator|&
name|engine_des_cbc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nid
operator|==
name|NID_des_ede3_cbc
condition|)
block|{
operator|*
name|cipher
operator|=
operator|&
name|engine_des_ede3_cbc
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cipher
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|engine_rc4_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|int
name|to_return
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|nb
init|=
literal|0
decl_stmt|;
name|NEW_ZEN_RC4_KEY
modifier|*
name|tmp_rc4_key
init|=
name|NULL
decl_stmt|;
name|tmp_rc4_key
operator|=
operator|(
name|NEW_ZEN_RC4_KEY
operator|*
operator|)
operator|(
name|ctx
operator|->
name|cipher_data
operator|)
expr_stmt|;
name|tmp_rc4_key
operator|->
name|first
operator|=
literal|0
expr_stmt|;
name|tmp_rc4_key
operator|->
name|len
operator|=
name|ctx
operator|->
name|key_len
expr_stmt|;
name|tmp_rc4_key
operator|->
name|rc4_state
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|tmp_rc4_key
operator|->
name|rc4_state
index|[
literal|2
index|]
operator|=
literal|0x00
expr_stmt|;
name|nb
operator|=
literal|256
operator|/
name|ctx
operator|->
name|key_len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nb
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
operator|(
name|tmp_rc4_key
operator|->
name|rc4_state
index|[
literal|4
operator|+
name|i
operator|*
name|ctx
operator|->
name|key_len
index|]
operator|)
argument_list|,
name|key
argument_list|,
name|ctx
operator|->
name|key_len
argument_list|)
expr_stmt|;
block|}
name|to_return
operator|=
literal|1
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|engine_rc4_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|int
name|in_len
parameter_list|)
block|{
name|zen_nb_t
name|output
decl_stmt|,
name|input
decl_stmt|;
name|zen_nb_t
name|rc4key
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
name|NEW_ZEN_RC4_KEY
modifier|*
name|tmp_rc4_key
init|=
name|NULL
decl_stmt|;
comment|/* Convert parameters ... */
name|input
operator|.
name|len
operator|=
name|in_len
expr_stmt|;
name|input
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in
expr_stmt|;
name|output
operator|.
name|len
operator|=
name|in_len
expr_stmt|;
name|output
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|out
expr_stmt|;
name|tmp_rc4_key
operator|=
operator|(
operator|(
name|NEW_ZEN_RC4_KEY
operator|*
operator|)
operator|(
name|ctx
operator|->
name|cipher_data
operator|)
operator|)
expr_stmt|;
name|rc4key
operator|.
name|len
operator|=
literal|260
expr_stmt|;
name|rc4key
operator|.
name|data
operator|=
operator|&
operator|(
name|tmp_rc4_key
operator|->
name|rc4_state
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* Test with zenbridge library ... */
name|to_return
operator|=
name|ptr_zencod_rc4_cipher
argument_list|(
operator|&
name|output
argument_list|,
operator|&
name|input
argument_list|,
operator|(
specifier|const
name|zen_nb_t
operator|*
operator|)
operator|&
name|rc4key
argument_list|,
operator|&
operator|(
name|tmp_rc4_key
operator|->
name|rc4_state
index|[
literal|0
index|]
operator|)
argument_list|,
operator|&
operator|(
name|tmp_rc4_key
operator|->
name|rc4_state
index|[
literal|3
index|]
operator|)
argument_list|,
operator|!
name|tmp_rc4_key
operator|->
name|first
argument_list|)
expr_stmt|;
name|to_return
operator|=
operator|!
name|to_return
expr_stmt|;
comment|/* Update encryption state ... */
name|tmp_rc4_key
operator|->
name|first
operator|=
literal|1
expr_stmt|;
name|tmp_rc4_key
operator|=
name|NULL
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|engine_des_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|ZEN_DES_KEY
modifier|*
name|tmp_des_key
init|=
name|NULL
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
name|tmp_des_key
operator|=
operator|(
name|ZEN_DES_KEY
operator|*
operator|)
operator|(
name|ctx
operator|->
name|cipher_data
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|tmp_des_key
operator|->
name|des_key
index|[
literal|0
index|]
operator|)
argument_list|,
name|key
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|tmp_des_key
operator|->
name|des_key
index|[
literal|8
index|]
operator|)
argument_list|,
name|key
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|tmp_des_key
operator|->
name|des_key
index|[
literal|16
index|]
operator|)
argument_list|,
name|key
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|tmp_des_key
operator|->
name|des_iv
index|[
literal|0
index|]
operator|)
argument_list|,
name|iv
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|1
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|engine_des_cbc_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|int
name|inl
parameter_list|)
block|{
name|zen_nb_t
name|output
decl_stmt|,
name|input
decl_stmt|;
name|zen_nb_t
name|deskey_1
decl_stmt|,
name|deskey_2
decl_stmt|,
name|deskey_3
decl_stmt|,
name|iv
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
comment|/* Convert parameters ... */
name|input
operator|.
name|len
operator|=
name|inl
expr_stmt|;
name|input
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in
expr_stmt|;
name|output
operator|.
name|len
operator|=
name|inl
expr_stmt|;
name|output
operator|.
name|data
operator|=
name|out
expr_stmt|;
comment|/* Set key parameters ... */
name|deskey_1
operator|.
name|len
operator|=
literal|8
expr_stmt|;
name|deskey_2
operator|.
name|len
operator|=
literal|8
expr_stmt|;
name|deskey_3
operator|.
name|len
operator|=
literal|8
expr_stmt|;
name|deskey_1
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|(
name|ZEN_DES_KEY
operator|*
operator|)
operator|(
name|ctx
operator|->
name|cipher_data
operator|)
operator|)
operator|->
name|des_key
expr_stmt|;
name|deskey_2
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
name|ZEN_DES_KEY
operator|*
operator|)
operator|(
name|ctx
operator|->
name|cipher_data
operator|)
operator|)
operator|->
name|des_key
index|[
literal|8
index|]
expr_stmt|;
name|deskey_3
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
name|ZEN_DES_KEY
operator|*
operator|)
operator|(
name|ctx
operator|->
name|cipher_data
operator|)
operator|)
operator|->
name|des_key
index|[
literal|16
index|]
expr_stmt|;
comment|/* Key correct iv ... */
name|memcpy
argument_list|(
operator|(
operator|(
name|ZEN_DES_KEY
operator|*
operator|)
operator|(
name|ctx
operator|->
name|cipher_data
operator|)
operator|)
operator|->
name|des_iv
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|iv
operator|.
name|len
operator|=
literal|8
expr_stmt|;
name|iv
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|(
name|ZEN_DES_KEY
operator|*
operator|)
operator|(
name|ctx
operator|->
name|cipher_data
operator|)
operator|)
operator|->
name|des_iv
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|encrypt
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
operator|&
operator|(
name|input
operator|.
name|data
index|[
name|input
operator|.
name|len
operator|-
literal|8
index|]
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* Test with zenbridge library ... */
name|to_return
operator|=
name|ptr_zencod_xdes_cipher
argument_list|(
operator|&
name|output
argument_list|,
operator|&
name|input
argument_list|,
operator|(
name|zen_nb_t
operator|*
operator|)
operator|&
name|deskey_1
argument_list|,
operator|(
name|zen_nb_t
operator|*
operator|)
operator|&
name|deskey_2
argument_list|,
operator|(
name|zen_nb_t
operator|*
operator|)
operator|&
name|deskey_3
argument_list|,
operator|&
name|iv
argument_list|,
name|ctx
operator|->
name|encrypt
argument_list|)
expr_stmt|;
name|to_return
operator|=
operator|!
name|to_return
expr_stmt|;
comment|/* But we need to set up the rigth iv ... 	 * Test ENCRYPT or DECRYPT mode to set iv ... */
if|if
condition|(
name|ctx
operator|->
name|encrypt
operator|==
literal|1
condition|)
block|{
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
operator|&
operator|(
name|output
operator|.
name|data
index|[
name|output
operator|.
name|len
operator|-
literal|8
index|]
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|engine_des_ede3_init_key
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|iv
parameter_list|,
name|int
name|enc
parameter_list|)
block|{
name|ZEN_3DES_KEY
modifier|*
name|tmp_3des_key
init|=
name|NULL
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
name|tmp_3des_key
operator|=
operator|(
name|ZEN_3DES_KEY
operator|*
operator|)
operator|(
name|ctx
operator|->
name|cipher_data
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|tmp_3des_key
operator|->
name|des3_key
index|[
literal|0
index|]
operator|)
argument_list|,
name|key
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|tmp_3des_key
operator|->
name|des3_iv
index|[
literal|0
index|]
operator|)
argument_list|,
name|iv
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|1
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|engine_des_ede3_cbc_cipher
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|int
name|in_len
parameter_list|)
block|{
name|zen_nb_t
name|output
decl_stmt|,
name|input
decl_stmt|;
name|zen_nb_t
name|deskey_1
decl_stmt|,
name|deskey_2
decl_stmt|,
name|deskey_3
decl_stmt|,
name|iv
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
comment|/* Convert parameters ... */
name|input
operator|.
name|len
operator|=
name|in_len
expr_stmt|;
name|input
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in
expr_stmt|;
name|output
operator|.
name|len
operator|=
name|in_len
expr_stmt|;
name|output
operator|.
name|data
operator|=
name|out
expr_stmt|;
comment|/* Set key ... */
name|deskey_1
operator|.
name|len
operator|=
literal|8
expr_stmt|;
name|deskey_2
operator|.
name|len
operator|=
literal|8
expr_stmt|;
name|deskey_3
operator|.
name|len
operator|=
literal|8
expr_stmt|;
name|deskey_1
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|(
name|ZEN_3DES_KEY
operator|*
operator|)
operator|(
name|ctx
operator|->
name|cipher_data
operator|)
operator|)
operator|->
name|des3_key
expr_stmt|;
name|deskey_2
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
name|ZEN_3DES_KEY
operator|*
operator|)
operator|(
name|ctx
operator|->
name|cipher_data
operator|)
operator|)
operator|->
name|des3_key
index|[
literal|8
index|]
expr_stmt|;
name|deskey_3
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
name|ZEN_3DES_KEY
operator|*
operator|)
operator|(
name|ctx
operator|->
name|cipher_data
operator|)
operator|)
operator|->
name|des3_key
index|[
literal|16
index|]
expr_stmt|;
comment|/* Key correct iv ... */
name|memcpy
argument_list|(
operator|(
operator|(
name|ZEN_3DES_KEY
operator|*
operator|)
operator|(
name|ctx
operator|->
name|cipher_data
operator|)
operator|)
operator|->
name|des3_iv
argument_list|,
name|ctx
operator|->
name|iv
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|iv
operator|.
name|len
operator|=
literal|8
expr_stmt|;
name|iv
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|(
name|ZEN_3DES_KEY
operator|*
operator|)
operator|(
name|ctx
operator|->
name|cipher_data
operator|)
operator|)
operator|->
name|des3_iv
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|encrypt
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
operator|&
operator|(
name|input
operator|.
name|data
index|[
name|input
operator|.
name|len
operator|-
literal|8
index|]
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* Test with zenbridge library ... */
name|to_return
operator|=
name|ptr_zencod_xdes_cipher
argument_list|(
operator|&
name|output
argument_list|,
operator|&
name|input
argument_list|,
operator|(
name|zen_nb_t
operator|*
operator|)
operator|&
name|deskey_1
argument_list|,
operator|(
name|zen_nb_t
operator|*
operator|)
operator|&
name|deskey_2
argument_list|,
operator|(
name|zen_nb_t
operator|*
operator|)
operator|&
name|deskey_3
argument_list|,
operator|&
name|iv
argument_list|,
name|ctx
operator|->
name|encrypt
argument_list|)
expr_stmt|;
name|to_return
operator|=
operator|!
name|to_return
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|encrypt
operator|==
literal|1
condition|)
block|{
name|memcpy
argument_list|(
name|ctx
operator|->
name|iv
argument_list|,
operator|&
operator|(
name|output
operator|.
name|data
index|[
name|output
operator|.
name|len
operator|-
literal|8
index|]
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|engine_cipher_cleanup
parameter_list|(
name|EVP_CIPHER_CTX
modifier|*
name|ctx
parameter_list|)
block|{
comment|/* Set the key pointer ... */
if|if
condition|(
name|ctx
operator|->
name|cipher
operator|->
name|nid
operator|==
name|NID_rc4
operator|||
name|ctx
operator|->
name|cipher
operator|->
name|nid
operator|==
name|NID_rc4_40
condition|)
block|{ 	}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|cipher
operator|->
name|nid
operator|==
name|NID_des_cbc
condition|)
block|{ 	}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|cipher
operator|->
name|nid
operator|==
name|NID_des_ede3_cbc
condition|)
block|{ 	}
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_HW_ZENCOD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_HW */
end_comment

end_unit

