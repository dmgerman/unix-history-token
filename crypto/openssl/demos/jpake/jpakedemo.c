begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"openssl/bn.h"
end_include

begin_include
include|#
directive|include
file|"openssl/sha.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* Copyright (C) 2008 Ben Laurie (ben@links.org) */
end_comment

begin_comment
comment|/*  * Implement J-PAKE, as described in  * http://grouper.ieee.org/groups/1363/Research/contributions/hao-ryan-2008.pdf  *   * With hints from http://www.cl.cam.ac.uk/~fh240/software/JPAKE2.java.  */
end_comment

begin_function
specifier|static
name|void
name|showbn
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|bn
parameter_list|)
block|{
name|fputs
argument_list|(
name|name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" = "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|BN_print_fp
argument_list|(
name|stdout
argument_list|,
name|bn
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
comment|// Perhaps not the best place for this?
name|BIGNUM
modifier|*
name|p
decl_stmt|;
name|BIGNUM
modifier|*
name|q
decl_stmt|;
name|BIGNUM
modifier|*
name|g
decl_stmt|;
block|}
name|JPakeParameters
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|JPakeParametersInit
parameter_list|(
name|JPakeParameters
modifier|*
name|params
parameter_list|)
block|{
name|params
operator|->
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
comment|// For now use p, q, g from Java sample code. Later, generate them.
name|params
operator|->
name|p
operator|=
name|NULL
expr_stmt|;
name|BN_hex2bn
argument_list|(
operator|&
name|params
operator|->
name|p
argument_list|,
literal|"fd7f53811d75122952df4a9c2eece4e7f611b7523cef4400c31e3f80b6512669455d402251fb593d8d58fabfc5f5ba30f6cb9b556cd7813b801d346ff26660b76b9950a5a49f9fe8047b1022c24fbba9d7feb7c61bf83b57e7c6a8a6150f04fb83f6d3c51ec3023554135a169132f675f3ae2b61d72aeff22203199dd14801c7"
argument_list|)
expr_stmt|;
name|params
operator|->
name|q
operator|=
name|NULL
expr_stmt|;
name|BN_hex2bn
argument_list|(
operator|&
name|params
operator|->
name|q
argument_list|,
literal|"9760508f15230bccb292b982a2eb840bf0581cf5"
argument_list|)
expr_stmt|;
name|params
operator|->
name|g
operator|=
name|NULL
expr_stmt|;
name|BN_hex2bn
argument_list|(
operator|&
name|params
operator|->
name|g
argument_list|,
literal|"f7e1a085d69b3ddecbbcab5c36b857b97994afbbfa3aea82f9574c0b3d0782675159578ebad4594fe67107108180b449167123e84c281613b7cf09328cc8a6e13c167a8b547c8d28e0a3ae1e2bb3a675916ea37f0bfa213562f1fb627a01243bcca4f1bea8519089a883dfe15ae59f06928b665e807b552564014c3bfecf492a"
argument_list|)
expr_stmt|;
name|showbn
argument_list|(
literal|"p"
argument_list|,
name|params
operator|->
name|p
argument_list|)
expr_stmt|;
name|showbn
argument_list|(
literal|"q"
argument_list|,
name|params
operator|->
name|q
argument_list|)
expr_stmt|;
name|showbn
argument_list|(
literal|"g"
argument_list|,
name|params
operator|->
name|g
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|BIGNUM
modifier|*
name|gr
decl_stmt|;
comment|// g^r (r random)
name|BIGNUM
modifier|*
name|b
decl_stmt|;
comment|// b = r - x*h, h=hash(g, g^r, g^x, name)
block|}
name|JPakeZKP
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|BIGNUM
modifier|*
name|gx
decl_stmt|;
comment|// g^x
name|JPakeZKP
name|zkpx
decl_stmt|;
comment|// ZKP(x)
block|}
name|JPakeStep1
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|BIGNUM
modifier|*
name|X
decl_stmt|;
comment|// g^(xa + xc + xd) * xb * s
name|JPakeZKP
name|zkpxbs
decl_stmt|;
comment|// ZKP(xb * s)
block|}
name|JPakeStep2
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|// Must be unique
name|int
name|base
decl_stmt|;
comment|// 1 for Alice, 3 for Bob. Only used for printing stuff.
name|JPakeStep1
name|s1c
decl_stmt|;
comment|// Alice's g^x3, ZKP(x3) or Bob's g^x1, ZKP(x1)
name|JPakeStep1
name|s1d
decl_stmt|;
comment|// Alice's g^x4, ZKP(x4) or Bob's g^x2, ZKP(x2)
name|JPakeStep2
name|s2
decl_stmt|;
comment|// Alice's A, ZKP(x2 * s) or Bob's B, ZKP(x4 * s)
block|}
name|JPakeUserPublic
typedef|;
end_typedef

begin_comment
comment|/*  * The user structure. In the definition, (xa, xb, xc, xd) are Alice's  * (x1, x2, x3, x4) or Bob's (x3, x4, x1, x2). If you see what I mean.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|JPakeUserPublic
name|p
decl_stmt|;
name|BIGNUM
modifier|*
name|secret
decl_stmt|;
comment|// The shared secret
name|BIGNUM
modifier|*
name|key
decl_stmt|;
comment|// The calculated (shared) key
name|BIGNUM
modifier|*
name|xa
decl_stmt|;
comment|// Alice's x1 or Bob's x3
name|BIGNUM
modifier|*
name|xb
decl_stmt|;
comment|// Alice's x2 or Bob's x4
block|}
name|JPakeUser
typedef|;
end_typedef

begin_comment
comment|// Generate each party's random numbers. xa is in [0, q), xb is in [1, q).
end_comment

begin_function
specifier|static
name|void
name|genrand
parameter_list|(
name|JPakeUser
modifier|*
name|user
parameter_list|,
specifier|const
name|JPakeParameters
modifier|*
name|params
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|qm1
decl_stmt|;
comment|// xa in [0, q)
name|user
operator|->
name|xa
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_rand_range
argument_list|(
name|user
operator|->
name|xa
argument_list|,
name|params
operator|->
name|q
argument_list|)
expr_stmt|;
comment|// q-1
name|qm1
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_copy
argument_list|(
name|qm1
argument_list|,
name|params
operator|->
name|q
argument_list|)
expr_stmt|;
name|BN_sub_word
argument_list|(
name|qm1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// ... and xb in [0, q-1)
name|user
operator|->
name|xb
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_rand_range
argument_list|(
name|user
operator|->
name|xb
argument_list|,
name|qm1
argument_list|)
expr_stmt|;
comment|// [1, q)
name|BN_add_word
argument_list|(
name|user
operator|->
name|xb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// cleanup
name|BN_free
argument_list|(
name|qm1
argument_list|)
expr_stmt|;
comment|// Show
name|printf
argument_list|(
literal|"x%d"
argument_list|,
name|user
operator|->
name|p
operator|.
name|base
argument_list|)
expr_stmt|;
name|showbn
argument_list|(
literal|""
argument_list|,
name|user
operator|->
name|xa
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"x%d"
argument_list|,
name|user
operator|->
name|p
operator|.
name|base
operator|+
literal|1
argument_list|)
expr_stmt|;
name|showbn
argument_list|(
literal|""
argument_list|,
name|user
operator|->
name|xb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hashlength
parameter_list|(
name|SHA_CTX
modifier|*
name|sha
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
name|unsigned
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
name|assert
argument_list|(
name|l
operator|<=
literal|0xffff
argument_list|)
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|l
operator|>>
literal|8
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
name|l
operator|&
literal|0xff
expr_stmt|;
name|SHA1_Update
argument_list|(
name|sha
argument_list|,
name|b
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hashstring
parameter_list|(
name|SHA_CTX
modifier|*
name|sha
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|hashlength
argument_list|(
name|sha
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|SHA1_Update
argument_list|(
name|sha
argument_list|,
name|string
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hashbn
parameter_list|(
name|SHA_CTX
modifier|*
name|sha
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|bn
parameter_list|)
block|{
name|size_t
name|l
init|=
name|BN_num_bytes
argument_list|(
name|bn
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bin
init|=
name|alloca
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|hashlength
argument_list|(
name|sha
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|bn
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|SHA1_Update
argument_list|(
name|sha
argument_list|,
name|bin
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// h=hash(g, g^r, g^x, name)
end_comment

begin_function
specifier|static
name|void
name|zkpHash
parameter_list|(
name|BIGNUM
modifier|*
name|h
parameter_list|,
specifier|const
name|JPakeZKP
modifier|*
name|zkp
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|gx
parameter_list|,
specifier|const
name|JPakeUserPublic
modifier|*
name|from
parameter_list|,
specifier|const
name|JPakeParameters
modifier|*
name|params
parameter_list|)
block|{
name|unsigned
name|char
name|md
index|[
name|SHA_DIGEST_LENGTH
index|]
decl_stmt|;
name|SHA_CTX
name|sha
decl_stmt|;
comment|// XXX: hash should not allow moving of the boundaries - Java code
comment|// is flawed in this respect. Length encoding seems simplest.
name|SHA1_Init
argument_list|(
operator|&
name|sha
argument_list|)
expr_stmt|;
name|hashbn
argument_list|(
operator|&
name|sha
argument_list|,
name|params
operator|->
name|g
argument_list|)
expr_stmt|;
name|hashbn
argument_list|(
operator|&
name|sha
argument_list|,
name|zkp
operator|->
name|gr
argument_list|)
expr_stmt|;
name|hashbn
argument_list|(
operator|&
name|sha
argument_list|,
name|gx
argument_list|)
expr_stmt|;
name|hashstring
argument_list|(
operator|&
name|sha
argument_list|,
name|from
operator|->
name|name
argument_list|)
expr_stmt|;
name|SHA1_Final
argument_list|(
name|md
argument_list|,
operator|&
name|sha
argument_list|)
expr_stmt|;
name|BN_bin2bn
argument_list|(
name|md
argument_list|,
name|SHA_DIGEST_LENGTH
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Prove knowledge of x
end_comment

begin_comment
comment|// Note that we don't send g^x because, as it happens, we've always
end_comment

begin_comment
comment|// sent it elsewhere. Also note that because of that, we could avoid
end_comment

begin_comment
comment|// calculating it here, but we don't, for clarity...
end_comment

begin_function
specifier|static
name|void
name|CreateZKP
parameter_list|(
name|JPakeZKP
modifier|*
name|zkp
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|x
parameter_list|,
specifier|const
name|JPakeUser
modifier|*
name|us
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|zkpg
parameter_list|,
specifier|const
name|JPakeParameters
modifier|*
name|params
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|r
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|gx
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|h
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t
init|=
name|BN_new
argument_list|()
decl_stmt|;
comment|// r in [0,q)
comment|// XXX: Java chooses r in [0, 2^160) - i.e. distribution not uniform
name|BN_rand_range
argument_list|(
name|r
argument_list|,
name|params
operator|->
name|q
argument_list|)
expr_stmt|;
comment|// g^r
name|zkp
operator|->
name|gr
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|zkp
operator|->
name|gr
argument_list|,
name|zkpg
argument_list|,
name|r
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// g^x
name|BN_mod_exp
argument_list|(
name|gx
argument_list|,
name|zkpg
argument_list|,
name|x
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// h=hash...
name|zkpHash
argument_list|(
name|h
argument_list|,
name|zkp
argument_list|,
name|gx
argument_list|,
operator|&
name|us
operator|->
name|p
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|// b = r - x*h
name|BN_mod_mul
argument_list|(
name|t
argument_list|,
name|x
argument_list|,
name|h
argument_list|,
name|params
operator|->
name|q
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|zkp
operator|->
name|b
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_mod_sub
argument_list|(
name|zkp
operator|->
name|b
argument_list|,
name|r
argument_list|,
name|t
argument_list|,
name|params
operator|->
name|q
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// show
name|printf
argument_list|(
literal|"  ZKP(x%d%s)\n"
argument_list|,
name|n
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|showbn
argument_list|(
literal|"   zkpg"
argument_list|,
name|zkpg
argument_list|)
expr_stmt|;
name|showbn
argument_list|(
literal|"    g^x"
argument_list|,
name|gx
argument_list|)
expr_stmt|;
name|showbn
argument_list|(
literal|"    g^r"
argument_list|,
name|zkp
operator|->
name|gr
argument_list|)
expr_stmt|;
name|showbn
argument_list|(
literal|"      b"
argument_list|,
name|zkp
operator|->
name|b
argument_list|)
expr_stmt|;
comment|// cleanup
name|BN_free
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|gx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|VerifyZKP
parameter_list|(
specifier|const
name|JPakeZKP
modifier|*
name|zkp
parameter_list|,
name|BIGNUM
modifier|*
name|gx
parameter_list|,
specifier|const
name|JPakeUserPublic
modifier|*
name|them
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|zkpg
parameter_list|,
specifier|const
name|JPakeParameters
modifier|*
name|params
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|h
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t1
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t2
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t3
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|zkpHash
argument_list|(
name|h
argument_list|,
name|zkp
argument_list|,
name|gx
argument_list|,
name|them
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|// t1 = g^b
name|BN_mod_exp
argument_list|(
name|t1
argument_list|,
name|zkpg
argument_list|,
name|zkp
operator|->
name|b
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// t2 = (g^x)^h = g^{hx}
name|BN_mod_exp
argument_list|(
name|t2
argument_list|,
name|gx
argument_list|,
name|h
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// t3 = t1 * t2 = g^{hx} * g^b = g^{hx+b} = g^r (allegedly)
name|BN_mod_mul
argument_list|(
name|t3
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ZKP(x%d%s)\n"
argument_list|,
name|n
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|showbn
argument_list|(
literal|"    zkpg"
argument_list|,
name|zkpg
argument_list|)
expr_stmt|;
name|showbn
argument_list|(
literal|"    g^r'"
argument_list|,
name|t3
argument_list|)
expr_stmt|;
comment|// verify t3 == g^r
if|if
condition|(
name|BN_cmp
argument_list|(
name|t3
argument_list|,
name|zkp
operator|->
name|gr
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
comment|// cleanup
name|BN_free
argument_list|(
name|t3
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|puts
argument_list|(
literal|"    OK"
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
literal|"    FAIL"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sendstep1_substep
parameter_list|(
name|JPakeStep1
modifier|*
name|s1
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|x
parameter_list|,
specifier|const
name|JPakeUser
modifier|*
name|us
parameter_list|,
specifier|const
name|JPakeParameters
modifier|*
name|params
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|s1
operator|->
name|gx
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|s1
operator|->
name|gx
argument_list|,
name|params
operator|->
name|g
argument_list|,
name|x
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  g^{x%d}"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|showbn
argument_list|(
literal|""
argument_list|,
name|s1
operator|->
name|gx
argument_list|)
expr_stmt|;
name|CreateZKP
argument_list|(
operator|&
name|s1
operator|->
name|zkpx
argument_list|,
name|x
argument_list|,
name|us
argument_list|,
name|params
operator|->
name|g
argument_list|,
name|params
argument_list|,
name|n
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sendstep1
parameter_list|(
specifier|const
name|JPakeUser
modifier|*
name|us
parameter_list|,
name|JPakeUserPublic
modifier|*
name|them
parameter_list|,
specifier|const
name|JPakeParameters
modifier|*
name|params
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\n%s sends %s:\n\n"
argument_list|,
name|us
operator|->
name|p
operator|.
name|name
argument_list|,
name|them
operator|->
name|name
argument_list|)
expr_stmt|;
comment|// from's g^xa (which becomes to's g^xc) and ZKP(xa)
name|sendstep1_substep
argument_list|(
operator|&
name|them
operator|->
name|s1c
argument_list|,
name|us
operator|->
name|xa
argument_list|,
name|us
argument_list|,
name|params
argument_list|,
name|us
operator|->
name|p
operator|.
name|base
argument_list|)
expr_stmt|;
comment|// from's g^xb (which becomes to's g^xd) and ZKP(xb)
name|sendstep1_substep
argument_list|(
operator|&
name|them
operator|->
name|s1d
argument_list|,
name|us
operator|->
name|xb
argument_list|,
name|us
argument_list|,
name|params
argument_list|,
name|us
operator|->
name|p
operator|.
name|base
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|verifystep1
parameter_list|(
specifier|const
name|JPakeUser
modifier|*
name|us
parameter_list|,
specifier|const
name|JPakeUserPublic
modifier|*
name|them
parameter_list|,
specifier|const
name|JPakeParameters
modifier|*
name|params
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\n%s verifies %s:\n\n"
argument_list|,
name|us
operator|->
name|p
operator|.
name|name
argument_list|,
name|them
operator|->
name|name
argument_list|)
expr_stmt|;
comment|// verify their ZKP(xc)
if|if
condition|(
operator|!
name|VerifyZKP
argument_list|(
operator|&
name|us
operator|->
name|p
operator|.
name|s1c
operator|.
name|zkpx
argument_list|,
name|us
operator|->
name|p
operator|.
name|s1c
operator|.
name|gx
argument_list|,
name|them
argument_list|,
name|params
operator|->
name|g
argument_list|,
name|params
argument_list|,
name|them
operator|->
name|base
argument_list|,
literal|""
argument_list|)
condition|)
return|return
literal|0
return|;
comment|// verify their ZKP(xd)
if|if
condition|(
operator|!
name|VerifyZKP
argument_list|(
operator|&
name|us
operator|->
name|p
operator|.
name|s1d
operator|.
name|zkpx
argument_list|,
name|us
operator|->
name|p
operator|.
name|s1d
operator|.
name|gx
argument_list|,
name|them
argument_list|,
name|params
operator|->
name|g
argument_list|,
name|params
argument_list|,
name|them
operator|->
name|base
operator|+
literal|1
argument_list|,
literal|""
argument_list|)
condition|)
return|return
literal|0
return|;
comment|// g^xd != 1
name|printf
argument_list|(
literal|"  g^{x%d} != 1: "
argument_list|,
name|them
operator|->
name|base
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_one
argument_list|(
name|us
operator|->
name|p
operator|.
name|s1d
operator|.
name|gx
argument_list|)
condition|)
block|{
name|puts
argument_list|(
literal|"FAIL"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|puts
argument_list|(
literal|"OK"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sendstep2
parameter_list|(
specifier|const
name|JPakeUser
modifier|*
name|us
parameter_list|,
name|JPakeUserPublic
modifier|*
name|them
parameter_list|,
specifier|const
name|JPakeParameters
modifier|*
name|params
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|t1
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t2
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|printf
argument_list|(
literal|"\n%s sends %s:\n\n"
argument_list|,
name|us
operator|->
name|p
operator|.
name|name
argument_list|,
name|them
operator|->
name|name
argument_list|)
expr_stmt|;
comment|// X = g^{(xa + xc + xd) * xb * s}
comment|// t1 = g^xa
name|BN_mod_exp
argument_list|(
name|t1
argument_list|,
name|params
operator|->
name|g
argument_list|,
name|us
operator|->
name|xa
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// t2 = t1 * g^{xc} = g^{xa} * g^{xc} = g^{xa + xc}
name|BN_mod_mul
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|,
name|us
operator|->
name|p
operator|.
name|s1c
operator|.
name|gx
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// t1 = t2 * g^{xd} = g^{xa + xc + xd}
name|BN_mod_mul
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|us
operator|->
name|p
operator|.
name|s1d
operator|.
name|gx
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// t2 = xb * s
name|BN_mod_mul
argument_list|(
name|t2
argument_list|,
name|us
operator|->
name|xb
argument_list|,
name|us
operator|->
name|secret
argument_list|,
name|params
operator|->
name|q
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// X = t1^{t2} = t1^{xb * s} = g^{(xa + xc + xd) * xb * s}
name|them
operator|->
name|s2
operator|.
name|X
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|them
operator|->
name|s2
operator|.
name|X
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// Show
name|printf
argument_list|(
literal|"  g^{(x%d + x%d + x%d) * x%d * s)"
argument_list|,
name|us
operator|->
name|p
operator|.
name|base
argument_list|,
name|them
operator|->
name|base
argument_list|,
name|them
operator|->
name|base
operator|+
literal|1
argument_list|,
name|us
operator|->
name|p
operator|.
name|base
operator|+
literal|1
argument_list|)
expr_stmt|;
name|showbn
argument_list|(
literal|""
argument_list|,
name|them
operator|->
name|s2
operator|.
name|X
argument_list|)
expr_stmt|;
comment|// ZKP(xb * s)
comment|// XXX: this is kinda funky, because we're using
comment|//
comment|// g' = g^{xa + xc + xd}
comment|//
comment|// as the generator, which means X is g'^{xb * s}
name|CreateZKP
argument_list|(
operator|&
name|them
operator|->
name|s2
operator|.
name|zkpxbs
argument_list|,
name|t2
argument_list|,
name|us
argument_list|,
name|t1
argument_list|,
name|params
argument_list|,
name|us
operator|->
name|p
operator|.
name|base
operator|+
literal|1
argument_list|,
literal|" * s"
argument_list|)
expr_stmt|;
comment|// cleanup
name|BN_free
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|verifystep2
parameter_list|(
specifier|const
name|JPakeUser
modifier|*
name|us
parameter_list|,
specifier|const
name|JPakeUserPublic
modifier|*
name|them
parameter_list|,
specifier|const
name|JPakeParameters
modifier|*
name|params
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|t1
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t2
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"\n%s verifies %s:\n\n"
argument_list|,
name|us
operator|->
name|p
operator|.
name|name
argument_list|,
name|them
operator|->
name|name
argument_list|)
expr_stmt|;
comment|// g' = g^{xc + xa + xb} [from our POV]
comment|// t1 = xa + xb
name|BN_mod_add
argument_list|(
name|t1
argument_list|,
name|us
operator|->
name|xa
argument_list|,
name|us
operator|->
name|xb
argument_list|,
name|params
operator|->
name|q
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// t2 = g^{t1} = g^{xa+xb}
name|BN_mod_exp
argument_list|(
name|t2
argument_list|,
name|params
operator|->
name|g
argument_list|,
name|t1
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// t1 = g^{xc} * t2 = g^{xc + xa + xb}
name|BN_mod_mul
argument_list|(
name|t1
argument_list|,
name|us
operator|->
name|p
operator|.
name|s1c
operator|.
name|gx
argument_list|,
name|t2
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|VerifyZKP
argument_list|(
operator|&
name|us
operator|->
name|p
operator|.
name|s2
operator|.
name|zkpxbs
argument_list|,
name|us
operator|->
name|p
operator|.
name|s2
operator|.
name|X
argument_list|,
name|them
argument_list|,
name|t1
argument_list|,
name|params
argument_list|,
name|them
operator|->
name|base
operator|+
literal|1
argument_list|,
literal|" * s"
argument_list|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
comment|// cleanup
name|BN_free
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|computekey
parameter_list|(
name|JPakeUser
modifier|*
name|us
parameter_list|,
specifier|const
name|JPakeParameters
modifier|*
name|params
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|t1
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t2
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|BIGNUM
modifier|*
name|t3
init|=
name|BN_new
argument_list|()
decl_stmt|;
name|printf
argument_list|(
literal|"\n%s calculates the shared key:\n\n"
argument_list|,
name|us
operator|->
name|p
operator|.
name|name
argument_list|)
expr_stmt|;
comment|// K = (X/g^{xb * xd * s})^{xb}
comment|//   = (g^{(xc + xa + xb) * xd * s - xb * xd *s})^{xb}
comment|//   = (g^{(xa + xc) * xd * s})^{xb}
comment|//   = g^{(xa + xc) * xb * xd * s}
comment|// [which is the same regardless of who calculates it]
comment|// t1 = (g^{xd})^{xb} = g^{xb * xd}
name|BN_mod_exp
argument_list|(
name|t1
argument_list|,
name|us
operator|->
name|p
operator|.
name|s1d
operator|.
name|gx
argument_list|,
name|us
operator|->
name|xb
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// t2 = -s = q-s
name|BN_sub
argument_list|(
name|t2
argument_list|,
name|params
operator|->
name|q
argument_list|,
name|us
operator|->
name|secret
argument_list|)
expr_stmt|;
comment|// t3 = t1^t2 = g^{-xb * xd * s}
name|BN_mod_exp
argument_list|(
name|t3
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// t1 = X * t3 = X/g^{xb * xd * s}
name|BN_mod_mul
argument_list|(
name|t1
argument_list|,
name|us
operator|->
name|p
operator|.
name|s2
operator|.
name|X
argument_list|,
name|t3
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// K = t1^{xb}
name|us
operator|->
name|key
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|us
operator|->
name|key
argument_list|,
name|t1
argument_list|,
name|us
operator|->
name|xb
argument_list|,
name|params
operator|->
name|p
argument_list|,
name|params
operator|->
name|ctx
argument_list|)
expr_stmt|;
comment|// show
name|showbn
argument_list|(
literal|"  K"
argument_list|,
name|us
operator|->
name|key
argument_list|)
expr_stmt|;
comment|// cleanup
name|BN_free
argument_list|(
name|t3
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|JPakeParameters
name|params
decl_stmt|;
name|JPakeUser
name|alice
decl_stmt|,
name|bob
decl_stmt|;
name|alice
operator|.
name|p
operator|.
name|name
operator|=
literal|"Alice"
expr_stmt|;
name|alice
operator|.
name|p
operator|.
name|base
operator|=
literal|1
expr_stmt|;
name|bob
operator|.
name|p
operator|.
name|name
operator|=
literal|"Bob"
expr_stmt|;
name|bob
operator|.
name|p
operator|.
name|base
operator|=
literal|3
expr_stmt|;
name|JPakeParametersInit
argument_list|(
operator|&
name|params
argument_list|)
expr_stmt|;
comment|// Shared secret
name|alice
operator|.
name|secret
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_rand
argument_list|(
name|alice
operator|.
name|secret
argument_list|,
literal|32
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bob
operator|.
name|secret
operator|=
name|alice
operator|.
name|secret
expr_stmt|;
name|showbn
argument_list|(
literal|"secret"
argument_list|,
name|alice
operator|.
name|secret
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|BN_cmp
argument_list|(
name|alice
operator|.
name|secret
argument_list|,
name|params
operator|.
name|q
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
comment|// Alice's x1, x2
name|genrand
argument_list|(
operator|&
name|alice
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
comment|// Bob's x3, x4
name|genrand
argument_list|(
operator|&
name|bob
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
comment|// Now send stuff to each other...
name|sendstep1
argument_list|(
operator|&
name|alice
argument_list|,
operator|&
name|bob
operator|.
name|p
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|sendstep1
argument_list|(
operator|&
name|bob
argument_list|,
operator|&
name|alice
operator|.
name|p
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
comment|// And verify what each other sent
if|if
condition|(
operator|!
name|verifystep1
argument_list|(
operator|&
name|alice
argument_list|,
operator|&
name|bob
operator|.
name|p
argument_list|,
operator|&
name|params
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|verifystep1
argument_list|(
operator|&
name|bob
argument_list|,
operator|&
name|alice
operator|.
name|p
argument_list|,
operator|&
name|params
argument_list|)
condition|)
return|return
literal|2
return|;
comment|// Second send
name|sendstep2
argument_list|(
operator|&
name|alice
argument_list|,
operator|&
name|bob
operator|.
name|p
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|sendstep2
argument_list|(
operator|&
name|bob
argument_list|,
operator|&
name|alice
operator|.
name|p
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
comment|// And second verify
if|if
condition|(
operator|!
name|verifystep2
argument_list|(
operator|&
name|alice
argument_list|,
operator|&
name|bob
operator|.
name|p
argument_list|,
operator|&
name|params
argument_list|)
condition|)
return|return
literal|3
return|;
if|if
condition|(
operator|!
name|verifystep2
argument_list|(
operator|&
name|bob
argument_list|,
operator|&
name|alice
operator|.
name|p
argument_list|,
operator|&
name|params
argument_list|)
condition|)
return|return
literal|4
return|;
comment|// Compute common key
name|computekey
argument_list|(
operator|&
name|alice
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|computekey
argument_list|(
operator|&
name|bob
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
comment|// Confirm the common key is identical
comment|// XXX: if the two secrets are not the same, everything works up
comment|// to this point, so the only way to detect a failure is by the
comment|// difference in the calculated keys.
comment|// Since we're all the same code, just compare them directly. In a
comment|// real system, Alice sends Bob H(H(K)), Bob checks it, then sends
comment|// back H(K), which Alice checks, or something equivalent.
name|puts
argument_list|(
literal|"\nAlice and Bob check keys are the same:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_cmp
argument_list|(
name|alice
operator|.
name|key
argument_list|,
name|bob
operator|.
name|key
argument_list|)
operator|==
literal|0
condition|)
name|puts
argument_list|(
literal|"  OK"
argument_list|)
expr_stmt|;
else|else
block|{
name|puts
argument_list|(
literal|"  FAIL"
argument_list|)
expr_stmt|;
return|return
literal|5
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

