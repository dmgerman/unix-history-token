begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
name|defined
argument_list|(
name|NO_BUFFER
argument_list|)
operator|||
name|defined
argument_list|(
name|NO_IP
argument_list|)
operator|||
name|defined
argument_list|(
name|NO_OPENSSL
argument_list|)
end_if

begin_error
error|#
directive|error
literal|"Badness, NO_BUFFER, NO_IP or NO_OPENSSL is defined, turn them *off*"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Include our bits'n'pieces */
end_comment

begin_include
include|#
directive|include
file|"tunala.h"
end_include

begin_comment
comment|/********************************************/
end_comment

begin_comment
comment|/* Our local types that specify our "world" */
end_comment

begin_comment
comment|/********************************************/
end_comment

begin_comment
comment|/* These represent running "tunnels". Eg. if you wanted to do SSL in a  * "message-passing" scanario, the "int" file-descriptors might be replaced by  * thread or process IDs, and the "select" code might be replaced by message  * handling code. Whatever. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_tunala_item_t
block|{
comment|/* The underlying SSL state machine. This is a data-only processing unit 	 * and we communicate with it by talking to its four "buffers". */
name|state_machine_t
name|sm
decl_stmt|;
comment|/* The file-descriptors for the "dirty" (encrypted) side of the SSL 	 * setup. In actuality, this is typically a socket and both values are 	 * identical. */
name|int
name|dirty_read
decl_stmt|,
name|dirty_send
decl_stmt|;
comment|/* The file-descriptors for the "clean" (unencrypted) side of the SSL 	 * setup. These could be stdin/stdout, a socket (both values the same), 	 * or whatever you like. */
name|int
name|clean_read
decl_stmt|,
name|clean_send
decl_stmt|;
block|}
name|tunala_item_t
typedef|;
end_typedef

begin_comment
comment|/* This structure is used as the data for running the main loop. Namely, in a  * network format such as this, it is stuff for select() - but as pointed out,  * when moving the real-world to somewhere else, this might be replaced by  * something entirely different. It's basically the stuff that controls when  * it's time to do some "work". */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_select_sets_t
block|{
name|int
name|max
decl_stmt|;
comment|/* As required as the first argument to select() */
name|fd_set
name|reads
decl_stmt|,
name|sends
decl_stmt|,
name|excepts
decl_stmt|;
comment|/* As passed to select() */
block|}
name|select_sets_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_tunala_selector_t
block|{
name|select_sets_t
name|last_selected
decl_stmt|;
comment|/* Results of the last select() */
name|select_sets_t
name|next_select
decl_stmt|;
comment|/* What we'll next select on */
block|}
name|tunala_selector_t
typedef|;
end_typedef

begin_comment
comment|/* This structure is *everything*. We do it to avoid the use of globals so that,  * for example, it would be easier to shift things around between async-IO,  * thread-based, or multi-fork()ed (or combinations thereof). */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_tunala_world_t
block|{
comment|/* The file-descriptor we "listen" on for new connections */
name|int
name|listen_fd
decl_stmt|;
comment|/* The array of tunnels */
name|tunala_item_t
modifier|*
name|tunnels
decl_stmt|;
comment|/* the number of tunnels in use and allocated, respectively */
name|unsigned
name|int
name|tunnels_used
decl_stmt|,
name|tunnels_size
decl_stmt|;
comment|/* Our outside "loop" context stuff */
name|tunala_selector_t
name|selector
decl_stmt|;
comment|/* Our SSL_CTX, which is configured as the SSL client or server and has 	 * the various cert-settings and callbacks configured. */
name|SSL_CTX
modifier|*
name|ssl_ctx
decl_stmt|;
comment|/* Simple flag with complex logic :-) Indicates whether we're an SSL 	 * server or an SSL client. */
name|int
name|server_mode
decl_stmt|;
block|}
name|tunala_world_t
typedef|;
end_typedef

begin_comment
comment|/*****************************/
end_comment

begin_comment
comment|/* Internal static functions */
end_comment

begin_comment
comment|/*****************************/
end_comment

begin_function_decl
specifier|static
name|SSL_CTX
modifier|*
name|initialise_ssl_ctx
parameter_list|(
name|int
name|server_mode
parameter_list|,
specifier|const
name|char
modifier|*
name|engine_id
parameter_list|,
specifier|const
name|char
modifier|*
name|CAfile
parameter_list|,
specifier|const
name|char
modifier|*
name|cert
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|dcert
parameter_list|,
specifier|const
name|char
modifier|*
name|dkey
parameter_list|,
specifier|const
name|char
modifier|*
name|cipher_list
parameter_list|,
specifier|const
name|char
modifier|*
name|dh_file
parameter_list|,
specifier|const
name|char
modifier|*
name|dh_special
parameter_list|,
name|int
name|ctx_options
parameter_list|,
name|int
name|out_state
parameter_list|,
name|int
name|out_verify
parameter_list|,
name|int
name|verify_mode
parameter_list|,
name|unsigned
name|int
name|verify_depth
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|selector_init
parameter_list|(
name|tunala_selector_t
modifier|*
name|selector
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|selector_add_listener
parameter_list|(
name|tunala_selector_t
modifier|*
name|selector
parameter_list|,
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|selector_add_tunala
parameter_list|(
name|tunala_selector_t
modifier|*
name|selector
parameter_list|,
name|tunala_item_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|selector_select
parameter_list|(
name|tunala_selector_t
modifier|*
name|selector
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This returns -1 for error, 0 for no new connections, or 1 for success, in  * which case *newfd is populated. */
end_comment

begin_function_decl
specifier|static
name|int
name|selector_get_listener
parameter_list|(
name|tunala_selector_t
modifier|*
name|selector
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
modifier|*
name|newfd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tunala_world_new_item
parameter_list|(
name|tunala_world_t
modifier|*
name|world
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|ip
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|,
name|int
name|flipped
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tunala_world_del_item
parameter_list|(
name|tunala_world_t
modifier|*
name|world
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tunala_item_io
parameter_list|(
name|tunala_selector_t
modifier|*
name|selector
parameter_list|,
name|tunala_item_t
modifier|*
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*********************************************/
end_comment

begin_comment
comment|/* MAIN FUNCTION (and its utility functions) */
end_comment

begin_comment
comment|/*********************************************/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|def_proxyhost
init|=
literal|"127.0.0.1:443"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|def_listenhost
init|=
literal|"127.0.0.1:8080"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|def_max_tunnels
init|=
literal|50
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|def_cacert
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|def_cert
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|def_key
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|def_dcert
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|def_dkey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|def_engine_id
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|def_server_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|def_flipped
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|def_cipher_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|def_dh_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|def_dh_special
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|def_ctx_options
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|def_verify_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|def_verify_depth
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|def_out_state
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|def_out_verify
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|def_out_totals
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|def_out_conns
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|helpstring
init|=
literal|"\n'Tunala' (A tunneler with a New Zealand accent)\n"
literal|"Usage: tunala [options], where options are from;\n"
literal|" -listen [host:]<port>  (default = 127.0.0.1:8080)\n"
literal|" -proxy<host>:<port>   (default = 127.0.0.1:443)\n"
literal|" -maxtunnels<num>      (default = 50)\n"
literal|" -cacert<path|NULL>    (default = NULL)\n"
literal|" -cert<path|NULL>      (default = NULL)\n"
literal|" -key<path|NULL>       (default = whatever '-cert' is)\n"
literal|" -dcert<path|NULL>     (usually for DSA, default = NULL)\n"
literal|" -dkey<path|NULL>      (usually for DSA, default = whatever '-dcert' is)\n"
literal|" -engine<id|NULL>      (default = NULL)\n"
literal|" -server<0|1>          (default = 0, ie. an SSL client)\n"
literal|" -flipped<0|1>         (makes SSL servers be network clients, and vice versa)\n"
literal|" -cipher<list>         (specifies cipher list to use)\n"
literal|" -dh_file<path>        (a PEM file containing DH parameters to use)\n"
literal|" -dh_special<NULL|generate|standard> (see below: def=NULL)\n"
literal|" -no_ssl2               (disable SSLv2)\n"
literal|" -no_ssl3               (disable SSLv3)\n"
literal|" -no_tls1               (disable TLSv1)\n"
literal|" -v_peer                (verify the peer certificate)\n"
literal|" -v_strict              (do not continue if peer doesn't authenticate)\n"
literal|" -v_once                (no verification in renegotiates)\n"
literal|" -v_depth<num>         (limit certificate chain depth, default = 10)\n"
literal|" -out_conns             (prints client connections and disconnections)\n"
literal|" -out_state             (prints SSL handshake states)\n"
literal|" -out_verify<0|1|2|3>  (prints certificate verification states: def=1)\n"
literal|" -out_totals            (prints out byte-totals when a tunnel closes)\n"
literal|" -<h|help|?>            (displays this help screen)\n"
literal|"Notes:\n"
literal|"(1) It is recommended to specify a cert+key when operating as an SSL server.\n"
literal|"    If you only specify '-cert', the same file must contain a matching\n"
literal|"    private key.\n"
literal|"(2) Either dh_file or dh_special can be used to specify where DH parameters\n"
literal|"    will be obtained from (or '-dh_special NULL' for the default choice) but\n"
literal|"    you cannot specify both. For dh_special, 'generate' will create new DH\n"
literal|"    parameters on startup, and 'standard' will use embedded parameters\n"
literal|"    instead.\n"
literal|"(3) Normally an ssl client connects to an ssl server - so that an 'ssl client\n"
literal|"    tunala' listens for 'clean' client connections and proxies ssl, and an\n"
literal|"    'ssl server tunala' listens for ssl connections and proxies 'clean'. With\n"
literal|"    '-flipped 1', this behaviour is reversed so that an 'ssl server tunala'\n"
literal|"    listens for clean client connections and proxies ssl (but participating\n"
literal|"    as an ssl *server* in the SSL/TLS protocol), and an 'ssl client tunala'\n"
literal|"    listens for ssl connections (participating as an ssl *client* in the\n"
literal|"    SSL/TLS protocol) and proxies 'clean' to the end destination. This can\n"
literal|"    be useful for allowing network access to 'servers' where only the server\n"
literal|"    needs to authenticate the client (ie. the other way is not required).\n"
literal|"    Even with client and server authentication, this 'technique' mitigates\n"
literal|"    some DoS (denial-of-service) potential as it will be the network client\n"
literal|"    having to perform the first private key operation rather than the other\n"
literal|"    way round.\n"
literal|"(4) The 'technique' used by setting '-flipped 1' is probably compatible with\n"
literal|"    absolutely nothing except another complimentary instance of 'tunala'\n"
literal|"    running with '-flipped 1'. :-)\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default DH parameters for use with "-dh_special standard" ... stolen striaght  * from s_server. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|dh512_p
index|[]
init|=
block|{
literal|0xDA
block|,
literal|0x58
block|,
literal|0x3C
block|,
literal|0x16
block|,
literal|0xD9
block|,
literal|0x85
block|,
literal|0x22
block|,
literal|0x89
block|,
literal|0xD0
block|,
literal|0xE4
block|,
literal|0xAF
block|,
literal|0x75
block|,
literal|0x6F
block|,
literal|0x4C
block|,
literal|0xCA
block|,
literal|0x92
block|,
literal|0xDD
block|,
literal|0x4B
block|,
literal|0xE5
block|,
literal|0x33
block|,
literal|0xB8
block|,
literal|0x04
block|,
literal|0xFB
block|,
literal|0x0F
block|,
literal|0xED
block|,
literal|0x94
block|,
literal|0xEF
block|,
literal|0x9C
block|,
literal|0x8A
block|,
literal|0x44
block|,
literal|0x03
block|,
literal|0xED
block|,
literal|0x57
block|,
literal|0x46
block|,
literal|0x50
block|,
literal|0xD3
block|,
literal|0x69
block|,
literal|0x99
block|,
literal|0xDB
block|,
literal|0x29
block|,
literal|0xD7
block|,
literal|0x76
block|,
literal|0x27
block|,
literal|0x6B
block|,
literal|0xA2
block|,
literal|0xD3
block|,
literal|0xD4
block|,
literal|0x12
block|,
literal|0xE2
block|,
literal|0x18
block|,
literal|0xF4
block|,
literal|0xDD
block|,
literal|0x1E
block|,
literal|0x08
block|,
literal|0x4C
block|,
literal|0xF6
block|,
literal|0xD8
block|,
literal|0x00
block|,
literal|0x3E
block|,
literal|0x7C
block|,
literal|0x47
block|,
literal|0x74
block|,
literal|0xE8
block|,
literal|0x33
block|, 	}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|dh512_g
index|[]
init|=
block|{
literal|0x02
block|, 	}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* And the function that parses the above "standard" parameters, again, straight  * out of s_server. */
end_comment

begin_function
specifier|static
name|DH
modifier|*
name|get_dh512
parameter_list|(
name|void
parameter_list|)
block|{
name|DH
modifier|*
name|dh
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|dh
operator|=
name|DH_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dh
operator|->
name|p
operator|=
name|BN_bin2bn
argument_list|(
name|dh512_p
argument_list|,
sizeof|sizeof
argument_list|(
name|dh512_p
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dh
operator|->
name|g
operator|=
name|BN_bin2bn
argument_list|(
name|dh512_g
argument_list|,
sizeof|sizeof
argument_list|(
name|dh512_g
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dh
operator|->
name|p
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dh
operator|->
name|g
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|dh
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Various help/error messages used by main() */
end_comment

begin_function
specifier|static
name|int
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|errstr
parameter_list|,
name|int
name|isunknownarg
parameter_list|)
block|{
if|if
condition|(
name|isunknownarg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: unknown argument '%s'\n"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|helpstring
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|err_str0
parameter_list|(
specifier|const
name|char
modifier|*
name|str0
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|str0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|err_str1
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|str1
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|str1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_max_tunnels
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|int
modifier|*
name|maxtunnels
parameter_list|)
block|{
name|unsigned
name|long
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|int_strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|l
argument_list|)
operator|||
operator|(
name|l
operator|<
literal|1
operator|)
operator|||
operator|(
name|l
operator|>
literal|1024
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error, '%s' is an invalid value for "
literal|"maxtunnels\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|maxtunnels
operator|=
operator|(
name|unsigned
name|int
operator|)
name|l
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_server_mode
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|servermode
parameter_list|)
block|{
name|unsigned
name|long
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|int_strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|l
argument_list|)
operator|||
operator|(
name|l
operator|>
literal|1
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error, '%s' is an invalid value for the "
literal|"server mode\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|servermode
operator|=
operator|(
name|int
operator|)
name|l
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_dh_special
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|dh_special
parameter_list|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"NULL"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"generate"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"standard"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|dh_special
operator|=
name|s
expr_stmt|;
return|return
literal|1
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error, '%s' is an invalid value for 'dh_special'\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_verify_level
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|int
modifier|*
name|verify_level
parameter_list|)
block|{
name|unsigned
name|long
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|int_strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|l
argument_list|)
operator|||
operator|(
name|l
operator|>
literal|3
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error, '%s' is an invalid value for "
literal|"out_verify\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|verify_level
operator|=
operator|(
name|unsigned
name|int
operator|)
name|l
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_verify_depth
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|int
modifier|*
name|verify_depth
parameter_list|)
block|{
name|unsigned
name|long
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|int_strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|l
argument_list|)
operator|||
operator|(
name|l
operator|<
literal|1
operator|)
operator|||
operator|(
name|l
operator|>
literal|50
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error, '%s' is an invalid value for "
literal|"verify_depth\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|verify_depth
operator|=
operator|(
name|unsigned
name|int
operator|)
name|l
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Some fprintf format strings used when tunnels close */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|io_stats_dirty
init|=
literal|"    SSL traffic;   %8lu bytes in, %8lu bytes out\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|io_stats_clean
init|=
literal|"    clear traffic; %8lu bytes in, %8lu bytes out\n"
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|unsigned
name|int
name|loop
decl_stmt|;
name|int
name|newfd
decl_stmt|;
name|tunala_world_t
name|world
decl_stmt|;
name|tunala_item_t
modifier|*
name|t_item
decl_stmt|;
specifier|const
name|char
modifier|*
name|proxy_ip
decl_stmt|;
name|unsigned
name|short
name|proxy_port
decl_stmt|;
comment|/* Overridables */
specifier|const
name|char
modifier|*
name|proxyhost
init|=
name|def_proxyhost
decl_stmt|;
specifier|const
name|char
modifier|*
name|listenhost
init|=
name|def_listenhost
decl_stmt|;
name|unsigned
name|int
name|max_tunnels
init|=
name|def_max_tunnels
decl_stmt|;
specifier|const
name|char
modifier|*
name|cacert
init|=
name|def_cacert
decl_stmt|;
specifier|const
name|char
modifier|*
name|cert
init|=
name|def_cert
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
init|=
name|def_key
decl_stmt|;
specifier|const
name|char
modifier|*
name|dcert
init|=
name|def_dcert
decl_stmt|;
specifier|const
name|char
modifier|*
name|dkey
init|=
name|def_dkey
decl_stmt|;
specifier|const
name|char
modifier|*
name|engine_id
init|=
name|def_engine_id
decl_stmt|;
name|int
name|server_mode
init|=
name|def_server_mode
decl_stmt|;
name|int
name|flipped
init|=
name|def_flipped
decl_stmt|;
specifier|const
name|char
modifier|*
name|cipher_list
init|=
name|def_cipher_list
decl_stmt|;
specifier|const
name|char
modifier|*
name|dh_file
init|=
name|def_dh_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|dh_special
init|=
name|def_dh_special
decl_stmt|;
name|int
name|ctx_options
init|=
name|def_ctx_options
decl_stmt|;
name|int
name|verify_mode
init|=
name|def_verify_mode
decl_stmt|;
name|unsigned
name|int
name|verify_depth
init|=
name|def_verify_depth
decl_stmt|;
name|int
name|out_state
init|=
name|def_out_state
decl_stmt|;
name|unsigned
name|int
name|out_verify
init|=
name|def_out_verify
decl_stmt|;
name|int
name|out_totals
init|=
name|def_out_totals
decl_stmt|;
name|int
name|out_conns
init|=
name|def_out_conns
decl_stmt|;
comment|/* Parse command-line arguments */
name|next_arg
label|:
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-listen"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-listen requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|listenhost
operator|=
operator|*
name|argv
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-proxy"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-proxy requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|proxyhost
operator|=
operator|*
name|argv
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-maxtunnels"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-maxtunnels requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|parse_max_tunnels
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|max_tunnels
argument_list|)
condition|)
return|return
literal|1
return|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-cacert"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-cacert requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"NULL"
argument_list|)
operator|==
literal|0
condition|)
name|cacert
operator|=
name|NULL
expr_stmt|;
else|else
name|cacert
operator|=
operator|*
name|argv
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-cert"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-cert requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"NULL"
argument_list|)
operator|==
literal|0
condition|)
name|cert
operator|=
name|NULL
expr_stmt|;
else|else
name|cert
operator|=
operator|*
name|argv
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-key"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-key requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"NULL"
argument_list|)
operator|==
literal|0
condition|)
name|key
operator|=
name|NULL
expr_stmt|;
else|else
name|key
operator|=
operator|*
name|argv
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-dcert"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-dcert requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"NULL"
argument_list|)
operator|==
literal|0
condition|)
name|dcert
operator|=
name|NULL
expr_stmt|;
else|else
name|dcert
operator|=
operator|*
name|argv
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-dkey"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-dkey requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"NULL"
argument_list|)
operator|==
literal|0
condition|)
name|dkey
operator|=
name|NULL
expr_stmt|;
else|else
name|dkey
operator|=
operator|*
name|argv
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-engine"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-engine requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|engine_id
operator|=
operator|*
name|argv
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-server"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-server requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|parse_server_mode
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|server_mode
argument_list|)
condition|)
return|return
literal|1
return|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-flipped"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-flipped requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|parse_server_mode
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|flipped
argument_list|)
condition|)
return|return
literal|1
return|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-cipher"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-cipher requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|cipher_list
operator|=
operator|*
name|argv
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-dh_file"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-dh_file requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|dh_special
condition|)
return|return
name|usage
argument_list|(
literal|"cannot mix -dh_file with "
literal|"-dh_special"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|dh_file
operator|=
operator|*
name|argv
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-dh_special"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-dh_special requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|dh_file
condition|)
return|return
name|usage
argument_list|(
literal|"cannot mix -dh_file with "
literal|"-dh_special"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|parse_dh_special
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|dh_special
argument_list|)
condition|)
return|return
literal|1
return|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-no_ssl2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctx_options
operator||=
name|SSL_OP_NO_SSLv2
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-no_ssl3"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctx_options
operator||=
name|SSL_OP_NO_SSLv3
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-no_tls1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctx_options
operator||=
name|SSL_OP_NO_TLSv1
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-v_peer"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify_mode
operator||=
name|SSL_VERIFY_PEER
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-v_strict"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify_mode
operator||=
name|SSL_VERIFY_FAIL_IF_NO_PEER_CERT
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-v_once"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify_mode
operator||=
name|SSL_VERIFY_CLIENT_ONCE
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-v_depth"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-v_depth requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|parse_verify_depth
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|verify_depth
argument_list|)
condition|)
return|return
literal|1
return|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-out_state"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|out_state
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-out_verify"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|usage
argument_list|(
literal|"-out_verify requires an argument"
argument_list|,
literal|0
argument_list|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|parse_verify_level
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|out_verify
argument_list|)
condition|)
return|return
literal|1
return|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-out_totals"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|out_totals
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-out_conns"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|out_conns
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_arg
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-h"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-help"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-?"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|helpstring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|usage
argument_list|(
operator|*
name|argv
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/* Run any sanity checks we want here */
if|if
condition|(
operator|!
name|cert
operator|&&
operator|!
name|dcert
operator|&&
name|server_mode
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: you are running an SSL server without "
literal|"a certificate - this may not work!\n"
argument_list|)
expr_stmt|;
comment|/* Initialise network stuff */
if|if
condition|(
operator|!
name|ip_initialise
argument_list|()
condition|)
return|return
name|err_str0
argument_list|(
literal|"ip_initialise failed"
argument_list|)
return|;
comment|/* Create the SSL_CTX */
if|if
condition|(
operator|(
name|world
operator|.
name|ssl_ctx
operator|=
name|initialise_ssl_ctx
argument_list|(
name|server_mode
argument_list|,
name|engine_id
argument_list|,
name|cacert
argument_list|,
name|cert
argument_list|,
name|key
argument_list|,
name|dcert
argument_list|,
name|dkey
argument_list|,
name|cipher_list
argument_list|,
name|dh_file
argument_list|,
name|dh_special
argument_list|,
name|ctx_options
argument_list|,
name|out_state
argument_list|,
name|out_verify
argument_list|,
name|verify_mode
argument_list|,
name|verify_depth
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|err_str1
argument_list|(
literal|"initialise_ssl_ctx(engine_id=%s) failed"
argument_list|,
operator|(
name|engine_id
operator|==
name|NULL
operator|)
condition|?
literal|"NULL"
else|:
name|engine_id
argument_list|)
return|;
if|if
condition|(
name|engine_id
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, engine '%s' initialised\n"
argument_list|,
name|engine_id
argument_list|)
expr_stmt|;
comment|/* Create the listener */
if|if
condition|(
operator|(
name|world
operator|.
name|listen_fd
operator|=
name|ip_create_listener
argument_list|(
name|listenhost
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
name|err_str1
argument_list|(
literal|"ip_create_listener(%s) failed"
argument_list|,
name|listenhost
argument_list|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, listening on '%s'\n"
argument_list|,
name|listenhost
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip_parse_address
argument_list|(
name|proxyhost
argument_list|,
operator|&
name|proxy_ip
argument_list|,
operator|&
name|proxy_port
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|err_str1
argument_list|(
literal|"ip_parse_address(%s) failed"
argument_list|,
name|proxyhost
argument_list|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, proxying to '%s' (%d.%d.%d.%d:%d)\n"
argument_list|,
name|proxyhost
argument_list|,
operator|(
name|int
operator|)
name|proxy_ip
index|[
literal|0
index|]
argument_list|,
operator|(
name|int
operator|)
name|proxy_ip
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|)
name|proxy_ip
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|proxy_ip
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|)
name|proxy_port
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, set maxtunnels to %d\n"
argument_list|,
operator|(
name|int
operator|)
name|max_tunnels
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, set to operate as an SSL %s\n"
argument_list|,
operator|(
name|server_mode
condition|?
literal|"server"
else|:
literal|"client"
operator|)
argument_list|)
expr_stmt|;
comment|/* Initialise the rest of the stuff */
name|world
operator|.
name|tunnels_used
operator|=
name|world
operator|.
name|tunnels_size
operator|=
literal|0
expr_stmt|;
name|world
operator|.
name|tunnels
operator|=
name|NULL
expr_stmt|;
name|world
operator|.
name|server_mode
operator|=
name|server_mode
expr_stmt|;
name|selector_init
argument_list|(
operator|&
name|world
operator|.
name|selector
argument_list|)
expr_stmt|;
comment|/* We're ready to loop */
name|main_loop
label|:
comment|/* Should we listen for *new* tunnels? */
if|if
condition|(
name|world
operator|.
name|tunnels_used
operator|<
name|max_tunnels
condition|)
name|selector_add_listener
argument_list|(
operator|&
name|world
operator|.
name|selector
argument_list|,
name|world
operator|.
name|listen_fd
argument_list|)
expr_stmt|;
comment|/* We should add in our existing tunnels */
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|world
operator|.
name|tunnels_used
condition|;
name|loop
operator|++
control|)
name|selector_add_tunala
argument_list|(
operator|&
name|world
operator|.
name|selector
argument_list|,
name|world
operator|.
name|tunnels
operator|+
name|loop
argument_list|)
expr_stmt|;
comment|/* Now do the select */
switch|switch
condition|(
name|selector_select
argument_list|(
operator|&
name|world
operator|.
name|selector
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"selector_select returned a badness error.\n"
argument_list|)
expr_stmt|;
goto|goto
name|shouldnt_happen
goto|;
case|case
literal|0
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warn, selector_select returned 0 - signal?"
literal|"?\n"
argument_list|)
expr_stmt|;
goto|goto
name|main_loop
goto|;
default|default:
break|break;
block|}
comment|/* Accept new connection if we should and can */
if|if
condition|(
operator|(
name|world
operator|.
name|tunnels_used
operator|<
name|max_tunnels
operator|)
operator|&&
operator|(
name|selector_get_listener
argument_list|(
operator|&
name|world
operator|.
name|selector
argument_list|,
name|world
operator|.
name|listen_fd
argument_list|,
operator|&
name|newfd
argument_list|)
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* We have a new connection */
if|if
condition|(
operator|!
name|tunala_world_new_item
argument_list|(
operator|&
name|world
argument_list|,
name|newfd
argument_list|,
name|proxy_ip
argument_list|,
name|proxy_port
argument_list|,
name|flipped
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tunala_world_new_item failed\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|out_conns
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, new tunnel opened, now up to "
literal|"%d\n"
argument_list|,
name|world
operator|.
name|tunnels_used
argument_list|)
expr_stmt|;
block|}
comment|/* Give each tunnel its moment, note the while loop is because it makes 	 * the logic easier than with "for" to deal with an array that may shift 	 * because of deletes. */
name|loop
operator|=
literal|0
expr_stmt|;
name|t_item
operator|=
name|world
operator|.
name|tunnels
expr_stmt|;
while|while
condition|(
name|loop
operator|<
name|world
operator|.
name|tunnels_used
condition|)
block|{
if|if
condition|(
operator|!
name|tunala_item_io
argument_list|(
operator|&
name|world
operator|.
name|selector
argument_list|,
name|t_item
argument_list|)
condition|)
block|{
comment|/* We're closing whether for reasons of an error or a 			 * natural close. Don't increment loop or t_item because 			 * the next item is moving to us! */
if|if
condition|(
operator|!
name|out_totals
condition|)
goto|goto
name|skip_totals
goto|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tunnel closing, traffic stats follow\n"
argument_list|)
expr_stmt|;
comment|/* Display the encrypted (over the network) stats */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|io_stats_dirty
argument_list|,
name|buffer_total_in
argument_list|(
name|state_machine_get_buffer
argument_list|(
operator|&
name|t_item
operator|->
name|sm
argument_list|,
name|SM_DIRTY_IN
argument_list|)
argument_list|)
argument_list|,
name|buffer_total_out
argument_list|(
name|state_machine_get_buffer
argument_list|(
operator|&
name|t_item
operator|->
name|sm
argument_list|,
name|SM_DIRTY_OUT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Display the local (tunnelled) stats. NB: Data we 			 * *receive* is data sent *out* of the state_machine on 			 * its 'clean' side. Hence the apparent back-to-front 			 * OUT/IN mixup here :-) */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|io_stats_clean
argument_list|,
name|buffer_total_out
argument_list|(
name|state_machine_get_buffer
argument_list|(
operator|&
name|t_item
operator|->
name|sm
argument_list|,
name|SM_CLEAN_OUT
argument_list|)
argument_list|)
argument_list|,
name|buffer_total_in
argument_list|(
name|state_machine_get_buffer
argument_list|(
operator|&
name|t_item
operator|->
name|sm
argument_list|,
name|SM_CLEAN_IN
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|skip_totals
label|:
name|tunala_world_del_item
argument_list|(
operator|&
name|world
argument_list|,
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_conns
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, tunnel closed, down to %d\n"
argument_list|,
name|world
operator|.
name|tunnels_used
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Move to the next item */
name|loop
operator|++
expr_stmt|;
name|t_item
operator|++
expr_stmt|;
block|}
block|}
goto|goto
name|main_loop
goto|;
comment|/* Should never get here */
name|shouldnt_happen
label|:
name|abort
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/****************/
end_comment

begin_comment
comment|/* OpenSSL bits */
end_comment

begin_comment
comment|/****************/
end_comment

begin_function
specifier|static
name|int
name|ctx_set_cert
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|cert
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|X509
modifier|*
name|x509
init|=
name|NULL
decl_stmt|;
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
name|int
name|toret
init|=
literal|0
decl_stmt|;
comment|/* Assume an error */
comment|/* cert */
if|if
condition|(
name|cert
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|cert
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error opening cert file '%s'\n"
argument_list|,
name|cert
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|PEM_read_X509
argument_list|(
name|fp
argument_list|,
operator|&
name|x509
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error reading PEM cert from '%s'\n"
argument_list|,
name|cert
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|SSL_CTX_use_certificate
argument_list|(
name|ctx
argument_list|,
name|x509
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error, cert in '%s' can not be used\n"
argument_list|,
name|cert
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Clear the FILE* for reuse in the "key" code */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, operating with cert in '%s'\n"
argument_list|,
name|cert
argument_list|)
expr_stmt|;
comment|/* If a cert was given without matching key, we assume the same 		 * file contains the required key. */
if|if
condition|(
operator|!
name|key
condition|)
name|key
operator|=
name|cert
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|key
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error, can't specify a key without a "
literal|"corresponding certificate\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error, ctx_set_cert called with "
literal|"NULLs!\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* key */
if|if
condition|(
name|key
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|key
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error opening key file '%s'\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|PEM_read_PrivateKey
argument_list|(
name|fp
argument_list|,
operator|&
name|pkey
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error reading PEM key from '%s'\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|SSL_CTX_use_PrivateKey
argument_list|(
name|ctx
argument_list|,
name|pkey
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error, key in '%s' can not be used\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, operating with key in '%s'\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, operating without a cert or key\n"
argument_list|)
expr_stmt|;
comment|/* Success */
name|toret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|x509
condition|)
name|X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey
condition|)
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|toret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctx_set_dh
parameter_list|(
name|SSL_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|dh_file
parameter_list|,
specifier|const
name|char
modifier|*
name|dh_special
parameter_list|)
block|{
name|DH
modifier|*
name|dh
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dh_special
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dh_special
argument_list|,
literal|"NULL"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|dh_special
argument_list|,
literal|"standard"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dh
operator|=
name|get_dh512
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error, can't parse 'standard'"
literal|" DH parameters\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, using 'standard' DH parameters\n"
argument_list|)
expr_stmt|;
goto|goto
name|do_it
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|dh_special
argument_list|,
literal|"generate"
argument_list|)
operator|!=
literal|0
condition|)
comment|/* This shouldn't happen - screening values is handled 			 * in main(). */
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, generating DH parameters ... "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dh
operator|=
name|DH_generate_parameters
argument_list|(
literal|512
argument_list|,
name|DH_GENERATOR_5
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error!\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"complete\n"
argument_list|)
expr_stmt|;
goto|goto
name|do_it
goto|;
block|}
comment|/* So, we're loading dh_file */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|dh_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error, couldn't open '%s' for DH parameters\n"
argument_list|,
name|dh_file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dh
operator|=
name|PEM_read_DHparams
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error, could not parse DH parameters from '%s'\n"
argument_list|,
name|dh_file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, using DH parameters from file '%s'\n"
argument_list|,
name|dh_file
argument_list|)
expr_stmt|;
name|do_it
label|:
name|SSL_CTX_set_tmp_dh
argument_list|(
name|ctx
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|DH_free
argument_list|(
name|dh
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|SSL_CTX
modifier|*
name|initialise_ssl_ctx
parameter_list|(
name|int
name|server_mode
parameter_list|,
specifier|const
name|char
modifier|*
name|engine_id
parameter_list|,
specifier|const
name|char
modifier|*
name|CAfile
parameter_list|,
specifier|const
name|char
modifier|*
name|cert
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|dcert
parameter_list|,
specifier|const
name|char
modifier|*
name|dkey
parameter_list|,
specifier|const
name|char
modifier|*
name|cipher_list
parameter_list|,
specifier|const
name|char
modifier|*
name|dh_file
parameter_list|,
specifier|const
name|char
modifier|*
name|dh_special
parameter_list|,
name|int
name|ctx_options
parameter_list|,
name|int
name|out_state
parameter_list|,
name|int
name|out_verify
parameter_list|,
name|int
name|verify_mode
parameter_list|,
name|unsigned
name|int
name|verify_depth
parameter_list|)
block|{
name|SSL_CTX
modifier|*
name|ctx
init|=
name|NULL
decl_stmt|,
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|SSL_METHOD
modifier|*
name|meth
decl_stmt|;
name|ENGINE
modifier|*
name|e
init|=
name|NULL
decl_stmt|;
name|OpenSSL_add_ssl_algorithms
argument_list|()
expr_stmt|;
name|SSL_load_error_strings
argument_list|()
expr_stmt|;
name|meth
operator|=
operator|(
name|server_mode
condition|?
name|SSLv23_server_method
argument_list|()
else|:
name|SSLv23_client_method
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|meth
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|engine_id
condition|)
block|{
name|ENGINE_load_builtin_engines
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|ENGINE_by_id
argument_list|(
name|engine_id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error obtaining '%s' engine, openssl "
literal|"errors follow\n"
argument_list|,
name|engine_id
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|ENGINE_set_default
argument_list|(
name|e
argument_list|,
name|ENGINE_METHOD_ALL
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error assigning '%s' engine, openssl "
literal|"errors follow\n"
argument_list|,
name|engine_id
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ENGINE_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ctx
operator|=
name|SSL_CTX_new
argument_list|(
name|meth
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* cacert */
if|if
condition|(
name|CAfile
condition|)
block|{
if|if
condition|(
operator|!
name|X509_STORE_load_locations
argument_list|(
name|SSL_CTX_get_cert_store
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|CAfile
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error loading CA cert(s) in '%s'\n"
argument_list|,
name|CAfile
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, operating with CA cert(s) in '%s'\n"
argument_list|,
name|CAfile
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, operating without a CA cert(-list)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_CTX_set_default_verify_paths
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error setting default verify paths\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* cert and key */
if|if
condition|(
operator|(
name|cert
operator|||
name|key
operator|)
operator|&&
operator|!
name|ctx_set_cert
argument_list|(
name|ctx
argument_list|,
name|cert
argument_list|,
name|key
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* dcert and dkey */
if|if
condition|(
operator|(
name|dcert
operator|||
name|dkey
operator|)
operator|&&
operator|!
name|ctx_set_cert
argument_list|(
name|ctx
argument_list|,
name|dcert
argument_list|,
name|dkey
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* cipher_list */
if|if
condition|(
name|cipher_list
condition|)
block|{
if|if
condition|(
operator|!
name|SSL_CTX_set_cipher_list
argument_list|(
name|ctx
argument_list|,
name|cipher_list
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error setting cipher list '%s'\n"
argument_list|,
name|cipher_list
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, set cipher list '%s'\n"
argument_list|,
name|cipher_list
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Info, operating with default cipher list\n"
argument_list|)
expr_stmt|;
comment|/* dh_file& dh_special */
if|if
condition|(
operator|(
name|dh_file
operator|||
name|dh_special
operator|)
operator|&&
operator|!
name|ctx_set_dh
argument_list|(
name|ctx
argument_list|,
name|dh_file
argument_list|,
name|dh_special
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* ctx_options */
name|SSL_CTX_set_options
argument_list|(
name|ctx
argument_list|,
name|ctx_options
argument_list|)
expr_stmt|;
comment|/* out_state (output of SSL handshake states to screen). */
if|if
condition|(
name|out_state
condition|)
name|cb_ssl_info_set_output
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* out_verify */
if|if
condition|(
name|out_verify
operator|>
literal|0
condition|)
block|{
name|cb_ssl_verify_set_output
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|cb_ssl_verify_set_level
argument_list|(
name|out_verify
argument_list|)
expr_stmt|;
block|}
comment|/* verify_depth */
name|cb_ssl_verify_set_depth
argument_list|(
name|verify_depth
argument_list|)
expr_stmt|;
comment|/* Success! (includes setting verify_mode) */
name|SSL_CTX_set_info_callback
argument_list|(
name|ctx
argument_list|,
name|cb_ssl_info
argument_list|)
expr_stmt|;
name|SSL_CTX_set_verify
argument_list|(
name|ctx
argument_list|,
name|verify_mode
argument_list|,
name|cb_ssl_verify
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ctx
expr_stmt|;
name|err
label|:
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ERR_print_errors_fp
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
condition|)
name|SSL_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*****************/
end_comment

begin_comment
comment|/* Selector bits */
end_comment

begin_comment
comment|/*****************/
end_comment

begin_function
specifier|static
name|void
name|selector_sets_init
parameter_list|(
name|select_sets_t
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|max
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|s
operator|->
name|reads
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|s
operator|->
name|sends
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|s
operator|->
name|excepts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|selector_init
parameter_list|(
name|tunala_selector_t
modifier|*
name|selector
parameter_list|)
block|{
name|selector_sets_init
argument_list|(
operator|&
name|selector
operator|->
name|last_selected
argument_list|)
expr_stmt|;
name|selector_sets_init
argument_list|(
operator|&
name|selector
operator|->
name|next_select
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SEL_EXCEPTS
value|0x00
end_define

begin_define
define|#
directive|define
name|SEL_READS
value|0x01
end_define

begin_define
define|#
directive|define
name|SEL_SENDS
value|0x02
end_define

begin_function
specifier|static
name|void
name|selector_add_raw_fd
parameter_list|(
name|tunala_selector_t
modifier|*
name|s
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|s
operator|->
name|next_select
operator|.
name|excepts
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEL_READS
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|s
operator|->
name|next_select
operator|.
name|reads
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEL_SENDS
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|s
operator|->
name|next_select
operator|.
name|sends
argument_list|)
expr_stmt|;
comment|/* Adjust "max" */
if|if
condition|(
name|s
operator|->
name|next_select
operator|.
name|max
operator|<
operator|(
name|fd
operator|+
literal|1
operator|)
condition|)
name|s
operator|->
name|next_select
operator|.
name|max
operator|=
name|fd
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|selector_add_listener
parameter_list|(
name|tunala_selector_t
modifier|*
name|selector
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|selector_add_raw_fd
argument_list|(
name|selector
argument_list|,
name|fd
argument_list|,
name|SEL_READS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|selector_add_tunala
parameter_list|(
name|tunala_selector_t
modifier|*
name|s
parameter_list|,
name|tunala_item_t
modifier|*
name|t
parameter_list|)
block|{
comment|/* Set clean read if sm.clean_in is not full */
if|if
condition|(
name|t
operator|->
name|clean_read
operator|!=
operator|-
literal|1
condition|)
block|{
name|selector_add_raw_fd
argument_list|(
name|s
argument_list|,
name|t
operator|->
name|clean_read
argument_list|,
operator|(
name|buffer_full
argument_list|(
name|state_machine_get_buffer
argument_list|(
operator|&
name|t
operator|->
name|sm
argument_list|,
name|SM_CLEAN_IN
argument_list|)
argument_list|)
condition|?
name|SEL_EXCEPTS
else|:
name|SEL_READS
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set clean send if sm.clean_out is not empty */
if|if
condition|(
name|t
operator|->
name|clean_send
operator|!=
operator|-
literal|1
condition|)
block|{
name|selector_add_raw_fd
argument_list|(
name|s
argument_list|,
name|t
operator|->
name|clean_send
argument_list|,
operator|(
name|buffer_empty
argument_list|(
name|state_machine_get_buffer
argument_list|(
operator|&
name|t
operator|->
name|sm
argument_list|,
name|SM_CLEAN_OUT
argument_list|)
argument_list|)
condition|?
name|SEL_EXCEPTS
else|:
name|SEL_SENDS
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set dirty read if sm.dirty_in is not full */
if|if
condition|(
name|t
operator|->
name|dirty_read
operator|!=
operator|-
literal|1
condition|)
block|{
name|selector_add_raw_fd
argument_list|(
name|s
argument_list|,
name|t
operator|->
name|dirty_read
argument_list|,
operator|(
name|buffer_full
argument_list|(
name|state_machine_get_buffer
argument_list|(
operator|&
name|t
operator|->
name|sm
argument_list|,
name|SM_DIRTY_IN
argument_list|)
argument_list|)
condition|?
name|SEL_EXCEPTS
else|:
name|SEL_READS
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set dirty send if sm.dirty_out is not empty */
if|if
condition|(
name|t
operator|->
name|dirty_send
operator|!=
operator|-
literal|1
condition|)
block|{
name|selector_add_raw_fd
argument_list|(
name|s
argument_list|,
name|t
operator|->
name|dirty_send
argument_list|,
operator|(
name|buffer_empty
argument_list|(
name|state_machine_get_buffer
argument_list|(
operator|&
name|t
operator|->
name|sm
argument_list|,
name|SM_DIRTY_OUT
argument_list|)
argument_list|)
condition|?
name|SEL_EXCEPTS
else|:
name|SEL_SENDS
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|selector_select
parameter_list|(
name|tunala_selector_t
modifier|*
name|selector
parameter_list|)
block|{
name|memcpy
argument_list|(
operator|&
name|selector
operator|->
name|last_selected
argument_list|,
operator|&
name|selector
operator|->
name|next_select
argument_list|,
sizeof|sizeof
argument_list|(
name|select_sets_t
argument_list|)
argument_list|)
expr_stmt|;
name|selector_sets_init
argument_list|(
operator|&
name|selector
operator|->
name|next_select
argument_list|)
expr_stmt|;
return|return
name|select
argument_list|(
name|selector
operator|->
name|last_selected
operator|.
name|max
argument_list|,
operator|&
name|selector
operator|->
name|last_selected
operator|.
name|reads
argument_list|,
operator|&
name|selector
operator|->
name|last_selected
operator|.
name|sends
argument_list|,
operator|&
name|selector
operator|->
name|last_selected
operator|.
name|excepts
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This returns -1 for error, 0 for no new connections, or 1 for success, in  * which case *newfd is populated. */
end_comment

begin_function
specifier|static
name|int
name|selector_get_listener
parameter_list|(
name|tunala_selector_t
modifier|*
name|selector
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
modifier|*
name|newfd
parameter_list|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|selector
operator|->
name|last_selected
operator|.
name|excepts
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|selector
operator|->
name|last_selected
operator|.
name|reads
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
operator|*
name|newfd
operator|=
name|ip_accept_connection
argument_list|(
name|fd
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/************************/
end_comment

begin_comment
comment|/* "Tunala" world stuff */
end_comment

begin_comment
comment|/************************/
end_comment

begin_function
specifier|static
name|int
name|tunala_world_make_room
parameter_list|(
name|tunala_world_t
modifier|*
name|world
parameter_list|)
block|{
name|unsigned
name|int
name|newsize
decl_stmt|;
name|tunala_item_t
modifier|*
name|newarray
decl_stmt|;
if|if
condition|(
name|world
operator|->
name|tunnels_used
operator|<
name|world
operator|->
name|tunnels_size
condition|)
return|return
literal|1
return|;
name|newsize
operator|=
operator|(
name|world
operator|->
name|tunnels_size
operator|==
literal|0
condition|?
literal|16
else|:
operator|(
operator|(
name|world
operator|->
name|tunnels_size
operator|*
literal|3
operator|)
operator|/
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|newarray
operator|=
name|malloc
argument_list|(
name|newsize
operator|*
sizeof|sizeof
argument_list|(
name|tunala_item_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
name|newarray
argument_list|,
literal|0
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
name|tunala_item_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|world
operator|->
name|tunnels_used
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|newarray
argument_list|,
name|world
operator|->
name|tunnels
argument_list|,
name|world
operator|->
name|tunnels_used
operator|*
sizeof|sizeof
argument_list|(
name|tunala_item_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|world
operator|->
name|tunnels_size
operator|>
literal|0
condition|)
name|free
argument_list|(
name|world
operator|->
name|tunnels
argument_list|)
expr_stmt|;
comment|/* migrate */
name|world
operator|->
name|tunnels
operator|=
name|newarray
expr_stmt|;
name|world
operator|->
name|tunnels_size
operator|=
name|newsize
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tunala_world_new_item
parameter_list|(
name|tunala_world_t
modifier|*
name|world
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|ip
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|,
name|int
name|flipped
parameter_list|)
block|{
name|tunala_item_t
modifier|*
name|item
decl_stmt|;
name|int
name|newfd
decl_stmt|;
name|SSL
modifier|*
name|new_ssl
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|tunala_world_make_room
argument_list|(
name|world
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|new_ssl
operator|=
name|SSL_new
argument_list|(
name|world
operator|->
name|ssl_ctx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error creating new SSL\n"
argument_list|)
expr_stmt|;
name|ERR_print_errors_fp
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|item
operator|=
name|world
operator|->
name|tunnels
operator|+
operator|(
name|world
operator|->
name|tunnels_used
operator|++
operator|)
expr_stmt|;
name|state_machine_init
argument_list|(
operator|&
name|item
operator|->
name|sm
argument_list|)
expr_stmt|;
name|item
operator|->
name|clean_read
operator|=
name|item
operator|->
name|clean_send
operator|=
name|item
operator|->
name|dirty_read
operator|=
name|item
operator|->
name|dirty_send
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|newfd
operator|=
name|ip_create_connection_split
argument_list|(
name|ip
argument_list|,
name|port
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
comment|/* Which way round? If we're a server, "fd" is the dirty side and the 	 * connection we open is the clean one. For a client, it's the other way 	 * around. Unless, of course, we're "flipped" in which case everything 	 * gets reversed. :-) */
if|if
condition|(
operator|(
name|world
operator|->
name|server_mode
operator|&&
operator|!
name|flipped
operator|)
operator|||
operator|(
operator|!
name|world
operator|->
name|server_mode
operator|&&
name|flipped
operator|)
condition|)
block|{
name|item
operator|->
name|dirty_read
operator|=
name|item
operator|->
name|dirty_send
operator|=
name|fd
expr_stmt|;
name|item
operator|->
name|clean_read
operator|=
name|item
operator|->
name|clean_send
operator|=
name|newfd
expr_stmt|;
block|}
else|else
block|{
name|item
operator|->
name|clean_read
operator|=
name|item
operator|->
name|clean_send
operator|=
name|fd
expr_stmt|;
name|item
operator|->
name|dirty_read
operator|=
name|item
operator|->
name|dirty_send
operator|=
name|newfd
expr_stmt|;
block|}
comment|/* We use the SSL's "app_data" to indicate a call-back induced "kill" */
name|SSL_set_app_data
argument_list|(
name|new_ssl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state_machine_set_SSL
argument_list|(
operator|&
name|item
operator|->
name|sm
argument_list|,
name|new_ssl
argument_list|,
name|world
operator|->
name|server_mode
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
literal|1
return|;
name|err
label|:
name|tunala_world_del_item
argument_list|(
name|world
argument_list|,
name|world
operator|->
name|tunnels_used
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tunala_world_del_item
parameter_list|(
name|tunala_world_t
modifier|*
name|world
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
block|{
name|tunala_item_t
modifier|*
name|item
init|=
name|world
operator|->
name|tunnels
operator|+
name|idx
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|clean_read
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|item
operator|->
name|clean_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|clean_send
operator|!=
name|item
operator|->
name|clean_read
condition|)
name|close
argument_list|(
name|item
operator|->
name|clean_send
argument_list|)
expr_stmt|;
name|item
operator|->
name|clean_read
operator|=
name|item
operator|->
name|clean_send
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|dirty_read
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|item
operator|->
name|dirty_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|dirty_send
operator|!=
name|item
operator|->
name|dirty_read
condition|)
name|close
argument_list|(
name|item
operator|->
name|dirty_send
argument_list|)
expr_stmt|;
name|item
operator|->
name|dirty_read
operator|=
name|item
operator|->
name|dirty_send
operator|=
operator|-
literal|1
expr_stmt|;
name|state_machine_close
argument_list|(
operator|&
name|item
operator|->
name|sm
argument_list|)
expr_stmt|;
comment|/* OK, now we fix the item array */
if|if
condition|(
name|idx
operator|+
literal|1
operator|<
name|world
operator|->
name|tunnels_used
condition|)
comment|/* We need to scroll entries to the left */
name|memmove
argument_list|(
name|world
operator|->
name|tunnels
operator|+
name|idx
argument_list|,
name|world
operator|->
name|tunnels
operator|+
operator|(
name|idx
operator|+
literal|1
operator|)
argument_list|,
operator|(
name|world
operator|->
name|tunnels_used
operator|-
operator|(
name|idx
operator|+
literal|1
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tunala_item_t
argument_list|)
argument_list|)
expr_stmt|;
name|world
operator|->
name|tunnels_used
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tunala_item_io
parameter_list|(
name|tunala_selector_t
modifier|*
name|selector
parameter_list|,
name|tunala_item_t
modifier|*
name|item
parameter_list|)
block|{
name|int
name|c_r
decl_stmt|,
name|c_s
decl_stmt|,
name|d_r
decl_stmt|,
name|d_s
decl_stmt|;
comment|/* Four boolean flags */
comment|/* Take ourselves out of the gene-pool if there was an except */
if|if
condition|(
operator|(
name|item
operator|->
name|clean_read
operator|!=
operator|-
literal|1
operator|)
operator|&&
name|FD_ISSET
argument_list|(
name|item
operator|->
name|clean_read
argument_list|,
operator|&
name|selector
operator|->
name|last_selected
operator|.
name|excepts
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|item
operator|->
name|clean_send
operator|!=
operator|-
literal|1
operator|)
operator|&&
name|FD_ISSET
argument_list|(
name|item
operator|->
name|clean_send
argument_list|,
operator|&
name|selector
operator|->
name|last_selected
operator|.
name|excepts
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|item
operator|->
name|dirty_read
operator|!=
operator|-
literal|1
operator|)
operator|&&
name|FD_ISSET
argument_list|(
name|item
operator|->
name|dirty_read
argument_list|,
operator|&
name|selector
operator|->
name|last_selected
operator|.
name|excepts
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|item
operator|->
name|dirty_send
operator|!=
operator|-
literal|1
operator|)
operator|&&
name|FD_ISSET
argument_list|(
name|item
operator|->
name|dirty_send
argument_list|,
operator|&
name|selector
operator|->
name|last_selected
operator|.
name|excepts
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Grab our 4 IO flags */
name|c_r
operator|=
name|c_s
operator|=
name|d_r
operator|=
name|d_s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|clean_read
operator|!=
operator|-
literal|1
condition|)
name|c_r
operator|=
name|FD_ISSET
argument_list|(
name|item
operator|->
name|clean_read
argument_list|,
operator|&
name|selector
operator|->
name|last_selected
operator|.
name|reads
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|clean_send
operator|!=
operator|-
literal|1
condition|)
name|c_s
operator|=
name|FD_ISSET
argument_list|(
name|item
operator|->
name|clean_send
argument_list|,
operator|&
name|selector
operator|->
name|last_selected
operator|.
name|sends
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|dirty_read
operator|!=
operator|-
literal|1
condition|)
name|d_r
operator|=
name|FD_ISSET
argument_list|(
name|item
operator|->
name|dirty_read
argument_list|,
operator|&
name|selector
operator|->
name|last_selected
operator|.
name|reads
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|dirty_send
operator|!=
operator|-
literal|1
condition|)
name|d_s
operator|=
name|FD_ISSET
argument_list|(
name|item
operator|->
name|dirty_send
argument_list|,
operator|&
name|selector
operator|->
name|last_selected
operator|.
name|sends
argument_list|)
expr_stmt|;
comment|/* If no IO has happened for us, skip needless data looping */
if|if
condition|(
operator|!
name|c_r
operator|&&
operator|!
name|c_s
operator|&&
operator|!
name|d_r
operator|&&
operator|!
name|d_s
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c_r
condition|)
name|c_r
operator|=
operator|(
name|buffer_from_fd
argument_list|(
name|state_machine_get_buffer
argument_list|(
operator|&
name|item
operator|->
name|sm
argument_list|,
name|SM_CLEAN_IN
argument_list|)
argument_list|,
name|item
operator|->
name|clean_read
argument_list|)
operator|<=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|c_s
condition|)
name|c_s
operator|=
operator|(
name|buffer_to_fd
argument_list|(
name|state_machine_get_buffer
argument_list|(
operator|&
name|item
operator|->
name|sm
argument_list|,
name|SM_CLEAN_OUT
argument_list|)
argument_list|,
name|item
operator|->
name|clean_send
argument_list|)
operator|<=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|d_r
condition|)
name|d_r
operator|=
operator|(
name|buffer_from_fd
argument_list|(
name|state_machine_get_buffer
argument_list|(
operator|&
name|item
operator|->
name|sm
argument_list|,
name|SM_DIRTY_IN
argument_list|)
argument_list|,
name|item
operator|->
name|dirty_read
argument_list|)
operator|<=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|d_s
condition|)
name|d_s
operator|=
operator|(
name|buffer_to_fd
argument_list|(
name|state_machine_get_buffer
argument_list|(
operator|&
name|item
operator|->
name|sm
argument_list|,
name|SM_DIRTY_OUT
argument_list|)
argument_list|,
name|item
operator|->
name|dirty_send
argument_list|)
operator|<=
literal|0
operator|)
expr_stmt|;
comment|/* If any of the flags is non-zero, that means they need closing */
if|if
condition|(
name|c_r
condition|)
block|{
name|close
argument_list|(
name|item
operator|->
name|clean_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|clean_send
operator|==
name|item
operator|->
name|clean_read
condition|)
name|item
operator|->
name|clean_send
operator|=
operator|-
literal|1
expr_stmt|;
name|item
operator|->
name|clean_read
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c_s
operator|&&
operator|(
name|item
operator|->
name|clean_send
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|close
argument_list|(
name|item
operator|->
name|clean_send
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|clean_send
operator|==
name|item
operator|->
name|clean_read
condition|)
name|item
operator|->
name|clean_read
operator|=
operator|-
literal|1
expr_stmt|;
name|item
operator|->
name|clean_send
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|d_r
condition|)
block|{
name|close
argument_list|(
name|item
operator|->
name|dirty_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|dirty_send
operator|==
name|item
operator|->
name|dirty_read
condition|)
name|item
operator|->
name|dirty_send
operator|=
operator|-
literal|1
expr_stmt|;
name|item
operator|->
name|dirty_read
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|d_s
operator|&&
operator|(
name|item
operator|->
name|dirty_send
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|close
argument_list|(
name|item
operator|->
name|dirty_send
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|dirty_send
operator|==
name|item
operator|->
name|dirty_read
condition|)
name|item
operator|->
name|dirty_read
operator|=
operator|-
literal|1
expr_stmt|;
name|item
operator|->
name|dirty_send
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* This function name is attributed to the term donated by David 	 * Schwartz on openssl-dev, message-ID: 	 *<NCBBLIEPOCNJOAEKBEAKEEDGLIAA.davids@webmaster.com>. :-) */
if|if
condition|(
operator|!
name|state_machine_churn
argument_list|(
operator|&
name|item
operator|->
name|sm
argument_list|)
condition|)
comment|/* If the SSL closes, it will also zero-out the _in buffers 		 * and will in future process just outgoing data. As and 		 * when the outgoing data has gone, it will return zero 		 * here to tell us to bail out. */
return|return
literal|0
return|;
comment|/* Otherwise, we return zero if both sides are dead. */
if|if
condition|(
operator|(
operator|(
name|item
operator|->
name|clean_read
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|item
operator|->
name|clean_send
operator|==
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|item
operator|->
name|dirty_read
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|item
operator|->
name|dirty_send
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If only one side closed, notify the SSL of this so it can take 	 * appropriate action. */
if|if
condition|(
operator|(
name|item
operator|->
name|clean_read
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|item
operator|->
name|clean_send
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|state_machine_close_clean
argument_list|(
operator|&
name|item
operator|->
name|sm
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|item
operator|->
name|dirty_read
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|item
operator|->
name|dirty_send
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|state_machine_close_dirty
argument_list|(
operator|&
name|item
operator|->
name|sm
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

