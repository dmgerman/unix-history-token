begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ====================================================================  * Copyright (c) 2007 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_function_decl
name|void
name|do_print_errors
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|hex2bin
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
name|char
modifier|*
name|hex2bin_m
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|long
modifier|*
name|plen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|do_hex2bn
parameter_list|(
name|BIGNUM
modifier|*
modifier|*
name|pr
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|do_bn_print
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|BIGNUM
modifier|*
name|bn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|do_bn_print_name
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|BIGNUM
modifier|*
name|bn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|parse_line
parameter_list|(
name|char
modifier|*
modifier|*
name|pkw
parameter_list|,
name|char
modifier|*
modifier|*
name|pval
parameter_list|,
name|char
modifier|*
name|linebuf
parameter_list|,
name|char
modifier|*
name|olinebuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|BIGNUM
modifier|*
name|hex2bn
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bin2hex
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pv
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|val
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tidy_line
parameter_list|(
name|char
modifier|*
name|linebuf
parameter_list|,
name|char
modifier|*
name|olinebuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bint2bin
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bin2bint
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|PrintValue
parameter_list|(
name|char
modifier|*
name|tag
parameter_list|,
name|unsigned
name|char
modifier|*
name|val
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|OutputValue
parameter_list|(
name|char
modifier|*
name|tag
parameter_list|,
name|unsigned
name|char
modifier|*
name|val
parameter_list|,
name|int
name|len
parameter_list|,
name|FILE
modifier|*
name|rfp
parameter_list|,
name|int
name|bitmode
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|do_print_errors
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|file
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|int
name|line
decl_stmt|,
name|flags
decl_stmt|;
name|unsigned
name|long
name|l
decl_stmt|;
while|while
condition|(
operator|(
name|l
operator|=
name|ERR_get_error_line_data
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|flags
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR:%lx:lib=%d,func=%d,reason=%d"
literal|":file=%s:line=%d:%s\n"
argument_list|,
name|l
argument_list|,
name|ERR_GET_LIB
argument_list|(
name|l
argument_list|)
argument_list|,
name|ERR_GET_FUNC
argument_list|(
name|l
argument_list|)
argument_list|,
name|ERR_GET_REASON
argument_list|(
name|l
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|flags
operator|&
name|ERR_TXT_STRING
condition|?
name|data
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|hex2bin
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|)
block|{
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
for|for
control|(
name|n1
operator|=
literal|0
operator|,
name|n2
operator|=
literal|0
init|;
name|in
index|[
name|n1
index|]
operator|&&
name|in
index|[
name|n1
index|]
operator|!=
literal|'\n'
condition|;
control|)
block|{
comment|/* first byte */
if|if
condition|(
operator|(
name|in
index|[
name|n1
index|]
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|in
index|[
name|n1
index|]
operator|<=
literal|'9'
operator|)
condition|)
name|ch
operator|=
name|in
index|[
name|n1
operator|++
index|]
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|in
index|[
name|n1
index|]
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|in
index|[
name|n1
index|]
operator|<=
literal|'F'
operator|)
condition|)
name|ch
operator|=
name|in
index|[
name|n1
operator|++
index|]
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|in
index|[
name|n1
index|]
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|in
index|[
name|n1
index|]
operator|<=
literal|'f'
operator|)
condition|)
name|ch
operator|=
name|in
index|[
name|n1
operator|++
index|]
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|in
index|[
name|n1
index|]
condition|)
block|{
name|out
index|[
name|n2
operator|++
index|]
operator|=
name|ch
expr_stmt|;
break|break;
block|}
name|out
index|[
name|n2
index|]
operator|=
name|ch
operator|<<
literal|4
expr_stmt|;
comment|/* second byte */
if|if
condition|(
operator|(
name|in
index|[
name|n1
index|]
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|in
index|[
name|n1
index|]
operator|<=
literal|'9'
operator|)
condition|)
name|ch
operator|=
name|in
index|[
name|n1
operator|++
index|]
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|in
index|[
name|n1
index|]
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|in
index|[
name|n1
index|]
operator|<=
literal|'F'
operator|)
condition|)
name|ch
operator|=
name|in
index|[
name|n1
operator|++
index|]
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|in
index|[
name|n1
index|]
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|in
index|[
name|n1
index|]
operator|<=
literal|'f'
operator|)
condition|)
name|ch
operator|=
name|in
index|[
name|n1
operator|++
index|]
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
name|out
index|[
name|n2
operator|++
index|]
operator||=
name|ch
expr_stmt|;
block|}
return|return
name|n2
return|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
name|hex2bin_m
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|long
modifier|*
name|plen
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|OPENSSL_malloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|in
argument_list|)
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
operator|*
name|plen
operator|=
name|hex2bin
argument_list|(
name|in
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|int
name|do_hex2bn
parameter_list|(
name|BIGNUM
modifier|*
modifier|*
name|pr
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|plen
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|hex2bin_m
argument_list|(
name|in
argument_list|,
operator|&
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|*
name|pr
condition|)
operator|*
name|pr
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pr
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|BN_bin2bn
argument_list|(
name|p
argument_list|,
name|plen
argument_list|,
operator|*
name|pr
argument_list|)
condition|)
name|r
operator|=
literal|1
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|do_bn_print
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|BIGNUM
modifier|*
name|bn
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tmp
decl_stmt|;
name|len
operator|=
name|BN_num_bytes
argument_list|(
name|bn
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"00"
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|tmp
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Memory allocation error\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|BN_bn2bin
argument_list|(
name|bn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%02x"
argument_list|,
name|tmp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|do_bn_print_name
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|BIGNUM
modifier|*
name|bn
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s = "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|r
operator|=
name|do_bn_print
argument_list|(
name|out
argument_list|,
name|bn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
literal|0
return|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|parse_line
parameter_list|(
name|char
modifier|*
modifier|*
name|pkw
parameter_list|,
name|char
modifier|*
modifier|*
name|pval
parameter_list|,
name|char
modifier|*
name|linebuf
parameter_list|,
name|char
modifier|*
name|olinebuf
parameter_list|)
block|{
name|char
modifier|*
name|keyword
decl_stmt|,
modifier|*
name|value
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|strcpy
argument_list|(
name|linebuf
argument_list|,
name|olinebuf
argument_list|)
expr_stmt|;
name|keyword
operator|=
name|linebuf
expr_stmt|;
comment|/* Skip leading space */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|keyword
argument_list|)
condition|)
name|keyword
operator|++
expr_stmt|;
comment|/* Look for = sign */
name|p
operator|=
name|strchr
argument_list|(
name|linebuf
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
comment|/* If no '=' exit */
if|if
condition|(
operator|!
name|p
condition|)
return|return
literal|0
return|;
name|q
operator|=
name|p
operator|-
literal|1
expr_stmt|;
comment|/* Remove trailing space */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|q
argument_list|)
condition|)
operator|*
name|q
operator|--
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Remove leading space from value */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|value
argument_list|)
condition|)
name|value
operator|++
expr_stmt|;
comment|/* Remove trailing space from value */
name|p
operator|=
name|value
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|--
operator|=
literal|0
expr_stmt|;
operator|*
name|pkw
operator|=
name|keyword
expr_stmt|;
operator|*
name|pval
operator|=
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|BIGNUM
modifier|*
name|hex2bn
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|do_hex2bn
argument_list|(
operator|&
name|p
argument_list|,
name|in
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|int
name|bin2hex
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|out
parameter_list|)
block|{
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
for|for
control|(
name|n1
operator|=
literal|0
operator|,
name|n2
operator|=
literal|0
init|;
name|n1
operator|<
name|len
condition|;
operator|++
name|n1
control|)
block|{
name|ch
operator|=
name|in
index|[
name|n1
index|]
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|ch
operator|<=
literal|0x09
condition|)
name|out
index|[
name|n2
operator|++
index|]
operator|=
name|ch
operator|+
literal|'0'
expr_stmt|;
else|else
name|out
index|[
name|n2
operator|++
index|]
operator|=
name|ch
operator|-
literal|10
operator|+
literal|'a'
expr_stmt|;
name|ch
operator|=
name|in
index|[
name|n1
index|]
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|ch
operator|<=
literal|0x09
condition|)
name|out
index|[
name|n2
operator|++
index|]
operator|=
name|ch
operator|+
literal|'0'
expr_stmt|;
else|else
name|out
index|[
name|n2
operator|++
index|]
operator|=
name|ch
operator|-
literal|10
operator|+
literal|'a'
expr_stmt|;
block|}
name|out
index|[
name|n2
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|n2
return|;
block|}
end_function

begin_function
name|void
name|pv
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|val
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
name|obuf
index|[
literal|2048
index|]
decl_stmt|;
name|bin2hex
argument_list|(
name|val
argument_list|,
name|len
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s = %s\n"
argument_list|,
name|tag
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* To avoid extensive changes to test program at this stage just convert  * the input line into an acceptable form. Keyword lines converted to form  * "keyword = value\n" no matter what white space present, all other lines  * just have leading and trailing space removed.  */
end_comment

begin_function
name|int
name|tidy_line
parameter_list|(
name|char
modifier|*
name|linebuf
parameter_list|,
name|char
modifier|*
name|olinebuf
parameter_list|)
block|{
name|char
modifier|*
name|keyword
decl_stmt|,
modifier|*
name|value
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|strcpy
argument_list|(
name|linebuf
argument_list|,
name|olinebuf
argument_list|)
expr_stmt|;
name|keyword
operator|=
name|linebuf
expr_stmt|;
comment|/* Skip leading space */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|keyword
argument_list|)
condition|)
name|keyword
operator|++
expr_stmt|;
comment|/* Look for = sign */
name|p
operator|=
name|strchr
argument_list|(
name|linebuf
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
comment|/* If no '=' just chop leading, trailing ws */
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|p
operator|=
name|keyword
operator|+
name|strlen
argument_list|(
name|keyword
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|--
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|olinebuf
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|olinebuf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|q
operator|=
name|p
operator|-
literal|1
expr_stmt|;
comment|/* Remove trailing space */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|q
argument_list|)
condition|)
operator|*
name|q
operator|--
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Remove leading space from value */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|value
argument_list|)
condition|)
name|value
operator|++
expr_stmt|;
comment|/* Remove trailing space from value */
name|p
operator|=
name|value
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|--
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|olinebuf
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|olinebuf
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|olinebuf
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|olinebuf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* NB: this return the number of _bits_ read */
end_comment

begin_function
name|int
name|bint2bin
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|memset
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|len
condition|;
operator|++
name|n
control|)
if|if
condition|(
name|in
index|[
name|n
index|]
operator|==
literal|'1'
condition|)
name|out
index|[
name|n
operator|/
literal|8
index|]
operator||=
operator|(
literal|0x80
operator|>>
operator|(
name|n
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
name|int
name|bin2bint
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|out
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|len
condition|;
operator|++
name|n
control|)
name|out
index|[
name|n
index|]
operator|=
operator|(
name|in
index|[
name|n
operator|/
literal|8
index|]
operator|&
operator|(
literal|0x80
operator|>>
operator|(
name|n
operator|%
literal|8
operator|)
operator|)
operator|)
condition|?
literal|'1'
else|:
literal|'0'
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------*/
end_comment

begin_function
name|void
name|PrintValue
parameter_list|(
name|char
modifier|*
name|tag
parameter_list|,
name|unsigned
name|char
modifier|*
name|val
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|#
directive|if
name|VERBOSE
name|char
name|obuf
index|[
literal|2048
index|]
decl_stmt|;
name|int
name|olen
decl_stmt|;
name|olen
operator|=
name|bin2hex
argument_list|(
name|val
argument_list|,
name|len
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s = %.*s\n"
argument_list|,
name|tag
argument_list|,
name|olen
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|OutputValue
parameter_list|(
name|char
modifier|*
name|tag
parameter_list|,
name|unsigned
name|char
modifier|*
name|val
parameter_list|,
name|int
name|len
parameter_list|,
name|FILE
modifier|*
name|rfp
parameter_list|,
name|int
name|bitmode
parameter_list|)
block|{
name|char
name|obuf
index|[
literal|2048
index|]
decl_stmt|;
name|int
name|olen
decl_stmt|;
if|if
condition|(
name|bitmode
condition|)
name|olen
operator|=
name|bin2bint
argument_list|(
name|val
argument_list|,
name|len
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
else|else
name|olen
operator|=
name|bin2hex
argument_list|(
name|val
argument_list|,
name|len
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rfp
argument_list|,
literal|"%s = %.*s\n"
argument_list|,
name|tag
argument_list|,
name|olen
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
if|#
directive|if
name|VERBOSE
name|printf
argument_list|(
literal|"%s = %.*s\n"
argument_list|,
name|tag
argument_list|,
name|olen
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

