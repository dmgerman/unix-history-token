begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* apps/s_socket.c -  socket-related functions used by s_client and s_server */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *   * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *   * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from   *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *   * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* With IPv6, it looks like Digital has mixed up the proper order of    recursive header file inclusion, resulting in the compiler complaining    that u_int isn't defined, but only if _POSIX_C_SOURCE is defined, which    is needed to have fileno() declared correctly...  So let's define u_int */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
name|defined
argument_list|(
name|__DECC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__U_INT
argument_list|)
end_if

begin_define
define|#
directive|define
name|__U_INT
end_define

begin_typedef
typedef|typedef
name|unsigned
name|int
name|u_int
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|USE_SOCKETS
end_define

begin_define
define|#
directive|define
name|NON_MAIN
end_define

begin_include
include|#
directive|include
file|"apps.h"
end_include

begin_undef
undef|#
directive|undef
name|USE_SOCKETS
end_undef

begin_undef
undef|#
directive|undef
name|NON_MAIN
end_undef

begin_include
include|#
directive|include
file|"s_apps.h"
end_include

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|GetHostByName
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|WINDOWS
end_ifdef

begin_function_decl
specifier|static
name|void
name|sock_cleanup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|sock_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|init_client_ip
parameter_list|(
name|int
modifier|*
name|sock
parameter_list|,
name|unsigned
name|char
name|ip
index|[
literal|4
index|]
parameter_list|,
name|int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|init_server
parameter_list|(
name|int
modifier|*
name|sock
parameter_list|,
name|int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|init_server_long
parameter_list|(
name|int
modifier|*
name|sock
parameter_list|,
name|int
name|port
parameter_list|,
name|char
modifier|*
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_accept
parameter_list|(
name|int
name|acc_sock
parameter_list|,
name|int
modifier|*
name|sock
parameter_list|,
name|char
modifier|*
modifier|*
name|host
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|host_ip
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|unsigned
name|char
name|ip
index|[
literal|4
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|WIN16
end_ifdef

begin_define
define|#
directive|define
name|SOCKET_PROTOCOL
value|0
end_define

begin_comment
comment|/* more microsoft stupidity */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SOCKET_PROTOCOL
value|IPPROTO_TCP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WINDOWS
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|WSAData
name|wsa_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wsa_init_done
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|WIN16
end_ifdef

begin_decl_stmt
specifier|static
name|HWND
name|topWnd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FARPROC
name|lpTopWndProc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FARPROC
name|lpTopHookProc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|HINSTANCE
name|_hInstance
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nice global CRT provides */
end_comment

begin_function
specifier|static
name|LONG
name|FAR
name|PASCAL
name|topHookProc
parameter_list|(
name|HWND
name|hwnd
parameter_list|,
name|UINT
name|message
parameter_list|,
name|WPARAM
name|wParam
parameter_list|,
name|LPARAM
name|lParam
parameter_list|)
block|{
if|if
condition|(
name|hwnd
operator|==
name|topWnd
condition|)
block|{
switch|switch
condition|(
name|message
condition|)
block|{
case|case
name|WM_DESTROY
case|:
case|case
name|WM_CLOSE
case|:
name|SetWindowLong
argument_list|(
name|topWnd
argument_list|,
name|GWL_WNDPROC
argument_list|,
operator|(
name|LONG
operator|)
name|lpTopWndProc
argument_list|)
expr_stmt|;
name|sock_cleanup
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
name|CallWindowProc
argument_list|(
name|lpTopWndProc
argument_list|,
name|hwnd
argument_list|,
name|message
argument_list|,
name|wParam
argument_list|,
name|lParam
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|BOOL
name|CALLBACK
name|enumproc
parameter_list|(
name|HWND
name|hwnd
parameter_list|,
name|LPARAM
name|lParam
parameter_list|)
block|{
name|topWnd
operator|=
name|hwnd
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WINDOWS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WINDOWS
end_ifdef

begin_function
specifier|static
name|void
name|sock_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|wsa_init_done
condition|)
block|{
name|wsa_init_done
operator|=
literal|0
expr_stmt|;
name|WSACancelBlockingCall
argument_list|()
expr_stmt|;
name|WSACleanup
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|sock_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|WINDOWS
if|if
condition|(
operator|!
name|wsa_init_done
condition|)
block|{
name|int
name|err
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGINT
name|signal
argument_list|(
name|SIGINT
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|sock_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wsa_init_done
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|wsa_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|wsa_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|WSAStartup
argument_list|(
literal|0x0101
argument_list|,
operator|&
name|wsa_state
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"unable to start WINSOCK, error code=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|WIN16
name|EnumTaskWindows
argument_list|(
name|GetCurrentTask
argument_list|()
argument_list|,
name|enumproc
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|lpTopWndProc
operator|=
operator|(
name|FARPROC
operator|)
name|GetWindowLong
argument_list|(
name|topWnd
argument_list|,
name|GWL_WNDPROC
argument_list|)
expr_stmt|;
name|lpTopHookProc
operator|=
name|MakeProcInstance
argument_list|(
operator|(
name|FARPROC
operator|)
name|topHookProc
argument_list|,
name|_hInstance
argument_list|)
expr_stmt|;
name|SetWindowLong
argument_list|(
name|topWnd
argument_list|,
name|GWL_WNDPROC
argument_list|,
operator|(
name|LONG
operator|)
name|lpTopHookProc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WIN16 */
block|}
endif|#
directive|endif
comment|/* WINDOWS */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|init_client
parameter_list|(
name|int
modifier|*
name|sock
parameter_list|,
name|char
modifier|*
name|host
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|unsigned
name|char
name|ip
index|[
literal|4
index|]
decl_stmt|;
name|short
name|p
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|host_ip
argument_list|(
name|host
argument_list|,
operator|&
operator|(
name|ip
index|[
literal|0
index|]
operator|)
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
name|port
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|init_client_ip
argument_list|(
name|sock
argument_list|,
name|ip
argument_list|,
name|port
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_client_ip
parameter_list|(
name|int
modifier|*
name|sock
parameter_list|,
name|unsigned
name|char
name|ip
index|[
literal|4
index|]
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|unsigned
name|long
name|addr
decl_stmt|;
name|struct
name|sockaddr_in
name|them
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|sock_init
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|them
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|them
argument_list|)
argument_list|)
expr_stmt|;
name|them
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|them
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|port
argument_list|)
expr_stmt|;
name|addr
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ip
index|[
literal|0
index|]
operator|<<
literal|24L
argument_list|)
operator||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|ip
index|[
literal|1
index|]
operator|<<
literal|16L
operator|)
operator||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|ip
index|[
literal|2
index|]
operator|<<
literal|8L
operator|)
operator||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|ip
index|[
literal|3
index|]
operator|)
expr_stmt|;
name|them
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
name|SOCKET_PROTOCOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|MPE
name|i
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"keepalive"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|them
argument_list|,
sizeof|sizeof
argument_list|(
name|them
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|sock
operator|=
name|s
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|do_server
parameter_list|(
name|int
name|port
parameter_list|,
name|int
modifier|*
name|ret
parameter_list|,
name|int
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|()
parameter_list|,
name|char
modifier|*
name|context
parameter_list|)
block|{
name|int
name|sock
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|accept_socket
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|init_server
argument_list|(
operator|&
name|accept_socket
argument_list|,
name|port
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ret
operator|=
name|accept_socket
expr_stmt|;
comment|/* return(1);*/
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|do_accept
argument_list|(
name|accept_socket
argument_list|,
operator|&
name|sock
argument_list|,
operator|&
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SHUTDOWN
argument_list|(
name|accept_socket
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|i
operator|=
call|(
modifier|*
name|cb
call|)
argument_list|(
name|name
argument_list|,
name|sock
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SHUTDOWN2
argument_list|(
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|SHUTDOWN2
argument_list|(
name|accept_socket
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|init_server_long
parameter_list|(
name|int
modifier|*
name|sock
parameter_list|,
name|int
name|port
parameter_list|,
name|char
modifier|*
name|ip
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_in
name|server
decl_stmt|;
name|int
name|s
init|=
operator|-
literal|1
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|sock_init
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|server
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|server
argument_list|)
argument_list|)
expr_stmt|;
name|server
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|server
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
name|server
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
else|else
comment|/* Added for T3E, address-of fails on bit field (beckman@acl.lanl.gov) */
ifndef|#
directive|ifndef
name|BIT_FIELD_LIMITS
name|memcpy
argument_list|(
operator|&
name|server
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|ip
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
operator|&
name|server
operator|.
name|sin_addr
argument_list|,
name|ip
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
name|SOCKET_PROTOCOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|INVALID_SOCKET
condition|)
goto|goto
name|err
goto|;
if|#
directive|if
name|defined
name|SOL_SOCKET
operator|&&
name|defined
name|SO_REUSEADDR
block|{
name|int
name|j
init|=
literal|1
decl_stmt|;
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|j
argument_list|,
sizeof|sizeof
name|j
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server
argument_list|,
sizeof|sizeof
argument_list|(
name|server
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|WINDOWS
name|perror
argument_list|(
literal|"bind"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|err
goto|;
block|}
comment|/* Make it 128 for linux */
if|if
condition|(
name|listen
argument_list|(
name|s
argument_list|,
literal|128
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
name|i
operator|=
literal|0
expr_stmt|;
operator|*
name|sock
operator|=
name|s
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|&&
operator|(
name|s
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|SHUTDOWN
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_server
parameter_list|(
name|int
modifier|*
name|sock
parameter_list|,
name|int
name|port
parameter_list|)
block|{
return|return
operator|(
name|init_server_long
argument_list|(
name|sock
argument_list|,
name|port
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_accept
parameter_list|(
name|int
name|acc_sock
parameter_list|,
name|int
modifier|*
name|sock
parameter_list|,
name|char
modifier|*
modifier|*
name|host
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|hostent
modifier|*
name|h1
decl_stmt|,
modifier|*
name|h2
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/*	struct linger ling; */
if|if
condition|(
operator|!
name|sock_init
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifndef|#
directive|ifndef
name|WINDOWS
name|redoit
label|:
endif|#
directive|endif
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|from
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* Note: under VMS with SOCKETSHR the fourth parameter is currently 	 * of type (int *) whereas under other systems it is (void *) if 	 * you don't have a cast it will choke the compiler: if you do 	 * have a cast then you can either go for (int *) or (void *). 	 */
name|ret
operator|=
name|accept
argument_list|(
name|acc_sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|INVALID_SOCKET
condition|)
block|{
ifdef|#
directive|ifdef
name|WINDOWS
name|i
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"accept error %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
comment|/*check_timeout(); */
goto|goto
name|redoit
goto|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"errno=%d "
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"accept"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	ling.l_onoff=1; 	ling.l_linger=0; 	i=setsockopt(ret,SOL_SOCKET,SO_LINGER,(char *)&ling,sizeof(ling)); 	if (i< 0) { perror("linger"); return(0); } 	i=0; 	i=setsockopt(ret,SOL_SOCKET,SO_KEEPALIVE,(char *)&i,sizeof(i)); 	if (i< 0) { perror("keepalive"); return(0); } */
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
ifndef|#
directive|ifndef
name|BIT_FIELD_LIMITS
comment|/* I should use WSAAsyncGetHostByName() under windows */
name|h1
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
else|#
directive|else
name|h1
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|from
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|h1
operator|==
name|NULL
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"bad gethostbyaddr\n"
argument_list|)
expr_stmt|;
operator|*
name|host
operator|=
name|NULL
expr_stmt|;
comment|/* return(0); */
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|host
operator|=
operator|(
name|char
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
name|strlen
argument_list|(
name|h1
operator|->
name|h_name
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"OPENSSL_malloc"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|strcpy
argument_list|(
operator|*
name|host
argument_list|,
name|h1
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|h2
operator|=
name|GetHostByName
argument_list|(
operator|*
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|h2
operator|==
name|NULL
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"gethostbyname failure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h2
operator|->
name|h_addrtype
operator|!=
name|AF_INET
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"gethostbyname addr is not AF_INET\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|end
label|:
operator|*
name|sock
operator|=
name|ret
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|extract_host_port
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
modifier|*
name|host_ptr
parameter_list|,
name|unsigned
name|char
modifier|*
name|ip
parameter_list|,
name|short
modifier|*
name|port_ptr
parameter_list|)
block|{
name|char
modifier|*
name|h
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|h
operator|=
name|str
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"no port defined\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|host_ip
argument_list|(
name|str
argument_list|,
name|ip
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|host_ptr
operator|!=
name|NULL
condition|)
operator|*
name|host_ptr
operator|=
name|h
expr_stmt|;
if|if
condition|(
operator|!
name|extract_port
argument_list|(
name|p
argument_list|,
name|port_ptr
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
operator|(
literal|1
operator|)
return|;
name|err
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|host_ip
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|unsigned
name|char
name|ip
index|[
literal|4
index|]
parameter_list|)
block|{
name|unsigned
name|int
name|in
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%u.%u.%u.%u"
argument_list|,
operator|&
operator|(
name|in
index|[
literal|0
index|]
operator|)
argument_list|,
operator|&
operator|(
name|in
index|[
literal|1
index|]
operator|)
argument_list|,
operator|&
operator|(
name|in
index|[
literal|2
index|]
operator|)
argument_list|,
operator|&
operator|(
name|in
index|[
literal|3
index|]
operator|)
argument_list|)
operator|==
literal|4
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|in
index|[
name|i
index|]
operator|>
literal|255
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"invalid IP address\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ip
index|[
literal|0
index|]
operator|=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|ip
index|[
literal|1
index|]
operator|=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|ip
index|[
literal|2
index|]
operator|=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|ip
index|[
literal|3
index|]
operator|=
name|in
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* do a gethostbyname */
name|struct
name|hostent
modifier|*
name|he
decl_stmt|;
if|if
condition|(
operator|!
name|sock_init
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|he
operator|=
name|GetHostByName
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|he
operator|==
name|NULL
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"gethostbyname failure\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* cast to short because of win16 winsock definition */
if|if
condition|(
operator|(
name|short
operator|)
name|he
operator|->
name|h_addrtype
operator|!=
name|AF_INET
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"gethostbyname addr is not AF_INET\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ip
index|[
literal|0
index|]
operator|=
name|he
operator|->
name|h_addr_list
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|ip
index|[
literal|1
index|]
operator|=
name|he
operator|->
name|h_addr_list
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|ip
index|[
literal|2
index|]
operator|=
name|he
operator|->
name|h_addr_list
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|ip
index|[
literal|3
index|]
operator|=
name|he
operator|->
name|h_addr_list
index|[
literal|0
index|]
index|[
literal|3
index|]
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|err
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|extract_port
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|short
modifier|*
name|port_ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|servent
modifier|*
name|s
decl_stmt|;
name|i
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
operator|*
name|port_ptr
operator|=
operator|(
name|unsigned
name|short
operator|)
name|i
expr_stmt|;
else|else
block|{
name|s
operator|=
name|getservbyname
argument_list|(
name|str
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"getservbyname failure for %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|port_ptr
operator|=
name|ntohs
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|s
operator|->
name|s_port
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|GHBN_NUM
value|4
end_define

begin_struct
specifier|static
struct|struct
name|ghbn_cache_st
block|{
name|char
name|name
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|hostent
name|ent
decl_stmt|;
name|unsigned
name|long
name|order
decl_stmt|;
block|}
name|ghbn_cache
index|[
name|GHBN_NUM
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|ghbn_hits
init|=
literal|0L
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|ghbn_miss
init|=
literal|0L
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|GetHostByName
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lowi
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|low
init|=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GHBN_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|low
operator|>
name|ghbn_cache
index|[
name|i
index|]
operator|.
name|order
condition|)
block|{
name|low
operator|=
name|ghbn_cache
index|[
name|i
index|]
operator|.
name|order
expr_stmt|;
name|lowi
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|ghbn_cache
index|[
name|i
index|]
operator|.
name|order
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|ghbn_cache
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|128
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|GHBN_NUM
condition|)
comment|/* no hit*/
block|{
name|ghbn_miss
operator|++
expr_stmt|;
name|ret
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* else add to cache */
name|strncpy
argument_list|(
name|ghbn_cache
index|[
name|lowi
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|ghbn_cache
index|[
name|lowi
index|]
operator|.
name|ent
operator|)
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hostent
argument_list|)
argument_list|)
expr_stmt|;
name|ghbn_cache
index|[
name|lowi
index|]
operator|.
name|order
operator|=
name|ghbn_miss
operator|+
name|ghbn_hits
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
else|else
block|{
name|ghbn_hits
operator|++
expr_stmt|;
name|ret
operator|=
operator|&
operator|(
name|ghbn_cache
index|[
name|i
index|]
operator|.
name|ent
operator|)
expr_stmt|;
name|ghbn_cache
index|[
name|i
index|]
operator|.
name|order
operator|=
name|ghbn_miss
operator|+
name|ghbn_hits
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
end_function

end_unit

