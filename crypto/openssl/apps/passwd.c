begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* apps/passwd.c */
end_comment

begin_if
if|#
directive|if
name|defined
name|NO_MD5
operator|||
name|defined
name|CHARSET_EBCDIC
end_if

begin_define
define|#
directive|define
name|NO_MD5CRYPT_1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_DES
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|NO_MD5CRYPT_1
argument_list|)
end_if

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"apps.h"
end_include

begin_include
include|#
directive|include
file|<openssl/bio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DES
end_ifndef

begin_include
include|#
directive|include
file|<openssl/des.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MD5CRYPT_1
end_ifndef

begin_include
include|#
directive|include
file|<openssl/md5.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|PROG
end_undef

begin_define
define|#
directive|define
name|PROG
value|passwd_main
end_define

begin_decl_stmt
specifier|static
name|unsigned
specifier|const
name|char
name|cov_2char
index|[
literal|64
index|]
init|=
block|{
comment|/* from crypto/des/fcrypt.c */
literal|0x2E
block|,
literal|0x2F
block|,
literal|0x30
block|,
literal|0x31
block|,
literal|0x32
block|,
literal|0x33
block|,
literal|0x34
block|,
literal|0x35
block|,
literal|0x36
block|,
literal|0x37
block|,
literal|0x38
block|,
literal|0x39
block|,
literal|0x41
block|,
literal|0x42
block|,
literal|0x43
block|,
literal|0x44
block|,
literal|0x45
block|,
literal|0x46
block|,
literal|0x47
block|,
literal|0x48
block|,
literal|0x49
block|,
literal|0x4A
block|,
literal|0x4B
block|,
literal|0x4C
block|,
literal|0x4D
block|,
literal|0x4E
block|,
literal|0x4F
block|,
literal|0x50
block|,
literal|0x51
block|,
literal|0x52
block|,
literal|0x53
block|,
literal|0x54
block|,
literal|0x55
block|,
literal|0x56
block|,
literal|0x57
block|,
literal|0x58
block|,
literal|0x59
block|,
literal|0x5A
block|,
literal|0x61
block|,
literal|0x62
block|,
literal|0x63
block|,
literal|0x64
block|,
literal|0x65
block|,
literal|0x66
block|,
literal|0x67
block|,
literal|0x68
block|,
literal|0x69
block|,
literal|0x6A
block|,
literal|0x6B
block|,
literal|0x6C
block|,
literal|0x6D
block|,
literal|0x6E
block|,
literal|0x6F
block|,
literal|0x70
block|,
literal|0x71
block|,
literal|0x72
block|,
literal|0x73
block|,
literal|0x74
block|,
literal|0x75
block|,
literal|0x76
block|,
literal|0x77
block|,
literal|0x78
block|,
literal|0x79
block|,
literal|0x7A
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|do_passwd
parameter_list|(
name|int
name|passed_salt
parameter_list|,
name|char
modifier|*
modifier|*
name|salt_p
parameter_list|,
name|char
modifier|*
modifier|*
name|salt_malloc_p
parameter_list|,
name|char
modifier|*
name|passwd
parameter_list|,
name|BIO
modifier|*
name|out
parameter_list|,
name|int
name|quiet
parameter_list|,
name|int
name|table
parameter_list|,
name|int
name|reverse
parameter_list|,
name|size_t
name|pw_maxlen
parameter_list|,
name|int
name|usecrypt
parameter_list|,
name|int
name|use1
parameter_list|,
name|int
name|useapr1
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* -crypt        - standard Unix password algorithm (default)  * -1            - MD5-based password algorithm  * -apr1         - MD5-based password algorithm, Apache variant  * -salt string  - salt  * -in file      - read passwords from file  * -stdin        - read passwords from stdin  * -quiet        - no warnings  * -table        - format output as table  * -reverse      - switch table columns  */
end_comment

begin_function_decl
name|int
name|MAIN
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|MAIN
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|infile
init|=
name|NULL
decl_stmt|;
name|int
name|in_stdin
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|salt
init|=
name|NULL
decl_stmt|,
modifier|*
name|passwd
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|passwds
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|salt_malloc
init|=
name|NULL
decl_stmt|,
modifier|*
name|passwd_malloc
init|=
name|NULL
decl_stmt|;
name|size_t
name|passwd_malloc_size
init|=
literal|0
decl_stmt|;
name|int
name|pw_source_defined
init|=
literal|0
decl_stmt|;
name|BIO
modifier|*
name|in
init|=
name|NULL
decl_stmt|,
modifier|*
name|out
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|badopt
decl_stmt|,
name|opt_done
decl_stmt|;
name|int
name|passed_salt
init|=
literal|0
decl_stmt|,
name|quiet
init|=
literal|0
decl_stmt|,
name|table
init|=
literal|0
decl_stmt|,
name|reverse
init|=
literal|0
decl_stmt|;
name|int
name|usecrypt
init|=
literal|0
decl_stmt|,
name|use1
init|=
literal|0
decl_stmt|,
name|useapr1
init|=
literal|0
decl_stmt|;
name|size_t
name|pw_maxlen
init|=
literal|0
decl_stmt|;
name|apps_startup
argument_list|()
expr_stmt|;
if|if
condition|(
name|bio_err
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|bio_err
operator|=
name|BIO_new
argument_list|(
name|BIO_s_file
argument_list|()
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|BIO_set_fp
argument_list|(
name|bio_err
argument_list|,
name|stderr
argument_list|,
name|BIO_NOCLOSE
operator||
name|BIO_FP_TEXT
argument_list|)
expr_stmt|;
name|out
operator|=
name|BIO_new
argument_list|(
name|BIO_s_file
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|BIO_set_fp
argument_list|(
name|out
argument_list|,
name|stdout
argument_list|,
name|BIO_NOCLOSE
operator||
name|BIO_FP_TEXT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
block|{
name|BIO
modifier|*
name|tmpbio
init|=
name|BIO_new
argument_list|(
name|BIO_f_linebuffer
argument_list|()
argument_list|)
decl_stmt|;
name|out
operator|=
name|BIO_push
argument_list|(
name|tmpbio
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|badopt
operator|=
literal|0
operator|,
name|opt_done
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|badopt
operator|&&
operator|!
name|opt_done
operator|&&
name|argv
index|[
operator|++
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-crypt"
argument_list|)
operator|==
literal|0
condition|)
name|usecrypt
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-1"
argument_list|)
operator|==
literal|0
condition|)
name|use1
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-apr1"
argument_list|)
operator|==
literal|0
condition|)
name|useapr1
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-salt"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|salt
operator|==
name|NULL
operator|)
condition|)
block|{
name|passed_salt
operator|=
literal|1
expr_stmt|;
name|salt
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
else|else
name|badopt
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-in"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|pw_source_defined
condition|)
block|{
name|pw_source_defined
operator|=
literal|1
expr_stmt|;
name|infile
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
else|else
name|badopt
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-stdin"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|pw_source_defined
condition|)
block|{
name|pw_source_defined
operator|=
literal|1
expr_stmt|;
name|in_stdin
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|badopt
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-quiet"
argument_list|)
operator|==
literal|0
condition|)
name|quiet
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-table"
argument_list|)
operator|==
literal|0
condition|)
name|table
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-reverse"
argument_list|)
operator|==
literal|0
condition|)
name|reverse
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|badopt
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|pw_source_defined
condition|)
comment|/* non-option arguments, use as passwords */
block|{
name|pw_source_defined
operator|=
literal|1
expr_stmt|;
name|passwds
operator|=
operator|&
name|argv
index|[
name|i
index|]
expr_stmt|;
name|opt_done
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|badopt
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|usecrypt
operator|&&
operator|!
name|use1
operator|&&
operator|!
name|useapr1
condition|)
comment|/* use default */
name|usecrypt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|usecrypt
operator|+
name|use1
operator|+
name|useapr1
operator|>
literal|1
condition|)
comment|/* conflict */
name|badopt
operator|=
literal|1
expr_stmt|;
comment|/* reject unsupported algorithms */
ifdef|#
directive|ifdef
name|NO_DES
if|if
condition|(
name|usecrypt
condition|)
name|badopt
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_MD5CRYPT_1
if|if
condition|(
name|use1
operator|||
name|useapr1
condition|)
name|badopt
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|badopt
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Usage: passwd [options] [passwords]\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"where options are\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_DES
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-crypt             standard Unix password algorithm (default)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_MD5CRYPT_1
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-1                 MD5-based password algorithm\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-apr1              MD5-based password algorithm, Apache variant\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-salt string       use provided salt\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-in file           read passwords from file\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-stdin             read passwords from stdin\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-quiet             no warnings\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-table             format output as table\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-reverse           switch table columns\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|infile
operator|!=
name|NULL
operator|)
operator|||
name|in_stdin
condition|)
block|{
name|in
operator|=
name|BIO_new
argument_list|(
name|BIO_s_file
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|infile
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|in_stdin
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BIO_read_filename
argument_list|(
name|in
argument_list|,
name|infile
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|assert
argument_list|(
name|in_stdin
argument_list|)
expr_stmt|;
name|BIO_set_fp
argument_list|(
name|in
argument_list|,
name|stdin
argument_list|,
name|BIO_NOCLOSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usecrypt
condition|)
name|pw_maxlen
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|use1
operator|||
name|useapr1
condition|)
name|pw_maxlen
operator|=
literal|256
expr_stmt|;
comment|/* arbitrary limit, should be enough for most passwords */
if|if
condition|(
name|passwds
operator|==
name|NULL
condition|)
block|{
comment|/* no passwords on the command line */
name|passwd_malloc_size
operator|=
name|pw_maxlen
operator|+
literal|2
expr_stmt|;
comment|/* longer than necessary so that we can warn about truncation */
name|passwd
operator|=
name|passwd_malloc
operator|=
name|OPENSSL_malloc
argument_list|(
name|passwd_malloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|passwd_malloc
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|in
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|passwds
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* build a null-terminated list */
specifier|static
name|char
modifier|*
name|passwds_static
index|[
literal|2
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|passwds
operator|=
name|passwds_static
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
if|if
condition|(
name|EVP_read_pw_string
argument_list|(
name|passwd_malloc
argument_list|,
name|passwd_malloc_size
argument_list|,
literal|"Password: "
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|passwds
index|[
literal|0
index|]
operator|=
name|passwd_malloc
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|passwds
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|passwds
operator|!=
name|NULL
argument_list|)
expr_stmt|;
do|do
comment|/* loop over list of passwords */
block|{
name|passwd
operator|=
operator|*
name|passwds
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|do_passwd
argument_list|(
name|passed_salt
argument_list|,
operator|&
name|salt
argument_list|,
operator|&
name|salt_malloc
argument_list|,
name|passwd
argument_list|,
name|out
argument_list|,
name|quiet
argument_list|,
name|table
argument_list|,
name|reverse
argument_list|,
name|pw_maxlen
argument_list|,
name|usecrypt
argument_list|,
name|use1
argument_list|,
name|useapr1
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
do|while
condition|(
operator|*
name|passwds
operator|!=
name|NULL
condition|)
do|;
block|}
else|else
comment|/* in != NULL */
block|{
name|int
name|done
decl_stmt|;
name|assert
argument_list|(
name|passwd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|r
init|=
name|BIO_gets
argument_list|(
name|in
argument_list|,
name|passwd
argument_list|,
name|pw_maxlen
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|c
init|=
operator|(
name|strchr
argument_list|(
name|passwd
argument_list|,
literal|'\n'
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
operator|*
name|c
operator|=
literal|0
expr_stmt|;
comment|/* truncate at newline */
else|else
block|{
comment|/* ignore rest of line */
name|char
name|trash
index|[
name|BUFSIZ
index|]
decl_stmt|;
do|do
name|r
operator|=
name|BIO_gets
argument_list|(
name|in
argument_list|,
name|trash
argument_list|,
sizeof|sizeof
name|trash
argument_list|)
expr_stmt|;
do|while
condition|(
operator|(
name|r
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|!
name|strchr
argument_list|(
name|trash
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
do|;
block|}
if|if
condition|(
operator|!
name|do_passwd
argument_list|(
name|passed_salt
argument_list|,
operator|&
name|salt
argument_list|,
operator|&
name|salt_malloc
argument_list|,
name|passwd
argument_list|,
name|out
argument_list|,
name|quiet
argument_list|,
name|table
argument_list|,
name|reverse
argument_list|,
name|pw_maxlen
argument_list|,
name|usecrypt
argument_list|,
name|use1
argument_list|,
name|useapr1
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
name|done
operator|=
operator|(
name|r
operator|<=
literal|0
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|err
label|:
name|ERR_print_errors
argument_list|(
name|bio_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|salt_malloc
condition|)
name|OPENSSL_free
argument_list|(
name|salt_malloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|passwd_malloc
condition|)
name|OPENSSL_free
argument_list|(
name|passwd_malloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
condition|)
name|BIO_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
condition|)
name|BIO_free_all
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|EXIT
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MD5CRYPT_1
end_ifndef

begin_comment
comment|/* MD5-based password algorithm (should probably be available as a library  * function; then the static buffer would not be acceptable).  * For magic string "1", this should be compatible to the MD5-based BSD  * password algorithm.  * For 'magic' string "apr1", this is compatible to the MD5-based Apache  * password algorithm.  * (Apparently, the Apache password algorithm is identical except that the  * 'magic' string was changed -- the laziest application of the NIH principle  * I've ever encountered.)  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|md5crypt
parameter_list|(
specifier|const
name|char
modifier|*
name|passwd
parameter_list|,
specifier|const
name|char
modifier|*
name|magic
parameter_list|,
specifier|const
name|char
modifier|*
name|salt
parameter_list|)
block|{
specifier|static
name|char
name|out_buf
index|[
literal|6
operator|+
literal|9
operator|+
literal|24
operator|+
literal|2
index|]
decl_stmt|;
comment|/* "$apr1$..salt..$.......md5hash..........\0" */
name|unsigned
name|char
name|buf
index|[
name|MD5_DIGEST_LENGTH
index|]
decl_stmt|;
name|char
modifier|*
name|salt_out
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
name|MD5_CTX
name|md
decl_stmt|;
name|size_t
name|passwd_len
decl_stmt|,
name|salt_len
decl_stmt|;
name|passwd_len
operator|=
name|strlen
argument_list|(
name|passwd
argument_list|)
expr_stmt|;
name|out_buf
index|[
literal|0
index|]
operator|=
literal|'$'
expr_stmt|;
name|out_buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|magic
argument_list|)
operator|<=
literal|4
argument_list|)
expr_stmt|;
comment|/* "1" or "apr1" */
name|strncat
argument_list|(
name|out_buf
argument_list|,
name|magic
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|out_buf
argument_list|,
literal|"$"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|out_buf
argument_list|,
name|salt
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|out_buf
argument_list|)
operator|<=
literal|6
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* "$apr1$..salt.." */
name|salt_out
operator|=
name|out_buf
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|magic
argument_list|)
expr_stmt|;
name|salt_len
operator|=
name|strlen
argument_list|(
name|salt_out
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|salt_len
operator|<=
literal|8
argument_list|)
expr_stmt|;
name|MD5_Init
argument_list|(
operator|&
name|md
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|md
argument_list|,
name|passwd
argument_list|,
name|passwd_len
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|md
argument_list|,
literal|"$"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|md
argument_list|,
name|magic
argument_list|,
name|strlen
argument_list|(
name|magic
argument_list|)
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|md
argument_list|,
literal|"$"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|md
argument_list|,
name|salt_out
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
block|{
name|MD5_CTX
name|md2
decl_stmt|;
name|MD5_Init
argument_list|(
operator|&
name|md2
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|md2
argument_list|,
name|passwd
argument_list|,
name|passwd_len
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|md2
argument_list|,
name|salt_out
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|md2
argument_list|,
name|passwd
argument_list|,
name|passwd_len
argument_list|)
expr_stmt|;
name|MD5_Final
argument_list|(
name|buf
argument_list|,
operator|&
name|md2
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|passwd_len
init|;
name|i
operator|>
sizeof|sizeof
name|buf
condition|;
name|i
operator|-=
sizeof|sizeof
name|buf
control|)
name|MD5_Update
argument_list|(
operator|&
name|md
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|md
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|n
operator|=
name|passwd_len
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|MD5_Update
argument_list|(
operator|&
name|md
argument_list|,
operator|(
name|n
operator|&
literal|1
operator|)
condition|?
literal|"\0"
else|:
name|passwd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|>>=
literal|1
expr_stmt|;
block|}
name|MD5_Final
argument_list|(
name|buf
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|MD5_CTX
name|md2
decl_stmt|;
name|MD5_Init
argument_list|(
operator|&
name|md2
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|md2
argument_list|,
operator|(
name|i
operator|&
literal|1
operator|)
condition|?
operator|(
name|unsigned
name|char
operator|*
operator|)
name|passwd
else|:
name|buf
argument_list|,
operator|(
name|i
operator|&
literal|1
operator|)
condition|?
name|passwd_len
else|:
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|3
condition|)
name|MD5_Update
argument_list|(
operator|&
name|md2
argument_list|,
name|salt_out
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|7
condition|)
name|MD5_Update
argument_list|(
operator|&
name|md2
argument_list|,
name|passwd
argument_list|,
name|passwd_len
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|md2
argument_list|,
operator|(
name|i
operator|&
literal|1
operator|)
condition|?
name|buf
else|:
operator|(
name|unsigned
name|char
operator|*
operator|)
name|passwd
argument_list|,
operator|(
name|i
operator|&
literal|1
operator|)
condition|?
sizeof|sizeof
name|buf
else|:
name|passwd_len
argument_list|)
expr_stmt|;
name|MD5_Final
argument_list|(
name|buf
argument_list|,
operator|&
name|md2
argument_list|)
expr_stmt|;
block|}
block|{
comment|/* transform buf into output string */
name|unsigned
name|char
name|buf_perm
index|[
sizeof|sizeof
name|buf
index|]
decl_stmt|;
name|int
name|dest
decl_stmt|,
name|source
decl_stmt|;
name|char
modifier|*
name|output
decl_stmt|;
comment|/* silly output permutation */
for|for
control|(
name|dest
operator|=
literal|0
operator|,
name|source
operator|=
literal|0
init|;
name|dest
operator|<
literal|14
condition|;
name|dest
operator|++
operator|,
name|source
operator|=
operator|(
name|source
operator|+
literal|6
operator|)
operator|%
literal|17
control|)
name|buf_perm
index|[
name|dest
index|]
operator|=
name|buf
index|[
name|source
index|]
expr_stmt|;
name|buf_perm
index|[
literal|14
index|]
operator|=
name|buf
index|[
literal|5
index|]
expr_stmt|;
name|buf_perm
index|[
literal|15
index|]
operator|=
name|buf
index|[
literal|11
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|PEDANTIC
comment|/* Unfortunately, this generates a "no effect" warning */
name|assert
argument_list|(
literal|16
operator|==
sizeof|sizeof
name|buf_perm
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|output
operator|=
name|salt_out
operator|+
name|salt_len
expr_stmt|;
name|assert
argument_list|(
name|output
operator|==
name|out_buf
operator|+
name|strlen
argument_list|(
name|out_buf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
literal|'$'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|+=
literal|3
control|)
block|{
operator|*
name|output
operator|++
operator|=
name|cov_2char
index|[
name|buf_perm
index|[
name|i
operator|+
literal|2
index|]
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|cov_2char
index|[
operator|(
operator|(
name|buf_perm
index|[
name|i
operator|+
literal|1
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
name|buf_perm
index|[
name|i
operator|+
literal|2
index|]
operator|>>
literal|6
operator|)
index|]
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|cov_2char
index|[
operator|(
operator|(
name|buf_perm
index|[
name|i
index|]
operator|&
literal|3
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|buf_perm
index|[
name|i
operator|+
literal|1
index|]
operator|>>
literal|4
operator|)
index|]
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|cov_2char
index|[
name|buf_perm
index|[
name|i
index|]
operator|>>
literal|2
index|]
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|==
literal|15
argument_list|)
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|cov_2char
index|[
name|buf_perm
index|[
name|i
index|]
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|output
operator|++
operator|=
name|cov_2char
index|[
name|buf_perm
index|[
name|i
index|]
operator|>>
literal|6
index|]
expr_stmt|;
operator|*
name|output
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|out_buf
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|out_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|out_buf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|do_passwd
parameter_list|(
name|int
name|passed_salt
parameter_list|,
name|char
modifier|*
modifier|*
name|salt_p
parameter_list|,
name|char
modifier|*
modifier|*
name|salt_malloc_p
parameter_list|,
name|char
modifier|*
name|passwd
parameter_list|,
name|BIO
modifier|*
name|out
parameter_list|,
name|int
name|quiet
parameter_list|,
name|int
name|table
parameter_list|,
name|int
name|reverse
parameter_list|,
name|size_t
name|pw_maxlen
parameter_list|,
name|int
name|usecrypt
parameter_list|,
name|int
name|use1
parameter_list|,
name|int
name|useapr1
parameter_list|)
block|{
name|char
modifier|*
name|hash
init|=
name|NULL
decl_stmt|;
name|assert
argument_list|(
name|salt_p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|salt_malloc_p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* first make sure we have a salt */
if|if
condition|(
operator|!
name|passed_salt
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_DES
if|if
condition|(
name|usecrypt
condition|)
block|{
if|if
condition|(
operator|*
name|salt_malloc_p
operator|==
name|NULL
condition|)
block|{
operator|*
name|salt_p
operator|=
operator|*
name|salt_malloc_p
operator|=
name|OPENSSL_malloc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|salt_malloc_p
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|RAND_pseudo_bytes
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|*
name|salt_p
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
operator|(
operator|*
name|salt_p
operator|)
index|[
literal|0
index|]
operator|=
name|cov_2char
index|[
operator|(
operator|*
name|salt_p
operator|)
index|[
literal|0
index|]
operator|&
literal|0x3f
index|]
expr_stmt|;
comment|/* 6 bits */
operator|(
operator|*
name|salt_p
operator|)
index|[
literal|1
index|]
operator|=
name|cov_2char
index|[
operator|(
operator|*
name|salt_p
operator|)
index|[
literal|1
index|]
operator|&
literal|0x3f
index|]
expr_stmt|;
comment|/* 6 bits */
operator|(
operator|*
name|salt_p
operator|)
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|CHARSET_EBCDIC
name|ascii2ebcdic
argument_list|(
operator|*
name|salt_p
argument_list|,
operator|*
name|salt_p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* des_crypt will convert 			                                    * back to ASCII */
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* !NO_DES */
ifndef|#
directive|ifndef
name|NO_MD5CRYPT_1
if|if
condition|(
name|use1
operator|||
name|useapr1
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|salt_malloc_p
operator|==
name|NULL
condition|)
block|{
operator|*
name|salt_p
operator|=
operator|*
name|salt_malloc_p
operator|=
name|OPENSSL_malloc
argument_list|(
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|salt_malloc_p
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|RAND_pseudo_bytes
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|*
name|salt_p
argument_list|,
literal|8
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|salt_p
operator|)
index|[
name|i
index|]
operator|=
name|cov_2char
index|[
operator|(
operator|*
name|salt_p
operator|)
index|[
name|i
index|]
operator|&
literal|0x3f
index|]
expr_stmt|;
comment|/* 6 bits */
operator|(
operator|*
name|salt_p
operator|)
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !NO_MD5CRYPT_1 */
block|}
name|assert
argument_list|(
operator|*
name|salt_p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* truncate password if necessary */
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|passwd
argument_list|)
operator|>
name|pw_maxlen
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Warning: truncating password to %u characters\n"
argument_list|,
name|pw_maxlen
argument_list|)
expr_stmt|;
name|passwd
index|[
name|pw_maxlen
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|assert
argument_list|(
name|strlen
argument_list|(
name|passwd
argument_list|)
operator|<=
name|pw_maxlen
argument_list|)
expr_stmt|;
comment|/* now compute password hash */
ifndef|#
directive|ifndef
name|NO_DES
if|if
condition|(
name|usecrypt
condition|)
name|hash
operator|=
name|des_crypt
argument_list|(
name|passwd
argument_list|,
operator|*
name|salt_p
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_MD5CRYPT_1
if|if
condition|(
name|use1
operator|||
name|useapr1
condition|)
name|hash
operator|=
name|md5crypt
argument_list|(
name|passwd
argument_list|,
operator|(
name|use1
condition|?
literal|"1"
else|:
literal|"apr1"
operator|)
argument_list|,
operator|*
name|salt_p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|hash
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|&&
operator|!
name|reverse
condition|)
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"%s\t%s\n"
argument_list|,
name|passwd
argument_list|,
name|hash
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|table
operator|&&
name|reverse
condition|)
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"%s\t%s\n"
argument_list|,
name|hash
argument_list|,
name|passwd
argument_list|)
expr_stmt|;
else|else
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|hash
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|err
label|:
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|MAIN
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|fputs
argument_list|(
literal|"Program not available.\n"
argument_list|,
argument|stderr
argument_list|)
name|EXIT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

