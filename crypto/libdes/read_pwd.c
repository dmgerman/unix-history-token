begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/des/read_pwd.c */
end_comment

begin_comment
comment|/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)  * All rights reserved.  *  * This package is an SSL implementation written  * by Eric Young (eay@cryptsoft.com).  * The implementation was written so as to conform with Netscapes SSL.  *   * This library is free for commercial and non-commercial use as long as  * the following conditions are aheared to.  The following conditions  * apply to all code found in this distribution, be it the RC4, RSA,  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation  * included with this distribution is covered by the same copyright terms  * except that the holder is Tim Hudson (tjh@cryptsoft.com).  *   * Copyright remains Eric Young's, and as such any Copyright notices in  * the code are not to be removed.  * If this package is used in a product, Eric Young should be given attribution  * as the author of the parts of the library used.  * This can be in the form of a textual message at program startup or  * in documentation (online or textual) provided with the package.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    "This product includes cryptographic software written by  *     Eric Young (eay@cryptsoft.com)"  *    The word 'cryptographic' can be left out if the rouines from the library  *    being used are not cryptographic related :-).  * 4. If you include any Windows specific code (or a derivative thereof) from   *    the apps directory (application code) you must include an acknowledgement:  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"  *   * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * The licence and distribution terms for any publically available version or  * derivative of this code cannot be changed.  i.e. this code cannot simply be  * copied and put under another distribution licence  * [including the GNU Public Licence.]  *   * $FreeBSD$  */
end_comment

begin_comment
comment|/* #define SIGACTION */
end_comment

begin_comment
comment|/* Define this if you have sigaction() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WIN16TTY
end_ifdef

begin_undef
undef|#
directive|undef
name|WIN16
end_undef

begin_undef
undef|#
directive|undef
name|_WINDOWS
end_undef

begin_include
include|#
directive|include
file|<graph.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 06-Apr-92 Luke Brennan    Support for VMS */
end_comment

begin_include
include|#
directive|include
file|"des_locl.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* prototypes for sys$whatever */
end_comment

begin_include
include|#
directive|include
file|<starlet.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__DECC
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|message
name|disable
name|DOLLARID
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIN_CONSOLE_BUG
end_ifdef

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<wincon.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* There are 5 types of terminal interface supported,  * TERMIO, TERMIOS, VMS, MSDOS and SGTTY  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TERMIOS
argument_list|)
end_if

begin_define
define|#
directive|define
name|TERMIOS
end_define

begin_undef
undef|#
directive|undef
name|TERMIO
end_undef

begin_undef
undef|#
directive|undef
name|SGTTY
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|linux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TERMIO
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|TERMIOS
end_undef

begin_define
define|#
directive|define
name|TERMIO
end_define

begin_undef
undef|#
directive|undef
name|SGTTY
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_undef
undef|#
directive|undef
name|TERMIOS
end_undef

begin_define
define|#
directive|define
name|TERMIO
end_define

begin_undef
undef|#
directive|undef
name|SGTTY
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TERMIO
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TERMIOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|TERMIOS
end_undef

begin_undef
undef|#
directive|undef
name|TERMIO
end_undef

begin_define
define|#
directive|define
name|SGTTY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIOS
end_ifdef

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_define
define|#
directive|define
name|TTY_STRUCT
value|struct termios
end_define

begin_define
define|#
directive|define
name|TTY_FLAGS
value|c_lflag
end_define

begin_define
define|#
directive|define
name|TTY_get
parameter_list|(
name|tty
parameter_list|,
name|data
parameter_list|)
value|tcgetattr(tty,data)
end_define

begin_define
define|#
directive|define
name|TTY_set
parameter_list|(
name|tty
parameter_list|,
name|data
parameter_list|)
value|tcsetattr(tty,TCSANOW,data)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIO
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_define
define|#
directive|define
name|TTY_STRUCT
value|struct termio
end_define

begin_define
define|#
directive|define
name|TTY_FLAGS
value|c_lflag
end_define

begin_define
define|#
directive|define
name|TTY_get
parameter_list|(
name|tty
parameter_list|,
name|data
parameter_list|)
value|ioctl(tty,TCGETA,data)
end_define

begin_define
define|#
directive|define
name|TTY_set
parameter_list|(
name|tty
parameter_list|,
name|data
parameter_list|)
value|ioctl(tty,TCSETA,data)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SGTTY
end_ifdef

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_define
define|#
directive|define
name|TTY_STRUCT
value|struct sgttyb
end_define

begin_define
define|#
directive|define
name|TTY_FLAGS
value|sg_flags
end_define

begin_define
define|#
directive|define
name|TTY_get
parameter_list|(
name|tty
parameter_list|,
name|data
parameter_list|)
value|ioctl(tty,TIOCGETP,data)
end_define

begin_define
define|#
directive|define
name|TTY_set
parameter_list|(
name|tty
parameter_list|,
name|data
parameter_list|)
value|ioctl(tty,TIOCSETP,data)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_LIBC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_include
include|#
directive|include
file|<conio.h>
end_include

begin_define
define|#
directive|define
name|fgets
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|noecho_fgets(a,b,c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<ssdef.h>
end_include

begin_include
include|#
directive|include
file|<iodef.h>
end_include

begin_include
include|#
directive|include
file|<ttdef.h>
end_include

begin_include
include|#
directive|include
file|<descrip.h>
end_include

begin_struct
struct|struct
name|IOSB
block|{
name|short
name|iosb$w_value
decl_stmt|;
name|short
name|iosb$w_count
decl_stmt|;
name|long
name|iosb$l_info
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NX509_SIG
end_ifndef

begin_define
define|#
directive|define
name|NX509_SIG
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|read_till_nl
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|recsig
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pushsig
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|popsig
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN16
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|noecho_fgets
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|FILE
modifier|*
name|tty
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SIGACTION
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|sigaction
name|savsig
index|[
name|NX509_SIG
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|savsig
index|[
name|NX509_SIG
index|]
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|jmp_buf
name|save
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|des_read_pw_string
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|prompt
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|des_read_pw
argument_list|(
name|buf
argument_list|,
name|buff
argument_list|,
operator|(
name|length
operator|>
name|BUFSIZ
operator|)
condition|?
name|BUFSIZ
else|:
name|length
argument_list|,
name|prompt
argument_list|,
name|verify
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|WIN16
end_ifndef

begin_function
specifier|static
name|void
name|read_till_nl
parameter_list|(
name|FILE
modifier|*
name|in
parameter_list|)
block|{
define|#
directive|define
name|SIZE
value|4
name|char
name|buf
index|[
name|SIZE
operator|+
literal|1
index|]
decl_stmt|;
do|do
block|{
name|fgets
argument_list|(
name|buf
argument_list|,
name|SIZE
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
operator|==
name|NULL
condition|)
do|;
block|}
end_function

begin_comment
comment|/* return 0 if ok, 1 (or -1) otherwise */
end_comment

begin_function
name|int
name|des_read_pw
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|buff
parameter_list|,
name|int
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|prompt
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|VMS
name|struct
name|IOSB
name|iosb
decl_stmt|;
name|$DESCRIPTOR
argument_list|(
name|terminal
argument_list|,
literal|"TT"
argument_list|)
expr_stmt|;
name|long
name|tty_orig
index|[
literal|3
index|]
decl_stmt|,
name|tty_new
index|[
literal|3
index|]
decl_stmt|;
name|long
name|status
decl_stmt|;
name|unsigned
name|short
name|channel
init|=
literal|0
decl_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|MSDOS
name|TTY_STRUCT
name|tty_orig
decl_stmt|,
name|tty_new
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|int
name|number
decl_stmt|;
name|int
name|ok
decl_stmt|;
comment|/* statics are simply to avoid warnings about longjmp clobbering 	   things */
specifier|static
name|int
name|ps
decl_stmt|;
name|int
name|is_a_tty
decl_stmt|;
specifier|static
name|FILE
modifier|*
name|tty
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|save
argument_list|)
condition|)
block|{
name|ok
operator|=
literal|0
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|number
operator|=
literal|5
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
name|ps
operator|=
literal|0
expr_stmt|;
name|is_a_tty
operator|=
literal|1
expr_stmt|;
name|tty
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
if|if
condition|(
operator|(
name|tty
operator|=
name|fopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tty
operator|=
name|stdin
expr_stmt|;
else|#
directive|else
comment|/* MSDOS */
if|if
condition|(
operator|(
name|tty
operator|=
name|fopen
argument_list|(
literal|"con"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tty
operator|=
name|stdin
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
if|#
directive|if
name|defined
argument_list|(
name|TTY_get
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
if|if
condition|(
name|TTY_get
argument_list|(
name|fileno
argument_list|(
name|tty
argument_list|)
argument_list|,
operator|&
name|tty_orig
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|ENOTTY
if|if
condition|(
name|errno
operator|==
name|ENOTTY
condition|)
name|is_a_tty
operator|=
literal|0
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EINVAL
comment|/* Ariel Glenn ariel@columbia.edu reports that solaris 		 * can return EINVAL instead.  This should be ok */
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
name|is_a_tty
operator|=
literal|0
expr_stmt|;
else|else
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|&
operator|(
name|tty_new
operator|)
argument_list|,
operator|&
operator|(
name|tty_orig
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tty_orig
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS
name|status
operator|=
name|sys$assign
argument_list|(
operator|&
name|terminal
argument_list|,
operator|&
name|channel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SS$_NORMAL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|status
operator|=
name|sys$qiow
argument_list|(
literal|0
argument_list|,
name|channel
argument_list|,
name|IO$_SENSEMODE
argument_list|,
operator|&
name|iosb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tty_orig
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|SS$_NORMAL
operator|)
operator|||
operator|(
name|iosb
operator|.
name|iosb$w_value
operator|!=
name|SS$_NORMAL
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
name|pushsig
argument_list|()
expr_stmt|;
name|ps
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TTY_FLAGS
name|tty_new
operator|.
name|TTY_FLAGS
operator|&=
operator|~
name|ECHO
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TTY_set
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
if|if
condition|(
name|is_a_tty
operator|&&
operator|(
name|TTY_set
argument_list|(
name|fileno
argument_list|(
name|tty
argument_list|)
argument_list|,
operator|&
name|tty_new
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS
name|tty_new
index|[
literal|0
index|]
operator|=
name|tty_orig
index|[
literal|0
index|]
expr_stmt|;
name|tty_new
index|[
literal|1
index|]
operator|=
name|tty_orig
index|[
literal|1
index|]
operator||
name|TT$M_NOECHO
expr_stmt|;
name|tty_new
index|[
literal|2
index|]
operator|=
name|tty_orig
index|[
literal|2
index|]
expr_stmt|;
name|status
operator|=
name|sys$qiow
argument_list|(
literal|0
argument_list|,
name|channel
argument_list|,
name|IO$_SETMODE
argument_list|,
operator|&
name|iosb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tty_new
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|SS$_NORMAL
operator|)
operator|||
operator|(
name|iosb
operator|.
name|iosb$w_value
operator|!=
name|SS$_NORMAL
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
name|ps
operator|=
literal|2
expr_stmt|;
while|while
condition|(
operator|(
operator|!
name|ok
operator|)
operator|&&
operator|(
name|number
operator|--
operator|)
condition|)
block|{
name|fputs
argument_list|(
name|prompt
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|tty
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|ferror
argument_list|(
name|tty
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
else|else
name|read_till_nl
argument_list|(
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nVerifying password - %s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|buff
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fgets
argument_list|(
name|buff
argument_list|,
name|size
argument_list|,
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|tty
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
else|else
name|read_till_nl
argument_list|(
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|buff
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nVerify failure"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
break|break;
comment|/* continue; */
block|}
block|}
name|ok
operator|=
literal|1
expr_stmt|;
block|}
name|error
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|perror
argument_list|(
literal|"fgets(tty)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* What can we do if there is an error? */
if|#
directive|if
name|defined
argument_list|(
name|TTY_set
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
if|if
condition|(
name|ps
operator|>=
literal|2
condition|)
name|TTY_set
argument_list|(
name|fileno
argument_list|(
name|tty
argument_list|)
argument_list|,
operator|&
name|tty_orig
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|ps
operator|>=
literal|2
condition|)
name|status
operator|=
name|sys$qiow
argument_list|(
literal|0
argument_list|,
name|channel
argument_list|,
name|IO$_SETMODE
argument_list|,
operator|&
name|iosb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tty_orig
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ps
operator|>=
literal|1
condition|)
name|popsig
argument_list|()
expr_stmt|;
if|if
condition|(
name|stdin
operator|!=
name|tty
condition|)
name|fclose
argument_list|(
name|tty
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|status
operator|=
name|sys$dassgn
argument_list|(
name|channel
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|!
name|ok
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* WIN16 */
end_comment

begin_function
name|int
name|des_read_pw
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|buff
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|prompt
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|pushsig
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGACTION
name|struct
name|sigaction
name|sa
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|recsig
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NX509_SIG
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|SIGUSR1
if|if
condition|(
name|i
operator|==
name|SIGUSR1
condition|)
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGUSR2
if|if
condition|(
name|i
operator|==
name|SIGUSR2
condition|)
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGACTION
name|sigaction
argument_list|(
name|i
argument_list|,
operator|&
name|sa
argument_list|,
operator|&
name|savsig
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|savsig
index|[
name|i
index|]
operator|=
name|signal
argument_list|(
name|i
argument_list|,
name|recsig
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SIGWINCH
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|popsig
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NX509_SIG
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|SIGUSR1
if|if
condition|(
name|i
operator|==
name|SIGUSR1
condition|)
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGUSR2
if|if
condition|(
name|i
operator|==
name|SIGUSR2
condition|)
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGACTION
name|sigaction
argument_list|(
name|i
argument_list|,
operator|&
name|savsig
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|i
argument_list|,
name|savsig
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|recsig
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|longjmp
argument_list|(
name|save
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LINT
name|i
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN16
argument_list|)
end_if

begin_function
specifier|static
name|int
name|noecho_fgets
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|FILE
modifier|*
name|tty
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|size
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|WIN16TTY
name|i
operator|=
name|_inchar
argument_list|()
expr_stmt|;
else|#
directive|else
name|i
operator|=
name|getch
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
literal|'\r'
condition|)
name|i
operator|=
literal|'\n'
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|WIN_CONSOLE_BUG
comment|/* Win95 has several evil console bugs: one of these is that the  * last character read using getch() is passed to the next read: this is  * usually a CR so this can be trouble. No STDIO fix seems to work but  * flushing the console appears to do the trick.  */
block|{
name|HANDLE
name|inh
decl_stmt|;
name|inh
operator|=
name|GetStdHandle
argument_list|(
name|STD_INPUT_HANDLE
argument_list|)
expr_stmt|;
name|FlushConsoleInputBuffer
argument_list|(
name|inh
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

