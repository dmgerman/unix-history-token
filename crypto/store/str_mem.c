begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/store/str_mem.c -*- mode:C; c-file-style: "eay" -*- */
end_comment

begin_comment
comment|/* Written by Richard Levitte (richard@levitte.org) for the OpenSSL  * project 2003.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2003 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|"str_locl.h"
end_include

begin_comment
comment|/* The memory store is currently highly experimental.  It's meant to become    a base store used by other stores for internal caching (for full caching    support, aging needs to be added).     The database use is meant to support as much attribute association as    possible, while providing for as small search ranges as possible.    This is currently provided for by sorting the entries by numbers that    are composed of bits set at the positions indicated by attribute type    codes.  This provides for ranges determined by the highest attribute    type code value.  A better idea might be to sort by values computed    from the range of attributes associated with the object (basically,    the difference between the highest and lowest attribute type code)    and it's distance from a base (basically, the lowest associated    attribute type code). */
end_comment

begin_struct
struct|struct
name|mem_object_data_st
block|{
name|STORE_OBJECT
modifier|*
name|object
decl_stmt|;
name|STORE_ATTR_INFO
modifier|*
name|attr_info
decl_stmt|;
name|int
name|references
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mem_data_st
block|{
name|STACK
modifier|*
name|data
decl_stmt|;
comment|/* A stack of mem_object_data_st, 				   sorted with STORE_ATTR_INFO_compare(). */
name|unsigned
name|int
name|compute_components
range|:
literal|1
decl_stmt|;
comment|/* Currently unused, but can 						be used to add attributes 						from parts of the data. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mem_ctx_st
block|{
name|int
name|type
decl_stmt|;
comment|/* The type we're searching for */
name|STACK
modifier|*
name|search_attributes
decl_stmt|;
comment|/* Sets of attributes to search for. 				     Each element is a STORE_ATTR_INFO. */
name|int
name|search_index
decl_stmt|;
comment|/* which of the search attributes we found a match 				   for, -1 when we still haven't found any */
name|int
name|index
decl_stmt|;
comment|/* -1 as long as we're searching for the first */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|mem_init
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mem_clean
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|STORE_OBJECT
modifier|*
name|mem_generate
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|STORE_OBJECT_TYPES
name|type
parameter_list|,
name|OPENSSL_ITEM
name|attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|STORE_OBJECT
modifier|*
name|mem_get
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|STORE_OBJECT_TYPES
name|type
parameter_list|,
name|OPENSSL_ITEM
name|attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mem_store
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|STORE_OBJECT_TYPES
name|type
parameter_list|,
name|STORE_OBJECT
modifier|*
name|data
parameter_list|,
name|OPENSSL_ITEM
name|attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mem_modify
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|STORE_OBJECT_TYPES
name|type
parameter_list|,
name|OPENSSL_ITEM
name|search_attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|add_attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|modify_attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|delete_attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mem_delete
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|STORE_OBJECT_TYPES
name|type
parameter_list|,
name|OPENSSL_ITEM
name|attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|mem_list_start
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|STORE_OBJECT_TYPES
name|type
parameter_list|,
name|OPENSSL_ITEM
name|attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|STORE_OBJECT
modifier|*
name|mem_list_next
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mem_list_end
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mem_list_endp
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mem_lock
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|OPENSSL_ITEM
name|attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mem_unlock
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|OPENSSL_ITEM
name|attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mem_ctrl
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|l
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|STORE_METHOD
name|store_memory
init|=
block|{
literal|"OpenSSL memory store interface"
block|,
name|mem_init
block|,
name|mem_clean
block|,
name|mem_generate
block|,
name|mem_get
block|,
name|mem_store
block|,
name|mem_modify
block|,
name|NULL
block|,
comment|/* revoke */
name|mem_delete
block|,
name|mem_list_start
block|,
name|mem_list_next
block|,
name|mem_list_end
block|,
name|mem_list_endp
block|,
name|NULL
block|,
comment|/* update */
name|mem_lock
block|,
name|mem_unlock
block|,
name|mem_ctrl
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|STORE_METHOD
modifier|*
name|STORE_Memory
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|store_memory
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mem_init
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mem_clean
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|STORE_OBJECT
modifier|*
name|mem_generate
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|STORE_OBJECT_TYPES
name|type
parameter_list|,
name|OPENSSL_ITEM
name|attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
block|{
name|STOREerr
argument_list|(
name|STORE_F_MEM_GENERATE
argument_list|,
name|STORE_R_NOT_IMPLEMENTED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|STORE_OBJECT
modifier|*
name|mem_get
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|STORE_OBJECT_TYPES
name|type
parameter_list|,
name|OPENSSL_ITEM
name|attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
block|{
name|void
modifier|*
name|context
init|=
name|mem_list_start
argument_list|(
name|s
argument_list|,
name|type
argument_list|,
name|attributes
argument_list|,
name|parameters
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|STORE_OBJECT
modifier|*
name|object
init|=
name|mem_list_next
argument_list|(
name|s
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|mem_list_end
argument_list|(
name|s
argument_list|,
name|context
argument_list|)
condition|)
return|return
name|object
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mem_store
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|STORE_OBJECT_TYPES
name|type
parameter_list|,
name|STORE_OBJECT
modifier|*
name|data
parameter_list|,
name|OPENSSL_ITEM
name|attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
block|{
name|STOREerr
argument_list|(
name|STORE_F_MEM_STORE
argument_list|,
name|STORE_R_NOT_IMPLEMENTED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mem_modify
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|STORE_OBJECT_TYPES
name|type
parameter_list|,
name|OPENSSL_ITEM
name|search_attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|add_attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|modify_attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|delete_attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
block|{
name|STOREerr
argument_list|(
name|STORE_F_MEM_MODIFY
argument_list|,
name|STORE_R_NOT_IMPLEMENTED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mem_delete
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|STORE_OBJECT_TYPES
name|type
parameter_list|,
name|OPENSSL_ITEM
name|attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
block|{
name|STOREerr
argument_list|(
name|STORE_F_MEM_DELETE
argument_list|,
name|STORE_R_NOT_IMPLEMENTED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The list functions may be the hardest to understand.  Basically,    mem_list_start compiles a stack of attribute info elements, and    puts that stack into the context to be returned.  mem_list_next    will then find the first matching element in the store, and then    walk all the way to the end of the store (since any combination    of attribute bits above the starting point may match the searched    for bit pattern...). */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|mem_list_start
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|STORE_OBJECT_TYPES
name|type
parameter_list|,
name|OPENSSL_ITEM
name|attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
block|{
name|struct
name|mem_ctx_st
modifier|*
name|context
init|=
operator|(
expr|struct
name|mem_ctx_st
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mem_ctx_st
argument_list|)
argument_list|)
decl_stmt|;
name|void
modifier|*
name|attribute_context
init|=
name|NULL
decl_stmt|;
name|STORE_ATTR_INFO
modifier|*
name|attrs
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|STOREerr
argument_list|(
name|STORE_F_MEM_LIST_START
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mem_ctx_st
argument_list|)
argument_list|)
expr_stmt|;
name|attribute_context
operator|=
name|STORE_parse_attrs_start
argument_list|(
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attribute_context
condition|)
block|{
name|STOREerr
argument_list|(
name|STORE_F_MEM_LIST_START
argument_list|,
name|ERR_R_STORE_LIB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
while|while
condition|(
operator|(
name|attrs
operator|=
name|STORE_parse_attrs_next
argument_list|(
name|attribute_context
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|search_attributes
operator|==
name|NULL
condition|)
block|{
name|context
operator|->
name|search_attributes
operator|=
name|sk_new
argument_list|(
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|char
operator|*
specifier|const
operator|*
argument_list|,
specifier|const
name|char
operator|*
specifier|const
operator|*
argument_list|)
operator|)
name|STORE_ATTR_INFO_compare
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
operator|->
name|search_attributes
condition|)
block|{
name|STOREerr
argument_list|(
name|STORE_F_MEM_LIST_START
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|sk_push
argument_list|(
name|context
operator|->
name|search_attributes
argument_list|,
operator|(
name|char
operator|*
operator|)
name|attrs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|STORE_parse_attrs_endp
argument_list|(
name|attribute_context
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|STORE_parse_attrs_end
argument_list|(
name|attribute_context
argument_list|)
expr_stmt|;
name|context
operator|->
name|search_index
operator|=
operator|-
literal|1
expr_stmt|;
name|context
operator|->
name|index
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|context
return|;
name|err
label|:
if|if
condition|(
name|attribute_context
condition|)
name|STORE_parse_attrs_end
argument_list|(
name|attribute_context
argument_list|)
expr_stmt|;
name|mem_list_end
argument_list|(
name|s
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|STORE_OBJECT
modifier|*
name|mem_list_next
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|mem_ctx_st
modifier|*
name|context
init|=
operator|(
expr|struct
name|mem_ctx_st
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|mem_object_data_st
name|key
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
name|struct
name|mem_data_st
modifier|*
name|store
init|=
operator|(
expr|struct
name|mem_data_st
operator|*
operator|)
name|STORE_get_ex_data
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|srch
decl_stmt|;
name|int
name|cres
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|STOREerr
argument_list|(
name|STORE_F_MEM_LIST_NEXT
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|store
condition|)
block|{
name|STOREerr
argument_list|(
name|STORE_F_MEM_LIST_NEXT
argument_list|,
name|STORE_R_NO_STORE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|context
operator|->
name|search_index
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_num
argument_list|(
name|context
operator|->
name|search_attributes
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|key
operator|.
name|attr_info
operator|=
operator|(
name|STORE_ATTR_INFO
operator|*
operator|)
name|sk_value
argument_list|(
name|context
operator|->
name|search_attributes
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|srch
operator|=
name|sk_find_ex
argument_list|(
name|store
operator|->
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|srch
operator|>=
literal|0
condition|)
block|{
name|context
operator|->
name|search_index
operator|=
name|srch
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|context
operator|->
name|search_index
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|key
operator|.
name|attr_info
operator|=
operator|(
name|STORE_ATTR_INFO
operator|*
operator|)
name|sk_value
argument_list|(
name|context
operator|->
name|search_attributes
argument_list|,
name|context
operator|->
name|search_index
argument_list|)
expr_stmt|;
for|for
control|(
name|srch
operator|=
name|context
operator|->
name|search_index
init|;
name|srch
operator|<
name|sk_num
argument_list|(
name|store
operator|->
name|data
argument_list|)
operator|&&
name|STORE_ATTR_INFO_in_range
argument_list|(
name|key
operator|.
name|attr_info
argument_list|,
operator|(
name|STORE_ATTR_INFO
operator|*
operator|)
name|sk_value
argument_list|(
name|store
operator|->
name|data
argument_list|,
name|srch
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|cres
operator|=
name|STORE_ATTR_INFO_in_ex
argument_list|(
name|key
operator|.
name|attr_info
argument_list|,
operator|(
name|STORE_ATTR_INFO
operator|*
operator|)
name|sk_value
argument_list|(
name|store
operator|->
name|data
argument_list|,
name|srch
argument_list|)
argument_list|)
operator|)
condition|;
name|srch
operator|++
control|)
empty_stmt|;
name|context
operator|->
name|search_index
operator|=
name|srch
expr_stmt|;
if|if
condition|(
name|cres
condition|)
return|return
operator|(
operator|(
expr|struct
name|mem_object_data_st
operator|*
operator|)
name|sk_value
argument_list|(
name|store
operator|->
name|data
argument_list|,
name|srch
argument_list|)
operator|)
operator|->
name|object
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mem_list_end
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|mem_ctx_st
modifier|*
name|context
init|=
operator|(
expr|struct
name|mem_ctx_st
operator|*
operator|)
name|handle
decl_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|STOREerr
argument_list|(
name|STORE_F_MEM_LIST_END
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|context
operator|&&
name|context
operator|->
name|search_attributes
condition|)
name|sk_free
argument_list|(
name|context
operator|->
name|search_attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|OPENSSL_free
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mem_list_endp
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|mem_ctx_st
modifier|*
name|context
init|=
operator|(
expr|struct
name|mem_ctx_st
operator|*
operator|)
name|handle
decl_stmt|;
if|if
condition|(
operator|!
name|context
operator|||
name|context
operator|->
name|search_index
operator|==
name|sk_num
argument_list|(
name|context
operator|->
name|search_attributes
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mem_lock
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|OPENSSL_ITEM
name|attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mem_unlock
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|OPENSSL_ITEM
name|attributes
index|[]
parameter_list|,
name|OPENSSL_ITEM
name|parameters
index|[]
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mem_ctrl
parameter_list|(
name|STORE
modifier|*
name|s
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|l
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

end_unit

