begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char sccsid[] = "@(#)sys_term.c	8.4+1 (Berkeley) 5/30/95";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"telnetd.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
end_if

begin_include
include|#
directive|include
file|<libtelnet/auth.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|altlogin
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|cleanopen
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|scrub_env
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CRAY
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
end_if

begin_define
define|#
directive|define
name|PARENT_DOES_UTMP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NEWINIT
end_ifdef

begin_include
include|#
directive|include
file|<initreq.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* NEWINIT*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UTMPX
end_ifdef

begin_include
include|#
directive|include
file|<utmpx.h>
end_include

begin_decl_stmt
name|struct
name|utmpx
name|wtmp
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_decl_stmt
name|struct
name|utmp
name|wtmp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UTMPX */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PARENT_DOES_UTMP
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|_PATH_WTMP
end_ifdef

begin_decl_stmt
name|char
name|wtmpf
index|[]
init|=
name|_PATH_WTMP
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|wtmpf
index|[]
init|=
literal|"/usr/adm/wtmp"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_PATH_UTMP
end_ifdef

begin_decl_stmt
name|char
name|utmpf
index|[]
init|=
name|_PATH_UTMP
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|utmpf
index|[]
init|=
literal|"/etc/utmp"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* PARENT_DOES_UTMP */
end_comment

begin_decl_stmt
name|char
name|wtmpf
index|[]
init|=
literal|"/etc/wtmp"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PARENT_DOES_UTMP */
end_comment

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CRAY
end_ifdef

begin_include
include|#
directive|include
file|<tmpdir.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_if
if|#
directive|if
operator|(
name|UNICOS_LVL
operator|==
literal|'7.0'
operator|)
operator|||
operator|(
name|UNICOS_LVL
operator|==
literal|'7.1'
operator|)
end_if

begin_define
define|#
directive|define
name|UNICOS7x
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UNICOS7x
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysv.h>
end_include

begin_include
include|#
directive|include
file|<sys/secstat.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|secflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sysv
name|sysv
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNICOS7x */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRAY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEWINIT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMSPTY
end_ifdef

begin_include
include|#
directive|include
file|<sac.h>
end_include

begin_include
include|#
directive|include
file|<sys/stropts.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SCPYN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(void) strncpy(a, b, sizeof(a))
end_define

begin_define
define|#
directive|define
name|SCMPN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strncmp(a, b, sizeof(a))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMS
end_ifdef

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|t_erase
end_ifdef

begin_undef
undef|#
directive|undef
name|t_erase
end_undef

begin_undef
undef|#
directive|undef
name|t_kill
end_undef

begin_undef
undef|#
directive|undef
name|t_intrc
end_undef

begin_undef
undef|#
directive|undef
name|t_quitc
end_undef

begin_undef
undef|#
directive|undef
name|t_startc
end_undef

begin_undef
undef|#
directive|undef
name|t_stopc
end_undef

begin_undef
undef|#
directive|undef
name|t_eofc
end_undef

begin_undef
undef|#
directive|undef
name|t_brkc
end_undef

begin_undef
undef|#
directive|undef
name|t_suspc
end_undef

begin_undef
undef|#
directive|undef
name|t_dsuspc
end_undef

begin_undef
undef|#
directive|undef
name|t_rprntc
end_undef

begin_undef
undef|#
directive|undef
name|t_flushc
end_undef

begin_undef
undef|#
directive|undef
name|t_werasc
end_undef

begin_undef
undef|#
directive|undef
name|t_lnextc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UNICOS5
argument_list|)
operator|&&
name|defined
argument_list|(
name|CRAY2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EXTPROC
argument_list|)
end_if

begin_define
define|#
directive|define
name|EXTPROC
value|0400
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USE_TERMIO
end_ifndef

begin_struct
struct|struct
name|termbuf
block|{
name|struct
name|sgttyb
name|sg
decl_stmt|;
name|struct
name|tchars
name|tc
decl_stmt|;
name|struct
name|ltchars
name|ltc
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|lflags
decl_stmt|;
block|}
name|termbuf
struct|,
name|termbuf2
struct|;
end_struct

begin_define
define|#
directive|define
name|cfsetospeed
parameter_list|(
name|tp
parameter_list|,
name|val
parameter_list|)
value|(tp)->sg.sg_ospeed = (val)
end_define

begin_define
define|#
directive|define
name|cfsetispeed
parameter_list|(
name|tp
parameter_list|,
name|val
parameter_list|)
value|(tp)->sg.sg_ispeed = (val)
end_define

begin_define
define|#
directive|define
name|cfgetospeed
parameter_list|(
name|tp
parameter_list|)
value|(tp)->sg.sg_ospeed
end_define

begin_define
define|#
directive|define
name|cfgetispeed
parameter_list|(
name|tp
parameter_list|)
value|(tp)->sg.sg_ispeed
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USE_TERMIO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV_TERMIO
end_ifdef

begin_define
define|#
directive|define
name|termios
value|termio
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TCSANOW
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|TCSETS
end_ifdef

begin_define
define|#
directive|define
name|TCSANOW
value|TCSETS
end_define

begin_define
define|#
directive|define
name|TCSADRAIN
value|TCSETSW
end_define

begin_define
define|#
directive|define
name|tcgetattr
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
value|ioctl(f, TCGETS, (char *)t)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|TCSETA
end_ifdef

begin_define
define|#
directive|define
name|TCSANOW
value|TCSETA
end_define

begin_define
define|#
directive|define
name|TCSADRAIN
value|TCSETAW
end_define

begin_define
define|#
directive|define
name|tcgetattr
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
value|ioctl(f, TCGETA, (char *)t)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TCSANOW
value|TIOCSETA
end_define

begin_define
define|#
directive|define
name|TCSADRAIN
value|TIOCSETAW
end_define

begin_define
define|#
directive|define
name|tcgetattr
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
value|ioctl(f, TIOCGETA, (char *)t)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|tcsetattr
parameter_list|(
name|f
parameter_list|,
name|a
parameter_list|,
name|t
parameter_list|)
value|ioctl(f, a, t)
end_define

begin_define
define|#
directive|define
name|cfsetospeed
parameter_list|(
name|tp
parameter_list|,
name|val
parameter_list|)
value|(tp)->c_cflag&= ~CBAUD; \ 					(tp)->c_cflag |= (val)
end_define

begin_define
define|#
directive|define
name|cfgetospeed
parameter_list|(
name|tp
parameter_list|)
value|((tp)->c_cflag& CBAUD)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|CIBAUD
end_ifdef

begin_define
define|#
directive|define
name|cfsetispeed
parameter_list|(
name|tp
parameter_list|,
name|val
parameter_list|)
value|(tp)->c_cflag&= ~CIBAUD; \ 					(tp)->c_cflag |= ((val)<<IBSHIFT)
end_define

begin_define
define|#
directive|define
name|cfgetispeed
parameter_list|(
name|tp
parameter_list|)
value|(((tp)->c_cflag& CIBAUD)>>IBSHIFT)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|cfsetispeed
parameter_list|(
name|tp
parameter_list|,
name|val
parameter_list|)
value|(tp)->c_cflag&= ~CBAUD; \ 					(tp)->c_cflag |= (val)
end_define

begin_define
define|#
directive|define
name|cfgetispeed
parameter_list|(
name|tp
parameter_list|)
value|((tp)->c_cflag& CBAUD)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCSANOW */
end_comment

begin_decl_stmt
name|struct
name|termios
name|termbuf
decl_stmt|,
name|termbuf2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pty control structure */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMSPTY
end_ifdef

begin_decl_stmt
name|int
name|ttyfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_TERMIO */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_decl_stmt
name|int
name|cleanopen
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|scrub_env
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * init_termbuf()  * copy_termbuf(cp)  * set_termbuf()  *  * These three routines are used to get and set the "termbuf" structure  * to and from the kernel.  init_termbuf() gets the current settings.  * copy_termbuf() hands in a new "termbuf" to write to the kernel, and  * set_termbuf() writes the structure into the kernel.  */
end_comment

begin_function
name|void
name|init_termbuf
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|sg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCGETC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|tc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCGLTC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|ltc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGSTATE
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCGSTATE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|STREAMSPTY
operator|(
name|void
operator|)
name|tcgetattr
argument_list|(
name|ttyfd
argument_list|,
operator|&
name|termbuf
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|tcgetattr
argument_list|(
name|pty
argument_list|,
operator|&
name|termbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|termbuf2
operator|=
name|termbuf
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LINEMODE
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCPKT_IOCTL
argument_list|)
end_if

begin_function
name|void
name|copy_termbuf
parameter_list|(
name|cp
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|termbuf
argument_list|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|termbuf
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|termbuf2
operator|=
name|termbuf
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(LINEMODE)&& defined(TIOCPKT_IOCTL) */
end_comment

begin_function
name|void
name|set_termbuf
parameter_list|()
block|{
comment|/* 	 * Only make the necessary changes. 	 */
ifndef|#
directive|ifndef
name|USE_TERMIO
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|sg
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf2
operator|.
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
name|termbuf
operator|.
name|sg
argument_list|)
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCSETN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|sg
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|tc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf2
operator|.
name|tc
argument_list|,
sizeof|sizeof
argument_list|(
name|termbuf
operator|.
name|tc
argument_list|)
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCSETC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|tc
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|ltc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf2
operator|.
name|ltc
argument_list|,
sizeof|sizeof
argument_list|(
name|termbuf
operator|.
name|ltc
argument_list|)
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCSLTC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|ltc
argument_list|)
expr_stmt|;
if|if
condition|(
name|termbuf
operator|.
name|lflags
operator|!=
name|termbuf2
operator|.
name|lflags
condition|)
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCLSET
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|lflags
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* USE_TERMIO */
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|termbuf2
argument_list|,
sizeof|sizeof
argument_list|(
name|termbuf
argument_list|)
argument_list|)
condition|)
ifdef|#
directive|ifdef
name|STREAMSPTY
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|ttyfd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|termbuf
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|pty
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|termbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|CRAY2
argument_list|)
operator|&&
name|defined
argument_list|(
name|UNICOS5
argument_list|)
name|needtermstat
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* USE_TERMIO */
block|}
end_function

begin_comment
comment|/*  * spcset(func, valp, valpp)  *  * This function takes various special characters (func), and  * sets *valp to the current value of that character, and  * *valpp to point to where in the "termbuf" structure that  * value is kept.  *  * It returns the SLC_ level of support for this function.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USE_TERMIO
end_ifndef

begin_function
name|int
name|spcset
parameter_list|(
name|func
parameter_list|,
name|valp
parameter_list|,
name|valpp
parameter_list|)
name|int
name|func
decl_stmt|;
name|cc_t
modifier|*
name|valp
decl_stmt|;
name|cc_t
modifier|*
modifier|*
name|valpp
decl_stmt|;
block|{
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|SLC_EOF
case|:
operator|*
name|valp
operator|=
name|termbuf
operator|.
name|tc
operator|.
name|t_eofc
expr_stmt|;
operator|*
name|valpp
operator|=
operator|(
name|cc_t
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|tc
operator|.
name|t_eofc
expr_stmt|;
return|return
operator|(
name|SLC_VARIABLE
operator|)
return|;
case|case
name|SLC_EC
case|:
operator|*
name|valp
operator|=
name|termbuf
operator|.
name|sg
operator|.
name|sg_erase
expr_stmt|;
operator|*
name|valpp
operator|=
operator|(
name|cc_t
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|sg
operator|.
name|sg_erase
expr_stmt|;
return|return
operator|(
name|SLC_VARIABLE
operator|)
return|;
case|case
name|SLC_EL
case|:
operator|*
name|valp
operator|=
name|termbuf
operator|.
name|sg
operator|.
name|sg_kill
expr_stmt|;
operator|*
name|valpp
operator|=
operator|(
name|cc_t
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|sg
operator|.
name|sg_kill
expr_stmt|;
return|return
operator|(
name|SLC_VARIABLE
operator|)
return|;
case|case
name|SLC_IP
case|:
operator|*
name|valp
operator|=
name|termbuf
operator|.
name|tc
operator|.
name|t_intrc
expr_stmt|;
operator|*
name|valpp
operator|=
operator|(
name|cc_t
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|tc
operator|.
name|t_intrc
expr_stmt|;
return|return
operator|(
name|SLC_VARIABLE
operator||
name|SLC_FLUSHIN
operator||
name|SLC_FLUSHOUT
operator|)
return|;
case|case
name|SLC_ABORT
case|:
operator|*
name|valp
operator|=
name|termbuf
operator|.
name|tc
operator|.
name|t_quitc
expr_stmt|;
operator|*
name|valpp
operator|=
operator|(
name|cc_t
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|tc
operator|.
name|t_quitc
expr_stmt|;
return|return
operator|(
name|SLC_VARIABLE
operator||
name|SLC_FLUSHIN
operator||
name|SLC_FLUSHOUT
operator|)
return|;
case|case
name|SLC_XON
case|:
operator|*
name|valp
operator|=
name|termbuf
operator|.
name|tc
operator|.
name|t_startc
expr_stmt|;
operator|*
name|valpp
operator|=
operator|(
name|cc_t
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|tc
operator|.
name|t_startc
expr_stmt|;
return|return
operator|(
name|SLC_VARIABLE
operator|)
return|;
case|case
name|SLC_XOFF
case|:
operator|*
name|valp
operator|=
name|termbuf
operator|.
name|tc
operator|.
name|t_stopc
expr_stmt|;
operator|*
name|valpp
operator|=
operator|(
name|cc_t
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|tc
operator|.
name|t_stopc
expr_stmt|;
return|return
operator|(
name|SLC_VARIABLE
operator|)
return|;
case|case
name|SLC_AO
case|:
operator|*
name|valp
operator|=
name|termbuf
operator|.
name|ltc
operator|.
name|t_flushc
expr_stmt|;
operator|*
name|valpp
operator|=
operator|(
name|cc_t
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|ltc
operator|.
name|t_flushc
expr_stmt|;
return|return
operator|(
name|SLC_VARIABLE
operator|)
return|;
case|case
name|SLC_SUSP
case|:
operator|*
name|valp
operator|=
name|termbuf
operator|.
name|ltc
operator|.
name|t_suspc
expr_stmt|;
operator|*
name|valpp
operator|=
operator|(
name|cc_t
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|ltc
operator|.
name|t_suspc
expr_stmt|;
return|return
operator|(
name|SLC_VARIABLE
operator|)
return|;
case|case
name|SLC_EW
case|:
operator|*
name|valp
operator|=
name|termbuf
operator|.
name|ltc
operator|.
name|t_werasc
expr_stmt|;
operator|*
name|valpp
operator|=
operator|(
name|cc_t
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|ltc
operator|.
name|t_werasc
expr_stmt|;
return|return
operator|(
name|SLC_VARIABLE
operator|)
return|;
case|case
name|SLC_RP
case|:
operator|*
name|valp
operator|=
name|termbuf
operator|.
name|ltc
operator|.
name|t_rprntc
expr_stmt|;
operator|*
name|valpp
operator|=
operator|(
name|cc_t
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|ltc
operator|.
name|t_rprntc
expr_stmt|;
return|return
operator|(
name|SLC_VARIABLE
operator|)
return|;
case|case
name|SLC_LNEXT
case|:
operator|*
name|valp
operator|=
name|termbuf
operator|.
name|ltc
operator|.
name|t_lnextc
expr_stmt|;
operator|*
name|valpp
operator|=
operator|(
name|cc_t
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|ltc
operator|.
name|t_lnextc
expr_stmt|;
return|return
operator|(
name|SLC_VARIABLE
operator|)
return|;
case|case
name|SLC_FORW1
case|:
operator|*
name|valp
operator|=
name|termbuf
operator|.
name|tc
operator|.
name|t_brkc
expr_stmt|;
operator|*
name|valpp
operator|=
operator|(
name|cc_t
operator|*
operator|)
operator|&
name|termbuf
operator|.
name|ltc
operator|.
name|t_lnextc
expr_stmt|;
return|return
operator|(
name|SLC_VARIABLE
operator|)
return|;
case|case
name|SLC_BRK
case|:
case|case
name|SLC_SYNCH
case|:
case|case
name|SLC_AYT
case|:
case|case
name|SLC_EOR
case|:
operator|*
name|valp
operator|=
operator|(
name|cc_t
operator|)
literal|0
expr_stmt|;
operator|*
name|valpp
operator|=
operator|(
name|cc_t
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|SLC_DEFAULT
operator|)
return|;
default|default:
operator|*
name|valp
operator|=
operator|(
name|cc_t
operator|)
literal|0
expr_stmt|;
operator|*
name|valpp
operator|=
operator|(
name|cc_t
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|SLC_NOSUPPORT
operator|)
return|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USE_TERMIO */
end_comment

begin_function
name|int
name|spcset
parameter_list|(
name|func
parameter_list|,
name|valp
parameter_list|,
name|valpp
parameter_list|)
name|int
name|func
decl_stmt|;
name|cc_t
modifier|*
name|valp
decl_stmt|;
name|cc_t
modifier|*
modifier|*
name|valpp
decl_stmt|;
block|{
define|#
directive|define
name|setval
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|*valp = termbuf.c_cc[a]; \ 			*valpp =&termbuf.c_cc[a]; \ 			return(b);
define|#
directive|define
name|defval
parameter_list|(
name|a
parameter_list|)
value|*valp = ((cc_t)a); *valpp = (cc_t *)0; return(SLC_DEFAULT);
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|SLC_EOF
case|:
name|setval
argument_list|(
name|VEOF
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
case|case
name|SLC_EC
case|:
name|setval
argument_list|(
name|VERASE
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
case|case
name|SLC_EL
case|:
name|setval
argument_list|(
name|VKILL
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
case|case
name|SLC_IP
case|:
name|setval
argument_list|(
name|VINTR
argument_list|,
name|SLC_VARIABLE
operator||
name|SLC_FLUSHIN
operator||
name|SLC_FLUSHOUT
argument_list|)
expr_stmt|;
case|case
name|SLC_ABORT
case|:
name|setval
argument_list|(
name|VQUIT
argument_list|,
name|SLC_VARIABLE
operator||
name|SLC_FLUSHIN
operator||
name|SLC_FLUSHOUT
argument_list|)
expr_stmt|;
case|case
name|SLC_XON
case|:
ifdef|#
directive|ifdef
name|VSTART
name|setval
argument_list|(
name|VSTART
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0x13
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_XOFF
case|:
ifdef|#
directive|ifdef
name|VSTOP
name|setval
argument_list|(
name|VSTOP
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0x11
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_EW
case|:
ifdef|#
directive|ifdef
name|VWERASE
name|setval
argument_list|(
name|VWERASE
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_RP
case|:
ifdef|#
directive|ifdef
name|VREPRINT
name|setval
argument_list|(
name|VREPRINT
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_LNEXT
case|:
ifdef|#
directive|ifdef
name|VLNEXT
name|setval
argument_list|(
name|VLNEXT
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_AO
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VDISCARD
argument_list|)
operator|&&
name|defined
argument_list|(
name|VFLUSHO
argument_list|)
define|#
directive|define
name|VDISCARD
value|VFLUSHO
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VDISCARD
name|setval
argument_list|(
name|VDISCARD
argument_list|,
name|SLC_VARIABLE
operator||
name|SLC_FLUSHOUT
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_SUSP
case|:
ifdef|#
directive|ifdef
name|VSUSP
name|setval
argument_list|(
name|VSUSP
argument_list|,
name|SLC_VARIABLE
operator||
name|SLC_FLUSHIN
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VEOL
case|case
name|SLC_FORW1
case|:
name|setval
argument_list|(
name|VEOL
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VEOL2
case|case
name|SLC_FORW2
case|:
name|setval
argument_list|(
name|VEOL2
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_AYT
case|:
ifdef|#
directive|ifdef
name|VSTATUS
name|setval
argument_list|(
name|VSTATUS
argument_list|,
name|SLC_VARIABLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|defval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|SLC_BRK
case|:
case|case
name|SLC_SYNCH
case|:
case|case
name|SLC_EOR
case|:
name|defval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
operator|*
name|valp
operator|=
literal|0
expr_stmt|;
operator|*
name|valpp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|SLC_NOSUPPORT
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_TERMIO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CRAY
end_ifdef

begin_comment
comment|/*  * getnpty()  *  * Return the number of pty's configured into the system.  */
end_comment

begin_function
name|int
name|getnpty
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|_SC_CRAY_NPTY
name|int
name|numptys
decl_stmt|;
if|if
condition|(
operator|(
name|numptys
operator|=
name|sysconf
argument_list|(
name|_SC_CRAY_NPTY
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|numptys
return|;
else|else
endif|#
directive|endif
comment|/* _SC_CRAY_NPTY */
return|return
literal|128
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRAY */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|convex
end_ifndef

begin_comment
comment|/*  * getpty()  *  * Allocate a pty.  As a side effect, the external character  * array "line" contains the name of the slave side.  *  * Returns the file descriptor of the opened pty.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|line
init|=
literal|"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|Xline
index|[]
init|=
literal|"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|line
init|=
name|Xline
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CRAY
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|myline
init|=
literal|"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRAY */
end_comment

begin_function
name|int
name|getpty
parameter_list|(
name|ptynum
parameter_list|)
name|int
modifier|*
name|ptynum
decl_stmt|;
block|{
specifier|register
name|int
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|STREAMSPTY
name|int
name|t
decl_stmt|;
name|char
modifier|*
name|ptsname
parameter_list|()
function_decl|;
name|p
operator|=
name|open
argument_list|(
literal|"/dev/ptmx"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>
literal|0
condition|)
block|{
name|grantpt
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|unlockpt
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|ptsname
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
else|#
directive|else
comment|/* ! STREAMSPTY */
ifndef|#
directive|ifndef
name|CRAY
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGPGRP
argument_list|)
operator|&&
name|BSD
operator|<
literal|199207
name|int
name|dummy
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|__hpux
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"/dev/ptyXX"
argument_list|)
expr_stmt|;
name|p1
operator|=
operator|&
name|line
index|[
literal|8
index|]
expr_stmt|;
name|p2
operator|=
operator|&
name|line
index|[
literal|9
index|]
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"/dev/ptym/ptyXX"
argument_list|)
expr_stmt|;
name|p1
operator|=
operator|&
name|line
index|[
literal|13
index|]
expr_stmt|;
name|p2
operator|=
operator|&
name|line
index|[
literal|14
index|]
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|cp
operator|=
literal|"pqrsPQRS"
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|struct
name|stat
name|stb
decl_stmt|;
operator|*
name|p1
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|p2
operator|=
literal|'0'
expr_stmt|;
comment|/* 		 * This stat() check is just to keep us from 		 * looping through all 256 combinations if there 		 * aren't that many ptys available. 		 */
if|if
condition|(
name|stat
argument_list|(
name|line
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p2
operator|=
literal|"0123456789abcdefghijklmnopqrstuv"
index|[
name|i
index|]
expr_stmt|;
name|p
operator|=
name|open
argument_list|(
name|line
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|__hpux
name|line
index|[
literal|5
index|]
operator|=
literal|'t'
expr_stmt|;
else|#
directive|else
for|for
control|(
name|p1
operator|=
operator|&
name|line
index|[
literal|8
index|]
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
operator|*
name|p1
operator|=
operator|*
operator|(
name|p1
operator|+
literal|1
operator|)
expr_stmt|;
name|line
index|[
literal|9
index|]
operator|=
literal|'t'
expr_stmt|;
endif|#
directive|endif
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|line
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGPGRP
argument_list|)
operator|&&
name|BSD
operator|<
literal|199207
if|if
condition|(
name|ioctl
argument_list|(
name|p
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|dummy
argument_list|)
operator|==
literal|0
operator|||
name|errno
operator|!=
name|EIO
condition|)
block|{
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|line
index|[
literal|5
index|]
operator|=
literal|'p'
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* defined(sun)&& defined(TIOCGPGRP)&& BSD< 199207 */
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
block|}
else|#
directive|else
comment|/* CRAY */
extern|extern lowpty
operator|,
extern|highpty;
name|struct
name|stat
name|sb
decl_stmt|;
for|for
control|(
operator|*
name|ptynum
operator|=
name|lowpty
init|;
operator|*
name|ptynum
operator|<=
name|highpty
condition|;
operator|(
operator|*
name|ptynum
operator|)
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|myline
argument_list|,
literal|"/dev/pty/%03d"
argument_list|,
operator|*
name|ptynum
argument_list|)
expr_stmt|;
name|p
operator|=
name|open
argument_list|(
name|myline
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"/dev/ttyp%03d"
argument_list|,
operator|*
name|ptynum
argument_list|)
expr_stmt|;
comment|/* 		 * Here are some shenanigans to make sure that there 		 * are no listeners lurking on the line. 		 */
if|if
condition|(
name|stat
argument_list|(
name|line
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sb
operator|.
name|st_uid
operator|||
name|sb
operator|.
name|st_gid
operator|||
name|sb
operator|.
name|st_mode
operator|!=
literal|0600
condition|)
block|{
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|line
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|open
argument_list|(
name|myline
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<
literal|0
condition|)
continue|continue;
block|}
comment|/* 		 * Now it should be safe...check for accessability. 		 */
if|if
condition|(
name|access
argument_list|(
name|line
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
else|else
block|{
comment|/* no tty side to pty so skip it */
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* CRAY */
endif|#
directive|endif
comment|/* STREAMSPTY */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* convex */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LINEMODE
end_ifdef

begin_comment
comment|/*  * tty_flowmode()	Find out if flow control is enabled or disabled.  * tty_linemode()	Find out if linemode (external processing) is enabled.  * tty_setlinemod(on)	Turn on/off linemode.  * tty_isecho()		Find out if echoing is turned on.  * tty_setecho(on)	Enable/disable character echoing.  * tty_israw()		Find out if terminal is in RAW mode.  * tty_binaryin(on)	Turn on/off BINARY on input.  * tty_binaryout(on)	Turn on/off BINARY on output.  * tty_isediting()	Find out if line editing is enabled.  * tty_istrapsig()	Find out if signal trapping is enabled.  * tty_setedit(on)	Turn on/off line editing.  * tty_setsig(on)	Turn on/off signal trapping.  * tty_issofttab()	Find out if tab expansion is enabled.  * tty_setsofttab(on)	Turn on/off soft tab expansion.  * tty_islitecho()	Find out if typed control chars are echoed literally  * tty_setlitecho()	Turn on/off literal echo of control chars  * tty_tspeed(val)	Set transmit speed to val.  * tty_rspeed(val)	Set receive speed to val.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|convex
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|linestate
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|tty_linemode
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|convex
ifndef|#
directive|ifndef
name|USE_TERMIO
return|return
operator|(
name|termbuf
operator|.
name|state
operator|&
name|TS_EXTPROC
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|termbuf
operator|.
name|c_lflag
operator|&
name|EXTPROC
operator|)
return|;
endif|#
directive|endif
else|#
directive|else
return|return
operator|(
name|linestate
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|tty_setlinemode
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TIOCEXT
ifndef|#
directive|ifndef
name|convex
name|set_termbuf
argument_list|()
expr_stmt|;
else|#
directive|else
name|linestate
operator|=
name|on
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCEXT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|convex
name|init_termbuf
argument_list|()
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* !TIOCEXT */
ifdef|#
directive|ifdef
name|EXTPROC
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|c_lflag
operator||=
name|EXTPROC
expr_stmt|;
else|else
name|termbuf
operator|.
name|c_lflag
operator|&=
operator|~
name|EXTPROC
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* TIOCEXT */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LINEMODE */
end_comment

begin_function
name|int
name|tty_isecho
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
return|return
operator|(
name|termbuf
operator|.
name|sg
operator|.
name|sg_flags
operator|&
name|ECHO
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|termbuf
operator|.
name|c_lflag
operator|&
name|ECHO
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|tty_flowmode
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
return|return
operator|(
operator|(
operator|(
name|termbuf
operator|.
name|tc
operator|.
name|t_startc
operator|)
operator|>
literal|0
operator|&&
operator|(
name|termbuf
operator|.
name|tc
operator|.
name|t_stopc
operator|)
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|(
name|termbuf
operator|.
name|c_iflag
operator|&
name|IXON
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|tty_restartany
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
ifdef|#
directive|ifdef
name|DECCTQ
return|return
operator|(
operator|(
name|termbuf
operator|.
name|lflags
operator|&
name|DECCTQ
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
else|#
directive|else
return|return
operator|(
operator|(
name|termbuf
operator|.
name|c_iflag
operator|&
name|IXANY
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|tty_setecho
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|sg
operator|.
name|sg_flags
operator||=
name|ECHO
operator||
name|CRMOD
expr_stmt|;
else|else
name|termbuf
operator|.
name|sg
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|CRMOD
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|c_lflag
operator||=
name|ECHO
expr_stmt|;
else|else
name|termbuf
operator|.
name|c_lflag
operator|&=
operator|~
name|ECHO
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|tty_israw
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
return|return
operator|(
name|termbuf
operator|.
name|sg
operator|.
name|sg_flags
operator|&
name|RAW
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|!
operator|(
name|termbuf
operator|.
name|c_lflag
operator|&
name|ICANON
operator|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
operator|&&
name|defined
argument_list|(
name|NO_LOGIN_F
argument_list|)
operator|&&
name|defined
argument_list|(
name|LOGIN_R
argument_list|)
end_if

begin_function
name|int
name|tty_setraw
parameter_list|(
name|on
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|sg
operator|.
name|sg_flags
operator||=
name|RAW
expr_stmt|;
else|else
name|termbuf
operator|.
name|sg
operator|.
name|sg_flags
operator|&=
operator|~
name|RAW
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|c_lflag
operator|&=
operator|~
name|ICANON
expr_stmt|;
else|else
name|termbuf
operator|.
name|c_lflag
operator||=
name|ICANON
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|tty_binaryin
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|lflags
operator||=
name|LPASS8
expr_stmt|;
else|else
name|termbuf
operator|.
name|lflags
operator|&=
operator|~
name|LPASS8
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|on
condition|)
block|{
name|termbuf
operator|.
name|c_iflag
operator|&=
operator|~
name|ISTRIP
expr_stmt|;
block|}
else|else
block|{
name|termbuf
operator|.
name|c_iflag
operator||=
name|ISTRIP
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|tty_binaryout
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|lflags
operator||=
name|LLITOUT
expr_stmt|;
else|else
name|termbuf
operator|.
name|lflags
operator|&=
operator|~
name|LLITOUT
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|on
condition|)
block|{
name|termbuf
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARENB
operator|)
expr_stmt|;
name|termbuf
operator|.
name|c_cflag
operator||=
name|CS8
expr_stmt|;
name|termbuf
operator|.
name|c_oflag
operator|&=
operator|~
name|OPOST
expr_stmt|;
block|}
else|else
block|{
name|termbuf
operator|.
name|c_cflag
operator|&=
operator|~
name|CSIZE
expr_stmt|;
name|termbuf
operator|.
name|c_cflag
operator||=
name|CS7
operator||
name|PARENB
expr_stmt|;
name|termbuf
operator|.
name|c_oflag
operator||=
name|OPOST
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|tty_isbinaryin
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
return|return
operator|(
name|termbuf
operator|.
name|lflags
operator|&
name|LPASS8
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|!
operator|(
name|termbuf
operator|.
name|c_iflag
operator|&
name|ISTRIP
operator|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|tty_isbinaryout
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
return|return
operator|(
name|termbuf
operator|.
name|lflags
operator|&
name|LLITOUT
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|!
operator|(
name|termbuf
operator|.
name|c_oflag
operator|&
name|OPOST
operator|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LINEMODE
end_ifdef

begin_function
name|int
name|tty_isediting
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
return|return
operator|(
operator|!
operator|(
name|termbuf
operator|.
name|sg
operator|.
name|sg_flags
operator|&
operator|(
name|CBREAK
operator||
name|RAW
operator|)
operator|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|termbuf
operator|.
name|c_lflag
operator|&
name|ICANON
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|tty_istrapsig
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
return|return
operator|(
operator|!
operator|(
name|termbuf
operator|.
name|sg
operator|.
name|sg_flags
operator|&
name|RAW
operator|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|termbuf
operator|.
name|c_lflag
operator|&
name|ISIG
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|tty_setedit
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|sg
operator|.
name|sg_flags
operator|&=
operator|~
name|CBREAK
expr_stmt|;
else|else
name|termbuf
operator|.
name|sg
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|c_lflag
operator||=
name|ICANON
expr_stmt|;
else|else
name|termbuf
operator|.
name|c_lflag
operator|&=
operator|~
name|ICANON
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|tty_setsig
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
if|if
condition|(
name|on
condition|)
empty_stmt|;
else|#
directive|else
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|c_lflag
operator||=
name|ISIG
expr_stmt|;
else|else
name|termbuf
operator|.
name|c_lflag
operator|&=
operator|~
name|ISIG
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LINEMODE */
end_comment

begin_function
name|int
name|tty_issofttab
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
return|return
operator|(
name|termbuf
operator|.
name|sg
operator|.
name|sg_flags
operator|&
name|XTABS
operator|)
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|OXTABS
return|return
operator|(
name|termbuf
operator|.
name|c_oflag
operator|&
name|OXTABS
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TABDLY
return|return
operator|(
operator|(
name|termbuf
operator|.
name|c_oflag
operator|&
name|TABDLY
operator|)
operator|==
name|TAB3
operator|)
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|tty_setsofttab
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|sg
operator|.
name|sg_flags
operator||=
name|XTABS
expr_stmt|;
else|else
name|termbuf
operator|.
name|sg
operator|.
name|sg_flags
operator|&=
operator|~
name|XTABS
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|on
condition|)
block|{
ifdef|#
directive|ifdef
name|OXTABS
name|termbuf
operator|.
name|c_oflag
operator||=
name|OXTABS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TABDLY
name|termbuf
operator|.
name|c_oflag
operator|&=
operator|~
name|TABDLY
expr_stmt|;
name|termbuf
operator|.
name|c_oflag
operator||=
name|TAB3
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|OXTABS
name|termbuf
operator|.
name|c_oflag
operator|&=
operator|~
name|OXTABS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TABDLY
name|termbuf
operator|.
name|c_oflag
operator|&=
operator|~
name|TABDLY
expr_stmt|;
name|termbuf
operator|.
name|c_oflag
operator||=
name|TAB0
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|tty_islitecho
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
return|return
operator|(
operator|!
operator|(
name|termbuf
operator|.
name|lflags
operator|&
name|LCTLECH
operator|)
operator|)
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ECHOCTL
return|return
operator|(
operator|!
operator|(
name|termbuf
operator|.
name|c_lflag
operator|&
name|ECHOCTL
operator|)
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TCTLECH
return|return
operator|(
operator|!
operator|(
name|termbuf
operator|.
name|c_lflag
operator|&
name|TCTLECH
operator|)
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ECHOCTL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TCTLECH
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* assumes ctl chars are echoed '^x' */
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|tty_setlitecho
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|lflags
operator|&=
operator|~
name|LCTLECH
expr_stmt|;
else|else
name|termbuf
operator|.
name|lflags
operator||=
name|LCTLECH
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ECHOCTL
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|c_lflag
operator|&=
operator|~
name|ECHOCTL
expr_stmt|;
else|else
name|termbuf
operator|.
name|c_lflag
operator||=
name|ECHOCTL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TCTLECH
if|if
condition|(
name|on
condition|)
name|termbuf
operator|.
name|c_lflag
operator|&=
operator|~
name|TCTLECH
expr_stmt|;
else|else
name|termbuf
operator|.
name|c_lflag
operator||=
name|TCTLECH
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|tty_iscrnl
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|USE_TERMIO
return|return
operator|(
name|termbuf
operator|.
name|sg
operator|.
name|sg_flags
operator|&
name|CRMOD
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|termbuf
operator|.
name|c_iflag
operator|&
name|ICRNL
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Try to guess whether speeds are "encoded" (4.2BSD) or just numeric (4.4BSD).  */
end_comment

begin_if
if|#
directive|if
name|B4800
operator|!=
literal|4800
end_if

begin_define
define|#
directive|define
name|DECODE_BAUD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DECODE_BAUD
end_ifdef

begin_comment
comment|/*  * A table of available terminal speeds  */
end_comment

begin_struct
struct|struct
name|termspeeds
block|{
name|int
name|speed
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|termspeeds
index|[]
init|=
block|{
block|{
literal|0
block|,
name|B0
block|}
block|,
block|{
literal|50
block|,
name|B50
block|}
block|,
block|{
literal|75
block|,
name|B75
block|}
block|,
block|{
literal|110
block|,
name|B110
block|}
block|,
block|{
literal|134
block|,
name|B134
block|}
block|,
block|{
literal|150
block|,
name|B150
block|}
block|,
block|{
literal|200
block|,
name|B200
block|}
block|,
block|{
literal|300
block|,
name|B300
block|}
block|,
block|{
literal|600
block|,
name|B600
block|}
block|,
block|{
literal|1200
block|,
name|B1200
block|}
block|,
block|{
literal|1800
block|,
name|B1800
block|}
block|,
block|{
literal|2400
block|,
name|B2400
block|}
block|,
block|{
literal|4800
block|,
name|B4800
block|}
block|,
ifdef|#
directive|ifdef
name|B7200
block|{
literal|7200
block|,
name|B7200
block|}
block|,
endif|#
directive|endif
block|{
literal|9600
block|,
name|B9600
block|}
block|,
ifdef|#
directive|ifdef
name|B14400
block|{
literal|14400
block|,
name|B14400
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B19200
block|{
literal|19200
block|,
name|B19200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B28800
block|{
literal|28800
block|,
name|B28800
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B38400
block|{
literal|38400
block|,
name|B38400
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B57600
block|{
literal|57600
block|,
name|B57600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B115200
block|{
literal|115200
block|,
name|B115200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B230400
block|{
literal|230400
block|,
name|B230400
block|}
block|,
endif|#
directive|endif
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DECODE_BAUD */
end_comment

begin_function
name|void
name|tty_tspeed
parameter_list|(
name|val
parameter_list|)
name|int
name|val
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DECODE_BAUD
specifier|register
name|struct
name|termspeeds
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|termspeeds
init|;
operator|(
name|tp
operator|->
name|speed
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|val
operator|>
name|tp
operator|->
name|speed
operator|)
condition|;
name|tp
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|tp
operator|->
name|speed
operator|==
operator|-
literal|1
condition|)
comment|/* back up to last valid value */
operator|--
name|tp
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|termbuf
argument_list|,
name|tp
operator|->
name|value
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* DECODE_BAUD */
name|cfsetospeed
argument_list|(
operator|&
name|termbuf
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DECODE_BAUD */
block|}
end_function

begin_function
name|void
name|tty_rspeed
parameter_list|(
name|val
parameter_list|)
name|int
name|val
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DECODE_BAUD
specifier|register
name|struct
name|termspeeds
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|termspeeds
init|;
operator|(
name|tp
operator|->
name|speed
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|val
operator|>
name|tp
operator|->
name|speed
operator|)
condition|;
name|tp
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|tp
operator|->
name|speed
operator|==
operator|-
literal|1
condition|)
comment|/* back up to last valid value */
operator|--
name|tp
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|termbuf
argument_list|,
name|tp
operator|->
name|value
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* DECODE_BAUD */
name|cfsetispeed
argument_list|(
operator|&
name|termbuf
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DECODE_BAUD */
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CRAY2
argument_list|)
operator|&&
name|defined
argument_list|(
name|UNICOS5
argument_list|)
end_if

begin_function
name|int
name|tty_isnewmap
parameter_list|()
block|{
return|return
operator|(
operator|(
name|termbuf
operator|.
name|c_oflag
operator|&
name|OPOST
operator|)
operator|&&
operator|(
name|termbuf
operator|.
name|c_oflag
operator|&
name|ONLCR
operator|)
operator|&&
operator|!
operator|(
name|termbuf
operator|.
name|c_oflag
operator|&
name|ONLRET
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PARENT_DOES_UTMP
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|NEWINIT
end_ifndef

begin_decl_stmt
specifier|extern
name|struct
name|utmp
name|wtmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|wtmpf
index|[]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* NEWINIT */
end_comment

begin_decl_stmt
name|int
name|gotalarm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|nologinproc
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|gotalarm
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEWINIT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PARENT_DOES_UTMP */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NEWINIT
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|PARENT_DOES_UTMP
end_ifdef

begin_decl_stmt
specifier|extern
name|void
name|utmp_sig_init
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|utmp_sig_reset
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|utmp_sig_wait
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|utmp_sig_notify
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PARENT_DOES_UTMP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * getptyslave()  *  * Open the slave side of the pty, and do any initialization  * that is necessary.  */
end_comment

begin_function
name|void
name|getptyslave
parameter_list|()
block|{
specifier|register
name|int
name|t
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|erase
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CRAY
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|NEWINIT
argument_list|)
ifdef|#
directive|ifdef
name|LINEMODE
name|int
name|waslm
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|struct
name|winsize
name|ws
decl_stmt|;
specifier|extern
name|int
name|def_row
decl_stmt|,
name|def_col
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|int
name|def_tspeed
decl_stmt|,
name|def_rspeed
decl_stmt|;
comment|/* 	 * Opening the slave side may cause initilization of the 	 * kernel tty structure.  We need remember the state of 	 * 	if linemode was turned on 	 *	terminal window size 	 *	terminal speed 	 *	erase character 	 * so that we can re-set them if we need to. 	 */
ifdef|#
directive|ifdef
name|LINEMODE
name|waslm
operator|=
name|tty_linemode
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|erase
operator|=
name|termbuf
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
comment|/* 	 * Make sure that we don't have a controlling tty, and 	 * that we are the session (process group) leader. 	 */
ifdef|#
directive|ifdef
name|TIOCNOTTY
name|t
operator|=
name|open
argument_list|(
name|_PATH_TTY
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|t
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PARENT_DOES_UTMP
comment|/* 	 * Wait for our parent to get the utmp stuff to get done. 	 */
name|utmp_sig_wait
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|t
operator|=
name|cleanopen
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|fatalperror
argument_list|(
name|net
argument_list|,
name|line
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STREAMSPTY
ifdef|#
directive|ifdef
name|USE_TERMIO
name|ttyfd
operator|=
name|t
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|t
argument_list|,
name|I_PUSH
argument_list|,
literal|"ptem"
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
name|net
argument_list|,
literal|"I_PUSH ptem"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|t
argument_list|,
name|I_PUSH
argument_list|,
literal|"ldterm"
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
name|net
argument_list|,
literal|"I_PUSH ldterm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|t
argument_list|,
name|I_PUSH
argument_list|,
literal|"ttcompat"
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
name|net
argument_list|,
literal|"I_PUSH ttcompat"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pty
argument_list|,
name|I_PUSH
argument_list|,
literal|"pckt"
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
name|net
argument_list|,
literal|"I_PUSH pckt"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * set up the tty modes as we like them to be. 	 */
name|init_termbuf
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
if|if
condition|(
name|def_row
operator|||
name|def_col
condition|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ws
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ws
argument_list|)
argument_list|)
expr_stmt|;
name|ws
operator|.
name|ws_col
operator|=
name|def_col
expr_stmt|;
name|ws
operator|.
name|ws_row
operator|=
name|def_row
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|t
argument_list|,
name|TIOCSWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ws
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Settings for sgtty based systems 	 */
ifndef|#
directive|ifndef
name|USE_TERMIO
name|termbuf
operator|.
name|sg
operator|.
name|sg_flags
operator||=
name|CRMOD
operator||
name|ANYP
operator||
name|ECHO
operator||
name|XTABS
expr_stmt|;
endif|#
directive|endif
comment|/* USE_TERMIO */
comment|/* 	 * Settings for UNICOS (and HPUX) 	 */
if|#
directive|if
name|defined
argument_list|(
name|CRAY
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
name|termbuf
operator|.
name|c_oflag
operator|=
name|OPOST
operator||
name|ONLCR
operator||
name|TAB3
expr_stmt|;
name|termbuf
operator|.
name|c_iflag
operator|=
name|IGNPAR
operator||
name|ISTRIP
operator||
name|ICRNL
operator||
name|IXON
expr_stmt|;
name|termbuf
operator|.
name|c_lflag
operator|=
name|ISIG
operator||
name|ICANON
operator||
name|ECHO
operator||
name|ECHOE
operator||
name|ECHOK
expr_stmt|;
name|termbuf
operator|.
name|c_cflag
operator|=
name|EXTB
operator||
name|HUPCL
operator||
name|CS8
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Settings for all other termios/termio based 	 * systems, other than 4.4BSD.  In 4.4BSD the 	 * kernel does the initial terminal setup. 	 */
if|#
directive|if
name|defined
argument_list|(
name|USE_TERMIO
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|CRAY
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|)
operator|&&
operator|(
name|BSD
operator|<=
literal|43
operator|)
ifndef|#
directive|ifndef
name|OXTABS
define|#
directive|define
name|OXTABS
value|0
endif|#
directive|endif
name|termbuf
operator|.
name|c_lflag
operator||=
name|ECHO
expr_stmt|;
name|termbuf
operator|.
name|c_oflag
operator||=
name|ONLCR
operator||
name|OXTABS
expr_stmt|;
name|termbuf
operator|.
name|c_iflag
operator||=
name|ICRNL
expr_stmt|;
name|termbuf
operator|.
name|c_iflag
operator|&=
operator|~
name|IXOFF
expr_stmt|;
endif|#
directive|endif
comment|/* defined(USE_TERMIO)&& !defined(CRAY)&& (BSD<= 43) */
name|tty_rspeed
argument_list|(
operator|(
name|def_rspeed
operator|>
literal|0
operator|)
condition|?
name|def_rspeed
else|:
literal|9600
argument_list|)
expr_stmt|;
name|tty_tspeed
argument_list|(
operator|(
name|def_tspeed
operator|>
literal|0
operator|)
condition|?
name|def_tspeed
else|:
literal|9600
argument_list|)
expr_stmt|;
if|if
condition|(
name|erase
condition|)
name|termbuf
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|erase
expr_stmt|;
ifdef|#
directive|ifdef
name|LINEMODE
if|if
condition|(
name|waslm
condition|)
name|tty_setlinemode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LINEMODE */
comment|/* 	 * Set the tty modes, and make this our controlling tty. 	 */
name|set_termbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|login_tty
argument_list|(
name|t
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatalperror
argument_list|(
name|net
argument_list|,
literal|"login_tty"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(CRAY) || !defined(NEWINIT) */
if|if
condition|(
name|net
operator|>
literal|2
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|net
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
operator|&&
name|defined
argument_list|(
name|NO_LOGIN_F
argument_list|)
operator|&&
name|defined
argument_list|(
name|LOGIN_R
argument_list|)
comment|/* 	 * Leave the pty open so that we can write out the rlogin 	 * protocol for /bin/login, if the authentication works. 	 */
else|#
directive|else
if|if
condition|(
name|pty
operator|>
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|pty
argument_list|)
expr_stmt|;
name|pty
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CRAY
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|NEWINIT
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|O_NOCTTY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Open the specified slave side of the pty,  * making sure that we have a clean tty.  */
end_comment

begin_function
name|int
name|cleanopen
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
specifier|register
name|int
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|UNICOS7x
name|struct
name|secstat
name|secbuf
decl_stmt|;
endif|#
directive|endif
comment|/* UNICOS7x */
ifndef|#
directive|ifndef
name|STREAMSPTY
comment|/* 	 * Make sure that other people can't open the 	 * slave side of the connection. 	 */
operator|(
name|void
operator|)
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|line
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CRAY
argument_list|)
operator|&&
operator|(
name|BSD
operator|>
literal|43
operator|)
operator|(
name|void
operator|)
name|revoke
argument_list|(
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UNICOS7x
if|if
condition|(
name|secflag
condition|)
block|{
if|if
condition|(
name|secstat
argument_list|(
name|line
argument_list|,
operator|&
name|secbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|setulvl
argument_list|(
name|secbuf
operator|.
name|st_slevel
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|setucmp
argument_list|(
name|secbuf
operator|.
name|st_compart
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* UNICOS7x */
name|t
operator|=
name|open
argument_list|(
name|line
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNICOS7x
if|if
condition|(
name|secflag
condition|)
block|{
if|if
condition|(
name|setulvl
argument_list|(
name|sysv
operator|.
name|sy_minlvl
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|setucmp
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* UNICOS7x */
if|if
condition|(
name|t
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Hangup anybody else using this ttyp, then reopen it for 	 * ourselves. 	 */
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|CRAY
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|)
operator|&&
operator|(
name|BSD
operator|<=
literal|43
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|STREAMSPTY
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|vhangup
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|t
operator|=
name|open
argument_list|(
name|line
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|CRAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|TCVHUP
argument_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|t
argument_list|,
name|TCVHUP
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNICOS7x
if|if
condition|(
name|secflag
condition|)
block|{
if|if
condition|(
name|secstat
argument_list|(
name|line
argument_list|,
operator|&
name|secbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|setulvl
argument_list|(
name|secbuf
operator|.
name|st_slevel
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|setucmp
argument_list|(
name|secbuf
operator|.
name|st_compart
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* UNICOS7x */
name|i
operator|=
name|open
argument_list|(
name|line
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNICOS7x
if|if
condition|(
name|secflag
condition|)
block|{
if|if
condition|(
name|setulvl
argument_list|(
name|sysv
operator|.
name|sy_minlvl
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|setucmp
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* UNICOS7x */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|i
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(CRAY)&& defined(TCVHUP) */
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(CRAY) || !defined(NEWINIT) */
end_comment

begin_if
if|#
directive|if
name|BSD
operator|<=
literal|43
end_if

begin_function
name|int
name|login_tty
parameter_list|(
name|t
parameter_list|)
name|int
name|t
decl_stmt|;
block|{
if|if
condition|(
name|setsid
argument_list|()
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|ultrix
comment|/* 		 * The setsid() may have failed because we 		 * already have a pgrp == pid.  Zero out 		 * our pgrp and try again... 		 */
if|if
condition|(
operator|(
name|setpgrp
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|setsid
argument_list|()
operator|<
literal|0
operator|)
condition|)
endif|#
directive|endif
name|fatalperror
argument_list|(
name|net
argument_list|,
literal|"setsid()"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TIOCSCTTY
if|if
condition|(
name|ioctl
argument_list|(
name|t
argument_list|,
name|TIOCSCTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|fatalperror
argument_list|(
name|net
argument_list|,
literal|"ioctl(sctty)"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CRAY
argument_list|)
comment|/* 	 * Close the hard fd to /dev/ttypXXX, and re-open through 	 * the indirect /dev/tty interface. 	 */
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|fatalperror
argument_list|(
name|net
argument_list|,
literal|"open(/dev/tty)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* 	 * We get our controlling tty assigned as a side-effect 	 * of opening up a tty device.  But on BSD based systems, 	 * this only happens if our process group is zero.  The 	 * setsid() call above may have set our pgrp, so clear 	 * it out before opening the tty... 	 */
ifndef|#
directive|ifndef
name|SOLARIS
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|setpgrp
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|(
name|open
argument_list|(
name|line
argument_list|,
name|O_RDWR
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|1
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|2
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|2
condition|)
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD<= 43 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEWINIT
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|gen_id
init|=
literal|"fe"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * startslave(host)  *  * Given a hostname, do whatever  * is necessary to startup the login process on the slave side of the pty.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|startslave
parameter_list|(
name|host
parameter_list|,
name|autologin
parameter_list|,
name|autoname
parameter_list|)
name|char
modifier|*
name|host
decl_stmt|;
name|int
name|autologin
decl_stmt|;
name|char
modifier|*
name|autoname
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|NEWINIT
specifier|extern
name|char
modifier|*
name|ptyip
decl_stmt|;
name|struct
name|init_request
name|request
decl_stmt|;
name|void
name|nologinproc
parameter_list|()
function_decl|;
specifier|register
name|int
name|n
decl_stmt|;
endif|#
directive|endif
comment|/* NEWINIT */
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
if|if
condition|(
operator|!
name|autoname
operator|||
operator|!
name|autoname
index|[
literal|0
index|]
condition|)
name|autologin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|autologin
operator|<
name|auth_level
condition|)
block|{
name|fatal
argument_list|(
name|net
argument_list|,
literal|"Authorization failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NEWINIT
ifdef|#
directive|ifdef
name|PARENT_DOES_UTMP
name|utmp_sig_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PARENT_DOES_UTMP */
if|if
condition|(
operator|(
name|i
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|fatalperror
argument_list|(
name|net
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
ifdef|#
directive|ifdef
name|PARENT_DOES_UTMP
comment|/* 		 * Cray parent will create utmp entry for child and send 		 * signal to child to tell when done.  Child waits for signal 		 * before doing anything important. 		 */
specifier|register
name|int
name|pid
init|=
name|i
decl_stmt|;
name|void
name|sigjob
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
name|setpgrp
argument_list|()
expr_stmt|;
name|utmp_sig_reset
argument_list|()
expr_stmt|;
comment|/* reset handler to default */
comment|/* 		 * Create utmp entry for child 		 */
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|wtmp
operator|.
name|ut_time
argument_list|)
expr_stmt|;
name|wtmp
operator|.
name|ut_type
operator|=
name|LOGIN_PROCESS
expr_stmt|;
name|wtmp
operator|.
name|ut_pid
operator|=
name|pid
expr_stmt|;
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_user
argument_list|,
literal|"LOGIN"
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_host
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_line
argument_list|,
name|line
operator|+
sizeof|sizeof
argument_list|(
literal|"/dev/"
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__hpux
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_id
argument_list|,
name|wtmp
operator|.
name|ut_line
operator|+
literal|3
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_id
argument_list|,
name|wtmp
operator|.
name|ut_line
operator|+
literal|7
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pututline
argument_list|(
operator|&
name|wtmp
argument_list|)
expr_stmt|;
name|endutent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|wtmpf
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|wtmp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CRAY
operator|(
name|void
operator|)
name|signal
argument_list|(
name|WJSIGNAL
argument_list|,
name|sigjob
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|utmp_sig_notify
argument_list|(
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PARENT_DOES_UTMP */
block|}
else|else
block|{
name|getptyslave
argument_list|(
name|autologin
argument_list|)
expr_stmt|;
name|start_login
argument_list|(
name|host
argument_list|,
name|autologin
argument_list|,
name|autoname
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
comment|/* NEWINIT */
comment|/* 	 * Init will start up login process if we ask nicely.  We only wait 	 * for it to start up and begin normal telnet operation. 	 */
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|INIT_FIFO
argument_list|,
name|O_WRONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|char
name|tbuf
index|[
literal|128
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"Can't open %s\n"
argument_list|,
name|INIT_FIFO
argument_list|)
expr_stmt|;
name|fatalperror
argument_list|(
name|net
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|request
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|.
name|magic
operator|=
name|INIT_MAGIC
expr_stmt|;
name|SCPYN
argument_list|(
name|request
operator|.
name|gen_id
argument_list|,
name|gen_id
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|request
operator|.
name|tty_id
argument_list|,
operator|&
name|line
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|request
operator|.
name|host
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|request
operator|.
name|term_type
argument_list|,
name|terminaltype
condition|?
name|terminaltype
else|:
literal|"network"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|UNICOS5
argument_list|)
name|request
operator|.
name|signal
operator|=
name|SIGCLD
expr_stmt|;
name|request
operator|.
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BFTPDAEMON
comment|/* 	 * Are we working as the bftp daemon? 	 */
if|if
condition|(
name|bftpd
condition|)
block|{
name|SCPYN
argument_list|(
name|request
operator|.
name|exec_name
argument_list|,
name|BFTPPATH
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* BFTPDAEMON */
if|if
condition|(
name|write
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|request
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|tbuf
index|[
literal|128
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"Can't write to %s\n"
argument_list|,
name|INIT_FIFO
argument_list|)
expr_stmt|;
name|fatalperror
argument_list|(
name|net
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|nologinproc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|char
name|tbuf
index|[
literal|128
index|]
decl_stmt|;
name|alarm
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|n
operator|=
name|read
argument_list|(
name|pty
argument_list|,
name|ptyip
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|3
operator|||
name|n
operator|>=
literal|0
operator|||
operator|!
name|gotalarm
condition|)
break|break;
name|gotalarm
operator|=
literal|0
expr_stmt|;
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"telnetd: waiting for /etc/init to start login process on %s\r\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|net
argument_list|,
name|tbuf
argument_list|,
name|strlen
argument_list|(
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
operator|&&
name|gotalarm
condition|)
name|fatal
argument_list|(
name|net
argument_list|,
literal|"/etc/init didn't start login process"
argument_list|)
expr_stmt|;
name|pcc
operator|+=
name|n
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
comment|/* NEWINIT */
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|envinit
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_env
parameter_list|()
block|{
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
name|envp
operator|=
name|envinit
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|envp
operator|=
name|getenv
argument_list|(
literal|"TZ"
argument_list|)
operator|)
condition|)
operator|*
name|envp
operator|++
operator|-=
literal|3
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CRAY
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
else|else
operator|*
name|envp
operator|++
operator|=
literal|"TZ=GMT0"
expr_stmt|;
endif|#
directive|endif
operator|*
name|envp
operator|=
literal|0
expr_stmt|;
name|environ
operator|=
name|envinit
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NEWINIT
end_ifndef

begin_comment
comment|/*  * start_login(host)  *  * Assuming that we are now running as a child processes, this  * function will turn us into the login process.  */
end_comment

begin_function
name|void
name|start_login
parameter_list|(
name|host
parameter_list|,
name|autologin
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|host
decl_stmt|;
name|int
name|autologin
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|addarg
argument_list|()
decl_stmt|,
modifier|*
name|user
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|UTMPX
specifier|register
name|int
name|pid
init|=
name|getpid
argument_list|()
decl_stmt|;
name|struct
name|utmpx
name|utmpx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SOLARIS
name|char
modifier|*
name|term
decl_stmt|;
name|char
name|termbuf
index|[
literal|64
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UTMPX
comment|/* 	 * Create utmp entry for child 	 */
name|memset
argument_list|(
operator|&
name|utmpx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|utmpx
argument_list|)
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|utmpx
operator|.
name|ut_user
argument_list|,
literal|".telnet"
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|utmpx
operator|.
name|ut_line
argument_list|,
name|line
operator|+
sizeof|sizeof
argument_list|(
literal|"/dev/"
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|utmpx
operator|.
name|ut_pid
operator|=
name|pid
expr_stmt|;
name|utmpx
operator|.
name|ut_id
index|[
literal|0
index|]
operator|=
literal|'t'
expr_stmt|;
name|utmpx
operator|.
name|ut_id
index|[
literal|1
index|]
operator|=
literal|'n'
expr_stmt|;
name|utmpx
operator|.
name|ut_id
index|[
literal|2
index|]
operator|=
name|SC_WILDC
expr_stmt|;
name|utmpx
operator|.
name|ut_id
index|[
literal|3
index|]
operator|=
name|SC_WILDC
expr_stmt|;
name|utmpx
operator|.
name|ut_type
operator|=
name|LOGIN_PROCESS
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|utmpx
operator|.
name|ut_tv
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|makeutx
argument_list|(
operator|&
name|utmpx
argument_list|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|net
argument_list|,
literal|"makeutx failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scrub_env
argument_list|()
expr_stmt|;
comment|/* 	 * -h : pass on name of host. 	 *		WARNING:  -h is accepted by login if and only if 	 *			getuid() == 0. 	 * -p : don't clobber the environment (so terminal type stays set). 	 * 	 * -f : force this login, he has already been authenticated 	 */
name|argv
operator|=
name|addarg
argument_list|(
literal|0
argument_list|,
literal|"login"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_LOGIN_H
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
operator|&&
name|defined
argument_list|(
name|NO_LOGIN_F
argument_list|)
operator|&&
name|defined
argument_list|(
name|LOGIN_R
argument_list|)
comment|/* 	 * Don't add the "-h host" option if we are going 	 * to be adding the "-r host" option down below... 	 */
if|if
condition|(
operator|(
name|auth_level
operator|<
literal|0
operator|)
operator|||
operator|(
name|autologin
operator|!=
name|AUTH_VALID
operator|)
condition|)
endif|#
directive|endif
block|{
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
literal|"-h"
argument_list|)
expr_stmt|;
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
name|host
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOLARIS
comment|/* 		 * SVR4 version of -h takes TERM= as second arg, or - 		 */
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|==
name|NULL
operator|||
name|term
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|term
operator|=
literal|"-"
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|termbuf
argument_list|,
literal|"TERM="
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|termbuf
argument_list|,
name|term
argument_list|,
sizeof|sizeof
argument_list|(
name|termbuf
argument_list|)
operator|-
literal|6
argument_list|)
expr_stmt|;
name|term
operator|=
name|termbuf
expr_stmt|;
block|}
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
name|term
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_LOGIN_P
argument_list|)
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
literal|"-p"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LINEMODE
comment|/* 	 * Set the environment variable "LINEMODE" to either 	 * "real" or "kludge" if we are operating in either 	 * real or kludge linemode. 	 */
if|if
condition|(
name|lmodetype
operator|==
name|REAL_LINEMODE
condition|)
name|setenv
argument_list|(
literal|"LINEMODE"
argument_list|,
literal|"real"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
elseif|else
if|if
condition|(
name|lmodetype
operator|==
name|KLUDGE_LINEMODE
operator|||
name|lmodetype
operator|==
name|KLUDGE_OK
condition|)
name|setenv
argument_list|(
literal|"LINEMODE"
argument_list|,
literal|"kludge"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BFTPDAEMON
comment|/* 	 * Are we working as the bftp daemon?  If so, then ask login 	 * to start bftp instead of shell. 	 */
if|if
condition|(
name|bftpd
condition|)
block|{
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
literal|"-e"
argument_list|)
expr_stmt|;
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
name|BFTPPATH
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SecurID
argument_list|)
comment|/* 	 * don't worry about the -f that might get sent. 	 * A -s is supposed to override it anyhow. 	 */
if|if
condition|(
name|require_SecurID
condition|)
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
literal|"-s"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
if|if
condition|(
name|auth_level
operator|>=
literal|0
operator|&&
name|autologin
operator|==
name|AUTH_VALID
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_LOGIN_F
argument_list|)
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
literal|"-f"
argument_list|)
expr_stmt|;
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
literal|"--"
argument_list|)
expr_stmt|;
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|LOGIN_R
argument_list|)
comment|/* 		 * We don't have support for "login -f", but we 		 * can fool /bin/login into thinking that we are 		 * rlogind, and allow us to log in without a 		 * password.  The rlogin protocol expects 		 *	local-user\0remote-user\0term/speed\0 		 */
if|if
condition|(
name|pty
operator|>
literal|2
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|speed
index|[
literal|128
index|]
decl_stmt|;
name|int
name|isecho
decl_stmt|,
name|israw
decl_stmt|,
name|xpty
decl_stmt|,
name|len
decl_stmt|;
specifier|extern
name|int
name|def_rspeed
decl_stmt|;
ifndef|#
directive|ifndef
name|LOGIN_HOST
comment|/* 			 * Tell login that we are coming from "localhost". 			 * If we passed in the real host name, then the 			 * user would have to allow .rhost access from 			 * every machine that they want authenticated 			 * access to work from, which sort of defeats 			 * the purpose of an authenticated login... 			 * So, we tell login that the session is coming 			 * from "localhost", and the user will only have 			 * to have "localhost" in their .rhost file. 			 */
define|#
directive|define
name|LOGIN_HOST
value|"localhost"
endif|#
directive|endif
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
literal|"-r"
argument_list|)
expr_stmt|;
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
name|LOGIN_HOST
argument_list|)
expr_stmt|;
name|xpty
operator|=
name|pty
expr_stmt|;
ifndef|#
directive|ifndef
name|STREAMSPTY
name|pty
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|ttyfd
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|init_termbuf
argument_list|()
expr_stmt|;
name|isecho
operator|=
name|tty_isecho
argument_list|()
expr_stmt|;
name|israw
operator|=
name|tty_israw
argument_list|()
expr_stmt|;
if|if
condition|(
name|isecho
operator|||
operator|!
name|israw
condition|)
block|{
name|tty_setecho
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Turn off echo */
name|tty_setraw
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Turn on raw */
name|set_termbuf
argument_list|()
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|write
argument_list|(
name|xpty
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|xpty
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|speed
argument_list|,
sizeof|sizeof
argument_list|(
name|speed
argument_list|)
argument_list|,
literal|"%s/%d"
argument_list|,
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
condition|?
name|cp
else|:
literal|""
argument_list|,
operator|(
name|def_rspeed
operator|>
literal|0
operator|)
condition|?
name|def_rspeed
else|:
literal|9600
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|speed
argument_list|)
operator|+
literal|1
expr_stmt|;
name|write
argument_list|(
name|xpty
argument_list|,
name|speed
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|isecho
operator|||
operator|!
name|israw
condition|)
block|{
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_setecho
argument_list|(
name|isecho
argument_list|)
expr_stmt|;
name|tty_setraw
argument_list|(
name|israw
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|israw
condition|)
block|{
comment|/* 					 * Write a newline to ensure 					 * that login will be able to 					 * read the line... 					 */
name|write
argument_list|(
name|xpty
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|pty
operator|=
name|xpty
expr_stmt|;
block|}
else|#
directive|else
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
literal|"--"
argument_list|)
expr_stmt|;
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|getenv
argument_list|(
literal|"USER"
argument_list|)
condition|)
block|{
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
literal|"--"
argument_list|)
expr_stmt|;
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
name|getenv
argument_list|(
literal|"USER"
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOGIN_ARGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|NO_LOGIN_P
argument_list|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
for|for
control|(
name|cpp
operator|=
name|environ
init|;
operator|*
name|cpp
condition|;
name|cpp
operator|++
control|)
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * Assume that login will set the USER variable 		 * correctly.  For SysV systems, this means that 		 * USER will no longer be set, just LOGNAME by 		 * login.  (The problem is that if the auto-login 		 * fails, and the user then specifies a different 		 * account name, he can get logged in with both 		 * LOGNAME and USER in his environment, but the 		 * USER value will be wrong. 		 */
name|unsetenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SOLARIS
else|else
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* no login name */
for|for
control|(
name|p
operator|=
name|environ
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|argv
operator|=
name|addarg
argument_list|(
name|argv
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SOLARIS */
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
operator|&&
name|defined
argument_list|(
name|NO_LOGIN_F
argument_list|)
operator|&&
name|defined
argument_list|(
name|LOGIN_R
argument_list|)
if|if
condition|(
name|pty
operator|>
literal|2
condition|)
name|close
argument_list|(
name|pty
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|closelog
argument_list|()
expr_stmt|;
if|if
condition|(
name|altlogin
operator|==
name|NULL
condition|)
block|{
name|altlogin
operator|=
name|_PATH_LOGIN
expr_stmt|;
block|}
name|execv
argument_list|(
name|altlogin
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m"
argument_list|,
name|altlogin
argument_list|)
expr_stmt|;
name|fatalperror
argument_list|(
name|net
argument_list|,
name|altlogin
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|addarg
parameter_list|(
name|argv
parameter_list|,
name|val
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|char
modifier|*
name|val
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * 10 entries, a leading length, and a null 		 */
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|argv
argument_list|)
operator|*
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|argv
operator|++
operator|=
operator|(
name|char
operator|*
operator|)
literal|10
expr_stmt|;
operator|*
name|argv
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
for|for
control|(
name|cpp
operator|=
name|argv
init|;
operator|*
name|cpp
condition|;
name|cpp
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|cpp
operator|==
operator|&
name|argv
index|[
operator|(
name|int
operator|)
name|argv
index|[
operator|-
literal|1
index|]
index|]
condition|)
block|{
operator|--
name|argv
expr_stmt|;
operator|*
name|argv
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|argv
argument_list|)
operator|+
literal|10
operator|)
expr_stmt|;
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|argv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|argv
argument_list|)
operator|*
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|argv
argument_list|)
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|argv
operator|++
expr_stmt|;
name|cpp
operator|=
operator|&
name|argv
index|[
operator|(
name|int
operator|)
name|argv
index|[
operator|-
literal|1
index|]
operator|-
literal|10
index|]
expr_stmt|;
block|}
operator|*
name|cpp
operator|++
operator|=
name|val
expr_stmt|;
operator|*
name|cpp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|argv
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEWINIT */
end_comment

begin_comment
comment|/*  * scrub_env()  *  * Remove a few things from the environment that  * don't need to be there.  */
end_comment

begin_function
name|void
name|scrub_env
parameter_list|()
block|{
specifier|register
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|,
modifier|*
modifier|*
name|cpp2
decl_stmt|;
for|for
control|(
name|cpp2
operator|=
name|cpp
operator|=
name|environ
init|;
operator|*
name|cpp
condition|;
name|cpp
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"LD_LIBRARY_PATH="
argument_list|,
literal|16
argument_list|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"LD_PRELOAD="
argument_list|,
literal|11
argument_list|)
operator|&&
else|#
directive|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"LD_"
argument_list|,
literal|3
argument_list|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"_RLD_"
argument_list|,
literal|5
argument_list|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"LIBPATH="
argument_list|,
literal|8
argument_list|)
operator|&&
endif|#
directive|endif
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"LOCALDOMAIN="
argument_list|,
literal|12
argument_list|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"RES_OPTIONS="
argument_list|,
literal|12
argument_list|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"TERMINFO="
argument_list|,
literal|9
argument_list|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"TERMINFO_DIRS="
argument_list|,
literal|14
argument_list|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"TERMPATH="
argument_list|,
literal|9
argument_list|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"TERMCAP=/"
argument_list|,
literal|9
argument_list|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"ENV="
argument_list|,
literal|4
argument_list|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"IFS="
argument_list|,
literal|4
argument_list|)
condition|)
operator|*
name|cpp2
operator|++
operator|=
operator|*
name|cpp
expr_stmt|;
block|}
operator|*
name|cpp2
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * cleanup()  *  * This is the routine to call when we are all through, to  * clean up anything that needs to be cleaned up.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|cleanup
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|PARENT_DOES_UTMP
if|#
directive|if
operator|(
name|BSD
operator|>
literal|43
operator|)
operator|||
name|defined
argument_list|(
name|convex
argument_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|line
operator|+
sizeof|sizeof
argument_list|(
literal|"/dev/"
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|logout
argument_list|(
name|p
argument_list|)
condition|)
name|logwtmp
argument_list|(
name|p
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'p'
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|shutdown
argument_list|(
name|net
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|void
name|rmut
parameter_list|()
function_decl|;
name|rmut
argument_list|()
expr_stmt|;
name|vhangup
argument_list|()
expr_stmt|;
comment|/* XXX */
operator|(
name|void
operator|)
name|shutdown
argument_list|(
name|net
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* PARENT_DOES_UTMP */
ifdef|#
directive|ifdef
name|NEWINIT
operator|(
name|void
operator|)
name|shutdown
argument_list|(
name|net
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NEWINIT */
ifdef|#
directive|ifdef
name|CRAY
specifier|static
name|int
name|incleanup
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|int
name|child_status
decl_stmt|;
comment|/* status of child process as returned by waitpid */
name|int
name|flags
init|=
name|WNOHANG
operator||
name|WUNTRACED
decl_stmt|;
comment|/* 	 * 1: Pick up the zombie, if we are being called 	 *    as the signal handler. 	 * 2: If we are a nested cleanup(), return. 	 * 3: Try to clean up TMPDIR. 	 * 4: Fill in utmp with shutdown of process. 	 * 5: Close down the network and pty connections. 	 * 6: Finish up the TMPDIR cleanup, if needed. 	 */
if|if
condition|(
name|sig
operator|==
name|SIGCHLD
condition|)
block|{
while|while
condition|(
name|waitpid
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|child_status
argument_list|,
name|flags
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* VOID */
comment|/* Check if the child process was stopped 		 * rather than exited.  We want cleanup only if 		 * the child has died. 		 */
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|child_status
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|t
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|incleanup
condition|)
block|{
name|sigsetmask
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|incleanup
operator|=
literal|1
expr_stmt|;
name|sigsetmask
argument_list|(
name|t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNICOS7x
if|if
condition|(
name|secflag
condition|)
block|{
comment|/* 		 *	We need to set ourselves back to a null 		 *	label to clean up. 		 */
name|setulvl
argument_list|(
name|sysv
operator|.
name|sy_minlvl
argument_list|)
expr_stmt|;
name|setucmp
argument_list|(
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* UNICOS7x */
name|t
operator|=
name|cleantmp
argument_list|(
operator|&
name|wtmp
argument_list|)
expr_stmt|;
name|setutent
argument_list|()
expr_stmt|;
comment|/* just to make sure */
endif|#
directive|endif
comment|/* CRAY */
name|rmut
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pty
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|shutdown
argument_list|(
name|net
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CRAY
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|cleantmp
argument_list|(
operator|&
name|wtmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CRAY */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NEWINT */
endif|#
directive|endif
comment|/* PARENT_DOES_UTMP */
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PARENT_DOES_UTMP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NEWINIT
argument_list|)
end_if

begin_comment
comment|/*  * _utmp_sig_rcv  * utmp_sig_init  * utmp_sig_wait  *	These three functions are used to coordinate the handling of  *	the utmp file between the server and the soon-to-be-login shell.  *	The server actually creates the utmp structure, the child calls  *	utmp_sig_wait(), until the server calls utmp_sig_notify() and  *	signals the future-login shell to proceed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|caught
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NZ when signal intercepted */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* address of previous handler */
end_comment

begin_function
name|void
name|_utmp_sig_rcv
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|caught
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|utmp_sig_init
parameter_list|()
block|{
comment|/* 	 * register signal handler for UTMP creation 	 */
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|func
operator|=
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|_utmp_sig_rcv
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatalperror
argument_list|(
name|net
argument_list|,
literal|"telnetd/signal"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|utmp_sig_reset
parameter_list|()
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* reset handler to default */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_define
define|#
directive|define
name|sigoff
parameter_list|()
end_define

begin_comment
comment|/* do nothing */
end_comment

begin_define
define|#
directive|define
name|sigon
parameter_list|()
end_define

begin_comment
comment|/* do nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|utmp_sig_wait
parameter_list|()
block|{
comment|/* 	 * Wait for parent to write our utmp entry. 	 */
name|sigoff
argument_list|()
expr_stmt|;
while|while
condition|(
name|caught
operator|==
literal|0
condition|)
block|{
name|pause
argument_list|()
expr_stmt|;
comment|/* wait until we get a signal (sigon) */
name|sigoff
argument_list|()
expr_stmt|;
comment|/* turn off signals while we check caught */
block|}
name|sigon
argument_list|()
expr_stmt|;
comment|/* turn on signals again */
block|}
end_function

begin_function
name|void
name|utmp_sig_notify
parameter_list|(
name|pid
parameter_list|)
block|{
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGUSR1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CRAY
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|gotsigjob
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|sigjob
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
specifier|register
name|int
name|jid
decl_stmt|;
specifier|register
name|struct
name|jobtemp
modifier|*
name|jp
decl_stmt|;
while|while
condition|(
operator|(
name|jid
operator|=
name|waitjob
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|jid
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|gotsigjob
operator|++
expr_stmt|;
name|jobend
argument_list|(
name|jid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	jid_getutid:  *		called by jobend() before calling cleantmp()  *		to find the correct $TMPDIR to cleanup.  */
end_comment

begin_function
name|struct
name|utmp
modifier|*
name|jid_getutid
parameter_list|(
name|jid
parameter_list|)
name|int
name|jid
decl_stmt|;
block|{
name|struct
name|utmp
modifier|*
name|cur
init|=
name|NULL
decl_stmt|;
name|setutent
argument_list|()
expr_stmt|;
comment|/* just to make sure */
while|while
condition|(
name|cur
operator|=
name|getutent
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|cur
operator|->
name|ut_type
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|jid
operator|==
name|cur
operator|->
name|ut_jid
operator|)
condition|)
block|{
return|return
operator|(
name|cur
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clean up the TMPDIR that login created.  * The first time this is called we pick up the info  * from the utmp.  If the job has already gone away,  * then we'll clean up and be done.  If not, then  * when this is called the second time it will wait  * for the signal that the job is done.  */
end_comment

begin_function
name|int
name|cleantmp
parameter_list|(
name|wtp
parameter_list|)
specifier|register
name|struct
name|utmp
modifier|*
name|wtp
decl_stmt|;
block|{
name|struct
name|utmp
modifier|*
name|utp
decl_stmt|;
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|mask
decl_stmt|,
name|omask
decl_stmt|,
name|ret
decl_stmt|;
specifier|extern
name|struct
name|utmp
modifier|*
name|getutid
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|utmp
operator|*
name|_Id
operator|)
argument_list|)
decl_stmt|;
name|mask
operator|=
name|sigmask
argument_list|(
name|WJSIGNAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|0
condition|)
block|{
name|omask
operator|=
name|sigblock
argument_list|(
name|mask
argument_list|)
expr_stmt|;
while|while
condition|(
name|gotsigjob
operator|==
literal|0
condition|)
name|sigpause
argument_list|(
name|omask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|first
operator|=
literal|0
expr_stmt|;
name|setutent
argument_list|()
expr_stmt|;
comment|/* just to make sure */
name|utp
operator|=
name|getutid
argument_list|(
name|wtp
argument_list|)
expr_stmt|;
if|if
condition|(
name|utp
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't get /etc/utmp entry to clean TMPDIR"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Nothing to clean up if the user shell was never started. 	 */
if|if
condition|(
name|utp
operator|->
name|ut_type
operator|!=
name|USER_PROCESS
operator|||
name|utp
operator|->
name|ut_jid
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Block the WJSIGNAL while we are in jobend(). 	 */
name|omask
operator|=
name|sigblock
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|ret
operator|=
name|jobend
argument_list|(
name|utp
operator|->
name|ut_jid
argument_list|,
name|utp
operator|->
name|ut_tpath
argument_list|,
name|utp
operator|->
name|ut_user
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|jobend
parameter_list|(
name|jid
parameter_list|,
name|path
parameter_list|,
name|user
parameter_list|)
specifier|register
name|int
name|jid
decl_stmt|;
specifier|register
name|char
modifier|*
name|path
decl_stmt|;
specifier|register
name|char
modifier|*
name|user
decl_stmt|;
block|{
specifier|static
name|int
name|saved_jid
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|pty_saved_jid
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|saved_path
index|[
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_tpath
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|char
name|saved_user
index|[
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_user
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * this little piece of code comes into play 	 * only when ptyreconnect is used to reconnect 	 * to an previous session. 	 * 	 * this is the only time when the 	 * "saved_jid != jid" code is executed. 	 */
if|if
condition|(
name|saved_jid
operator|&&
name|saved_jid
operator|!=
name|jid
condition|)
block|{
if|if
condition|(
operator|!
name|path
condition|)
block|{
comment|/* called from signal handler */
name|pty_saved_jid
operator|=
name|jid
expr_stmt|;
block|}
else|else
block|{
name|pty_saved_jid
operator|=
name|saved_jid
expr_stmt|;
block|}
block|}
if|if
condition|(
name|path
condition|)
block|{
name|strncpy
argument_list|(
name|saved_path
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_tpath
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|saved_user
argument_list|,
name|user
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
operator|.
name|ut_user
argument_list|)
argument_list|)
expr_stmt|;
name|saved_path
index|[
sizeof|sizeof
argument_list|(
name|saved_path
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|saved_user
index|[
sizeof|sizeof
argument_list|(
name|saved_user
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|saved_jid
operator|==
literal|0
condition|)
block|{
name|saved_jid
operator|=
name|jid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* if the jid has changed, get the correct entry from the utmp file */
if|if
condition|(
name|saved_jid
operator|!=
name|jid
condition|)
block|{
name|struct
name|utmp
modifier|*
name|utp
init|=
name|NULL
decl_stmt|;
name|struct
name|utmp
modifier|*
name|jid_getutid
parameter_list|()
function_decl|;
name|utp
operator|=
name|jid_getutid
argument_list|(
name|pty_saved_jid
argument_list|)
expr_stmt|;
if|if
condition|(
name|utp
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't get /etc/utmp entry to clean TMPDIR"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cleantmpdir
argument_list|(
name|jid
argument_list|,
name|utp
operator|->
name|ut_tpath
argument_list|,
name|utp
operator|->
name|ut_user
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cleantmpdir
argument_list|(
name|jid
argument_list|,
name|saved_path
argument_list|,
name|saved_user
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fork a child process to clean up the TMPDIR  */
end_comment

begin_expr_stmt
name|cleantmpdir
argument_list|(
name|jid
argument_list|,
name|tpath
argument_list|,
name|user
argument_list|)
specifier|register
name|int
name|jid
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|tpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|user
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"TMPDIR cleanup(%s): fork() failed: %m"
argument_list|,
name|tpath
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|execl
argument_list|(
name|CLEANTMPCMD
argument_list|,
name|CLEANTMPCMD
argument_list|,
name|user
argument_list|,
name|tpath
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"TMPDIR cleanup(%s): execl(%s) failed: %m"
argument_list|,
name|tpath
argument_list|,
name|CLEANTMPCMD
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
default|default:
comment|/* 		 * Forget about child.  We will exit, and 		 * /etc/init will pick it up. 		 */
break|break;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRAY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(PARENT_DOES_UTMP)&& !defined(NEWINIT) */
end_comment

begin_comment
comment|/*  * rmut()  *  * This is the function called by cleanup() to  * remove the utmp entry for this person.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UTMPX
end_ifdef

begin_function
name|void
name|rmut
parameter_list|()
block|{
specifier|register
name|f
expr_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|struct
name|utmp
modifier|*
name|u
decl_stmt|,
modifier|*
name|utmp
decl_stmt|;
name|int
name|nutmp
decl_stmt|;
name|struct
name|stat
name|statbf
decl_stmt|;
name|struct
name|utmpx
modifier|*
name|utxp
decl_stmt|,
name|utmpx
decl_stmt|;
comment|/* 	 * This updates the utmpx and utmp entries and make a wtmp/x entry 	 */
name|SCPYN
argument_list|(
name|utmpx
operator|.
name|ut_line
argument_list|,
name|line
operator|+
sizeof|sizeof
argument_list|(
literal|"/dev/"
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|utxp
operator|=
name|getutxline
argument_list|(
operator|&
name|utmpx
argument_list|)
expr_stmt|;
if|if
condition|(
name|utxp
condition|)
block|{
name|utxp
operator|->
name|ut_type
operator|=
name|DEAD_PROCESS
expr_stmt|;
name|utxp
operator|->
name|ut_exit
operator|.
name|e_termination
operator|=
literal|0
expr_stmt|;
name|utxp
operator|->
name|ut_exit
operator|.
name|e_exit
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|utmpx
operator|.
name|ut_tv
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|utmpx
operator|.
name|ut_tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|modutx
argument_list|(
name|utxp
argument_list|)
expr_stmt|;
block|}
name|endutxent
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of rmut */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|UTMPX
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|CRAY
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|)
operator|&&
name|BSD
operator|<=
literal|43
end_if

begin_function
name|void
name|rmut
parameter_list|()
block|{
specifier|register
name|f
expr_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|struct
name|utmp
modifier|*
name|u
decl_stmt|,
modifier|*
name|utmp
decl_stmt|;
name|int
name|nutmp
decl_stmt|;
name|struct
name|stat
name|statbf
decl_stmt|;
name|f
operator|=
name|open
argument_list|(
name|utmpf
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fstat
argument_list|(
name|f
argument_list|,
operator|&
name|statbf
argument_list|)
expr_stmt|;
name|utmp
operator|=
operator|(
expr|struct
name|utmp
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|statbf
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|utmp
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"utmp malloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|statbf
operator|.
name|st_size
operator|&&
name|utmp
condition|)
block|{
name|nutmp
operator|=
name|read
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
name|utmp
argument_list|,
operator|(
name|int
operator|)
name|statbf
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|nutmp
operator|/=
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
name|utmp
init|;
name|u
operator|<
operator|&
name|utmp
index|[
name|nutmp
index|]
condition|;
name|u
operator|++
control|)
block|{
if|if
condition|(
name|SCMPN
argument_list|(
name|u
operator|->
name|ut_line
argument_list|,
name|line
operator|+
literal|5
argument_list|)
operator|||
name|u
operator|->
name|ut_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
operator|(
name|long
operator|)
name|u
operator|)
operator|-
operator|(
operator|(
name|long
operator|)
name|utmp
operator|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|u
operator|->
name|ut_name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|u
operator|->
name|ut_host
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|u
operator|->
name|ut_time
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
name|u
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
name|f
operator|=
name|open
argument_list|(
name|wtmpf
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_line
argument_list|,
name|line
operator|+
literal|5
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_host
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|wtmp
operator|.
name|ut_time
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|wtmp
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
name|strlen
argument_list|(
literal|"/dev/"
argument_list|)
index|]
operator|=
literal|'p'
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of rmut */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRAY */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_macro
name|rmut
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|utmp
name|utmp
decl_stmt|;
name|struct
name|utmp
modifier|*
name|utptr
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* for /etc/wtmp */
name|utmp
operator|.
name|ut_type
operator|=
name|USER_PROCESS
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|utmp
operator|.
name|ut_id
argument_list|,
name|line
operator|+
literal|12
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_id
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setutent
argument_list|()
expr_stmt|;
name|utptr
operator|=
name|getutid
argument_list|(
operator|&
name|utmp
argument_list|)
expr_stmt|;
comment|/* write it out only if it exists */
if|if
condition|(
name|utptr
condition|)
block|{
name|utptr
operator|->
name|ut_type
operator|=
name|DEAD_PROCESS
expr_stmt|;
name|utptr
operator|->
name|ut_time
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pututline
argument_list|(
name|utptr
argument_list|)
expr_stmt|;
comment|/* set wtmp entry if wtmp file exists */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|wtmpf
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
name|fd
argument_list|,
name|utptr
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|endutent
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
literal|14
index|]
operator|=
name|line
index|[
literal|13
index|]
expr_stmt|;
name|line
index|[
literal|13
index|]
operator|=
name|line
index|[
literal|12
index|]
expr_stmt|;
name|line
index|[
literal|8
index|]
operator|=
literal|'m'
expr_stmt|;
name|line
index|[
literal|9
index|]
operator|=
literal|'/'
expr_stmt|;
name|line
index|[
literal|10
index|]
operator|=
literal|'p'
expr_stmt|;
name|line
index|[
literal|11
index|]
operator|=
literal|'t'
expr_stmt|;
name|line
index|[
literal|12
index|]
operator|=
literal|'y'
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

