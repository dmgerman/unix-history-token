begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static const char sccsid[] = "@(#)telnet.c	8.4 (Berkeley) 5/30/95";
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|unix
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* By the way, we need to include curses.h before telnet.h since,  * among other things, telnet.h #defines 'DO', which is a variable  * declared in curses.h.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(unix) */
end_comment

begin_include
include|#
directive|include
file|<arpa/telnet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"ring.h"
end_include

begin_include
include|#
directive|include
file|"defines.h"
end_include

begin_include
include|#
directive|include
file|"externs.h"
end_include

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
end_if

begin_include
include|#
directive|include
file|<libtelnet/auth.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ENCRYPTION
argument_list|)
end_if

begin_include
include|#
directive|include
file|<libtelnet/encrypt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<libtelnet/misc.h>
end_include

begin_escape
end_escape

begin_define
define|#
directive|define
name|strip
parameter_list|(
name|x
parameter_list|)
value|((my_want_state_is_wont(TELOPT_BINARY)) ? ((x)&0x7f) : (x))
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|subbuffer
index|[
name|SUBBUFSIZE
index|]
decl_stmt|,
modifier|*
name|subpointer
decl_stmt|,
modifier|*
name|subend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for sub-options */
end_comment

begin_define
define|#
directive|define
name|SB_CLEAR
parameter_list|()
value|subpointer = subbuffer;
end_define

begin_define
define|#
directive|define
name|SB_TERM
parameter_list|()
value|{ subend = subpointer; SB_CLEAR(); }
end_define

begin_define
define|#
directive|define
name|SB_ACCUM
parameter_list|(
name|c
parameter_list|)
value|if (subpointer< (subbuffer+sizeof subbuffer)) { \ 				*subpointer++ = (c); \ 			}
end_define

begin_define
define|#
directive|define
name|SB_GET
parameter_list|()
value|((*subpointer++)&0xff)
end_define

begin_define
define|#
directive|define
name|SB_PEEK
parameter_list|()
value|((*subpointer)&0xff)
end_define

begin_define
define|#
directive|define
name|SB_EOF
parameter_list|()
value|(subpointer>= subend)
end_define

begin_define
define|#
directive|define
name|SB_LEN
parameter_list|()
value|(subend - subpointer)
end_define

begin_decl_stmt
name|char
name|options
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The combined options */
end_comment

begin_decl_stmt
name|char
name|do_dont_resp
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|will_wont_resp
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|eight
init|=
literal|0
decl_stmt|,
name|autologin
init|=
literal|0
decl_stmt|,
comment|/* Autologin anyone? */
name|skiprc
init|=
literal|0
decl_stmt|,
name|connected
decl_stmt|,
name|showoptions
decl_stmt|,
name|In3270
decl_stmt|,
comment|/* Are we in 3270 mode? */
name|ISend
decl_stmt|,
comment|/* trying to send network data in */
name|debug
init|=
literal|0
decl_stmt|,
name|crmod
decl_stmt|,
name|netdata
decl_stmt|,
comment|/* Print out network data flow */
name|crlf
decl_stmt|,
comment|/* Should '\r' be mapped to<CR><LF> (or<CR><NUL>)? */
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
name|noasynchtty
init|=
literal|0
decl_stmt|,
comment|/* User specified "-noasynch" on command line */
name|noasynchnet
init|=
literal|0
decl_stmt|,
comment|/* User specified "-noasynch" on command line */
name|askedSGA
init|=
literal|0
decl_stmt|,
comment|/* We have talked about suppress go ahead */
endif|#
directive|endif
comment|/* defined(TN3270) */
name|telnetport
decl_stmt|,
name|SYNCHing
decl_stmt|,
comment|/* we are in TELNET SYNCH mode */
name|flushout
decl_stmt|,
comment|/* flush output */
name|autoflush
init|=
literal|0
decl_stmt|,
comment|/* flush output when interrupting? */
name|autosynch
decl_stmt|,
comment|/* send interrupt characters with SYNCH? */
name|localflow
decl_stmt|,
comment|/* we handle flow control locally */
name|restartany
decl_stmt|,
comment|/* if flow control enabled, restart on any character */
name|localchars
decl_stmt|,
comment|/* we recognize interrupt/quit */
name|donelclchars
decl_stmt|,
comment|/* the user has set "localchars" */
name|donebinarytoggle
decl_stmt|,
comment|/* the user has put us in binary */
name|dontlecho
decl_stmt|,
comment|/* do we suppress local echoing right now? */
name|globalmode
decl_stmt|,
name|doaddrlookup
init|=
literal|1
decl_stmt|,
comment|/* do a reverse address lookup? */
name|clienteof
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prompt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cc_t
name|escape
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cc_t
name|rlogin
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
end_ifdef

begin_decl_stmt
name|cc_t
name|echoc
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Telnet receiver states for fsm  */
end_comment

begin_define
define|#
directive|define
name|TS_DATA
value|0
end_define

begin_define
define|#
directive|define
name|TS_IAC
value|1
end_define

begin_define
define|#
directive|define
name|TS_WILL
value|2
end_define

begin_define
define|#
directive|define
name|TS_WONT
value|3
end_define

begin_define
define|#
directive|define
name|TS_DO
value|4
end_define

begin_define
define|#
directive|define
name|TS_DONT
value|5
end_define

begin_define
define|#
directive|define
name|TS_CR
value|6
end_define

begin_define
define|#
directive|define
name|TS_SB
value|7
end_define

begin_comment
comment|/* sub-option collection */
end_comment

begin_define
define|#
directive|define
name|TS_SE
value|8
end_define

begin_comment
comment|/* looking for sub-option end */
end_comment

begin_decl_stmt
specifier|static
name|int
name|telrcv_state
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OLD_ENVIRON
end_ifdef

begin_decl_stmt
name|unsigned
name|char
name|telopt_environ
init|=
name|TELOPT_NEW_ENVIRON
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|telopt_environ
value|TELOPT_NEW_ENVIRON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|jmp_buf
name|toplevel
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|peerdied
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flushline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linemode
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
end_ifdef

begin_decl_stmt
name|int
name|kludgelinemode
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The following are some clocks used to decide how to interpret  * the relationship between various variables.  */
end_comment

begin_decl_stmt
name|Clocks
name|clocks
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_decl_stmt
name|Modelist
name|modelist
index|[]
init|=
block|{
block|{
literal|"telnet command mode"
block|,
name|COMMAND_LINE
block|}
block|,
block|{
literal|"character-at-a-time mode"
block|,
literal|0
block|}
block|,
block|{
literal|"character-at-a-time mode (local echo)"
block|,
name|LOCAL_ECHO
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"line-by-line mode (remote echo)"
block|,
name|LINE
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"line-by-line mode"
block|,
name|LINE
operator||
name|LOCAL_ECHO
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"line-by-line mode (local echoing suppressed)"
block|,
name|LINE
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"3270 mode"
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * Initialize telnet environment.  */
end_comment

begin_function
name|void
name|init_telnet
parameter_list|()
block|{
name|env_init
argument_list|()
expr_stmt|;
name|SB_CLEAR
argument_list|()
expr_stmt|;
name|ClearArray
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|connected
operator|=
name|In3270
operator|=
name|ISend
operator|=
name|localflow
operator|=
name|donebinarytoggle
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
operator|||
name|defined
argument_list|(
name|ENCRYPTION
argument_list|)
name|auth_encrypt_connect
argument_list|(
name|connected
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(AUTHENTICATION) || defined(ENCRYPTION)  */
name|restartany
operator|=
operator|-
literal|1
expr_stmt|;
name|SYNCHing
operator|=
literal|0
expr_stmt|;
comment|/* Don't change NetTrace */
name|escape
operator|=
name|CONTROL
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|rlogin
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
name|echoc
operator|=
name|CONTROL
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flushline
operator|=
literal|1
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
specifier|static
name|void
name|printring
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
comment|/* where things go */
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|Ring
modifier|*
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ring
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|Ring
operator|*
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
operator|*
name|format
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|'%'
condition|)
block|{
name|i
operator|=
operator|*
name|format
operator|++
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'c'
case|:
operator|*
name|ptr
operator|++
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|string
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|ring_supply_data
argument_list|(
name|ring
argument_list|,
name|buffer
argument_list|,
name|ptr
operator|-
name|buffer
argument_list|)
expr_stmt|;
name|ring_supply_data
argument_list|(
name|ring
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buffer
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|ExitString
argument_list|(
literal|"printring: trailing %%.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
default|default:
name|ExitString
argument_list|(
literal|"printring: unknown format character.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
else|else
block|{
operator|*
name|ptr
operator|++
operator|=
name|i
expr_stmt|;
block|}
block|}
name|ring_supply_data
argument_list|(
name|ring
argument_list|,
name|buffer
argument_list|,
name|ptr
operator|-
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * These routines are in charge of sending option negotiations  * to the other side.  *  * The basic idea is that we send the negotiation if either side  * is in disagreement as to what the current state should be.  */
end_comment

begin_function
name|void
name|send_do
parameter_list|(
name|c
parameter_list|,
name|init
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|do_dont_resp
index|[
name|c
index|]
operator|==
literal|0
operator|)
operator|&&
name|my_state_is_do
argument_list|(
name|c
argument_list|)
operator|)
operator|||
name|my_want_state_is_do
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|set_my_want_state_do
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|do_dont_resp
index|[
name|c
index|]
operator|++
expr_stmt|;
block|}
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|DO
argument_list|)
expr_stmt|;
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
name|DO
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|send_dont
parameter_list|(
name|c
parameter_list|,
name|init
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|do_dont_resp
index|[
name|c
index|]
operator|==
literal|0
operator|)
operator|&&
name|my_state_is_dont
argument_list|(
name|c
argument_list|)
operator|)
operator|||
name|my_want_state_is_dont
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|set_my_want_state_dont
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|do_dont_resp
index|[
name|c
index|]
operator|++
expr_stmt|;
block|}
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|DONT
argument_list|)
expr_stmt|;
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
name|DONT
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|send_will
parameter_list|(
name|c
parameter_list|,
name|init
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|will_wont_resp
index|[
name|c
index|]
operator|==
literal|0
operator|)
operator|&&
name|my_state_is_will
argument_list|(
name|c
argument_list|)
operator|)
operator|||
name|my_want_state_is_will
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|set_my_want_state_will
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|will_wont_resp
index|[
name|c
index|]
operator|++
expr_stmt|;
block|}
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|WILL
argument_list|)
expr_stmt|;
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
name|WILL
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|send_wont
parameter_list|(
name|c
parameter_list|,
name|init
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|will_wont_resp
index|[
name|c
index|]
operator|==
literal|0
operator|)
operator|&&
name|my_state_is_wont
argument_list|(
name|c
argument_list|)
operator|)
operator|||
name|my_want_state_is_wont
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|set_my_want_state_wont
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|will_wont_resp
index|[
name|c
index|]
operator|++
expr_stmt|;
block|}
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|WONT
argument_list|)
expr_stmt|;
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
name|WONT
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|willoption
parameter_list|(
name|option
parameter_list|)
name|int
name|option
decl_stmt|;
block|{
name|int
name|new_state_ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
condition|)
block|{
operator|--
name|do_dont_resp
index|[
name|option
index|]
expr_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|&&
name|my_state_is_do
argument_list|(
name|option
argument_list|)
condition|)
operator|--
name|do_dont_resp
index|[
name|option
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|)
operator|&&
name|my_want_state_is_dont
argument_list|(
name|option
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_ECHO
case|:
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
comment|/* 		 * The following is a pain in the rear-end. 		 * Various IBM servers (some versions of Wiscnet, 		 * possibly Fibronics/Spartacus, and who knows who 		 * else) will NOT allow us to send "DO SGA" too early 		 * in the setup proceedings.  On the other hand, 		 * 4.2 servers (telnetd) won't set SGA correctly. 		 * So, we are stuck.  Empirically (but, based on 		 * a VERY small sample), the IBM servers don't send 		 * out anything about ECHO, so we postpone our sending 		 * "DO SGA" until we see "WILL ECHO" (which 4.2 servers 		 * DO send). 		  */
block|{
if|if
condition|(
name|askedSGA
operator|==
literal|0
condition|)
block|{
name|askedSGA
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|my_want_state_is_dont
argument_list|(
name|TELOPT_SGA
argument_list|)
condition|)
name|send_do
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fall through */
case|case
name|TELOPT_EOR
case|:
endif|#
directive|endif
comment|/* defined(TN3270) */
case|case
name|TELOPT_BINARY
case|:
case|case
name|TELOPT_SGA
case|:
name|settimer
argument_list|(
name|modenegotiated
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|TELOPT_STATUS
case|:
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
case|case
name|TELOPT_AUTHENTICATION
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENCRYPTION
case|case
name|TELOPT_ENCRYPT
case|:
endif|#
directive|endif
comment|/* ENCRYPTION */
name|new_state_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TELOPT_TM
case|:
if|if
condition|(
name|flushout
condition|)
name|flushout
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Special case for TM.  If we get back a WILL, 		 * pretend we got back a WONT. 		 */
name|set_my_want_state_dont
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|set_my_state_dont
argument_list|(
name|option
argument_list|)
expr_stmt|;
return|return;
comment|/* Never reply to TM will's/wont's */
case|case
name|TELOPT_LINEMODE
case|:
default|default:
break|break;
block|}
if|if
condition|(
name|new_state_ok
condition|)
block|{
name|set_my_want_state_do
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|send_do
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* possibly set new tty mode */
block|}
else|else
block|{
name|do_dont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
name|send_dont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|set_my_state_do
argument_list|(
name|option
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENCRYPTION
if|if
condition|(
name|option
operator|==
name|TELOPT_ENCRYPT
condition|)
name|encrypt_send_support
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ENCRYPTION */
block|}
end_function

begin_function
name|void
name|wontoption
parameter_list|(
name|option
parameter_list|)
name|int
name|option
decl_stmt|;
block|{
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
condition|)
block|{
operator|--
name|do_dont_resp
index|[
name|option
index|]
expr_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|&&
name|my_state_is_dont
argument_list|(
name|option
argument_list|)
condition|)
operator|--
name|do_dont_resp
index|[
name|option
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|)
operator|&&
name|my_want_state_is_do
argument_list|(
name|option
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
case|case
name|TELOPT_SGA
case|:
if|if
condition|(
operator|!
name|kludgelinemode
condition|)
break|break;
comment|/* FALL THROUGH */
endif|#
directive|endif
case|case
name|TELOPT_ECHO
case|:
name|settimer
argument_list|(
name|modenegotiated
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELOPT_TM
case|:
if|if
condition|(
name|flushout
condition|)
name|flushout
operator|=
literal|0
expr_stmt|;
name|set_my_want_state_dont
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|set_my_state_dont
argument_list|(
name|option
argument_list|)
expr_stmt|;
return|return;
comment|/* Never reply to TM will's/wont's */
default|default:
break|break;
block|}
name|set_my_want_state_dont
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_state_is_do
argument_list|(
name|option
argument_list|)
condition|)
name|send_dont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Set new tty mode */
block|}
elseif|else
if|if
condition|(
name|option
operator|==
name|TELOPT_TM
condition|)
block|{
comment|/* 	     * Special case for TM. 	     */
if|if
condition|(
name|flushout
condition|)
name|flushout
operator|=
literal|0
expr_stmt|;
name|set_my_want_state_dont
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
name|set_my_state_dont
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dooption
parameter_list|(
name|option
parameter_list|)
name|int
name|option
decl_stmt|;
block|{
name|int
name|new_state_ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
condition|)
block|{
operator|--
name|will_wont_resp
index|[
name|option
index|]
expr_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
operator|&&
name|my_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
operator|--
name|will_wont_resp
index|[
name|option
index|]
expr_stmt|;
block|}
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|option
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_TM
case|:
comment|/* 		 * Special case for TM.  We send a WILL, but pretend 		 * we sent WONT. 		 */
name|send_will
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_my_want_state_wont
argument_list|(
name|TELOPT_TM
argument_list|)
expr_stmt|;
name|set_my_state_wont
argument_list|(
name|TELOPT_TM
argument_list|)
expr_stmt|;
return|return;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
case|case
name|TELOPT_EOR
case|:
comment|/* end of record */
endif|#
directive|endif
comment|/* defined(TN3270) */
case|case
name|TELOPT_BINARY
case|:
comment|/* binary mode */
case|case
name|TELOPT_NAWS
case|:
comment|/* window size */
case|case
name|TELOPT_TSPEED
case|:
comment|/* terminal speed */
case|case
name|TELOPT_LFLOW
case|:
comment|/* local flow control */
case|case
name|TELOPT_TTYPE
case|:
comment|/* terminal type option */
case|case
name|TELOPT_SGA
case|:
comment|/* no big deal */
ifdef|#
directive|ifdef
name|ENCRYPTION
case|case
name|TELOPT_ENCRYPT
case|:
comment|/* encryption variable option */
endif|#
directive|endif
comment|/* ENCRYPTION */
name|new_state_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TELOPT_NEW_ENVIRON
case|:
comment|/* New environment variable option */
ifdef|#
directive|ifdef
name|OLD_ENVIRON
if|if
condition|(
name|my_state_is_will
argument_list|(
name|TELOPT_OLD_ENVIRON
argument_list|)
condition|)
name|send_wont
argument_list|(
name|TELOPT_OLD_ENVIRON
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* turn off the old */
goto|goto
name|env_common
goto|;
case|case
name|TELOPT_OLD_ENVIRON
case|:
comment|/* Old environment variable option */
if|if
condition|(
name|my_state_is_will
argument_list|(
name|TELOPT_NEW_ENVIRON
argument_list|)
condition|)
break|break;
comment|/* Don't enable if new one is in use! */
name|env_common
label|:
name|telopt_environ
operator|=
name|option
expr_stmt|;
endif|#
directive|endif
name|new_state_ok
operator|=
literal|1
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
case|case
name|TELOPT_AUTHENTICATION
case|:
if|if
condition|(
name|autologin
condition|)
name|new_state_ok
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|TELOPT_XDISPLOC
case|:
comment|/* X Display location */
if|if
condition|(
name|env_getvalue
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"DISPLAY"
argument_list|)
condition|)
name|new_state_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TELOPT_LINEMODE
case|:
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
name|kludgelinemode
operator|=
literal|0
expr_stmt|;
name|send_do
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_my_want_state_will
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_my_state_will
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
expr_stmt|;
name|slc_init
argument_list|()
expr_stmt|;
return|return;
case|case
name|TELOPT_ECHO
case|:
comment|/* We're never going to echo... */
default|default:
break|break;
block|}
if|if
condition|(
name|new_state_ok
condition|)
block|{
name|set_my_want_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Set new tty mode */
block|}
else|else
block|{
name|will_wont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
name|send_wont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * Handle options that need more things done after the 	     * other side has acknowledged the option. 	     */
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_LINEMODE
case|:
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
name|kludgelinemode
operator|=
literal|0
expr_stmt|;
name|send_do
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_my_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|slc_init
argument_list|()
expr_stmt|;
name|send_do
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|set_my_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dontoption
parameter_list|(
name|option
parameter_list|)
name|int
name|option
decl_stmt|;
block|{
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
condition|)
block|{
operator|--
name|will_wont_resp
index|[
name|option
index|]
expr_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
operator|&&
name|my_state_is_wont
argument_list|(
name|option
argument_list|)
condition|)
operator|--
name|will_wont_resp
index|[
name|option
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|)
operator|&&
name|my_want_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_LINEMODE
case|:
name|linemode
operator|=
literal|0
expr_stmt|;
comment|/* put us back to the default state */
break|break;
ifdef|#
directive|ifdef
name|OLD_ENVIRON
case|case
name|TELOPT_NEW_ENVIRON
case|:
comment|/* 		 * The new environ option wasn't recognized, try 		 * the old one. 		 */
name|send_will
argument_list|(
name|TELOPT_OLD_ENVIRON
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|telopt_environ
operator|=
name|TELOPT_OLD_ENVIRON
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
comment|/* we always accept a DONT */
name|set_my_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
name|send_wont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Set new tty mode */
block|}
name|set_my_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a buffer returned by tgetent(), this routine will turn  * the pipe seperated list of names in the buffer into an array  * of pointers to null terminated names.  We toss out any bad,  * duplicate, or verbose names (names with spaces).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|name_unknown
init|=
literal|"UNKNOWN"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|unknown
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
modifier|*
name|mklist
parameter_list|(
name|buf
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|argvp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|,
modifier|*
modifier|*
name|argv
decl_stmt|,
modifier|*
modifier|*
name|avt
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
literal|40
condition|)
block|{
name|name
operator|=
literal|0
expr_stmt|;
name|unknown
index|[
literal|0
index|]
operator|=
name|name_unknown
expr_stmt|;
block|}
else|else
block|{
name|unknown
index|[
literal|0
index|]
operator|=
name|name
expr_stmt|;
name|upcase
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|unknown
index|[
literal|0
index|]
operator|=
name|name_unknown
expr_stmt|;
comment|/* 	 * Count up the number of names. 	 */
for|for
control|(
name|n
operator|=
literal|1
operator|,
name|cp
operator|=
name|buf
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|':'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'|'
condition|)
name|n
operator|++
expr_stmt|;
block|}
comment|/* 	 * Allocate an array to put the name pointers into 	 */
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|n
operator|+
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|==
literal|0
condition|)
return|return
operator|(
name|unknown
operator|)
return|;
comment|/* 	 * Fill up the array of pointers to names. 	 */
operator|*
name|argv
operator|=
literal|0
expr_stmt|;
name|argvp
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cp2
operator|=
name|buf
init|;
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'|'
operator|||
name|c
operator|==
literal|':'
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * Skip entries that have spaces or are over 40 			 * characters long.  If this is our environment 			 * name, then put it up front.  Otherwise, as 			 * long as this is not a duplicate name (case 			 * insensitive) add it to the list. 			 */
if|if
condition|(
name|n
operator|||
operator|(
name|cp
operator|-
name|cp2
operator|>
literal|41
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|name
operator|&&
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
name|cp2
argument_list|,
name|cp
operator|-
name|cp2
argument_list|)
operator|==
literal|0
operator|)
condition|)
operator|*
name|argv
operator|=
name|cp2
expr_stmt|;
elseif|else
if|if
condition|(
name|is_unique
argument_list|(
name|cp2
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|argvp
argument_list|)
condition|)
operator|*
name|argvp
operator|++
operator|=
name|cp2
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
break|break;
comment|/* 			 * Skip multiple delimiters. Reset cp2 to 			 * the beginning of the next name. Reset n, 			 * the flag for names with spaces. 			 */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|==
literal|'|'
condition|)
name|cp
operator|++
expr_stmt|;
name|cp2
operator|=
name|cp
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Skip entries with spaces or non-ascii values. 		 * Convert lower case letters to upper case. 		 */
if|if
condition|(
operator|(
name|c
operator|==
literal|' '
operator|)
operator|||
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
name|n
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for an old V6 2 character name.  If the second 	 * name points to the beginning of the buffer, and is 	 * only 2 characters long, move it to the end of the array. 	 */
if|if
condition|(
operator|(
name|argv
index|[
literal|1
index|]
operator|==
name|buf
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|2
operator|)
condition|)
block|{
operator|--
name|argvp
expr_stmt|;
for|for
control|(
name|avt
operator|=
operator|&
name|argv
index|[
literal|1
index|]
init|;
name|avt
operator|<
name|argvp
condition|;
name|avt
operator|++
control|)
operator|*
name|avt
operator|=
operator|*
operator|(
name|avt
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|argvp
operator|++
operator|=
name|buf
expr_stmt|;
block|}
comment|/* 	 * Duplicate last name, for TTYPE option, and null 	 * terminate the array.  If we didn't find a match on 	 * our terminal name, put that name at the beginning. 	 */
name|cp
operator|=
operator|*
operator|(
name|argvp
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|argvp
operator|++
operator|=
name|cp
expr_stmt|;
operator|*
name|argvp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|argv
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|name
condition|)
operator|*
name|argv
operator|=
name|name
expr_stmt|;
else|else
block|{
operator|--
name|argvp
expr_stmt|;
for|for
control|(
name|avt
operator|=
name|argv
init|;
name|avt
operator|<
name|argvp
condition|;
name|avt
operator|++
control|)
operator|*
name|avt
operator|=
operator|*
operator|(
name|avt
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|argv
condition|)
return|return
operator|(
name|argv
operator|)
return|;
else|else
return|return
operator|(
name|unknown
operator|)
return|;
block|}
end_block

begin_function
name|int
name|is_unique
parameter_list|(
name|name
parameter_list|,
name|as
parameter_list|,
name|ae
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
decl|*
modifier|*
name|as
decl_stmt|,
modifier|*
modifier|*
name|ae
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|as
init|;
name|ap
operator|<
name|ae
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|ap
argument_list|,
name|name
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|TERMCAP
end_ifdef

begin_decl_stmt
name|char
name|termbuf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|setupterm
parameter_list|(
name|tname
parameter_list|,
name|fd
parameter_list|,
name|errp
parameter_list|)
name|char
modifier|*
name|tname
decl_stmt|;
name|int
name|fd
decl_stmt|,
decl|*
name|errp
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|tgetent
argument_list|(
name|termbuf
argument_list|,
name|tname
argument_list|)
operator|==
literal|1
condition|)
block|{
name|termbuf
index|[
literal|1023
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|errp
condition|)
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|errp
condition|)
operator|*
name|errp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|termbuf
value|ttytype
end_define

begin_decl_stmt
specifier|extern
name|char
name|ttytype
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|resettermname
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|gettermname
parameter_list|()
block|{
name|char
modifier|*
name|tname
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|tnamep
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|next
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|resettermname
condition|)
block|{
name|resettermname
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tnamep
operator|&&
name|tnamep
operator|!=
name|unknown
condition|)
name|free
argument_list|(
name|tnamep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tname
operator|=
operator|(
name|char
operator|*
operator|)
name|env_getvalue
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"TERM"
argument_list|)
operator|)
operator|&&
operator|(
name|setupterm
argument_list|(
name|tname
argument_list|,
literal|1
argument_list|,
operator|&
name|err
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|tnamep
operator|=
name|mklist
argument_list|(
name|termbuf
argument_list|,
name|tname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tname
operator|&&
operator|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|tname
argument_list|)
operator|<=
literal|40
operator|)
condition|)
block|{
name|unknown
index|[
literal|0
index|]
operator|=
name|tname
expr_stmt|;
name|upcase
argument_list|(
name|tname
argument_list|)
expr_stmt|;
block|}
else|else
name|unknown
index|[
literal|0
index|]
operator|=
name|name_unknown
expr_stmt|;
name|tnamep
operator|=
name|unknown
expr_stmt|;
block|}
name|next
operator|=
name|tnamep
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|next
operator|==
literal|0
condition|)
name|next
operator|=
name|tnamep
expr_stmt|;
return|return
operator|(
operator|*
name|next
operator|++
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * suboption()  *  *	Look at the sub-option buffer, and try to be helpful to the other  * side.  *  *	Currently we recognize:  *  *		Terminal type, send request.  *		Terminal speed (send request).  *		Local flow control (is request).  *		Linemode  */
end_comment

begin_function
specifier|static
name|void
name|suboption
parameter_list|()
block|{
name|unsigned
name|char
name|subchar
decl_stmt|;
name|printsub
argument_list|(
literal|'<'
argument_list|,
name|subbuffer
argument_list|,
name|SB_LEN
argument_list|()
operator|+
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|subchar
operator|=
name|SB_GET
argument_list|()
condition|)
block|{
case|case
name|TELOPT_TTYPE
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_TTYPE
argument_list|)
condition|)
return|return;
if|if
condition|(
name|SB_EOF
argument_list|()
operator|||
name|SB_GET
argument_list|()
operator|!=
name|TELQUAL_SEND
condition|)
block|{
return|return;
block|}
else|else
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|char
name|temp
index|[
literal|50
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|tn3270_ttype
argument_list|()
condition|)
block|{
return|return;
block|}
endif|#
directive|endif
comment|/* defined(TN3270) */
name|name
operator|=
name|gettermname
argument_list|()
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|4
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|NETROOM
argument_list|()
condition|)
block|{
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp
argument_list|,
literal|"%c%c%c%c%s%c%c"
argument_list|,
name|IAC
argument_list|,
name|SB
argument_list|,
name|TELOPT_TTYPE
argument_list|,
name|TELQUAL_IS
argument_list|,
name|name
argument_list|,
name|IAC
argument_list|,
name|SE
argument_list|)
expr_stmt|;
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|temp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|temp
index|[
literal|2
index|]
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ExitString
argument_list|(
literal|"No room in buffer for terminal type.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
break|break;
case|case
name|TELOPT_TSPEED
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_TSPEED
argument_list|)
condition|)
return|return;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
if|if
condition|(
name|SB_GET
argument_list|()
operator|==
name|TELQUAL_SEND
condition|)
block|{
name|long
name|ospeed
decl_stmt|,
name|ispeed
decl_stmt|;
name|unsigned
name|char
name|temp
index|[
literal|50
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|TerminalSpeeds
argument_list|(
operator|&
name|ispeed
argument_list|,
operator|&
name|ospeed
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp
argument_list|,
literal|"%c%c%c%c%ld,%ld%c%c"
argument_list|,
name|IAC
argument_list|,
name|SB
argument_list|,
name|TELOPT_TSPEED
argument_list|,
name|TELQUAL_IS
argument_list|,
name|ospeed
argument_list|,
name|ispeed
argument_list|,
name|IAC
argument_list|,
name|SE
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp
operator|+
literal|4
argument_list|)
operator|+
literal|4
expr_stmt|;
comment|/* temp[3] is 0 ... */
if|if
condition|(
name|len
operator|<
name|NETROOM
argument_list|()
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|temp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
name|temp
operator|+
literal|2
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"lm_will: not enough room in buffer\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TELOPT_LFLOW
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_LFLOW
argument_list|)
condition|)
return|return;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
switch|switch
condition|(
name|SB_GET
argument_list|()
condition|)
block|{
case|case
name|LFLOW_RESTART_ANY
case|:
name|restartany
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LFLOW_RESTART_XON
case|:
name|restartany
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LFLOW_ON
case|:
name|localflow
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LFLOW_OFF
case|:
name|localflow
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|setcommandmode
argument_list|()
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELOPT_LINEMODE
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
condition|)
return|return;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
switch|switch
condition|(
name|SB_GET
argument_list|()
condition|)
block|{
case|case
name|WILL
case|:
name|lm_will
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|WONT
case|:
name|lm_wont
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|DO
case|:
name|lm_do
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|DONT
case|:
name|lm_dont
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|LM_SLC
case|:
name|slc
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|LM_MODE
case|:
name|lm_mode
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
ifdef|#
directive|ifdef
name|OLD_ENVIRON
case|case
name|TELOPT_OLD_ENVIRON
case|:
endif|#
directive|endif
case|case
name|TELOPT_NEW_ENVIRON
case|:
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
switch|switch
condition|(
name|SB_PEEK
argument_list|()
condition|)
block|{
case|case
name|TELQUAL_IS
case|:
case|case
name|TELQUAL_INFO
case|:
if|if
condition|(
name|my_want_state_is_dont
argument_list|(
name|subchar
argument_list|)
condition|)
return|return;
break|break;
case|case
name|TELQUAL_SEND
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|subchar
argument_list|)
condition|)
block|{
return|return;
block|}
break|break;
default|default:
return|return;
block|}
name|env_opt
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELOPT_XDISPLOC
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_XDISPLOC
argument_list|)
condition|)
return|return;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
if|if
condition|(
name|SB_GET
argument_list|()
operator|==
name|TELQUAL_SEND
condition|)
block|{
name|unsigned
name|char
name|temp
index|[
literal|50
index|]
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|env_getvalue
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"DISPLAY"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Something happened, we no longer have a DISPLAY 		 * variable.  So, turn off the option. 		 */
name|send_wont
argument_list|(
name|TELOPT_XDISPLOC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp
argument_list|,
literal|"%c%c%c%c%s%c%c"
argument_list|,
name|IAC
argument_list|,
name|SB
argument_list|,
name|TELOPT_XDISPLOC
argument_list|,
name|TELQUAL_IS
argument_list|,
name|dp
argument_list|,
name|IAC
argument_list|,
name|SE
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp
operator|+
literal|4
argument_list|)
operator|+
literal|4
expr_stmt|;
comment|/* temp[3] is 0 ... */
if|if
condition|(
name|len
operator|<
name|NETROOM
argument_list|()
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|temp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
name|temp
operator|+
literal|2
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"lm_will: not enough room in buffer\n"
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
case|case
name|TELOPT_AUTHENTICATION
case|:
block|{
if|if
condition|(
operator|!
name|autologin
condition|)
break|break;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
switch|switch
condition|(
name|SB_GET
argument_list|()
condition|)
block|{
case|case
name|TELQUAL_IS
case|:
if|if
condition|(
name|my_want_state_is_dont
argument_list|(
name|TELOPT_AUTHENTICATION
argument_list|)
condition|)
return|return;
name|auth_is
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELQUAL_SEND
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_AUTHENTICATION
argument_list|)
condition|)
return|return;
name|auth_send
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELQUAL_REPLY
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_AUTHENTICATION
argument_list|)
condition|)
return|return;
name|auth_reply
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELQUAL_NAME
case|:
if|if
condition|(
name|my_want_state_is_dont
argument_list|(
name|TELOPT_AUTHENTICATION
argument_list|)
condition|)
return|return;
name|auth_name
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENCRYPTION
case|case
name|TELOPT_ENCRYPT
case|:
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
switch|switch
condition|(
name|SB_GET
argument_list|()
condition|)
block|{
case|case
name|ENCRYPT_START
case|:
if|if
condition|(
name|my_want_state_is_dont
argument_list|(
name|TELOPT_ENCRYPT
argument_list|)
condition|)
return|return;
name|encrypt_start
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_END
case|:
if|if
condition|(
name|my_want_state_is_dont
argument_list|(
name|TELOPT_ENCRYPT
argument_list|)
condition|)
return|return;
name|encrypt_end
argument_list|()
expr_stmt|;
break|break;
case|case
name|ENCRYPT_SUPPORT
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_ENCRYPT
argument_list|)
condition|)
return|return;
name|encrypt_support
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_REQSTART
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_ENCRYPT
argument_list|)
condition|)
return|return;
name|encrypt_request_start
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_REQEND
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_ENCRYPT
argument_list|)
condition|)
return|return;
comment|/* 			 * We can always send an REQEND so that we cannot 			 * get stuck encrypting.  We should only get this 			 * if we have been able to get in the correct mode 			 * anyhow. 			 */
name|encrypt_request_end
argument_list|()
expr_stmt|;
break|break;
case|case
name|ENCRYPT_IS
case|:
if|if
condition|(
name|my_want_state_is_dont
argument_list|(
name|TELOPT_ENCRYPT
argument_list|)
condition|)
return|return;
name|encrypt_is
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_REPLY
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_ENCRYPT
argument_list|)
condition|)
return|return;
name|encrypt_reply
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_ENC_KEYID
case|:
if|if
condition|(
name|my_want_state_is_dont
argument_list|(
name|TELOPT_ENCRYPT
argument_list|)
condition|)
return|return;
name|encrypt_enc_keyid
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_DEC_KEYID
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_ENCRYPT
argument_list|)
condition|)
return|return;
name|encrypt_dec_keyid
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
endif|#
directive|endif
comment|/* ENCRYPTION */
default|default:
break|break;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|str_lm
index|[]
init|=
block|{
name|IAC
block|,
name|SB
block|,
name|TELOPT_LINEMODE
block|,
literal|0
block|,
literal|0
block|,
name|IAC
block|,
name|SE
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|lm_will
parameter_list|(
name|cmd
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
comment|/*@*/
name|printf
argument_list|(
literal|"lm_will: no command!!!\n"
argument_list|)
expr_stmt|;
comment|/* Should not happen... */
return|return;
block|}
switch|switch
condition|(
name|cmd
index|[
literal|0
index|]
condition|)
block|{
case|case
name|LM_FORWARDMASK
case|:
comment|/* We shouldn't ever get this... */
default|default:
name|str_lm
index|[
literal|3
index|]
operator|=
name|DONT
expr_stmt|;
name|str_lm
index|[
literal|4
index|]
operator|=
name|cmd
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|NETROOM
argument_list|()
operator|>
sizeof|sizeof
argument_list|(
name|str_lm
argument_list|)
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|str_lm
argument_list|,
sizeof|sizeof
argument_list|(
name|str_lm
argument_list|)
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|str_lm
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|str_lm
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"lm_will: not enough room in buffer\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|lm_wont
parameter_list|(
name|cmd
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
comment|/*@*/
name|printf
argument_list|(
literal|"lm_wont: no command!!!\n"
argument_list|)
expr_stmt|;
comment|/* Should not happen... */
return|return;
block|}
switch|switch
condition|(
name|cmd
index|[
literal|0
index|]
condition|)
block|{
case|case
name|LM_FORWARDMASK
case|:
comment|/* We shouldn't ever get this... */
default|default:
comment|/* We are always DONT, so don't respond */
return|return;
block|}
block|}
end_function

begin_function
name|void
name|lm_do
parameter_list|(
name|cmd
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
comment|/*@*/
name|printf
argument_list|(
literal|"lm_do: no command!!!\n"
argument_list|)
expr_stmt|;
comment|/* Should not happen... */
return|return;
block|}
switch|switch
condition|(
name|cmd
index|[
literal|0
index|]
condition|)
block|{
case|case
name|LM_FORWARDMASK
case|:
default|default:
name|str_lm
index|[
literal|3
index|]
operator|=
name|WONT
expr_stmt|;
name|str_lm
index|[
literal|4
index|]
operator|=
name|cmd
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|NETROOM
argument_list|()
operator|>
sizeof|sizeof
argument_list|(
name|str_lm
argument_list|)
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|str_lm
argument_list|,
sizeof|sizeof
argument_list|(
name|str_lm
argument_list|)
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|str_lm
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|str_lm
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"lm_do: not enough room in buffer\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|lm_dont
parameter_list|(
name|cmd
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
comment|/*@*/
name|printf
argument_list|(
literal|"lm_dont: no command!!!\n"
argument_list|)
expr_stmt|;
comment|/* Should not happen... */
return|return;
block|}
switch|switch
condition|(
name|cmd
index|[
literal|0
index|]
condition|)
block|{
case|case
name|LM_FORWARDMASK
case|:
default|default:
comment|/* we are always WONT, so don't respond */
break|break;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|str_lm_mode
index|[]
init|=
block|{
name|IAC
block|,
name|SB
block|,
name|TELOPT_LINEMODE
block|,
name|LM_MODE
block|,
literal|0
block|,
name|IAC
block|,
name|SE
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|lm_mode
parameter_list|(
name|cmd
parameter_list|,
name|len
parameter_list|,
name|init
parameter_list|)
name|unsigned
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|len
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|!=
literal|1
condition|)
return|return;
if|if
condition|(
operator|(
name|linemode
operator|&
name|MODE_MASK
operator|&
operator|~
name|MODE_ACK
operator|)
operator|==
operator|*
name|cmd
condition|)
return|return;
if|if
condition|(
operator|*
name|cmd
operator|&
name|MODE_ACK
condition|)
return|return;
name|linemode
operator|=
operator|*
name|cmd
operator|&
operator|(
name|MODE_MASK
operator|&
operator|~
name|MODE_ACK
operator|)
expr_stmt|;
name|str_lm_mode
index|[
literal|4
index|]
operator|=
name|linemode
expr_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
name|str_lm_mode
index|[
literal|4
index|]
operator||=
name|MODE_ACK
expr_stmt|;
if|if
condition|(
name|NETROOM
argument_list|()
operator|>
sizeof|sizeof
argument_list|(
name|str_lm_mode
argument_list|)
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|str_lm_mode
argument_list|,
sizeof|sizeof
argument_list|(
name|str_lm_mode
argument_list|)
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|str_lm_mode
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|str_lm_mode
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"lm_mode: not enough room in buffer\n"
argument_list|)
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* set changed mode */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * slc()  * Handle special character suboption of LINEMODE.  */
end_comment

begin_struct
struct|struct
name|spc
block|{
name|cc_t
name|val
decl_stmt|;
name|cc_t
modifier|*
name|valp
decl_stmt|;
name|char
name|flags
decl_stmt|;
comment|/* Current flags& level */
name|char
name|mylevel
decl_stmt|;
comment|/* Maximum level& flags */
block|}
name|spc_data
index|[
name|NSLC
operator|+
literal|1
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|SLC_IMPORT
value|0
end_define

begin_define
define|#
directive|define
name|SLC_EXPORT
value|1
end_define

begin_define
define|#
directive|define
name|SLC_RVALUE
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|slc_mode
init|=
name|SLC_EXPORT
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|slc_init
parameter_list|()
block|{
specifier|register
name|struct
name|spc
modifier|*
name|spcp
decl_stmt|;
name|localchars
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|spcp
operator|=
name|spc_data
init|;
name|spcp
operator|<
operator|&
name|spc_data
index|[
name|NSLC
operator|+
literal|1
index|]
condition|;
name|spcp
operator|++
control|)
block|{
name|spcp
operator|->
name|val
operator|=
literal|0
expr_stmt|;
name|spcp
operator|->
name|valp
operator|=
literal|0
expr_stmt|;
name|spcp
operator|->
name|flags
operator|=
name|spcp
operator|->
name|mylevel
operator|=
name|SLC_NOSUPPORT
expr_stmt|;
block|}
define|#
directive|define
name|initfunc
parameter_list|(
name|func
parameter_list|,
name|flags
parameter_list|)
value|{ \ 					spcp =&spc_data[func]; \ 					if ((spcp->valp = tcval(func))) { \ 					    spcp->val = *spcp->valp; \ 					    spcp->mylevel = SLC_VARIABLE|flags; \ 					} else { \ 					    spcp->val = 0; \ 					    spcp->mylevel = SLC_DEFAULT; \ 					} \ 				    }
name|initfunc
argument_list|(
name|SLC_SYNCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* No BRK */
name|initfunc
argument_list|(
name|SLC_AO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initfunc
argument_list|(
name|SLC_AYT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* No EOR */
name|initfunc
argument_list|(
name|SLC_ABORT
argument_list|,
name|SLC_FLUSHIN
operator||
name|SLC_FLUSHOUT
argument_list|)
expr_stmt|;
name|initfunc
argument_list|(
name|SLC_EOF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYSV_TERMIO
name|initfunc
argument_list|(
name|SLC_SUSP
argument_list|,
name|SLC_FLUSHIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|initfunc
argument_list|(
name|SLC_EC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initfunc
argument_list|(
name|SLC_EL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYSV_TERMIO
name|initfunc
argument_list|(
name|SLC_EW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initfunc
argument_list|(
name|SLC_RP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initfunc
argument_list|(
name|SLC_LNEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|initfunc
argument_list|(
name|SLC_XON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initfunc
argument_list|(
name|SLC_XOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV_TERMIO
name|spc_data
index|[
name|SLC_XON
index|]
operator|.
name|mylevel
operator|=
name|SLC_CANTCHANGE
expr_stmt|;
name|spc_data
index|[
name|SLC_XOFF
index|]
operator|.
name|mylevel
operator|=
name|SLC_CANTCHANGE
expr_stmt|;
endif|#
directive|endif
name|initfunc
argument_list|(
name|SLC_FORW1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_TERMIO
name|initfunc
argument_list|(
name|SLC_FORW2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* No FORW2 */
endif|#
directive|endif
name|initfunc
argument_list|(
name|SLC_IP
argument_list|,
name|SLC_FLUSHIN
operator||
name|SLC_FLUSHOUT
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|initfunc
if|if
condition|(
name|slc_mode
operator|==
name|SLC_EXPORT
condition|)
name|slc_export
argument_list|()
expr_stmt|;
else|else
name|slc_import
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|slcstate
parameter_list|()
block|{
name|printf
argument_list|(
literal|"Special characters are %s values\n"
argument_list|,
name|slc_mode
operator|==
name|SLC_IMPORT
condition|?
literal|"remote default"
else|:
name|slc_mode
operator|==
name|SLC_EXPORT
condition|?
literal|"local"
else|:
literal|"remote"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|slc_mode_export
parameter_list|()
block|{
name|slc_mode
operator|=
name|SLC_EXPORT
expr_stmt|;
if|if
condition|(
name|my_state_is_will
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
condition|)
name|slc_export
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|slc_mode_import
parameter_list|(
name|def
parameter_list|)
name|int
name|def
decl_stmt|;
block|{
name|slc_mode
operator|=
name|def
condition|?
name|SLC_IMPORT
else|:
name|SLC_RVALUE
expr_stmt|;
if|if
condition|(
name|my_state_is_will
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
condition|)
name|slc_import
argument_list|(
name|def
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|unsigned
name|char
name|slc_import_val
index|[]
init|=
block|{
name|IAC
block|,
name|SB
block|,
name|TELOPT_LINEMODE
block|,
name|LM_SLC
block|,
literal|0
block|,
name|SLC_VARIABLE
block|,
literal|0
block|,
name|IAC
block|,
name|SE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|slc_import_def
index|[]
init|=
block|{
name|IAC
block|,
name|SB
block|,
name|TELOPT_LINEMODE
block|,
name|LM_SLC
block|,
literal|0
block|,
name|SLC_DEFAULT
block|,
literal|0
block|,
name|IAC
block|,
name|SE
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|slc_import
parameter_list|(
name|def
parameter_list|)
name|int
name|def
decl_stmt|;
block|{
if|if
condition|(
name|NETROOM
argument_list|()
operator|>
sizeof|sizeof
argument_list|(
name|slc_import_val
argument_list|)
condition|)
block|{
if|if
condition|(
name|def
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|slc_import_def
argument_list|,
sizeof|sizeof
argument_list|(
name|slc_import_def
argument_list|)
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|slc_import_def
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|slc_import_def
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|slc_import_val
argument_list|,
sizeof|sizeof
argument_list|(
name|slc_import_val
argument_list|)
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|slc_import_val
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|slc_import_val
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"slc_import: not enough room\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|slc_export
parameter_list|()
block|{
specifier|register
name|struct
name|spc
modifier|*
name|spcp
decl_stmt|;
name|TerminalDefaultChars
argument_list|()
expr_stmt|;
name|slc_start_reply
argument_list|()
expr_stmt|;
for|for
control|(
name|spcp
operator|=
operator|&
name|spc_data
index|[
literal|1
index|]
init|;
name|spcp
operator|<
operator|&
name|spc_data
index|[
name|NSLC
operator|+
literal|1
index|]
condition|;
name|spcp
operator|++
control|)
block|{
if|if
condition|(
name|spcp
operator|->
name|mylevel
operator|!=
name|SLC_NOSUPPORT
condition|)
block|{
if|if
condition|(
name|spcp
operator|->
name|val
operator|==
call|(
name|cc_t
call|)
argument_list|(
name|_POSIX_VDISABLE
argument_list|)
condition|)
name|spcp
operator|->
name|flags
operator|=
name|SLC_NOSUPPORT
expr_stmt|;
else|else
name|spcp
operator|->
name|flags
operator|=
name|spcp
operator|->
name|mylevel
expr_stmt|;
if|if
condition|(
name|spcp
operator|->
name|valp
condition|)
name|spcp
operator|->
name|val
operator|=
operator|*
name|spcp
operator|->
name|valp
expr_stmt|;
name|slc_add_reply
argument_list|(
name|spcp
operator|-
name|spc_data
argument_list|,
name|spcp
operator|->
name|flags
argument_list|,
name|spcp
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
block|}
name|slc_end_reply
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|slc_update
argument_list|()
expr_stmt|;
name|setconnmode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Make sure the character values are set */
block|}
end_function

begin_function
name|void
name|slc
parameter_list|(
name|cp
parameter_list|,
name|len
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|struct
name|spc
modifier|*
name|spcp
decl_stmt|;
specifier|register
name|int
name|func
decl_stmt|,
name|level
decl_stmt|;
name|slc_start_reply
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>=
literal|3
condition|;
name|len
operator|-=
literal|3
operator|,
name|cp
operator|+=
literal|3
control|)
block|{
name|func
operator|=
name|cp
index|[
name|SLC_FUNC
index|]
expr_stmt|;
if|if
condition|(
name|func
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Client side: always ignore 0 function. 			 */
continue|continue;
block|}
if|if
condition|(
name|func
operator|>
name|NSLC
condition|)
block|{
if|if
condition|(
operator|(
name|cp
index|[
name|SLC_FLAGS
index|]
operator|&
name|SLC_LEVELBITS
operator|)
operator|!=
name|SLC_NOSUPPORT
condition|)
name|slc_add_reply
argument_list|(
name|func
argument_list|,
name|SLC_NOSUPPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|spcp
operator|=
operator|&
name|spc_data
index|[
name|func
index|]
expr_stmt|;
name|level
operator|=
name|cp
index|[
name|SLC_FLAGS
index|]
operator|&
operator|(
name|SLC_LEVELBITS
operator||
name|SLC_ACK
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
index|[
name|SLC_VALUE
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
name|spcp
operator|->
name|val
operator|)
operator|&&
operator|(
operator|(
name|level
operator|&
name|SLC_LEVELBITS
operator|)
operator|==
operator|(
name|spcp
operator|->
name|flags
operator|&
name|SLC_LEVELBITS
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|level
operator|==
operator|(
name|SLC_DEFAULT
operator||
name|SLC_ACK
operator|)
condition|)
block|{
comment|/* 			 * This is an error condition, the SLC_ACK 			 * bit should never be set for the SLC_DEFAULT 			 * level.  Our best guess to recover is to 			 * ignore the SLC_ACK bit. 			 */
name|cp
index|[
name|SLC_FLAGS
index|]
operator|&=
operator|~
name|SLC_ACK
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|==
operator|(
operator|(
name|spcp
operator|->
name|flags
operator|&
name|SLC_LEVELBITS
operator|)
operator||
name|SLC_ACK
operator|)
condition|)
block|{
name|spcp
operator|->
name|val
operator|=
operator|(
name|cc_t
operator|)
name|cp
index|[
name|SLC_VALUE
index|]
expr_stmt|;
name|spcp
operator|->
name|flags
operator|=
name|cp
index|[
name|SLC_FLAGS
index|]
expr_stmt|;
comment|/* include SLC_ACK */
continue|continue;
block|}
name|level
operator|&=
operator|~
name|SLC_ACK
expr_stmt|;
if|if
condition|(
name|level
operator|<=
operator|(
name|spcp
operator|->
name|mylevel
operator|&
name|SLC_LEVELBITS
operator|)
condition|)
block|{
name|spcp
operator|->
name|flags
operator|=
name|cp
index|[
name|SLC_FLAGS
index|]
operator||
name|SLC_ACK
expr_stmt|;
name|spcp
operator|->
name|val
operator|=
operator|(
name|cc_t
operator|)
name|cp
index|[
name|SLC_VALUE
index|]
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|==
name|SLC_DEFAULT
condition|)
block|{
if|if
condition|(
operator|(
name|spcp
operator|->
name|mylevel
operator|&
name|SLC_LEVELBITS
operator|)
operator|!=
name|SLC_DEFAULT
condition|)
name|spcp
operator|->
name|flags
operator|=
name|spcp
operator|->
name|mylevel
expr_stmt|;
else|else
name|spcp
operator|->
name|flags
operator|=
name|SLC_NOSUPPORT
expr_stmt|;
block|}
name|slc_add_reply
argument_list|(
name|func
argument_list|,
name|spcp
operator|->
name|flags
argument_list|,
name|spcp
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
name|slc_end_reply
argument_list|()
expr_stmt|;
if|if
condition|(
name|slc_update
argument_list|()
condition|)
name|setconnmode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* set the  new character values */
block|}
end_function

begin_function
name|void
name|slc_check
parameter_list|()
block|{
specifier|register
name|struct
name|spc
modifier|*
name|spcp
decl_stmt|;
name|slc_start_reply
argument_list|()
expr_stmt|;
for|for
control|(
name|spcp
operator|=
operator|&
name|spc_data
index|[
literal|1
index|]
init|;
name|spcp
operator|<
operator|&
name|spc_data
index|[
name|NSLC
operator|+
literal|1
index|]
condition|;
name|spcp
operator|++
control|)
block|{
if|if
condition|(
name|spcp
operator|->
name|valp
operator|&&
name|spcp
operator|->
name|val
operator|!=
operator|*
name|spcp
operator|->
name|valp
condition|)
block|{
name|spcp
operator|->
name|val
operator|=
operator|*
name|spcp
operator|->
name|valp
expr_stmt|;
if|if
condition|(
name|spcp
operator|->
name|val
operator|==
call|(
name|cc_t
call|)
argument_list|(
name|_POSIX_VDISABLE
argument_list|)
condition|)
name|spcp
operator|->
name|flags
operator|=
name|SLC_NOSUPPORT
expr_stmt|;
else|else
name|spcp
operator|->
name|flags
operator|=
name|spcp
operator|->
name|mylevel
expr_stmt|;
name|slc_add_reply
argument_list|(
name|spcp
operator|-
name|spc_data
argument_list|,
name|spcp
operator|->
name|flags
argument_list|,
name|spcp
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
block|}
name|slc_end_reply
argument_list|()
expr_stmt|;
name|setconnmode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|unsigned
name|char
name|slc_reply
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|slc_replyp
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|slc_start_reply
parameter_list|()
block|{
name|slc_replyp
operator|=
name|slc_reply
expr_stmt|;
operator|*
name|slc_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|slc_replyp
operator|++
operator|=
name|SB
expr_stmt|;
operator|*
name|slc_replyp
operator|++
operator|=
name|TELOPT_LINEMODE
expr_stmt|;
operator|*
name|slc_replyp
operator|++
operator|=
name|LM_SLC
expr_stmt|;
block|}
end_function

begin_function
name|void
name|slc_add_reply
parameter_list|(
name|func
parameter_list|,
name|flags
parameter_list|,
name|value
parameter_list|)
name|unsigned
name|char
name|func
decl_stmt|;
name|unsigned
name|char
name|flags
decl_stmt|;
name|cc_t
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|slc_replyp
operator|++
operator|=
name|func
operator|)
operator|==
name|IAC
condition|)
operator|*
name|slc_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|slc_replyp
operator|++
operator|=
name|flags
operator|)
operator|==
name|IAC
condition|)
operator|*
name|slc_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|slc_replyp
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|value
operator|)
operator|==
name|IAC
condition|)
operator|*
name|slc_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
block|}
end_function

begin_function
name|void
name|slc_end_reply
parameter_list|()
block|{
specifier|register
name|int
name|len
decl_stmt|;
operator|*
name|slc_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|slc_replyp
operator|++
operator|=
name|SE
expr_stmt|;
name|len
operator|=
name|slc_replyp
operator|-
name|slc_reply
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|6
condition|)
return|return;
if|if
condition|(
name|NETROOM
argument_list|()
operator|>
name|len
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|slc_reply
argument_list|,
name|slc_replyp
operator|-
name|slc_reply
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|slc_reply
index|[
literal|2
index|]
argument_list|,
name|slc_replyp
operator|-
name|slc_reply
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"slc_end_reply: not enough room\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|slc_update
parameter_list|()
block|{
specifier|register
name|struct
name|spc
modifier|*
name|spcp
decl_stmt|;
name|int
name|need_update
init|=
literal|0
decl_stmt|;
for|for
control|(
name|spcp
operator|=
operator|&
name|spc_data
index|[
literal|1
index|]
init|;
name|spcp
operator|<
operator|&
name|spc_data
index|[
name|NSLC
operator|+
literal|1
index|]
condition|;
name|spcp
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|spcp
operator|->
name|flags
operator|&
name|SLC_ACK
operator|)
condition|)
continue|continue;
name|spcp
operator|->
name|flags
operator|&=
operator|~
name|SLC_ACK
expr_stmt|;
if|if
condition|(
name|spcp
operator|->
name|valp
operator|&&
operator|(
operator|*
name|spcp
operator|->
name|valp
operator|!=
name|spcp
operator|->
name|val
operator|)
condition|)
block|{
operator|*
name|spcp
operator|->
name|valp
operator|=
name|spcp
operator|->
name|val
expr_stmt|;
name|need_update
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|need_update
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OLD_ENVIRON
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ENV_HACK
end_ifdef

begin_comment
comment|/*  * Earlier version of telnet/telnetd from the BSD code had  * the definitions of VALUE and VAR reversed.  To ensure  * maximum interoperability, we assume that the server is  * an older BSD server, until proven otherwise.  The newer  * BSD servers should be able to handle either definition,  * so it is better to use the wrong values if we don't  * know what type of server it is.  */
end_comment

begin_decl_stmt
name|int
name|env_auto
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|old_env_var
init|=
name|OLD_ENV_VAR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|old_env_value
init|=
name|OLD_ENV_VALUE
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|old_env_var
value|OLD_ENV_VAR
end_define

begin_define
define|#
directive|define
name|old_env_value
value|OLD_ENV_VALUE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|env_opt
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|ep
init|=
literal|0
decl_stmt|,
modifier|*
name|epc
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0xff
condition|)
block|{
case|case
name|TELQUAL_SEND
case|:
name|env_opt_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|env_opt_add
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|buf
index|[
name|i
index|]
operator|&
literal|0xff
condition|)
block|{
ifdef|#
directive|ifdef
name|OLD_ENVIRON
case|case
name|OLD_ENV_VAR
case|:
ifdef|#
directive|ifdef
name|ENV_HACK
if|if
condition|(
name|telopt_environ
operator|==
name|TELOPT_OLD_ENVIRON
operator|&&
name|env_auto
condition|)
block|{
comment|/* Server has the same definitions */
name|old_env_var
operator|=
name|OLD_ENV_VAR
expr_stmt|;
name|old_env_value
operator|=
name|OLD_ENV_VALUE
expr_stmt|;
block|}
comment|/* FALL THROUGH */
endif|#
directive|endif
case|case
name|OLD_ENV_VALUE
case|:
comment|/* 				 * Although OLD_ENV_VALUE is not legal, we will 				 * still recognize it, just in case it is an 				 * old server that has VAR& VALUE mixed up... 				 */
comment|/* FALL THROUGH */
else|#
directive|else
case|case
name|NEW_ENV_VAR
case|:
endif|#
directive|endif
case|case
name|ENV_USERVAR
case|:
if|if
condition|(
name|ep
condition|)
block|{
operator|*
name|epc
operator|=
literal|0
expr_stmt|;
name|env_opt_add
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
name|ep
operator|=
name|epc
operator|=
operator|&
name|buf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|ENV_ESC
case|:
name|i
operator|++
expr_stmt|;
comment|/*FALL THROUGH*/
default|default:
if|if
condition|(
name|epc
condition|)
operator|*
name|epc
operator|++
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ep
condition|)
block|{
operator|*
name|epc
operator|=
literal|0
expr_stmt|;
name|env_opt_add
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
name|env_opt_end
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELQUAL_IS
case|:
case|case
name|TELQUAL_INFO
case|:
comment|/* Ignore for now.  We shouldn't get it anyway. */
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|OPT_REPLY_SIZE
value|256
end_define

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|opt_reply
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|opt_replyp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|opt_replyend
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|env_opt_start
parameter_list|()
block|{
if|if
condition|(
name|opt_reply
condition|)
name|opt_reply
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|opt_reply
argument_list|,
name|OPT_REPLY_SIZE
argument_list|)
expr_stmt|;
else|else
name|opt_reply
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|OPT_REPLY_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_reply
operator|==
name|NULL
condition|)
block|{
comment|/*@*/
name|printf
argument_list|(
literal|"env_opt_start: malloc()/realloc() failed!!!\n"
argument_list|)
expr_stmt|;
name|opt_reply
operator|=
name|opt_replyp
operator|=
name|opt_replyend
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|opt_replyp
operator|=
name|opt_reply
expr_stmt|;
name|opt_replyend
operator|=
name|opt_reply
operator|+
name|OPT_REPLY_SIZE
expr_stmt|;
operator|*
name|opt_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|opt_replyp
operator|++
operator|=
name|SB
expr_stmt|;
operator|*
name|opt_replyp
operator|++
operator|=
name|telopt_environ
expr_stmt|;
operator|*
name|opt_replyp
operator|++
operator|=
name|TELQUAL_IS
expr_stmt|;
block|}
end_function

begin_function
name|void
name|env_opt_start_info
parameter_list|()
block|{
name|env_opt_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|opt_replyp
condition|)
name|opt_replyp
index|[
operator|-
literal|1
index|]
operator|=
name|TELQUAL_INFO
expr_stmt|;
block|}
end_function

begin_function
name|void
name|env_opt_add
parameter_list|(
name|ep
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|ep
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|vp
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|opt_reply
operator|==
name|NULL
condition|)
comment|/*XXX*/
return|return;
comment|/*XXX*/
if|if
condition|(
name|ep
operator|==
name|NULL
operator|||
operator|*
name|ep
operator|==
literal|'\0'
condition|)
block|{
comment|/* Send user defined variables first. */
name|env_default
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ep
operator|=
name|env_default
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|env_opt_add
argument_list|(
name|ep
argument_list|)
expr_stmt|;
comment|/* Now add the list of well know variables.  */
name|env_default
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ep
operator|=
name|env_default
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|env_opt_add
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
name|vp
operator|=
name|env_getvalue
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_replyp
operator|+
operator|(
name|vp
condition|?
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vp
argument_list|)
else|:
literal|0
operator|)
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ep
argument_list|)
operator|+
literal|6
operator|>
name|opt_replyend
condition|)
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|opt_replyend
operator|+=
name|OPT_REPLY_SIZE
expr_stmt|;
name|len
operator|=
name|opt_replyend
operator|-
name|opt_reply
expr_stmt|;
name|opt_reply
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|opt_reply
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_reply
operator|==
name|NULL
condition|)
block|{
comment|/*@*/
name|printf
argument_list|(
literal|"env_opt_add: realloc() failed!!!\n"
argument_list|)
expr_stmt|;
name|opt_reply
operator|=
name|opt_replyp
operator|=
name|opt_replyend
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|opt_replyp
operator|=
name|opt_reply
operator|+
name|len
operator|-
operator|(
name|opt_replyend
operator|-
name|opt_replyp
operator|)
expr_stmt|;
name|opt_replyend
operator|=
name|opt_reply
operator|+
name|len
expr_stmt|;
block|}
if|if
condition|(
name|opt_welldefined
argument_list|(
name|ep
argument_list|)
condition|)
ifdef|#
directive|ifdef
name|OLD_ENVIRON
if|if
condition|(
name|telopt_environ
operator|==
name|TELOPT_OLD_ENVIRON
condition|)
operator|*
name|opt_replyp
operator|++
operator|=
name|old_env_var
expr_stmt|;
else|else
endif|#
directive|endif
operator|*
name|opt_replyp
operator|++
operator|=
name|NEW_ENV_VAR
expr_stmt|;
else|else
operator|*
name|opt_replyp
operator|++
operator|=
name|ENV_USERVAR
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|ep
operator|++
operator|)
condition|)
block|{
switch|switch
condition|(
name|c
operator|&
literal|0xff
condition|)
block|{
case|case
name|IAC
case|:
operator|*
name|opt_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
break|break;
case|case
name|NEW_ENV_VAR
case|:
case|case
name|NEW_ENV_VALUE
case|:
case|case
name|ENV_ESC
case|:
case|case
name|ENV_USERVAR
case|:
operator|*
name|opt_replyp
operator|++
operator|=
name|ENV_ESC
expr_stmt|;
break|break;
block|}
operator|*
name|opt_replyp
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ep
operator|=
name|vp
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|OLD_ENVIRON
if|if
condition|(
name|telopt_environ
operator|==
name|TELOPT_OLD_ENVIRON
condition|)
operator|*
name|opt_replyp
operator|++
operator|=
name|old_env_value
expr_stmt|;
else|else
endif|#
directive|endif
operator|*
name|opt_replyp
operator|++
operator|=
name|NEW_ENV_VALUE
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
end_function

begin_function
name|int
name|opt_welldefined
parameter_list|(
name|ep
parameter_list|)
name|char
modifier|*
name|ep
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|ep
argument_list|,
literal|"USER"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|ep
argument_list|,
literal|"DISPLAY"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|ep
argument_list|,
literal|"PRINTER"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|ep
argument_list|,
literal|"SYSTEMTYPE"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|ep
argument_list|,
literal|"JOB"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|ep
argument_list|,
literal|"ACCT"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|env_opt_end
parameter_list|(
name|emptyok
parameter_list|)
specifier|register
name|int
name|emptyok
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|len
operator|=
name|opt_replyp
operator|-
name|opt_reply
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|emptyok
operator|||
name|len
operator|>
literal|6
condition|)
block|{
operator|*
name|opt_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|opt_replyp
operator|++
operator|=
name|SE
expr_stmt|;
if|if
condition|(
name|NETROOM
argument_list|()
operator|>
name|len
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|opt_reply
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|opt_reply
index|[
literal|2
index|]
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"slc_end_reply: not enough room\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opt_reply
condition|)
block|{
name|free
argument_list|(
name|opt_reply
argument_list|)
expr_stmt|;
name|opt_reply
operator|=
name|opt_replyp
operator|=
name|opt_replyend
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|telrcv
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|scc
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|sbp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|returnValue
init|=
literal|0
decl_stmt|;
name|scc
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TTYROOM
argument_list|()
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|scc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|count
condition|)
block|{
name|ring_consumed
argument_list|(
operator|&
name|netiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|returnValue
operator|=
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|sbp
operator|=
name|netiring
operator|.
name|consume
expr_stmt|;
name|scc
operator|=
name|ring_full_consecutive
argument_list|(
operator|&
name|netiring
argument_list|)
expr_stmt|;
if|if
condition|(
name|scc
operator|==
literal|0
condition|)
block|{
comment|/* No more data coming in */
break|break;
block|}
block|}
name|c
operator|=
operator|*
name|sbp
operator|++
operator|&
literal|0xff
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|ENCRYPTION
if|if
condition|(
name|decrypt_input
condition|)
name|c
operator|=
call|(
modifier|*
name|decrypt_input
call|)
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENCRYPTION */
switch|switch
condition|(
name|telrcv_state
condition|)
block|{
case|case
name|TS_CR
case|:
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
break|break;
comment|/* Ignore \0 after CR */
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|&&
name|my_want_state_is_dont
argument_list|(
name|TELOPT_ECHO
argument_list|)
operator|&&
operator|!
name|crmod
condition|)
block|{
name|TTYADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Else, fall through */
case|case
name|TS_DATA
case|:
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|telrcv_state
operator|=
name|TS_IAC
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|In3270
condition|)
block|{
operator|*
name|Ifrontp
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|scc
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|sbp
operator|++
operator|&
literal|0377
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|ENCRYPTION
if|if
condition|(
name|decrypt_input
condition|)
name|c
operator|=
call|(
modifier|*
name|decrypt_input
call|)
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENCRYPTION */
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|telrcv_state
operator|=
name|TS_IAC
expr_stmt|;
break|break;
block|}
operator|*
name|Ifrontp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* defined(TN3270) */
comment|/* 		     * The 'crmod' hack (see following) is needed 		     * since we can't * set CRMOD on output only. 		     * Machines like MULTICS like to send \r without 		     * \n; since we must turn off CRMOD to get proper 		     * input, the mapping is done here (sigh). 		     */
if|if
condition|(
operator|(
name|c
operator|==
literal|'\r'
operator|)
operator|&&
name|my_want_state_is_dont
argument_list|(
name|TELOPT_BINARY
argument_list|)
condition|)
block|{
if|if
condition|(
name|scc
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|sbp
operator|&
literal|0xff
expr_stmt|;
ifdef|#
directive|ifdef
name|ENCRYPTION
if|if
condition|(
name|decrypt_input
condition|)
name|c
operator|=
call|(
modifier|*
name|decrypt_input
call|)
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENCRYPTION */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|sbp
operator|++
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
comment|/* a "true" CR */
name|TTYADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|my_want_state_is_dont
argument_list|(
name|TELOPT_ECHO
argument_list|)
operator|&&
operator|(
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|sbp
operator|++
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|TTYADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ENCRYPTION
if|if
condition|(
name|decrypt_input
condition|)
call|(
modifier|*
name|decrypt_input
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENCRYPTION */
name|TTYADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|crmod
condition|)
block|{
name|TTYADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|telrcv_state
operator|=
name|TS_CR
expr_stmt|;
name|TTYADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|crmod
condition|)
block|{
name|TTYADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|TTYADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|TS_IAC
case|:
name|process_iac
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|WILL
case|:
name|telrcv_state
operator|=
name|TS_WILL
expr_stmt|;
continue|continue;
case|case
name|WONT
case|:
name|telrcv_state
operator|=
name|TS_WONT
expr_stmt|;
continue|continue;
case|case
name|DO
case|:
name|telrcv_state
operator|=
name|TS_DO
expr_stmt|;
continue|continue;
case|case
name|DONT
case|:
name|telrcv_state
operator|=
name|TS_DONT
expr_stmt|;
continue|continue;
case|case
name|DM
case|:
comment|/* 		     * We may have missed an urgent notification, 		     * so make sure we flush whatever is in the 		     * buffer currently. 		     */
name|printoption
argument_list|(
literal|"RCVD"
argument_list|,
name|IAC
argument_list|,
name|DM
argument_list|)
expr_stmt|;
name|SYNCHing
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|ttyflush
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SYNCHing
operator|=
name|stilloob
argument_list|()
expr_stmt|;
name|settimer
argument_list|(
name|gotDM
argument_list|)
expr_stmt|;
break|break;
case|case
name|SB
case|:
name|SB_CLEAR
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_SB
expr_stmt|;
continue|continue;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
case|case
name|EOR
case|:
if|if
condition|(
name|In3270
condition|)
block|{
if|if
condition|(
name|Ibackp
operator|==
name|Ifrontp
condition|)
block|{
name|Ibackp
operator|=
name|Ifrontp
operator|=
name|Ibuf
expr_stmt|;
name|ISend
operator|=
literal|0
expr_stmt|;
comment|/* should have been! */
block|}
else|else
block|{
name|Ibackp
operator|+=
name|DataFromNetwork
argument_list|(
name|Ibackp
argument_list|,
name|Ifrontp
operator|-
name|Ibackp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ISend
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|printoption
argument_list|(
literal|"RCVD"
argument_list|,
name|IAC
argument_list|,
name|EOR
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(TN3270) */
case|case
name|IAC
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
name|TTYADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !defined(TN3270) */
if|if
condition|(
name|In3270
condition|)
block|{
operator|*
name|Ifrontp
operator|++
operator|=
name|IAC
expr_stmt|;
block|}
else|else
block|{
name|TTYADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined(TN3270) */
break|break;
case|case
name|NOP
case|:
case|case
name|GA
case|:
default|default:
name|printoption
argument_list|(
literal|"RCVD"
argument_list|,
name|IAC
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_WILL
case|:
name|printoption
argument_list|(
literal|"RCVD"
argument_list|,
name|WILL
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|willoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_WONT
case|:
name|printoption
argument_list|(
literal|"RCVD"
argument_list|,
name|WONT
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|wontoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_DO
case|:
name|printoption
argument_list|(
literal|"RCVD"
argument_list|,
name|DO
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|dooption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|SetIn3270
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|TELOPT_NAWS
condition|)
block|{
name|sendnaws
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|TELOPT_LFLOW
condition|)
block|{
name|localflow
operator|=
literal|1
expr_stmt|;
name|setcommandmode
argument_list|()
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_DONT
case|:
name|printoption
argument_list|(
literal|"RCVD"
argument_list|,
name|DONT
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|dontoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* set new tty mode (maybe) */
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_SB
case|:
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|telrcv_state
operator|=
name|TS_SE
expr_stmt|;
block|}
else|else
block|{
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|TS_SE
case|:
if|if
condition|(
name|c
operator|!=
name|SE
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|IAC
condition|)
block|{
comment|/* 		     * This is an error.  We only expect to get 		     * "IAC IAC" or "IAC SE".  Several things may 		     * have happend.  An IAC was not doubled, the 		     * IAC SE was left off, or another option got 		     * inserted into the suboption are all possibilities. 		     * If we assume that the IAC was not doubled, 		     * and really the IAC SE was left off, we could 		     * get into an infinate loop here.  So, instead, 		     * we terminate the suboption, and process the 		     * partial suboption if we can. 		     */
name|SB_ACCUM
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|subpointer
operator|-=
literal|2
expr_stmt|;
name|SB_TERM
argument_list|()
expr_stmt|;
name|printoption
argument_list|(
literal|"In SUBOPTION processing, RCVD"
argument_list|,
name|IAC
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|suboption
argument_list|()
expr_stmt|;
comment|/* handle sub-option */
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_IAC
expr_stmt|;
goto|goto
name|process_iac
goto|;
block|}
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|telrcv_state
operator|=
name|TS_SB
expr_stmt|;
block|}
else|else
block|{
name|SB_ACCUM
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|SB_ACCUM
argument_list|(
name|SE
argument_list|)
expr_stmt|;
name|subpointer
operator|-=
literal|2
expr_stmt|;
name|SB_TERM
argument_list|()
expr_stmt|;
name|suboption
argument_list|()
expr_stmt|;
comment|/* handle sub-option */
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|count
condition|)
name|ring_consumed
argument_list|(
operator|&
name|netiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|returnValue
operator|||
name|count
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|bol
init|=
literal|1
decl_stmt|,
name|local
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|rlogin_susp
parameter_list|()
block|{
if|if
condition|(
name|local
condition|)
block|{
name|local
operator|=
literal|0
expr_stmt|;
name|bol
operator|=
literal|1
expr_stmt|;
name|command
argument_list|(
literal|0
argument_list|,
literal|"z\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|telsnd
parameter_list|()
block|{
name|int
name|tcc
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|returnValue
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tbp
decl_stmt|;
name|tcc
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|NETROOM
argument_list|()
operator|>
literal|2
condition|)
block|{
specifier|register
name|int
name|sc
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|tcc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|count
condition|)
block|{
name|ring_consumed
argument_list|(
operator|&
name|ttyiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|returnValue
operator|=
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|tbp
operator|=
name|ttyiring
operator|.
name|consume
expr_stmt|;
name|tcc
operator|=
name|ring_full_consecutive
argument_list|(
operator|&
name|ttyiring
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcc
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|c
operator|=
operator|*
name|tbp
operator|++
operator|&
literal|0xff
operator|,
name|sc
operator|=
name|strip
argument_list|(
name|c
argument_list|)
operator|,
name|tcc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|rlogin
operator|!=
name|_POSIX_VDISABLE
condition|)
block|{
if|if
condition|(
name|bol
condition|)
block|{
name|bol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|rlogin
condition|)
block|{
name|local
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|local
condition|)
block|{
name|local
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|==
literal|'.'
operator|||
name|c
operator|==
name|termEofChar
condition|)
block|{
name|bol
operator|=
literal|1
expr_stmt|;
name|command
argument_list|(
literal|0
argument_list|,
literal|"close\n"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sc
operator|==
name|termSuspChar
condition|)
block|{
name|bol
operator|=
literal|1
expr_stmt|;
name|command
argument_list|(
literal|0
argument_list|,
literal|"z\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sc
operator|==
name|escape
condition|)
block|{
name|command
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tbp
argument_list|,
name|tcc
argument_list|)
expr_stmt|;
name|bol
operator|=
literal|1
expr_stmt|;
name|count
operator|+=
name|tcc
expr_stmt|;
name|tcc
operator|=
literal|0
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sc
operator|!=
name|rlogin
condition|)
block|{
operator|++
name|tcc
expr_stmt|;
operator|--
name|tbp
expr_stmt|;
operator|--
name|count
expr_stmt|;
name|c
operator|=
name|sc
operator|=
name|rlogin
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|sc
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|sc
operator|==
literal|'\r'
operator|)
condition|)
name|bol
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|escape
operator|!=
name|_POSIX_VDISABLE
operator|&&
name|sc
operator|==
name|escape
condition|)
block|{
comment|/* 	     * Double escape is a pass through of a single escape character. 	     */
if|if
condition|(
name|tcc
operator|&&
name|strip
argument_list|(
operator|*
name|tbp
argument_list|)
operator|==
name|escape
condition|)
block|{
name|tbp
operator|++
expr_stmt|;
name|tcc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|bol
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|command
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tbp
argument_list|,
name|tcc
argument_list|)
expr_stmt|;
name|bol
operator|=
literal|1
expr_stmt|;
name|count
operator|+=
name|tcc
expr_stmt|;
name|tcc
operator|=
literal|0
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
name|bol
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
if|if
condition|(
name|kludgelinemode
operator|&&
operator|(
name|globalmode
operator|&
name|MODE_EDIT
operator|)
operator|&&
operator|(
name|sc
operator|==
name|echoc
operator|)
condition|)
block|{
if|if
condition|(
name|tcc
operator|>
literal|0
operator|&&
name|strip
argument_list|(
operator|*
name|tbp
argument_list|)
operator|==
name|echoc
condition|)
block|{
name|tcc
operator|--
expr_stmt|;
name|tbp
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|dontlecho
operator|=
operator|!
name|dontlecho
expr_stmt|;
name|settimer
argument_list|(
name|echotoggle
argument_list|)
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|MODE_LOCAL_CHARS
argument_list|(
name|globalmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|TerminalSpecialChars
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bol
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_BINARY
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* 		     * If we are in CRMOD mode (\r ==> \n) 		     * on our local machine, then probably 		     * a newline (unix) is CRLF (TELNET). 		     */
if|if
condition|(
name|MODE_LOCAL_CHARS
argument_list|(
name|globalmode
argument_list|)
condition|)
block|{
name|NETADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
name|NETADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|bol
operator|=
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
if|if
condition|(
operator|!
name|crlf
condition|)
block|{
name|NET2ADD
argument_list|(
literal|'\r'
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NET2ADD
argument_list|(
literal|'\r'
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|bol
operator|=
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IAC
case|:
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|IAC
argument_list|)
expr_stmt|;
break|break;
default|default:
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|IAC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
condition|)
name|ring_consumed
argument_list|(
operator|&
name|ttyiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|returnValue
operator|||
name|count
return|;
comment|/* Non-zero if we did anything */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Scheduler()  *  * Try to do something.  *  * If we do something useful, return 1; else return 0.  *  */
end_comment

begin_function
name|int
name|Scheduler
parameter_list|(
name|block
parameter_list|)
name|int
name|block
decl_stmt|;
comment|/* should we block in the select ? */
block|{
comment|/* One wants to be a bit careful about setting returnValue 		 * to one, since a one implies we did some useful work, 		 * and therefore probably won't be called to block next 		 * time (TN3270 mode only). 		 */
name|int
name|returnValue
decl_stmt|;
name|int
name|netin
decl_stmt|,
name|netout
decl_stmt|,
name|netex
decl_stmt|,
name|ttyin
decl_stmt|,
name|ttyout
decl_stmt|;
comment|/* Decide which rings should be processed */
name|netout
operator|=
name|ring_full_count
argument_list|(
operator|&
name|netoring
argument_list|)
operator|&&
operator|(
name|flushline
operator|||
operator|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
operator|&&
operator|(
operator|!
name|kludgelinemode
operator|||
name|my_want_state_is_do
argument_list|(
name|TELOPT_SGA
argument_list|)
operator|)
endif|#
directive|endif
operator|)
operator|||
name|my_want_state_is_will
argument_list|(
name|TELOPT_BINARY
argument_list|)
operator|)
expr_stmt|;
name|ttyout
operator|=
name|ring_full_count
argument_list|(
operator|&
name|ttyoring
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
name|ttyin
operator|=
name|ring_empty_count
argument_list|(
operator|&
name|ttyiring
argument_list|)
operator|&&
operator|(
name|clienteof
operator|==
literal|0
operator|)
operator|&&
operator|(
name|shell_active
operator|==
literal|0
operator|)
expr_stmt|;
else|#
directive|else
comment|/* defined(TN3270) */
name|ttyin
operator|=
name|ring_empty_count
argument_list|(
operator|&
name|ttyiring
argument_list|)
operator|&&
operator|(
name|clienteof
operator|==
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(TN3270) */
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
name|netin
operator|=
name|ring_empty_count
argument_list|(
operator|&
name|netiring
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !defined(TN3270) */
name|netin
operator|=
operator|!
name|ISend
operator|&&
name|ring_empty_count
argument_list|(
operator|&
name|netiring
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(TN3270) */
name|netex
operator|=
operator|!
name|SYNCHing
expr_stmt|;
comment|/* If we have seen a signal recently, reset things */
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
operator|&&
name|defined
argument_list|(
name|unix
argument_list|)
if|if
condition|(
name|HaveInput
condition|)
block|{
name|HaveInput
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|inputAvailable
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(TN3270)&& defined(unix) */
comment|/* Call to system code to process rings */
name|returnValue
operator|=
name|process_rings
argument_list|(
name|netin
argument_list|,
name|netout
argument_list|,
name|netex
argument_list|,
name|ttyin
argument_list|,
name|ttyout
argument_list|,
operator|!
name|block
argument_list|)
expr_stmt|;
comment|/* Now, look at the input rings, looking for work to do. */
if|if
condition|(
name|ring_full_count
argument_list|(
operator|&
name|ttyiring
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|In3270
condition|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|DataFromTerminal
argument_list|(
name|ttyiring
operator|.
name|consume
argument_list|,
name|ring_full_consecutive
argument_list|(
operator|&
name|ttyiring
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|returnValue
operator|=
literal|1
expr_stmt|;
name|ring_consumed
argument_list|(
operator|&
name|ttyiring
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* defined(TN3270) */
name|returnValue
operator||=
name|telsnd
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
block|}
endif|#
directive|endif
comment|/* defined(TN3270) */
block|}
if|if
condition|(
name|ring_full_count
argument_list|(
operator|&
name|netiring
argument_list|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
name|returnValue
operator||=
name|telrcv
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* !defined(TN3270) */
name|returnValue
operator|=
name|Push3270
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(TN3270) */
block|}
return|return
name|returnValue
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Select from tty and network...  */
end_comment

begin_function
name|void
name|telnet
parameter_list|(
name|user
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|;
block|{
name|sys_telnet_init
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
operator|||
name|defined
argument_list|(
name|ENCRYPTION
argument_list|)
block|{
specifier|static
name|char
name|local_host
index|[
literal|256
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|local_host
index|[
literal|0
index|]
condition|)
block|{
name|gethostname
argument_list|(
name|local_host
argument_list|,
sizeof|sizeof
argument_list|(
name|local_host
argument_list|)
argument_list|)
expr_stmt|;
name|local_host
index|[
sizeof|sizeof
argument_list|(
name|local_host
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|auth_encrypt_init
argument_list|(
name|local_host
argument_list|,
name|hostname
argument_list|,
literal|"TELNET"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|auth_encrypt_user
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(AUTHENTICATION) || defined(ENCRYPTION)  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|telnetport
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
if|if
condition|(
name|autologin
condition|)
name|send_will
argument_list|(
name|TELOPT_AUTHENTICATION
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENCRYPTION
name|send_do
argument_list|(
name|TELOPT_ENCRYPT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_ENCRYPT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENCRYPTION */
name|send_do
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_TTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_NAWS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_TSPEED
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_LFLOW
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_LINEMODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_NEW_ENVIRON
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_do
argument_list|(
name|TELOPT_STATUS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_getvalue
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"DISPLAY"
argument_list|)
condition|)
name|send_will
argument_list|(
name|TELOPT_XDISPLOC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|eight
condition|)
name|tel_enter_binary
argument_list|(
name|eight
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined(TN3270) */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|schedValue
decl_stmt|;
while|while
condition|(
operator|(
name|schedValue
operator|=
name|Scheduler
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|schedValue
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|Scheduler
argument_list|(
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|#
directive|else
comment|/* !defined(TN3270) */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|schedValue
decl_stmt|;
while|while
condition|(
operator|!
name|In3270
operator|&&
operator|!
name|shell_active
condition|)
block|{
if|if
condition|(
name|Scheduler
argument_list|(
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
while|while
condition|(
operator|(
name|schedValue
operator|=
name|Scheduler
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|schedValue
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* If there is data waiting to go out to terminal, don't 		 * schedule any more data for the terminal. 		 */
if|if
condition|(
name|ring_full_count
argument_list|(
operator|&
name|ttyoring
argument_list|)
condition|)
block|{
name|schedValue
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|shell_active
condition|)
block|{
if|if
condition|(
name|shell_continue
argument_list|()
operator|==
literal|0
condition|)
block|{
name|ConnectScreen
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|In3270
condition|)
block|{
name|schedValue
operator|=
name|DoTerminalOutput
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|schedValue
operator|&&
operator|(
name|shell_active
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|Scheduler
argument_list|(
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* !defined(TN3270) */
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXX - this not being in is a bug */
end_comment

begin_comment
comment|/*  * nextitem()  *  *	Return the address of the next "item" in the TELNET data  * stream.  This will be the address of the next character if  * the current address is a user data character, or it will  * be the address of the character following the TELNET command  * if the current address is a TELNET IAC ("I Am a Command")  * character.  */
end_comment

begin_comment
unit|static char * nextitem(current)     char *current; {     if ((*current&0xff) != IAC) { 	return current+1;     }     switch (*(current+1)&0xff) {     case DO:     case DONT:     case WILL:     case WONT: 	return current+3;     case SB:
comment|/* loop forever looking for the SE */
end_comment

begin_endif
unit|{ 	    register char *look = current+2;  	    for (;;) { 		if ((*look++&0xff) == IAC) { 		    if ((*look++&0xff) == SE) { 			return look; 		    } 		} 	    } 	}     default: 	return current+2;     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/*  * netclear()  *  *	We are about to do a TELNET SYNCH operation.  Clear  * the path to the network.  *  *	Things are a bit tricky since we may have sent the first  * byte or so of a previous TELNET command into the network.  * So, we have to scan the network buffer from the beginning  * until we are up to where we want to be.  *  *	A side effect of what we do, just to keep things  * simple, is to clear the urgent data pointer.  The principal  * caller should be setting the urgent data pointer AFTER calling  * us in any case.  */
end_comment

begin_function
specifier|static
name|void
name|netclear
parameter_list|()
block|{
if|#
directive|if
literal|0
comment|/* XXX */
block|register char *thisitem, *next;     char *good;
define|#
directive|define
name|wewant
parameter_list|(
name|p
parameter_list|)
value|((nfrontp> p)&& ((*p&0xff) == IAC)&& \ 				((*(p+1)&0xff) != EC)&& ((*(p+1)&0xff) != EL))
block|thisitem = netobuf;      while ((next = nextitem(thisitem))<= netobuf.send) { 	thisitem = next;     }
comment|/* Now, thisitem is first before/at boundary. */
block|good = netobuf;
comment|/* where the good bytes go */
block|while (netoring.add> thisitem) { 	if (wewant(thisitem)) { 	    int length;  	    next = thisitem; 	    do { 		next = nextitem(next); 	    } while (wewant(next)&& (nfrontp> next)); 	    length = next-thisitem; 	    memmove(good, thisitem, length); 	    good += length; 	    thisitem = next; 	} else { 	    thisitem = nextitem(thisitem); 	}     }
endif|#
directive|endif
comment|/* 0 */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * These routines add various telnet commands to the data stream.  */
end_comment

begin_function
specifier|static
name|void
name|doflush
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|DO
argument_list|)
expr_stmt|;
name|NETADD
argument_list|(
name|TELOPT_TM
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
name|flushout
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|ttyflush
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Flush/drop output */
comment|/* do printoption AFTER flush, otherwise the output gets tossed... */
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
name|DO
argument_list|,
name|TELOPT_TM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xmitAO
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|AO
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
name|IAC
argument_list|,
name|AO
argument_list|)
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xmitEL
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|EL
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
name|IAC
argument_list|,
name|EL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xmitEC
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|EC
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
name|IAC
argument_list|,
name|EC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dosynch
parameter_list|()
block|{
name|netclear
argument_list|()
expr_stmt|;
comment|/* clear the path to the network */
name|NETADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|setneturg
argument_list|()
expr_stmt|;
name|NETADD
argument_list|(
name|DM
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
name|IAC
argument_list|,
name|DM
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
name|int
name|want_status_response
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|get_status
parameter_list|()
block|{
name|unsigned
name|char
name|tmp
index|[
literal|16
index|]
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|my_want_state_is_dont
argument_list|(
name|TELOPT_STATUS
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Remote side does not support STATUS option\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cp
operator|=
name|tmp
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|SB
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|TELOPT_STATUS
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|TELQUAL_SEND
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|SE
expr_stmt|;
if|if
condition|(
name|NETROOM
argument_list|()
operator|>=
name|cp
operator|-
name|tmp
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|tmp
argument_list|,
name|cp
operator|-
name|tmp
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
name|tmp
operator|+
literal|2
argument_list|,
name|cp
operator|-
name|tmp
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
operator|++
name|want_status_response
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|intp
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|IP
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
name|IAC
argument_list|,
name|IP
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|autosynch
condition|)
block|{
name|dosynch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sendbrk
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|BREAK
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
name|IAC
argument_list|,
name|BREAK
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|autosynch
condition|)
block|{
name|dosynch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sendabort
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|ABORT
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
name|IAC
argument_list|,
name|ABORT
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|autosynch
condition|)
block|{
name|dosynch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sendsusp
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|SUSP
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
name|IAC
argument_list|,
name|SUSP
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|autosynch
condition|)
block|{
name|dosynch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sendeof
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|xEOF
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
name|IAC
argument_list|,
name|xEOF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sendayt
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|AYT
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
name|IAC
argument_list|,
name|AYT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a window size update to the remote system.  */
end_comment

begin_function
name|void
name|sendnaws
parameter_list|()
block|{
name|long
name|rows
decl_stmt|,
name|cols
decl_stmt|;
name|unsigned
name|char
name|tmp
index|[
literal|16
index|]
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|my_state_is_wont
argument_list|(
name|TELOPT_NAWS
argument_list|)
condition|)
return|return;
define|#
directive|define
name|PUTSHORT
parameter_list|(
name|cp
parameter_list|,
name|x
parameter_list|)
value|{ if ((*cp++ = ((x)>>8)&0xff) == IAC) *cp++ = IAC; \ 			    if ((*cp++ = ((x))&0xff) == IAC) *cp++ = IAC; }
if|if
condition|(
name|TerminalWindowSize
argument_list|(
operator|&
name|rows
argument_list|,
operator|&
name|cols
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Failed */
return|return;
block|}
name|cp
operator|=
name|tmp
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|SB
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|TELOPT_NAWS
expr_stmt|;
name|PUTSHORT
argument_list|(
name|cp
argument_list|,
name|cols
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|cp
argument_list|,
name|rows
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|SE
expr_stmt|;
if|if
condition|(
name|NETROOM
argument_list|()
operator|>=
name|cp
operator|-
name|tmp
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|tmp
argument_list|,
name|cp
operator|-
name|tmp
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
name|tmp
operator|+
literal|2
argument_list|,
name|cp
operator|-
name|tmp
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tel_enter_binary
parameter_list|(
name|rw
parameter_list|)
name|int
name|rw
decl_stmt|;
block|{
if|if
condition|(
name|rw
operator|&
literal|1
condition|)
name|send_do
argument_list|(
name|TELOPT_BINARY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|&
literal|2
condition|)
name|send_will
argument_list|(
name|TELOPT_BINARY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tel_leave_binary
parameter_list|(
name|rw
parameter_list|)
name|int
name|rw
decl_stmt|;
block|{
if|if
condition|(
name|rw
operator|&
literal|1
condition|)
name|send_dont
argument_list|(
name|TELOPT_BINARY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|&
literal|2
condition|)
name|send_wont
argument_list|(
name|TELOPT_BINARY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

