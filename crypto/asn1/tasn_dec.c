begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tasn_dec.c */
end_comment

begin_comment
comment|/* Written by Dr Stephen N Henson (shenson@bigfoot.com) for the OpenSSL  * project 2000.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/asn1.h>
end_include

begin_include
include|#
directive|include
file|<openssl/asn1t.h>
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_include
include|#
directive|include
file|<openssl/buffer.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_function_decl
specifier|static
name|int
name|asn1_check_eoc
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asn1_find_end
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
name|char
name|inf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asn1_collect
parameter_list|(
name|BUF_MEM
modifier|*
name|buf
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
name|char
name|inf
parameter_list|,
name|int
name|tag
parameter_list|,
name|int
name|aclass
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|collect_data
parameter_list|(
name|BUF_MEM
modifier|*
name|buf
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|long
name|plen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asn1_check_tlen
parameter_list|(
name|long
modifier|*
name|olen
parameter_list|,
name|int
modifier|*
name|otag
parameter_list|,
name|unsigned
name|char
modifier|*
name|oclass
parameter_list|,
name|char
modifier|*
name|inf
parameter_list|,
name|char
modifier|*
name|cst
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
name|int
name|exptag
parameter_list|,
name|int
name|expclass
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asn1_template_ex_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asn1_template_noexp_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|val
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asn1_d2i_ex_primitive
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|,
name|int
name|tag
parameter_list|,
name|int
name|aclass
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Table to convert tags to bit values, used for MSTRING type */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|long
name|tag2bit
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|B_ASN1_BIT_STRING
block|,
comment|/* tags  0 -  3 */
name|B_ASN1_OCTET_STRING
block|,
literal|0
block|,
literal|0
block|,
name|B_ASN1_UNKNOWN
block|,
comment|/* tags  4- 7 */
name|B_ASN1_UNKNOWN
block|,
name|B_ASN1_UNKNOWN
block|,
name|B_ASN1_UNKNOWN
block|,
name|B_ASN1_UNKNOWN
block|,
comment|/* tags  8-11 */
name|B_ASN1_UTF8STRING
block|,
name|B_ASN1_UNKNOWN
block|,
name|B_ASN1_UNKNOWN
block|,
name|B_ASN1_UNKNOWN
block|,
comment|/* tags 12-15 */
name|B_ASN1_SEQUENCE
block|,
literal|0
block|,
name|B_ASN1_NUMERICSTRING
block|,
name|B_ASN1_PRINTABLESTRING
block|,
comment|/* tags 16-19 */
name|B_ASN1_T61STRING
block|,
name|B_ASN1_VIDEOTEXSTRING
block|,
name|B_ASN1_IA5STRING
block|,
comment|/* tags 20-22 */
name|B_ASN1_UTCTIME
block|,
name|B_ASN1_GENERALIZEDTIME
block|,
comment|/* tags 23-24 */
name|B_ASN1_GRAPHICSTRING
block|,
name|B_ASN1_ISO64STRING
block|,
name|B_ASN1_GENERALSTRING
block|,
comment|/* tags 25-27 */
name|B_ASN1_UNIVERSALSTRING
block|,
name|B_ASN1_UNKNOWN
block|,
name|B_ASN1_BMPSTRING
block|,
name|B_ASN1_UNKNOWN
block|,
comment|/* tags 28-31 */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|unsigned
name|long
name|ASN1_tag2bit
parameter_list|(
name|int
name|tag
parameter_list|)
block|{
if|if
condition|(
operator|(
name|tag
operator|<
literal|0
operator|)
operator|||
operator|(
name|tag
operator|>
literal|30
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|tag2bit
index|[
name|tag
index|]
return|;
block|}
end_function

begin_comment
comment|/* Macro to initialize and invalidate the cache */
end_comment

begin_define
define|#
directive|define
name|asn1_tlc_clear
parameter_list|(
name|c
parameter_list|)
value|if (c) (c)->valid = 0
end_define

begin_comment
comment|/* Decode an ASN1 item, this currently behaves just   * like a standard 'd2i' function. 'in' points to   * a buffer to read the data from, in future we will  * have more advanced versions that can input data  * a piece at a time and this will simply be a special  * case.  */
end_comment

begin_function
name|ASN1_VALUE
modifier|*
name|ASN1_item_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
block|{
name|ASN1_TLC
name|c
decl_stmt|;
name|ASN1_VALUE
modifier|*
name|ptmpval
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|pval
condition|)
name|pval
operator|=
operator|&
name|ptmpval
expr_stmt|;
name|asn1_tlc_clear
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASN1_item_ex_d2i
argument_list|(
name|pval
argument_list|,
name|in
argument_list|,
name|len
argument_list|,
name|it
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|c
argument_list|)
operator|>
literal|0
condition|)
return|return
operator|*
name|pval
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|ASN1_template_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|)
block|{
name|ASN1_TLC
name|c
decl_stmt|;
name|asn1_tlc_clear
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
return|return
name|asn1_template_ex_d2i
argument_list|(
name|pval
argument_list|,
name|in
argument_list|,
name|len
argument_list|,
name|tt
argument_list|,
literal|0
argument_list|,
operator|&
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Decode an item, taking care of IMPLICIT tagging, if any.  * If 'opt' set and tag mismatch return -1 to handle OPTIONAL  */
end_comment

begin_function
name|int
name|ASN1_item_ex_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|,
name|int
name|tag
parameter_list|,
name|int
name|aclass
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
decl_stmt|,
modifier|*
name|errtt
init|=
name|NULL
decl_stmt|;
specifier|const
name|ASN1_COMPAT_FUNCS
modifier|*
name|cf
decl_stmt|;
specifier|const
name|ASN1_EXTERN_FUNCS
modifier|*
name|ef
decl_stmt|;
specifier|const
name|ASN1_AUX
modifier|*
name|aux
init|=
name|it
operator|->
name|funcs
decl_stmt|;
name|ASN1_aux_cb
modifier|*
name|asn1_cb
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|char
modifier|*
name|wp
init|=
name|NULL
decl_stmt|;
comment|/* BIG FAT WARNING!  BREAKS CONST WHERE USED */
name|unsigned
name|char
name|imphack
init|=
literal|0
decl_stmt|,
name|oclass
decl_stmt|;
name|char
name|seq_eoc
decl_stmt|,
name|seq_nolen
decl_stmt|,
name|cst
decl_stmt|,
name|isopt
decl_stmt|;
name|long
name|tmplen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|otag
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|ASN1_VALUE
modifier|*
name|pchval
decl_stmt|,
modifier|*
modifier|*
name|pchptr
decl_stmt|,
modifier|*
name|ptmpval
decl_stmt|;
if|if
condition|(
operator|!
name|pval
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|aux
operator|&&
name|aux
operator|->
name|asn1_cb
condition|)
name|asn1_cb
operator|=
name|aux
operator|->
name|asn1_cb
expr_stmt|;
else|else
name|asn1_cb
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|it
operator|->
name|itype
condition|)
block|{
case|case
name|ASN1_ITYPE_PRIMITIVE
case|:
if|if
condition|(
name|it
operator|->
name|templates
condition|)
block|{
comment|/* tagging or OPTIONAL is currently illegal on an item 			 * template because the flags can't get passed down. 			 * In practice this isn't a problem: we include the 			 * relevant flags from the item template in the 			 * template itself. 			 */
if|if
condition|(
operator|(
name|tag
operator|!=
operator|-
literal|1
operator|)
operator|||
name|opt
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
name|asn1_template_ex_d2i
argument_list|(
name|pval
argument_list|,
name|in
argument_list|,
name|len
argument_list|,
name|it
operator|->
name|templates
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
return|;
block|}
return|return
name|asn1_d2i_ex_primitive
argument_list|(
name|pval
argument_list|,
name|in
argument_list|,
name|len
argument_list|,
name|it
argument_list|,
name|tag
argument_list|,
name|aclass
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
return|;
break|break;
case|case
name|ASN1_ITYPE_MSTRING
case|:
name|p
operator|=
operator|*
name|in
expr_stmt|;
comment|/* Just read in tag and class */
name|ret
operator|=
name|asn1_check_tlen
argument_list|(
name|NULL
argument_list|,
operator|&
name|otag
argument_list|,
operator|&
name|oclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Must be UNIVERSAL class */
if|if
condition|(
name|oclass
operator|!=
name|V_ASN1_UNIVERSAL
condition|)
block|{
comment|/* If OPTIONAL, assume this is OK */
if|if
condition|(
name|opt
condition|)
return|return
operator|-
literal|1
return|;
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_MSTRING_NOT_UNIVERSAL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Check tag matches bit map */
if|if
condition|(
operator|!
operator|(
name|ASN1_tag2bit
argument_list|(
name|otag
argument_list|)
operator|&
name|it
operator|->
name|utype
operator|)
condition|)
block|{
comment|/* If OPTIONAL, assume this is OK */
if|if
condition|(
name|opt
condition|)
return|return
operator|-
literal|1
return|;
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_MSTRING_WRONG_TAG
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
name|asn1_d2i_ex_primitive
argument_list|(
name|pval
argument_list|,
name|in
argument_list|,
name|len
argument_list|,
name|it
argument_list|,
name|otag
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ctx
argument_list|)
return|;
case|case
name|ASN1_ITYPE_EXTERN
case|:
comment|/* Use new style d2i */
name|ef
operator|=
name|it
operator|->
name|funcs
expr_stmt|;
return|return
name|ef
operator|->
name|asn1_ex_d2i
argument_list|(
name|pval
argument_list|,
name|in
argument_list|,
name|len
argument_list|,
name|it
argument_list|,
name|tag
argument_list|,
name|aclass
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
return|;
case|case
name|ASN1_ITYPE_COMPAT
case|:
comment|/* we must resort to old style evil hackery */
name|cf
operator|=
name|it
operator|->
name|funcs
expr_stmt|;
comment|/* If OPTIONAL see if it is there */
if|if
condition|(
name|opt
condition|)
block|{
name|int
name|exptag
decl_stmt|;
name|p
operator|=
operator|*
name|in
expr_stmt|;
if|if
condition|(
name|tag
operator|==
operator|-
literal|1
condition|)
name|exptag
operator|=
name|it
operator|->
name|utype
expr_stmt|;
else|else
name|exptag
operator|=
name|tag
expr_stmt|;
comment|/* Don't care about anything other than presence 			 * of expected tag */
name|ret
operator|=
name|asn1_check_tlen
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|exptag
argument_list|,
name|aclass
argument_list|,
literal|1
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* This is the old style evil hack IMPLICIT handling: 		 * since the underlying code is expecting a tag and 		 * class other than the one present we change the 		 * buffer temporarily then change it back afterwards. 		 * This doesn't and never did work for tags> 30. 		 * 		 * Yes this is *horrible* but it is only needed for 		 * old style d2i which will hopefully not be around 		 * for much longer. 		 * FIXME: should copy the buffer then modify it so 		 * the input buffer can be const: we should *always* 		 * copy because the old style d2i might modify the 		 * buffer. 		 */
if|if
condition|(
name|tag
operator|!=
operator|-
literal|1
condition|)
block|{
name|wp
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|in
expr_stmt|;
name|imphack
operator|=
operator|*
name|wp
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|*
name|wp
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
operator|*
name|p
operator|&
name|V_ASN1_CONSTRUCTED
operator|)
operator||
name|it
operator|->
name|utype
argument_list|)
expr_stmt|;
block|}
name|ptmpval
operator|=
name|cf
operator|->
name|asn1_d2i
argument_list|(
name|pval
argument_list|,
name|in
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
operator|-
literal|1
condition|)
operator|*
name|wp
operator|=
name|imphack
expr_stmt|;
if|if
condition|(
name|ptmpval
condition|)
return|return
literal|1
return|;
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
case|case
name|ASN1_ITYPE_CHOICE
case|:
if|if
condition|(
name|asn1_cb
operator|&&
operator|!
name|asn1_cb
argument_list|(
name|ASN1_OP_D2I_PRE
argument_list|,
name|pval
argument_list|,
name|it
argument_list|)
condition|)
goto|goto
name|auxerr
goto|;
comment|/* Allocate structure */
if|if
condition|(
operator|!
operator|*
name|pval
operator|&&
operator|!
name|ASN1_item_ex_new
argument_list|(
name|pval
argument_list|,
name|it
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* CHOICE type, try each possibility in turn */
name|pchval
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
operator|*
name|in
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tt
operator|=
name|it
operator|->
name|templates
init|;
name|i
operator|<
name|it
operator|->
name|tcount
condition|;
name|i
operator|++
operator|,
name|tt
operator|++
control|)
block|{
name|pchptr
operator|=
name|asn1_get_field_ptr
argument_list|(
name|pval
argument_list|,
name|tt
argument_list|)
expr_stmt|;
comment|/* We mark field as OPTIONAL so its absence 			 * can be recognised. 			 */
name|ret
operator|=
name|asn1_template_ex_d2i
argument_list|(
name|pchptr
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|tt
argument_list|,
literal|1
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* If field not present, try the next one */
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* If positive return, read OK, break loop */
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
break|break;
comment|/* Otherwise must be an ASN1 parsing error */
name|errtt
operator|=
name|tt
expr_stmt|;
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Did we fall off the end without reading anything? */
if|if
condition|(
name|i
operator|==
name|it
operator|->
name|tcount
condition|)
block|{
comment|/* If OPTIONAL, this is OK */
if|if
condition|(
name|opt
condition|)
block|{
comment|/* Free and zero it */
name|ASN1_item_ex_free
argument_list|(
name|pval
argument_list|,
name|it
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_NO_MATCHING_CHOICE_TYPE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|asn1_set_choice_selector
argument_list|(
name|pval
argument_list|,
name|i
argument_list|,
name|it
argument_list|)
expr_stmt|;
operator|*
name|in
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|asn1_cb
operator|&&
operator|!
name|asn1_cb
argument_list|(
name|ASN1_OP_D2I_POST
argument_list|,
name|pval
argument_list|,
name|it
argument_list|)
condition|)
goto|goto
name|auxerr
goto|;
return|return
literal|1
return|;
case|case
name|ASN1_ITYPE_NDEF_SEQUENCE
case|:
case|case
name|ASN1_ITYPE_SEQUENCE
case|:
name|p
operator|=
operator|*
name|in
expr_stmt|;
name|tmplen
operator|=
name|len
expr_stmt|;
comment|/* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */
if|if
condition|(
name|tag
operator|==
operator|-
literal|1
condition|)
block|{
name|tag
operator|=
name|V_ASN1_SEQUENCE
expr_stmt|;
name|aclass
operator|=
name|V_ASN1_UNIVERSAL
expr_stmt|;
block|}
comment|/* Get SEQUENCE length and update len, p */
name|ret
operator|=
name|asn1_check_tlen
argument_list|(
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|seq_eoc
argument_list|,
operator|&
name|cst
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|tag
argument_list|,
name|aclass
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|aux
operator|&&
operator|(
name|aux
operator|->
name|flags
operator|&
name|ASN1_AFLG_BROKEN
operator|)
condition|)
block|{
name|len
operator|=
name|tmplen
operator|-
operator|(
name|p
operator|-
operator|*
name|in
operator|)
expr_stmt|;
name|seq_nolen
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If indefinite we don't do a length check */
else|else
name|seq_nolen
operator|=
name|seq_eoc
expr_stmt|;
if|if
condition|(
operator|!
name|cst
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_SEQUENCE_NOT_CONSTRUCTED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
operator|*
name|pval
operator|&&
operator|!
name|ASN1_item_ex_new
argument_list|(
name|pval
argument_list|,
name|it
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|asn1_cb
operator|&&
operator|!
name|asn1_cb
argument_list|(
name|ASN1_OP_D2I_PRE
argument_list|,
name|pval
argument_list|,
name|it
argument_list|)
condition|)
goto|goto
name|auxerr
goto|;
comment|/* Get each field entry */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tt
operator|=
name|it
operator|->
name|templates
init|;
name|i
operator|<
name|it
operator|->
name|tcount
condition|;
name|i
operator|++
operator|,
name|tt
operator|++
control|)
block|{
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|seqtt
decl_stmt|;
name|ASN1_VALUE
modifier|*
modifier|*
name|pseqval
decl_stmt|;
name|seqtt
operator|=
name|asn1_do_adb
argument_list|(
name|pval
argument_list|,
name|tt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seqtt
condition|)
goto|goto
name|err
goto|;
name|pseqval
operator|=
name|asn1_get_field_ptr
argument_list|(
name|pval
argument_list|,
name|seqtt
argument_list|)
expr_stmt|;
comment|/* Have we ran out of data? */
if|if
condition|(
operator|!
name|len
condition|)
break|break;
name|q
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|asn1_check_eoc
argument_list|(
operator|&
name|p
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|seq_eoc
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_UNEXPECTED_EOC
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|len
operator|-=
name|p
operator|-
name|q
expr_stmt|;
name|seq_eoc
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
break|break;
block|}
comment|/* This determines the OPTIONAL flag value. The field 			 * cannot be omitted if it is the last of a SEQUENCE 			 * and there is still data to be read. This isn't 			 * strictly necessary but it increases efficiency in 			 * some cases. 			 */
if|if
condition|(
name|i
operator|==
operator|(
name|it
operator|->
name|tcount
operator|-
literal|1
operator|)
condition|)
name|isopt
operator|=
literal|0
expr_stmt|;
else|else
name|isopt
operator|=
call|(
name|char
call|)
argument_list|(
name|seqtt
operator|->
name|flags
operator|&
name|ASN1_TFLG_OPTIONAL
argument_list|)
expr_stmt|;
comment|/* attempt to read in field, allowing each to be 			 * OPTIONAL */
name|ret
operator|=
name|asn1_template_ex_d2i
argument_list|(
name|pseqval
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|seqtt
argument_list|,
name|isopt
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|errtt
operator|=
name|seqtt
expr_stmt|;
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* OPTIONAL component absent. 				 * Free and zero the field. 				 */
name|ASN1_template_free
argument_list|(
name|pseqval
argument_list|,
name|seqtt
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Update length */
name|len
operator|-=
name|p
operator|-
name|q
expr_stmt|;
block|}
comment|/* Check for EOC if expecting one */
if|if
condition|(
name|seq_eoc
operator|&&
operator|!
name|asn1_check_eoc
argument_list|(
operator|&
name|p
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_MISSING_EOC
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Check all data read */
if|if
condition|(
operator|!
name|seq_nolen
operator|&&
name|len
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_SEQUENCE_LENGTH_MISMATCH
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* If we get here we've got no more data in the SEQUENCE, 		 * however we may not have read all fields so check all 		 * remaining are OPTIONAL and clear any that are. 		 */
for|for
control|(
init|;
name|i
operator|<
name|it
operator|->
name|tcount
condition|;
name|tt
operator|++
operator|,
name|i
operator|++
control|)
block|{
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|seqtt
decl_stmt|;
name|seqtt
operator|=
name|asn1_do_adb
argument_list|(
name|pval
argument_list|,
name|tt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seqtt
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|seqtt
operator|->
name|flags
operator|&
name|ASN1_TFLG_OPTIONAL
condition|)
block|{
name|ASN1_VALUE
modifier|*
modifier|*
name|pseqval
decl_stmt|;
name|pseqval
operator|=
name|asn1_get_field_ptr
argument_list|(
name|pval
argument_list|,
name|seqtt
argument_list|)
expr_stmt|;
name|ASN1_template_free
argument_list|(
name|pseqval
argument_list|,
name|seqtt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errtt
operator|=
name|seqtt
expr_stmt|;
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_FIELD_MISSING
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
comment|/* Save encoding */
if|if
condition|(
operator|!
name|asn1_enc_save
argument_list|(
name|pval
argument_list|,
operator|*
name|in
argument_list|,
name|p
operator|-
operator|*
name|in
argument_list|,
name|it
argument_list|)
condition|)
goto|goto
name|auxerr
goto|;
operator|*
name|in
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|asn1_cb
operator|&&
operator|!
name|asn1_cb
argument_list|(
name|ASN1_OP_D2I_POST
argument_list|,
name|pval
argument_list|,
name|it
argument_list|)
condition|)
goto|goto
name|auxerr
goto|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
name|auxerr
label|:
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_ITEM_EX_D2I
argument_list|,
name|ASN1_R_AUX_ERROR
argument_list|)
expr_stmt|;
name|err
label|:
name|ASN1_item_ex_free
argument_list|(
name|pval
argument_list|,
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|errtt
condition|)
name|ERR_add_error_data
argument_list|(
literal|4
argument_list|,
literal|"Field="
argument_list|,
name|errtt
operator|->
name|field_name
argument_list|,
literal|", Type="
argument_list|,
name|it
operator|->
name|sname
argument_list|)
expr_stmt|;
else|else
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"Type="
argument_list|,
name|it
operator|->
name|sname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Templates are handled with two separate functions.  * One handles any EXPLICIT tag and the other handles the rest.  */
end_comment

begin_function
specifier|static
name|int
name|asn1_template_ex_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|val
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|inlen
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|flags
decl_stmt|,
name|aclass
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|long
name|len
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|exp_eoc
decl_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
return|return
literal|0
return|;
name|flags
operator|=
name|tt
operator|->
name|flags
expr_stmt|;
name|aclass
operator|=
name|flags
operator|&
name|ASN1_TFLG_TAG_CLASS
expr_stmt|;
name|p
operator|=
operator|*
name|in
expr_stmt|;
comment|/* Check if EXPLICIT tag expected */
if|if
condition|(
name|flags
operator|&
name|ASN1_TFLG_EXPTAG
condition|)
block|{
name|char
name|cst
decl_stmt|;
comment|/* Need to work out amount of data available to the inner 		 * content and where it starts: so read in EXPLICIT header to 		 * get the info. 		 */
name|ret
operator|=
name|asn1_check_tlen
argument_list|(
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|exp_eoc
argument_list|,
operator|&
name|cst
argument_list|,
operator|&
name|p
argument_list|,
name|inlen
argument_list|,
name|tt
operator|->
name|tag
argument_list|,
name|aclass
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|cst
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_EX_D2I
argument_list|,
name|ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We've found the field so it can't be OPTIONAL now */
name|ret
operator|=
name|asn1_template_noexp_d2i
argument_list|(
name|val
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|tt
argument_list|,
literal|0
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_EX_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We read the field in OK so update length */
name|len
operator|-=
name|p
operator|-
name|q
expr_stmt|;
if|if
condition|(
name|exp_eoc
condition|)
block|{
comment|/* If NDEF we must have an EOC here */
if|if
condition|(
operator|!
name|asn1_check_eoc
argument_list|(
operator|&
name|p
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_EX_D2I
argument_list|,
name|ASN1_R_MISSING_EOC
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
else|else
block|{
comment|/* Otherwise we must hit the EXPLICIT tag end or its 			 * an error */
if|if
condition|(
name|len
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_EX_D2I
argument_list|,
name|ASN1_R_EXPLICIT_LENGTH_MISMATCH
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
block|}
else|else
return|return
name|asn1_template_noexp_d2i
argument_list|(
name|val
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|,
name|tt
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
return|;
operator|*
name|in
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
name|err
label|:
name|ASN1_template_free
argument_list|(
name|val
argument_list|,
name|tt
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|asn1_template_noexp_d2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|val
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
specifier|const
name|ASN1_TEMPLATE
modifier|*
name|tt
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|flags
decl_stmt|,
name|aclass
decl_stmt|;
name|int
name|ret
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
return|return
literal|0
return|;
name|flags
operator|=
name|tt
operator|->
name|flags
expr_stmt|;
name|aclass
operator|=
name|flags
operator|&
name|ASN1_TFLG_TAG_CLASS
expr_stmt|;
name|p
operator|=
operator|*
name|in
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ASN1_TFLG_SK_MASK
condition|)
block|{
comment|/* SET OF, SEQUENCE OF */
name|int
name|sktag
decl_stmt|,
name|skaclass
decl_stmt|;
name|char
name|sk_eoc
decl_stmt|;
comment|/* First work out expected inner tag value */
if|if
condition|(
name|flags
operator|&
name|ASN1_TFLG_IMPTAG
condition|)
block|{
name|sktag
operator|=
name|tt
operator|->
name|tag
expr_stmt|;
name|skaclass
operator|=
name|aclass
expr_stmt|;
block|}
else|else
block|{
name|skaclass
operator|=
name|V_ASN1_UNIVERSAL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ASN1_TFLG_SET_OF
condition|)
name|sktag
operator|=
name|V_ASN1_SET
expr_stmt|;
else|else
name|sktag
operator|=
name|V_ASN1_SEQUENCE
expr_stmt|;
block|}
comment|/* Get the tag */
name|ret
operator|=
name|asn1_check_tlen
argument_list|(
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sk_eoc
argument_list|,
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|sktag
argument_list|,
name|skaclass
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|*
name|val
condition|)
operator|*
name|val
operator|=
operator|(
name|ASN1_VALUE
operator|*
operator|)
name|sk_new_null
argument_list|()
expr_stmt|;
else|else
block|{
comment|/* We've got a valid STACK: free up any items present */
name|STACK
modifier|*
name|sktmp
init|=
operator|(
name|STACK
operator|*
operator|)
operator|*
name|val
decl_stmt|;
name|ASN1_VALUE
modifier|*
name|vtmp
decl_stmt|;
while|while
condition|(
name|sk_num
argument_list|(
name|sktmp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|vtmp
operator|=
operator|(
name|ASN1_VALUE
operator|*
operator|)
name|sk_pop
argument_list|(
name|sktmp
argument_list|)
expr_stmt|;
name|ASN1_item_ex_free
argument_list|(
operator|&
name|vtmp
argument_list|,
name|ASN1_ITEM_ptr
argument_list|(
name|tt
operator|->
name|item
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|val
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Read as many items as we can */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|ASN1_VALUE
modifier|*
name|skfield
decl_stmt|;
name|q
operator|=
name|p
expr_stmt|;
comment|/* See if EOC found */
if|if
condition|(
name|asn1_check_eoc
argument_list|(
operator|&
name|p
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|sk_eoc
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ASN1_R_UNEXPECTED_EOC
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|len
operator|-=
name|p
operator|-
name|q
expr_stmt|;
name|sk_eoc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|skfield
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ASN1_item_ex_d2i
argument_list|(
operator|&
name|skfield
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|ASN1_ITEM_ptr
argument_list|(
name|tt
operator|->
name|item
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ctx
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|len
operator|-=
name|p
operator|-
name|q
expr_stmt|;
if|if
condition|(
operator|!
name|sk_push
argument_list|(
operator|(
name|STACK
operator|*
operator|)
operator|*
name|val
argument_list|,
operator|(
name|char
operator|*
operator|)
name|skfield
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|sk_eoc
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ASN1_R_MISSING_EOC
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|ASN1_TFLG_IMPTAG
condition|)
block|{
comment|/* IMPLICIT tagging */
name|ret
operator|=
name|ASN1_item_ex_d2i
argument_list|(
name|val
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|ASN1_ITEM_ptr
argument_list|(
name|tt
operator|->
name|item
argument_list|)
argument_list|,
name|tt
operator|->
name|tag
argument_list|,
name|aclass
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|/* Nothing special */
name|ret
operator|=
name|ASN1_item_ex_d2i
argument_list|(
name|val
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|ASN1_ITEM_ptr
argument_list|(
name|tt
operator|->
name|item
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_TEMPLATE_NOEXP_D2I
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|in
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
name|err
label|:
name|ASN1_template_free
argument_list|(
name|val
argument_list|,
name|tt
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|asn1_d2i_ex_primitive
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|inlen
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|,
name|int
name|tag
parameter_list|,
name|int
name|aclass
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|utype
decl_stmt|;
name|long
name|plen
decl_stmt|;
name|char
name|cst
decl_stmt|,
name|inf
decl_stmt|,
name|free_cont
init|=
literal|0
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|BUF_MEM
name|buf
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|cont
init|=
name|NULL
decl_stmt|;
name|long
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|pval
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_D2I_EX_PRIMITIVE
argument_list|,
name|ASN1_R_ILLEGAL_NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Should never happen */
block|}
if|if
condition|(
name|it
operator|->
name|itype
operator|==
name|ASN1_ITYPE_MSTRING
condition|)
block|{
name|utype
operator|=
name|tag
expr_stmt|;
name|tag
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|utype
operator|=
name|it
operator|->
name|utype
expr_stmt|;
if|if
condition|(
name|utype
operator|==
name|V_ASN1_ANY
condition|)
block|{
comment|/* If type is ANY need to figure out type from tag */
name|unsigned
name|char
name|oclass
decl_stmt|;
if|if
condition|(
name|tag
operator|>=
literal|0
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_D2I_EX_PRIMITIVE
argument_list|,
name|ASN1_R_ILLEGAL_TAGGED_ANY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|opt
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_D2I_EX_PRIMITIVE
argument_list|,
name|ASN1_R_ILLEGAL_OPTIONAL_ANY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|=
operator|*
name|in
expr_stmt|;
name|ret
operator|=
name|asn1_check_tlen
argument_list|(
name|NULL
argument_list|,
operator|&
name|utype
argument_list|,
operator|&
name|oclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|inlen
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_D2I_EX_PRIMITIVE
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|oclass
operator|!=
name|V_ASN1_UNIVERSAL
condition|)
name|utype
operator|=
name|V_ASN1_OTHER
expr_stmt|;
block|}
if|if
condition|(
name|tag
operator|==
operator|-
literal|1
condition|)
block|{
name|tag
operator|=
name|utype
expr_stmt|;
name|aclass
operator|=
name|V_ASN1_UNIVERSAL
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|in
expr_stmt|;
comment|/* Check header */
name|ret
operator|=
name|asn1_check_tlen
argument_list|(
operator|&
name|plen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|inf
argument_list|,
operator|&
name|cst
argument_list|,
operator|&
name|p
argument_list|,
name|inlen
argument_list|,
name|tag
argument_list|,
name|aclass
argument_list|,
name|opt
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_D2I_EX_PRIMITIVE
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* SEQUENCE, SET and "OTHER" are left in encoded form */
if|if
condition|(
operator|(
name|utype
operator|==
name|V_ASN1_SEQUENCE
operator|)
operator|||
operator|(
name|utype
operator|==
name|V_ASN1_SET
operator|)
operator|||
operator|(
name|utype
operator|==
name|V_ASN1_OTHER
operator|)
condition|)
block|{
comment|/* Clear context cache for type OTHER because the auto clear 		 * when we have a exact match wont work 		 */
if|if
condition|(
name|utype
operator|==
name|V_ASN1_OTHER
condition|)
block|{
name|asn1_tlc_clear
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/* SEQUENCE and SET must be constructed */
elseif|else
if|if
condition|(
operator|!
name|cst
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_D2I_EX_PRIMITIVE
argument_list|,
name|ASN1_R_TYPE_NOT_CONSTRUCTED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cont
operator|=
operator|*
name|in
expr_stmt|;
comment|/* If indefinite length constructed find the real end */
if|if
condition|(
name|inf
condition|)
block|{
if|if
condition|(
operator|!
name|asn1_find_end
argument_list|(
operator|&
name|p
argument_list|,
name|plen
argument_list|,
name|inf
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|len
operator|=
name|p
operator|-
name|cont
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|p
operator|-
name|cont
operator|+
name|plen
expr_stmt|;
name|p
operator|+=
name|plen
expr_stmt|;
name|buf
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cst
condition|)
block|{
name|buf
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|max
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* Should really check the internal tags are correct but 		 * some things may get this wrong. The relevant specs 		 * say that constructed string types should be OCTET STRINGs 		 * internally irrespective of the type. So instead just check 		 * for UNIVERSAL class and ignore the tag. 		 */
if|if
condition|(
operator|!
name|asn1_collect
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|p
argument_list|,
name|plen
argument_list|,
name|inf
argument_list|,
operator|-
literal|1
argument_list|,
name|V_ASN1_UNIVERSAL
argument_list|)
condition|)
block|{
name|free_cont
operator|=
literal|1
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|len
operator|=
name|buf
operator|.
name|length
expr_stmt|;
comment|/* Append a final null to string */
if|if
condition|(
operator|!
name|BUF_MEM_grow_clean
argument_list|(
operator|&
name|buf
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_D2I_EX_PRIMITIVE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|buf
operator|.
name|data
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|cont
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|.
name|data
expr_stmt|;
name|free_cont
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cont
operator|=
name|p
expr_stmt|;
name|len
operator|=
name|plen
expr_stmt|;
name|p
operator|+=
name|plen
expr_stmt|;
block|}
comment|/* We now have content length and type: translate into a structure */
if|if
condition|(
operator|!
name|asn1_ex_c2i
argument_list|(
name|pval
argument_list|,
name|cont
argument_list|,
name|len
argument_list|,
name|utype
argument_list|,
operator|&
name|free_cont
argument_list|,
name|it
argument_list|)
condition|)
goto|goto
name|err
goto|;
operator|*
name|in
operator|=
name|p
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|free_cont
operator|&&
name|buf
operator|.
name|data
condition|)
name|OPENSSL_free
argument_list|(
name|buf
operator|.
name|data
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Translate ASN1 content octets into a structure */
end_comment

begin_function
name|int
name|asn1_ex_c2i
parameter_list|(
name|ASN1_VALUE
modifier|*
modifier|*
name|pval
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|cont
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|utype
parameter_list|,
name|char
modifier|*
name|free_cont
parameter_list|,
specifier|const
name|ASN1_ITEM
modifier|*
name|it
parameter_list|)
block|{
name|ASN1_VALUE
modifier|*
modifier|*
name|opval
init|=
name|NULL
decl_stmt|;
name|ASN1_STRING
modifier|*
name|stmp
decl_stmt|;
name|ASN1_TYPE
modifier|*
name|typ
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|ASN1_PRIMITIVE_FUNCS
modifier|*
name|pf
decl_stmt|;
name|ASN1_INTEGER
modifier|*
modifier|*
name|tint
decl_stmt|;
name|pf
operator|=
name|it
operator|->
name|funcs
expr_stmt|;
if|if
condition|(
name|pf
operator|&&
name|pf
operator|->
name|prim_c2i
condition|)
return|return
name|pf
operator|->
name|prim_c2i
argument_list|(
name|pval
argument_list|,
name|cont
argument_list|,
name|len
argument_list|,
name|utype
argument_list|,
name|free_cont
argument_list|,
name|it
argument_list|)
return|;
comment|/* If ANY type clear type and set pointer to internal value */
if|if
condition|(
name|it
operator|->
name|utype
operator|==
name|V_ASN1_ANY
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|pval
condition|)
block|{
name|typ
operator|=
name|ASN1_TYPE_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|typ
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
operator|*
name|pval
operator|=
operator|(
name|ASN1_VALUE
operator|*
operator|)
name|typ
expr_stmt|;
block|}
else|else
name|typ
operator|=
operator|(
name|ASN1_TYPE
operator|*
operator|)
operator|*
name|pval
expr_stmt|;
if|if
condition|(
name|utype
operator|!=
name|typ
operator|->
name|type
condition|)
name|ASN1_TYPE_set
argument_list|(
name|typ
argument_list|,
name|utype
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|opval
operator|=
name|pval
expr_stmt|;
name|pval
operator|=
operator|(
name|ASN1_VALUE
operator|*
operator|*
operator|)
operator|&
name|typ
operator|->
name|value
operator|.
name|ptr
expr_stmt|;
block|}
switch|switch
condition|(
name|utype
condition|)
block|{
case|case
name|V_ASN1_OBJECT
case|:
if|if
condition|(
operator|!
name|c2i_ASN1_OBJECT
argument_list|(
operator|(
name|ASN1_OBJECT
operator|*
operator|*
operator|)
name|pval
argument_list|,
operator|&
name|cont
argument_list|,
name|len
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|V_ASN1_NULL
case|:
if|if
condition|(
name|len
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_EX_C2I
argument_list|,
name|ASN1_R_NULL_IS_WRONG_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|*
name|pval
operator|=
operator|(
name|ASN1_VALUE
operator|*
operator|)
literal|1
expr_stmt|;
break|break;
case|case
name|V_ASN1_BOOLEAN
case|:
if|if
condition|(
name|len
operator|!=
literal|1
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_EX_C2I
argument_list|,
name|ASN1_R_BOOLEAN_IS_WRONG_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|ASN1_BOOLEAN
modifier|*
name|tbool
decl_stmt|;
name|tbool
operator|=
operator|(
name|ASN1_BOOLEAN
operator|*
operator|)
name|pval
expr_stmt|;
operator|*
name|tbool
operator|=
operator|*
name|cont
expr_stmt|;
block|}
break|break;
case|case
name|V_ASN1_BIT_STRING
case|:
if|if
condition|(
operator|!
name|c2i_ASN1_BIT_STRING
argument_list|(
operator|(
name|ASN1_BIT_STRING
operator|*
operator|*
operator|)
name|pval
argument_list|,
operator|&
name|cont
argument_list|,
name|len
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|V_ASN1_INTEGER
case|:
case|case
name|V_ASN1_NEG_INTEGER
case|:
case|case
name|V_ASN1_ENUMERATED
case|:
case|case
name|V_ASN1_NEG_ENUMERATED
case|:
name|tint
operator|=
operator|(
name|ASN1_INTEGER
operator|*
operator|*
operator|)
name|pval
expr_stmt|;
if|if
condition|(
operator|!
name|c2i_ASN1_INTEGER
argument_list|(
name|tint
argument_list|,
operator|&
name|cont
argument_list|,
name|len
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Fixup type to match the expected form */
operator|(
operator|*
name|tint
operator|)
operator|->
name|type
operator|=
name|utype
operator||
operator|(
operator|(
operator|*
name|tint
operator|)
operator|->
name|type
operator|&
name|V_ASN1_NEG
operator|)
expr_stmt|;
break|break;
case|case
name|V_ASN1_OCTET_STRING
case|:
case|case
name|V_ASN1_NUMERICSTRING
case|:
case|case
name|V_ASN1_PRINTABLESTRING
case|:
case|case
name|V_ASN1_T61STRING
case|:
case|case
name|V_ASN1_VIDEOTEXSTRING
case|:
case|case
name|V_ASN1_IA5STRING
case|:
case|case
name|V_ASN1_UTCTIME
case|:
case|case
name|V_ASN1_GENERALIZEDTIME
case|:
case|case
name|V_ASN1_GRAPHICSTRING
case|:
case|case
name|V_ASN1_VISIBLESTRING
case|:
case|case
name|V_ASN1_GENERALSTRING
case|:
case|case
name|V_ASN1_UNIVERSALSTRING
case|:
case|case
name|V_ASN1_BMPSTRING
case|:
case|case
name|V_ASN1_UTF8STRING
case|:
case|case
name|V_ASN1_OTHER
case|:
case|case
name|V_ASN1_SET
case|:
case|case
name|V_ASN1_SEQUENCE
case|:
default|default:
comment|/* All based on ASN1_STRING and handled the same */
if|if
condition|(
operator|!
operator|*
name|pval
condition|)
block|{
name|stmp
operator|=
name|ASN1_STRING_type_new
argument_list|(
name|utype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stmp
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_EX_C2I
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|*
name|pval
operator|=
operator|(
name|ASN1_VALUE
operator|*
operator|)
name|stmp
expr_stmt|;
block|}
else|else
block|{
name|stmp
operator|=
operator|(
name|ASN1_STRING
operator|*
operator|)
operator|*
name|pval
expr_stmt|;
name|stmp
operator|->
name|type
operator|=
name|utype
expr_stmt|;
block|}
comment|/* If we've already allocated a buffer use it */
if|if
condition|(
operator|*
name|free_cont
condition|)
block|{
if|if
condition|(
name|stmp
operator|->
name|data
condition|)
name|OPENSSL_free
argument_list|(
name|stmp
operator|->
name|data
argument_list|)
expr_stmt|;
name|stmp
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|cont
expr_stmt|;
comment|/* UGLY CAST! RL */
name|stmp
operator|->
name|length
operator|=
name|len
expr_stmt|;
operator|*
name|free_cont
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ASN1_STRING_set
argument_list|(
name|stmp
argument_list|,
name|cont
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_EX_C2I
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
name|ASN1_STRING_free
argument_list|(
name|stmp
argument_list|)
expr_stmt|;
operator|*
name|pval
operator|=
name|NULL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
break|break;
block|}
comment|/* If ASN1_ANY and NULL type fix up value */
if|if
condition|(
name|typ
operator|&&
operator|(
name|utype
operator|==
name|V_ASN1_NULL
operator|)
condition|)
name|typ
operator|->
name|value
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ASN1_TYPE_free
argument_list|(
name|typ
argument_list|)
expr_stmt|;
if|if
condition|(
name|opval
condition|)
operator|*
name|opval
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* This function finds the end of an ASN1 structure when passed its maximum  * length, whether it is indefinite length and a pointer to the content.  * This is more efficient than calling asn1_collect because it does not  * recurse on each indefinite length header.  */
end_comment

begin_function
specifier|static
name|int
name|asn1_find_end
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
name|char
name|inf
parameter_list|)
block|{
name|int
name|expected_eoc
decl_stmt|;
name|long
name|plen
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|*
name|in
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* If not indefinite length constructed just add length */
if|if
condition|(
name|inf
operator|==
literal|0
condition|)
block|{
operator|*
name|in
operator|+=
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
name|expected_eoc
operator|=
literal|1
expr_stmt|;
comment|/* Indefinite length constructed form. Find the end when enough EOCs 	 * are found. If more indefinite length constructed headers 	 * are encountered increment the expected eoc count otherwise just 	 * skip to the end of the data. 	 */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|asn1_check_eoc
argument_list|(
operator|&
name|p
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|expected_eoc
operator|--
expr_stmt|;
if|if
condition|(
name|expected_eoc
operator|==
literal|0
condition|)
break|break;
name|len
operator|-=
literal|2
expr_stmt|;
continue|continue;
block|}
name|q
operator|=
name|p
expr_stmt|;
comment|/* Just read in a header: only care about the length */
if|if
condition|(
operator|!
name|asn1_check_tlen
argument_list|(
operator|&
name|plen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|inf
argument_list|,
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_FIND_END
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|inf
condition|)
name|expected_eoc
operator|++
expr_stmt|;
else|else
name|p
operator|+=
name|plen
expr_stmt|;
name|len
operator|-=
name|p
operator|-
name|q
expr_stmt|;
block|}
if|if
condition|(
name|expected_eoc
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_FIND_END
argument_list|,
name|ASN1_R_MISSING_EOC
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|in
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This function collects the asn1 data from a constructred string  * type into a buffer. The values of 'in' and 'len' should refer  * to the contents of the constructed type and 'inf' should be set  * if it is indefinite length.  */
end_comment

begin_function
specifier|static
name|int
name|asn1_collect
parameter_list|(
name|BUF_MEM
modifier|*
name|buf
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
name|char
name|inf
parameter_list|,
name|int
name|tag
parameter_list|,
name|int
name|aclass
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|long
name|plen
decl_stmt|;
name|char
name|cst
decl_stmt|,
name|ininf
decl_stmt|;
name|p
operator|=
operator|*
name|in
expr_stmt|;
name|inf
operator|&=
literal|1
expr_stmt|;
comment|/* If no buffer and not indefinite length constructed just pass over 	 * the encoded data */
if|if
condition|(
operator|!
name|buf
operator|&&
operator|!
name|inf
condition|)
block|{
operator|*
name|in
operator|+=
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
comment|/* Check for EOC */
if|if
condition|(
name|asn1_check_eoc
argument_list|(
operator|&
name|p
argument_list|,
name|len
argument_list|)
condition|)
block|{
comment|/* EOC is illegal outside indefinite length 			 * constructed form */
if|if
condition|(
operator|!
name|inf
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_COLLECT
argument_list|,
name|ASN1_R_UNEXPECTED_EOC
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|inf
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|asn1_check_tlen
argument_list|(
operator|&
name|plen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ininf
argument_list|,
operator|&
name|cst
argument_list|,
operator|&
name|p
argument_list|,
name|len
argument_list|,
name|tag
argument_list|,
name|aclass
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_COLLECT
argument_list|,
name|ERR_R_NESTED_ASN1_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If indefinite length constructed update max length */
if|if
condition|(
name|cst
condition|)
block|{
ifdef|#
directive|ifdef
name|OPENSSL_ALLOW_NESTED_ASN1_STRINGS
if|if
condition|(
operator|!
name|asn1_collect
argument_list|(
name|buf
argument_list|,
operator|&
name|p
argument_list|,
name|plen
argument_list|,
name|ininf
argument_list|,
name|tag
argument_list|,
name|aclass
argument_list|)
condition|)
return|return
literal|0
return|;
else|#
directive|else
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_COLLECT
argument_list|,
name|ASN1_R_NESTED_ASN1_STRING
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|plen
operator|&&
operator|!
name|collect_data
argument_list|(
name|buf
argument_list|,
operator|&
name|p
argument_list|,
name|plen
argument_list|)
condition|)
return|return
literal|0
return|;
name|len
operator|-=
name|p
operator|-
name|q
expr_stmt|;
block|}
if|if
condition|(
name|inf
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_COLLECT
argument_list|,
name|ASN1_R_MISSING_EOC
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|in
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|collect_data
parameter_list|(
name|BUF_MEM
modifier|*
name|buf
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|long
name|plen
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
name|len
operator|=
name|buf
operator|->
name|length
expr_stmt|;
if|if
condition|(
operator|!
name|BUF_MEM_grow_clean
argument_list|(
name|buf
argument_list|,
name|len
operator|+
name|plen
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_COLLECT_DATA
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|buf
operator|->
name|data
operator|+
name|len
argument_list|,
operator|*
name|p
argument_list|,
name|plen
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|+=
name|plen
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check for ASN1 EOC and swallow it if found */
end_comment

begin_function
specifier|static
name|int
name|asn1_check_eoc
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|p
operator|=
operator|*
name|in
expr_stmt|;
if|if
condition|(
operator|!
name|p
index|[
literal|0
index|]
operator|&&
operator|!
name|p
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|in
operator|+=
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check an ASN1 tag and length: a bit like ASN1_get_object  * but it sets the length for indefinite length constructed  * form, we don't know the exact length but we can set an  * upper bound to the amount of data available minus the  * header length just read.  */
end_comment

begin_function
specifier|static
name|int
name|asn1_check_tlen
parameter_list|(
name|long
modifier|*
name|olen
parameter_list|,
name|int
modifier|*
name|otag
parameter_list|,
name|unsigned
name|char
modifier|*
name|oclass
parameter_list|,
name|char
modifier|*
name|inf
parameter_list|,
name|char
modifier|*
name|cst
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|long
name|len
parameter_list|,
name|int
name|exptag
parameter_list|,
name|int
name|expclass
parameter_list|,
name|char
name|opt
parameter_list|,
name|ASN1_TLC
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ptag
decl_stmt|,
name|pclass
decl_stmt|;
name|long
name|plen
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
operator|*
name|in
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|ctx
operator|&&
name|ctx
operator|->
name|valid
condition|)
block|{
name|i
operator|=
name|ctx
operator|->
name|ret
expr_stmt|;
name|plen
operator|=
name|ctx
operator|->
name|plen
expr_stmt|;
name|pclass
operator|=
name|ctx
operator|->
name|pclass
expr_stmt|;
name|ptag
operator|=
name|ctx
operator|->
name|ptag
expr_stmt|;
name|p
operator|+=
name|ctx
operator|->
name|hdrlen
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|ASN1_get_object
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|plen
argument_list|,
operator|&
name|ptag
argument_list|,
operator|&
name|pclass
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
condition|)
block|{
name|ctx
operator|->
name|ret
operator|=
name|i
expr_stmt|;
name|ctx
operator|->
name|plen
operator|=
name|plen
expr_stmt|;
name|ctx
operator|->
name|pclass
operator|=
name|pclass
expr_stmt|;
name|ctx
operator|->
name|ptag
operator|=
name|ptag
expr_stmt|;
name|ctx
operator|->
name|hdrlen
operator|=
name|p
operator|-
name|q
expr_stmt|;
name|ctx
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
comment|/* If definite length, and no error, length + 			 * header can't exceed total amount of data available.  			 */
if|if
condition|(
operator|!
operator|(
name|i
operator|&
literal|0x81
operator|)
operator|&&
operator|(
operator|(
name|plen
operator|+
name|ctx
operator|->
name|hdrlen
operator|)
operator|>
name|len
operator|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_CHECK_TLEN
argument_list|,
name|ASN1_R_TOO_LONG
argument_list|)
expr_stmt|;
name|asn1_tlc_clear
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|&
literal|0x80
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_CHECK_TLEN
argument_list|,
name|ASN1_R_BAD_OBJECT_HEADER
argument_list|)
expr_stmt|;
name|asn1_tlc_clear
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|exptag
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|exptag
operator|!=
name|ptag
operator|)
operator|||
operator|(
name|expclass
operator|!=
name|pclass
operator|)
condition|)
block|{
comment|/* If type is OPTIONAL, not an error: 			 * indicate missing type. 			 */
if|if
condition|(
name|opt
condition|)
return|return
operator|-
literal|1
return|;
name|asn1_tlc_clear
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_CHECK_TLEN
argument_list|,
name|ASN1_R_WRONG_TAG
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We have a tag and class match: 		 * assume we are going to do something with it */
name|asn1_tlc_clear
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|plen
operator|=
name|len
operator|-
operator|(
name|p
operator|-
name|q
operator|)
expr_stmt|;
if|if
condition|(
name|inf
condition|)
operator|*
name|inf
operator|=
name|i
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|cst
condition|)
operator|*
name|cst
operator|=
name|i
operator|&
name|V_ASN1_CONSTRUCTED
expr_stmt|;
if|if
condition|(
name|olen
condition|)
operator|*
name|olen
operator|=
name|plen
expr_stmt|;
if|if
condition|(
name|oclass
condition|)
operator|*
name|oclass
operator|=
name|pclass
expr_stmt|;
if|if
condition|(
name|otag
condition|)
operator|*
name|otag
operator|=
name|ptag
expr_stmt|;
operator|*
name|in
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

