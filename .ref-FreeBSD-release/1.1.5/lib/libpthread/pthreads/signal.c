begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ==== signal.c ============================================================  * Copyright (c) 1993, 1994 by Chris Provenzano, proven@mit.edu  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *  This product includes software developed by Chris Provenzano.  * 4. The name of Chris Provenzano may not be used to endorse or promote   *	  products derived from this software without specific prior written  *	  permission.  *  * THIS SOFTWARE IS PROVIDED BY CHRIS PROVENZANO ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL CHRIS PROVENZANO BE LIABLE FOR ANY   * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF   * SUCH DAMAGE.  *  * Description : Queue functions.  *  *  1.00 93/07/21 proven  *      -Started coding this file.  */
end_comment

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/*  * Time which select in fd_kern_wait() will sleep.  * If there are no threads to run we sleep for an hour or until  * we get an interrupt or an fd thats awakens. To make sure we  * don't miss an interrupt this variable gets reset too zero in  * sig_handler_real().  */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|__fd_kern_wait_timeout
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Global for user-kernel lock, and blocked signals  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|sigset_t
name|sig_to_tryagain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|sigset_t
name|sig_to_process
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|kernel_lock
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|sig_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sig_handler
parameter_list|(
name|int
name|signal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_thread_timer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sig_prevent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sig_resume
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ==========================================================================  * context_switch()  *  * This routine saves the current state of the running thread gets  * the next thread to run and restores it's state. To allow different  * processors to work with this routine, I allow the machdep_restore_state()  * to either return or have it return from machdep_save_state with a value  * other than 0, this is for implementations which use setjmp/longjmp.   */
end_comment

begin_function
specifier|static
name|void
name|context_switch
parameter_list|()
block|{
name|struct
name|pthread
modifier|*
modifier|*
name|current
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|semaphore
modifier|*
name|lock
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* save state of current thread */
if|if
condition|(
name|machdep_save_state
argument_list|()
condition|)
block|{
return|return;
block|}
name|last
operator|=
name|pthread_run
expr_stmt|;
if|if
condition|(
name|pthread_run
operator|=
name|pthread_queue_deq
argument_list|(
operator|&
name|pthread_current_queue
argument_list|)
condition|)
block|{
comment|/* restore state of new current thread */
name|machdep_restore_state
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Poll all the kernel fds */
name|fd_kern_poll
argument_list|()
expr_stmt|;
name|context_switch_reschedule
label|:
empty_stmt|;
comment|/* 	 * Go through the reschedule list once, this is the only place 	 * that goes through the queue without using the queue routines. 	 * 	 * But first delete the current queue. 	 */
name|pthread_queue_init
argument_list|(
operator|&
name|pthread_current_queue
argument_list|)
expr_stmt|;
name|current
operator|=
operator|&
operator|(
name|pthread_link_list
operator|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|current
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|current
operator|)
operator|->
name|state
condition|)
block|{
case|case
name|PS_RUNNING
case|:
name|pthread_queue_enq
argument_list|(
operator|&
name|pthread_current_queue
argument_list|,
operator|*
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
operator|&
operator|(
operator|(
operator|*
name|current
operator|)
operator|->
name|pll
operator|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
break|break;
case|case
name|PS_DEAD
case|:
comment|/* Cleanup thread, unless we're using the stack */
if|if
condition|(
operator|(
operator|(
operator|*
name|current
operator|)
operator|->
name|flags
operator|&
name|PF_DETACHED
operator|)
operator|&&
operator|(
operator|*
name|current
operator|!=
name|last
operator|)
condition|)
block|{
name|next
operator|=
operator|(
operator|*
name|current
operator|)
operator|->
name|pll
expr_stmt|;
name|lock
operator|=
operator|&
operator|(
operator|(
operator|*
name|current
operator|)
operator|->
name|lock
operator|)
expr_stmt|;
if|if
condition|(
name|SEMAPHORE_TEST_AND_SET
argument_list|(
name|lock
argument_list|)
condition|)
block|{
comment|/* Couldn't cleanup this time, try again later */
name|current
operator|=
operator|&
operator|(
operator|(
operator|*
name|current
operator|)
operator|->
name|pll
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|current
operator|)
operator|->
name|attr
operator|.
name|stackaddr_attr
operator|)
condition|)
block|{
name|free
argument_list|(
name|machdep_pthread_cleanup
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|current
operator|)
operator|->
name|machdep_data
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|*
name|current
argument_list|)
expr_stmt|;
operator|*
name|current
operator|=
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|current
operator|=
operator|&
operator|(
operator|(
operator|*
name|current
operator|)
operator|->
name|pll
operator|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Should be on a different queue. Ignore. */
name|current
operator|=
operator|&
operator|(
operator|(
operator|*
name|current
operator|)
operator|->
name|pll
operator|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* Are there any threads to run */
if|if
condition|(
name|pthread_run
operator|=
name|pthread_queue_deq
argument_list|(
operator|&
name|pthread_current_queue
argument_list|)
condition|)
block|{
comment|/* restore state of new current thread */
name|machdep_restore_state
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Are there any threads at all */
if|if
condition|(
name|count
condition|)
block|{
comment|/* 		 * Do a wait, timeout is set to a hour unless we get an interrupt 		 * before the select in wich case it polls and returns.  		 */
name|fd_kern_wait
argument_list|()
expr_stmt|;
comment|/* Check for interrupts, but ignore SIGVTALR */
name|sigdelset
argument_list|(
operator|&
name|sig_to_process
argument_list|,
name|SIGVTALRM
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig_to_process
condition|)
block|{
comment|/* Process interrupts */
name|sig_handler
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
goto|goto
name|context_switch_reschedule
goto|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ==========================================================================  * sig_handler_pause()  *   * Wait until a signal is sent to the process.  */
end_comment

begin_function
name|void
name|sig_handler_pause
parameter_list|()
block|{
name|sigset_t
name|sig_to_block
decl_stmt|,
name|sig_to_pause
decl_stmt|;
name|sigfillset
argument_list|(
operator|&
name|sig_to_block
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sig_to_pause
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|sig_to_block
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sig_to_process
condition|)
block|{
name|sigsuspend
argument_list|(
operator|&
name|sig_to_pause
argument_list|)
expr_stmt|;
block|}
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|sig_to_block
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ==========================================================================  * context_switch_done()  *  * This routine does all the things that are necessary after a context_switch()  * calls the machdep_restore_state(). DO NOT put this in the context_switch()  * routine because sometimes the machdep_restore_state() doesn't return  * to context_switch() but instead ends up in machdep_thread_start() or  * some such routine, which will need to call this routine and  * sig_check_and_resume().  */
end_comment

begin_function
name|void
name|context_switch_done
parameter_list|()
block|{
name|sigdelset
argument_list|(
operator|&
name|sig_to_process
argument_list|,
name|SIGVTALRM
argument_list|)
expr_stmt|;
name|set_thread_timer
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ==========================================================================  * set_thread_timer()  *  * Assums kernel is locked.  */
end_comment

begin_function
specifier|static
name|void
name|set_thread_timer
parameter_list|()
block|{
specifier|static
name|int
name|last_sched_attr
init|=
name|SCHED_RR
decl_stmt|;
switch|switch
condition|(
name|pthread_run
operator|->
name|attr
operator|.
name|sched_attr
condition|)
block|{
case|case
name|SCHED_RR
case|:
name|machdep_set_thread_timer
argument_list|(
operator|&
operator|(
name|pthread_run
operator|->
name|machdep_data
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCHED_FIFO
case|:
if|if
condition|(
name|last_sched_attr
operator|!=
name|SCHED_FIFO
condition|)
block|{
name|machdep_unset_thread_timer
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|SCHED_IO
case|:
if|if
condition|(
operator|(
name|last_sched_attr
operator|!=
name|SCHED_IO
operator|)
operator|&&
operator|(
operator|!
name|sig_count
operator|)
condition|)
block|{
name|machdep_set_thread_timer
argument_list|(
operator|&
operator|(
name|pthread_run
operator|->
name|machdep_data
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|machdep_set_thread_timer
argument_list|(
operator|&
operator|(
name|pthread_run
operator|->
name|machdep_data
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|last_sched_attr
operator|=
name|pthread_run
operator|->
name|attr
operator|.
name|sched_attr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ==========================================================================  * sig_handler()  *  * Assumes the kernel is locked.   */
end_comment

begin_function
specifier|static
name|void
name|sig_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
comment|/* 	 * First check for old signals, do one pass through and don't  	 * check any twice.      */
if|if
condition|(
name|sig_to_tryagain
condition|)
block|{
if|if
condition|(
name|sigismember
argument_list|(
operator|&
name|sig_to_tryagain
argument_list|,
name|SIGALRM
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|sleep_wakeup
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
comment|/* Do the default action, no threads were sleeping */
case|case
name|OK
case|:
comment|/* Woke up a sleeping thread */
name|sigdelset
argument_list|(
operator|&
name|sig_to_tryagain
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTOK
case|:
comment|/* Couldn't get appropriate locks, try again later */
break|break;
block|}
block|}
else|else
block|{
name|PANIC
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* 	 * NOW, process signal that just came in, plus any pending on the 	 * signal mask. All of these must be resolved. 	 */
name|sig_handler_top
label|:
empty_stmt|;
switch|switch
condition|(
name|sig
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
name|SIGVTALRM
case|:
if|if
condition|(
name|sig_count
condition|)
block|{
name|sigset_t
name|sigall
decl_stmt|;
name|sig_count
operator|=
literal|0
expr_stmt|;
comment|/* Unblock all signals */
name|sigemptyset
argument_list|(
operator|&
name|sigall
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sigall
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|context_switch
argument_list|()
expr_stmt|;
name|context_switch_done
argument_list|()
expr_stmt|;
break|break;
case|case
name|SIGALRM
case|:
name|sigdelset
argument_list|(
operator|&
name|sig_to_process
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sleep_wakeup
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
comment|/* Do the default action, no threads were sleeping */
case|case
name|OK
case|:
comment|/* Woke up a sleeping thread */
break|break;
case|case
name|NOTOK
case|:
comment|/* Couldn't get appropriate locks, try again later */
name|sigaddset
argument_list|(
operator|&
name|sig_to_tryagain
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|PANIC
argument_list|()
expr_stmt|;
block|}
comment|/* Determine if there are any other signals */
if|if
condition|(
name|sig_to_process
condition|)
block|{
for|for
control|(
name|sig
operator|=
literal|1
init|;
name|sig
operator|<=
name|SIGMAX
condition|;
name|sig
operator|++
control|)
block|{
if|if
condition|(
name|sigismember
argument_list|(
operator|&
name|sig_to_process
argument_list|,
name|sig
argument_list|)
condition|)
block|{
comment|/* goto sig_handler_top */
goto|goto
name|sig_handler_top
goto|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* ==========================================================================  * sig_handler_real()  *   * On a multi-processor this would need to use the test and set instruction  * otherwise the following will work.  */
end_comment

begin_function
name|void
name|sig_handler_real
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|kernel_lock
condition|)
block|{
name|__fd_kern_wait_timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|sig_to_process
argument_list|,
name|sig
argument_list|)
expr_stmt|;
return|return;
block|}
name|sig_prevent
argument_list|()
expr_stmt|;
name|sig_count
operator|++
expr_stmt|;
name|sig_handler
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|sig_resume
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ==========================================================================  * sig_handler_fake()  */
end_comment

begin_function
name|void
name|sig_handler_fake
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|kernel_lock
condition|)
block|{
comment|/* Currently this should be impossible */
name|PANIC
argument_list|()
expr_stmt|;
block|}
name|sig_prevent
argument_list|()
expr_stmt|;
name|sig_handler
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|sig_resume
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ==========================================================================  * reschedule()  *  * This routine assumes that the caller is the current pthread, pthread_run  * and that it has a lock on itself and that it wants to reschedule itself.  */
end_comment

begin_function
name|void
name|reschedule
parameter_list|(
name|enum
name|pthread_state
name|state
parameter_list|)
block|{
name|semaphore
modifier|*
name|plock
decl_stmt|;
if|if
condition|(
name|kernel_lock
condition|)
block|{
comment|/* Currently this should be impossible */
name|PANIC
argument_list|()
expr_stmt|;
block|}
name|sig_prevent
argument_list|()
expr_stmt|;
name|pthread_run
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|SEMAPHORE_RESET
argument_list|(
operator|(
name|plock
operator|=
operator|&
operator|(
name|pthread_run
operator|->
name|lock
operator|)
operator|)
argument_list|)
expr_stmt|;
name|sig_handler
argument_list|(
name|SIGVTALRM
argument_list|)
expr_stmt|;
name|sig_resume
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ==========================================================================  * sig_prevent()  */
end_comment

begin_function
name|void
name|sig_prevent
parameter_list|(
name|void
parameter_list|)
block|{
name|kernel_lock
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ==========================================================================  * sig_resume()  */
end_comment

begin_function
name|void
name|sig_resume
parameter_list|()
block|{
name|kernel_lock
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ==========================================================================  * sig_check_and_resume()  */
end_comment

begin_function
name|void
name|sig_check_and_resume
parameter_list|()
block|{
comment|/* Some routine name that is yet to be determined. */
comment|/* Only bother if we are truely unlocking the kernel */
while|while
condition|(
operator|!
operator|(
operator|--
name|kernel_lock
operator|)
condition|)
block|{
comment|/* Assume sigset_t is not a struct or union */
if|if
condition|(
name|sig_to_process
condition|)
block|{
name|kernel_lock
operator|++
expr_stmt|;
name|sig_handler
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ==========================================================================  * sig_init()  *  * SIGVTALRM	(NOT POSIX) needed for thread timeslice timeouts.  *				Since it's not POSIX I will replace it with a   *				virtual timer for threads.  * SIGALRM		(IS POSIX) so some special handling will be  * 				necessary to fake SIGALRM signals  */
end_comment

begin_function
name|void
name|sig_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|sig_to_init
index|[]
init|=
block|{
name|SIGVTALRM
block|,
name|SIGALRM
block|,
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Initialize only the necessary signals */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sig_to_init
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|signal
argument_list|(
name|sig_to_init
index|[
name|i
index|]
argument_list|,
name|sig_handler_real
argument_list|)
condition|)
block|{
name|PANIC
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

