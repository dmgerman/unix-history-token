begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Author: Mark Moraes<moraes@csri.toronto.edu> */
end_comment

begin_comment
comment|/*LINTLIBRARY*/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"sptree.h"
end_include

begin_macro
name|RCSID
argument_list|(
literal|"$Id: leak.c,v 1.12 1993/05/23 03:38:27 moraes Exp $"
argument_list|)
end_macro

begin_comment
comment|/*   *  These routines provide an interface for tracing memory leaks. The  *  user can turn on leak tracing at any time by calling  *  mal_leaktrace(1), after which every block allocated by  *  _malloc()/_calloc()/_realloc()/_valloc()/_memalign() has a string  *  (containing the filename and linenumber of the routine invoking it)  *  stored in a database. When _free()/_cfree() is called on that block,  *  the record is deleted from the database. The user can call  *  mal_dumpleaktrace() to show the list of blocks allocated, and  *  where they were allocated. The location of leaks can usually be  *  detected from this.  */
end_comment

begin_comment
comment|/*  *  The tree implementation used to store the blocks is a splay-tree,  *  using an implementation in C by Dave Brower (daveb@rtech.uucp),  *  translated from Douglas Jones' original Pascal. However, any data  *  structure that permits insert(), delete() and traverse()/apply() of  *  key, value pairs should be suitable. Only this file needs to be  *  changed.  */
end_comment

begin_decl_stmt
specifier|static
name|SPTREE
modifier|*
name|sp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  num is a sequence number, incremented for ever block. min_num gets  *  set to num after every dumpleaktrace - subsequent dumps do not print  *  any blocks with sequence numbers less than min_num  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|min_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These are used by mal_contents to count number of allocated blocks and the  * number of bytes allocated.  Better way to do this is to walk the heap  * rather than scan the splay tree.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|nmallocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|nbytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|dumpfd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   *  Turns recording of FILE and LINE number of each call to  *  malloc/free/realloc/calloc/cfree/memalign/valloc on (if value != 0)  *  or off, (if value == 0)  */
end_comment

begin_function
name|void
name|mal_leaktrace
parameter_list|(
name|value
parameter_list|)
name|int
name|value
decl_stmt|;
block|{
name|_malloc_leaktrace
operator|=
operator|(
name|value
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|sp
operator|=
name|__spinit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  The routine which actually does the printing. I know it is silly to  *  print address in decimal, but sort doesn't read hex, so sorting the  *  printed data by address is impossible otherwise. Urr. The format is  *		FILE:LINE: sequence_number address_in_decimal (address_in_hex)  */
end_comment

begin_function
name|void
name|__m_prnode
parameter_list|(
name|spblk
parameter_list|)
name|SPBLK
modifier|*
name|spblk
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|spblk
operator|->
name|datb
operator|<
name|min_num
condition|)
return|return;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|_malloc_statsbuf
argument_list|,
literal|"%s%8lu %8lu(0x%08lx)\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|spblk
operator|->
name|data
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|spblk
operator|->
name|datb
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|spblk
operator|->
name|key
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|spblk
operator|->
name|key
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|_malloc_statsbuf
argument_list|,
name|dumpfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Dumps all blocks which have been recorded.  */
end_comment

begin_function
name|void
name|mal_dumpleaktrace
parameter_list|(
name|fd
parameter_list|)
name|FILE
modifier|*
name|fd
decl_stmt|;
block|{
name|dumpfd
operator|=
name|fd
expr_stmt|;
name|__spscan
argument_list|(
name|__m_prnode
argument_list|,
operator|(
name|SPBLK
operator|*
operator|)
name|NULL
argument_list|,
name|sp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|dumpfd
argument_list|)
expr_stmt|;
name|min_num
operator|=
name|num
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Inserts a copy of a string keyed by the address addr into the tree  *  that stores the leak trace information. The string is presumably of  *  the form "file:linenumber:". It also stores a sequence number that  *  gets incremented with each call to this routine.  */
end_comment

begin_function
name|void
name|__m_install_record
parameter_list|(
name|addr
parameter_list|,
name|s
parameter_list|)
name|univptr_t
name|addr
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|num
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|__spadd
argument_list|(
name|addr
argument_list|,
name|strsave
argument_list|(
name|s
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|num
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deletes the record keyed by addr if it exists */
end_comment

begin_function
name|void
name|__m_delete_record
parameter_list|(
name|addr
parameter_list|)
name|univptr_t
name|addr
decl_stmt|;
block|{
name|SPBLK
modifier|*
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|__splookup
argument_list|(
name|addr
argument_list|,
name|sp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|result
operator|->
name|data
argument_list|)
expr_stmt|;
name|result
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|__spdelete
argument_list|(
name|result
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|__m_count
parameter_list|(
name|spblk
parameter_list|)
name|SPBLK
modifier|*
name|spblk
decl_stmt|;
block|{
name|Word
modifier|*
name|p
decl_stmt|;
name|nmallocs
operator|++
expr_stmt|;
name|p
operator|=
operator|(
name|Word
operator|*
operator|)
name|spblk
operator|->
name|key
expr_stmt|;
name|p
operator|-=
name|HEADERWORDS
expr_stmt|;
comment|/* A little paranoia... */
name|ASSERT
argument_list|(
name|PTR_IN_HEAP
argument_list|(
name|p
argument_list|)
argument_list|,
literal|"bad pointer seen in __m_count"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|TAG
argument_list|(
name|p
argument_list|)
operator|!=
name|FREE
argument_list|,
literal|"freed block seen in __m_count"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_START_SIZE_FIELD
argument_list|(
name|p
argument_list|)
argument_list|,
literal|"corrupt block seen in __m_count"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_MAGIC
argument_list|(
name|p
argument_list|)
argument_list|,
literal|"block with end overwritten seen in __m_count"
argument_list|)
expr_stmt|;
name|nbytes
operator|+=
name|SIZE
argument_list|(
name|p
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|mal_contents
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|void
name|__m_count
name|proto
argument_list|(
operator|(
name|SPBLK
operator|*
operator|)
argument_list|)
decl_stmt|;
name|nmallocs
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|=
literal|0
expr_stmt|;
name|__spscan
argument_list|(
name|__m_count
argument_list|,
operator|(
name|SPBLK
operator|*
operator|)
name|NULL
argument_list|,
name|sp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|_malloc_statsbuf
argument_list|,
literal|"%% %lu bytes %lu mallocs %lu available %lu vm\n"
argument_list|,
name|nbytes
argument_list|,
name|nmallocs
argument_list|,
operator|(
name|ulong
operator|)
name|_malloc_totalavail
argument_list|,
operator|(
name|ulong
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|_malloc_statsbuf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

