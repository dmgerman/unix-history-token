begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Author: Mark Moraes<moraes@csri.toronto.edu> */
end_comment

begin_comment
comment|/*LINTLIBRARY*/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_macro
name|RCSID
argument_list|(
literal|"$Id: verify.c,v 1.11 1993/05/23 03:38:27 moraes Exp $"
argument_list|)
end_macro

begin_comment
comment|/*  *  Goes through the entire heap checking all pointers, tags for  *  consistency. Should catch most casual heap corruption (overwriting  *  the end of a malloc'ed chunk, etc..) Nonetheless, heap corrupters  *  tend to be devious and ingenious in ways they corrupt heaps (Believe  *  me, I know:-). We should probably do the same thing if DEBUG is not  *  defined, but return 0 instead of aborting. If fullcheck is non-zero,  *  it also checks that free blocks contain the magic pattern written  *  into them when they were freed to make sure the program is not still  *  trying to access those blocks.  */
end_comment

begin_function
name|int
name|mal_verify
parameter_list|(
name|fullcheck
parameter_list|)
name|int
name|fullcheck
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|REGISTER
name|Word
modifier|*
name|ptr
decl_stmt|;
name|REGISTER
name|Word
modifier|*
name|blk
decl_stmt|;
name|REGISTER
name|Word
modifier|*
name|blkend
decl_stmt|;
if|if
condition|(
name|_malloc_loword
operator|==
name|NULL
condition|)
comment|/* Nothing malloc'ed yet */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|_malloc_rover
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|PTR_IN_HEAP
argument_list|(
name|_malloc_rover
argument_list|)
argument_list|,
literal|"corrupt ROVER pointer found by mal_verify()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_END_SIZE_FIELD
argument_list|(
name|_malloc_rover
argument_list|)
argument_list|,
literal|"corrupt ROVER SIZE field found by mal_verify()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_NEXT_PTR
argument_list|(
name|_malloc_rover
argument_list|)
argument_list|,
literal|"corrupt ROVER NEXT pointer found by mal_verify()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_PREV_PTR
argument_list|(
name|_malloc_rover
argument_list|)
argument_list|,
literal|"corrupt ROVER PREV pointer found by mal_verify()"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ptr
operator|=
name|_malloc_mem
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
comment|/* 		 *  Check arena bounds - not same as checking block tags, 		 *  despite similar appearance of the test 		 */
name|ASSERT
argument_list|(
name|SIZEFIELD
argument_list|(
name|ptr
operator|+
literal|1
argument_list|)
operator|==
name|SIZEFIELD
argument_list|(
name|ptr
operator|+
name|SIZE
argument_list|(
name|ptr
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|"corrupt malloc arena found by mal_verify"
argument_list|)
expr_stmt|;
name|blkend
operator|=
name|ptr
operator|+
name|SIZE
argument_list|(
name|ptr
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|blk
operator|=
name|ptr
operator|+
name|ARENASTART
init|;
name|blk
operator|<
name|blkend
condition|;
name|blk
operator|+=
name|SIZE
argument_list|(
name|blk
argument_list|)
control|)
block|{
name|ASSERT
argument_list|(
name|PTR_IN_HEAP
argument_list|(
name|blk
argument_list|)
argument_list|,
literal|"corrupt pointer found by mal_verify()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_START_SIZE_FIELD
argument_list|(
name|blk
argument_list|)
argument_list|,
literal|"corrupt SIZE field found by mal_verify()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAG
argument_list|(
name|blk
argument_list|)
operator|==
name|FREE
condition|)
block|{
name|ASSERT
argument_list|(
name|VALID_NEXT_PTR
argument_list|(
name|blk
operator|+
name|FREESIZE
argument_list|(
name|blk
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
literal|"corrupt NEXT pointer found by mal_verify()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_PREV_PTR
argument_list|(
name|blk
operator|+
name|FREESIZE
argument_list|(
name|blk
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
literal|"corrupt PREV pointer found by mal_verify()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullcheck
condition|)
block|{
comment|/* Make sure all free blocks are filled with FREEMAGIC */
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|n
operator|=
operator|(
name|SIZE
argument_list|(
name|blk
argument_list|)
operator|-
name|FREE_OVERHEAD
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|blk
operator|+
name|FREEHEADERWORDS
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|cp
operator|++
control|)
block|{
name|ASSERT
argument_list|(
operator|*
name|cp
operator|==
name|FREEMAGIC
argument_list|,
literal|"corrupt free block found by mal_verify()"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|VALID_MAGIC
argument_list|(
name|blk
argument_list|)
argument_list|,
literal|"overwritten end of block found by mal_verify()"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

