begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  This file contains a few splay tree routines snarfed from David  *  Brower's package, with globals renamed to keep them internal to the  *  malloc, and not clash with similar routines that the application may  *  use. The comments have been left with the original names - most of  *  the renaming just involved prepending an __ before the name -  *  spinstall got remapped to __spadd. Function prototypes added for  *  external declarations. - Mark Moraes.  */
end_comment

begin_comment
comment|/*  * spdaveb.c -- daveb's new splay tree functions.  *  * The functions in this file provide an interface that is nearly  * the same as the hash library I swiped from mkmf, allowing  * replacement of one by the other.  Hey, it worked for me!  *  * splookup() -- given a key, find a node in a tree.  * spinstall() -- install an item in the tree, overwriting existing value.  * spfhead() -- fast (non-splay) find the first node in a tree.  * spscan() -- forward scan tree from the head.  * spfnext() -- non-splaying next.  * spstats() -- make char string of stats for a tree.  *  * Written by David Brower, daveb@rtech.uucp 1/88.  */
end_comment

begin_comment
comment|/*LINTLIBRARY*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|ANSI_TYPES
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_define
define|#
directive|define
name|COMPARE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((char *) (a)) - ((char *) (b)))
end_define

begin_include
include|#
directive|include
file|"sptree.h"
end_include

begin_comment
comment|/* insert item into the tree */
end_comment

begin_decl_stmt
specifier|static
name|SPBLK
modifier|*
name|spenq
name|proto
argument_list|(
operator|(
name|SPBLK
operator|*
operator|,
name|SPTREE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* return and remove lowest item in subtree */
end_comment

begin_decl_stmt
specifier|static
name|SPBLK
modifier|*
name|spdeq
name|proto
argument_list|(
operator|(
name|SPBLK
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reorganize tree */
end_comment

begin_decl_stmt
specifier|static
name|void
name|splay
name|proto
argument_list|(
operator|(
name|SPBLK
operator|*
operator|,
name|SPTREE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fast non-splaying head */
end_comment

begin_decl_stmt
specifier|static
name|SPBLK
modifier|*
name|spfhead
name|proto
argument_list|(
operator|(
name|SPTREE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fast non-splaying next */
end_comment

begin_decl_stmt
specifier|static
name|SPBLK
modifier|*
name|spfnext
name|proto
argument_list|(
operator|(
name|SPBLK
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* USER SUPPLIED! */
end_comment

begin_decl_stmt
specifier|extern
name|univptr_t
name|emalloc
name|proto
argument_list|(
operator|(
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*----------------  *  * splookup() -- given key, find a node in a tree.  *  *	Splays the found node to the root.  */
end_comment

begin_function
name|SPBLK
modifier|*
name|__splookup
parameter_list|(
name|key
parameter_list|,
name|q
parameter_list|)
name|REGISTER
name|univptr_t
name|key
decl_stmt|;
name|REGISTER
name|SPTREE
modifier|*
name|q
decl_stmt|;
block|{
name|REGISTER
name|SPBLK
modifier|*
name|n
decl_stmt|;
name|REGISTER
name|int
name|Sct
decl_stmt|;
name|REGISTER
name|int
name|c
decl_stmt|;
comment|/* find node in the tree */
name|n
operator|=
name|q
operator|->
name|root
expr_stmt|;
name|c
operator|=
operator|++
operator|(
name|q
operator|->
name|lkpcmps
operator|)
expr_stmt|;
name|q
operator|->
name|lookups
operator|++
expr_stmt|;
while|while
condition|(
name|n
operator|&&
operator|(
name|Sct
operator|=
name|COMPARE
argument_list|(
name|key
argument_list|,
name|n
operator|->
name|key
argument_list|)
operator|)
condition|)
block|{
name|c
operator|++
expr_stmt|;
name|n
operator|=
operator|(
name|Sct
operator|<
literal|0
operator|)
condition|?
name|n
operator|->
name|leftlink
else|:
name|n
operator|->
name|rightlink
expr_stmt|;
block|}
name|q
operator|->
name|lkpcmps
operator|=
name|c
expr_stmt|;
comment|/* reorganize tree around this node */
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
name|splay
argument_list|(
name|n
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------  *  * spinstall() -- install an entry in a tree, overwriting any existing node.  *  *	If the node already exists, replace its contents.  *	If it does not exist, then allocate a new node and fill it in.  */
end_comment

begin_function
name|SPBLK
modifier|*
name|__spadd
parameter_list|(
name|key
parameter_list|,
name|data
parameter_list|,
name|datb
parameter_list|,
name|q
parameter_list|)
name|REGISTER
name|univptr_t
name|key
decl_stmt|;
name|REGISTER
name|univptr_t
name|data
decl_stmt|;
name|REGISTER
name|univptr_t
name|datb
decl_stmt|;
name|REGISTER
name|SPTREE
modifier|*
name|q
decl_stmt|;
block|{
name|REGISTER
name|SPBLK
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|n
operator|=
name|__splookup
argument_list|(
name|key
argument_list|,
name|q
argument_list|)
operator|)
condition|)
block|{
name|n
operator|=
operator|(
name|SPBLK
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|key
operator|=
operator|(
name|univptr_t
operator|)
name|key
expr_stmt|;
name|n
operator|->
name|leftlink
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|rightlink
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|uplink
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|spenq
argument_list|(
name|n
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
name|n
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|n
operator|->
name|datb
operator|=
name|datb
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------  *  * spfhead() --	return the "lowest" element in the tree.  *  *	returns a reference to the head event in the event-set q.  *	avoids splaying but just searches for and returns a pointer to  *	the bottom of the left branch.  */
end_comment

begin_function
specifier|static
name|SPBLK
modifier|*
name|spfhead
parameter_list|(
name|q
parameter_list|)
name|REGISTER
name|SPTREE
modifier|*
name|q
decl_stmt|;
block|{
name|REGISTER
name|SPBLK
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|x
operator|=
name|q
operator|->
name|root
operator|)
condition|)
while|while
condition|(
name|x
operator|->
name|leftlink
operator|!=
name|NULL
condition|)
name|x
operator|=
name|x
operator|->
name|leftlink
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/* spfhead */
end_comment

begin_comment
comment|/*----------------  *  * spscan() -- apply a function to nodes in ascending order.  *  *	if n is given, start at that node, otherwise start from  *	the head.  */
end_comment

begin_decl_stmt
name|void
name|__spscan
argument_list|(
name|f
argument_list|,
name|n
argument_list|,
name|q
argument_list|)
name|REGISTER
name|void
argument_list|(
operator|*
name|f
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REGISTER
name|SPBLK
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REGISTER
name|SPTREE
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REGISTER
name|SPBLK
modifier|*
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|n
operator|!=
name|NULL
condition|?
name|n
else|:
name|spfhead
argument_list|(
name|q
argument_list|)
init|;
name|x
operator|!=
name|NULL
condition|;
name|x
operator|=
name|spfnext
argument_list|(
name|x
argument_list|)
control|)
call|(
modifier|*
name|f
call|)
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------  *  * spfnext() -- fast return next higer item in the tree, or NULL.  *  *	return the successor of n in q, represented as a splay tree.  *	This is a fast (on average) version that does not splay.  */
end_comment

begin_function
specifier|static
name|SPBLK
modifier|*
name|spfnext
parameter_list|(
name|n
parameter_list|)
name|REGISTER
name|SPBLK
modifier|*
name|n
decl_stmt|;
block|{
name|REGISTER
name|SPBLK
modifier|*
name|next
decl_stmt|;
name|REGISTER
name|SPBLK
modifier|*
name|x
decl_stmt|;
comment|/* a long version, avoids splaying for fast average,      * poor amortized bound      */
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
operator|(
name|n
operator|)
return|;
name|x
operator|=
name|n
operator|->
name|rightlink
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|x
operator|->
name|leftlink
operator|!=
name|NULL
condition|)
name|x
operator|=
name|x
operator|->
name|leftlink
expr_stmt|;
name|next
operator|=
name|x
expr_stmt|;
block|}
else|else
comment|/* x == NULL */
block|{
name|x
operator|=
name|n
operator|->
name|uplink
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|x
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|x
operator|->
name|leftlink
operator|==
name|n
condition|)
block|{
name|next
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|n
operator|->
name|uplink
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

begin_comment
comment|/* spfnext */
end_comment

begin_function
name|char
modifier|*
name|__spstats
parameter_list|(
name|q
parameter_list|)
name|SPTREE
modifier|*
name|q
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|float
name|llen
decl_stmt|;
name|float
name|elen
decl_stmt|;
name|float
name|sloops
decl_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
return|return
operator|(
literal|""
operator|)
return|;
name|llen
operator|=
name|q
operator|->
name|lookups
condition|?
operator|(
name|float
operator|)
name|q
operator|->
name|lkpcmps
operator|/
name|q
operator|->
name|lookups
else|:
literal|0
expr_stmt|;
name|elen
operator|=
name|q
operator|->
name|enqs
condition|?
operator|(
name|float
operator|)
name|q
operator|->
name|enqcmps
operator|/
name|q
operator|->
name|enqs
else|:
literal|0
expr_stmt|;
name|sloops
operator|=
name|q
operator|->
name|splays
condition|?
operator|(
name|float
operator|)
name|q
operator|->
name|splayloops
operator|/
name|q
operator|->
name|splays
else|:
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"f(%d %4.2f) i(%d %4.2f) s(%d %4.2f)"
argument_list|,
name|q
operator|->
name|lookups
argument_list|,
name|llen
argument_list|,
name|q
operator|->
name|enqs
argument_list|,
name|elen
argument_list|,
name|q
operator|->
name|splays
argument_list|,
name|sloops
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*   spaux.c:  This code implements the following operations on an event-set   or priority-queue implemented using splay trees:      spdelete( n, q )		n is removed from q.      In the above, n and np are pointers to single items (type   SPBLK *); q is an event-set (type SPTREE *),   The type definitions for these are taken   from file sptree.h.  All of these operations rest on basic   splay tree operations from file sptree.c.      The basic splay tree algorithms were originally presented in:      Self Adjusting Binary Trees,   by D. D. Sleator and R. E. Tarjan,   Proc. ACM SIGACT Symposium on Theory   of Computing (Boston, Apr 1983) 235-245.      The operations in this package supplement the operations from   file splay.h to provide support for operations typically needed   on the pending event set in discrete event simulation.  See, for   example,      Introduction to Simula 67,   by Gunther Lamprecht, Vieweg& Sohn, Braucschweig, Wiesbaden, 1981.   (Chapter 14 contains the relevant discussion.)      Simula Begin,   by Graham M. Birtwistle, et al, Studentlitteratur, Lund, 1979.   (Chapter 9 contains the relevant discussion.)      Many of the routines in this package use the splay procedure,   for bottom-up splaying of the queue.  Consequently, item n in   delete and item np in all operations listed above must be in the   event-set prior to the call or the results will be   unpredictable (eg:  chaos will ensue).      Note that, in all cases, these operations can be replaced with   the corresponding operations formulated for a conventional   lexicographically ordered tree.  The versions here all use the   splay operation to ensure the amortized bounds; this usually   leads to a very compact formulation of the operations   themselves, but it may slow the average performance.      Alternative versions based on simple binary tree operations are   provided (commented out) for head, next, and prev, since these   are frequently used to traverse the entire data structure, and   the cost of traversal is independent of the shape of the   structure, so the extra time taken by splay in this context is   wasted.      This code was written by:   Douglas W. Jones with assistance from Srinivas R. Sataluri      Translated to C by David Brower, daveb@rtech.uucp      Thu Oct  6 12:11:33 PDT 1988 (daveb) Fixed spdeq, which was broken  	handling one-node trees.  I botched the pascal translation of  	a VAR parameter.  Changed interface, so callers must also be 	corrected to pass the node by address rather than value.   Mon Apr  3 15:18:32 PDT 1989 (daveb)   	Apply fix supplied by Mark Moraes<moraes@csri.toronto.edu> to 	spdelete(), which dropped core when taking out the last element 	in a subtree -- that is, when the right subtree was empty and 	the leftlink was also null, it tried to take out the leftlink's 	uplink anyway.  */
end_comment

begin_comment
comment|/*----------------  *  * spdelete() -- Delete node from a tree.  *  *	n is deleted from q; the resulting splay tree has been splayed  *	around its new root, which is the successor of n  *  */
end_comment

begin_function
name|void
name|__spdelete
parameter_list|(
name|n
parameter_list|,
name|q
parameter_list|)
name|REGISTER
name|SPBLK
modifier|*
name|n
decl_stmt|;
name|REGISTER
name|SPTREE
modifier|*
name|q
decl_stmt|;
block|{
name|REGISTER
name|SPBLK
modifier|*
name|x
decl_stmt|;
name|splay
argument_list|(
name|n
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|x
operator|=
name|spdeq
argument_list|(
operator|&
name|q
operator|->
name|root
operator|->
name|rightlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
comment|/* empty right subtree */
block|{
name|q
operator|->
name|root
operator|=
name|q
operator|->
name|root
operator|->
name|leftlink
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|root
condition|)
name|q
operator|->
name|root
operator|->
name|uplink
operator|=
name|NULL
expr_stmt|;
block|}
else|else
comment|/* non-empty right subtree */
block|{
name|x
operator|->
name|uplink
operator|=
name|NULL
expr_stmt|;
name|x
operator|->
name|leftlink
operator|=
name|q
operator|->
name|root
operator|->
name|leftlink
expr_stmt|;
name|x
operator|->
name|rightlink
operator|=
name|q
operator|->
name|root
operator|->
name|rightlink
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|leftlink
operator|!=
name|NULL
condition|)
name|x
operator|->
name|leftlink
operator|->
name|uplink
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|rightlink
operator|!=
name|NULL
condition|)
name|x
operator|->
name|rightlink
operator|->
name|uplink
operator|=
name|x
expr_stmt|;
name|q
operator|->
name|root
operator|=
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* spdelete */
end_comment

begin_comment
comment|/*  *  *  sptree.c:  The following code implements the basic operations on  *  an event-set or priority-queue implemented using splay trees:  *  *  SPTREE *spinit( compare )	Make a new tree  *  SPBLK *spenq( n, q )	Insert n in q after all equal keys.  *  SPBLK *spdeq( np )		Return first key under *np, removing it.  *  void splay( n, q )		n (already in q) becomes the root.  *  *  In the above, n points to an SPBLK type, while q points to an  *  SPTREE.  *  *  The implementation used here is based on the implementation  *  which was used in the tests of splay trees reported in:  *  *    An Empirical Comparison of Priority-Queue and Event-Set Implementations,  *	by Douglas W. Jones, Comm. ACM 29, 4 (Apr. 1986) 300-311.  *  *  The changes made include the addition of the enqprior  *  operation and the addition of up-links to allow for the splay  *  operation.  The basic splay tree algorithms were originally  *  presented in:  *  *	Self Adjusting Binary Trees,  *		by D. D. Sleator and R. E. Tarjan,  *			Proc. ACM SIGACT Symposium on Theory  *			of Computing (Boston, Apr 1983) 235-245.  *  *  The enq and enqprior routines use variations on the  *  top-down splay operation, while the splay routine is bottom-up.  *  All are coded for speed.  *  *  Written by:  *    Douglas W. Jones  *  *  Translated to C by:  *    David Brower, daveb@rtech.uucp  *  * Thu Oct  6 12:11:33 PDT 1988 (daveb) Fixed spdeq, which was broken  *	handling one-node trees.  I botched the pascal translation of  *	a VAR parameter.  */
end_comment

begin_comment
comment|/*----------------  *  * spinit() -- initialize an empty splay tree  *  */
end_comment

begin_function
name|SPTREE
modifier|*
name|__spinit
parameter_list|()
block|{
name|REGISTER
name|SPTREE
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
name|SPTREE
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|lookups
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|lkpcmps
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|enqs
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|enqcmps
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|splays
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|splayloops
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|root
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------  *  *  spenq() -- insert item in a tree.  *  *  put n in q after all other nodes with the same key; when this is  *  done, n will be the root of the splay tree representing q, all nodes  *  in q with keys less than or equal to that of n will be in the  *  left subtree, all with greater keys will be in the right subtree;  *  the tree is split into these subtrees from the top down, with rotations  *  performed along the way to shorten the left branch of the right subtree  *  and the right branch of the left subtree  */
end_comment

begin_function
specifier|static
name|SPBLK
modifier|*
name|spenq
parameter_list|(
name|n
parameter_list|,
name|q
parameter_list|)
name|REGISTER
name|SPBLK
modifier|*
name|n
decl_stmt|;
name|REGISTER
name|SPTREE
modifier|*
name|q
decl_stmt|;
block|{
name|REGISTER
name|SPBLK
modifier|*
name|left
decl_stmt|;
comment|/* the rightmost node in the left tree */
name|REGISTER
name|SPBLK
modifier|*
name|right
decl_stmt|;
comment|/* the leftmost node in the right tree */
name|REGISTER
name|SPBLK
modifier|*
name|next
decl_stmt|;
comment|/* the root of the unsplit part */
name|REGISTER
name|SPBLK
modifier|*
name|temp
decl_stmt|;
name|REGISTER
name|univptr_t
name|key
decl_stmt|;
name|q
operator|->
name|enqs
operator|++
expr_stmt|;
name|n
operator|->
name|uplink
operator|=
name|NULL
expr_stmt|;
name|next
operator|=
name|q
operator|->
name|root
expr_stmt|;
name|q
operator|->
name|root
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
comment|/* trivial enq */
block|{
name|n
operator|->
name|leftlink
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|rightlink
operator|=
name|NULL
expr_stmt|;
block|}
else|else
comment|/* difficult enq */
block|{
name|key
operator|=
name|n
operator|->
name|key
expr_stmt|;
name|left
operator|=
name|n
expr_stmt|;
name|right
operator|=
name|n
expr_stmt|;
comment|/* n's left and right children will hold the right and left 	   splayed trees resulting from splitting on n->key; 	   note that the children will be reversed! */
name|q
operator|->
name|enqcmps
operator|++
expr_stmt|;
if|if
condition|(
name|COMPARE
argument_list|(
name|next
operator|->
name|key
argument_list|,
name|key
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|two
goto|;
name|one
label|:
comment|/* assert next->key<= key */
do|do
comment|/* walk to the right in the left tree */
block|{
name|temp
operator|=
name|next
operator|->
name|rightlink
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|left
operator|->
name|rightlink
operator|=
name|next
expr_stmt|;
name|next
operator|->
name|uplink
operator|=
name|left
expr_stmt|;
name|right
operator|->
name|leftlink
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* job done, entire tree split */
block|}
name|q
operator|->
name|enqcmps
operator|++
expr_stmt|;
if|if
condition|(
name|COMPARE
argument_list|(
name|temp
operator|->
name|key
argument_list|,
name|key
argument_list|)
operator|>
literal|0
condition|)
block|{
name|left
operator|->
name|rightlink
operator|=
name|next
expr_stmt|;
name|next
operator|->
name|uplink
operator|=
name|left
expr_stmt|;
name|left
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|temp
expr_stmt|;
goto|goto
name|two
goto|;
comment|/* change sides */
block|}
name|next
operator|->
name|rightlink
operator|=
name|temp
operator|->
name|leftlink
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|leftlink
operator|!=
name|NULL
condition|)
name|temp
operator|->
name|leftlink
operator|->
name|uplink
operator|=
name|next
expr_stmt|;
name|left
operator|->
name|rightlink
operator|=
name|temp
expr_stmt|;
name|temp
operator|->
name|uplink
operator|=
name|left
expr_stmt|;
name|temp
operator|->
name|leftlink
operator|=
name|next
expr_stmt|;
name|next
operator|->
name|uplink
operator|=
name|temp
expr_stmt|;
name|left
operator|=
name|temp
expr_stmt|;
name|next
operator|=
name|temp
operator|->
name|rightlink
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
name|right
operator|->
name|leftlink
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* job done, entire tree split */
block|}
name|q
operator|->
name|enqcmps
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|COMPARE
argument_list|(
name|next
operator|->
name|key
argument_list|,
name|key
argument_list|)
operator|<=
literal|0
condition|)
do|;
comment|/* change sides */
name|two
label|:
comment|/* assert next->key> key */
do|do
comment|/* walk to the left in the right tree */
block|{
name|temp
operator|=
name|next
operator|->
name|leftlink
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|right
operator|->
name|leftlink
operator|=
name|next
expr_stmt|;
name|next
operator|->
name|uplink
operator|=
name|right
expr_stmt|;
name|left
operator|->
name|rightlink
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* job done, entire tree split */
block|}
name|q
operator|->
name|enqcmps
operator|++
expr_stmt|;
if|if
condition|(
name|COMPARE
argument_list|(
name|temp
operator|->
name|key
argument_list|,
name|key
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|right
operator|->
name|leftlink
operator|=
name|next
expr_stmt|;
name|next
operator|->
name|uplink
operator|=
name|right
expr_stmt|;
name|right
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|temp
expr_stmt|;
goto|goto
name|one
goto|;
comment|/* change sides */
block|}
name|next
operator|->
name|leftlink
operator|=
name|temp
operator|->
name|rightlink
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|rightlink
operator|!=
name|NULL
condition|)
name|temp
operator|->
name|rightlink
operator|->
name|uplink
operator|=
name|next
expr_stmt|;
name|right
operator|->
name|leftlink
operator|=
name|temp
expr_stmt|;
name|temp
operator|->
name|uplink
operator|=
name|right
expr_stmt|;
name|temp
operator|->
name|rightlink
operator|=
name|next
expr_stmt|;
name|next
operator|->
name|uplink
operator|=
name|temp
expr_stmt|;
name|right
operator|=
name|temp
expr_stmt|;
name|next
operator|=
name|temp
operator|->
name|leftlink
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
name|left
operator|->
name|rightlink
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* job done, entire tree split */
block|}
name|q
operator|->
name|enqcmps
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|COMPARE
argument_list|(
name|next
operator|->
name|key
argument_list|,
name|key
argument_list|)
operator|>
literal|0
condition|)
do|;
comment|/* change sides */
goto|goto
name|one
goto|;
name|done
label|:
comment|/* split is done, branches of n need reversal */
name|temp
operator|=
name|n
operator|->
name|leftlink
expr_stmt|;
name|n
operator|->
name|leftlink
operator|=
name|n
operator|->
name|rightlink
expr_stmt|;
name|n
operator|->
name|rightlink
operator|=
name|temp
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/* spenq */
end_comment

begin_comment
comment|/*----------------  *  *  spdeq() -- return and remove head node from a subtree.  *  *  remove and return the head node from the node set; this deletes  *  (and returns) the leftmost node from q, replacing it with its right  *  subtree (if there is one); on the way to the leftmost node, rotations  *  are performed to shorten the left branch of the tree  */
end_comment

begin_function
specifier|static
name|SPBLK
modifier|*
name|spdeq
parameter_list|(
name|np
parameter_list|)
name|SPBLK
modifier|*
modifier|*
name|np
decl_stmt|;
comment|/* pointer to a node pointer */
block|{
name|REGISTER
name|SPBLK
modifier|*
name|deq
decl_stmt|;
comment|/* one to return */
name|REGISTER
name|SPBLK
modifier|*
name|next
decl_stmt|;
comment|/* the next thing to deal with */
name|REGISTER
name|SPBLK
modifier|*
name|left
decl_stmt|;
comment|/* the left child of next */
name|REGISTER
name|SPBLK
modifier|*
name|farleft
decl_stmt|;
comment|/* the left child of left */
name|REGISTER
name|SPBLK
modifier|*
name|farfarleft
decl_stmt|;
comment|/* the left child of farleft */
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
operator|*
name|np
operator|==
name|NULL
condition|)
block|{
name|deq
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
operator|*
name|np
expr_stmt|;
name|left
operator|=
name|next
operator|->
name|leftlink
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|NULL
condition|)
block|{
name|deq
operator|=
name|next
expr_stmt|;
operator|*
name|np
operator|=
name|next
operator|->
name|rightlink
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|np
operator|)
operator|->
name|uplink
operator|=
name|NULL
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
condition|;
control|)
comment|/* left is not null */
block|{
comment|/* next is not it, left is not NULL, might be it */
name|farleft
operator|=
name|left
operator|->
name|leftlink
expr_stmt|;
if|if
condition|(
name|farleft
operator|==
name|NULL
condition|)
block|{
name|deq
operator|=
name|left
expr_stmt|;
name|next
operator|->
name|leftlink
operator|=
name|left
operator|->
name|rightlink
expr_stmt|;
if|if
condition|(
name|left
operator|->
name|rightlink
operator|!=
name|NULL
condition|)
name|left
operator|->
name|rightlink
operator|->
name|uplink
operator|=
name|next
expr_stmt|;
break|break;
block|}
comment|/* next, left are not it, farleft is not NULL, might be it */
name|farfarleft
operator|=
name|farleft
operator|->
name|leftlink
expr_stmt|;
if|if
condition|(
name|farfarleft
operator|==
name|NULL
condition|)
block|{
name|deq
operator|=
name|farleft
expr_stmt|;
name|left
operator|->
name|leftlink
operator|=
name|farleft
operator|->
name|rightlink
expr_stmt|;
if|if
condition|(
name|farleft
operator|->
name|rightlink
operator|!=
name|NULL
condition|)
name|farleft
operator|->
name|rightlink
operator|->
name|uplink
operator|=
name|left
expr_stmt|;
break|break;
block|}
comment|/* next, left, farleft are not it, rotate */
name|next
operator|->
name|leftlink
operator|=
name|farleft
expr_stmt|;
name|farleft
operator|->
name|uplink
operator|=
name|next
expr_stmt|;
name|left
operator|->
name|leftlink
operator|=
name|farleft
operator|->
name|rightlink
expr_stmt|;
if|if
condition|(
name|farleft
operator|->
name|rightlink
operator|!=
name|NULL
condition|)
name|farleft
operator|->
name|rightlink
operator|->
name|uplink
operator|=
name|left
expr_stmt|;
name|farleft
operator|->
name|rightlink
operator|=
name|left
expr_stmt|;
name|left
operator|->
name|uplink
operator|=
name|farleft
expr_stmt|;
name|next
operator|=
name|farleft
expr_stmt|;
name|left
operator|=
name|farfarleft
expr_stmt|;
block|}
block|}
return|return
operator|(
name|deq
operator|)
return|;
block|}
end_function

begin_comment
comment|/* spdeq */
end_comment

begin_comment
comment|/*----------------  *  *  splay() -- reorganize the tree.  *  *  the tree is reorganized so that n is the root of the  *  splay tree representing q; results are unpredictable if n is not  *  in q to start with; q is split from n up to the old root, with all  *  nodes to the left of n ending up in the left subtree, and all nodes  *  to the right of n ending up in the right subtree; the left branch of  *  the right subtree and the right branch of the left subtree are  *  shortened in the process  *  *  this code assumes that n is not NULL and is in q; it can sometimes  *  detect n not in q and complain  */
end_comment

begin_function
specifier|static
name|void
name|splay
parameter_list|(
name|n
parameter_list|,
name|q
parameter_list|)
name|REGISTER
name|SPBLK
modifier|*
name|n
decl_stmt|;
name|SPTREE
modifier|*
name|q
decl_stmt|;
block|{
name|REGISTER
name|SPBLK
modifier|*
name|up
decl_stmt|;
comment|/* points to the node being dealt with */
name|REGISTER
name|SPBLK
modifier|*
name|prev
decl_stmt|;
comment|/* a descendent of up, already dealt with */
name|REGISTER
name|SPBLK
modifier|*
name|upup
decl_stmt|;
comment|/* the parent of up */
name|REGISTER
name|SPBLK
modifier|*
name|upupup
decl_stmt|;
comment|/* the grandparent of up */
name|REGISTER
name|SPBLK
modifier|*
name|left
decl_stmt|;
comment|/* the top of left subtree being built */
name|REGISTER
name|SPBLK
modifier|*
name|right
decl_stmt|;
comment|/* the top of right subtree being built */
name|left
operator|=
name|n
operator|->
name|leftlink
expr_stmt|;
name|right
operator|=
name|n
operator|->
name|rightlink
expr_stmt|;
name|prev
operator|=
name|n
expr_stmt|;
name|up
operator|=
name|prev
operator|->
name|uplink
expr_stmt|;
name|q
operator|->
name|splays
operator|++
expr_stmt|;
while|while
condition|(
name|up
operator|!=
name|NULL
condition|)
block|{
name|q
operator|->
name|splayloops
operator|++
expr_stmt|;
comment|/* walk up the tree towards the root, splaying all to the left of 	   n into the left subtree, all to right into the right subtree */
name|upup
operator|=
name|up
operator|->
name|uplink
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|leftlink
operator|==
name|prev
condition|)
comment|/* up is to the right of n */
block|{
if|if
condition|(
name|upup
operator|!=
name|NULL
operator|&&
name|upup
operator|->
name|leftlink
operator|==
name|up
condition|)
comment|/* rotate */
block|{
name|upupup
operator|=
name|upup
operator|->
name|uplink
expr_stmt|;
name|upup
operator|->
name|leftlink
operator|=
name|up
operator|->
name|rightlink
expr_stmt|;
if|if
condition|(
name|upup
operator|->
name|leftlink
operator|!=
name|NULL
condition|)
name|upup
operator|->
name|leftlink
operator|->
name|uplink
operator|=
name|upup
expr_stmt|;
name|up
operator|->
name|rightlink
operator|=
name|upup
expr_stmt|;
name|upup
operator|->
name|uplink
operator|=
name|up
expr_stmt|;
if|if
condition|(
name|upupup
operator|==
name|NULL
condition|)
name|q
operator|->
name|root
operator|=
name|up
expr_stmt|;
elseif|else
if|if
condition|(
name|upupup
operator|->
name|leftlink
operator|==
name|upup
condition|)
name|upupup
operator|->
name|leftlink
operator|=
name|up
expr_stmt|;
else|else
name|upupup
operator|->
name|rightlink
operator|=
name|up
expr_stmt|;
name|up
operator|->
name|uplink
operator|=
name|upupup
expr_stmt|;
name|upup
operator|=
name|upupup
expr_stmt|;
block|}
name|up
operator|->
name|leftlink
operator|=
name|right
expr_stmt|;
if|if
condition|(
name|right
operator|!=
name|NULL
condition|)
name|right
operator|->
name|uplink
operator|=
name|up
expr_stmt|;
name|right
operator|=
name|up
expr_stmt|;
block|}
else|else
comment|/* up is to the left of n */
block|{
if|if
condition|(
name|upup
operator|!=
name|NULL
operator|&&
name|upup
operator|->
name|rightlink
operator|==
name|up
condition|)
comment|/* rotate */
block|{
name|upupup
operator|=
name|upup
operator|->
name|uplink
expr_stmt|;
name|upup
operator|->
name|rightlink
operator|=
name|up
operator|->
name|leftlink
expr_stmt|;
if|if
condition|(
name|upup
operator|->
name|rightlink
operator|!=
name|NULL
condition|)
name|upup
operator|->
name|rightlink
operator|->
name|uplink
operator|=
name|upup
expr_stmt|;
name|up
operator|->
name|leftlink
operator|=
name|upup
expr_stmt|;
name|upup
operator|->
name|uplink
operator|=
name|up
expr_stmt|;
if|if
condition|(
name|upupup
operator|==
name|NULL
condition|)
name|q
operator|->
name|root
operator|=
name|up
expr_stmt|;
elseif|else
if|if
condition|(
name|upupup
operator|->
name|rightlink
operator|==
name|upup
condition|)
name|upupup
operator|->
name|rightlink
operator|=
name|up
expr_stmt|;
else|else
name|upupup
operator|->
name|leftlink
operator|=
name|up
expr_stmt|;
name|up
operator|->
name|uplink
operator|=
name|upupup
expr_stmt|;
name|upup
operator|=
name|upupup
expr_stmt|;
block|}
name|up
operator|->
name|rightlink
operator|=
name|left
expr_stmt|;
if|if
condition|(
name|left
operator|!=
name|NULL
condition|)
name|left
operator|->
name|uplink
operator|=
name|up
expr_stmt|;
name|left
operator|=
name|up
expr_stmt|;
block|}
name|prev
operator|=
name|up
expr_stmt|;
name|up
operator|=
name|upup
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SPLAYDEBUG
if|if
condition|(
name|q
operator|->
name|root
operator|!=
name|prev
condition|)
block|{
comment|/*	fprintf(stderr, " *** bug in splay: n not in q *** " ); */
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|n
operator|->
name|leftlink
operator|=
name|left
expr_stmt|;
name|n
operator|->
name|rightlink
operator|=
name|right
expr_stmt|;
if|if
condition|(
name|left
operator|!=
name|NULL
condition|)
name|left
operator|->
name|uplink
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|right
operator|!=
name|NULL
condition|)
name|right
operator|->
name|uplink
operator|=
name|n
expr_stmt|;
name|q
operator|->
name|root
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|uplink
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* splay */
end_comment

end_unit

