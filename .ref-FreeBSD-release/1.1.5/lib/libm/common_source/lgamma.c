begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)lgamma.c	5.11 (Berkeley) 12/16/92"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Coded by Peter McIlroy, Nov 1992;  *  * The financial support of UUNET Communications Services is greatfully  * acknowledged.  */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"mathimpl.h"
end_include

begin_comment
comment|/* Log gamma function.  * Error:  x> 0 error< 1.3ulp.  *	   x> 4, error< 1ulp.  *	   x> 9, error< .6ulp.  * 	   x< 0, all bets are off. (When G(x) ~ 1, log(G(x)) ~ 0)  * Method:  *	x> 6:  *		Use the asymptotic expansion (Stirling's Formula)  *	0< x< 6:  *		Use gamma(x+1) = x*gamma(x) for argument reduction.  *		Use rational approximation in  *		the range 1.2, 2.5  *		Two approximations are used, one centered at the  *		minimum to ensure monotonicity; one centered at 2  *		to maintain small relative error.  *	x< 0:  *		Use the reflection formula,  *		G(1-x)G(x) = PI/sin(PI*x)  * Special values:  *	non-positive integer	returns +Inf.  *	NaN			returns NaN */
end_comment

begin_decl_stmt
specifier|static
name|int
name|endian
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_define
define|#
directive|define
name|_IEEE
value|0
end_define

begin_comment
comment|/* double and float have same size exponent field */
end_comment

begin_define
define|#
directive|define
name|TRUNC
parameter_list|(
name|x
parameter_list|)
value|x = (double) (float) (x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_IEEE
value|1
end_define

begin_define
define|#
directive|define
name|TRUNC
parameter_list|(
name|x
parameter_list|)
value|*(((int *)&x) + endian)&= 0xf8000000
end_define

begin_define
define|#
directive|define
name|infnan
parameter_list|(
name|x
parameter_list|)
value|0.0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|double
name|log1p
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|small_lgam
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|large_lgam
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|neg_lgam
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|double
name|zero
init|=
literal|0.0
decl_stmt|,
name|one
init|=
literal|1.0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|signgam
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UNDERFL
value|(1e-1020 * 1e-1020)
end_define

begin_define
define|#
directive|define
name|LEFT
value|(1.0 - (x0 + .25))
end_define

begin_define
define|#
directive|define
name|RIGHT
value|(x0 - .218)
end_define

begin_comment
comment|/* /* Constants for approximation in [1.244,1.712] */
end_comment

begin_define
define|#
directive|define
name|x0
value|0.461632144968362356785
end_define

begin_define
define|#
directive|define
name|x0_lo
value|-.000000000000000015522348162858676890521
end_define

begin_define
define|#
directive|define
name|a0_hi
value|-0.12148629128932952880859
end_define

begin_define
define|#
directive|define
name|a0_lo
value|.0000000007534799204229502
end_define

begin_define
define|#
directive|define
name|r0
value|-2.771227512955130520e-002
end_define

begin_define
define|#
directive|define
name|r1
value|-2.980729795228150847e-001
end_define

begin_define
define|#
directive|define
name|r2
value|-3.257411333183093394e-001
end_define

begin_define
define|#
directive|define
name|r3
value|-1.126814387531706041e-001
end_define

begin_define
define|#
directive|define
name|r4
value|-1.129130057170225562e-002
end_define

begin_define
define|#
directive|define
name|r5
value|-2.259650588213369095e-005
end_define

begin_define
define|#
directive|define
name|s0
value|1.714457160001714442e+000
end_define

begin_define
define|#
directive|define
name|s1
value|2.786469504618194648e+000
end_define

begin_define
define|#
directive|define
name|s2
value|1.564546365519179805e+000
end_define

begin_define
define|#
directive|define
name|s3
value|3.485846389981109850e-001
end_define

begin_define
define|#
directive|define
name|s4
value|2.467759345363656348e-002
end_define

begin_comment
comment|/*  * Constants for approximation in [1.71, 2.5] */
end_comment

begin_define
define|#
directive|define
name|a1_hi
value|4.227843350984671344505727574870e-01
end_define

begin_define
define|#
directive|define
name|a1_lo
value|4.670126436531227189e-18
end_define

begin_define
define|#
directive|define
name|p0
value|3.224670334241133695662995251041e-01
end_define

begin_define
define|#
directive|define
name|p1
value|3.569659696950364669021382724168e-01
end_define

begin_define
define|#
directive|define
name|p2
value|1.342918716072560025853732668111e-01
end_define

begin_define
define|#
directive|define
name|p3
value|1.950702176409779831089963408886e-02
end_define

begin_define
define|#
directive|define
name|p4
value|8.546740251667538090796227834289e-04
end_define

begin_define
define|#
directive|define
name|q0
value|1.000000000000000444089209850062e+00
end_define

begin_define
define|#
directive|define
name|q1
value|1.315850076960161985084596381057e+00
end_define

begin_define
define|#
directive|define
name|q2
value|6.274644311862156431658377186977e-01
end_define

begin_define
define|#
directive|define
name|q3
value|1.304706631926259297049597307705e-01
end_define

begin_define
define|#
directive|define
name|q4
value|1.102815279606722369265536798366e-02
end_define

begin_define
define|#
directive|define
name|q5
value|2.512690594856678929537585620579e-04
end_define

begin_define
define|#
directive|define
name|q6
value|-1.003597548112371003358107325598e-06
end_define

begin_comment
comment|/*  * Stirling's Formula, adjusted for equal-ripple. x in [6,Inf]. */
end_comment

begin_define
define|#
directive|define
name|lns2pi
value|.418938533204672741780329736405
end_define

begin_define
define|#
directive|define
name|pb0
value|8.33333333333333148296162562474e-02
end_define

begin_define
define|#
directive|define
name|pb1
value|-2.77777777774548123579378966497e-03
end_define

begin_define
define|#
directive|define
name|pb2
value|7.93650778754435631476282786423e-04
end_define

begin_define
define|#
directive|define
name|pb3
value|-5.95235082566672847950717262222e-04
end_define

begin_define
define|#
directive|define
name|pb4
value|8.41428560346653702135821806252e-04
end_define

begin_define
define|#
directive|define
name|pb5
value|-1.89773526463879200348872089421e-03
end_define

begin_define
define|#
directive|define
name|pb6
value|5.69394463439411649408050664078e-03
end_define

begin_define
define|#
directive|define
name|pb7
value|-1.44705562421428915453880392761e-02
end_define

begin_function
name|double
name|lgamma
parameter_list|(
name|double
name|x
parameter_list|)
block|{
name|double
name|r
decl_stmt|;
name|signgam
operator|=
literal|1
expr_stmt|;
name|endian
operator|=
operator|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|one
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|finite
argument_list|(
name|x
argument_list|)
condition|)
if|if
condition|(
name|_IEEE
condition|)
return|return
operator|(
name|x
operator|+
name|x
operator|)
return|;
else|else
return|return
operator|(
name|infnan
argument_list|(
name|EDOM
argument_list|)
operator|)
return|;
if|if
condition|(
name|x
operator|>
literal|6
operator|+
name|RIGHT
condition|)
block|{
name|r
operator|=
name|large_lgam
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>
literal|1e-16
condition|)
return|return
operator|(
name|small_lgam
argument_list|(
name|x
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|x
operator|>
operator|-
literal|1e-16
condition|)
block|{
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|signgam
operator|=
operator|-
literal|1
operator|,
name|x
operator|=
operator|-
name|x
expr_stmt|;
return|return
operator|(
operator|-
name|log
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|neg_lgam
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|double
name|large_lgam
parameter_list|(
name|double
name|x
parameter_list|)
block|{
name|double
name|z
decl_stmt|,
name|p
decl_stmt|,
name|x1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|Double
name|t
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|;
name|u
operator|=
name|log__D
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|u
operator|.
name|a
operator|-=
literal|1.0
expr_stmt|;
if|if
condition|(
name|x
operator|>
literal|1e15
condition|)
block|{
name|v
operator|.
name|a
operator|=
name|x
operator|-
literal|0.5
expr_stmt|;
name|TRUNC
argument_list|(
name|v
operator|.
name|a
argument_list|)
expr_stmt|;
name|v
operator|.
name|b
operator|=
operator|(
name|x
operator|-
name|v
operator|.
name|a
operator|)
operator|-
literal|0.5
expr_stmt|;
name|t
operator|.
name|a
operator|=
name|u
operator|.
name|a
operator|*
name|v
operator|.
name|a
expr_stmt|;
name|t
operator|.
name|b
operator|=
name|x
operator|*
name|u
operator|.
name|b
operator|+
name|v
operator|.
name|b
operator|*
name|u
operator|.
name|a
expr_stmt|;
if|if
condition|(
name|_IEEE
operator|==
literal|0
operator|&&
operator|!
name|finite
argument_list|(
name|t
operator|.
name|a
argument_list|)
condition|)
return|return
operator|(
name|infnan
argument_list|(
name|ERANGE
argument_list|)
operator|)
return|;
return|return
operator|(
name|t
operator|.
name|a
operator|+
name|t
operator|.
name|b
operator|)
return|;
block|}
name|x1
operator|=
literal|1.
operator|/
name|x
expr_stmt|;
name|z
operator|=
name|x1
operator|*
name|x1
expr_stmt|;
name|p
operator|=
name|pb0
operator|+
name|z
operator|*
operator|(
name|pb1
operator|+
name|z
operator|*
operator|(
name|pb2
operator|+
name|z
operator|*
operator|(
name|pb3
operator|+
name|z
operator|*
operator|(
name|pb4
operator|+
name|z
operator|*
operator|(
name|pb5
operator|+
name|z
operator|*
operator|(
name|pb6
operator|+
name|z
operator|*
name|pb7
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* error in approximation = 2.8e-19 */
name|p
operator|=
name|p
operator|*
name|x1
expr_stmt|;
comment|/* error< 2.3e-18 absolute */
comment|/* 0< p< 1/64 (at x = 5.5) */
name|v
operator|.
name|a
operator|=
name|x
operator|=
name|x
operator|-
literal|0.5
expr_stmt|;
name|TRUNC
argument_list|(
name|v
operator|.
name|a
argument_list|)
expr_stmt|;
comment|/* truncate v.a to 26 bits. */
name|v
operator|.
name|b
operator|=
name|x
operator|-
name|v
operator|.
name|a
expr_stmt|;
name|t
operator|.
name|a
operator|=
name|v
operator|.
name|a
operator|*
name|u
operator|.
name|a
expr_stmt|;
comment|/* t = (x-.5)*(log(x)-1) */
name|t
operator|.
name|b
operator|=
name|v
operator|.
name|b
operator|*
name|u
operator|.
name|a
operator|+
name|x
operator|*
name|u
operator|.
name|b
expr_stmt|;
name|t
operator|.
name|b
operator|+=
name|p
expr_stmt|;
name|t
operator|.
name|b
operator|+=
name|lns2pi
expr_stmt|;
comment|/* return t + lns2pi + p */
return|return
operator|(
name|t
operator|.
name|a
operator|+
name|t
operator|.
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|double
name|small_lgam
parameter_list|(
name|double
name|x
parameter_list|)
block|{
name|int
name|x_int
decl_stmt|;
name|double
name|y
decl_stmt|,
name|z
decl_stmt|,
name|t
decl_stmt|,
name|r
init|=
literal|0
decl_stmt|,
name|p
decl_stmt|,
name|q
decl_stmt|,
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|struct
name|Double
name|rr
decl_stmt|;
name|x_int
operator|=
operator|(
name|x
operator|+
literal|.5
operator|)
expr_stmt|;
name|y
operator|=
name|x
operator|-
name|x_int
expr_stmt|;
if|if
condition|(
name|x_int
operator|<=
literal|2
operator|&&
name|y
operator|>
name|RIGHT
condition|)
block|{
name|t
operator|=
name|y
operator|-
name|x0
expr_stmt|;
name|y
operator|--
expr_stmt|;
name|x_int
operator|++
expr_stmt|;
goto|goto
name|CONTINUE
goto|;
block|}
elseif|else
if|if
condition|(
name|y
operator|<
operator|-
name|LEFT
condition|)
block|{
name|t
operator|=
name|y
operator|+
operator|(
literal|1.0
operator|-
name|x0
operator|)
expr_stmt|;
name|CONTINUE
label|:
name|z
operator|=
name|t
operator|-
name|x0_lo
expr_stmt|;
name|p
operator|=
name|r0
operator|+
name|z
operator|*
operator|(
name|r1
operator|+
name|z
operator|*
operator|(
name|r2
operator|+
name|z
operator|*
operator|(
name|r3
operator|+
name|z
operator|*
operator|(
name|r4
operator|+
name|z
operator|*
name|r5
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
name|q
operator|=
name|s0
operator|+
name|z
operator|*
operator|(
name|s1
operator|+
name|z
operator|*
operator|(
name|s2
operator|+
name|z
operator|*
operator|(
name|s3
operator|+
name|z
operator|*
name|s4
operator|)
operator|)
operator|)
expr_stmt|;
name|r
operator|=
name|t
operator|*
operator|(
name|z
operator|*
operator|(
name|p
operator|/
name|q
operator|)
operator|-
name|x0_lo
operator|)
expr_stmt|;
name|t
operator|=
literal|.5
operator|*
name|t
operator|*
name|t
expr_stmt|;
name|z
operator|=
literal|1.0
expr_stmt|;
switch|switch
condition|(
name|x_int
condition|)
block|{
case|case
literal|6
case|:
name|z
operator|=
operator|(
name|y
operator|+
literal|5
operator|)
expr_stmt|;
case|case
literal|5
case|:
name|z
operator|*=
operator|(
name|y
operator|+
literal|4
operator|)
expr_stmt|;
case|case
literal|4
case|:
name|z
operator|*=
operator|(
name|y
operator|+
literal|3
operator|)
expr_stmt|;
case|case
literal|3
case|:
name|z
operator|*=
operator|(
name|y
operator|+
literal|2
operator|)
expr_stmt|;
name|rr
operator|=
name|log__D
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|rr
operator|.
name|b
operator|+=
name|a0_lo
expr_stmt|;
name|rr
operator|.
name|a
operator|+=
name|a0_hi
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|r
operator|+
name|rr
operator|.
name|b
operator|)
operator|+
name|t
operator|+
name|rr
operator|.
name|a
operator|)
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
operator|(
operator|(
name|r
operator|+
name|a0_lo
operator|)
operator|+
name|t
operator|)
operator|+
name|a0_hi
operator|)
return|;
case|case
literal|0
case|:
name|r
operator|-=
name|log1p
argument_list|(
name|x
argument_list|)
expr_stmt|;
default|default:
name|rr
operator|=
name|log__D
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|rr
operator|.
name|a
operator|-=
name|a0_hi
expr_stmt|;
name|rr
operator|.
name|b
operator|-=
name|a0_lo
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|r
operator|-
name|rr
operator|.
name|b
operator|)
operator|+
name|t
operator|)
operator|-
name|rr
operator|.
name|a
operator|)
return|;
block|}
block|}
else|else
block|{
name|p
operator|=
name|p0
operator|+
name|y
operator|*
operator|(
name|p1
operator|+
name|y
operator|*
operator|(
name|p2
operator|+
name|y
operator|*
operator|(
name|p3
operator|+
name|y
operator|*
name|p4
operator|)
operator|)
operator|)
expr_stmt|;
name|q
operator|=
name|q0
operator|+
name|y
operator|*
operator|(
name|q1
operator|+
name|y
operator|*
operator|(
name|q2
operator|+
name|y
operator|*
operator|(
name|q3
operator|+
name|y
operator|*
operator|(
name|q4
operator|+
name|y
operator|*
operator|(
name|q5
operator|+
name|y
operator|*
name|q6
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
name|p
operator|=
name|p
operator|*
operator|(
name|y
operator|/
name|q
operator|)
expr_stmt|;
name|t
operator|=
operator|(
name|double
operator|)
operator|(
name|float
operator|)
name|y
expr_stmt|;
name|z
operator|=
name|y
operator|-
name|t
expr_stmt|;
name|hi
operator|=
call|(
name|double
call|)
argument_list|(
name|float
argument_list|)
argument_list|(
name|p
operator|+
name|a1_hi
argument_list|)
expr_stmt|;
name|lo
operator|=
name|a1_hi
operator|-
name|hi
expr_stmt|;
name|lo
operator|+=
name|p
expr_stmt|;
name|lo
operator|+=
name|a1_lo
expr_stmt|;
name|r
operator|=
name|lo
operator|*
name|y
operator|+
name|z
operator|*
name|hi
expr_stmt|;
comment|/* q + r = y*(a0+p/q) */
name|q
operator|=
name|hi
operator|*
name|t
expr_stmt|;
name|z
operator|=
literal|1.0
expr_stmt|;
switch|switch
condition|(
name|x_int
condition|)
block|{
case|case
literal|6
case|:
name|z
operator|=
operator|(
name|y
operator|+
literal|5
operator|)
expr_stmt|;
case|case
literal|5
case|:
name|z
operator|*=
operator|(
name|y
operator|+
literal|4
operator|)
expr_stmt|;
case|case
literal|4
case|:
name|z
operator|*=
operator|(
name|y
operator|+
literal|3
operator|)
expr_stmt|;
case|case
literal|3
case|:
name|z
operator|*=
operator|(
name|y
operator|+
literal|2
operator|)
expr_stmt|;
name|rr
operator|=
name|log__D
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|r
operator|+=
name|rr
operator|.
name|b
expr_stmt|;
name|r
operator|+=
name|q
expr_stmt|;
return|return
operator|(
name|rr
operator|.
name|a
operator|+
name|r
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|q
operator|+
name|r
operator|)
return|;
case|case
literal|0
case|:
name|rr
operator|=
name|log__D
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|r
operator|-=
name|rr
operator|.
name|b
expr_stmt|;
name|r
operator|-=
name|log1p
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|r
operator|+=
name|q
expr_stmt|;
name|r
operator|-=
name|rr
operator|.
name|a
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
default|default:
name|rr
operator|=
name|log__D
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|r
operator|-=
name|rr
operator|.
name|b
expr_stmt|;
name|q
operator|-=
name|rr
operator|.
name|a
expr_stmt|;
return|return
operator|(
name|r
operator|+
name|q
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|double
name|neg_lgam
parameter_list|(
name|double
name|x
parameter_list|)
block|{
name|int
name|xi
decl_stmt|;
name|double
name|y
decl_stmt|,
name|z
decl_stmt|,
name|one
init|=
literal|1.0
decl_stmt|,
name|zero
init|=
literal|0.0
decl_stmt|;
specifier|extern
name|double
name|gamma
parameter_list|()
function_decl|;
comment|/* avoid destructive cancellation as much as possible */
if|if
condition|(
name|x
operator|>
operator|-
literal|170
condition|)
block|{
name|xi
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|xi
operator|==
name|x
condition|)
if|if
condition|(
name|_IEEE
condition|)
return|return
operator|(
name|one
operator|/
name|zero
operator|)
return|;
else|else
return|return
operator|(
name|infnan
argument_list|(
name|ERANGE
argument_list|)
operator|)
return|;
name|y
operator|=
name|gamma
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|=
operator|-
name|y
operator|,
name|signgam
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|log
argument_list|(
name|y
argument_list|)
operator|)
return|;
block|}
name|z
operator|=
name|floor
argument_list|(
name|x
operator|+
literal|.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|x
condition|)
block|{
comment|/* convention: G(-(integer)) -> +Inf */
if|if
condition|(
name|_IEEE
condition|)
return|return
operator|(
name|one
operator|/
name|zero
operator|)
return|;
else|else
return|return
operator|(
name|infnan
argument_list|(
name|ERANGE
argument_list|)
operator|)
return|;
block|}
name|y
operator|=
literal|.5
operator|*
name|ceil
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|ceil
argument_list|(
name|y
argument_list|)
condition|)
name|signgam
operator|=
operator|-
literal|1
expr_stmt|;
name|x
operator|=
operator|-
name|x
expr_stmt|;
name|z
operator|=
name|fabs
argument_list|(
name|x
operator|+
name|z
argument_list|)
expr_stmt|;
comment|/* 0< z<= .5 */
if|if
condition|(
name|z
operator|<
literal|.25
condition|)
name|z
operator|=
name|sin
argument_list|(
name|M_PI
operator|*
name|z
argument_list|)
expr_stmt|;
else|else
name|z
operator|=
name|cos
argument_list|(
name|M_PI
operator|*
operator|(
literal|0.5
operator|-
name|z
operator|)
argument_list|)
expr_stmt|;
name|z
operator|=
name|log
argument_list|(
name|M_PI
operator|/
operator|(
name|z
operator|*
name|x
operator|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|large_lgam
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|z
operator|-
name|y
operator|)
return|;
block|}
end_function

end_unit

