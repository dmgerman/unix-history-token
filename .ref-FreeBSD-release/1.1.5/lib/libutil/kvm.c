begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: kvm.c,v 1.9 1994/03/22 19:03:01 davidg Exp $  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)kvm.c	5.18 (Berkeley) 5/7/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_define
define|#
directive|define
name|DEBUG
value|0
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<ndbm.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_define
define|#
directive|define
name|btop
parameter_list|(
name|x
parameter_list|)
value|(((unsigned)(x))>> PGSHIFT)
end_define

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|ptob
parameter_list|(
name|x
parameter_list|)
value|((caddr_t)((x)<< PGSHIFT))
end_define

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* ??? kinfo_proc currently includes this*/
end_comment

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/swap_pager.h>
end_include

begin_include
include|#
directive|include
file|<sys/kinfo_proc.h>
end_include

begin_comment
comment|/*  * files  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|unixf
decl_stmt|,
modifier|*
name|memf
decl_stmt|,
modifier|*
name|kmemf
decl_stmt|,
modifier|*
name|swapf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unixx
decl_stmt|,
name|mem
decl_stmt|,
name|kmem
decl_stmt|,
name|swap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DBM
modifier|*
name|db
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * flags  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deadkernel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kvminit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kvmfilesopen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * state  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|kinfo_proc
modifier|*
name|kvmprocbase
decl_stmt|,
modifier|*
name|kvmprocptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kvmnprocs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * u. buffer  */
end_comment

begin_union
specifier|static
union|union
block|{
name|struct
name|user
name|user
decl_stmt|;
name|char
name|upages
index|[
name|UPAGES
index|]
index|[
name|NBPG
index|]
decl_stmt|;
block|}
name|user
union|;
end_union

begin_struct
struct|struct
name|swapblk
block|{
name|long
name|offset
decl_stmt|;
comment|/* offset in swap device */
name|long
name|size
decl_stmt|;
comment|/* remaining size of block in swap device */
block|}
struct|;
end_struct

begin_comment
comment|/*  * random other stuff  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dmmin
decl_stmt|,
name|dmmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcbpf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|argaddr0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
specifier|static
name|int
name|argaddr1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nswap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pde
modifier|*
name|PTD
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|basename
parameter_list|(
name|cp
parameter_list|)
value|((tmp=rindex((cp), '/')) ? tmp+1 : (cp))
end_define

begin_define
define|#
directive|define
name|MAXSYMSIZE
value|256
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|pftoc
end_ifndef

begin_define
define|#
directive|define
name|pftoc
parameter_list|(
name|f
parameter_list|)
value|(f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|iskva
end_ifndef

begin_define
define|#
directive|define
name|iskva
parameter_list|(
name|v
parameter_list|)
value|((u_long)(v)& KERNBASE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
block|{
literal|"_Usrptmap"
block|}
block|,
define|#
directive|define
name|X_USRPTMAP
value|0
block|{
literal|"_usrpt"
block|}
block|,
define|#
directive|define
name|X_USRPT
value|1
block|{
literal|"_nswap"
block|}
block|,
define|#
directive|define
name|X_NSWAP
value|2
block|{
literal|"_dmmin"
block|}
block|,
define|#
directive|define
name|X_DMMIN
value|3
block|{
literal|"_dmmax"
block|}
block|,
define|#
directive|define
name|X_DMMAX
value|4
block|{
literal|"_vm_page_buckets"
block|}
block|,
define|#
directive|define
name|X_VM_PAGE_BUCKETS
value|5
block|{
literal|"_vm_page_hash_mask"
block|}
block|,
define|#
directive|define
name|X_VM_PAGE_HASH_MASK
value|6
block|{
literal|"_page_shift"
block|}
block|,
define|#
directive|define
name|X_PAGE_SHIFT
value|7
block|{
literal|"_kstack"
block|}
block|,
define|#
directive|define
name|X_KSTACK
value|8
block|{
literal|"_kernel_object"
block|}
block|,
define|#
directive|define
name|X_KERNEL_OBJECT
value|9
block|{
literal|"_btext"
block|,}
block|,
define|#
directive|define
name|X_KERNEL_BTEXT
value|10
comment|/* 	 * everything here and down, only if a dead kernel 	 */
block|{
literal|"_Sysmap"
block|}
block|,
define|#
directive|define
name|X_SYSMAP
value|11
define|#
directive|define
name|X_DEADKERNEL
value|X_SYSMAP
block|{
literal|"_Syssize"
block|}
block|,
define|#
directive|define
name|X_SYSSIZE
value|12
block|{
literal|"_allproc"
block|}
block|,
define|#
directive|define
name|X_ALLPROC
value|13
block|{
literal|"_zombproc"
block|}
block|,
define|#
directive|define
name|X_ZOMBPROC
value|14
block|{
literal|"_nproc"
block|}
block|,
define|#
directive|define
name|X_NPROC
value|15
define|#
directive|define
name|X_LAST
value|15
block|{
literal|"_IdlePTD"
block|}
block|,
define|#
directive|define
name|X_IdlePTD
value|(X_LAST+1)
block|{
literal|""
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|off_t
name|Vtophys
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|klseek
argument_list|()
decl_stmt|,
name|seterr
argument_list|()
decl_stmt|,
name|setsyserr
argument_list|()
decl_stmt|,
name|vstodb
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getkvars
argument_list|()
decl_stmt|,
name|kvm_doprocs
argument_list|()
decl_stmt|,
name|kvm_init
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|findpage
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * returns 	0 if files were opened now,  * 		1 if files were already opened,  *		-1 if files could not be opened.  */
end_comment

begin_macro
name|kvm_openfiles
argument_list|(
argument|uf
argument_list|,
argument|mf
argument_list|,
argument|sf
argument_list|)
end_macro

begin_decl_stmt
specifier|const
name|char
modifier|*
name|uf
decl_stmt|,
modifier|*
name|mf
decl_stmt|,
modifier|*
name|sf
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|kvmfilesopen
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|unixx
operator|=
name|mem
operator|=
name|kmem
operator|=
name|swap
operator|=
operator|-
literal|1
expr_stmt|;
name|unixf
operator|=
operator|(
name|uf
operator|==
name|NULL
operator|)
condition|?
name|_PATH_UNIX
else|:
name|uf
expr_stmt|;
name|memf
operator|=
operator|(
name|mf
operator|==
name|NULL
operator|)
condition|?
name|_PATH_MEM
else|:
name|mf
expr_stmt|;
if|if
condition|(
operator|(
name|unixx
operator|=
name|open
argument_list|(
name|unixf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setsyserr
argument_list|(
literal|"can't open %s"
argument_list|,
name|unixf
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
operator|(
name|mem
operator|=
name|open
argument_list|(
name|memf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setsyserr
argument_list|(
literal|"can't open %s"
argument_list|,
name|memf
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|sf
operator|!=
name|NULL
condition|)
name|swapf
operator|=
name|sf
expr_stmt|;
if|if
condition|(
name|mf
operator|!=
name|NULL
condition|)
block|{
name|deadkernel
operator|++
expr_stmt|;
name|kmemf
operator|=
name|mf
expr_stmt|;
name|kmem
operator|=
name|mem
expr_stmt|;
name|swap
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|kmemf
operator|=
name|_PATH_KMEM
expr_stmt|;
if|if
condition|(
operator|(
name|kmem
operator|=
name|open
argument_list|(
name|kmemf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setsyserr
argument_list|(
literal|"can't open %s"
argument_list|,
name|kmemf
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|swapf
operator|=
operator|(
name|sf
operator|==
name|NULL
operator|)
condition|?
name|_PATH_DRUM
else|:
name|sf
expr_stmt|;
comment|/* 		 * live kernel - avoid looking up nlist entries 		 * past X_DEADKERNEL. 		 */
name|nl
index|[
name|X_DEADKERNEL
index|]
operator|.
name|n_name
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|swapf
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|swap
operator|=
name|open
argument_list|(
name|swapf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't open %s"
argument_list|,
name|swapf
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|kvmfilesopen
operator|++
expr_stmt|;
if|if
condition|(
name|kvminit
operator|==
literal|0
operator|&&
name|kvm_init
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
comment|/*XXX*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
name|kvm_close
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|kvm_init
argument_list|(
argument|uf
argument_list|,
argument|mf
argument_list|,
argument|sf
argument_list|)
name|char
operator|*
name|uf
operator|,
operator|*
name|mf
operator|,
operator|*
name|sf
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|kvmfilesopen
operator|==
literal|0
operator|&&
name|kvm_openfiles
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|getkvars
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|kvminit
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|kvm_close
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|unixx
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|unixx
argument_list|)
expr_stmt|;
name|unixx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|kmem
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|kmem
operator|!=
name|mem
condition|)
name|close
argument_list|(
name|kmem
argument_list|)
expr_stmt|;
comment|/* otherwise kmem is a copy of mem, and will be closed below */
name|kmem
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mem
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|mem
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|swap
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|swap
argument_list|)
expr_stmt|;
name|swap
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
block|{
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
block|}
name|kvminit
operator|=
literal|0
expr_stmt|;
name|kvmfilesopen
operator|=
literal|0
expr_stmt|;
name|deadkernel
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|kvm_nlist
argument_list|(
argument|nl
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|nl
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|datum
name|key
decl_stmt|,
name|data
decl_stmt|;
name|char
name|dbname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|dbversion
index|[
name|_POSIX2_LINE_MAX
index|]
decl_stmt|;
name|char
name|kversion
index|[
name|_POSIX2_LINE_MAX
index|]
decl_stmt|;
name|int
name|dbversionlen
decl_stmt|;
name|char
name|symbuf
index|[
name|MAXSYMSIZE
index|]
decl_stmt|;
name|struct
name|nlist
name|nbuf
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|num
decl_stmt|,
name|did
decl_stmt|;
if|if
condition|(
name|kvmfilesopen
operator|==
literal|0
operator|&&
name|kvm_openfiles
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|deadkernel
condition|)
goto|goto
name|hard2
goto|;
comment|/* 	 * initialize key datum 	 */
name|key
operator|.
name|dptr
operator|=
name|symbuf
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
goto|goto
name|win
goto|;
comment|/* off to the races */
comment|/* 	 * open database 	 */
name|sprintf
argument_list|(
name|dbname
argument_list|,
literal|"%s/kvm_%s"
argument_list|,
name|_PATH_VARRUN
argument_list|,
name|basename
argument_list|(
name|unixf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|db
operator|=
name|dbm_open
argument_list|(
name|dbname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|hard2
goto|;
comment|/* 	 * getem from the database. 	 */
name|win
label|:
name|num
operator|=
name|did
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|nl
init|;
name|n
operator|->
name|n_name
operator|&&
name|n
operator|->
name|n_name
index|[
literal|0
index|]
condition|;
name|n
operator|++
operator|,
name|num
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
comment|/* 		 * clear out fields from users buffer 		 */
name|n
operator|->
name|n_type
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|n_other
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|n_desc
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|n_value
operator|=
literal|0
expr_stmt|;
comment|/* 		 * query db 		 */
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|n
operator|->
name|n_name
argument_list|)
operator|)
operator|>
name|MAXSYMSIZE
condition|)
block|{
name|seterr
argument_list|(
literal|"symbol too large"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|symbuf
argument_list|,
name|n
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|len
expr_stmt|;
name|data
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|dptr
operator|==
name|NULL
operator|||
name|data
operator|.
name|dsize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
condition|)
continue|continue;
name|bcopy
argument_list|(
name|data
operator|.
name|dptr
argument_list|,
operator|&
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_value
operator|=
name|nbuf
operator|.
name|n_value
expr_stmt|;
name|n
operator|->
name|n_type
operator|=
name|nbuf
operator|.
name|n_type
expr_stmt|;
name|n
operator|->
name|n_desc
operator|=
name|nbuf
operator|.
name|n_desc
expr_stmt|;
name|n
operator|->
name|n_other
operator|=
name|nbuf
operator|.
name|n_other
expr_stmt|;
name|did
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|num
operator|-
name|did
operator|)
return|;
name|hard1
label|:
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|hard2
label|:
name|num
operator|=
name|nlist
argument_list|(
name|unixf
argument_list|,
name|nl
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
operator|-
literal|1
condition|)
name|seterr
argument_list|(
literal|"nlist (hard way) failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|num
operator|)
return|;
block|}
end_block

begin_macro
name|kvm_getprocs
argument_list|(
argument|what
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|what
decl_stmt|,
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|ocopysize
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|kvminit
operator|==
literal|0
operator|&&
name|kvm_init
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|deadkernel
condition|)
block|{
name|int
name|ret
decl_stmt|,
name|copysize
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|getkerninfo
argument_list|(
name|what
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|arg
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setsyserr
argument_list|(
literal|"can't get estimate for kerninfo"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|copysize
operator|=
name|ret
expr_stmt|;
if|if
condition|(
operator|(
name|copysize
operator|>
name|ocopysize
operator|||
name|kvmprocbase
operator|==
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|kvmprocbase
operator|=
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|)
name|realloc
argument_list|(
name|kvmprocbase
argument_list|,
name|copysize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|seterr
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ocopysize
operator|=
name|copysize
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|getkerninfo
argument_list|(
name|what
argument_list|,
name|kvmprocbase
argument_list|,
operator|&
name|copysize
argument_list|,
name|arg
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setsyserr
argument_list|(
literal|"can't get proc list"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|copysize
operator|%
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"proc size mismatch (got %d total, kinfo_proc: %d)"
argument_list|,
name|copysize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|kvmnprocs
operator|=
name|copysize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|nproc
decl_stmt|;
if|if
condition|(
name|kvm_read
argument_list|(
operator|(
name|void
operator|*
operator|)
name|nl
index|[
name|X_NPROC
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|nproc
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read nproc"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|kvmprocbase
operator|=
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|)
name|malloc
argument_list|(
name|nproc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|seterr
argument_list|(
literal|"out of memory (addr: %x nproc = %d)"
argument_list|,
name|nl
index|[
name|X_NPROC
index|]
operator|.
name|n_value
argument_list|,
name|nproc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|kvmnprocs
operator|=
name|kvm_doprocs
argument_list|(
name|what
argument_list|,
name|arg
argument_list|,
name|kvmprocbase
argument_list|)
expr_stmt|;
name|realloc
argument_list|(
name|kvmprocbase
argument_list|,
name|kvmnprocs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kvmprocptr
operator|=
name|kvmprocbase
expr_stmt|;
return|return
operator|(
name|kvmnprocs
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * XXX - should NOT give up so easily - especially since the kernel  * may be corrupt (it died).  Should gather as much information as possible.  * Follows proc ptrs instead of reading table since table may go  * away soon.  */
end_comment

begin_expr_stmt
specifier|static
name|kvm_doprocs
argument_list|(
argument|what
argument_list|,
argument|arg
argument_list|,
argument|buff
argument_list|)
name|int
name|what
operator|,
name|arg
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|buff
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|,
name|proc
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
init|=
name|buff
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|doingzomb
init|=
literal|0
decl_stmt|;
name|struct
name|eproc
name|eproc
decl_stmt|;
name|struct
name|pgrp
name|pgrp
decl_stmt|;
name|struct
name|session
name|sess
decl_stmt|;
name|struct
name|tty
name|tty
decl_stmt|;
comment|/* allproc */
if|if
condition|(
name|kvm_read
argument_list|(
operator|(
name|void
operator|*
operator|)
name|nl
index|[
name|X_ALLPROC
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc
operator|*
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|proc
operator|*
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read allproc"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|again
label|:
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|proc
operator|.
name|p_nxt
control|)
block|{
if|if
condition|(
name|kvm_read
argument_list|(
name|p
argument_list|,
operator|&
name|proc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read proc at %x"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|kvm_read
argument_list|(
name|proc
operator|.
name|p_cred
argument_list|,
operator|&
name|eproc
operator|.
name|e_pcred
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcred
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|pcred
argument_list|)
condition|)
operator|(
name|void
operator|)
name|kvm_read
argument_list|(
name|eproc
operator|.
name|e_pcred
operator|.
name|pc_ucred
argument_list|,
operator|&
name|eproc
operator|.
name|e_ucred
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ucred
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ki_op
argument_list|(
name|what
argument_list|)
condition|)
block|{
case|case
name|KINFO_PROC_PID
case|:
if|if
condition|(
name|proc
operator|.
name|p_pid
operator|!=
operator|(
name|pid_t
operator|)
name|arg
condition|)
continue|continue;
break|break;
case|case
name|KINFO_PROC_UID
case|:
if|if
condition|(
name|eproc
operator|.
name|e_ucred
operator|.
name|cr_uid
operator|!=
operator|(
name|uid_t
operator|)
name|arg
condition|)
continue|continue;
break|break;
case|case
name|KINFO_PROC_RUID
case|:
if|if
condition|(
name|eproc
operator|.
name|e_pcred
operator|.
name|p_ruid
operator|!=
operator|(
name|uid_t
operator|)
name|arg
condition|)
continue|continue;
break|break;
block|}
comment|/* 		 * gather eproc 		 */
name|eproc
operator|.
name|e_paddr
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|kvm_read
argument_list|(
name|proc
operator|.
name|p_pgrp
argument_list|,
operator|&
name|pgrp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pgrp
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pgrp
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read pgrp at %x"
argument_list|,
name|proc
operator|.
name|p_pgrp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|eproc
operator|.
name|e_sess
operator|=
name|pgrp
operator|.
name|pg_session
expr_stmt|;
name|eproc
operator|.
name|e_pgid
operator|=
name|pgrp
operator|.
name|pg_id
expr_stmt|;
name|eproc
operator|.
name|e_jobc
operator|=
name|pgrp
operator|.
name|pg_jobc
expr_stmt|;
if|if
condition|(
name|kvm_read
argument_list|(
name|pgrp
operator|.
name|pg_session
argument_list|,
operator|&
name|sess
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|session
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|session
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read session at %x"
argument_list|,
name|pgrp
operator|.
name|pg_session
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|proc
operator|.
name|p_flag
operator|&
name|SCTTY
operator|)
operator|&&
name|sess
operator|.
name|s_ttyp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|kvm_read
argument_list|(
name|sess
operator|.
name|s_ttyp
argument_list|,
operator|&
name|tty
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tty
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|tty
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read tty at %x"
argument_list|,
name|sess
operator|.
name|s_ttyp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|eproc
operator|.
name|e_tdev
operator|=
name|tty
operator|.
name|t_dev
expr_stmt|;
name|eproc
operator|.
name|e_tsess
operator|=
name|tty
operator|.
name|t_session
expr_stmt|;
if|if
condition|(
name|tty
operator|.
name|t_pgrp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|kvm_read
argument_list|(
name|tty
operator|.
name|t_pgrp
argument_list|,
operator|&
name|pgrp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pgrp
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pgrp
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read tpgrp at&x"
argument_list|,
name|tty
operator|.
name|t_pgrp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|eproc
operator|.
name|e_tpgid
operator|=
name|pgrp
operator|.
name|pg_id
expr_stmt|;
block|}
else|else
name|eproc
operator|.
name|e_tpgid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|eproc
operator|.
name|e_tdev
operator|=
name|NODEV
expr_stmt|;
if|if
condition|(
name|proc
operator|.
name|p_wmesg
condition|)
name|kvm_read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|proc
operator|.
name|p_wmesg
argument_list|,
name|eproc
operator|.
name|e_wmesg
argument_list|,
name|WMESGLEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kvm_read
argument_list|(
name|proc
operator|.
name|p_vmspace
argument_list|,
operator|&
name|eproc
operator|.
name|e_vm
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmspace
argument_list|)
argument_list|)
expr_stmt|;
name|eproc
operator|.
name|e_xsize
operator|=
name|eproc
operator|.
name|e_xrssize
operator|=
name|eproc
operator|.
name|e_xccount
operator|=
name|eproc
operator|.
name|e_xswrss
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ki_op
argument_list|(
name|what
argument_list|)
condition|)
block|{
case|case
name|KINFO_PROC_PGRP
case|:
if|if
condition|(
name|eproc
operator|.
name|e_pgid
operator|!=
operator|(
name|pid_t
operator|)
name|arg
condition|)
continue|continue;
break|break;
case|case
name|KINFO_PROC_TTY
case|:
if|if
condition|(
operator|(
name|proc
operator|.
name|p_flag
operator|&
name|SCTTY
operator|)
operator|==
literal|0
operator|||
name|eproc
operator|.
name|e_tdev
operator|!=
operator|(
name|dev_t
operator|)
name|arg
condition|)
continue|continue;
break|break;
block|}
name|i
operator|++
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|proc
argument_list|,
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|eproc
argument_list|,
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eproc
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|eproc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|doingzomb
condition|)
block|{
comment|/* zombproc */
if|if
condition|(
name|kvm_read
argument_list|(
operator|(
name|void
operator|*
operator|)
name|nl
index|[
name|X_ZOMBPROC
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc
operator|*
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|proc
operator|*
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read zombproc"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|doingzomb
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_function
name|struct
name|proc
modifier|*
name|kvm_nextproc
parameter_list|()
block|{
if|if
condition|(
operator|!
name|kvmprocbase
operator|&&
name|kvm_getprocs
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|kvmprocptr
operator|>=
operator|(
name|kvmprocbase
operator|+
name|kvmnprocs
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|seterr("end of proc list");
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
operator|(
expr|struct
name|proc
operator|*
operator|)
operator|(
name|kvmprocptr
operator|++
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|eproc
modifier|*
name|kvm_geteproc
parameter_list|(
name|p
parameter_list|)
specifier|const
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
return|return
operator|(
operator|(
expr|struct
name|eproc
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_macro
name|kvm_setproc
argument_list|()
end_macro

begin_block
block|{
name|kvmprocptr
operator|=
name|kvmprocbase
expr_stmt|;
block|}
end_block

begin_macro
name|kvm_freeprocs
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|kvmprocbase
condition|)
block|{
name|free
argument_list|(
name|kvmprocbase
argument_list|)
expr_stmt|;
name|kvmprocbase
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|proc_getmem
argument_list|(
argument|const struct proc *p
argument_list|,
argument|void *buffer
argument_list|,
argument|vm_offset_t size
argument_list|,
argument|vm_offset_t offset
argument_list|)
end_macro

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|char
name|fn
index|[
literal|512
operator|+
literal|1
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|fn
argument_list|,
literal|"/proc/%d"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SSYS
condition|)
return|return
literal|0
return|;
name|fd
operator|=
name|open
argument_list|(
name|fn
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_function
name|struct
name|user
modifier|*
name|kvm_getu
parameter_list|(
name|p
parameter_list|)
specifier|const
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|kp
init|=
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|)
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|up
decl_stmt|;
name|u_int
name|vaddr
decl_stmt|;
name|int
name|arg_size
decl_stmt|;
if|if
condition|(
name|kvminit
operator|==
literal|0
operator|&&
name|kvm_init
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|p_stat
operator|==
name|SZOMB
condition|)
block|{
name|seterr
argument_list|(
literal|"zombie process"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|deadkernel
condition|)
block|{
if|if
condition|(
name|proc_getmem
argument_list|(
name|p
argument_list|,
name|user
operator|.
name|upages
argument_list|,
sizeof|sizeof
name|user
operator|.
name|upages
argument_list|,
name|USRSTACK
argument_list|)
condition|)
block|{
name|kp
operator|->
name|kp_eproc
operator|.
name|e_vm
operator|.
name|vm_rssize
operator|=
name|kp
operator|->
name|kp_eproc
operator|.
name|e_vm
operator|.
name|vm_pmap
operator|.
name|pm_stats
operator|.
name|resident_count
expr_stmt|;
comment|/* XXX */
return|return
operator|&
name|user
operator|.
name|user
return|;
block|}
block|}
name|argaddr0
operator|=
name|argaddr1
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Read u-area one page at a time for the benefit of post-mortems 	 */
name|up
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|p_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
block|{
name|klseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|up
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
name|user
operator|.
name|upages
index|[
name|i
index|]
argument_list|,
name|CLBYTES
argument_list|)
operator|!=
name|CLBYTES
condition|)
block|{
name|seterr
argument_list|(
literal|"cant read page %x of u of pid %d from %s"
argument_list|,
name|up
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|kmemf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|up
operator|+=
name|CLBYTES
expr_stmt|;
block|}
name|pcbpf
operator|=
operator|(
name|int
operator|)
name|btop
argument_list|(
name|p
operator|->
name|p_addr
argument_list|)
expr_stmt|;
comment|/* what should this be really? */
comment|/* 	 * Conjure up a physical address for the arguments. 	 */
name|kp
operator|->
name|kp_eproc
operator|.
name|e_vm
operator|.
name|vm_rssize
operator|=
name|kp
operator|->
name|kp_eproc
operator|.
name|e_vm
operator|.
name|vm_pmap
operator|.
name|pm_stats
operator|.
name|resident_count
expr_stmt|;
comment|/* XXX */
name|vaddr
operator|=
operator|(
name|u_int
operator|)
name|kp
operator|->
name|kp_eproc
operator|.
name|e_vm
operator|.
name|vm_minsaddr
expr_stmt|;
name|arg_size
operator|=
name|USRSTACK
operator|-
name|vaddr
expr_stmt|;
if|if
condition|(
name|kp
operator|->
name|kp_eproc
operator|.
name|e_vm
operator|.
name|vm_pmap
operator|.
name|pm_pdir
condition|)
block|{
name|struct
name|pde
name|pde
decl_stmt|;
name|klseek
argument_list|(
name|kmem
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|&
name|kp
operator|->
name|kp_eproc
operator|.
name|e_vm
operator|.
name|vm_pmap
operator|.
name|pm_pdir
index|[
name|pdei
argument_list|(
name|vaddr
argument_list|)
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pde
argument_list|,
sizeof|sizeof
name|pde
argument_list|)
operator|==
sizeof|sizeof
name|pde
operator|&&
name|pde
operator|.
name|pd_v
condition|)
block|{
name|struct
name|pte
name|pte
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|mem
argument_list|,
operator|(
name|long
operator|)
name|ctob
argument_list|(
name|pde
operator|.
name|pd_pfnum
argument_list|)
operator|+
operator|(
name|ptei
argument_list|(
name|vaddr
argument_list|)
operator|*
sizeof|sizeof
name|pte
operator|)
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|seterr
argument_list|(
literal|"kvm_getu: lseek"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pte
argument_list|,
sizeof|sizeof
name|pte
argument_list|)
operator|==
sizeof|sizeof
name|pte
condition|)
block|{
if|if
condition|(
name|pte
operator|.
name|pg_v
condition|)
block|{
name|argaddr1
operator|=
operator|(
name|pte
operator|.
name|pg_pfnum
operator|<<
name|PGSHIFT
operator|)
operator||
operator|(
operator|(
name|u_long
operator|)
name|vaddr
operator|&
operator|(
name|NBPG
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|seterr
argument_list|(
literal|"kvm_getu: read"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
operator|&
name|user
operator|.
name|user
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|kvm_getargs
parameter_list|(
name|p
parameter_list|,
name|up
parameter_list|)
specifier|const
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|const
name|struct
name|user
modifier|*
name|up
decl_stmt|;
block|{
name|int
name|arg_size
decl_stmt|,
name|arg_offset
decl_stmt|;
specifier|static
name|char
name|cmdbuf
index|[
name|ARG_MAX
index|]
decl_stmt|;
name|char
name|argc
index|[
name|ARG_MAX
operator|*
literal|3
index|]
decl_stmt|;
name|int
modifier|*
name|argv
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|nbad
decl_stmt|;
name|char
modifier|*
name|cmdbufp
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
name|char
name|procfile
index|[
literal|16
index|]
decl_stmt|;
name|int
name|mmfd
decl_stmt|;
if|#
directive|if
literal|0
block|char *argc = NULL;
endif|#
directive|endif
operator|*
name|cmdbuf
operator|=
literal|0
expr_stmt|;
name|vaddr
operator|=
call|(
name|u_int
call|)
argument_list|(
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|)
name|p
argument_list|)
operator|->
name|kp_eproc
operator|.
name|e_vm
operator|.
name|vm_minsaddr
expr_stmt|;
name|arg_size
operator|=
name|USRSTACK
operator|-
name|vaddr
expr_stmt|;
if|if
condition|(
name|arg_size
operator|>=
literal|3
operator|*
name|ARG_MAX
condition|)
goto|goto
name|bad
goto|;
if|#
directive|if
literal|0
block|sprintf(procfile, "/proc/%d", p->p_pid); 	if ((mmfd = open(procfile, O_RDONLY, 0)) == -1) { printf("failed to open %s\n",procfile); 		goto bad; 	}  	if ((argc = mmap(0, arg_size, PROT_READ, MAP_FILE, mmfd, vaddr)) 		== (char *)-1) { printf("failed to mmap %s error=%s\n", procfile, strerror(errno)); 		goto bad; 	}
endif|#
directive|endif
if|if
condition|(
operator|!
name|proc_getmem
argument_list|(
name|p
argument_list|,
name|argc
argument_list|,
name|arg_size
argument_list|,
name|vaddr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SLOAD
operator|)
operator|==
literal|0
operator|||
name|argaddr1
operator|==
literal|0
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
else|else
block|{
name|lseek
argument_list|(
name|mem
argument_list|,
operator|(
name|long
operator|)
name|argaddr1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
name|argc
argument_list|,
name|arg_size
argument_list|)
operator|!=
name|arg_size
condition|)
goto|goto
name|bad
goto|;
block|}
block|}
name|argv
operator|=
operator|(
name|int
operator|*
operator|)
name|argc
expr_stmt|;
name|arg_offset
operator|=
name|argv
index|[
literal|0
index|]
operator|-
name|vaddr
expr_stmt|;
if|if
condition|(
name|arg_offset
operator|>=
literal|3
operator|*
name|ARG_MAX
condition|)
goto|goto
name|bad
goto|;
name|nbad
operator|=
literal|0
expr_stmt|;
name|cmdbufp
operator|=
name|cmdbuf
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|&
name|argc
index|[
name|arg_offset
index|]
init|;
name|cp
operator|<
operator|&
name|argc
index|[
name|arg_size
index|]
condition|;
name|cp
operator|++
operator|,
name|cmdbufp
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|cmdbufp
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* convert null between arguments to space */
operator|*
name|cmdbufp
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* if null argument follows then no more args */
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|' '
operator|||
name|c
operator|>
literal|0176
condition|)
block|{
if|if
condition|(
operator|++
name|nbad
operator|>=
literal|5
operator|*
operator|(
literal|0
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* eflg -> 0 XXX */
comment|/* limit number of bad chars to 5 */
operator|*
name|cmdbufp
operator|++
operator|=
literal|'?'
expr_stmt|;
break|break;
block|}
operator|*
name|cmdbufp
operator|=
literal|'?'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
literal|0
operator|&&
name|c
operator|==
literal|'='
condition|)
block|{
comment|/* eflg -> 0 XXX */
while|while
condition|(
operator|*
operator|--
name|cmdbufp
operator|!=
literal|' '
condition|)
if|if
condition|(
name|cmdbufp
operator|<=
name|cmdbuf
condition|)
break|break;
break|break;
block|}
block|}
operator|*
name|cmdbufp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|--
name|cmdbufp
operator|==
literal|' '
condition|)
operator|*
name|cmdbufp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cmdbuf
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|cmdbuf
index|[
literal|0
index|]
operator|==
literal|'?'
operator|||
name|cmdbuf
index|[
literal|0
index|]
operator|<=
literal|' '
condition|)
block|{
name|bad
label|:
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cmdbuf
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|cmdbuf
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_comm
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cmdbuf
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (argc&& argc != (char *)-1) 		munmap(argc, arg_size); 	if (mmfd&& mmfd != -1) 		close (mmfd);
endif|#
directive|endif
return|return
operator|(
name|cmdbuf
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|getkvars
argument_list|()
block|{
if|if
condition|(
name|kvm_nlist
argument_list|(
name|nl
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|deadkernel
condition|)
block|{
comment|/* We must do the sys map first because klseek uses it */
name|long
name|addr
decl_stmt|;
name|PTD
operator|=
operator|(
expr|struct
name|pde
operator|*
operator|)
name|malloc
argument_list|(
name|NBPG
argument_list|)
expr_stmt|;
if|if
condition|(
name|PTD
operator|==
name|NULL
condition|)
block|{
name|seterr
argument_list|(
literal|"out of space for PTD"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|addr
operator|=
operator|(
name|long
operator|)
name|nl
index|[
name|X_IdlePTD
index|]
operator|.
name|n_value
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
name|PTD
argument_list|,
name|NBPG
argument_list|)
operator|!=
name|NBPG
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read PTD"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_if

begin_if
if|if
condition|(
name|kvm_read
argument_list|(
operator|(
name|void
operator|*
operator|)
name|nl
index|[
name|X_NSWAP
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|nswap
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read nswap"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_if

begin_if
if|if
condition|(
name|kvm_read
argument_list|(
operator|(
name|void
operator|*
operator|)
name|nl
index|[
name|X_DMMIN
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|dmmin
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read dmmin"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_if

begin_if
if|if
condition|(
name|kvm_read
argument_list|(
operator|(
name|void
operator|*
operator|)
name|nl
index|[
name|X_DMMAX
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|dmmax
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read dmmax"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_if

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_expr_stmt
unit|}  kvm_read
operator|(
name|loc
operator|,
name|buf
operator|,
name|len
operator|)
name|void
operator|*
name|loc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|kvmfilesopen
operator|==
literal|0
operator|&&
name|kvm_openfiles
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|iskva
argument_list|(
name|loc
argument_list|)
condition|)
block|{
name|klseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
block|{
name|seterr
argument_list|(
literal|"error reading kmem at %x"
argument_list|,
name|loc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|lseek
argument_list|(
name|mem
argument_list|,
operator|(
name|off_t
operator|)
name|loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
block|{
name|seterr
argument_list|(
literal|"error reading mem at %x"
argument_list|,
name|loc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|klseek
parameter_list|(
name|fd
parameter_list|,
name|loc
parameter_list|,
name|off
parameter_list|)
name|int
name|fd
decl_stmt|;
name|off_t
name|loc
decl_stmt|;
name|int
name|off
decl_stmt|;
block|{
if|if
condition|(
name|deadkernel
condition|)
block|{
if|if
condition|(
operator|(
name|loc
operator|=
name|Vtophys
argument_list|(
name|loc
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|loc
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|off_t
name|Vtophys
parameter_list|(
name|loc
parameter_list|)
name|u_long
name|loc
decl_stmt|;
block|{
name|off_t
name|newloc
init|=
operator|(
name|off_t
operator|)
operator|-
literal|1
decl_stmt|;
name|struct
name|pde
name|pde
decl_stmt|;
name|struct
name|pte
name|pte
decl_stmt|;
name|int
name|p
decl_stmt|;
name|pde
operator|=
name|PTD
index|[
name|loc
operator|>>
name|PD_SHIFT
index|]
expr_stmt|;
if|if
condition|(
name|pde
operator|.
name|pd_v
operator|==
literal|0
condition|)
block|{
name|seterr
argument_list|(
literal|"vtophys: page directory entry not valid"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|off_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|p
operator|=
name|btop
argument_list|(
name|loc
operator|&
name|PT_MASK
argument_list|)
expr_stmt|;
name|newloc
operator|=
name|pde
operator|.
name|pd_pfnum
operator|+
operator|(
name|p
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|newloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pte
argument_list|,
sizeof|sizeof
name|pte
argument_list|)
operator|!=
sizeof|sizeof
name|pte
condition|)
block|{
name|seterr
argument_list|(
literal|"vtophys: cannot obtain desired pte"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|off_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|newloc
operator|=
name|pte
operator|.
name|pg_pfnum
expr_stmt|;
if|if
condition|(
name|pte
operator|.
name|pg_v
operator|==
literal|0
condition|)
block|{
name|seterr
argument_list|(
literal|"vtophys: page table entry not valid"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|off_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|newloc
operator|+=
operator|(
name|loc
operator|&
name|PGOFSET
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|off_t
operator|)
name|newloc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * locate address of unwired or swapped page  */
end_comment

begin_define
define|#
directive|define
name|KREAD
parameter_list|(
name|off
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
define|\
value|(kvm_read((void *)(off), (char *)(addr), (len)) == (len))
end_define

begin_define
define|#
directive|define
name|vm_page_hash
parameter_list|(
name|object
parameter_list|,
name|offset
parameter_list|)
define|\
value|(((unsigned)object+(unsigned)atop(offset))&vm_page_hash_mask)
end_define

begin_function
specifier|static
name|int
name|findpage
parameter_list|(
name|object
parameter_list|,
name|offset
parameter_list|,
name|maddr
parameter_list|)
name|long
name|object
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|vm_offset_t
modifier|*
name|maddr
decl_stmt|;
block|{
specifier|static
name|long
name|vm_page_hash_mask
decl_stmt|;
specifier|static
name|long
name|vm_page_buckets
decl_stmt|;
specifier|static
name|long
name|page_shift
decl_stmt|;
name|queue_head_t
name|bucket
decl_stmt|;
name|struct
name|vm_page
name|mem
decl_stmt|;
name|long
name|addr
decl_stmt|,
name|baddr
decl_stmt|;
if|if
condition|(
name|vm_page_hash_mask
operator|==
literal|0
operator|&&
operator|!
name|KREAD
argument_list|(
name|nl
index|[
name|X_VM_PAGE_HASH_MASK
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|vm_page_hash_mask
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read vm_page_hash_mask"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|page_shift
operator|==
literal|0
operator|&&
operator|!
name|KREAD
argument_list|(
name|nl
index|[
name|X_PAGE_SHIFT
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|page_shift
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read page_shift"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|vm_page_buckets
operator|==
literal|0
operator|&&
operator|!
name|KREAD
argument_list|(
name|nl
index|[
name|X_VM_PAGE_BUCKETS
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|vm_page_buckets
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read vm_page_buckets"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|baddr
operator|=
name|vm_page_buckets
operator|+
name|vm_page_hash
argument_list|(
name|object
argument_list|,
name|offset
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|queue_head_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|KREAD
argument_list|(
name|baddr
argument_list|,
operator|&
name|bucket
argument_list|,
sizeof|sizeof
argument_list|(
name|bucket
argument_list|)
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read vm_page_bucket"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|addr
operator|=
operator|(
name|long
operator|)
name|bucket
operator|.
name|next
expr_stmt|;
while|while
condition|(
name|addr
operator|!=
name|baddr
condition|)
block|{
if|if
condition|(
operator|!
name|KREAD
argument_list|(
name|addr
argument_list|,
operator|&
name|mem
argument_list|,
sizeof|sizeof
argument_list|(
name|mem
argument_list|)
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read vm_page"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|mem
operator|.
name|object
operator|==
name|object
operator|&&
name|mem
operator|.
name|offset
operator|==
name|offset
condition|)
block|{
operator|*
name|maddr
operator|=
operator|(
name|long
operator|)
name|mem
operator|.
name|phys_addr
expr_stmt|;
return|return
literal|1
return|;
block|}
name|addr
operator|=
operator|(
name|long
operator|)
name|mem
operator|.
name|hashq
operator|.
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_decl_stmt
specifier|static
name|char
name|errbuf
index|[
name|_POSIX2_LINE_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|seterr
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|errbuf
argument_list|,
name|_POSIX2_LINE_MAX
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setsyserr
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|char
modifier|*
name|fmt
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|errbuf
argument_list|,
name|_POSIX2_LINE_MAX
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|errbuf
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
empty_stmt|;
name|snprintf
argument_list|(
name|cp
argument_list|,
name|_POSIX2_LINE_MAX
operator|-
operator|(
name|cp
operator|-
name|errbuf
operator|)
argument_list|,
literal|": %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|kvm_geterr
parameter_list|()
block|{
return|return
operator|(
name|errbuf
operator|)
return|;
block|}
end_function

end_unit

