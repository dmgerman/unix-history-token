begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE".  Use of the mrouted program represents acceptance of  * the terms and conditions listed in that file.  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  *  *  * $Id: vif.c,v 1.5 1993/06/24 05:11:16 deering Exp $  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/*  * Exported variables.  */
end_comment

begin_decl_stmt
name|struct
name|uvif
name|uvifs
index|[
name|MAXVIFS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of virtual interfaces */
end_comment

begin_decl_stmt
name|vifi_t
name|numvifs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of vifs in use       */
end_comment

begin_decl_stmt
name|int
name|vifs_down
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1=>some interfaces are down */
end_comment

begin_decl_stmt
name|int
name|udp_socket
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Since the honkin' kernel doesn't support */
end_comment

begin_comment
comment|/* ioctls on raw IP sockets, we need a UDP  */
end_comment

begin_comment
comment|/* socket as well as our IGMP (raw) socket. */
end_comment

begin_comment
comment|/* How dumb.                                */
end_comment

begin_comment
comment|/*  * Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|start_vif
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stop_vif
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Initialize the virtual interfaces.  */
end_comment

begin_function
name|void
name|init_vifs
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|int
name|enabled_vifs
decl_stmt|,
name|enabled_phyints
decl_stmt|;
name|numvifs
operator|=
literal|0
expr_stmt|;
name|vifs_down
operator|=
name|FALSE
expr_stmt|;
comment|/*      * Configure the vifs based on the interface configuration of the      * the kernel and the contents of the configuration file.      * (Open a UDP socket for ioctl use in the config procedures.)      */
if|if
condition|(
operator|(
name|udp_socket
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"UDP socket"
argument_list|)
expr_stmt|;
name|config_vifs_from_kernel
argument_list|()
expr_stmt|;
name|config_vifs_from_file
argument_list|()
expr_stmt|;
comment|/*      * Quit if there are fewer than two enabled vifs.      */
name|enabled_vifs
operator|=
literal|0
expr_stmt|;
name|enabled_phyints
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
operator|)
condition|)
block|{
operator|++
name|enabled_vifs
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
operator|++
name|enabled_phyints
expr_stmt|;
block|}
block|}
if|if
condition|(
name|enabled_vifs
operator|<
literal|2
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"can't forward: %s"
argument_list|,
name|enabled_vifs
operator|==
literal|0
condition|?
literal|"no enabled vifs"
else|:
literal|"only one enabled vif"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabled_phyints
operator|==
literal|0
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"no enabled interfaces, forwarding via tunnels only"
argument_list|)
expr_stmt|;
comment|/*      * Start routing on all virtual interfaces that are not down or      * administratively disabled.      */
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DOWN
operator|)
condition|)
name|start_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"%s is not yet up; vif #%u not in service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * See if any interfaces have changed from up state to down, or vice versa,  * including any non-multicast-capable interfaces that are in use as local  * tunnel end-points.  Ignore interfaces that have been administratively  * disabled.  */
end_comment

begin_function
name|void
name|check_vif_state
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|vifs_down
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
condition|)
continue|continue;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"ioctl SIOCGIFFLAGS for %s"
argument_list|,
name|ifr
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DOWN
condition|)
block|{
if|if
condition|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_UP
condition|)
block|{
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_DOWN
expr_stmt|;
name|start_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"%s has come up; vif #%u now in service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
else|else
name|vifs_down
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|stop_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_DOWN
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"%s has gone down; vif #%u taken out of service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|vifs_down
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Start routing on the specified virtual interface.  */
end_comment

begin_function
specifier|static
name|void
name|start_vif
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_long
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
name|src
operator|=
name|v
operator|->
name|uv_lcl_addr
expr_stmt|;
name|dst
operator|=
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
name|v
operator|->
name|uv_rmt_addr
else|:
name|dvmrp_group
expr_stmt|;
comment|/*      * Install the interface in the kernel's vif structure.      */
name|k_add_vif
argument_list|(
name|vifi
argument_list|,
operator|&
name|uvifs
index|[
name|vifi
index|]
argument_list|)
expr_stmt|;
comment|/*      * Update the existing route entries to take into account the new vif.      */
name|add_vif_to_routes
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
comment|/* 	 * Join the DVMRP multicast group on the interface. 	 * (This is not strictly necessary, since the kernel promiscuously 	 * receives IGMP packets addressed to ANY IP multicast group while 	 * multicast routing is enabled.  However, joining the group allows 	 * this host to receive non-IGMP packets as well, such as 'pings'.) 	 */
name|k_join
argument_list|(
name|dvmrp_group
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* 	 * Install an entry in the routing table for the subnet to which 	 * the interface is connected. 	 */
name|start_route_updates
argument_list|()
expr_stmt|;
name|update_route
argument_list|(
name|v
operator|->
name|uv_subnet
argument_list|,
name|v
operator|->
name|uv_subnetmask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
comment|/* 	 * Until neighbors are discovered, assume responsibility for sending 	 * periodic group membership queries to the subnet.  Send the first 	 * query. 	 */
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_QUERIER
expr_stmt|;
name|send_igmp
argument_list|(
name|src
argument_list|,
name|allhosts_group
argument_list|,
name|IGMP_HOST_MEMBERSHIP_QUERY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * Send a probe via the new vif to look for neighbors.      */
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_PROBE
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop routing on the specified virtual interface.  */
end_comment

begin_function
specifier|static
name|void
name|stop_vif
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
comment|/* 	 * Depart from the DVMRP multicast group on the interface. 	 */
name|k_leave
argument_list|(
name|dvmrp_group
argument_list|,
name|v
operator|->
name|uv_lcl_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Update the entry in the routing table for the subnet to which 	 * the interface is connected, to take into account the interface 	 * failure. 	 */
name|start_route_updates
argument_list|()
expr_stmt|;
name|update_route
argument_list|(
name|v
operator|->
name|uv_subnet
argument_list|,
name|v
operator|->
name|uv_subnetmask
argument_list|,
name|UNREACHABLE
argument_list|,
literal|0
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
comment|/* 	 * Discard all group addresses.  (No need to tell kernel; 	 * the k_del_vif() call, below, will clean up kernel state.) 	 */
while|while
condition|(
name|v
operator|->
name|uv_groups
operator|!=
name|NULL
condition|)
block|{
name|a
operator|=
name|v
operator|->
name|uv_groups
expr_stmt|;
name|v
operator|->
name|uv_groups
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_QUERIER
expr_stmt|;
block|}
comment|/*      * Update the existing route entries to take into account the vif failure.      */
name|delete_vif_from_routes
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
comment|/*      * Delete the interface from the kernel's vif structure.      */
name|k_del_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
comment|/*      * Discard all neighbor addresses.      */
while|while
condition|(
name|v
operator|->
name|uv_neighbors
operator|!=
name|NULL
condition|)
block|{
name|a
operator|=
name|v
operator|->
name|uv_neighbors
expr_stmt|;
name|v
operator|->
name|uv_neighbors
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find the virtual interface from which an incoming packet arrived,  * based on the packet's source and destination IP addresses.  */
end_comment

begin_function
name|vifi_t
name|find_vif
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
specifier|register
name|u_long
name|src
decl_stmt|;
specifier|register
name|u_long
name|dst
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
condition|)
block|{
if|if
condition|(
name|src
operator|==
name|v
operator|->
name|uv_rmt_addr
operator|&&
name|dst
operator|==
name|v
operator|->
name|uv_lcl_addr
condition|)
return|return
operator|(
name|vifi
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|src
operator|&
name|v
operator|->
name|uv_subnetmask
operator|)
operator|==
name|v
operator|->
name|uv_subnet
operator|&&
name|src
operator|!=
name|v
operator|->
name|uv_subnetbcast
condition|)
return|return
operator|(
name|vifi
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|NO_VIF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send group membership queries to all subnets for which I am querier.  */
end_comment

begin_function
name|void
name|query_groups
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_QUERIER
condition|)
block|{
name|send_igmp
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|allhosts_group
argument_list|,
name|IGMP_HOST_MEMBERSHIP_QUERY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Process an incoming group membership report.  */
end_comment

begin_function
name|void
name|accept_group_report
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|group
parameter_list|)
name|u_long
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|group
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
operator|||
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring group membership report from non-adjacent host %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
comment|/*      * Look for the group in our group list; if found, reset its timer.      */
for|for
control|(
name|g
operator|=
name|v
operator|->
name|uv_groups
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|al_next
control|)
block|{
if|if
condition|(
name|group
operator|==
name|g
operator|->
name|al_addr
condition|)
block|{
name|g
operator|->
name|al_timer
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/*      * If not found, add it to the list and tell the kernel.      */
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|g
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"ran out of memory"
argument_list|)
expr_stmt|;
comment|/* fatal */
name|g
operator|->
name|al_addr
operator|=
name|group
expr_stmt|;
name|g
operator|->
name|al_timer
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|al_next
operator|=
name|v
operator|->
name|uv_groups
expr_stmt|;
name|v
operator|->
name|uv_groups
operator|=
name|g
expr_stmt|;
name|k_add_group
argument_list|(
name|vifi
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send a probe on all vifs from which no neighbors have been heard recently.  */
end_comment

begin_function
name|void
name|probe_for_neighbors
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator|)
operator|)
operator|&&
name|v
operator|->
name|uv_neighbors
operator|==
name|NULL
condition|)
block|{
name|send_igmp
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
name|v
operator|->
name|uv_rmt_addr
else|:
name|dvmrp_group
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_PROBE
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Send a list of all of our neighbors to the requestor, `src'.  */
end_comment

begin_function
name|void
name|accept_neighbor_request
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|u_long
name|src
decl_stmt|,
name|dst
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ncount
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|la
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_long
name|temp_addr
decl_stmt|,
name|us
decl_stmt|,
name|them
init|=
name|src
decl_stmt|;
comment|/* Determine which of our addresses to use as the source of our response      * to this query.      */
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
block|{
comment|/* query sent to a multicast group */
name|int
name|udp
decl_stmt|;
comment|/* find best interface to reply on */
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|int
name|addrlen
init|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|dst
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
comment|/* any port over 1024 will do... */
if|if
condition|(
operator|(
name|udp
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|connect
argument_list|(
name|udp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
name|getsockname
argument_list|(
name|udp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"Determining local address"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|udp
argument_list|)
expr_stmt|;
return|return;
block|}
name|close
argument_list|(
name|udp
argument_list|)
expr_stmt|;
name|us
operator|=
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
else|else
comment|/* query sent to us alone */
name|us
operator|=
name|dst
expr_stmt|;
define|#
directive|define
name|PUT_ADDR
parameter_list|(
name|a
parameter_list|)
value|temp_addr = ntohl(a); \ 			*p++ = temp_addr>> 24; \ 			*p++ = (temp_addr>> 16)& 0xFF; \ 			*p++ = (temp_addr>> 8)& 0xFF; \ 			*p++ = temp_addr& 0xFF;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
condition|)
continue|continue;
name|ncount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|la
operator|=
name|v
operator|->
name|uv_neighbors
init|;
name|la
condition|;
name|la
operator|=
name|la
operator|->
name|al_next
control|)
block|{
comment|/* Make sure that there's room for this neighbor... */
if|if
condition|(
name|datalen
operator|+
operator|(
name|ncount
operator|==
literal|0
condition|?
literal|4
operator|+
literal|3
operator|+
literal|4
else|:
literal|4
operator|)
operator|>
name|MAX_DVMRP_DATA_LEN
condition|)
block|{
name|send_igmp
argument_list|(
name|us
argument_list|,
name|them
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_NEIGHBORS
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
name|ncount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Put out the header for this neighbor list... */
if|if
condition|(
name|ncount
operator|==
literal|0
condition|)
block|{
name|PUT_ADDR
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_metric
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_threshold
expr_stmt|;
name|ncount
operator|=
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|datalen
operator|+=
literal|4
operator|+
literal|3
expr_stmt|;
block|}
name|PUT_ADDR
argument_list|(
name|la
operator|->
name|al_addr
argument_list|)
expr_stmt|;
name|datalen
operator|+=
literal|4
expr_stmt|;
operator|(
operator|*
name|ncount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
name|send_igmp
argument_list|(
name|us
argument_list|,
name|them
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_NEIGHBORS
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a list of all of our neighbors to the requestor, `src'.  */
end_comment

begin_function
name|void
name|accept_neighbor_request2
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|u_long
name|src
decl_stmt|,
name|dst
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ncount
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|la
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_long
name|temp_addr
decl_stmt|,
name|us
decl_stmt|,
name|them
init|=
name|src
decl_stmt|;
comment|/* Determine which of our addresses to use as the source of our response      * to this query.      */
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
block|{
comment|/* query sent to a multicast group */
name|int
name|udp
decl_stmt|;
comment|/* find best interface to reply on */
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|int
name|addrlen
init|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|dst
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
comment|/* any port over 1024 will do... */
if|if
condition|(
operator|(
name|udp
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|connect
argument_list|(
name|udp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
name|getsockname
argument_list|(
name|udp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"Determining local address"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|udp
argument_list|)
expr_stmt|;
return|return;
block|}
name|close
argument_list|(
name|udp
argument_list|)
expr_stmt|;
name|us
operator|=
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
else|else
comment|/* query sent to us alone */
name|us
operator|=
name|dst
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
specifier|register
name|u_short
name|vflags
init|=
name|v
operator|->
name|uv_flags
decl_stmt|;
specifier|register
name|u_char
name|rflags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_TUNNEL
condition|)
name|rflags
operator||=
name|DVMRP_NF_TUNNEL
expr_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_SRCRT
condition|)
name|rflags
operator||=
name|DVMRP_NF_SRCRT
expr_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_DOWN
condition|)
name|rflags
operator||=
name|DVMRP_NF_DOWN
expr_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_DISABLED
condition|)
name|rflags
operator||=
name|DVMRP_NF_DISABLED
expr_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_QUERIER
condition|)
name|rflags
operator||=
name|DVMRP_NF_QUERIER
expr_stmt|;
name|ncount
operator|=
literal|0
expr_stmt|;
name|la
operator|=
name|v
operator|->
name|uv_neighbors
expr_stmt|;
if|if
condition|(
name|la
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * include down& disabled interfaces and interfaces on 		 * leaf nets. 		 */
if|if
condition|(
name|rflags
operator|&
name|DVMRP_NF_TUNNEL
condition|)
name|rflags
operator||=
name|DVMRP_NF_DOWN
expr_stmt|;
if|if
condition|(
name|datalen
operator|>
name|MAX_DVMRP_DATA_LEN
operator|-
literal|12
condition|)
block|{
name|send_igmp
argument_list|(
name|us
argument_list|,
name|them
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_NEIGHBORS2
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
block|}
operator|*
operator|(
name|u_int
operator|*
operator|)
name|p
operator|=
name|v
operator|->
name|uv_lcl_addr
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_metric
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_threshold
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rflags
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|p
operator|=
name|v
operator|->
name|uv_rmt_addr
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|datalen
operator|+=
literal|12
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|la
condition|;
name|la
operator|=
name|la
operator|->
name|al_next
control|)
block|{
comment|/* Make sure that there's room for this neighbor... */
if|if
condition|(
name|datalen
operator|+
operator|(
name|ncount
operator|==
literal|0
condition|?
literal|4
operator|+
literal|4
operator|+
literal|4
else|:
literal|4
operator|)
operator|>
name|MAX_DVMRP_DATA_LEN
condition|)
block|{
name|send_igmp
argument_list|(
name|us
argument_list|,
name|them
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_NEIGHBORS2
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
name|ncount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Put out the header for this neighbor list... */
if|if
condition|(
name|ncount
operator|==
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int
operator|*
operator|)
name|p
operator|=
name|v
operator|->
name|uv_lcl_addr
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_metric
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_threshold
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rflags
expr_stmt|;
name|ncount
operator|=
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|datalen
operator|+=
literal|4
operator|+
literal|4
expr_stmt|;
block|}
operator|*
operator|(
name|u_int
operator|*
operator|)
name|p
operator|=
name|la
operator|->
name|al_addr
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|datalen
operator|+=
literal|4
expr_stmt|;
operator|(
operator|*
name|ncount
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
name|send_igmp
argument_list|(
name|us
argument_list|,
name|them
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_NEIGHBORS2
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an incoming neighbor-list message.  */
end_comment

begin_function
name|void
name|accept_neighbors
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|,
name|level
parameter_list|)
name|u_long
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|level
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring spurious DVMRP neighbor list from %s to %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an incoming neighbor-list message.  */
end_comment

begin_function
name|void
name|accept_neighbors2
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|,
name|level
parameter_list|)
name|u_long
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|level
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring spurious DVMRP neighbor list2 from %s to %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the neighbor entry for neighbor 'addr' on vif 'vifi'.  * 'msgtype' is the type of DVMRP message received from the neighbor.  * Return TRUE if 'addr' is a valid neighbor, FALSE otherwise.  */
end_comment

begin_function
name|int
name|update_neighbor
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|,
name|msgtype
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_long
name|addr
decl_stmt|;
name|int
name|msgtype
decl_stmt|;
block|{
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|n
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
comment|/*      * Confirm that 'addr' is a valid neighbor address on vif 'vifi'.      * IT IS ASSUMED that this was preceded by a call to find_vif(), which      * checks that 'addr' is either a valid remote tunnel endpoint or a      * non-broadcast address belonging to a directly-connected subnet.      * Therefore, here we check only that 'addr' is not our own address      * (due to an impostor or erroneous loopback) or an address of the form      * {subnet,0} ("the unknown host").  These checks are not performed in      * find_vif() because those types of address are acceptable for some      * types of IGMP message (such as group membership reports).      */
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
operator|&&
operator|(
name|addr
operator|==
name|v
operator|->
name|uv_lcl_addr
operator|||
name|addr
operator|==
name|v
operator|->
name|uv_subnet
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received DVMRP message from 'the unknown host' or self: %s"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*      * If we have received a route report from a neighbor, and we believed      * that we had no neighbors on this vif, send a full route report to      * all neighbors on the vif.      */
if|if
condition|(
name|msgtype
operator|==
name|DVMRP_REPORT
operator|&&
name|v
operator|->
name|uv_neighbors
operator|==
name|NULL
condition|)
name|report
argument_list|(
name|ALL_ROUTES
argument_list|,
name|vifi
argument_list|,
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
name|addr
else|:
name|dvmrp_group
argument_list|)
expr_stmt|;
comment|/*      * Look for addr in list of neighbors; if found, reset its timer.      */
for|for
control|(
name|n
operator|=
name|v
operator|->
name|uv_neighbors
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|al_next
control|)
block|{
if|if
condition|(
name|addr
operator|==
name|n
operator|->
name|al_addr
condition|)
block|{
name|n
operator|->
name|al_timer
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/*      * If not found, add it to the list.  If the neighbor has a lower      * IP address than me, yield querier duties to it.      */
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|n
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"ran out of memory"
argument_list|)
expr_stmt|;
comment|/* fatal */
name|n
operator|->
name|al_addr
operator|=
name|addr
expr_stmt|;
name|n
operator|->
name|al_timer
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|al_next
operator|=
name|v
operator|->
name|uv_neighbors
expr_stmt|;
name|v
operator|->
name|uv_neighbors
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
operator|&&
name|ntohl
argument_list|(
name|addr
argument_list|)
operator|<
name|ntohl
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|)
condition|)
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_QUERIER
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * On every timer interrupt, advance the timer in each neighbor and  * group entry on every vif.  */
end_comment

begin_function
name|void
name|age_vifs
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|,
modifier|*
name|prev_a
decl_stmt|,
modifier|*
name|n
decl_stmt|;
specifier|register
name|u_long
name|addr
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
for|for
control|(
name|prev_a
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
operator|&
operator|(
name|v
operator|->
name|uv_neighbors
operator|)
operator|,
name|a
operator|=
name|v
operator|->
name|uv_neighbors
init|;
name|a
operator|!=
name|NULL
condition|;
name|prev_a
operator|=
name|a
operator|,
name|a
operator|=
name|a
operator|->
name|al_next
control|)
block|{
if|if
condition|(
operator|(
name|a
operator|->
name|al_timer
operator|+=
name|TIMER_INTERVAL
operator|)
operator|<
name|NEIGHBOR_EXPIRE_TIME
condition|)
continue|continue;
comment|/* 	     * Neighbor has expired; delete it from the neighbor list, 	     * delete it from the 'dominants' and 'subordinates arrays of 	     * any route entries and assume querier duties unless there is 	     * another neighbor with a lower IP address than mine. 	     */
name|addr
operator|=
name|a
operator|->
name|al_addr
expr_stmt|;
name|prev_a
operator|->
name|al_next
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
name|a
operator|=
name|prev_a
expr_stmt|;
name|delete_neighbor_from_routes
argument_list|(
name|addr
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_QUERIER
expr_stmt|;
for|for
control|(
name|n
operator|=
name|v
operator|->
name|uv_neighbors
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|al_next
control|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|n
operator|->
name|al_addr
argument_list|)
operator|<
name|ntohl
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|)
condition|)
block|{
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_QUERIER
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
for|for
control|(
name|prev_a
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
operator|&
operator|(
name|v
operator|->
name|uv_groups
operator|)
operator|,
name|a
operator|=
name|v
operator|->
name|uv_groups
init|;
name|a
operator|!=
name|NULL
condition|;
name|prev_a
operator|=
name|a
operator|,
name|a
operator|=
name|a
operator|->
name|al_next
control|)
block|{
if|if
condition|(
operator|(
name|a
operator|->
name|al_timer
operator|+=
name|TIMER_INTERVAL
operator|)
operator|<
name|GROUP_EXPIRE_TIME
condition|)
continue|continue;
comment|/* 	     * Group has expired; tell kernel and delete from group list. 	     */
name|k_del_group
argument_list|(
name|vifi
argument_list|,
name|a
operator|->
name|al_addr
argument_list|)
expr_stmt|;
name|prev_a
operator|->
name|al_next
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
name|a
operator|=
name|prev_a
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print the contents of the uvifs array on file 'fp'.  */
end_comment

begin_function
name|void
name|dump_vifs
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nVirtual Interface Table\n%s"
argument_list|,
literal|" Vif  Local-Address                           Metric  Thresh  Flags\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %2u   %-15s %6s: %-15s %4u %7u   "
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|s1
argument_list|)
argument_list|,
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
literal|"tunnel"
else|:
literal|"subnet"
argument_list|,
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_rmt_addr
argument_list|,
name|s2
argument_list|)
else|:
name|inet_fmts
argument_list|(
name|v
operator|->
name|uv_subnet
argument_list|,
name|v
operator|->
name|uv_subnetmask
argument_list|,
name|s3
argument_list|)
argument_list|,
name|v
operator|->
name|uv_metric
argument_list|,
name|v
operator|->
name|uv_threshold
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DOWN
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" down"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" disabled"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_QUERIER
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" querier"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_SRCRT
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" src-rt"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_neighbors
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                      peers : %-15s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_neighbors
operator|->
name|al_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|v
operator|->
name|uv_neighbors
operator|->
name|al_next
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|al_next
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                              %-15s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|a
operator|->
name|al_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v
operator|->
name|uv_groups
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                      groups: %-15s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_groups
operator|->
name|al_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|v
operator|->
name|uv_groups
operator|->
name|al_next
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|al_next
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                              %-15s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|a
operator|->
name|al_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

