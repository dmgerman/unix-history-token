begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1985 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)timed.c	2.21 (Berkeley) 3/2/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_define
define|#
directive|define
name|TSPTYPES
end_define

begin_include
include|#
directive|include
file|<protocols/timed.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_decl_stmt
name|int
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|trace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sock
decl_stmt|,
name|sock_raw
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|status
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|backoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|slvcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no. of slaves controlled by master */
end_comment

begin_decl_stmt
name|int
name|machup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|sequence
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sequence number */
end_comment

begin_decl_stmt
name|long
name|delay1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|delay2
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|random
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|host
name|hp
index|[
name|NHOSTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|tracefile
index|[]
init|=
name|_PATH_TIMEDLOG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|jmpenv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|netinfo
modifier|*
name|nettab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nslavenets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of networks were I could be a slave */
end_comment

begin_decl_stmt
name|int
name|nmasternets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of networks were I could be a master */
end_comment

begin_decl_stmt
name|int
name|nignorednets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of ignored networks */
end_comment

begin_decl_stmt
name|int
name|nnets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of networks I am connected to */
end_comment

begin_decl_stmt
name|struct
name|netinfo
modifier|*
name|slavenet
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|netinfo
modifier|*
name|firstslavenet
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|Mflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|justquit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|nets
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|net
decl_stmt|;
name|struct
name|nets
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|nets
init|=
operator|(
expr|struct
name|nets
operator|*
operator|)
literal|0
struct|;
end_struct

begin_comment
comment|/*  * The timedaemons synchronize the clocks of hosts in a local area network.  * One daemon runs as master, all the others as slaves. The master  * performs the task of computing clock differences and sends correction  * values to the slaves.   * Slaves start an election to choose a new master when the latter disappears   * because of a machine crash, network partition, or when killed.  * A resolution protocol is used to kill all but one of the masters  * that happen to exist in segments of a partitioned network when the   * network partition is fixed.  *  * Authors: Riccardo Gusella& Stefano Zatti  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|on
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|long
name|seed
decl_stmt|;
name|int
name|nflag
decl_stmt|,
name|iflag
decl_stmt|;
name|struct
name|timeval
name|time
decl_stmt|;
name|struct
name|servent
modifier|*
name|srvp
decl_stmt|;
name|long
name|casual
parameter_list|()
function_decl|;
name|char
modifier|*
name|date
parameter_list|()
function_decl|;
name|int
name|n
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cplim
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|struct
name|ifreq
name|ifreq
decl_stmt|,
modifier|*
name|ifr
decl_stmt|;
specifier|register
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|ntip
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|savefromnet
decl_stmt|;
name|struct
name|sockaddr_in
name|server
decl_stmt|;
name|u_short
name|port
decl_stmt|;
name|uid_t
name|getuid
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|lint
name|ntip
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|Mflag
operator|=
literal|0
expr_stmt|;
name|on
operator|=
literal|1
expr_stmt|;
name|backoff
operator|=
literal|1
expr_stmt|;
name|trace
operator|=
name|OFF
expr_stmt|;
name|nflag
operator|=
name|OFF
expr_stmt|;
name|iflag
operator|=
name|OFF
expr_stmt|;
name|openlog
argument_list|(
literal|"timed"
argument_list|,
name|LOG_CONS
operator||
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
if|if
condition|(
name|getuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Timed: not superuser\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
block|{
operator|(
operator|*
name|argv
operator|)
operator|++
expr_stmt|;
do|do
block|{
switch|switch
condition|(
operator|*
operator|*
name|argv
condition|)
block|{
case|case
literal|'M'
case|:
name|Mflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|trace
operator|=
name|ON
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|iflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"timed: -i and -n make no sense together\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nflag
operator|=
name|ON
expr_stmt|;
name|addnetname
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
operator|(
operator|++
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
operator|)
condition|)
empty_stmt|;
break|break;
case|case
literal|'i'
case|:
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"timed: -i and -n make no sense together\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iflag
operator|=
name|ON
expr_stmt|;
name|addnetname
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
operator|(
operator|++
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
operator|)
condition|)
empty_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"timed: -%c: unknown option\n"
argument_list|,
operator|*
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|*
operator|++
operator|(
operator|*
name|argv
operator|)
condition|)
do|;
block|}
ifndef|#
directive|ifndef
name|DEBUG
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|trace
operator|==
name|ON
condition|)
block|{
name|fd
operator|=
name|fopen
argument_list|(
name|tracefile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|setlinebuf
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Tracing started on: %s\n\n"
argument_list|,
name|date
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|srvp
operator|=
name|getservbyname
argument_list|(
literal|"timed"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srvp
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"unknown service 'timed/udp'"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|port
operator|=
name|srvp
operator|->
name|s_port
expr_stmt|;
name|server
operator|.
name|sin_port
operator|=
name|srvp
operator|->
name|s_port
expr_stmt|;
name|server
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|server
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server
argument_list|,
sizeof|sizeof
argument_list|(
name|server
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EADDRINUSE
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server already running"
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* choose a unique seed for random number generation */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|time
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|seed
operator|=
name|time
operator|.
name|tv_sec
operator|+
name|time
operator|.
name|tv_usec
expr_stmt|;
name|srandom
argument_list|(
name|seed
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|random
argument_list|()
expr_stmt|;
comment|/* initial seq number */
comment|/* rounds kernel variable time to multiple of 5 ms. */
name|time
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|time
operator|.
name|tv_usec
operator|=
operator|-
operator|(
operator|(
name|time
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
operator|%
literal|5
operator|)
operator|*
literal|1000
expr_stmt|;
operator|(
name|void
operator|)
name|adjtime
argument_list|(
operator|&
name|time
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|id
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gethostname: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hp
index|[
literal|0
index|]
operator|.
name|name
operator|=
name|hostname
expr_stmt|;
if|if
condition|(
name|nflag
operator|||
name|iflag
condition|)
block|{
name|struct
name|netent
modifier|*
name|getnetent
parameter_list|()
function_decl|;
name|struct
name|netent
modifier|*
name|n
decl_stmt|;
name|struct
name|nets
modifier|*
name|np
decl_stmt|;
for|for
control|(
name|np
operator|=
name|nets
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|next
control|)
block|{
name|n
operator|=
name|getnetbyname
argument_list|(
name|np
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getnetbyname: unknown net %s"
argument_list|,
name|np
operator|->
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|net
operator|=
name|n
operator|->
name|n_net
expr_stmt|;
block|}
block|}
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get interface configuration: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ntp
operator|=
name|NULL
expr_stmt|;
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a> b ? a : b)
define|#
directive|define
name|size
parameter_list|(
name|p
parameter_list|)
value|max((p).sa_len, sizeof(p))
name|cplim
operator|=
name|buf
operator|+
name|ifc
operator|.
name|ifc_len
expr_stmt|;
comment|/*skip over if's with big ifr_addr's */
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
name|cplim
condition|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
operator|+
name|size
argument_list|(
name|ifr
operator|->
name|ifr_addr
argument_list|)
control|)
block|{
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
continue|continue;
name|ifreq
operator|=
operator|*
name|ifr
expr_stmt|;
if|if
condition|(
name|ntp
operator|==
name|NULL
condition|)
name|ntp
operator|=
operator|(
expr|struct
name|netinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo
argument_list|)
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|my_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get interface flags: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_BROADCAST
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_BROADCAST
condition|)
name|flag
operator|=
literal|1
expr_stmt|;
else|else
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get netmask: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ntp
operator|->
name|mask
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFBRDADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get broadaddr: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ntp
operator|->
name|dest_addr
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_broadaddr
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFDSTADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get destaddr: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ntp
operator|->
name|dest_addr
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_dstaddr
expr_stmt|;
block|}
name|ntp
operator|->
name|dest_addr
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
if|if
condition|(
name|nflag
operator|||
name|iflag
condition|)
block|{
name|u_long
name|addr
decl_stmt|,
name|mask
decl_stmt|;
name|struct
name|nets
modifier|*
name|n
decl_stmt|;
name|addr
operator|=
name|ntohl
argument_list|(
name|ntp
operator|->
name|dest_addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ntohl
argument_list|(
name|ntp
operator|->
name|mask
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|mask
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|addr
operator|>>=
literal|1
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
name|nets
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
if|if
condition|(
name|addr
operator|==
name|n
operator|->
name|net
condition|)
break|break;
if|if
condition|(
name|nflag
operator|&&
operator|!
name|n
operator|||
name|iflag
operator|&&
name|n
condition|)
continue|continue;
block|}
name|ntp
operator|->
name|net
operator|=
name|ntp
operator|->
name|mask
operator|&
name|ntp
operator|->
name|dest_addr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|ntp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nettab
operator|==
name|NULL
condition|)
block|{
name|nettab
operator|=
name|ntp
expr_stmt|;
block|}
else|else
block|{
name|ntip
operator|->
name|next
operator|=
name|ntp
expr_stmt|;
block|}
name|ntip
operator|=
name|ntp
expr_stmt|;
name|ntp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ntp
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nettab
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No network usable"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
name|lookformaster
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
name|setstatus
argument_list|()
expr_stmt|;
comment|/* 	 * Take care of some basic initialization. 	 */
comment|/* us. delay to be used in response to broadcast */
name|delay1
operator|=
name|casual
argument_list|(
operator|(
name|long
operator|)
literal|10000
argument_list|,
literal|200000
argument_list|)
expr_stmt|;
comment|/* election timer delay in secs. */
name|delay2
operator|=
name|casual
argument_list|(
operator|(
name|long
operator|)
name|MINTOUT
argument_list|,
operator|(
name|long
operator|)
name|MAXTOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mflag
condition|)
block|{
comment|/* 		 * number (increased by 1) of slaves controlled by master:  		 * used in master.c, candidate.c, networkdelta.c, and  		 * correct.c  		 */
name|slvcount
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|setjmp
argument_list|(
name|jmpenv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|0
case|:
name|makeslave
argument_list|(
name|firstslavenet
argument_list|()
argument_list|)
expr_stmt|;
name|setstatus
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Just lost our master */
name|setstatus
argument_list|()
expr_stmt|;
name|slavenet
operator|->
name|status
operator|=
name|election
argument_list|(
name|slavenet
argument_list|)
expr_stmt|;
name|checkignorednets
argument_list|()
expr_stmt|;
name|setstatus
argument_list|()
expr_stmt|;
if|if
condition|(
name|slavenet
operator|->
name|status
operator|==
name|MASTER
condition|)
name|makeslave
argument_list|(
name|firstslavenet
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|makeslave
argument_list|(
name|slavenet
argument_list|)
expr_stmt|;
name|setstatus
argument_list|()
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Just been told to quit */
name|fromnet
operator|->
name|status
operator|=
name|SLAVE
expr_stmt|;
name|setstatus
argument_list|()
expr_stmt|;
name|savefromnet
operator|=
name|fromnet
expr_stmt|;
name|rmnetmachs
argument_list|(
name|fromnet
argument_list|)
expr_stmt|;
name|checkignorednets
argument_list|()
expr_stmt|;
if|if
condition|(
name|slavenet
condition|)
name|makeslave
argument_list|(
name|slavenet
argument_list|)
expr_stmt|;
else|else
name|makeslave
argument_list|(
name|savefromnet
argument_list|)
expr_stmt|;
name|setstatus
argument_list|()
expr_stmt|;
name|justquit
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* this should not happen */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Attempt to enter invalid state"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|&
name|MASTER
condition|)
block|{
comment|/* open raw socket used to measure time differences */
if|if
condition|(
name|sock_raw
operator|==
operator|-
literal|1
condition|)
block|{
name|sock_raw
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_ICMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_raw
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"opening raw socket: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* sock_raw is not being used now */
if|if
condition|(
name|sock_raw
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock_raw
argument_list|)
expr_stmt|;
name|sock_raw
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|MASTER
condition|)
name|master
argument_list|()
expr_stmt|;
else|else
name|slave
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* if Mflag is not set timedaemon is forced to act as a slave */
name|status
operator|=
name|SLAVE
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jmpenv
argument_list|)
condition|)
block|{
name|setstatus
argument_list|()
expr_stmt|;
name|checkignorednets
argument_list|()
expr_stmt|;
block|}
name|makeslave
argument_list|(
name|firstslavenet
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|MASTER
condition|)
name|ntp
operator|->
name|status
operator|=
name|IGNORE
expr_stmt|;
name|setstatus
argument_list|()
expr_stmt|;
name|slave
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Try to become master over ignored nets..  */
end_comment

begin_macro
name|checkignorednets
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|IGNORE
condition|)
name|lookformaster
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|lookformaster
argument_list|(
name|ntp
argument_list|)
specifier|register
expr|struct
name|netinfo
operator|*
name|ntp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|tsp
name|resp
decl_stmt|,
name|conflict
decl_stmt|,
modifier|*
name|answer
decl_stmt|,
modifier|*
name|readmsg
argument_list|()
decl_stmt|,
modifier|*
name|acksend
argument_list|()
decl_stmt|;
name|struct
name|timeval
name|time
decl_stmt|;
name|char
name|mastername
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|masteraddr
decl_stmt|;
name|ntp
operator|->
name|status
operator|=
name|SLAVE
expr_stmt|;
comment|/* look for master */
name|resp
operator|.
name|tsp_type
operator|=
name|TSP_MASTERREQ
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|resp
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|resp
argument_list|,
operator|&
name|ntp
operator|->
name|dest_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ANYADDR
argument_list|,
name|TSP_MASTERACK
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Various conditions can cause conflict: race between 		 * two just started timedaemons when no master is 		 * present, or timedaemon started during an election. 		 * Conservative approach is taken: give up and became a 		 * slave postponing election of a master until first 		 * timer expires. 		 */
name|time
operator|.
name|tv_sec
operator|=
name|time
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|answer
operator|=
name|readmsg
argument_list|(
name|TSP_MASTERREQ
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ANYADDR
argument_list|,
operator|&
name|time
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
name|NULL
condition|)
block|{
name|ntp
operator|->
name|status
operator|=
name|SLAVE
expr_stmt|;
return|return;
block|}
name|time
operator|.
name|tv_sec
operator|=
name|time
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|answer
operator|=
name|readmsg
argument_list|(
name|TSP_MASTERUP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ANYADDR
argument_list|,
operator|&
name|time
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
name|NULL
condition|)
block|{
name|ntp
operator|->
name|status
operator|=
name|SLAVE
expr_stmt|;
return|return;
block|}
name|time
operator|.
name|tv_sec
operator|=
name|time
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|answer
operator|=
name|readmsg
argument_list|(
name|TSP_ELECTION
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ANYADDR
argument_list|,
operator|&
name|time
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
name|NULL
condition|)
block|{
name|ntp
operator|->
name|status
operator|=
name|SLAVE
expr_stmt|;
return|return;
block|}
name|ntp
operator|->
name|status
operator|=
name|MASTER
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|mastername
argument_list|,
name|answer
operator|->
name|tsp_name
argument_list|)
expr_stmt|;
name|masteraddr
operator|=
name|from
expr_stmt|;
comment|/* 		 * If network has been partitioned, there might be other 		 * masters; tell the one we have just acknowledged that  		 * it has to gain control over the others.  		 */
name|time
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|time
operator|.
name|tv_usec
operator|=
literal|300000
expr_stmt|;
name|answer
operator|=
name|readmsg
argument_list|(
name|TSP_MASTERACK
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ANYADDR
argument_list|,
operator|&
name|time
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
comment|/* 		 * checking also not to send CONFLICT to ack'ed master 		 * due to duplicated MASTERACKs 		 */
if|if
condition|(
name|answer
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|answer
operator|->
name|tsp_name
argument_list|,
name|mastername
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|conflict
operator|.
name|tsp_type
operator|=
name|TSP_CONFLICT
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|conflict
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|acksend
argument_list|(
operator|&
name|conflict
argument_list|,
operator|&
name|masteraddr
argument_list|,
name|mastername
argument_list|,
name|TSP_ACK
argument_list|,
operator|(
expr|struct
name|netinfo
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error on sending TSP_CONFLICT"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * based on the current network configuration, set the status, and count  * networks;  */
end_comment

begin_macro
name|setstatus
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|nmasternets
operator|=
name|nslavenets
operator|=
name|nnets
operator|=
name|nignorednets
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Net status:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ntp
operator|->
name|status
condition|)
block|{
case|case
name|MASTER
case|:
name|nmasternets
operator|++
expr_stmt|;
break|break;
case|case
name|SLAVE
case|:
name|nslavenets
operator|++
expr_stmt|;
break|break;
case|case
name|IGNORE
case|:
name|nignorednets
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\t%-16s"
argument_list|,
name|inet_ntoa
argument_list|(
name|inet_makeaddr
argument_list|(
name|ntp
operator|->
name|net
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|ntp
operator|->
name|status
condition|)
block|{
case|case
name|MASTER
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"MASTER\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLAVE
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"SLAVE\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IGNORE
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"IGNORE\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"invalid state %d\n"
argument_list|,
operator|(
name|int
operator|)
name|ntp
operator|->
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|nnets
operator|++
expr_stmt|;
name|status
operator||=
name|ntp
operator|->
name|status
expr_stmt|;
block|}
name|status
operator|&=
operator|~
name|IGNORE
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\tnets = %d, masters = %d, slaves = %d, ignored = %d\n"
argument_list|,
name|nnets
argument_list|,
name|nmasternets
argument_list|,
name|nslavenets
argument_list|,
name|nignorednets
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|makeslave
argument_list|(
argument|net
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|netinfo
modifier|*
name|net
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|SLAVE
operator|&&
name|ntp
operator|!=
name|net
condition|)
name|ntp
operator|->
name|status
operator|=
name|IGNORE
expr_stmt|;
name|slavenet
operator|=
name|net
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|netinfo
modifier|*
name|firstslavenet
parameter_list|()
block|{
specifier|register
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|SLAVE
condition|)
return|return
operator|(
name|ntp
operator|)
return|;
return|return
operator|(
operator|(
expr|struct
name|netinfo
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * `casual' returns a random number in the range [inf, sup]  */
end_comment

begin_function
name|long
name|casual
parameter_list|(
name|inf
parameter_list|,
name|sup
parameter_list|)
name|long
name|inf
decl_stmt|;
name|long
name|sup
decl_stmt|;
block|{
name|float
name|value
decl_stmt|;
name|value
operator|=
call|(
name|float
call|)
argument_list|(
name|random
argument_list|()
operator|&
literal|0x7fffffff
argument_list|)
operator|/
literal|0x7fffffff
expr_stmt|;
return|return
operator|(
name|inf
operator|+
operator|(
name|sup
operator|-
name|inf
operator|)
operator|*
name|value
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|date
parameter_list|()
block|{
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
name|struct
name|timeval
name|tv
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctime
argument_list|(
operator|&
name|tv
operator|.
name|tv_sec
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|addnetname
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nets
modifier|*
modifier|*
name|netlist
init|=
operator|&
name|nets
decl_stmt|;
while|while
condition|(
operator|*
name|netlist
condition|)
name|netlist
operator|=
operator|&
operator|(
operator|(
operator|*
name|netlist
operator|)
operator|->
name|next
operator|)
expr_stmt|;
operator|*
name|netlist
operator|=
operator|(
expr|struct
name|nets
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
operator|*
name|netlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|netlist
operator|==
operator|(
expr|struct
name|nets
operator|*
operator|)
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|netlist
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|netlist
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|netlist
operator|)
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_block

end_unit

