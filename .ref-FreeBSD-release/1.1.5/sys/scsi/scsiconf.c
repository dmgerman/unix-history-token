begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  * Ported to run under 386BSD by Julian Elischer (julian@tfs.com) Sept 1992  *  *      $Id: scsiconf.c,v 1.7 1993/11/18 05:02:58 rgrimes Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|"st.h"
end_include

begin_include
include|#
directive|include
file|"sd.h"
end_include

begin_include
include|#
directive|include
file|"ch.h"
end_include

begin_include
include|#
directive|include
file|"cd.h"
end_include

begin_include
include|#
directive|include
file|"uk.h"
end_include

begin_include
include|#
directive|include
file|"su.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NSCBUS
end_ifndef

begin_define
define|#
directive|define
name|NSCBUS
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSCBUS */
end_comment

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TFS
end_ifdef

begin_include
include|#
directive|include
file|"bll.h"
end_include

begin_include
include|#
directive|include
file|"cals.h"
end_include

begin_include
include|#
directive|include
file|"kil.h"
end_include

begin_include
include|#
directive|include
file|"scan.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* TFS */
end_comment

begin_define
define|#
directive|define
name|NBLL
value|0
end_define

begin_define
define|#
directive|define
name|NCALS
value|0
end_define

begin_define
define|#
directive|define
name|NKIL
value|0
end_define

begin_define
define|#
directive|define
name|NSCAN
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TFS */
end_comment

begin_if
if|#
directive|if
name|NSD
operator|>
literal|0
end_if

begin_extern
extern|extern  sdattach(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSD */
end_comment

begin_if
if|#
directive|if
name|NST
operator|>
literal|0
end_if

begin_extern
extern|extern  stattach(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NST */
end_comment

begin_if
if|#
directive|if
name|NCH
operator|>
literal|0
end_if

begin_extern
extern|extern  chattach(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCH */
end_comment

begin_if
if|#
directive|if
name|NCD
operator|>
literal|0
end_if

begin_extern
extern|extern  cdattach(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCD */
end_comment

begin_if
if|#
directive|if
name|NBLL
operator|>
literal|0
end_if

begin_extern
extern|extern  bllattach(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NBLL */
end_comment

begin_if
if|#
directive|if
name|NCALS
operator|>
literal|0
end_if

begin_extern
extern|extern  calsattach(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCALS */
end_comment

begin_if
if|#
directive|if
name|NKIL
operator|>
literal|0
end_if

begin_extern
extern|extern  kil_attach(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NKIL */
end_comment

begin_if
if|#
directive|if
name|NUK
operator|>
literal|0
end_if

begin_extern
extern|extern  ukattach(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NUK */
end_comment

begin_comment
comment|/*  * One of these is allocated and filled in for each scsi bus.  * it holds pointers to allow the scsi bus to get to the driver  * That is running each LUN on the bus  * it also has a template entry which is the prototype struct  * supplied by the adapter driver, this is used to initialise  * the others, before they have the rest of the fields filled in  */
end_comment

begin_decl_stmt
name|struct
name|scsibus_data
modifier|*
name|scbus_data
index|[
name|NSCBUS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The structure of pre-configured devices that might be turned  * off and therefore may not show up  */
end_comment

begin_struct
struct|struct
name|predefined
block|{
name|u_char
name|scsibus
decl_stmt|;
name|u_char
name|dev
decl_stmt|;
name|u_char
name|lu
decl_stmt|;
name|errval
function_decl|(
modifier|*
name|attach_rtn
function_decl|)
parameter_list|()
function_decl|;
name|char
modifier|*
name|devname
decl_stmt|;
name|char
name|flags
decl_stmt|;
block|}
name|pd
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|EXAMPLE_PREDEFINE
if|#
directive|if
name|NSD
operator|>
literal|0
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|sdattach
block|,
literal|"sd"
block|,
literal|0
block|}
block|,
comment|/* define a disk at scsibus=0 dev=0 lu=0 */
endif|#
directive|endif
comment|/* NSD */
endif|#
directive|endif
comment|/* EXAMPLE_PREDEFINE */
block|{
literal|0
block|,
literal|9
block|,
literal|9
block|}
comment|/*illegal dummy end entry */
block|}
struct|;
end_struct

begin_comment
comment|/*  * The structure of known drivers for autoconfiguration  */
end_comment

begin_struct
struct|struct
name|scsidevs
block|{
name|u_int32
name|type
decl_stmt|;
name|boolean
name|removable
decl_stmt|;
name|char
modifier|*
name|manufacturer
decl_stmt|;
name|char
modifier|*
name|model
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|errval
function_decl|(
modifier|*
name|attach_rtn
function_decl|)
parameter_list|()
function_decl|;
name|char
modifier|*
name|devname
decl_stmt|;
name|char
name|flags
decl_stmt|;
comment|/* 1 show my comparisons during boot(debug) */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SC_SHOWME
value|0x01
end_define

begin_define
define|#
directive|define
name|SC_ONE_LU
value|0x00
end_define

begin_define
define|#
directive|define
name|SC_MORE_LUS
value|0x02
end_define

begin_if
if|#
directive|if
name|NUK
operator|>
literal|0
end_if

begin_decl_stmt
specifier|static
name|struct
name|scsidevs
name|unknowndev
init|=
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|"standard"
block|,
literal|"any"
block|,
literal|"any"
block|,
name|ukattach
block|,
literal|"uk"
block|,
name|SC_MORE_LUS
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*NUK*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsidevs
name|knowndevs
index|[]
init|=
block|{
if|#
directive|if
name|NSD
operator|>
literal|0
block|{
name|T_DIRECT
block|,
name|T_FIXED
block|,
literal|"standard"
block|,
literal|"any"
block|,
literal|"any"
block|,
name|sdattach
block|,
literal|"sd"
block|,
name|SC_ONE_LU
block|}
block|,
block|{
name|T_DIRECT
block|,
name|T_FIXED
block|,
literal|"MAXTOR  "
block|,
literal|"XT-4170S        "
block|,
literal|"B5A "
block|,
name|sdattach
block|,
literal|"mx1"
block|,
name|SC_ONE_LU
block|}
block|,
endif|#
directive|endif
comment|/* NSD */
if|#
directive|if
name|NST
operator|>
literal|0
block|{
name|T_SEQUENTIAL
block|,
name|T_REMOV
block|,
literal|"standard"
block|,
literal|"any"
block|,
literal|"any"
block|,
name|stattach
block|,
literal|"st"
block|,
name|SC_ONE_LU
block|}
block|,
endif|#
directive|endif
comment|/* NST */
if|#
directive|if
name|NCALS
operator|>
literal|0
block|{
name|T_PROCESSOR
block|,
name|T_FIXED
block|,
literal|"standard"
block|,
literal|"any"
block|,
literal|"any"
block|,
name|calsattach
block|,
literal|"cals"
block|,
name|SC_MORE_LUS
block|}
block|,
endif|#
directive|endif
comment|/* NCALS */
if|#
directive|if
name|NCH
operator|>
literal|0
block|{
name|T_CHANGER
block|,
name|T_REMOV
block|,
literal|"standard"
block|,
literal|"any"
block|,
literal|"any"
block|,
name|chattach
block|,
literal|"ch"
block|,
name|SC_ONE_LU
block|}
block|,
endif|#
directive|endif
comment|/* NCH */
if|#
directive|if
name|NCD
operator|>
literal|0
ifndef|#
directive|ifndef
name|UKTEST
comment|/* make cdroms unrecognised to test the uk driver */
block|{
name|T_READONLY
block|,
name|T_REMOV
block|,
literal|"SONY    "
block|,
literal|"CD-ROM CDU-8012 "
block|,
literal|"3.1a"
block|,
name|cdattach
block|,
literal|"cd"
block|,
name|SC_ONE_LU
block|}
block|,
block|{
name|T_READONLY
block|,
name|T_REMOV
block|,
literal|"PIONEER "
block|,
literal|"CD-ROM DRM-600  "
block|,
literal|"any"
block|,
name|cdattach
block|,
literal|"cd"
block|,
name|SC_MORE_LUS
block|}
block|,
endif|#
directive|endif
endif|#
directive|endif
comment|/* NCD */
if|#
directive|if
name|NBLL
operator|>
literal|0
block|{
name|T_PROCESSOR
block|,
name|T_FIXED
block|,
literal|"AEG     "
block|,
literal|"READER          "
block|,
literal|"V1.0"
block|,
name|bllattach
block|,
literal|"bll"
block|,
name|SC_MORE_LUS
block|}
block|,
endif|#
directive|endif
comment|/* NBLL */
if|#
directive|if
name|NKIL
operator|>
literal|0
block|{
name|T_SCANNER
block|,
name|T_FIXED
block|,
literal|"KODAK   "
block|,
literal|"IL Scanner 900  "
block|,
literal|"any"
block|,
name|kil_attach
block|,
literal|"kil"
block|,
name|SC_ONE_LU
block|}
block|,
endif|#
directive|endif
comment|/* NKIL */
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Declarations  */
end_comment

begin_function_decl
name|struct
name|predefined
modifier|*
name|scsi_get_predef
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|scsidevs
modifier|*
name|scsi_probedev
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|scsidevs
modifier|*
name|selectdev
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|errval
name|scsi_probe_bus
name|__P
argument_list|(
operator|(
name|int
name|bus
operator|,
name|int
name|targ
operator|,
name|int
name|lun
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scsi_device
name|probe_switch
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"probe"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * controls debug level within the scsi subsystem -  * see scsiconf.h for values  */
end_comment

begin_decl_stmt
name|int32
name|scsibus
init|=
literal|0x0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the Nth scsibus we've seen */
end_comment

begin_comment
comment|/*  * The routine called by the adapter boards to get all their  * devices configured in.  */
end_comment

begin_function
name|void
name|scsi_attachdevs
parameter_list|(
name|sc_link_proto
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link_proto
decl_stmt|;
block|{
if|if
condition|(
name|scsibus
operator|>=
name|NSCBUS
condition|)
block|{
name|printf
argument_list|(
literal|"too many scsi busses, reconfigure the kernel\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc_link_proto
operator|->
name|scsibus
operator|=
name|scsibus
expr_stmt|;
name|scbus_data
index|[
name|scsibus
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsibus_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scbus_data
index|[
name|scsibus
index|]
condition|)
block|{
name|panic
argument_list|(
literal|"scsi_attachdevs: malloc\n"
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|scbus_data
index|[
name|scsibus
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsibus_data
argument_list|)
argument_list|)
expr_stmt|;
name|scbus_data
index|[
name|scsibus
index|]
operator|->
name|adapter_link
operator|=
name|sc_link_proto
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCSI_DELAY
argument_list|)
operator|&&
name|SCSI_DELAY
operator|>
literal|2
name|printf
argument_list|(
literal|"%s%d waiting for scsi devices to settle\n"
argument_list|,
name|sc_link_proto
operator|->
name|adapter
operator|->
name|name
argument_list|,
name|sc_link_proto
operator|->
name|adapter_unit
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SCSI_DELAY> 2 */
undef|#
directive|undef
name|SCSI_DELAY
define|#
directive|define
name|SCSI_DELAY
value|2
endif|#
directive|endif
comment|/* SCSI_DELAY */
name|DELAY
argument_list|(
literal|1000000
operator|*
name|SCSI_DELAY
argument_list|)
expr_stmt|;
name|scsibus
operator|++
expr_stmt|;
name|scsi_probe_bus
argument_list|(
name|scsibus
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Probe the requested scsi bus. It must be already set up.  * -1 requests all set up scsi busses.  * targ and lun optionally narrow the search if not -1  */
end_comment

begin_function
name|errval
name|scsi_probe_busses
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|targ
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
if|if
condition|(
name|bus
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|bus
operator|<
name|scsibus
condition|;
name|bus
operator|++
control|)
block|{
name|scsi_probe_bus
argument_list|(
name|bus
argument_list|,
name|targ
argument_list|,
name|lun
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|scsi_probe_bus
argument_list|(
name|bus
argument_list|,
name|targ
argument_list|,
name|lun
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Probe the requested scsi bus. It must be already set up.  * targ and lun optionally narrow the search if not -1  */
end_comment

begin_function
name|errval
name|scsi_probe_bus
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|targ
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
name|struct
name|scsibus_data
modifier|*
name|scsi
decl_stmt|;
name|int
name|maxtarg
decl_stmt|,
name|mintarg
decl_stmt|,
name|maxlun
decl_stmt|,
name|minlun
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link_proto
decl_stmt|;
name|u_int8
name|scsi_addr
decl_stmt|;
name|struct
name|scsidevs
modifier|*
name|bestmatch
init|=
name|NULL
decl_stmt|;
name|struct
name|predefined
modifier|*
name|predef
init|=
name|NULL
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|NULL
decl_stmt|;
name|boolean
name|maybe_more
decl_stmt|;
if|if
condition|(
operator|(
name|bus
operator|<
literal|0
operator|)
operator|||
operator|(
name|bus
operator|>=
name|scsibus
operator|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|scsi
operator|=
name|scbus_data
index|[
name|bus
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|scsi
condition|)
return|return
name|ENXIO
return|;
name|sc_link_proto
operator|=
name|scsi
operator|->
name|adapter_link
expr_stmt|;
name|scsi_addr
operator|=
name|sc_link_proto
operator|->
name|adapter_targ
expr_stmt|;
if|if
condition|(
name|targ
operator|==
operator|-
literal|1
condition|)
block|{
name|maxtarg
operator|=
literal|7
expr_stmt|;
name|mintarg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|targ
operator|<
literal|0
operator|)
operator|||
operator|(
name|targ
operator|>
literal|7
operator|)
condition|)
return|return
name|EINVAL
return|;
name|maxtarg
operator|=
name|mintarg
operator|=
name|targ
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|==
operator|-
literal|1
condition|)
block|{
name|maxlun
operator|=
literal|7
expr_stmt|;
name|minlun
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|lun
operator|<
literal|0
operator|)
operator|||
operator|(
name|lun
operator|>
literal|7
operator|)
condition|)
return|return
name|EINVAL
return|;
name|maxlun
operator|=
name|minlun
operator|=
name|lun
expr_stmt|;
block|}
for|for
control|(
name|targ
operator|=
name|mintarg
init|;
name|targ
operator|<=
name|maxtarg
condition|;
name|targ
operator|++
control|)
block|{
name|maybe_more
operator|=
literal|0
expr_stmt|;
comment|/* by default only check 1 lun */
if|if
condition|(
name|targ
operator|==
name|scsi_addr
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|lun
operator|=
name|minlun
init|;
name|lun
operator|<=
name|maxlun
condition|;
name|lun
operator|++
control|)
block|{
comment|/* 			 * The spot appears to already have something 			 * linked in, skip past it. Must be doing a 'reprobe' 			 */
if|if
condition|(
name|scsi
operator|->
name|sc_link
index|[
name|targ
index|]
index|[
name|lun
index|]
condition|)
block|{
comment|/* don't do this one, but check other luns */
name|maybe_more
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * If we presently don't have a link block 			 * then allocate one to use while probing 			 */
if|if
condition|(
operator|!
name|sc_link
condition|)
block|{
name|sc_link
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc_link
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
operator|*
name|sc_link
operator|=
operator|*
name|sc_link_proto
expr_stmt|;
comment|/* struct copy */
name|sc_link
operator|->
name|opennings
operator|=
literal|1
expr_stmt|;
name|sc_link
operator|->
name|device
operator|=
operator|&
name|probe_switch
expr_stmt|;
block|}
name|sc_link
operator|->
name|target
operator|=
name|targ
expr_stmt|;
name|sc_link
operator|->
name|lun
operator|=
name|lun
expr_stmt|;
name|predef
operator|=
name|scsi_get_predef
argument_list|(
name|sc_link
argument_list|,
operator|&
name|maybe_more
argument_list|)
expr_stmt|;
name|bestmatch
operator|=
name|scsi_probedev
argument_list|(
name|sc_link
argument_list|,
operator|&
name|maybe_more
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bestmatch
operator|)
operator|&&
operator|(
name|predef
operator|)
condition|)
block|{
comment|/* both exist */
if|if
condition|(
name|bestmatch
operator|->
name|attach_rtn
operator|!=
name|predef
operator|->
name|attach_rtn
condition|)
block|{
name|printf
argument_list|(
literal|"Clash in found/expected devices\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|NUK
operator|>
literal|0
if|if
condition|(
name|bestmatch
operator|==
operator|&
name|unknowndev
condition|)
block|{
name|printf
argument_list|(
literal|"will link in PREDEFINED\n"
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|predef
operator|->
name|attach_rtn
operator|)
operator|)
operator|(
name|sc_link
operator|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/*NUK*/
block|{
name|printf
argument_list|(
literal|"will link in FOUND\n"
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|bestmatch
operator|->
name|attach_rtn
operator|)
operator|)
operator|(
name|sc_link
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
operator|*
operator|(
name|bestmatch
operator|->
name|attach_rtn
operator|)
operator|)
operator|(
name|sc_link
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|bestmatch
operator|)
operator|&&
operator|(
operator|!
name|predef
operator|)
condition|)
block|{
comment|/* just FOUND */
operator|(
operator|*
operator|(
name|bestmatch
operator|->
name|attach_rtn
operator|)
operator|)
operator|(
name|sc_link
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|bestmatch
operator|)
operator|&&
operator|(
name|predef
operator|)
condition|)
block|{
comment|/* just predef */
operator|(
operator|*
operator|(
name|predef
operator|->
name|attach_rtn
operator|)
operator|)
operator|(
name|sc_link
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bestmatch
operator|)
operator|||
operator|(
name|predef
operator|)
condition|)
block|{
comment|/* one exists */
name|scsi
operator|->
name|sc_link
index|[
name|targ
index|]
index|[
name|lun
index|]
operator|=
name|sc_link
expr_stmt|;
name|sc_link
operator|=
name|NULL
expr_stmt|;
comment|/* it's been used */
block|}
if|if
condition|(
operator|!
operator|(
name|maybe_more
operator|)
condition|)
block|{
comment|/* nothing suggests we'll find more */
break|break;
comment|/* nothing here, skip to next targ */
block|}
comment|/* otherwise something says we should look further */
block|}
block|}
if|if
condition|(
name|sc_link
condition|)
block|{
name|free
argument_list|(
name|sc_link
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * given a target and lu, check if there is a predefined device for  * that address  */
end_comment

begin_function
name|struct
name|predefined
modifier|*
name|scsi_get_predef
parameter_list|(
name|sc_link
parameter_list|,
name|maybe_more
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|boolean
modifier|*
name|maybe_more
decl_stmt|;
block|{
name|u_int8
name|unit
init|=
name|sc_link
operator|->
name|scsibus
decl_stmt|;
name|u_int8
name|target
init|=
name|sc_link
operator|->
name|target
decl_stmt|;
name|u_int8
name|lu
init|=
name|sc_link
operator|->
name|lun
decl_stmt|;
name|struct
name|scsi_adapter
modifier|*
name|scsi_adapter
init|=
name|sc_link
operator|->
name|adapter
decl_stmt|;
name|u_int32
name|upto
decl_stmt|,
name|numents
decl_stmt|;
name|numents
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|pd
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|predefined
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|upto
operator|=
literal|0
init|;
name|upto
operator|<
name|numents
condition|;
name|upto
operator|++
control|)
block|{
if|if
condition|(
name|pd
index|[
name|upto
index|]
operator|.
name|scsibus
operator|!=
name|unit
condition|)
continue|continue;
if|if
condition|(
name|pd
index|[
name|upto
index|]
operator|.
name|dev
operator|!=
name|target
condition|)
continue|continue;
if|if
condition|(
name|pd
index|[
name|upto
index|]
operator|.
name|lu
operator|!=
name|lu
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%s%d targ %d lun %d:<%s> - PRECONFIGURED -\n"
argument_list|,
name|scsi_adapter
operator|->
name|name
argument_list|,
name|unit
argument_list|,
name|target
argument_list|,
name|lu
argument_list|,
name|pd
index|[
name|upto
index|]
operator|.
name|devname
argument_list|)
expr_stmt|;
operator|*
name|maybe_more
operator|=
name|pd
index|[
name|upto
index|]
operator|.
name|flags
operator|&
name|SC_MORE_LUS
expr_stmt|;
return|return
operator|(
operator|&
operator|(
name|pd
index|[
name|upto
index|]
operator|)
operator|)
return|;
block|}
return|return
operator|(
operator|(
expr|struct
name|predefined
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * given a target and lu, ask the device what  * it is, and find the correct driver table  * entry.  */
end_comment

begin_function
name|struct
name|scsidevs
modifier|*
name|scsi_probedev
parameter_list|(
name|sc_link
parameter_list|,
name|maybe_more
parameter_list|)
name|boolean
modifier|*
name|maybe_more
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
block|{
name|u_int8
name|unit
init|=
name|sc_link
operator|->
name|adapter_unit
decl_stmt|;
name|u_int8
name|target
init|=
name|sc_link
operator|->
name|target
decl_stmt|;
name|u_int8
name|lu
init|=
name|sc_link
operator|->
name|lun
decl_stmt|;
name|struct
name|scsi_adapter
modifier|*
name|scsi_adapter
init|=
name|sc_link
operator|->
name|adapter
decl_stmt|;
name|struct
name|scsidevs
modifier|*
name|bestmatch
init|=
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
decl_stmt|;
name|char
modifier|*
name|dtype
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|,
modifier|*
name|desc
decl_stmt|;
name|char
modifier|*
name|qtype
decl_stmt|;
specifier|static
name|struct
name|scsi_inquiry_data
name|inqbuf
decl_stmt|;
name|u_int32
name|len
decl_stmt|,
name|qualifier
decl_stmt|,
name|type
decl_stmt|;
name|boolean
name|remov
decl_stmt|;
name|char
name|manu
index|[
literal|32
index|]
decl_stmt|;
name|char
name|model
index|[
literal|32
index|]
decl_stmt|;
name|char
name|version
index|[
literal|32
index|]
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|inqbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|inqbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Ask the device what it is 	 */
ifdef|#
directive|ifdef
name|SCSIDEBUG
if|if
condition|(
operator|(
name|target
operator|==
name|DEBUGTARG
operator|)
operator|&&
operator|(
name|lu
operator|==
name|DEBUGLUN
operator|)
condition|)
name|sc_link
operator|->
name|flags
operator||=
operator|(
name|DEBUGLEVEL
operator|)
expr_stmt|;
else|else
name|sc_link
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SDEV_DB1
operator||
name|SDEV_DB2
operator||
name|SDEV_DB3
operator||
name|SDEV_DB4
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* SCSIDEBUG */
comment|/* catch unit attn */
name|scsi_test_unit_ready
argument_list|(
name|sc_link
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DOUBTFULL
switch|switch
condition|(
name|scsi_test_unit_ready
argument_list|(
name|sc_link
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* said it WAS ready */
case|case
name|EBUSY
case|:
comment|/* replied 'NOT READY' but WAS present, continue */
case|case
name|ENXIO
case|:
break|break;
case|case
name|EIO
case|:
comment|/* device timed out */
case|case
name|EINVAL
case|:
comment|/* Lun not supported */
default|default:
return|return
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
return|;
block|}
endif|#
directive|endif
comment|/*DOUBTFULL*/
ifdef|#
directive|ifdef
name|SCSI_2_DEF
comment|/* some devices need to be told to go to SCSI2 */
comment|/* However some just explode if you tell them this.. leave it out */
name|scsi_change_def
argument_list|(
name|sc_link
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*SCSI_2_DEF */
comment|/* Now go ask the device all about itself */
if|if
condition|(
name|scsi_inquire
argument_list|(
name|sc_link
argument_list|,
operator|&
name|inqbuf
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
return|;
block|}
comment|/* 	 * note what BASIC type of device it is 	 */
name|type
operator|=
name|inqbuf
operator|.
name|device
operator|&
name|SID_TYPE
expr_stmt|;
name|qualifier
operator|=
name|inqbuf
operator|.
name|device
operator|&
name|SID_QUAL
expr_stmt|;
name|remov
operator|=
name|inqbuf
operator|.
name|dev_qual2
operator|&
name|SID_REMOVABLE
expr_stmt|;
comment|/* 	 * Any device qualifier that has the top bit set (qualifier&4 != 0) 	 * is vendor specific and won't match in this switch. 	 */
switch|switch
condition|(
operator|(
name|int
operator|)
name|qualifier
condition|)
block|{
case|case
name|SID_QUAL_LU_OK
case|:
name|qtype
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|SID_QUAL_LU_OFFLINE
case|:
name|qtype
operator|=
literal|", Unit not Connected!"
expr_stmt|;
break|break;
case|case
name|SID_QUAL_RSVD
case|:
name|qtype
operator|=
literal|", Reserved Peripheral Qualifier!"
expr_stmt|;
operator|*
name|maybe_more
operator|=
literal|1
expr_stmt|;
return|return
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
return|;
break|break;
case|case
name|SID_QUAL_BAD_LU
case|:
comment|/* 		 * Check for a non-existent unit.  If the device is returning 		 * this much, then we must set the flag that has 		 * the searchers keep looking on other luns. 		 */
name|qtype
operator|=
literal|", The Target can't support this Unit!"
expr_stmt|;
operator|*
name|maybe_more
operator|=
literal|1
expr_stmt|;
return|return
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
return|;
default|default:
name|dtype
operator|=
literal|"vendor specific"
expr_stmt|;
name|qtype
operator|=
literal|""
expr_stmt|;
operator|*
name|maybe_more
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dtype
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|type
condition|)
block|{
case|case
name|T_DIRECT
case|:
name|dtype
operator|=
literal|"direct"
expr_stmt|;
break|break;
case|case
name|T_SEQUENTIAL
case|:
name|dtype
operator|=
literal|"sequential"
expr_stmt|;
break|break;
case|case
name|T_PRINTER
case|:
name|dtype
operator|=
literal|"printer"
expr_stmt|;
break|break;
case|case
name|T_PROCESSOR
case|:
name|dtype
operator|=
literal|"processor"
expr_stmt|;
break|break;
case|case
name|T_READONLY
case|:
name|dtype
operator|=
literal|"readonly"
expr_stmt|;
break|break;
case|case
name|T_WORM
case|:
name|dtype
operator|=
literal|"worm"
expr_stmt|;
break|break;
case|case
name|T_SCANNER
case|:
name|dtype
operator|=
literal|"scanner"
expr_stmt|;
break|break;
case|case
name|T_OPTICAL
case|:
name|dtype
operator|=
literal|"optical"
expr_stmt|;
break|break;
case|case
name|T_CHANGER
case|:
name|dtype
operator|=
literal|"changer"
expr_stmt|;
break|break;
case|case
name|T_COMM
case|:
name|dtype
operator|=
literal|"communication"
expr_stmt|;
break|break;
case|case
name|T_NODEVICE
case|:
operator|*
name|maybe_more
operator|=
literal|1
expr_stmt|;
return|return
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
return|;
default|default:
name|dtype
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Then if it's advanced enough, more detailed 	 * information 	 */
if|if
condition|(
operator|(
name|inqbuf
operator|.
name|version
operator|&
name|SID_ANSII
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|inqbuf
operator|.
name|additional_length
operator|+
operator|(
operator|(
name|char
operator|*
operator|)
name|inqbuf
operator|.
name|unused
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|inqbuf
operator|)
operator|)
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
operator|-
literal|1
operator|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
operator|-
literal|1
expr_stmt|;
name|desc
operator|=
name|inqbuf
operator|.
name|vendor
expr_stmt|;
name|desc
index|[
name|len
operator|-
operator|(
name|desc
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|inqbuf
operator|)
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|manu
argument_list|,
name|inqbuf
operator|.
name|vendor
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|manu
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|model
argument_list|,
name|inqbuf
operator|.
name|product
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|model
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|version
argument_list|,
name|inqbuf
operator|.
name|revision
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|version
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* 		 * If not advanced enough, use default values 		 */
block|{
name|desc
operator|=
literal|"early protocol device"
expr_stmt|;
name|strncpy
argument_list|(
name|manu
argument_list|,
literal|"unknown"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|model
argument_list|,
literal|"unknown"
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|version
argument_list|,
literal|"????"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s%d targ %d lun %d: type %d(%s) %s SCSI%d\n"
argument_list|,
name|scsi_adapter
operator|->
name|name
argument_list|,
name|unit
argument_list|,
name|target
argument_list|,
name|lu
argument_list|,
name|type
argument_list|,
name|dtype
argument_list|,
name|remov
condition|?
literal|"removable"
else|:
literal|"fixed"
argument_list|,
name|inqbuf
operator|.
name|version
operator|&
name|SID_ANSII
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d targ %d lun %d:<%s%s%s>\n"
argument_list|,
name|scsi_adapter
operator|->
name|name
argument_list|,
name|unit
argument_list|,
name|target
argument_list|,
name|lu
argument_list|,
name|manu
argument_list|,
name|model
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtype
index|[
literal|0
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d targ %d lun %d: qualifier %d(%s)\n"
argument_list|,
name|scsi_adapter
operator|->
name|name
argument_list|,
name|unit
argument_list|,
name|target
argument_list|,
name|lu
argument_list|,
name|qualifier
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Try make as good a match as possible with 	 * available sub drivers        	 */
name|bestmatch
operator|=
operator|(
name|selectdev
argument_list|(
name|qualifier
argument_list|,
name|type
argument_list|,
name|remov
condition|?
name|T_REMOV
else|:
name|T_FIXED
argument_list|,
name|manu
argument_list|,
name|model
argument_list|,
name|version
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bestmatch
operator|)
operator|&&
operator|(
name|bestmatch
operator|->
name|flags
operator|&
name|SC_MORE_LUS
operator|)
condition|)
block|{
operator|*
name|maybe_more
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|bestmatch
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try make as good a match as possible with  * available sub drivers         */
end_comment

begin_function
name|struct
name|scsidevs
modifier|*
name|selectdev
parameter_list|(
name|qualifier
parameter_list|,
name|type
parameter_list|,
name|remov
parameter_list|,
name|manu
parameter_list|,
name|model
parameter_list|,
name|rev
parameter_list|)
name|u_int32
name|qualifier
decl_stmt|,
name|type
decl_stmt|;
name|boolean
name|remov
decl_stmt|;
name|char
modifier|*
name|manu
decl_stmt|,
decl|*
name|model
decl_stmt|,
modifier|*
name|rev
decl_stmt|;
end_function

begin_block
block|{
name|u_int32
name|numents
init|=
operator|(
sizeof|sizeof
argument_list|(
name|knowndevs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|scsidevs
argument_list|)
operator|)
operator|-
literal|1
decl_stmt|;
name|u_int32
name|count
init|=
literal|0
decl_stmt|;
name|u_int32
name|bestmatches
init|=
literal|0
decl_stmt|;
name|struct
name|scsidevs
modifier|*
name|bestmatch
init|=
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|scsidevs
modifier|*
name|thisentry
init|=
name|knowndevs
decl_stmt|;
name|type
operator||=
name|qualifier
expr_stmt|;
comment|/* why? */
name|thisentry
operator|--
expr_stmt|;
while|while
condition|(
name|count
operator|++
operator|<
name|numents
condition|)
block|{
name|thisentry
operator|++
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|thisentry
operator|->
name|type
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|bestmatches
operator|<
literal|1
condition|)
block|{
name|bestmatches
operator|=
literal|1
expr_stmt|;
name|bestmatch
operator|=
name|thisentry
expr_stmt|;
block|}
if|if
condition|(
name|remov
operator|!=
name|thisentry
operator|->
name|removable
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|bestmatches
operator|<
literal|2
condition|)
block|{
name|bestmatches
operator|=
literal|2
expr_stmt|;
name|bestmatch
operator|=
name|thisentry
expr_stmt|;
block|}
if|if
condition|(
name|thisentry
operator|->
name|flags
operator|&
name|SC_SHOWME
condition|)
name|printf
argument_list|(
literal|"\n%s-\n%s-"
argument_list|,
name|thisentry
operator|->
name|manufacturer
argument_list|,
name|manu
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|thisentry
operator|->
name|manufacturer
argument_list|,
name|manu
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|bestmatches
operator|<
literal|3
condition|)
block|{
name|bestmatches
operator|=
literal|3
expr_stmt|;
name|bestmatch
operator|=
name|thisentry
expr_stmt|;
block|}
if|if
condition|(
name|thisentry
operator|->
name|flags
operator|&
name|SC_SHOWME
condition|)
name|printf
argument_list|(
literal|"\n%s-\n%s-"
argument_list|,
name|thisentry
operator|->
name|model
argument_list|,
name|model
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|thisentry
operator|->
name|model
argument_list|,
name|model
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|bestmatches
operator|<
literal|4
condition|)
block|{
name|bestmatches
operator|=
literal|4
expr_stmt|;
name|bestmatch
operator|=
name|thisentry
expr_stmt|;
block|}
if|if
condition|(
name|thisentry
operator|->
name|flags
operator|&
name|SC_SHOWME
condition|)
name|printf
argument_list|(
literal|"\n%s-\n%s-"
argument_list|,
name|thisentry
operator|->
name|version
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|thisentry
operator|->
name|version
argument_list|,
name|rev
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|bestmatches
operator|<
literal|5
condition|)
block|{
name|bestmatches
operator|=
literal|5
expr_stmt|;
name|bestmatch
operator|=
name|thisentry
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bestmatch
operator|==
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
condition|)
block|{
if|#
directive|if
name|NUK
operator|>
literal|0
name|bestmatch
operator|=
operator|&
name|unknowndev
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"No explicit device driver match.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|bestmatch
operator|)
return|;
block|}
end_block

end_unit

