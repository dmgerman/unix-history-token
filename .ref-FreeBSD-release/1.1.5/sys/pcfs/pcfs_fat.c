begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Written by Paul Popelka (paulp@uts.amdahl.com)  *  *  You can do anything you want with this software,  *    just don't say you wrote it,  *    and don't remove this notice.  *  *  This software is provided "as is".  *  *  The author supplies this software to be publicly  *  redistributed on the understanding that the author  *  is not responsible for the correct functioning of  *  this software in any circumstances and is not liable  *  for any damages caused by this software.  *  *  October 1992  *  *	$Id: pcfs_fat.c,v 1.3 1993/11/25 01:37:11 wollman Exp $  */
end_comment

begin_comment
comment|/*  *  kernel include files.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"namei.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_comment
comment|/* to define statfs structure */
end_comment

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_comment
comment|/* to define vattr structure */
end_comment

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_comment
comment|/*  *  pcfs include files.  */
end_comment

begin_include
include|#
directive|include
file|"bpb.h"
end_include

begin_include
include|#
directive|include
file|"pcfsmount.h"
end_include

begin_include
include|#
directive|include
file|"direntry.h"
end_include

begin_include
include|#
directive|include
file|"denode.h"
end_include

begin_include
include|#
directive|include
file|"fat.h"
end_include

begin_function_decl
specifier|static
name|void
name|fc_lookup
parameter_list|(
name|struct
name|denode
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|u_long
modifier|*
parameter_list|,
name|u_long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *  Fat cache stats.  */
end_comment

begin_decl_stmt
name|int
name|fc_fileextends
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of file extends			*/
end_comment

begin_decl_stmt
name|int
name|fc_lfcempty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of time last file cluster cache entry 				 * was empty */
end_comment

begin_decl_stmt
name|int
name|fc_bmapcalls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of times pcbmap was called		*/
end_comment

begin_define
define|#
directive|define
name|LMMAX
value|20
end_define

begin_decl_stmt
name|int
name|fc_lmdistance
index|[
name|LMMAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* counters for how far off the last cluster 				 * mapped entry was. */
end_comment

begin_decl_stmt
name|int
name|fc_largedistance
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* off by more than LMMAX		*/
end_comment

begin_comment
comment|/* Byte offset in FAT on filesystem pmp, cluster cn */
end_comment

begin_define
define|#
directive|define
name|FATOFS
parameter_list|(
name|pmp
parameter_list|,
name|cn
parameter_list|)
value|(FAT12(pmp) ? (cn) * 3 / 2 : (cn) * 2)
end_define

begin_function
specifier|static
name|void
name|fatblock
parameter_list|(
name|pmp
parameter_list|,
name|ofs
parameter_list|,
name|bnp
parameter_list|,
name|sizep
parameter_list|,
name|bop
parameter_list|)
name|struct
name|pcfsmount
modifier|*
name|pmp
decl_stmt|;
name|u_long
name|ofs
decl_stmt|;
name|u_long
modifier|*
name|bnp
decl_stmt|;
name|u_long
modifier|*
name|sizep
decl_stmt|;
name|u_long
modifier|*
name|bop
decl_stmt|;
block|{
name|u_long
name|bn
decl_stmt|,
name|size
decl_stmt|;
name|bn
operator|=
name|ofs
operator|/
name|pmp
operator|->
name|pm_fatblocksize
operator|*
name|pmp
operator|->
name|pm_fatblocksec
expr_stmt|;
name|size
operator|=
name|min
argument_list|(
name|pmp
operator|->
name|pm_fatblocksec
argument_list|,
name|pmp
operator|->
name|pm_FATsecs
operator|-
name|bn
argument_list|)
operator|*
name|pmp
operator|->
name|pm_BytesPerSec
expr_stmt|;
name|bn
operator|+=
name|pmp
operator|->
name|pm_fatblk
expr_stmt|;
if|if
condition|(
name|bnp
condition|)
operator|*
name|bnp
operator|=
name|bn
expr_stmt|;
if|if
condition|(
name|sizep
condition|)
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|bop
condition|)
operator|*
name|bop
operator|=
name|ofs
operator|%
name|pmp
operator|->
name|pm_fatblocksize
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Map the logical cluster number of a file into  *  a physical disk sector that is filesystem relative.  *  dep - address of denode representing the file of interest  *  findcn - file relative cluster whose filesystem relative  *    cluster number and/or block number are/is to be found  *  bnp - address of where to place the file system relative  *    block number.  If this pointer is null then don't return  *    this quantity.  *  cnp - address of where to place the file system relative  *    cluster number.  If this pointer is null then don't return  *    this quantity.  *  NOTE:  *    Either bnp or cnp must be non-null.  *    This function has one side effect.  If the requested  *    file relative cluster is beyond the end of file, then  *    the actual number of clusters in the file is returned  *    in *cnp.  This is useful for determining how long a  *    directory is.  If cnp is null, nothing is returned.  */
end_comment

begin_function
name|int
name|pcbmap
parameter_list|(
name|dep
parameter_list|,
name|findcn
parameter_list|,
name|bnp
parameter_list|,
name|cnp
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|u_long
name|findcn
decl_stmt|;
comment|/* file relative cluster to get		*/
name|daddr_t
modifier|*
name|bnp
decl_stmt|;
comment|/* returned filesys relative blk number	*/
name|u_long
modifier|*
name|cnp
decl_stmt|;
comment|/* returned cluster number		*/
block|{
name|int
name|error
decl_stmt|;
name|u_long
name|i
decl_stmt|;
name|u_long
name|cn
decl_stmt|;
name|u_long
name|prevcn
init|=
literal|0
decl_stmt|;
name|u_long
name|byteoffset
decl_stmt|;
name|u_long
name|bn
decl_stmt|;
name|u_long
name|bo
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|u_long
name|bp_bn
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|pcfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|u_long
name|bsize
decl_stmt|;
name|int
name|fat12
init|=
name|FAT12
argument_list|(
name|pmp
argument_list|)
decl_stmt|;
comment|/* 12 bit fat	*/
name|fc_bmapcalls
operator|++
expr_stmt|;
comment|/*  *  If they don't give us someplace to return a value  *  then don't bother doing anything.  */
if|if
condition|(
name|bnp
operator|==
name|NULL
operator|&&
name|cnp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|cn
operator|=
name|dep
operator|->
name|de_StartCluster
expr_stmt|;
comment|/*  *  The "file" that makes up the root directory is contiguous,  *  permanently allocated, of fixed size, and is not made up  *  of clusters.  If the cluster number is beyond the end of  *  the root directory, then return the number of clusters in  *  the file.  */
if|if
condition|(
name|cn
operator|==
name|PCFSROOT
condition|)
block|{
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
if|if
condition|(
name|findcn
operator|*
name|pmp
operator|->
name|pm_SectPerClust
operator|>
name|pmp
operator|->
name|pm_rootdirsize
condition|)
block|{
if|if
condition|(
name|cnp
condition|)
operator|*
name|cnp
operator|=
name|pmp
operator|->
name|pm_rootdirsize
operator|/
name|pmp
operator|->
name|pm_SectPerClust
expr_stmt|;
return|return
name|E2BIG
return|;
block|}
if|if
condition|(
name|bnp
condition|)
operator|*
name|bnp
operator|=
name|pmp
operator|->
name|pm_rootdirblk
operator|+
operator|(
name|findcn
operator|*
name|pmp
operator|->
name|pm_SectPerClust
operator|)
expr_stmt|;
if|if
condition|(
name|cnp
condition|)
operator|*
name|cnp
operator|=
name|PCFSROOT
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* just an empty file */
if|if
condition|(
name|cnp
condition|)
operator|*
name|cnp
operator|=
literal|0
expr_stmt|;
return|return
name|E2BIG
return|;
block|}
block|}
comment|/*  *  Rummage around in the fat cache, maybe we can avoid  *  tromping thru every fat entry for the file.  *  And, keep track of how far off the cache was from  *  where we wanted to be.  */
name|i
operator|=
literal|0
expr_stmt|;
name|fc_lookup
argument_list|(
name|dep
argument_list|,
name|findcn
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bn
operator|=
name|findcn
operator|-
name|i
operator|)
operator|>=
name|LMMAX
condition|)
name|fc_largedistance
operator|++
expr_stmt|;
else|else
name|fc_lmdistance
index|[
name|bn
index|]
operator|++
expr_stmt|;
comment|/*  *  Handle all other files or directories the normal way.  */
for|for
control|(
init|;
name|i
operator|<
name|findcn
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|PCFSEOF
argument_list|(
name|cn
argument_list|)
condition|)
goto|goto
name|hiteof
goto|;
name|byteoffset
operator|=
name|FATOFS
argument_list|(
name|pmp
argument_list|,
name|cn
argument_list|)
expr_stmt|;
name|fatblock
argument_list|(
name|pmp
argument_list|,
name|byteoffset
argument_list|,
operator|&
name|bn
argument_list|,
operator|&
name|bsize
argument_list|,
operator|&
name|bo
argument_list|)
expr_stmt|;
if|if
condition|(
name|bn
operator|!=
name|bp_bn
condition|)
block|{
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|bp_bn
operator|=
name|bn
expr_stmt|;
block|}
name|prevcn
operator|=
name|cn
expr_stmt|;
name|cn
operator|=
name|getushort
argument_list|(
operator|&
name|bp
operator|->
name|b_un
operator|.
name|b_addr
index|[
name|bo
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fat12
condition|)
block|{
if|if
condition|(
name|prevcn
operator|&
literal|1
condition|)
name|cn
operator|>>=
literal|4
expr_stmt|;
name|cn
operator|&=
literal|0x0fff
expr_stmt|;
comment|/*  *  Force the special cluster numbers in the range  *  0x0ff0-0x0fff to be the same as for 16 bit cluster  *  numbers to let the rest of pcfs think it is always  *  dealing with 16 bit fats.  */
if|if
condition|(
operator|(
name|cn
operator|&
literal|0x0ff0
operator|)
operator|==
literal|0x0ff0
condition|)
name|cn
operator||=
literal|0xf000
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|PCFSEOF
argument_list|(
name|cn
argument_list|)
condition|)
block|{
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bnp
condition|)
operator|*
name|bnp
operator|=
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnp
condition|)
operator|*
name|cnp
operator|=
name|cn
expr_stmt|;
name|fc_setcache
argument_list|(
name|dep
argument_list|,
name|FC_LASTMAP
argument_list|,
name|i
argument_list|,
name|cn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|hiteof
label|:
empty_stmt|;
if|if
condition|(
name|cnp
condition|)
operator|*
name|cnp
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* update last file cluster entry in the fat cache */
name|fc_setcache
argument_list|(
name|dep
argument_list|,
name|FC_LASTFC
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|prevcn
argument_list|)
expr_stmt|;
return|return
name|E2BIG
return|;
block|}
end_function

begin_comment
comment|/*  *  Find the closest entry in the fat cache to the  *  cluster we are looking for.  */
end_comment

begin_function
specifier|static
name|void
name|fc_lookup
parameter_list|(
name|dep
parameter_list|,
name|findcn
parameter_list|,
name|frcnp
parameter_list|,
name|fsrcnp
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|u_long
name|findcn
decl_stmt|;
name|u_long
modifier|*
name|frcnp
decl_stmt|;
name|u_long
modifier|*
name|fsrcnp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_long
name|cn
decl_stmt|;
name|struct
name|fatcache
modifier|*
name|closest
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FC_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|cn
operator|=
name|dep
operator|->
name|de_fc
index|[
name|i
index|]
operator|.
name|fc_frcn
expr_stmt|;
if|if
condition|(
name|cn
operator|!=
name|FCE_EMPTY
operator|&&
name|cn
operator|<=
name|findcn
condition|)
block|{
if|if
condition|(
name|closest
operator|==
literal|0
operator|||
name|cn
operator|>
name|closest
operator|->
name|fc_frcn
condition|)
name|closest
operator|=
operator|&
name|dep
operator|->
name|de_fc
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|closest
condition|)
block|{
operator|*
name|frcnp
operator|=
name|closest
operator|->
name|fc_frcn
expr_stmt|;
operator|*
name|fsrcnp
operator|=
name|closest
operator|->
name|fc_fsrcn
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  Purge the fat cache in denode dep of all entries  *  relating to file relative cluster frcn and beyond.  */
end_comment

begin_function
name|void
name|fc_purge
parameter_list|(
name|dep
parameter_list|,
name|frcn
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|u_int
name|frcn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|fatcache
modifier|*
name|fcp
decl_stmt|;
name|fcp
operator|=
name|dep
operator|->
name|de_fc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FC_SIZE
condition|;
name|i
operator|++
operator|,
name|fcp
operator|++
control|)
block|{
if|if
condition|(
name|fcp
operator|->
name|fc_frcn
operator|!=
name|FCE_EMPTY
operator|&&
name|fcp
operator|->
name|fc_frcn
operator|>=
name|frcn
condition|)
name|fcp
operator|->
name|fc_frcn
operator|=
name|FCE_EMPTY
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  Once the first fat is updated the other copies of  *  the fat must also be updated.  This function does  *  this.  *  pmp - pcfsmount structure for filesystem to update  *  bp - addr of modified fat block  *  fatbn - block number relative to begin of filesystem  *    of the modified fat block.  */
end_comment

begin_function
name|void
name|updateotherfats
parameter_list|(
name|pmp
parameter_list|,
name|bp
parameter_list|,
name|fatbn
parameter_list|)
name|struct
name|pcfsmount
modifier|*
name|pmp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|u_long
name|fatbn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|buf
modifier|*
name|bpn
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PCFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"updateotherfats(pmp %08x, bp %08x, fatbn %d)\n"
argument_list|,
name|pmp
argument_list|,
name|bp
argument_list|,
name|fatbn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(PCFSDEBUG) */
comment|/*  *  Now copy the block(s) of the modified fat to the other  *  copies of the fat and write them out.  This is faster  *  than reading in the other fats and then writing them  *  back out.  This could tie up the fat for quite a while.  *  Preventing others from accessing it.  To prevent us  *  from going after the fat quite so much we use delayed  *  writes, unless they specfied "synchronous" when the  *  filesystem was mounted.  If synch is asked for then  *  use bwrite()'s and really slow things down.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|pmp
operator|->
name|pm_FATs
condition|;
name|i
operator|++
control|)
block|{
name|fatbn
operator|+=
name|pmp
operator|->
name|pm_FATsecs
expr_stmt|;
comment|/* getblk() never fails */
name|bpn
operator|=
name|getblk
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|fatbn
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bpn
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmp
operator|->
name|pm_waitonfat
condition|)
name|bwrite
argument_list|(
name|bpn
argument_list|)
expr_stmt|;
else|else
name|bdwrite
argument_list|(
name|bpn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  Updating entries in 12 bit fats is a pain in the butt.  *  *  The following picture shows where nibbles go when  *  moving from a 12 bit cluster number into the appropriate  *  bytes in the FAT.  *  *      byte m        byte m+1      byte m+2  *    +----+----+   +----+----+   +----+----+  *    |  0    1 |   |  2    3 |   |  4    5 |   FAT bytes  *    +----+----+   +----+----+   +----+----+  *  *       +----+----+----+ +----+----+----+  *       |  3    0    1 | |  4    5    2 |  *       +----+----+----+ +----+----+----+  *         cluster n        cluster n+1  *  *    Where n is even.  *    m = n + (n>> 2)  *  *	(Function no longer used)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_define
define|#
directive|define
name|inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|void
name|usemap_alloc
parameter_list|(
name|pmp
parameter_list|,
name|cn
parameter_list|)
name|struct
name|pcfsmount
modifier|*
name|pmp
decl_stmt|;
name|u_long
name|cn
decl_stmt|;
block|{
name|pmp
operator|->
name|pm_inusemap
index|[
name|cn
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
name|cn
operator|%
literal|8
operator|)
expr_stmt|;
name|pmp
operator|->
name|pm_freeclustercount
operator|--
expr_stmt|;
comment|/* This assumes that the lowest available cluster was allocated */
name|pmp
operator|->
name|pm_lookhere
operator|=
name|cn
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|usemap_free
parameter_list|(
name|pmp
parameter_list|,
name|cn
parameter_list|)
name|struct
name|pcfsmount
modifier|*
name|pmp
decl_stmt|;
name|u_long
name|cn
decl_stmt|;
block|{
name|pmp
operator|->
name|pm_freeclustercount
operator|++
expr_stmt|;
name|pmp
operator|->
name|pm_inusemap
index|[
name|cn
operator|/
literal|8
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|cn
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|pmp
operator|->
name|pm_lookhere
operator|>
name|cn
condition|)
name|pmp
operator|->
name|pm_lookhere
operator|=
name|cn
expr_stmt|;
block|}
end_function

begin_function
name|int
name|clusterfree
parameter_list|(
name|pmp
parameter_list|,
name|cluster
parameter_list|,
name|oldcnp
parameter_list|)
name|struct
name|pcfsmount
modifier|*
name|pmp
decl_stmt|;
name|u_long
name|cluster
decl_stmt|;
name|u_long
modifier|*
name|oldcnp
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|u_long
name|oldcn
decl_stmt|;
name|error
operator|=
name|fatentry
argument_list|(
name|FAT_GET_AND_SET
argument_list|,
name|pmp
argument_list|,
name|cluster
argument_list|,
operator|&
name|oldcn
argument_list|,
name|PCFSFREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/*  *  If the cluster was successfully marked free, then update the count of  *  free clusters, and turn off the "allocated" bit in the  *  "in use" cluster bit map.  */
name|usemap_free
argument_list|(
name|pmp
argument_list|,
name|cluster
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldcnp
condition|)
operator|*
name|oldcnp
operator|=
name|oldcn
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  *  Get or Set or 'Get and Set' the cluster'th entry in the  *  fat.  *  function - whether to get or set a fat entry  *  pmp - address of the pcfsmount structure for the  *    filesystem whose fat is to be manipulated.  *  cluster - which cluster is of interest  *  oldcontents - address of a word that is to receive  *    the contents of the cluster'th entry if this is  *    a get function  *  newcontents - the new value to be written into the  *    cluster'th element of the fat if this is a set  *    function.  *  *  This function can also be used to free a cluster  *  by setting the fat entry for a cluster to 0.  *  *  All copies of the fat are updated if this is a set  *  function.  *  NOTE:  *    If fatentry() marks a cluster as free it does not  *    update the inusemap in the pcfsmount structure.  *    This is left to the caller.  */
end_comment

begin_function
name|int
name|fatentry
parameter_list|(
name|function
parameter_list|,
name|pmp
parameter_list|,
name|cn
parameter_list|,
name|oldcontents
parameter_list|,
name|newcontents
parameter_list|)
name|int
name|function
decl_stmt|;
name|struct
name|pcfsmount
modifier|*
name|pmp
decl_stmt|;
name|u_long
name|cn
decl_stmt|;
name|u_long
modifier|*
name|oldcontents
decl_stmt|;
name|u_long
name|newcontents
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|u_long
name|readcn
decl_stmt|;
name|u_long
name|bn
decl_stmt|,
name|bo
decl_stmt|,
name|bsize
decl_stmt|,
name|byteoffset
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/*printf("fatentry(func %d, pmp %08x, clust %d, oldcon %08x, newcon %d)\n", 	function, pmp, cluster, oldcontents, newcontents);*/
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/*  *  Be sure they asked us to do something.  */
if|if
condition|(
operator|(
name|function
operator|&
operator|(
name|FAT_SET
operator||
name|FAT_GET
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"fatentry(): function code doesn't specify get or set\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/*  *  If they asked us to return a cluster number  *  but didn't tell us where to put it, give them  *  an error.  */
if|if
condition|(
operator|(
name|function
operator|&
name|FAT_GET
operator|)
operator|&&
name|oldcontents
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"fatentry(): get function with no place to put result\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
endif|#
directive|endif
comment|/*  *  Be sure the requested cluster is in the filesystem.  */
if|if
condition|(
name|cn
operator|<
name|CLUST_FIRST
operator|||
name|cn
operator|>
name|pmp
operator|->
name|pm_maxcluster
condition|)
return|return
name|EINVAL
return|;
name|byteoffset
operator|=
name|FATOFS
argument_list|(
name|pmp
argument_list|,
name|cn
argument_list|)
expr_stmt|;
name|fatblock
argument_list|(
name|pmp
argument_list|,
name|byteoffset
argument_list|,
operator|&
name|bn
argument_list|,
operator|&
name|bsize
argument_list|,
operator|&
name|bo
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|&
name|FAT_GET
condition|)
block|{
name|readcn
operator|=
name|getushort
argument_list|(
operator|&
name|bp
operator|->
name|b_un
operator|.
name|b_addr
index|[
name|bo
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAT12
argument_list|(
name|pmp
argument_list|)
condition|)
block|{
if|if
condition|(
name|cn
operator|&
literal|1
condition|)
name|readcn
operator|>>=
literal|4
expr_stmt|;
name|readcn
operator|&=
literal|0x0fff
expr_stmt|;
comment|/* map certain 12 bit fat entries to 16 bit */
if|if
condition|(
operator|(
name|readcn
operator|&
literal|0x0ff0
operator|)
operator|==
literal|0x0ff0
condition|)
name|readcn
operator||=
literal|0xf000
expr_stmt|;
block|}
operator|*
name|oldcontents
operator|=
name|readcn
expr_stmt|;
block|}
if|if
condition|(
name|function
operator|&
name|FAT_SET
condition|)
block|{
if|if
condition|(
name|FAT12
argument_list|(
name|pmp
argument_list|)
condition|)
block|{
name|readcn
operator|=
name|getushort
argument_list|(
operator|&
name|bp
operator|->
name|b_un
operator|.
name|b_addr
index|[
name|bo
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
operator|&
literal|1
condition|)
block|{
name|readcn
operator|&=
literal|0x000f
expr_stmt|;
name|readcn
operator||=
operator|(
name|newcontents
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
name|readcn
operator|&=
literal|0xf000
expr_stmt|;
name|readcn
operator||=
operator|(
name|newcontents
operator|<<
literal|0
operator|)
expr_stmt|;
block|}
name|putushort
argument_list|(
operator|&
name|bp
operator|->
name|b_un
operator|.
name|b_addr
index|[
name|bo
index|]
argument_list|,
name|readcn
argument_list|)
expr_stmt|;
block|}
else|else
name|putushort
argument_list|(
operator|&
name|bp
operator|->
name|b_un
operator|.
name|b_addr
index|[
name|bo
index|]
argument_list|,
name|newcontents
argument_list|)
expr_stmt|;
name|updateotherfats
argument_list|(
name|pmp
argument_list|,
name|bp
argument_list|,
name|bn
argument_list|)
expr_stmt|;
comment|/*  *  Write out the first fat last.  */
if|if
condition|(
name|pmp
operator|->
name|pm_waitonfat
condition|)
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|pmp
operator|->
name|pm_fmod
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Allocate a free cluster.  *  pmp -   *  retcluster - put the allocated cluster's number here.  *  fillwith - put this value into the fat entry for the  *     allocated cluster.  */
end_comment

begin_function
name|int
name|clusteralloc
parameter_list|(
name|pmp
parameter_list|,
name|retcluster
parameter_list|,
name|fillwith
parameter_list|)
name|struct
name|pcfsmount
modifier|*
name|pmp
decl_stmt|;
name|u_long
modifier|*
name|retcluster
decl_stmt|;
name|u_long
name|fillwith
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|u_long
name|cn
decl_stmt|;
name|u_long
name|idx
decl_stmt|,
name|max_idx
decl_stmt|,
name|bit
decl_stmt|,
name|map
decl_stmt|;
name|max_idx
operator|=
name|pmp
operator|->
name|pm_maxcluster
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|pmp
operator|->
name|pm_lookhere
operator|/
literal|8
init|;
name|idx
operator|<=
name|max_idx
condition|;
name|idx
operator|++
control|)
block|{
name|map
operator|=
name|pmp
operator|->
name|pm_inusemap
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|map
operator|!=
literal|0xff
condition|)
block|{
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
literal|8
condition|;
name|bit
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|map
operator|&
operator|(
literal|1
operator|<<
name|bit
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|cn
operator|=
name|idx
operator|*
literal|8
operator|+
name|bit
expr_stmt|;
goto|goto
name|found_one
goto|;
block|}
block|}
block|}
block|}
return|return
name|ENOSPC
return|;
name|found_one
label|:
empty_stmt|;
name|error
operator|=
name|fatentry
argument_list|(
name|FAT_SET
argument_list|,
name|pmp
argument_list|,
name|cn
argument_list|,
literal|0
argument_list|,
name|fillwith
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|usemap_alloc
argument_list|(
name|pmp
argument_list|,
name|cn
argument_list|)
expr_stmt|;
operator|*
name|retcluster
operator|=
name|cn
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PCFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"clusteralloc(): allocated cluster %d\n"
argument_list|,
name|cn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(PCFSDEBUG) */
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  *  Free a chain of clusters.  *  pmp - address of the pcfs mount structure for the  *    filesystem containing the cluster chain to be freed.  *  startcluster - number of the 1st cluster in the chain  *    of clusters to be freed.  */
end_comment

begin_function
name|int
name|freeclusterchain
parameter_list|(
name|pmp
parameter_list|,
name|startcluster
parameter_list|)
name|struct
name|pcfsmount
modifier|*
name|pmp
decl_stmt|;
name|u_long
name|startcluster
decl_stmt|;
block|{
name|u_long
name|nextcluster
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|startcluster
operator|>=
name|CLUST_FIRST
operator|&&
name|startcluster
operator|<=
name|pmp
operator|->
name|pm_maxcluster
condition|)
block|{
name|error
operator|=
name|clusterfree
argument_list|(
name|pmp
argument_list|,
name|startcluster
argument_list|,
operator|&
name|nextcluster
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"freeclusterchain(): free failed, cluster %d\n"
argument_list|,
name|startcluster
argument_list|)
expr_stmt|;
break|break;
block|}
name|startcluster
operator|=
name|nextcluster
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  *  Read in fat blocks looking for free clusters.  *  For every free cluster found turn off its  *  corresponding bit in the pm_inusemap.  */
end_comment

begin_function
name|int
name|fillinusemap
parameter_list|(
name|pmp
parameter_list|)
name|struct
name|pcfsmount
modifier|*
name|pmp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|u_long
name|cn
decl_stmt|,
name|readcn
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|fat12
init|=
name|FAT12
argument_list|(
name|pmp
argument_list|)
decl_stmt|;
name|u_long
name|bn
decl_stmt|,
name|bo
decl_stmt|,
name|bsize
decl_stmt|,
name|byteoffset
decl_stmt|;
comment|/*  *  Mark all clusters in use, we mark the free ones in the  *  fat scan loop further down.  */
for|for
control|(
name|cn
operator|=
literal|0
init|;
name|cn
operator|<
operator|(
name|pmp
operator|->
name|pm_maxcluster
operator|>>
literal|3
operator|)
operator|+
literal|1
condition|;
name|cn
operator|++
control|)
name|pmp
operator|->
name|pm_inusemap
index|[
name|cn
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/*  *  Figure how many free clusters are in the filesystem  *  by ripping thougth the fat counting the number of  *  entries whose content is zero.  These represent free  *  clusters.  */
name|pmp
operator|->
name|pm_freeclustercount
operator|=
literal|0
expr_stmt|;
name|pmp
operator|->
name|pm_lookhere
operator|=
name|pmp
operator|->
name|pm_maxcluster
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|cn
operator|=
name|CLUST_FIRST
init|;
name|cn
operator|<=
name|pmp
operator|->
name|pm_maxcluster
condition|;
name|cn
operator|++
control|)
block|{
name|byteoffset
operator|=
name|FATOFS
argument_list|(
name|pmp
argument_list|,
name|cn
argument_list|)
expr_stmt|;
name|bo
operator|=
name|byteoffset
operator|%
name|pmp
operator|->
name|pm_fatblocksize
expr_stmt|;
if|if
condition|(
operator|!
name|bo
operator|||
operator|!
name|bp
condition|)
block|{
comment|/* Read new FAT block */
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fatblock
argument_list|(
name|pmp
argument_list|,
name|byteoffset
argument_list|,
operator|&
name|bn
argument_list|,
operator|&
name|bsize
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|readcn
operator|=
name|getushort
argument_list|(
operator|&
name|bp
operator|->
name|b_un
operator|.
name|b_addr
index|[
name|bo
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fat12
condition|)
block|{
if|if
condition|(
name|cn
operator|&
literal|1
condition|)
name|readcn
operator|>>=
literal|4
expr_stmt|;
name|readcn
operator|&=
literal|0x0fff
expr_stmt|;
block|}
if|if
condition|(
name|readcn
operator|==
literal|0
condition|)
name|usemap_free
argument_list|(
name|pmp
argument_list|,
name|cn
argument_list|)
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Allocate a new cluster and chain it onto the end of the  *  file.  *  dep - the file to extend  *  bpp - where to return the address of the buf header for the  *        new file block  *  ncp - where to put cluster number of the newly allocated file block  *        If this pointer is 0, do not return the cluster number.  *  *  NOTE:  *   This function is not responsible for turning on the DEUPD  *   bit if the de_flag field of the denode and it does not  *   change the de_FileSize field.  This is left for the caller  *   to do.  */
end_comment

begin_function
name|int
name|extendfile
parameter_list|(
name|dep
parameter_list|,
name|bpp
parameter_list|,
name|ncp
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|struct
name|buf
modifier|*
modifier|*
name|bpp
decl_stmt|;
name|u_int
modifier|*
name|ncp
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_long
name|frcn
decl_stmt|;
name|u_long
name|cn
decl_stmt|;
name|struct
name|pcfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
comment|/*  *  Don't try to extend the root directory  */
if|if
condition|(
name|DETOV
argument_list|(
name|dep
argument_list|)
operator|->
name|v_flag
operator|&
name|VROOT
condition|)
block|{
name|printf
argument_list|(
literal|"extendfile(): attempt to extend root directory\n"
argument_list|)
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
comment|/*  *  If the "file's last cluster" cache entry is empty,  *  and the file is not empty,  *  then fill the cache entry by calling pcbmap().  */
name|fc_fileextends
operator|++
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_fc
index|[
name|FC_LASTFC
index|]
operator|.
name|fc_frcn
operator|==
name|FCE_EMPTY
operator|&&
name|dep
operator|->
name|de_StartCluster
operator|!=
literal|0
condition|)
block|{
name|fc_lfcempty
operator|++
expr_stmt|;
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
literal|0xffff
argument_list|,
literal|0
argument_list|,
operator|&
name|cn
argument_list|)
expr_stmt|;
comment|/* we expect it to return E2BIG */
if|if
condition|(
name|error
operator|!=
name|E2BIG
condition|)
return|return
name|error
return|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  *  Allocate another cluster and chain onto the end of the file.  *  If the file is empty we make de_StartCluster point to the  *  new block.  Note that de_StartCluster being 0 is sufficient  *  to be sure the file is empty since we exclude attempts to  *  extend the root directory above, and the root dir is the  *  only file with a startcluster of 0 that has blocks allocated  *  (sort of).  */
if|if
condition|(
name|error
operator|=
name|clusteralloc
argument_list|(
name|pmp
argument_list|,
operator|&
name|cn
argument_list|,
name|CLUST_EOFE
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|dep
operator|->
name|de_StartCluster
operator|==
literal|0
condition|)
block|{
name|dep
operator|->
name|de_StartCluster
operator|=
name|cn
expr_stmt|;
name|frcn
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|fatentry
argument_list|(
name|FAT_SET
argument_list|,
name|pmp
argument_list|,
name|dep
operator|->
name|de_fc
index|[
name|FC_LASTFC
index|]
operator|.
name|fc_fsrcn
argument_list|,
literal|0
argument_list|,
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|clusterfree
argument_list|(
name|pmp
argument_list|,
name|cn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|frcn
operator|=
name|dep
operator|->
name|de_fc
index|[
name|FC_LASTFC
index|]
operator|.
name|fc_frcn
operator|+
literal|1
expr_stmt|;
block|}
comment|/*  *  Update the "last cluster of the file" entry in the denode's  *  fat cache.  */
name|fc_setcache
argument_list|(
name|dep
argument_list|,
name|FC_LASTFC
argument_list|,
name|frcn
argument_list|,
name|cn
argument_list|)
expr_stmt|;
comment|/*  *  Get the buf header for the new block of the file.  */
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
operator|*
name|bpp
operator|=
name|getblk
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|cn
argument_list|)
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bpp
operator|=
name|getblk
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|,
name|frcn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|)
expr_stmt|;
block|}
name|clrbuf
argument_list|(
operator|*
name|bpp
argument_list|)
expr_stmt|;
comment|/*  *  Give them the filesystem relative cluster number  *  if they want it.  */
if|if
condition|(
name|ncp
condition|)
operator|*
name|ncp
operator|=
name|cn
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

