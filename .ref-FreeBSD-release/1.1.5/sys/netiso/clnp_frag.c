begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)clnp_frag.c	7.12 (Berkeley) 5/6/91  *	$Id: clnp_frag.c,v 1.4 1993/11/25 01:35:41 wollman Exp $  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"iso.h"
end_include

begin_include
include|#
directive|include
file|"iso_var.h"
end_include

begin_include
include|#
directive|include
file|"clnp.h"
end_include

begin_include
include|#
directive|include
file|"clnp_stat.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_comment
comment|/* all fragments are hung off this list */
end_comment

begin_decl_stmt
name|struct
name|clnp_fragl
modifier|*
name|clnp_frags
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|clnp_insert_frag
parameter_list|(
name|struct
name|clnp_fragl
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|clnp_segment
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|mbuf
modifier|*
name|clnp_comp_pdu
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * FUNCTION:	clnp_fragment  *  * PURPOSE:	Fragment a datagram, and send the itty bitty pieces  *		out over an interface.  *  * RETURNS:	success - 0  *		failure - unix error code  *  * SIDE EFFECTS:	  *  * NOTES: 	If there is an error sending the packet, clnp_discard  *		is called to discard the packet and send an ER. If  *		clnp_fragment was called from clnp_output, then  *		we generated the packet, and should not send an   *		ER -- clnp_emit_er will check for this. Otherwise,  *		the packet was fragmented during forwarding. In this  *		case, we ought to send an ER back.  */
end_comment

begin_function
name|int
name|clnp_fragment
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|,
name|first_hop
parameter_list|,
name|total_len
parameter_list|,
name|segoff
parameter_list|,
name|flags
parameter_list|,
name|rt
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* ptr to outgoing interface */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* ptr to packet */
name|struct
name|sockaddr
modifier|*
name|first_hop
decl_stmt|;
comment|/* ptr to first hop */
name|int
name|total_len
decl_stmt|;
comment|/* length of datagram */
name|int
name|segoff
decl_stmt|;
comment|/* offset of segpart in hdr */
name|int
name|flags
decl_stmt|;
comment|/* flags passed to clnp_output */
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
comment|/* route if direct ether */
block|{
name|struct
name|clnp_fixed
modifier|*
name|clnp
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|clnp_fixed
operator|*
argument_list|)
decl_stmt|;
name|int
name|hdr_len
init|=
operator|(
name|int
operator|)
name|clnp
operator|->
name|cnf_hdr_len
decl_stmt|;
name|int
name|frag_size
init|=
operator|(
name|SN_MTU
argument_list|(
name|ifp
argument_list|,
name|rt
argument_list|)
operator|-
name|hdr_len
operator|)
operator|&
operator|~
literal|7
decl_stmt|;
name|total_len
operator|-=
name|hdr_len
expr_stmt|;
if|if
condition|(
operator|(
name|clnp
operator|->
name|cnf_type
operator|&
name|CNF_SEG_OK
operator|)
operator|&&
operator|(
name|total_len
operator|>=
literal|8
operator|)
operator|&&
operator|(
name|frag_size
operator|>
literal|8
operator|||
operator|(
name|frag_size
operator|==
literal|8
operator|&&
operator|!
operator|(
name|total_len
operator|&
literal|7
operator|)
operator|)
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|hdr
init|=
name|NULL
decl_stmt|;
comment|/* save copy of clnp hdr */
name|struct
name|mbuf
modifier|*
name|frag_hdr
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|frag_data
init|=
name|NULL
decl_stmt|;
name|struct
name|clnp_segment
name|seg_part
decl_stmt|;
comment|/* segmentation header */
name|int
name|frag_base
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|INCSTAT
argument_list|(
name|cns_fragmented
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|segoff
operator|+
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|seg_part
argument_list|,
sizeof|sizeof
argument_list|(
name|seg_part
argument_list|)
argument_list|)
expr_stmt|;
name|frag_base
operator|=
name|ntohs
argument_list|(
name|seg_part
operator|.
name|cng_off
argument_list|)
expr_stmt|;
comment|/* 		 *	Duplicate header, and remove from packet 		 */
if|if
condition|(
operator|(
name|hdr
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|hdr_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|clnp_discard
argument_list|(
name|m
argument_list|,
name|GEN_CONGEST
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
name|hdr_len
argument_list|)
expr_stmt|;
while|while
condition|(
name|total_len
operator|>
literal|0
condition|)
block|{
name|int
name|remaining
decl_stmt|,
name|last_frag
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_FRAG
argument_list|)
name|struct
name|mbuf
modifier|*
name|mdump
init|=
name|frag_hdr
decl_stmt|;
name|int
name|tot_mlen
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"clnp_fragment: total_len %d:\n"
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
while|while
condition|(
name|mdump
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\tmbuf x%x, m_len %d\n"
argument_list|,
name|mdump
argument_list|,
name|mdump
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|tot_mlen
operator|+=
name|mdump
operator|->
name|m_len
expr_stmt|;
name|mdump
operator|=
name|mdump
operator|->
name|m_next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"clnp_fragment: sum of mbuf chain %d:\n"
argument_list|,
name|tot_mlen
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|frag_size
init|=
name|min
argument_list|(
name|total_len
argument_list|,
name|frag_size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|remaining
operator|=
name|total_len
operator|-
name|frag_size
operator|)
operator|==
literal|0
condition|)
name|last_frag
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* 				 *  If this fragment will cause the last one to  				 *	be less than 8 bytes, shorten this fragment a bit. 				 *  The obscure test on frag_size above ensures that 				 *  frag_size will be positive. 				 */
name|last_frag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|remaining
operator|<
literal|8
condition|)
name|frag_size
operator|-=
literal|8
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_FRAG
argument_list|)
name|printf
argument_list|(
literal|"clnp_fragment: seg off %d, size %d, remaining %d\n"
argument_list|,
name|ntohs
argument_list|(
name|seg_part
operator|.
name|cng_off
argument_list|)
argument_list|,
name|frag_size
argument_list|,
name|total_len
operator|-
name|frag_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_frag
condition|)
name|printf
argument_list|(
literal|"clnp_fragment: last fragment\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|last_frag
condition|)
block|{
comment|/*  				 *	this is the last fragment; we don't need to get any other 				 *	mbufs. 				 */
name|frag_hdr
operator|=
name|hdr
expr_stmt|;
name|frag_data
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
comment|/* duplicate header and data mbufs */
if|if
condition|(
operator|(
name|frag_hdr
operator|=
name|m_copy
argument_list|(
name|hdr
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|clnp_discard
argument_list|(
name|hdr
argument_list|,
name|GEN_CONGEST
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|frag_data
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|frag_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|clnp_discard
argument_list|(
name|hdr
argument_list|,
name|GEN_CONGEST
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|frag_hdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|INCSTAT
argument_list|(
name|cns_fragments
argument_list|)
expr_stmt|;
block|}
name|clnp
operator|=
name|mtod
argument_list|(
name|frag_hdr
argument_list|,
expr|struct
name|clnp_fixed
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|last_frag
condition|)
name|clnp
operator|->
name|cnf_type
operator||=
name|CNF_MORE_SEGS
expr_stmt|;
comment|/* link together */
name|m_cat
argument_list|(
name|frag_hdr
argument_list|,
name|frag_data
argument_list|)
expr_stmt|;
comment|/* insert segmentation part; updated below */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|seg_part
argument_list|,
name|mtod
argument_list|(
name|frag_hdr
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|segoff
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|clnp_segment
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|int
name|derived_len
init|=
name|hdr_len
operator|+
name|frag_size
decl_stmt|;
name|HTOC
argument_list|(
name|clnp
operator|->
name|cnf_seglen_msb
argument_list|,
name|clnp
operator|->
name|cnf_seglen_lsb
argument_list|,
name|derived_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|frag_hdr
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"clnp_frag:lost header"
argument_list|)
expr_stmt|;
name|frag_hdr
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|derived_len
expr_stmt|;
block|}
comment|/* compute clnp checksum (on header only) */
if|if
condition|(
name|flags
operator|&
name|CLNP_NO_CKSUM
condition|)
block|{
name|HTOC
argument_list|(
name|clnp
operator|->
name|cnf_cksum_msb
argument_list|,
name|clnp
operator|->
name|cnf_cksum_lsb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iso_gen_csum
argument_list|(
name|frag_hdr
argument_list|,
name|CLNP_CKSUM_OFF
argument_list|,
name|hdr_len
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_DUMPOUT
argument_list|)
name|struct
name|mbuf
modifier|*
name|mdump
init|=
name|frag_hdr
decl_stmt|;
name|printf
argument_list|(
literal|"clnp_fragment: sending dg:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|mdump
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\tmbuf x%x, m_len %d\n"
argument_list|,
name|mdump
argument_list|,
name|mdump
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|mdump
operator|=
name|mdump
operator|->
name|m_next
expr_stmt|;
block|}
name|ENDDEBUG
ifdef|#
directive|ifdef
name|TROLL
name|error
init|=
name|troll_output
argument_list|(
name|ifp
argument_list|,
name|frag_hdr
argument_list|,
name|first_hop
argument_list|,
name|rt
argument_list|)
decl_stmt|;
else|#
directive|else
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|frag_hdr
argument_list|,
name|first_hop
argument_list|,
name|rt
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TROLL
comment|/* 			 * Tough situation: if the error occured on the last  			 * fragment, we can not send an ER, as the if_output 			 * routine consumed the packet. If the error occured 			 * on any intermediate packets, we can send an ER 			 * because we still have the original header in (m). 			 */
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|frag_hdr
operator|!=
name|hdr
condition|)
block|{
comment|/*  			 * The error was not on the last fragment. We must 			 * free hdr and m before returning 			 */
name|clnp_discard
argument_list|(
name|hdr
argument_list|,
name|GEN_NOREAS
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* bump segment offset, trim data mbuf, and decrement count left */
ifdef|#
directive|ifdef
name|TROLL
comment|/* 	 * Decrement frag_size by some fraction. This will cause the 	 * next fragment to start 'early', thus duplicating the end 	 * of the current fragment.  troll.tr_dup_size controls 	 * the fraction. If positive, it specifies the fraction. If 	 * negative, a random fraction is used. 	 */
if|if
condition|(
operator|(
name|trollctl
operator|.
name|tr_ops
operator|&
name|TR_DUPEND
operator|)
operator|&&
operator|(
operator|!
name|last_frag
operator|)
condition|)
block|{
name|int
name|num_bytes
init|=
name|frag_size
decl_stmt|;
if|if
condition|(
name|trollctl
operator|.
name|tr_dup_size
operator|>
literal|0
condition|)
name|num_bytes
operator|*=
name|trollctl
operator|.
name|tr_dup_size
expr_stmt|;
else|else
name|num_bytes
operator|*=
name|troll_random
argument_list|()
expr_stmt|;
name|frag_size
operator|-=
name|num_bytes
expr_stmt|;
block|}
endif|#
directive|endif
endif|TROLL
name|total_len
operator|-=
name|frag_size
expr_stmt|;
if|if
condition|(
operator|!
name|last_frag
condition|)
block|{
name|frag_base
operator|+=
name|frag_size
expr_stmt|;
name|seg_part
operator|.
name|cng_off
operator|=
name|htons
argument_list|(
name|frag_base
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|frag_size
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|cantfrag
label|:
name|INCSTAT
argument_list|(
name|cns_cantfrag
argument_list|)
expr_stmt|;
name|clnp_discard
argument_list|(
name|m
argument_list|,
name|GEN_SEGNEEDED
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		clnp_reass  *  * PURPOSE:			Attempt to reassemble a clnp packet given the current  *					fragment. If reassembly succeeds (all the fragments  *					are present), then return a pointer to an mbuf chain  *					containing the reassembled packet. This packet will  *					appear in the mbufs as if it had just arrived in  *					one piece.   *  *					If reassembly fails, then save this fragment and  *					return 0.  *  * RETURNS:			Ptr to assembled packet, or 0  *  * SIDE EFFECTS:	  *  * NOTES:			  *		clnp_slowtimo can not affect this code because clnpintr, and thus  *		this code, is called at a higher priority than clnp_slowtimo.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|clnp_reass
parameter_list|(
name|m
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|seg
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* new fragment */
name|struct
name|iso_addr
modifier|*
name|src
decl_stmt|;
comment|/* src of new fragment */
name|struct
name|iso_addr
modifier|*
name|dst
decl_stmt|;
comment|/* dst of new fragment */
name|struct
name|clnp_segment
modifier|*
name|seg
decl_stmt|;
comment|/* segment part of fragment header */
block|{
specifier|register
name|struct
name|clnp_fragl
modifier|*
name|cfh
decl_stmt|;
comment|/* look for other fragments of this datagram */
for|for
control|(
name|cfh
operator|=
name|clnp_frags
init|;
name|cfh
operator|!=
name|NULL
condition|;
name|cfh
operator|=
name|cfh
operator|->
name|cfl_next
control|)
block|{
if|if
condition|(
name|seg
operator|->
name|cng_id
operator|==
name|cfh
operator|->
name|cfl_id
operator|&&
name|iso_addrmatch1
argument_list|(
name|src
argument_list|,
operator|&
name|cfh
operator|->
name|cfl_src
argument_list|)
operator|&&
name|iso_addrmatch1
argument_list|(
name|dst
argument_list|,
operator|&
name|cfh
operator|->
name|cfl_dst
argument_list|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_REASS
argument_list|)
name|printf
argument_list|(
literal|"clnp_reass: found packet\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 			 *	There are other fragments here already. Lets see if 			 *	this fragment is of any help 			 */
name|clnp_insert_frag
argument_list|(
name|cfh
argument_list|,
name|m
argument_list|,
name|seg
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|=
name|clnp_comp_pdu
argument_list|(
name|cfh
argument_list|)
condition|)
block|{
specifier|register
name|struct
name|clnp_fixed
modifier|*
name|clnp
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|clnp_fixed
operator|*
argument_list|)
decl_stmt|;
name|HTOC
argument_list|(
name|clnp
operator|->
name|cnf_seglen_msb
argument_list|,
name|clnp
operator|->
name|cnf_seglen_lsb
argument_list|,
name|seg
operator|->
name|cng_tot_len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
block|}
name|IFDEBUG
argument_list|(
argument|D_REASS
argument_list|)
name|printf
argument_list|(
literal|"clnp_reass: new packet!\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 *	This is the first fragment. If src is not consuming too many 	 *	resources, then create a new fragment list and add 	 *	this fragment to the list. 	 */
comment|/* TODO: don't let one src hog all the reassembly buffers */
if|if
condition|(
operator|!
name|clnp_newpkt
argument_list|(
name|m
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|seg
argument_list|)
comment|/* || this src is a hog */
condition|)
block|{
name|INCSTAT
argument_list|(
name|cns_fragdropped
argument_list|)
expr_stmt|;
name|clnp_discard
argument_list|(
name|m
argument_list|,
name|GEN_CONGEST
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		clnp_newpkt  *  * PURPOSE:			Create the necessary structures to handle a new  *					fragmented clnp packet.  *  * RETURNS:			non-zero if it succeeds, zero if fails.  *  * SIDE EFFECTS:	  *  * NOTES:			Failure is only due to insufficient resources.  */
end_comment

begin_function
name|int
name|clnp_newpkt
parameter_list|(
name|m
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|seg
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* new fragment */
name|struct
name|iso_addr
modifier|*
name|src
decl_stmt|;
comment|/* src of new fragment */
name|struct
name|iso_addr
modifier|*
name|dst
decl_stmt|;
comment|/* dst of new fragment */
name|struct
name|clnp_segment
modifier|*
name|seg
decl_stmt|;
comment|/* segment part of fragment header */
block|{
specifier|register
name|struct
name|clnp_fragl
modifier|*
name|cfh
decl_stmt|;
specifier|register
name|struct
name|clnp_fixed
modifier|*
name|clnp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|clnp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|clnp_fixed
operator|*
argument_list|)
expr_stmt|;
comment|/*  	 *	Allocate new clnp fragl structure to act as header of all fragments 	 *	for this datagram. 	 */
name|MGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_FTABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cfh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|clnp_fragl
operator|*
argument_list|)
expr_stmt|;
comment|/*  	 *	Duplicate the header of this fragment, and save in cfh. 	 *	Free m0 and return if m_copy does not succeed. 	 */
if|if
condition|(
operator|(
name|cfh
operator|->
name|cfl_orighdr
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|clnp
operator|->
name|cnf_hdr_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Fill in rest of fragl structure */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|src
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cfh
operator|->
name|cfl_src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|dst
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cfh
operator|->
name|cfl_dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cfh
operator|->
name|cfl_id
operator|=
name|seg
operator|->
name|cng_id
expr_stmt|;
name|cfh
operator|->
name|cfl_ttl
operator|=
name|clnp
operator|->
name|cnf_ttl
expr_stmt|;
name|cfh
operator|->
name|cfl_last
operator|=
operator|(
name|seg
operator|->
name|cng_tot_len
operator|-
name|clnp
operator|->
name|cnf_hdr_len
operator|)
operator|-
literal|1
expr_stmt|;
name|cfh
operator|->
name|cfl_frags
operator|=
name|NULL
expr_stmt|;
name|cfh
operator|->
name|cfl_next
operator|=
name|NULL
expr_stmt|;
comment|/* Insert into list of packets */
name|cfh
operator|->
name|cfl_next
operator|=
name|clnp_frags
expr_stmt|;
name|clnp_frags
operator|=
name|cfh
expr_stmt|;
comment|/* Insert this fragment into list headed by cfh */
name|clnp_insert_frag
argument_list|(
name|cfh
argument_list|,
name|m
argument_list|,
name|seg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		clnp_insert_frag  *  * PURPOSE:			Insert fragment into list headed by 'cf'.  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	  *  * NOTES:			This is the 'guts' of the reassembly algorithm.  *					Each fragment in this list contains a clnp_frag  *					structure followed by the data of the fragment.  *					The clnp_frag structure actually lies on top of  *					part of the old clnp header.  */
end_comment

begin_function
specifier|static
name|void
name|clnp_insert_frag
parameter_list|(
name|cfh
parameter_list|,
name|m
parameter_list|,
name|seg
parameter_list|)
name|struct
name|clnp_fragl
modifier|*
name|cfh
decl_stmt|;
comment|/* header of list of packet fragments */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* new fragment */
name|struct
name|clnp_segment
modifier|*
name|seg
decl_stmt|;
comment|/* segment part of fragment header */
block|{
specifier|register
name|struct
name|clnp_fixed
modifier|*
name|clnp
decl_stmt|;
comment|/* clnp hdr of fragment */
specifier|register
name|struct
name|clnp_frag
modifier|*
name|cf
decl_stmt|;
comment|/* generic fragment ptr */
specifier|register
name|struct
name|clnp_frag
modifier|*
name|cf_sub
init|=
name|NULL
decl_stmt|;
comment|/* frag subsequent to new one */
specifier|register
name|struct
name|clnp_frag
modifier|*
name|cf_prev
init|=
name|NULL
decl_stmt|;
comment|/* frag previous to new one */
name|u_short
name|first
decl_stmt|;
comment|/* offset of first byte of initial pdu*/
name|u_short
name|last
decl_stmt|;
comment|/* offset of last byte of initial pdu */
name|u_short
name|fraglen
decl_stmt|;
comment|/* length of fragment */
name|clnp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|clnp_fixed
operator|*
argument_list|)
expr_stmt|;
name|first
operator|=
name|seg
operator|->
name|cng_off
expr_stmt|;
name|CTOH
argument_list|(
name|clnp
operator|->
name|cnf_seglen_msb
argument_list|,
name|clnp
operator|->
name|cnf_seglen_lsb
argument_list|,
name|fraglen
argument_list|)
expr_stmt|;
name|fraglen
operator|-=
name|clnp
operator|->
name|cnf_hdr_len
expr_stmt|;
name|last
operator|=
operator|(
name|first
operator|+
name|fraglen
operator|)
operator|-
literal|1
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REASS
argument_list|)
name|printf
argument_list|(
literal|"clnp_insert_frag: New fragment: [%d ... %d], len %d\n"
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|fraglen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"clnp_insert_frag: current fragments:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|cf
operator|=
name|cfh
operator|->
name|cfl_frags
init|;
name|cf
operator|!=
name|NULL
condition|;
name|cf
operator|=
name|cf
operator|->
name|cfr_next
control|)
block|{
name|printf
argument_list|(
literal|"\tcf x%x: [%d ... %d]\n"
argument_list|,
name|cf
argument_list|,
name|cf
operator|->
name|cfr_first
argument_list|,
name|cf
operator|->
name|cfr_last
argument_list|)
expr_stmt|;
block|}
name|ENDDEBUG
if|if
condition|(
name|cfh
operator|->
name|cfl_frags
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 *	Find fragment which begins after the new one 		 */
for|for
control|(
name|cf
operator|=
name|cfh
operator|->
name|cfl_frags
init|;
name|cf
operator|!=
name|NULL
condition|;
name|cf_prev
operator|=
name|cf
operator|,
name|cf
operator|=
name|cf
operator|->
name|cfr_next
control|)
block|{
if|if
condition|(
name|cf
operator|->
name|cfr_first
operator|>
name|first
condition|)
block|{
name|cf_sub
operator|=
name|cf
expr_stmt|;
break|break;
block|}
block|}
name|IFDEBUG
argument_list|(
argument|D_REASS
argument_list|)
name|printf
argument_list|(
literal|"clnp_insert_frag: Previous frag is "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf_prev
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"NULL\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"[%d ... %d]\n"
argument_list|,
name|cf_prev
operator|->
name|cfr_first
argument_list|,
name|cf_prev
operator|->
name|cfr_last
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"clnp_insert_frag: Subsequent frag is "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf_sub
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"NULL\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"[%d ... %d]\n"
argument_list|,
name|cf_sub
operator|->
name|cfr_first
argument_list|,
name|cf_sub
operator|->
name|cfr_last
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 		 *	If there is a fragment before the new one, check if it 		 *	overlaps the new one. If so, then trim the end of the 		 *	previous one. 		 */
if|if
condition|(
name|cf_prev
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cf_prev
operator|->
name|cfr_last
operator|>
name|first
condition|)
block|{
name|u_short
name|overlap
init|=
name|cf_prev
operator|->
name|cfr_last
operator|-
name|first
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REASS
argument_list|)
name|printf
argument_list|(
literal|"clnp_insert_frag: previous overlaps by %d\n"
argument_list|,
name|overlap
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|overlap
operator|>
name|fraglen
condition|)
block|{
comment|/* 					 *	The new fragment is entirely contained in the 					 *	preceeding one. We can punt on the new frag 					 *	completely. 					 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Trim data off of end of previous fragment */
comment|/* inc overlap to prevent duplication of last byte */
name|overlap
operator|++
expr_stmt|;
name|m_adj
argument_list|(
name|cf_prev
operator|->
name|cfr_data
argument_list|,
operator|-
operator|(
name|int
operator|)
name|overlap
argument_list|)
expr_stmt|;
name|cf_prev
operator|->
name|cfr_last
operator|-=
name|overlap
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 *	For all fragments past the new one, check if any data on 		 *	the new one overlaps data on existing fragments. If so, 		 *	then trim the extra data off the end of the new one. 		 */
for|for
control|(
name|cf
operator|=
name|cf_sub
init|;
name|cf
operator|!=
name|NULL
condition|;
name|cf
operator|=
name|cf
operator|->
name|cfr_next
control|)
block|{
if|if
condition|(
name|cf
operator|->
name|cfr_first
operator|<
name|last
condition|)
block|{
name|u_short
name|overlap
init|=
name|last
operator|-
name|cf
operator|->
name|cfr_first
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REASS
argument_list|)
name|printf
argument_list|(
literal|"clnp_insert_frag: subsequent overlaps by %d\n"
argument_list|,
name|overlap
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|overlap
operator|>
name|fraglen
condition|)
block|{
comment|/* 					 *	The new fragment is entirely contained in the 					 *	succeeding one. This should not happen, because 					 *	early on in this code we scanned for the fragment 					 *	which started after the new one! 					 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"clnp_insert_frag: internal error!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Trim data off of end of new fragment */
comment|/* inc overlap to prevent duplication of last byte */
name|overlap
operator|++
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
operator|(
name|int
operator|)
name|overlap
argument_list|)
expr_stmt|;
name|last
operator|-=
name|overlap
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 *	Insert the new fragment beween cf_prev and cf_sub 	 * 	 *	Note: the clnp hdr is still in the mbuf.  	 *	If the data of the mbuf is not word aligned, shave off enough 	 *	so that it is. Then, cast the clnp_frag structure on top 	 *	of the clnp header.  	 *	The clnp_hdr will not be used again (as we already have 	 *	saved a copy of it). 	 * 	 *	Save in cfr_bytes the number of bytes to shave off to get to 	 *	the data of the packet. This is used when we coalesce fragments; 	 *	the clnp_frag structure must be removed before joining mbufs. 	 */
block|{
name|int
name|pad
decl_stmt|;
name|u_int
name|bytes
decl_stmt|;
comment|/* determine if header is not word aligned */
name|pad
operator|=
operator|(
name|int
operator|)
name|clnp
operator|%
literal|4
expr_stmt|;
if|if
condition|(
name|pad
operator|<
literal|0
condition|)
name|pad
operator|=
operator|-
name|pad
expr_stmt|;
comment|/* bytes is number of bytes left in front of data */
name|bytes
operator|=
name|clnp
operator|->
name|cnf_hdr_len
operator|-
name|pad
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REASS
argument_list|)
name|printf
argument_list|(
literal|"clnp_insert_frag: clnp x%x requires %d alignment\n"
argument_list|,
name|clnp
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* make it word aligned if necessary */
if|if
condition|(
name|pad
condition|)
name|m_adj
argument_list|(
name|m
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|cf
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|clnp_frag
operator|*
argument_list|)
expr_stmt|;
name|cf
operator|->
name|cfr_bytes
operator|=
name|bytes
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REASS
argument_list|)
name|printf
argument_list|(
literal|"clnp_insert_frag: cf now x%x, cfr_bytes %d\n"
argument_list|,
name|cf
argument_list|,
name|cf
operator|->
name|cfr_bytes
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
name|cf
operator|->
name|cfr_first
operator|=
name|first
expr_stmt|;
name|cf
operator|->
name|cfr_last
operator|=
name|last
expr_stmt|;
comment|/* 	 *	The data is the mbuf itself, although we must remember that the 	 *	first few bytes are actually a clnp_frag structure 	 */
name|cf
operator|->
name|cfr_data
operator|=
name|m
expr_stmt|;
comment|/* link into place */
name|cf
operator|->
name|cfr_next
operator|=
name|cf_sub
expr_stmt|;
if|if
condition|(
name|cf_prev
operator|==
name|NULL
condition|)
name|cfh
operator|->
name|cfl_frags
operator|=
name|cf
expr_stmt|;
else|else
name|cf_prev
operator|->
name|cfr_next
operator|=
name|cf
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		clnp_comp_pdu  *  * PURPOSE:			Scan the list of fragments headed by cfh. Merge  *					any contigious fragments into one. If, after  *					traversing all the fragments, it is determined that  *					the packet is complete, then return a pointer to  *					the packet (with header prepended). Otherwise,  *					return NULL.  *  * RETURNS:			NULL, or a pointer to the assembled pdu in an mbuf chain.  *  * SIDE EFFECTS:	Will colapse contigious fragments into one.  *  * NOTES:			This code assumes that there are no overlaps of  *					fragment pdus.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|clnp_comp_pdu
parameter_list|(
name|cfh
parameter_list|)
name|struct
name|clnp_fragl
modifier|*
name|cfh
decl_stmt|;
comment|/* fragment header */
block|{
specifier|register
name|struct
name|clnp_frag
modifier|*
name|cf
init|=
name|cfh
operator|->
name|cfl_frags
decl_stmt|;
while|while
condition|(
name|cf
operator|->
name|cfr_next
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|struct
name|clnp_frag
modifier|*
name|cf_next
init|=
name|cf
operator|->
name|cfr_next
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REASS
argument_list|)
name|printf
argument_list|(
literal|"clnp_comp_pdu: comparing: [%d ... %d] to [%d ... %d]\n"
argument_list|,
name|cf
operator|->
name|cfr_first
argument_list|,
name|cf
operator|->
name|cfr_last
argument_list|,
name|cf_next
operator|->
name|cfr_first
argument_list|,
name|cf_next
operator|->
name|cfr_last
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cf
operator|->
name|cfr_last
operator|==
operator|(
name|cf_next
operator|->
name|cfr_first
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* 			 *	Merge fragment cf and cf_next 			 * 			 *	- update cf header 			 *	- trim clnp_frag structure off of cf_next 			 *	- append cf_next to cf 			 */
name|struct
name|clnp_frag
name|cf_next_hdr
decl_stmt|;
name|struct
name|clnp_frag
modifier|*
name|next_frag
decl_stmt|;
name|cf_next_hdr
operator|=
operator|*
name|cf_next
expr_stmt|;
name|next_frag
operator|=
name|cf_next
operator|->
name|cfr_next
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REASS
argument_list|)
name|struct
name|mbuf
modifier|*
name|mdump
decl_stmt|;
name|int
name|l
decl_stmt|;
name|printf
argument_list|(
literal|"clnp_comp_pdu: merging fragments\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"clnp_comp_pdu: 1st: [%d ... %d] (bytes %d)\n"
argument_list|,
name|cf
operator|->
name|cfr_first
argument_list|,
name|cf
operator|->
name|cfr_last
argument_list|,
name|cf
operator|->
name|cfr_bytes
argument_list|)
expr_stmt|;
name|mdump
operator|=
name|cf
operator|->
name|cfr_data
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mdump
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\tmbuf x%x, m_len %d\n"
argument_list|,
name|mdump
argument_list|,
name|mdump
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|l
operator|+=
name|mdump
operator|->
name|m_len
expr_stmt|;
name|mdump
operator|=
name|mdump
operator|->
name|m_next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\ttotal len: %d\n"
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"clnp_comp_pdu: 2nd: [%d ... %d] (bytes %d)\n"
argument_list|,
name|cf_next
operator|->
name|cfr_first
argument_list|,
name|cf_next
operator|->
name|cfr_last
argument_list|,
name|cf_next
operator|->
name|cfr_bytes
argument_list|)
expr_stmt|;
name|mdump
operator|=
name|cf_next
operator|->
name|cfr_data
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mdump
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\tmbuf x%x, m_len %d\n"
argument_list|,
name|mdump
argument_list|,
name|mdump
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|l
operator|+=
name|mdump
operator|->
name|m_len
expr_stmt|;
name|mdump
operator|=
name|mdump
operator|->
name|m_next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\ttotal len: %d\n"
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|cf
operator|->
name|cfr_last
init|=
name|cf_next
operator|->
name|cfr_last
decl_stmt|;
comment|/* 			 *	After this m_adj, the cf_next ptr is useless because we 			 *	have adjusted the clnp_frag structure away... 			 */
name|IFDEBUG
argument_list|(
argument|D_REASS
argument_list|)
name|printf
argument_list|(
literal|"clnp_comp_pdu: shaving off %d bytes\n"
argument_list|,
name|cf_next_hdr
operator|.
name|cfr_bytes
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|m_adj
argument_list|(
name|cf_next_hdr
operator|.
name|cfr_data
argument_list|,
operator|(
name|int
operator|)
name|cf_next_hdr
operator|.
name|cfr_bytes
argument_list|)
decl_stmt|;
name|m_cat
argument_list|(
name|cf
operator|->
name|cfr_data
argument_list|,
name|cf_next_hdr
operator|.
name|cfr_data
argument_list|)
expr_stmt|;
name|cf
operator|->
name|cfr_next
operator|=
name|next_frag
expr_stmt|;
block|}
else|else
block|{
name|cf
operator|=
name|cf
operator|->
name|cfr_next
expr_stmt|;
block|}
block|}
name|cf
operator|=
name|cfh
operator|->
name|cfl_frags
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REASS
argument_list|)
name|struct
name|mbuf
modifier|*
name|mdump
init|=
name|cf
operator|->
name|cfr_data
decl_stmt|;
name|printf
argument_list|(
literal|"clnp_comp_pdu: first frag now: [%d ... %d]\n"
argument_list|,
name|cf
operator|->
name|cfr_first
argument_list|,
name|cf
operator|->
name|cfr_last
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"clnp_comp_pdu: data for frag:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|mdump
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"mbuf x%x, m_len %d\n"
argument_list|,
name|mdump
argument_list|,
name|mdump
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* 			dump_buf(mtod(mdump, caddr_t), mdump->m_len);*/
name|mdump
operator|=
name|mdump
operator|->
name|m_next
expr_stmt|;
block|}
name|ENDDEBUG
comment|/* Check if datagram is complete */
if|if
condition|(
operator|(
name|cf
operator|->
name|cfr_first
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cf
operator|->
name|cfr_last
operator|==
name|cfh
operator|->
name|cfl_last
operator|)
condition|)
block|{
comment|/* 		 *	We have a complete pdu! 		 *	- Remove the frag header from (only) remaining fragment 		 *		(which is not really a fragment anymore, as the datagram is 		 *		complete). 		 *	- Prepend a clnp header 		 */
name|struct
name|mbuf
modifier|*
name|data
init|=
name|cf
operator|->
name|cfr_data
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|hdr
init|=
name|cfh
operator|->
name|cfl_orighdr
decl_stmt|;
name|struct
name|clnp_fragl
modifier|*
name|scan
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REASS
argument_list|)
name|printf
argument_list|(
literal|"clnp_comp_pdu: complete pdu!\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|m_adj
argument_list|(
name|data
argument_list|,
operator|(
name|int
operator|)
name|cf
operator|->
name|cfr_bytes
argument_list|)
decl_stmt|;
name|m_cat
argument_list|(
name|hdr
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_DUMPIN
argument_list|)
name|struct
name|mbuf
modifier|*
name|mdump
init|=
name|hdr
decl_stmt|;
name|printf
argument_list|(
literal|"clnp_comp_pdu: pdu is:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|mdump
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"mbuf x%x, m_len %d\n"
argument_list|,
name|mdump
argument_list|,
name|mdump
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* 				dump_buf(mtod(mdump, caddr_t), mdump->m_len);*/
name|mdump
operator|=
name|mdump
operator|->
name|m_next
expr_stmt|;
block|}
name|ENDDEBUG
comment|/* 		 *	Remove cfh from the list of fragmented pdus 		 */
if|if
condition|(
name|clnp_frags
operator|==
name|cfh
condition|)
block|{
name|clnp_frags
operator|=
name|cfh
operator|->
name|cfl_next
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|scan
operator|=
name|clnp_frags
init|;
name|scan
operator|!=
name|NULL
condition|;
name|scan
operator|=
name|scan
operator|->
name|cfl_next
control|)
block|{
if|if
condition|(
name|scan
operator|->
name|cfl_next
operator|==
name|cfh
condition|)
block|{
name|scan
operator|->
name|cfl_next
operator|=
name|cfh
operator|->
name|cfl_next
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* free cfh */
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|cfh
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|hdr
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TROLL
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|troll_cnt
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_comment
comment|/*  * FUNCTION:		troll_random  *  * PURPOSE:			generate a pseudo-random number between 0 and 1  *  * RETURNS:			the random number  *  * SIDE EFFECTS:	  *  * NOTES:			This is based on the clock.  */
end_comment

begin_function
name|float
name|troll_random
parameter_list|()
block|{
specifier|extern
name|struct
name|timeval
name|time
decl_stmt|;
name|long
name|t
init|=
name|time
operator|.
name|tv_usec
operator|%
literal|100
decl_stmt|;
return|return
operator|(
operator|(
name|float
operator|)
name|t
operator|/
operator|(
name|float
operator|)
literal|100
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		troll_output  *  * PURPOSE:			Do something sneaky with the datagram passed. Possible  *					operations are:  *						Duplicate the packet  *						Drop the packet  *						Trim some number of bytes from the packet  *						Munge some byte in the packet  *  * RETURNS:			0, or unix error code  *  * SIDE EFFECTS:	  *  * NOTES:			The operation of this procedure is regulated by the  *					troll control structure (Troll).  */
end_comment

begin_function
name|int
name|troll_output
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|,
name|dst
parameter_list|,
name|rt
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|troll_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|trollctl
operator|.
name|tr_ops
operator|&
name|TR_DUPPKT
condition|)
block|{
comment|/* 		 *	Duplicate every Nth packet 		 *	TODO: random? 		 */
name|float
name|f_freq
init|=
name|troll_cnt
operator|*
name|trollctl
operator|.
name|tr_dup_freq
decl_stmt|;
name|int
name|i_freq
init|=
name|troll_cnt
operator|*
name|trollctl
operator|.
name|tr_dup_freq
decl_stmt|;
if|if
condition|(
name|i_freq
operator|==
name|f_freq
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|dup
init|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
decl_stmt|;
if|if
condition|(
name|dup
operator|!=
name|NULL
condition|)
name|err
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|dup
argument_list|,
name|dst
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|trollctl
operator|.
name|tr_ops
operator|&
name|TR_DROPPKT
condition|)
block|{ 	}
elseif|else
if|if
condition|(
name|trollctl
operator|.
name|tr_ops
operator|&
name|TR_CHANGE
condition|)
block|{
name|struct
name|clnp_fixed
modifier|*
name|clnp
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|clnp_fixed
operator|*
argument_list|)
decl_stmt|;
name|clnp
operator|->
name|cnf_cksum_msb
operator|=
literal|0
expr_stmt|;
name|err
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
else|else
block|{
name|err
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|TROLL
end_endif

end_unit

