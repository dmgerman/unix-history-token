begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1991 by AT&T Bell Laboratories and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T Bell Laboratories or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"iob.h"
end_include

begin_define
define|#
directive|define
name|MEMBSIZE
value|32000
end_define

begin_define
define|#
directive|define
name|GMEMBSIZE
value|16000
end_define

begin_function_decl
specifier|extern
name|void
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|char
modifier|*
name|gmem
parameter_list|(
name|n
parameter_list|,
name|round
parameter_list|)
name|int
name|n
decl_stmt|,
name|round
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|last
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|rv
decl_stmt|;
if|if
condition|(
name|round
condition|)
ifdef|#
directive|ifdef
name|CRAY
if|if
condition|(
operator|(
name|long
operator|)
name|next
operator|&
literal|0xe000000000000000
condition|)
name|next
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|)
name|next
operator|&
literal|0x1fffffffffffffff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
operator|(
name|int
operator|)
name|next
operator|&
literal|1
condition|)
name|next
operator|++
expr_stmt|;
else|#
directive|else
name|next
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|)
name|next
operator|+
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|rv
operator|=
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|next
operator|+=
name|n
operator|)
operator|>
name|last
condition|)
block|{
name|rv
operator|=
name|Alloc
argument_list|(
name|n
operator|+
name|GMEMBSIZE
argument_list|)
expr_stmt|;
name|next
operator|=
name|rv
operator|+
name|n
expr_stmt|;
name|last
operator|=
name|next
operator|+
name|GMEMBSIZE
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_struct
struct|struct
name|memblock
block|{
name|struct
name|memblock
modifier|*
name|next
decl_stmt|;
name|char
name|buf
index|[
name|MEMBSIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|memblock
name|memblock
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|memblock
modifier|*
name|mem0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|memblock
modifier|*
name|curmemblock
decl_stmt|,
modifier|*
name|firstmemblock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mem_first
decl_stmt|,
modifier|*
name|mem_next
decl_stmt|,
modifier|*
name|mem_last
decl_stmt|,
modifier|*
name|mem0_last
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|mem_init
parameter_list|()
block|{
name|curmemblock
operator|=
name|firstmemblock
operator|=
name|mem0
operator|=
operator|(
name|memblock
operator|*
operator|)
name|Alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|memblock
argument_list|)
argument_list|)
expr_stmt|;
name|mem_first
operator|=
name|mem0
operator|->
name|buf
expr_stmt|;
name|mem_next
operator|=
name|mem0
operator|->
name|buf
expr_stmt|;
name|mem_last
operator|=
name|mem0
operator|->
name|buf
operator|+
name|MEMBSIZE
expr_stmt|;
name|mem0_last
operator|=
name|mem0
operator|->
name|buf
operator|+
name|MEMBSIZE
expr_stmt|;
name|mem0
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|mem
parameter_list|(
name|n
parameter_list|,
name|round
parameter_list|)
name|int
name|n
decl_stmt|,
name|round
decl_stmt|;
block|{
name|memblock
modifier|*
name|b
decl_stmt|;
specifier|register
name|char
modifier|*
name|rv
decl_stmt|,
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|round
condition|)
ifdef|#
directive|ifdef
name|CRAY
if|if
condition|(
operator|(
name|long
operator|)
name|mem_next
operator|&
literal|0xe000000000000000
condition|)
name|mem_next
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|)
name|mem_next
operator|&
literal|0x1fffffffffffffff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
operator|(
name|int
operator|)
name|mem_next
operator|&
literal|1
condition|)
name|mem_next
operator|++
expr_stmt|;
else|#
directive|else
name|mem_next
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|)
name|mem_next
operator|+
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|rv
operator|=
name|mem_next
expr_stmt|;
name|s
operator|=
name|rv
operator|+
name|n
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|mem_last
condition|)
block|{
if|if
condition|(
name|n
operator|>
name|MEMBSIZE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mem(%d) failure!\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|b
operator|=
name|curmemblock
operator|->
name|next
operator|)
condition|)
block|{
name|b
operator|=
operator|(
name|memblock
operator|*
operator|)
name|Alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|memblock
argument_list|)
argument_list|)
expr_stmt|;
name|curmemblock
operator|->
name|next
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
name|curmemblock
operator|=
name|b
expr_stmt|;
name|rv
operator|=
name|b
operator|->
name|buf
expr_stmt|;
name|mem_last
operator|=
name|rv
operator|+
sizeof|sizeof
argument_list|(
name|b
operator|->
name|buf
argument_list|)
expr_stmt|;
name|s
operator|=
name|rv
operator|+
name|n
expr_stmt|;
block|}
name|mem_next
operator|=
name|s
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|tostring
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|se
decl_stmt|,
modifier|*
modifier|*
name|sf
decl_stmt|;
name|char
modifier|*
name|rv
decl_stmt|,
modifier|*
name|s0
decl_stmt|;
specifier|register
name|int
name|k
init|=
name|n
operator|+
literal|2
decl_stmt|,
name|t
decl_stmt|;
name|sf
operator|=
name|str_fmt
expr_stmt|;
name|sf
index|[
literal|'%'
index|]
operator|=
literal|"%"
expr_stmt|;
name|s0
operator|=
name|s
expr_stmt|;
name|se
operator|=
name|s
operator|+
name|n
expr_stmt|;
for|for
control|(
init|;
name|s
operator|<
name|se
condition|;
name|s
operator|++
control|)
block|{
name|t
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
expr_stmt|;
name|s1
operator|=
name|sf
index|[
name|t
index|]
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s1
condition|)
name|k
operator|++
expr_stmt|;
block|}
name|sf
index|[
literal|'%'
index|]
operator|=
literal|"%%"
expr_stmt|;
name|rv
operator|=
name|s1
operator|=
name|mem
argument_list|(
name|k
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
literal|'"'
expr_stmt|;
for|for
control|(
name|s
operator|=
name|s0
init|;
name|s
operator|<
name|se
condition|;
name|s
operator|++
control|)
block|{
name|t
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
expr_stmt|;
name|sprintf
argument_list|(
name|s1
argument_list|,
name|sf
index|[
name|t
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|s1
operator|+=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
block|}
operator|*
name|s1
operator|=
literal|0
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|cpstring
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|strcpy
argument_list|(
name|mem
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|new_iob_data
parameter_list|(
name|ios
parameter_list|,
name|name
parameter_list|)
specifier|register
name|io_setup
modifier|*
name|ios
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|iob_data
modifier|*
name|iod
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|s
decl_stmt|,
modifier|*
modifier|*
name|se
decl_stmt|;
name|iod
operator|=
operator|(
name|iob_data
operator|*
operator|)
name|mem
argument_list|(
sizeof|sizeof
argument_list|(
name|iob_data
argument_list|)
operator|+
name|ios
operator|->
name|nelt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iod
operator|->
name|next
operator|=
name|iob_list
expr_stmt|;
name|iob_list
operator|=
name|iod
expr_stmt|;
name|iod
operator|->
name|type
operator|=
name|ios
operator|->
name|fields
index|[
literal|0
index|]
expr_stmt|;
name|iod
operator|->
name|name
operator|=
name|cpstring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|s
operator|=
name|iod
operator|->
name|fields
expr_stmt|;
name|se
operator|=
name|s
operator|+
name|ios
operator|->
name|nelt
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|se
condition|)
operator|*
name|s
operator|++
operator|=
literal|"0"
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|string_num
parameter_list|(
name|pfx
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|pfx
decl_stmt|;
name|long
name|n
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%ld"
argument_list|,
name|pfx
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* can't trust return type of sprintf -- BSD gets it wrong */
return|return
name|strcpy
argument_list|(
name|mem
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|defines
modifier|*
name|define_list
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|def_start
parameter_list|(
name|outfile
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|,
name|post
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|post
decl_stmt|;
end_function

begin_block
block|{
name|defines
modifier|*
name|d
decl_stmt|;
name|int
name|n
decl_stmt|,
name|n1
decl_stmt|;
specifier|extern
name|int
name|in_define
decl_stmt|;
name|n
operator|=
name|n1
operator|=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
condition|)
name|n
operator|+=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|defines
operator|*
operator|)
name|mem
argument_list|(
sizeof|sizeof
argument_list|(
name|defines
argument_list|)
operator|+
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|define_list
expr_stmt|;
name|define_list
operator|=
name|d
expr_stmt|;
name|strcpy
argument_list|(
name|d
operator|->
name|defname
argument_list|,
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
condition|)
name|strcpy
argument_list|(
name|d
operator|->
name|defname
operator|+
name|n1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|in_define
operator|=
literal|1
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"#define %s"
argument_list|,
name|d
operator|->
name|defname
argument_list|)
expr_stmt|;
if|if
condition|(
name|post
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" %s"
argument_list|,
name|post
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|other_undefs
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|defines
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|d
operator|=
name|define_list
condition|)
block|{
name|define_list
operator|=
literal|0
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
do|do
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"#undef %s\n"
argument_list|,
name|d
operator|->
name|defname
argument_list|)
expr_stmt|;
do|while
condition|(
name|d
operator|=
name|d
operator|->
name|next
condition|)
do|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

