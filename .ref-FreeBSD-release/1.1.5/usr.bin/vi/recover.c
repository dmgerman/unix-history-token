begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)recover.c	8.50 (Berkeley) 3/23/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/*  * We include<sys/file.h>, because the flock(2) #defines were  * found there on historical systems.  We also include<fcntl.h>  * because the open(2) #defines are found there on newer systems.  */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_comment
comment|/* MAXHOSTNAMELEN on some systems. */
end_comment

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<pathnames.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_comment
comment|/*  * Recovery code.  *  * The basic scheme is there's a btree file, whose name we specify.  The first  * time a file is modified, and then at RCV_PERIOD intervals after that, the  * btree file is synced to disk.  Each time a keystroke is requested for a file  * the terminal routines check to see if the file needs to be synced.  This, of  * course means that the data structures had better be consistent each time the  * key routines are called.  *  * We don't use timers other than to flag that the file should be synced.  This  * would require that the SCR and EXF data structures be locked, the dbopen(3)  * routines lock out the timers for each update, etc.  It's just not worth it.  * The only way we can lose in the current scheme is if the file is saved, then  * the user types furiously for RCV_PERIOD - 1 seconds, and types nothing more.  * Not likely.  *  * When a file is first modified, a file which can be handed off to the mailer  * is created.  The file contains normal headers, with two additions, which  * occur in THIS order, as the FIRST TWO headers:  *  *	Vi-recover-file: file_name  *	Vi-recover-path: recover_path  *  * Since newlines delimit the headers, this means that file names cannot  * have newlines in them, but that's probably okay.  *  * Btree files are named "vi.XXXX" and recovery files are named "recover.XXXX".  */
end_comment

begin_define
define|#
directive|define
name|VI_FHEADER
value|"Vi-recover-file: "
end_define

begin_define
define|#
directive|define
name|VI_PHEADER
value|"Vi-recover-path: "
end_define

begin_decl_stmt
specifier|static
name|int
name|rcv_mailfile
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcv_syncit
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * rcv_tmp --  *	Build a file name that will be used as the recovery file.  */
end_comment

begin_function
name|int
name|rcv_tmp
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|name
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* 	 * If the recovery directory doesn't exist, try and create it.  As 	 * the recovery files are themselves protected from reading/writing 	 * by other than the owner, the worst that can happen is that a user 	 * would have permission to remove other users recovery files.  If 	 * the sticky bit has the BSD semantics, that too will be impossible. 	 */
name|dp
operator|=
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dp
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
operator|||
name|mkdir
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Error: %s: %s"
argument_list|,
name|dp
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|dp
argument_list|,
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
operator||
name|S_ISVTX
argument_list|)
expr_stmt|;
block|}
comment|/* Newlines delimit the mail messages. */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Files with newlines in the name are unrecoverable."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/vi.XXXXXX"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* 	 * !!! 	 * We depend on mkstemp(3) setting the permissions correctly. 	 * GP's, we do it ourselves, to keep the window as small as 	 * possible. 	 */
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|path
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Error: %s: %s"
argument_list|,
name|dp
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|path
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|rcv_path
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* We believe the file is recoverable. */
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_RCV_ON
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rcv_init --  *	Force the file to be snapshotted for recovery.  */
end_comment

begin_function
name|int
name|rcv_init
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|recno_t
name|lno
decl_stmt|;
name|int
name|btear
decl_stmt|;
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_FIRSTMODIFY
operator||
name|F_RCV_ON
argument_list|)
expr_stmt|;
comment|/* 	 * If not already recoverying a file, build a file to mail 	 * to the user. 	 */
if|if
condition|(
name|ep
operator|->
name|rcv_mpath
operator|==
name|NULL
operator|&&
name|rcv_mailfile
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Force read of entire file. */
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Turn on a busy message, and sync it to backing store. */
name|btear
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_EXSILENT
argument_list|)
condition|?
literal|0
else|:
operator|!
name|busy_on
argument_list|(
name|sp
argument_list|,
literal|"Copying file for recovery..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|db
operator|->
name|sync
argument_list|(
name|ep
operator|->
name|db
argument_list|,
name|R_RECNOSYNC
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Preservation failed: %s: %s"
argument_list|,
name|ep
operator|->
name|rcv_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|btear
condition|)
name|busy_off
argument_list|(
name|sp
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|btear
condition|)
name|busy_off
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_RECOVER_SET
argument_list|)
operator|&&
name|rcv_on
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
block|{
name|err
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Recovery after system crash not possible."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* We believe the file is recoverable. */
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_RCV_ON
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rcv_mailfile --  *	Build the file to mail to the user.  */
end_comment

begin_function
specifier|static
name|int
name|rcv_mailfile
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|,
name|host
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|,
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
operator|=
name|getuid
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Information on user id %u not found."
argument_list|,
name|uid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/recover.XXXXXX"
argument_list|,
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|path
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Error: %s: %s"
argument_list|,
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * We keep an open lock on the file so that the recover option can 	 * distinguish between files that are live and those that need to 	 * be recovered.  There's an obvious window between the mkstemp call 	 * and the lock, but it's pretty small. 	 */
if|if
condition|(
operator|(
name|ep
operator|->
name|rcv_fd
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
name|flock
argument_list|(
name|ep
operator|->
name|rcv_fd
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"Unable to lock recovery file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|rcv_mpath
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|t
operator|=
name|FILENAME
argument_list|(
name|sp
operator|->
name|frp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|t
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
name|t
expr_stmt|;
else|else
operator|++
name|p
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gethostname
argument_list|(
name|host
argument_list|,
sizeof|sizeof
argument_list|(
name|host
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s%s\n%s%s\n%s\n%s\n%s%s\n%s%s\n%s\n\n"
argument_list|,
name|VI_FHEADER
argument_list|,
name|p
argument_list|,
comment|/* Non-standard. */
name|VI_PHEADER
argument_list|,
name|ep
operator|->
name|rcv_path
argument_list|,
comment|/* Non-standard. */
literal|"Reply-To: root"
argument_list|,
literal|"From: root (Nvi recovery program)"
argument_list|,
literal|"To: "
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
literal|"Subject: Nvi saved the file "
argument_list|,
name|p
argument_list|,
literal|"Precedence: bulk"
argument_list|)
expr_stmt|;
comment|/* For vacation(1). */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s%.24s%s%s\n%s%s"
argument_list|,
literal|"On "
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|,
literal|", the user "
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
literal|"was editing a file named "
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|t
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" (%s)"
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n%s%s%s\n"
argument_list|,
literal|"on the machine "
argument_list|,
name|host
argument_list|,
literal|", when it was saved for\nrecovery."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n%s\n%s\n%s\n\n"
argument_list|,
literal|"You can recover most, if not all, of the changes"
argument_list|,
literal|"to this file using the -l and -r options to nvi(1)"
argument_list|,
literal|"or nex(1)."
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|fp
argument_list|)
operator|||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rcv_sync --  *	Sync the backing file.  */
end_comment

begin_function
name|int
name|rcv_sync
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
if|if
condition|(
name|ep
operator|->
name|db
operator|->
name|sync
argument_list|(
name|ep
operator|->
name|db
argument_list|,
name|R_RECNOSYNC
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_RCV_ON
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Automatic file backup failed: %s: %s"
argument_list|,
name|ep
operator|->
name|rcv_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rcv_hup --  *	Recovery SIGHUP interrupt handler.  (Modem line dropped, or  *	xterm window closed.)  */
end_comment

begin_function
name|void
name|rcv_hup
parameter_list|()
block|{
name|SCR
modifier|*
name|sp
decl_stmt|;
comment|/* 	 * Walk the lists of screens, sync'ing the files; only sync 	 * each file once.  Send email to the user for each file saved. 	 */
for|for
control|(
name|sp
operator|=
name|__global_list
operator|->
name|dq
operator|.
name|cqh_first
init|;
name|sp
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|__global_list
operator|->
name|dq
condition|;
name|sp
operator|=
name|sp
operator|->
name|q
operator|.
name|cqe_next
control|)
name|rcv_syncit
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|__global_list
operator|->
name|hq
operator|.
name|cqh_first
init|;
name|sp
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|__global_list
operator|->
name|hq
condition|;
name|sp
operator|=
name|sp
operator|->
name|q
operator|.
name|cqe_next
control|)
name|rcv_syncit
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Die with the proper exit status.  Don't bother using 	 * sigaction(2) 'cause we want the default behavior. 	 */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rcv_term --  *	Recovery SIGTERM interrupt handler.  (Reboot or halt is running.)  */
end_comment

begin_function
name|void
name|rcv_term
parameter_list|()
block|{
name|SCR
modifier|*
name|sp
decl_stmt|;
comment|/* 	 * Walk the lists of screens, sync'ing the files; only sync 	 * each file once. 	 */
for|for
control|(
name|sp
operator|=
name|__global_list
operator|->
name|dq
operator|.
name|cqh_first
init|;
name|sp
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|__global_list
operator|->
name|dq
condition|;
name|sp
operator|=
name|sp
operator|->
name|q
operator|.
name|cqe_next
control|)
name|rcv_syncit
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|__global_list
operator|->
name|hq
operator|.
name|cqh_first
init|;
name|sp
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|__global_list
operator|->
name|hq
condition|;
name|sp
operator|=
name|sp
operator|->
name|q
operator|.
name|cqe_next
control|)
name|rcv_syncit
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Die with the proper exit status.  Don't bother using 	 * sigaction(2) 'cause we want the default behavior. 	 */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rcv_syncit --  *	Sync the file, optionally send mail.  */
end_comment

begin_function
specifier|static
name|void
name|rcv_syncit
parameter_list|(
name|sp
parameter_list|,
name|email
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|email
decl_stmt|;
block|{
name|EXF
modifier|*
name|ep
decl_stmt|;
name|char
name|comm
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ep
operator|=
name|sp
operator|->
name|ep
operator|)
operator|==
name|NULL
operator|||
operator|!
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
operator|||
operator|!
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_RCV_ON
argument_list|)
condition|)
return|return;
operator|(
name|void
operator|)
name|ep
operator|->
name|db
operator|->
name|sync
argument_list|(
name|ep
operator|->
name|db
argument_list|,
name|R_RECNOSYNC
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_RCV_NORM
argument_list|)
expr_stmt|;
comment|/* 	 * !!! 	 * If you need to port this to a system that doesn't have sendmail, 	 * the -t flag being used causes sendmail to read the message for 	 * the recipients instead of us specifying them some other way. 	 */
if|if
condition|(
name|email
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|comm
argument_list|,
sizeof|sizeof
argument_list|(
name|comm
argument_list|)
argument_list|,
literal|"%s -t< %s"
argument_list|,
name|_PATH_SENDMAIL
argument_list|,
name|ep
operator|->
name|rcv_mpath
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|system
argument_list|(
name|comm
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|file_end
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	people making love  *	never exactly the same  *	just like a snowflake  *  * rcv_list --  *	List the files that can be recovered by this user.  */
end_comment

begin_function
name|int
name|rcv_list
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|found
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|file
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|)
argument_list|)
operator|||
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vi: %s: %s\n"
argument_list|,
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|found
operator|=
literal|0
init|;
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"recover."
argument_list|,
literal|8
argument_list|)
condition|)
continue|continue;
comment|/* If it's readable, it's recoverable. */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* If it's locked, it's live. */
if|if
condition|(
name|flock
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Check the header, get the file name. */
if|if
condition|(
name|fgets
argument_list|(
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|file
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|file
argument_list|,
name|VI_FHEADER
argument_list|,
sizeof|sizeof
argument_list|(
name|VI_FHEADER
argument_list|)
operator|-
literal|1
argument_list|)
operator|||
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|file
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vi: %s: malformed recovery file.\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get the last modification time. */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vi: %s: %s\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* Display. */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: %s"
argument_list|,
name|file
operator|+
sizeof|sizeof
argument_list|(
name|VI_FHEADER
argument_list|)
operator|-
literal|1
argument_list|,
name|ctime
argument_list|(
operator|&
name|sb
operator|.
name|st_mtime
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
name|next
label|:
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"vi: no files to recover.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rcv_read --  *	Start a recovered file as the file to edit.  */
end_comment

begin_function
name|int
name|rcv_read
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|FREF
modifier|*
name|frp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|sv_fp
decl_stmt|;
name|time_t
name|rec_mtime
decl_stmt|;
name|int
name|found
decl_stmt|,
name|requested
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|recp
decl_stmt|,
modifier|*
name|pathp
decl_stmt|;
name|char
name|recpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|file
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: %s"
argument_list|,
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sv_fp
operator|=
name|NULL
expr_stmt|;
name|rec_mtime
operator|=
literal|0
expr_stmt|;
name|recp
operator|=
name|pathp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|found
operator|=
name|requested
operator|=
literal|0
init|;
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"recover."
argument_list|,
literal|8
argument_list|)
condition|)
continue|continue;
comment|/* If it's readable, it's recoverable. */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|recpath
argument_list|,
sizeof|sizeof
argument_list|(
name|recpath
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|)
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|recpath
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* If it's locked, it's live. */
if|if
condition|(
name|flock
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Check the headers. */
if|if
condition|(
name|fgets
argument_list|(
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|file
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|file
argument_list|,
name|VI_FHEADER
argument_list|,
sizeof|sizeof
argument_list|(
name|VI_FHEADER
argument_list|)
operator|-
literal|1
argument_list|)
operator|||
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|file
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|fgets
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|path
argument_list|,
name|VI_PHEADER
argument_list|,
sizeof|sizeof
argument_list|(
name|VI_PHEADER
argument_list|)
operator|-
literal|1
argument_list|)
operator|||
operator|(
name|t
operator|=
name|strchr
argument_list|(
name|path
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: malformed recovery file."
argument_list|,
name|recpath
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
operator|++
name|found
expr_stmt|;
operator|*
name|t
operator|=
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get the last modification time. */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"vi: %s: %s"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* Check the file name. */
if|if
condition|(
name|strcmp
argument_list|(
name|file
operator|+
sizeof|sizeof
argument_list|(
name|VI_FHEADER
argument_list|)
operator|-
literal|1
argument_list|,
name|name
argument_list|)
condition|)
goto|goto
name|next
goto|;
operator|++
name|requested
expr_stmt|;
comment|/* If we've found more than one, take the most recent. */
if|if
condition|(
name|recp
operator|==
name|NULL
operator|||
name|rec_mtime
operator|<
name|sb
operator|.
name|st_mtime
condition|)
block|{
name|p
operator|=
name|recp
expr_stmt|;
name|t
operator|=
name|pathp
expr_stmt|;
if|if
condition|(
operator|(
name|recp
operator|=
name|strdup
argument_list|(
name|recpath
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"vi: Error: %s.\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|recp
operator|=
name|p
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
operator|(
name|pathp
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"vi: Error: %s.\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|recp
argument_list|,
name|strlen
argument_list|(
name|recp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|recp
operator|=
name|p
expr_stmt|;
name|pathp
operator|=
name|t
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|t
argument_list|,
name|strlen
argument_list|(
name|t
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|rec_mtime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|sv_fp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|sv_fp
argument_list|)
expr_stmt|;
name|sv_fp
operator|=
name|fp
expr_stmt|;
block|}
else|else
name|next
label|:
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recp
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"No files named %s, owned by you, to edit."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|requested
operator|>
literal|1
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"There are older versions of this file for you to recover."
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|>
name|requested
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"There are other files for you to recover."
argument_list|)
expr_stmt|;
block|}
comment|/* Create the FREF structure, start the btree file. */
if|if
condition|(
operator|(
name|frp
operator|=
name|file_add
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|file_init
argument_list|(
name|sp
argument_list|,
name|frp
argument_list|,
name|pathp
operator|+
sizeof|sizeof
argument_list|(
name|VI_PHEADER
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|FREE
argument_list|(
name|recp
argument_list|,
name|strlen
argument_list|(
name|recp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pathp
argument_list|,
name|strlen
argument_list|(
name|pathp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|sv_fp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * We keep an open lock on the file so that the recover option can 	 * distinguish between files that are live and those that need to 	 * be recovered.  The lock is already acquired, so just get a copy. 	 */
if|if
condition|(
operator|(
name|sp
operator|->
name|ep
operator|->
name|rcv_fd
operator|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|sv_fp
argument_list|)
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|sv_fp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|ep
operator|->
name|rcv_mpath
operator|=
name|recp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

