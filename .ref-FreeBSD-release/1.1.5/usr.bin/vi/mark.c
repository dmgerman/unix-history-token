begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)mark.c	8.17 (Berkeley) 3/15/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_decl_stmt
specifier|static
name|LMARK
modifier|*
name|mark_find
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|ARG_CHAR_T
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Marks are maintained in a key sorted doubly linked list.  We can't  * use arrays because we have no idea how big an index key could be.  * The underlying assumption is that users don't have more than, say,  * 10 marks at any one time, so this will be is fast enough.  *  * Marks are fixed, and modifications to the line don't update the mark's  * position in the line.  This can be hard.  If you add text to the line,  * place a mark in that text, undo the addition and use ` to move to the  * mark, the location will have disappeared.  It's tempting to try to adjust  * the mark with the changes in the line, but this is hard to do, especially  * if we've given the line to v_ntext.c:v_ntext() for editing.  Historic vi  * would move to the first non-blank on the line when the mark location was  * past the end of the line.  This can be complicated by deleting to a mark  * that has disappeared using the ` command.  Historic vi vi treated this as  * a line-mode motion and deleted the line.  This implementation complains to  * the user.  *  * In historic vi, marks returned if the operation was undone, unless the  * mark had been subsequently reset.  Tricky.  This is hard to start with,  * but in the presence of repeated undo it gets nasty.  When a line is  * deleted, we delete (and log) any marks on that line.  An undo will create  * the mark.  Any mark creations are noted as to whether the user created  * it or if it was created by an undo.  The former cannot be reset by another  * undo, but the latter may.  *  * All of these routines translate ABSMARK2 to ABSMARK1.  Setting either of  * the absolute mark locations sets both, so that "m'" and "m`" work like  * they, ah, for lack of a better word, "should".  */
end_comment

begin_comment
comment|/*  * mark_init --  *	Set up the marks.  */
end_comment

begin_function
name|int
name|mark_init
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|LMARK
modifier|*
name|lmp
decl_stmt|;
comment|/* 	 * Make sure the marks have been set up.  If they 	 * haven't, do so, and create the absolute mark. 	 */
name|MALLOC_RET
argument_list|(
name|sp
argument_list|,
name|lmp
argument_list|,
name|LMARK
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|LMARK
argument_list|)
argument_list|)
expr_stmt|;
name|lmp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|lmp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
name|lmp
operator|->
name|name
operator|=
name|ABSMARK1
expr_stmt|;
name|lmp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ep
operator|->
name|marks
argument_list|,
name|lmp
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mark_end --  *	Free up the marks.  */
end_comment

begin_function
name|int
name|mark_end
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|LMARK
modifier|*
name|lmp
decl_stmt|;
while|while
condition|(
operator|(
name|lmp
operator|=
name|ep
operator|->
name|marks
operator|.
name|lh_first
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|lmp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|lmp
argument_list|,
sizeof|sizeof
argument_list|(
name|LMARK
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mark_get --  *	Get the location referenced by a mark.  */
end_comment

begin_function
name|int
name|mark_get
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|key
parameter_list|,
name|mp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|ARG_CHAR_T
name|key
decl_stmt|;
name|MARK
modifier|*
name|mp
decl_stmt|;
block|{
name|LMARK
modifier|*
name|lmp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|ABSMARK2
condition|)
name|key
operator|=
name|ABSMARK1
expr_stmt|;
name|lmp
operator|=
name|mark_find
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|==
name|NULL
operator|||
name|lmp
operator|->
name|name
operator|!=
name|key
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"Mark %s: not set."
argument_list|,
name|charname
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|F_ISSET
argument_list|(
name|lmp
argument_list|,
name|MARK_DELETED
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"Mark %s: the line was deleted."
argument_list|,
name|charname
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lmp
operator|->
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|==
name|NULL
operator|||
name|lmp
operator|->
name|cno
operator|>
name|len
operator|||
name|lmp
operator|->
name|cno
operator|==
name|len
operator|&&
name|len
operator|!=
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"Mark %s: cursor position no longer exists."
argument_list|,
name|charname
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|mp
operator|->
name|lno
operator|=
name|lmp
operator|->
name|lno
expr_stmt|;
name|mp
operator|->
name|cno
operator|=
name|lmp
operator|->
name|cno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mark_set --  *	Set the location referenced by a mark.  */
end_comment

begin_function
name|int
name|mark_set
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|key
parameter_list|,
name|value
parameter_list|,
name|userset
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|ARG_CHAR_T
name|key
decl_stmt|;
name|MARK
modifier|*
name|value
decl_stmt|;
name|int
name|userset
decl_stmt|;
block|{
name|LMARK
modifier|*
name|lmp
decl_stmt|,
modifier|*
name|lmt
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|ABSMARK2
condition|)
name|key
operator|=
name|ABSMARK1
expr_stmt|;
comment|/* 	 * The rules are simple.  If the user is setting a mark (if it's a 	 * new mark this is always true), it always happens.  If not, it's 	 * an undo, and we set it if it's not already set or if it was set 	 * by a previous undo. 	 */
name|lmp
operator|=
name|mark_find
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|==
name|NULL
operator|||
name|lmp
operator|->
name|name
operator|!=
name|key
condition|)
block|{
name|MALLOC_RET
argument_list|(
name|sp
argument_list|,
name|lmt
argument_list|,
name|LMARK
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|LMARK
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ep
operator|->
name|marks
argument_list|,
name|lmt
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|LIST_INSERT_AFTER
argument_list|(
name|lmp
argument_list|,
name|lmt
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|lmp
operator|=
name|lmt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|userset
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|lmp
argument_list|,
name|MARK_DELETED
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|lmp
argument_list|,
name|MARK_USERSET
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lmp
operator|->
name|lno
operator|=
name|value
operator|->
name|lno
expr_stmt|;
name|lmp
operator|->
name|cno
operator|=
name|value
operator|->
name|cno
expr_stmt|;
name|lmp
operator|->
name|name
operator|=
name|key
expr_stmt|;
name|lmp
operator|->
name|flags
operator|=
name|userset
condition|?
name|MARK_USERSET
else|:
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mark_find --  *	Find the requested mark, or, the slot immediately before  *	where it would go.  */
end_comment

begin_function
specifier|static
name|LMARK
modifier|*
name|mark_find
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|key
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|ARG_CHAR_T
name|key
decl_stmt|;
block|{
name|LMARK
modifier|*
name|lmp
decl_stmt|,
modifier|*
name|lastlmp
decl_stmt|;
comment|/* 	 * Return the requested mark or the slot immediately before 	 * where it should go. 	 */
for|for
control|(
name|lastlmp
operator|=
name|NULL
operator|,
name|lmp
operator|=
name|ep
operator|->
name|marks
operator|.
name|lh_first
init|;
name|lmp
operator|!=
name|NULL
condition|;
name|lastlmp
operator|=
name|lmp
operator|,
name|lmp
operator|=
name|lmp
operator|->
name|q
operator|.
name|le_next
control|)
if|if
condition|(
name|lmp
operator|->
name|name
operator|>=
name|key
condition|)
return|return
operator|(
name|lmp
operator|->
name|name
operator|==
name|key
condition|?
name|lmp
else|:
name|lastlmp
operator|)
return|;
return|return
operator|(
name|lastlmp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mark_insdel --  *	Update the marks based on an insertion or deletion.  */
end_comment

begin_function
name|void
name|mark_insdel
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|op
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|enum
name|operation
name|op
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
name|LMARK
modifier|*
name|lmp
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|LINE_APPEND
case|:
return|return;
case|case
name|LINE_DELETE
case|:
for|for
control|(
name|lmp
operator|=
name|ep
operator|->
name|marks
operator|.
name|lh_first
init|;
name|lmp
operator|!=
name|NULL
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|q
operator|.
name|le_next
control|)
if|if
condition|(
name|lmp
operator|->
name|lno
operator|>=
name|lno
condition|)
if|if
condition|(
name|lmp
operator|->
name|lno
operator|==
name|lno
condition|)
block|{
name|F_SET
argument_list|(
name|lmp
argument_list|,
name|MARK_DELETED
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|log_mark
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lmp
argument_list|)
expr_stmt|;
block|}
else|else
operator|--
name|lmp
operator|->
name|lno
expr_stmt|;
return|return;
case|case
name|LINE_INSERT
case|:
for|for
control|(
name|lmp
operator|=
name|ep
operator|->
name|marks
operator|.
name|lh_first
init|;
name|lmp
operator|!=
name|NULL
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|q
operator|.
name|le_next
control|)
if|if
condition|(
name|lmp
operator|->
name|lno
operator|>=
name|lno
condition|)
operator|++
name|lmp
operator|->
name|lno
expr_stmt|;
return|return;
case|case
name|LINE_RESET
case|:
return|return;
block|}
comment|/* NOTREACHED */
block|}
end_function

end_unit

