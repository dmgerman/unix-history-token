begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)v_ntext.c	8.95 (Berkeley) 3/24/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"seq.h"
end_include

begin_include
include|#
directive|include
file|"vcmd.h"
end_include

begin_include
include|#
directive|include
file|"excmd.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|txt_abbrev
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|CHAR_T
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|txt_ai_resolve
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TEXT
modifier|*
name|txt_backup
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|TEXTH
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|txt_err
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|TEXTH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_hex
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|int
operator|*
operator|,
name|CHAR_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_indent
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_margin
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|int
operator|*
operator|,
name|CHAR_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_outdent
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|txt_showmatch
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|txt_Rcleanup
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXTH
operator|*
operator|,
name|TEXT
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|txt_resolve
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|TEXTH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|txt_unmap
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|,
name|u_int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cursor character (space is hard to track on the screen). */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
end_if

begin_undef
undef|#
directive|undef
name|CURSOR_CH
end_undef

begin_define
define|#
directive|define
name|CURSOR_CH
value|'+'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Local version of BINC. */
end_comment

begin_define
define|#
directive|define
name|TBINC
parameter_list|(
name|sp
parameter_list|,
name|lp
parameter_list|,
name|llen
parameter_list|,
name|nlen
parameter_list|)
value|{					\ 	if ((nlen)> llen&& binc(sp,&(lp),&(llen), nlen))		\ 		goto err;						\ }
end_define

begin_comment
comment|/*  * v_ntext --  *	Read in text from the user.  *  * !!!  * Historic vi did a special screen optimization for tab characters.  For  * the keystrokes "iabcd<esc>0C<tab>", the tab would overwrite the rest of  * the string when it was displayed.  Because this implementation redisplays  * the entire line on each keystroke, the "bcd" gets pushed to the right as  * we ignore that the user has "promised" to change the rest of the characters.  * Users have noticed, but this isn't worth fixing, and, the way that the  * historic vi did it results in an even worse bug.  Given the keystrokes  * "iabcd<esc>0R<tab><esc>", the "bcd" disappears, and magically reappears  * on the second<esc> key.  */
end_comment

begin_function
name|int
name|v_ntext
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|tiqh
parameter_list|,
name|tm
parameter_list|,
name|lp
parameter_list|,
name|len
parameter_list|,
name|rp
parameter_list|,
name|prompt
parameter_list|,
name|ai_line
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|TEXTH
modifier|*
name|tiqh
decl_stmt|;
name|MARK
modifier|*
name|tm
decl_stmt|;
comment|/* To MARK. */
specifier|const
name|char
modifier|*
name|lp
decl_stmt|;
comment|/* Input line. */
specifier|const
name|size_t
name|len
decl_stmt|;
comment|/* Input line length. */
name|MARK
modifier|*
name|rp
decl_stmt|;
comment|/* Return MARK. */
name|int
name|prompt
decl_stmt|;
comment|/* Prompt to display. */
name|recno_t
name|ai_line
decl_stmt|;
comment|/* Line number to use for autoindent count. */
name|u_int
name|flags
decl_stmt|;
comment|/* TXT_ flags. */
block|{
comment|/* State of abbreviation checks. */
enum|enum
block|{
name|A_NOTSET
block|,
name|A_NOTWORD
block|,
name|A_INWORD
block|}
name|abb
enum|;
comment|/* State of the "[^0]^D" sequences. */
enum|enum
block|{
name|C_NOTSET
block|,
name|C_CARATSET
block|,
name|C_NOCHANGE
block|,
name|C_ZEROSET
block|}
name|carat_st
enum|;
comment|/* State of the hex input character. */
enum|enum
block|{
name|H_NOTSET
block|,
name|H_NEXTCHAR
block|,
name|H_INHEX
block|}
name|hex
enum|;
comment|/* State of quotation. */
enum|enum
block|{
name|Q_NOTSET
block|,
name|Q_NEXTCHAR
block|,
name|Q_THISCHAR
block|}
name|quoted
enum|;
name|CH
name|ikey
decl_stmt|;
comment|/* Input character structure. */
name|CHAR_T
name|ch
decl_stmt|;
comment|/* Input character. */
name|TEXT
modifier|*
name|tp
decl_stmt|,
modifier|*
name|ntp
decl_stmt|,
name|ait
decl_stmt|;
comment|/* Input and autoindent text structures. */
name|size_t
name|rcol
decl_stmt|;
comment|/* 0-N: insert offset in the replay buffer. */
name|size_t
name|col
decl_stmt|;
comment|/* Current column. */
name|u_long
name|margin
decl_stmt|;
comment|/* Wrapmargin value. */
name|u_int
name|iflags
decl_stmt|;
comment|/* Input flags. */
name|int
name|ab_cnt
decl_stmt|,
name|ab_turnoff
decl_stmt|;
comment|/* Abbreviation count, if turned off. */
name|int
name|eval
decl_stmt|;
comment|/* Routine return value. */
name|int
name|replay
decl_stmt|;
comment|/* If replaying a set of input. */
name|int
name|showmatch
decl_stmt|;
comment|/* Showmatch set on this character. */
name|int
name|testnr
decl_stmt|;
comment|/* Test first character for nul replay. */
name|int
name|max
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|unmap_tst
decl_stmt|;
comment|/* Input map needs testing. */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Set the input flag, so tabs get displayed correctly 	 * and everyone knows that the text buffer is in use. 	 */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_INPUT
argument_list|)
expr_stmt|;
comment|/* Local initialization. */
name|eval
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get one TEXT structure with some initial buffer space, reusing 	 * the last one if it's big enough.  (All TEXT bookkeeping fields 	 * default to 0 -- text_init() handles this.)  If changing a line, 	 * copy it into the TEXT buffer. 	 */
if|if
condition|(
name|tiqh
operator|->
name|cqh_first
operator|!=
operator|(
name|void
operator|*
operator|)
name|tiqh
condition|)
block|{
name|tp
operator|=
name|tiqh
operator|->
name|cqh_first
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|q
operator|.
name|cqe_next
operator|!=
operator|(
name|void
operator|*
operator|)
name|tiqh
operator|||
name|tp
operator|->
name|lb_len
operator|<
name|len
operator|+
literal|32
condition|)
block|{
name|text_lfree
argument_list|(
name|tiqh
argument_list|)
expr_stmt|;
goto|goto
name|newtp
goto|;
block|}
name|tp
operator|->
name|ai
operator|=
name|tp
operator|->
name|insert
operator|=
name|tp
operator|->
name|offset
operator|=
name|tp
operator|->
name|owrite
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
block|{
name|tp
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|memmove
argument_list|(
name|tp
operator|->
name|lb
argument_list|,
name|lp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|newtp
label|:
if|if
condition|(
operator|(
name|tp
operator|=
name|text_init
argument_list|(
name|sp
argument_list|,
name|lp
argument_list|,
name|len
argument_list|,
name|len
operator|+
literal|32
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|CIRCLEQ_INSERT_HEAD
argument_list|(
name|tiqh
argument_list|,
name|tp
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* Set the starting line number. */
name|tp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
comment|/* 	 * Set the insert and overwrite counts.  If overwriting characters, 	 * do insertion afterward.  If not overwriting characters, assume 	 * doing insertion.  If change is to a mark, emphasize it with an 	 * END_CH. 	 */
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_OVERWRITE
argument_list|)
condition|)
block|{
name|tp
operator|->
name|owrite
operator|=
operator|(
name|tm
operator|->
name|cno
operator|-
name|sp
operator|->
name|cno
operator|)
operator|+
literal|1
expr_stmt|;
name|tp
operator|->
name|insert
operator|=
operator|(
name|len
operator|-
name|tm
operator|->
name|cno
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|insert
operator|=
name|len
operator|-
name|sp
operator|->
name|cno
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_EMARK
argument_list|)
condition|)
name|tp
operator|->
name|lb
index|[
name|tm
operator|->
name|cno
index|]
operator|=
name|END_CH
expr_stmt|;
block|}
comment|/* 	 * Many of the special cases in this routine are to handle autoindent 	 * support.  Somebody decided that it would be a good idea if "^^D" 	 * and "0^D" deleted all of the autoindented characters.  In an editor 	 * that takes single character input from the user, this beggars the 	 * imagination.  Note also, "^^D" resets the next lines' autoindent, 	 * but "0^D" doesn't. 	 * 	 * We assume that autoindent only happens on empty lines, so insert 	 * and overwrite will be zero.  If doing autoindent, figure out how 	 * much indentation we need and fill it in.  Update input column and 	 * screen cursor as necessary. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
operator|&&
name|ai_line
operator|!=
name|OOBLNO
condition|)
block|{
if|if
condition|(
name|txt_auto
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|ai_line
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|tp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sp
operator|->
name|cno
operator|=
name|tp
operator|->
name|ai
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The cc and S commands have a special feature -- leading 		 *<blank> characters are handled as autoindent characters. 		 * Beauty! 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AICHARS
argument_list|)
condition|)
block|{
name|tp
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|ai
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|offset
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
block|}
comment|/* If getting a command buffer from the user, there may be a prompt. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_PROMPT
argument_list|)
condition|)
block|{
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|++
index|]
operator|=
name|prompt
expr_stmt|;
operator|++
name|tp
operator|->
name|len
expr_stmt|;
operator|++
name|tp
operator|->
name|offset
expr_stmt|;
block|}
comment|/* 	 * If appending after the end-of-line, add a space into the buffer 	 * and move the cursor right.  This space is inserted, i.e. pushed 	 * along, and then deleted when the line is resolved.  Assumes that 	 * the cursor is already positioned at the end of the line.  This 	 * avoids the nastiness of having the cursor reside on a magical 	 * column, i.e. a column that doesn't really exist.  The only down 	 * side is that we may wrap lines or scroll the screen before it's 	 * strictly necessary.  Not a big deal. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_APPENDEOL
argument_list|)
condition|)
block|{
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
index|]
operator|=
name|CURSOR_CH
expr_stmt|;
operator|++
name|tp
operator|->
name|len
expr_stmt|;
operator|++
name|tp
operator|->
name|insert
expr_stmt|;
block|}
comment|/* 	 * Historic practice is that the wrapmargin value was a distance 	 * from the RIGHT-HAND column, not the left.  It's more useful to 	 * us as a distance from the left-hand column. 	 * 	 * !!! 	 * Replay commands are not affected by wrapmargin values.  What 	 * I found surprising was that people actually depend on it, as 	 * in this gem of a macro which centers lines: 	 * 	 *	map #c $mq81a ^V^[81^V|D`qld0:s/  / /g^V^M$p 	 * 	 * XXX 	 * Setting margin causes a significant performance hit.  Normally 	 * we don't update the screen if there are keys waiting, but we 	 * have to if margin is set, otherwise the screen routines don't 	 * know where the cursor is. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_REPLAY
argument_list|)
operator|||
operator|!
name|LF_ISSET
argument_list|(
name|TXT_WRAPMARGIN
argument_list|)
condition|)
name|margin
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|margin
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_WRAPMARGIN
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|margin
operator|=
name|sp
operator|->
name|cols
operator|-
name|margin
expr_stmt|;
comment|/* Initialize abbreviations checks. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_ABBREV
argument_list|)
operator|&&
name|LF_ISSET
argument_list|(
name|TXT_MAPINPUT
argument_list|)
condition|)
block|{
name|abb
operator|=
name|A_INWORD
expr_stmt|;
name|ab_cnt
operator|=
name|ab_turnoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|abb
operator|=
name|A_NOTSET
expr_stmt|;
comment|/* 	 * Set up the dot command.  Dot commands are done by saving the 	 * actual characters and replaying the input.  We have to push 	 * the characters onto the key stack and then handle them normally, 	 * otherwise things like wrapmargin will fail. 	 * 	 * XXX 	 * It would be nice if we could swallow backspaces and such, but 	 * it's not all that easy to do.  Another possibility would be to 	 * recognize full line insertions, which could be performed quickly, 	 * without replay. 	 */
name|nullreplay
label|:
name|rcol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|replay
operator|=
name|LF_ISSET
argument_list|(
name|TXT_REPLAY
argument_list|)
condition|)
block|{
comment|/* 		 * !!! 		 * Historically, it wasn't an error to replay non-existent 		 * input.  This test is necessary, we get here by the user 		 * doing an input command followed by a nul. 		 * 		 * !!! 		 * Historically, vi did not remap or reabbreviate replayed 		 * input.  It did, however, beep at you if you changed an 		 * abbreviation and then replayed the input.  We're not that 		 * compatible. 		 */
if|if
condition|(
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|rep
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|rep
argument_list|,
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|rep_cnt
argument_list|,
literal|0
argument_list|,
name|CH_NOMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|testnr
operator|=
literal|0
expr_stmt|;
name|abb
operator|=
name|A_NOTSET
expr_stmt|;
name|LF_CLR
argument_list|(
name|TXT_RECORD
argument_list|)
expr_stmt|;
block|}
else|else
name|testnr
operator|=
literal|1
expr_stmt|;
name|unmap_tst
operator|=
name|LF_ISSET
argument_list|(
name|TXT_MAPINPUT
argument_list|)
operator|&&
name|LF_ISSET
argument_list|(
name|TXT_INFOLINE
argument_list|)
expr_stmt|;
name|iflags
operator|=
name|LF_ISSET
argument_list|(
name|TXT_MAPCOMMAND
operator||
name|TXT_MAPINPUT
argument_list|)
expr_stmt|;
for|for
control|(
name|showmatch
operator|=
literal|0
operator|,
name|carat_st
operator|=
name|C_NOTSET
operator|,
name|hex
operator|=
name|H_NOTSET
operator|,
name|quoted
operator|=
name|Q_NOTSET
init|;
condition|;
control|)
block|{
comment|/* 		 * Reset the line and update the screen.  (The txt_showmatch() 		 * code refreshes the screen for us.)  Don't refresh unless 		 * we're about to wait on a character or we need to know where 		 * the cursor really is. 		 */
if|if
condition|(
name|showmatch
operator|||
name|margin
operator|||
operator|!
name|KEYS_WAITING
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_change
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_RESET
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|showmatch
condition|)
block|{
name|showmatch
operator|=
literal|0
expr_stmt|;
name|txt_showmatch
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* Get the next character. */
name|next_ch
label|:
if|if
condition|(
name|term_key
argument_list|(
name|sp
argument_list|,
operator|&
name|ikey
argument_list|,
name|quoted
operator|==
name|Q_THISCHAR
condition|?
name|iflags
operator|&
operator|~
operator|(
name|TXT_MAPCOMMAND
operator||
name|TXT_MAPINPUT
operator|)
else|:
name|iflags
argument_list|)
operator|!=
name|INP_OK
condition|)
goto|goto
name|err
goto|;
name|ch
operator|=
name|ikey
operator|.
name|ch
expr_stmt|;
comment|/* Abbreviation check.  See comment in txt_abbrev(). */
define|#
directive|define
name|MAX_ABBREVIATION_EXPANSION
value|256
if|if
condition|(
name|ikey
operator|.
name|flags
operator|&
name|CH_ABBREVIATED
condition|)
block|{
if|if
condition|(
operator|++
name|ab_cnt
operator|>
name|MAX_ABBREVIATION_EXPANSION
condition|)
block|{
name|term_ab_flush
argument_list|(
name|sp
argument_list|,
literal|"Abbreviation exceeded maximum number of characters"
argument_list|)
expr_stmt|;
name|ab_cnt
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
else|else
name|ab_cnt
operator|=
literal|0
expr_stmt|;
comment|/* 		 * !!! 		 * Historic feature.  If the first character of the input is 		 * a nul, replay the previous input.  This isn't documented 		 * anywhere, and is a great test of vi clones. 		 */
if|if
condition|(
name|ch
operator|==
literal|'\0'
operator|&&
name|testnr
condition|)
block|{
name|LF_SET
argument_list|(
name|TXT_REPLAY
argument_list|)
expr_stmt|;
goto|goto
name|nullreplay
goto|;
block|}
name|testnr
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Check to see if the character fits into the input (and 		 * replay, if necessary) buffers.  It isn't necessary to 		 * have tp->len bytes, since it doesn't consider overwrite 		 * characters, but not worth fixing. 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_RECORD
argument_list|)
condition|)
block|{
name|TBINC
argument_list|(
name|sp
argument_list|,
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|rep
argument_list|,
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|rep_len
argument_list|,
name|rcol
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|rep
index|[
name|rcol
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
name|TBINC
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * If the character was quoted, replace the last character 		 * (the literal mark) with the new character.  If quoted 		 * by someone else, simply insert the character. 		 * 		 * !!! 		 * Extension -- if the quoted character is HEX_CH, enter hex 		 * mode.  If the user enters "<HEX_CH>[isxdigit()]*" we will 		 * try to use the value as a character.  Anything else resets 		 * hex mode. 		 */
if|if
condition|(
name|ikey
operator|.
name|flags
operator|&
name|CH_QUOTED
condition|)
goto|goto
name|insq_ch
goto|;
if|if
condition|(
name|quoted
operator|==
name|Q_THISCHAR
condition|)
block|{
operator|--
name|sp
operator|->
name|cno
expr_stmt|;
operator|++
name|tp
operator|->
name|owrite
expr_stmt|;
name|quoted
operator|=
name|Q_NOTSET
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|HEX_CH
condition|)
name|hex
operator|=
name|H_NEXTCHAR
expr_stmt|;
goto|goto
name|insq_ch
goto|;
block|}
switch|switch
condition|(
name|ikey
operator|.
name|value
condition|)
block|{
case|case
name|K_CR
case|:
case|case
name|K_NL
case|:
comment|/* New line. */
define|#
directive|define
name|LINE_RESOLVE
value|{							\
comment|/*						\ 			 * Handle abbreviations.  If there was one,	\ 			 * discard the replay characters.		\ 			 */
value|\ 			if (abb == A_INWORD&& !replay) {		\ 				if (txt_abbrev(sp, tp,&ch,		\ 				    LF_ISSET(TXT_INFOLINE),&tmp,	\&ab_turnoff))			\ 					goto err;			\ 				if (tmp) {				\ 					if (LF_ISSET(TXT_RECORD))	\ 						rcol -= tmp;		\ 					goto next_ch;			\ 				}					\ 			}						\ 			if (abb != A_NOTSET)				\ 				abb = A_NOTWORD;			\ 			if (unmap_tst)					\ 				txt_unmap(sp, tp,&iflags);		\
comment|/* Handle hex numbers. */
value|\ 			if (hex == H_INHEX) {				\ 				if (txt_hex(sp, tp,&tmp,&ch))		\ 					goto err;			\ 				if (tmp) {				\ 					hex = H_NOTSET;			\ 					goto next_ch;			\ 				}					\ 			}						\
comment|/* Clean up for the 'R' command. */
value|\ 			if (LF_ISSET(TXT_REPLACE))			\ 				txt_Rcleanup(sp, tiqh, tp, lp, len);	\
comment|/* Delete any appended cursor. */
value|\ 			if (LF_ISSET(TXT_APPENDEOL)) {			\ 				--tp->len;				\ 				--tp->insert;				\ 			}						\ }
name|LINE_RESOLVE
expr_stmt|;
comment|/* CR returns from the vi command line. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_CR
argument_list|)
condition|)
block|{
comment|/* 				 * If a script window and not the colon 				 * line, push a<cr> so it gets executed. 				 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SCRIPT
argument_list|)
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|TXT_INFOLINE
argument_list|)
condition|)
operator|(
name|void
operator|)
name|term_push
argument_list|(
name|sp
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|CH_NOMAP
argument_list|)
expr_stmt|;
goto|goto
name|k_escape
goto|;
block|}
comment|/* 			 * Historic practice was to delete any<blank> 			 * characters following the inserted newline. 			 * This affects the 'R', 'c', and 's' commands. 			 */
for|for
control|(
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
name|tp
operator|->
name|owrite
init|;
name|tp
operator|->
name|insert
operator|&&
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
operator|,
operator|++
name|tp
operator|->
name|owrite
operator|,
operator|--
name|tp
operator|->
name|insert
control|)
empty_stmt|;
comment|/* 			 * Move any remaining insert characters into 			 * a new TEXT structure. 			 */
if|if
condition|(
operator|(
name|ntp
operator|=
name|text_init
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
name|tp
operator|->
name|owrite
argument_list|,
name|tp
operator|->
name|insert
argument_list|,
name|tp
operator|->
name|insert
operator|+
literal|32
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* Set bookkeeping for the new line. */
name|ntp
operator|->
name|lno
operator|=
name|tp
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
name|ntp
operator|->
name|insert
operator|=
name|tp
operator|->
name|insert
expr_stmt|;
comment|/* 			 * Note if the user inserted any characters on this 			 * line.  Done before calling txt_ai_resolve() because 			 * it changes the value of sp->cno without making the 			 * corresponding changes to tp->ai. 			 */
name|tmp
operator|=
name|sp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|ai
expr_stmt|;
comment|/* 			 * Resolve autoindented characters for the old line. 			 * Reset the autoindent line value.  0^D keeps the ai 			 * line from changing, ^D changes the level, even if 			 * there are no characters in the old line.  Note, 			 * if using the current tp structure, use the cursor 			 * as the length, the user may have erased autoindent 			 * characters. 			 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
condition|)
block|{
name|txt_ai_resolve
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|carat_st
operator|==
name|C_NOCHANGE
condition|)
block|{
if|if
condition|(
name|txt_auto
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|OOBLNO
argument_list|,
operator|&
name|ait
argument_list|,
name|ait
operator|.
name|ai
argument_list|,
name|ntp
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|ait
operator|.
name|lb
argument_list|,
name|ait
operator|.
name|lb_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|txt_auto
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|OOBLNO
argument_list|,
name|tp
argument_list|,
name|sp
operator|->
name|cno
argument_list|,
name|ntp
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|carat_st
operator|=
name|C_NOTSET
expr_stmt|;
block|}
comment|/* 			 * If the user hasn't entered any characters, delete 			 * any autoindent characters. 			 * 			 * !!! 			 * Historic vi didn't get the insert test right, if 			 * there were characters after the cursor, entering 			 * a<cr> left the autoindent characters on the line. 			 */
if|if
condition|(
name|tmp
condition|)
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
comment|/* Reset bookkeeping for the old line. */
name|tp
operator|->
name|len
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|tp
operator|->
name|ai
operator|=
name|tp
operator|->
name|insert
operator|=
name|tp
operator|->
name|owrite
operator|=
literal|0
expr_stmt|;
comment|/* New cursor position. */
name|sp
operator|->
name|cno
operator|=
name|ntp
operator|->
name|ai
expr_stmt|;
comment|/* New lines are TXT_APPENDEOL if nothing to insert. */
if|if
condition|(
name|ntp
operator|->
name|insert
operator|==
literal|0
condition|)
block|{
name|TBINC
argument_list|(
name|sp
argument_list|,
name|ntp
operator|->
name|lb
argument_list|,
name|ntp
operator|->
name|lb_len
argument_list|,
name|ntp
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|LF_SET
argument_list|(
name|TXT_APPENDEOL
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
index|]
operator|=
name|CURSOR_CH
expr_stmt|;
operator|++
name|ntp
operator|->
name|insert
expr_stmt|;
operator|++
name|ntp
operator|->
name|len
expr_stmt|;
block|}
comment|/* Update the old line. */
if|if
condition|(
name|sp
operator|->
name|s_change
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_RESET
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 			 * Swap old and new TEXT's, and insert the new TEXT 			 * into the queue.  (DON'T insert until the old line 			 * has been updated, or the inserted line count in 			 * line.c:file_gline() will be wrong.) 			 */
name|tp
operator|=
name|ntp
expr_stmt|;
name|CIRCLEQ_INSERT_TAIL
argument_list|(
name|tiqh
argument_list|,
name|tp
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Reset the cursor. */
name|sp
operator|->
name|lno
operator|=
name|tp
operator|->
name|lno
expr_stmt|;
comment|/* Update the new line. */
if|if
condition|(
name|sp
operator|->
name|s_change
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|LINE_INSERT
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Set the renumber bit. */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_RENUMBER
argument_list|)
expr_stmt|;
comment|/* Refresh if nothing waiting. */
if|if
condition|(
operator|(
name|margin
operator|||
operator|!
name|KEYS_WAITING
argument_list|(
name|sp
argument_list|)
operator|)
operator|&&
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|next_ch
goto|;
case|case
name|K_ESCAPE
case|:
comment|/* Escape. */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|TXT_ESCAPE
argument_list|)
condition|)
goto|goto
name|ins_ch
goto|;
name|LINE_RESOLVE
expr_stmt|;
comment|/* 			 * If there aren't any trailing characters in the line 			 * and the user hasn't entered any characters, delete 			 * the autoindent characters. 			 */
if|if
condition|(
operator|!
name|tp
operator|->
name|insert
operator|&&
name|sp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|ai
condition|)
block|{
name|tp
operator|->
name|len
operator|=
name|tp
operator|->
name|owrite
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
condition|)
name|txt_ai_resolve
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* If there are insert characters, copy them down. */
name|k_escape
label|:
if|if
condition|(
name|tp
operator|->
name|insert
operator|&&
name|tp
operator|->
name|owrite
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
name|tp
operator|->
name|owrite
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
name|tp
operator|->
name|len
operator|-=
name|tp
operator|->
name|owrite
expr_stmt|;
comment|/* 			 * Delete any lines that were inserted into the text 			 * structure and then erased. 			 */
while|while
condition|(
name|tp
operator|->
name|q
operator|.
name|cqe_next
operator|!=
operator|(
name|void
operator|*
operator|)
name|tiqh
condition|)
block|{
name|ntp
operator|=
name|tp
operator|->
name|q
operator|.
name|cqe_next
expr_stmt|;
name|CIRCLEQ_REMOVE
argument_list|(
name|tiqh
argument_list|,
name|ntp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|text_free
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If not resolving the lines into the file, end 			 * it with a nul. 			 * 			 * XXX 			 * This is wrong, should pass back a length. 			 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_RESOLVE
argument_list|)
condition|)
block|{
if|if
condition|(
name|txt_resolve
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tiqh
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 				 * Clear input flag -- input buffer no longer 				 * valid. 				 */
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_INPUT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TBINC
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 			 * Set the return cursor position to rest on the last 			 * inserted character. 			 */
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|tp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
condition|?
name|sp
operator|->
name|cno
operator|-
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_change
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|rp
operator|->
name|lno
argument_list|,
name|LINE_RESET
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
goto|goto
name|ret
goto|;
case|case
name|K_CARAT
case|:
comment|/* Delete autoindent chars. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
operator|&&
name|sp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|ai
condition|)
name|carat_st
operator|=
name|C_CARATSET
expr_stmt|;
goto|goto
name|ins_ch
goto|;
case|case
name|K_ZERO
case|:
comment|/* Delete autoindent chars. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
operator|&&
name|sp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|ai
condition|)
name|carat_st
operator|=
name|C_ZEROSET
expr_stmt|;
goto|goto
name|ins_ch
goto|;
case|case
name|K_CNTRLD
case|:
comment|/* Delete autoindent char. */
comment|/* 			 * If in the first column or no characters to erase, 			 * ignore the ^D (this matches historic practice).  If 			 * not doing autoindent or already inserted non-ai 			 * characters, it's a literal.  The latter test is done 			 * in the switch, as the CARAT forms are N + 1, not N. 			 */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
condition|)
goto|goto
name|ins_ch
goto|;
if|if
condition|(
name|sp
operator|->
name|cno
operator|==
literal|0
operator|||
name|tp
operator|->
name|ai
operator|==
literal|0
condition|)
break|break;
switch|switch
condition|(
name|carat_st
condition|)
block|{
case|case
name|C_CARATSET
case|:
comment|/* ^^D */
if|if
condition|(
name|sp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
operator|+
name|tp
operator|->
name|offset
operator|+
literal|1
condition|)
goto|goto
name|ins_ch
goto|;
comment|/* Save the ai string for later. */
name|ait
operator|.
name|lb
operator|=
name|NULL
expr_stmt|;
name|ait
operator|.
name|lb_len
operator|=
literal|0
expr_stmt|;
name|TBINC
argument_list|(
name|sp
argument_list|,
name|ait
operator|.
name|lb
argument_list|,
name|ait
operator|.
name|lb_len
argument_list|,
name|tp
operator|->
name|ai
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|ait
operator|.
name|lb
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|ai
argument_list|)
expr_stmt|;
name|ait
operator|.
name|ai
operator|=
name|ait
operator|.
name|len
operator|=
name|tp
operator|->
name|ai
expr_stmt|;
name|carat_st
operator|=
name|C_NOCHANGE
expr_stmt|;
goto|goto
name|leftmargin
goto|;
case|case
name|C_ZEROSET
case|:
comment|/* 0^D */
if|if
condition|(
name|sp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
operator|+
name|tp
operator|->
name|offset
operator|+
literal|1
condition|)
goto|goto
name|ins_ch
goto|;
name|carat_st
operator|=
name|C_NOTSET
expr_stmt|;
name|leftmargin
label|:
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|tp
operator|->
name|owrite
operator|+=
name|sp
operator|->
name|cno
operator|-
name|tp
operator|->
name|offset
expr_stmt|;
name|tp
operator|->
name|ai
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|tp
operator|->
name|offset
expr_stmt|;
break|break;
case|case
name|C_NOTSET
case|:
comment|/* ^D */
if|if
condition|(
name|sp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
operator|+
name|tp
operator|->
name|offset
condition|)
goto|goto
name|ins_ch
goto|;
operator|(
name|void
operator|)
name|txt_outdent
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|K_VERASE
case|:
comment|/* Erase the last character. */
comment|/* 			 * If can erase over the prompt, return.  Len is 0 			 * if backspaced over the prompt, 1 if only CR entered. 			 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_BS
argument_list|)
operator|&&
name|sp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|offset
condition|)
block|{
name|tp
operator|->
name|len
operator|=
literal|0
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/* 			 * If at the beginning of the line, try and drop back 			 * to a previously inserted line. 			 */
if|if
condition|(
name|sp
operator|->
name|cno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ntp
operator|=
name|txt_backup
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tiqh
argument_list|,
name|tp
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|tp
operator|=
name|ntp
expr_stmt|;
break|break;
block|}
comment|/* If nothing to erase, bell the user. */
if|if
condition|(
name|sp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|offset
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"No more characters to erase."
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Drop back one character. */
operator|--
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* 			 * Increment overwrite, decrement ai if deleted. 			 * 			 * !!! 			 * Historic vi did not permit users to use erase 			 * characters to delete autoindent characters. 			 */
operator|++
name|tp
operator|->
name|owrite
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|cno
operator|<
name|tp
operator|->
name|ai
condition|)
operator|--
name|tp
operator|->
name|ai
expr_stmt|;
break|break;
case|case
name|K_VINTR
case|:
comment|/* 			 * !!! 			 * Historically,<interrupt> exited the user from 			 * editing the infoline, and returned to the main 			 * screen.  It also beeped the terminal, but that 			 * seems excessive. 			 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_INFOLINE
argument_list|)
condition|)
block|{
name|tp
operator|->
name|lb
index|[
name|tp
operator|->
name|len
operator|=
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
goto|goto
name|ins_ch
goto|;
case|case
name|K_VWERASE
case|:
comment|/* Skip back one word. */
comment|/* 			 * If at the beginning of the line, try and drop back 			 * to a previously inserted line. 			 */
if|if
condition|(
name|sp
operator|->
name|cno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ntp
operator|=
name|txt_backup
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tiqh
argument_list|,
name|tp
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|tp
operator|=
name|ntp
expr_stmt|;
block|}
comment|/* 			 * If at offset, nothing to erase so bell the user. 			 */
if|if
condition|(
name|sp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|offset
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"No more characters to erase."
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * First werase goes back to any autoindent 			 * and second werase goes back to the offset. 			 * 			 * !!! 			 * Historic vi did not permit users to use erase 			 * characters to delete autoindent characters. 			 */
if|if
condition|(
name|tp
operator|->
name|ai
operator|&&
name|sp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
condition|)
name|max
operator|=
name|tp
operator|->
name|ai
expr_stmt|;
else|else
block|{
name|tp
operator|->
name|ai
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|tp
operator|->
name|offset
expr_stmt|;
block|}
comment|/* Skip over trailing space characters. */
while|while
condition|(
name|sp
operator|->
name|cno
operator|>
name|max
operator|&&
name|isblank
argument_list|(
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
operator|--
name|sp
operator|->
name|cno
expr_stmt|;
operator|++
name|tp
operator|->
name|owrite
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|cno
operator|==
name|max
condition|)
break|break;
comment|/* 			 * There are three types of word erase found on UNIX 			 * systems.  They can be identified by how the string 			 * /a/b/c is treated -- as 1, 3, or 6 words.  Historic 			 * vi had two classes of characters, and strings were 			 * delimited by them and<blank>'s, so, 6 words.  The 			 * historic tty interface used<blank>'s to delimit 			 * strings, so, 1 word.  The algorithm offered in the 			 * 4.4BSD tty interface (as stty altwerase) treats it 			 * as 3 words -- there are two classes of characters, 			 * and strings are delimited by them and<blank>'s. 			 * The difference is that the type of the first erased 			 * character erased is ignored, which is exactly right 			 * when erasing pathname components.  Here, the options 			 * TXT_ALTWERASE and TXT_TTYWERASE specify the 4.4BSD 			 * tty interface and the historic tty driver behavior, 			 * respectively, and the default is the same as the 			 * historic vi behavior. 			 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_TTYWERASE
argument_list|)
condition|)
while|while
condition|(
name|sp
operator|->
name|cno
operator|>
name|max
condition|)
block|{
operator|--
name|sp
operator|->
name|cno
expr_stmt|;
operator|++
name|tp
operator|->
name|owrite
expr_stmt|;
if|if
condition|(
name|isblank
argument_list|(
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_ALTWERASE
argument_list|)
condition|)
block|{
operator|--
name|sp
operator|->
name|cno
expr_stmt|;
operator|++
name|tp
operator|->
name|owrite
expr_stmt|;
if|if
condition|(
name|isblank
argument_list|(
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|sp
operator|->
name|cno
operator|>
name|max
condition|)
name|tmp
operator|=
name|inword
argument_list|(
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
operator|->
name|cno
operator|>
name|max
condition|)
block|{
operator|--
name|sp
operator|->
name|cno
expr_stmt|;
operator|++
name|tp
operator|->
name|owrite
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|inword
argument_list|(
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
operator|||
name|isblank
argument_list|(
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
block|}
block|}
break|break;
case|case
name|K_VKILL
case|:
comment|/* Restart this line. */
comment|/* 			 * If at the beginning of the line, try and drop back 			 * to a previously inserted line. 			 */
if|if
condition|(
name|sp
operator|->
name|cno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ntp
operator|=
name|txt_backup
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tiqh
argument_list|,
name|tp
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|tp
operator|=
name|ntp
expr_stmt|;
block|}
comment|/* If at offset, nothing to erase so bell the user. */
if|if
condition|(
name|sp
operator|->
name|cno
operator|<=
name|tp
operator|->
name|offset
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"No more characters to erase."
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * First kill goes back to any autoindent 			 * and second kill goes back to the offset. 			 * 			 * !!! 			 * Historic vi did not permit users to use erase 			 * characters to delete autoindent characters. 			 */
if|if
condition|(
name|tp
operator|->
name|ai
operator|&&
name|sp
operator|->
name|cno
operator|>
name|tp
operator|->
name|ai
condition|)
name|max
operator|=
name|tp
operator|->
name|ai
expr_stmt|;
else|else
block|{
name|tp
operator|->
name|ai
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|tp
operator|->
name|offset
expr_stmt|;
block|}
name|tp
operator|->
name|owrite
operator|+=
name|sp
operator|->
name|cno
operator|-
name|max
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|max
expr_stmt|;
break|break;
case|case
name|K_CNTRLT
case|:
comment|/* Add autoindent char. */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|TXT_CNTRLT
argument_list|)
condition|)
goto|goto
name|ins_ch
goto|;
if|if
condition|(
name|txt_indent
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|ebuf_chk
goto|;
case|case
name|K_CNTRLZ
case|:
operator|(
name|void
operator|)
name|sp
operator|->
name|s_suspend
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HISTORIC_PRACTICE_IS_TO_INSERT_NOT_REPAINT
case|case
name|K_FORMFEED
case|:
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REFRESH
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|K_RIGHTBRACE
case|:
case|case
name|K_RIGHTPAREN
case|:
name|showmatch
operator|=
name|LF_ISSET
argument_list|(
name|TXT_SHOWMATCH
argument_list|)
expr_stmt|;
goto|goto
name|ins_ch
goto|;
case|case
name|K_VLNEXT
case|:
comment|/* Quote the next character. */
comment|/* If in hex mode, see if we've entered a hex value. */
if|if
condition|(
name|hex
operator|==
name|H_INHEX
condition|)
block|{
if|if
condition|(
name|txt_hex
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|ch
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|tmp
condition|)
block|{
name|hex
operator|=
name|H_NOTSET
expr_stmt|;
goto|goto
name|next_ch
goto|;
block|}
block|}
name|ch
operator|=
literal|'^'
expr_stmt|;
name|quoted
operator|=
name|Q_NEXTCHAR
expr_stmt|;
goto|goto
name|insq_ch
goto|;
default|default:
comment|/* Insert the character. */
name|ins_ch
label|:
comment|/* 	 		 * Historically, vi eliminated nul's out of hand.  If 			 * the beautify option was set, it also deleted any 			 * unknown ASCII value less than space (040) and the 			 * del character (0177), except for tabs.  Unknown is 			 * a key word here.  Most vi documentation claims that 			 * it deleted everything but<tab>,<nl> and<ff>, as 			 * that's what the original 4BSD documentation said. 			 * This is obviously wrong, however, as<esc> would be 			 * included in that list.  What we do is eliminate any 			 * unquoted, iscntrl() character that wasn't a replay 			 * and wasn't handled specially, except<tab> or<ff>. 			 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_BEAUTIFY
argument_list|)
operator|&&
name|iscntrl
argument_list|(
name|ch
argument_list|)
operator|&&
name|ikey
operator|.
name|value
operator|!=
name|K_FORMFEED
operator|&&
name|ikey
operator|.
name|value
operator|!=
name|K_TAB
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"Illegal character; quote to enter."
argument_list|)
expr_stmt|;
break|break;
block|}
name|insq_ch
label|:
comment|/* 			 * If entering a non-word character after a word, check 			 * for abbreviations.  If there was one, discard the 			 * replay characters.  If entering a blank character, 			 * check for unmap commands, as well. 			 */
if|if
condition|(
operator|!
name|inword
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|abb
operator|==
name|A_INWORD
operator|&&
operator|!
name|replay
condition|)
block|{
if|if
condition|(
name|txt_abbrev
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
operator|&
name|ch
argument_list|,
name|LF_ISSET
argument_list|(
name|TXT_INFOLINE
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|ab_turnoff
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_RECORD
argument_list|)
condition|)
name|rcol
operator|-=
name|tmp
expr_stmt|;
goto|goto
name|next_ch
goto|;
block|}
block|}
if|if
condition|(
name|isblank
argument_list|(
name|ch
argument_list|)
operator|&&
name|unmap_tst
condition|)
name|txt_unmap
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
operator|&
name|iflags
argument_list|)
expr_stmt|;
block|}
comment|/* If in hex mode, see if we've entered a hex value. */
if|if
condition|(
name|hex
operator|==
name|H_INHEX
operator|&&
operator|!
name|isxdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|txt_hex
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|ch
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|tmp
condition|)
block|{
name|hex
operator|=
name|H_NOTSET
expr_stmt|;
goto|goto
name|next_ch
goto|;
block|}
block|}
comment|/* Check to see if we've crossed the margin. */
if|if
condition|(
name|margin
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_column
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|col
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|col
operator|>=
name|margin
condition|)
block|{
if|if
condition|(
name|txt_margin
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|ch
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|tmp
condition|)
goto|goto
name|next_ch
goto|;
block|}
block|}
if|if
condition|(
name|abb
operator|!=
name|A_NOTSET
condition|)
name|abb
operator|=
name|inword
argument_list|(
name|ch
argument_list|)
condition|?
name|A_INWORD
else|:
name|A_NOTWORD
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|owrite
condition|)
comment|/* Overwrite a character. */
operator|--
name|tp
operator|->
name|owrite
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|insert
condition|)
block|{
comment|/* Insert a character. */
operator|++
name|tp
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|insert
operator|==
literal|1
condition|)
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|+
literal|1
index|]
operator|=
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
index|]
expr_stmt|;
else|else
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
literal|1
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|++
index|]
operator|=
name|ch
expr_stmt|;
comment|/* 			 * If we've reached the end of the buffer, then we 			 * need to switch into insert mode.  This happens 			 * when there's a change to a mark and the user puts 			 * in more characters than the length of the motion. 			 */
name|ebuf_chk
label|:
if|if
condition|(
name|sp
operator|->
name|cno
operator|>=
name|tp
operator|->
name|len
condition|)
block|{
name|TBINC
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|LF_SET
argument_list|(
name|TXT_APPENDEOL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
index|]
operator|=
name|CURSOR_CH
expr_stmt|;
operator|++
name|tp
operator|->
name|insert
expr_stmt|;
operator|++
name|tp
operator|->
name|len
expr_stmt|;
block|}
if|if
condition|(
name|hex
operator|==
name|H_NEXTCHAR
condition|)
name|hex
operator|=
name|H_INHEX
expr_stmt|;
if|if
condition|(
name|quoted
operator|==
name|Q_NEXTCHAR
condition|)
name|quoted
operator|=
name|Q_THISCHAR
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|1
if|if
condition|(
name|sp
operator|->
name|cno
operator|+
name|tp
operator|->
name|insert
operator|+
name|tp
operator|->
name|owrite
operator|!=
name|tp
operator|->
name|len
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"len %u != cno: %u ai: %u insert %u overwrite %u"
argument_list|,
name|tp
operator|->
name|len
argument_list|,
name|sp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|ai
argument_list|,
name|tp
operator|->
name|insert
argument_list|,
name|tp
operator|->
name|owrite
argument_list|)
expr_stmt|;
name|tp
operator|->
name|len
operator|=
name|sp
operator|->
name|cno
operator|+
name|tp
operator|->
name|insert
operator|+
name|tp
operator|->
name|owrite
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Clear input flag. */
name|ret
label|:
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_INPUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_RECORD
argument_list|)
condition|)
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|rep_cnt
operator|=
name|rcol
expr_stmt|;
return|return
operator|(
name|eval
operator|)
return|;
comment|/* Error jump. */
name|err
label|:
name|eval
operator|=
literal|1
expr_stmt|;
name|txt_err
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tiqh
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
end_function

begin_comment
comment|/*  * txt_abbrev --  *	Handle abbreviations.  */
end_comment

begin_function
specifier|static
name|int
name|txt_abbrev
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|,
name|pushcp
parameter_list|,
name|isinfoline
parameter_list|,
name|didsubp
parameter_list|,
name|turnoffp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|CHAR_T
modifier|*
name|pushcp
decl_stmt|;
name|int
name|isinfoline
decl_stmt|,
decl|*
name|didsubp
decl_stmt|,
modifier|*
name|turnoffp
decl_stmt|;
end_function

begin_block
block|{
name|CHAR_T
name|ch
decl_stmt|;
name|SEQ
modifier|*
name|qp
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|off
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Find the start of the "word".  Historically, abbreviations 	 * could be preceded by any non-word character. 	 */
for|for
control|(
name|off
operator|=
name|sp
operator|->
name|cno
operator|-
literal|1
operator|,
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|off
operator|,
name|len
operator|=
literal|0
init|;
condition|;
operator|--
name|p
operator|,
operator|--
name|off
control|)
block|{
if|if
condition|(
operator|!
name|inword
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|++
name|p
expr_stmt|;
break|break;
block|}
operator|++
name|len
expr_stmt|;
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|ai
operator|||
name|off
operator|==
name|tp
operator|->
name|offset
condition|)
break|break;
block|}
comment|/* 	 * !!! 	 * Historic vi exploded abbreviations on the command line.  This has 	 * obvious problems in that unabbreviating the string can be extremely 	 * tricky, particularly if the string has, say, an embedded escape 	 * character.  Personally, I think it's a stunningly bad idea.  Other 	 * examples of problems this caused in historic vi are: 	 *	:ab foo bar 	 *	:ab foo baz 	 * results in "bar" being abbreviated to "baz", which wasn't what the 	 * user had in mind at all.  Also, the commands: 	 *	:ab foo bar 	 *	:unab foo<space> 	 * resulted in an error message that "bar" wasn't mapped.  Finally, 	 * since the string was already exploded by the time the unabbreviate 	 * command got it, all it knew was that an abbreviation had occurred. 	 * Cleverly, it checked the replacement string for its unabbreviation 	 * match, which meant that the commands: 	 *	:ab foo1 bar 	 *	:ab foo2 bar 	 *	:unab foo2 	 * unabbreviates "foo1", and the commands: 	 *	:ab foo bar 	 *	:ab bar baz 	 * unabbreviates "foo"! 	 * 	 * Anyway, people neglected to first ask my opinion before they wrote 	 * macros that depend on this stuff, so, we make this work as follows. 	 * When checking for an abbreviation on the command line, if we get a 	 * string which is<blank> terminated and which starts at the beginning 	 * of the line, we check to see it is the abbreviate or unabbreviate 	 * commands.  If it is, turn abbreviations off and return as if no 	 * abbreviation was found.  Note also, minor trickiness, so that if the 	 * user erases the line and starts another command, we go ahead an turn 	 * abbreviations back on. 	 * 	 * This makes the layering look like a Nachos Supreme. 	 */
operator|*
name|didsubp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isinfoline
condition|)
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|ai
operator|||
name|off
operator|==
name|tp
operator|->
name|offset
condition|)
if|if
condition|(
name|ex_is_abbrev
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|turnoffp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
operator|*
name|turnoffp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|turnoffp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Check for any abbreviations. */
if|if
condition|(
operator|(
name|qp
operator|=
name|seq_find
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
name|SEQ_ABBREV
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Push the abbreviation onto the tty stack.  Historically, characters 	 * resulting from an abbreviation expansion were themselves subject to 	 * map expansions, O_SHOWMATCH matching etc.  This means the expanded 	 * characters will be re-tested for abbreviations.  It's difficult to 	 * know what historic practice in this case was, since abbreviations 	 * were applied to :colon command lines, so entering abbreviations that 	 * looped was tricky, although possible.  In addition, obvious loops 	 * didn't work as expected.  (The command ':ab a b|ab b c|ab c a' will 	 * silently only implement and/or display the last abbreviation.) 	 * 	 * This implementation doesn't recover well from such abbreviations. 	 * The main input loop counts abbreviated characters, and, when it 	 * reaches a limit, discards any abbreviated characters on the queue. 	 * It's difficult to back up to the original position, as the replay 	 * queue would have to be adjusted, and the line state when an initial 	 * abbreviated character was received would have to be saved. 	 */
name|ch
operator|=
operator|*
name|pushcp
expr_stmt|;
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|CH_ABBREVIATED
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
name|qp
operator|->
name|output
argument_list|,
name|qp
operator|->
name|olen
argument_list|,
literal|0
argument_list|,
name|CH_ABBREVIATED
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Move the cursor to the start of the abbreviation, 	 * adjust the length. 	 */
name|sp
operator|->
name|cno
operator|-=
name|len
expr_stmt|;
name|tp
operator|->
name|len
operator|-=
name|len
expr_stmt|;
comment|/* Copy any insert characters back. */
if|if
condition|(
name|tp
operator|->
name|insert
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
name|tp
operator|->
name|owrite
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
name|tp
operator|->
name|owrite
operator|+
name|len
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
comment|/* 	 * We return the length of the abbreviated characters.  This is so 	 * the calling routine can replace the replay characters with the 	 * abbreviation.  This means that subsequent '.' commands will produce 	 * the same text, regardless of intervening :[un]abbreviate commands. 	 * This is historic practice. 	 */
operator|*
name|didsubp
operator|=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * txt_unmap --  *	Handle the unmap command.  */
end_comment

begin_function
specifier|static
name|void
name|txt_unmap
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|,
name|iflagsp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|u_int
modifier|*
name|iflagsp
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|,
name|off
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Find the beginning of this "word". */
for|for
control|(
name|off
operator|=
name|sp
operator|->
name|cno
operator|-
literal|1
operator|,
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|off
operator|,
name|len
operator|=
literal|0
init|;
condition|;
operator|--
name|p
operator|,
operator|--
name|off
control|)
block|{
if|if
condition|(
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|++
name|p
expr_stmt|;
break|break;
block|}
operator|++
name|len
expr_stmt|;
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|ai
operator|||
name|off
operator|==
name|tp
operator|->
name|offset
condition|)
break|break;
block|}
comment|/* 	 * !!! 	 * Historic vi exploded input mappings on the command line.  See the 	 * txt_abbrev() routine for an explanation of the problems inherent 	 * in this. 	 * 	 * We make this work as follows.  If we get a string which is<blank> 	 * terminated and which starts at the beginning of the line, we check 	 * to see it is the unmap command.  If it is, we return that the input 	 * mapping should be turned off.  Note also, minor trickiness, so that 	 * if the user erases the line and starts another command, we go ahead 	 * an turn mapping back on. 	 */
if|if
condition|(
operator|(
name|off
operator|==
name|tp
operator|->
name|ai
operator|||
name|off
operator|==
name|tp
operator|->
name|offset
operator|)
operator|&&
name|ex_is_unmap
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
condition|)
operator|*
name|iflagsp
operator|&=
operator|~
name|TXT_MAPINPUT
expr_stmt|;
else|else
operator|*
name|iflagsp
operator||=
name|TXT_MAPINPUT
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Offset to next column of stop size. */
end_comment

begin_define
define|#
directive|define
name|STOP_OFF
parameter_list|(
name|c
parameter_list|,
name|stop
parameter_list|)
value|(stop - (c) % stop)
end_define

begin_comment
comment|/*  * txt_ai_resolve --  *	When a line is resolved by<esc> or<cr>, review autoindent  *	characters.  */
end_comment

begin_function
specifier|static
name|void
name|txt_ai_resolve
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
block|{
name|u_long
name|ts
decl_stmt|;
name|int
name|del
decl_stmt|;
name|size_t
name|cno
decl_stmt|,
name|len
decl_stmt|,
name|new
decl_stmt|,
name|old
decl_stmt|,
name|scno
decl_stmt|,
name|spaces
decl_stmt|,
name|tab_after_sp
decl_stmt|,
name|tabs
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * If the line is empty, has an offset, or no autoindent 	 * characters, we're done. 	 */
if|if
condition|(
operator|!
name|tp
operator|->
name|len
operator|||
name|tp
operator|->
name|offset
operator|||
operator|!
name|tp
operator|->
name|ai
condition|)
return|return;
comment|/* 	 * The autoindent characters plus any leading<blank> characters 	 * in the line are resolved into the minimum number of characters. 	 * Historic practice. 	 */
name|ts
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_TABSTOP
argument_list|)
expr_stmt|;
comment|/* Figure out the last<blank> screen column. */
for|for
control|(
name|p
operator|=
name|tp
operator|->
name|lb
operator|,
name|scno
operator|=
literal|0
operator|,
name|len
operator|=
name|tp
operator|->
name|len
operator|,
name|spaces
operator|=
name|tab_after_sp
operator|=
literal|0
init|;
name|len
operator|--
operator|&&
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
name|spaces
condition|)
name|tab_after_sp
operator|=
literal|1
expr_stmt|;
name|scno
operator|+=
name|STOP_OFF
argument_list|(
name|scno
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|spaces
expr_stmt|;
operator|++
name|scno
expr_stmt|;
block|}
comment|/* 	 * If there are no spaces, or no tabs after spaces and less than 	 * ts spaces, it's already minimal. 	 */
if|if
condition|(
operator|!
name|spaces
operator|||
operator|!
name|tab_after_sp
operator|&&
name|spaces
operator|<
name|ts
condition|)
return|return;
comment|/* Count up spaces/tabs needed to get to the target. */
for|for
control|(
name|cno
operator|=
literal|0
operator|,
name|tabs
operator|=
literal|0
init|;
name|cno
operator|+
name|STOP_OFF
argument_list|(
name|cno
argument_list|,
name|ts
argument_list|)
operator|<=
name|scno
condition|;
operator|++
name|tabs
control|)
name|cno
operator|+=
name|STOP_OFF
argument_list|(
name|cno
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|spaces
operator|=
name|scno
operator|-
name|cno
expr_stmt|;
comment|/* 	 * Figure out how many characters we're dropping -- if we're not 	 * dropping any, it's already minimal, we're done. 	 */
name|old
operator|=
name|p
operator|-
name|tp
operator|->
name|lb
expr_stmt|;
name|new
operator|=
name|spaces
operator|+
name|tabs
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|new
condition|)
return|return;
comment|/* Shift the rest of the characters down, adjust the counts. */
name|del
operator|=
name|old
operator|-
name|new
expr_stmt|;
name|memmove
argument_list|(
name|p
operator|-
name|del
argument_list|,
name|p
argument_list|,
name|tp
operator|->
name|len
operator|-
name|old
argument_list|)
expr_stmt|;
name|sp
operator|->
name|cno
operator|-=
name|del
expr_stmt|;
name|tp
operator|->
name|len
operator|-=
name|del
expr_stmt|;
comment|/* Fill in space/tab characters. */
for|for
control|(
name|p
operator|=
name|tp
operator|->
name|lb
init|;
name|tabs
operator|--
condition|;
control|)
operator|*
name|p
operator|++
operator|=
literal|'\t'
expr_stmt|;
while|while
condition|(
name|spaces
operator|--
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * txt_auto --  *	Handle autoindent.  If aitp isn't NULL, use it, otherwise,  *	retrieve the line.  */
end_comment

begin_function
name|int
name|txt_auto
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|lno
parameter_list|,
name|aitp
parameter_list|,
name|len
parameter_list|,
name|tp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|TEXT
modifier|*
name|aitp
decl_stmt|,
decl|*
name|tp
decl_stmt|;
end_function

begin_block
block|{
name|size_t
name|nlen
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|aitp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|t
operator|=
name|aitp
operator|->
name|lb
expr_stmt|;
comment|/* Count whitespace characters. */
for|for
control|(
name|p
operator|=
name|t
init|;
name|len
operator|>
literal|0
condition|;
operator|++
name|p
operator|,
operator|--
name|len
control|)
if|if
condition|(
operator|!
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
comment|/* Set count, check for no indentation. */
if|if
condition|(
operator|(
name|nlen
operator|=
operator|(
name|p
operator|-
name|t
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Make sure the buffer's big enough. */
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
name|nlen
argument_list|)
expr_stmt|;
comment|/* Copy the buffer's current contents up. */
if|if
condition|(
name|tp
operator|->
name|len
operator|!=
literal|0
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|nlen
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|len
argument_list|)
expr_stmt|;
name|tp
operator|->
name|len
operator|+=
name|nlen
expr_stmt|;
comment|/* Copy the indentation into the new buffer. */
name|memmove
argument_list|(
name|tp
operator|->
name|lb
argument_list|,
name|t
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
comment|/* Set the autoindent count. */
name|tp
operator|->
name|ai
operator|=
name|nlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * txt_backup --  *	Back up to the previously edited line.  */
end_comment

begin_function
specifier|static
name|TEXT
modifier|*
name|txt_backup
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|tiqh
parameter_list|,
name|tp
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|TEXTH
modifier|*
name|tiqh
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
name|TEXT
modifier|*
name|ntp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|total
decl_stmt|;
comment|/* Get a handle on the previous TEXT structure. */
if|if
condition|(
operator|(
name|ntp
operator|=
name|tp
operator|->
name|q
operator|.
name|cqe_prev
operator|)
operator|==
operator|(
name|void
operator|*
operator|)
name|tiqh
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"Already at the beginning of the insert"
argument_list|)
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
comment|/* Make sure that we have enough space. */
name|total
operator|=
name|ntp
operator|->
name|len
operator|+
name|tp
operator|->
name|insert
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_APPENDEOL
argument_list|)
condition|)
operator|++
name|total
expr_stmt|;
if|if
condition|(
name|total
operator|>
name|ntp
operator|->
name|lb_len
operator|&&
name|binc
argument_list|(
name|sp
argument_list|,
operator|&
name|ntp
operator|->
name|lb
argument_list|,
operator|&
name|ntp
operator|->
name|lb_len
argument_list|,
name|total
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Append a cursor or copy inserted bytes to the end of the old line. 	 * Test for appending a cursor first, because the TEXT insert field 	 * will be 1 if we're appending a cursor.  I don't think there's a 	 * third case, so abort() if there is. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_APPENDEOL
argument_list|)
condition|)
block|{
name|ntp
operator|->
name|lb
index|[
name|ntp
operator|->
name|len
index|]
operator|=
name|CURSOR_CH
expr_stmt|;
name|ntp
operator|->
name|insert
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|insert
condition|)
block|{
name|memmove
argument_list|(
name|ntp
operator|->
name|lb
operator|+
name|ntp
operator|->
name|len
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|tp
operator|->
name|owrite
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|insert
operator|=
name|tp
operator|->
name|insert
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Set bookkeeping information. */
name|sp
operator|->
name|lno
operator|=
name|ntp
operator|->
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|ntp
operator|->
name|len
expr_stmt|;
name|ntp
operator|->
name|len
operator|+=
name|ntp
operator|->
name|insert
expr_stmt|;
comment|/* Release the current TEXT. */
name|lno
operator|=
name|tp
operator|->
name|lno
expr_stmt|;
name|CIRCLEQ_REMOVE
argument_list|(
name|tiqh
argument_list|,
name|tp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|text_free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Update the old line on the screen. */
if|if
condition|(
name|sp
operator|->
name|s_change
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|LINE_DELETE
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Return the old line. */
return|return
operator|(
name|ntp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_err --  *	Handle an error during input processing.  */
end_comment

begin_function
specifier|static
name|void
name|txt_err
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|tiqh
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|TEXTH
modifier|*
name|tiqh
decl_stmt|;
block|{
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* 	 * The problem with input processing is that the cursor is at an 	 * indeterminate position since some input may have been lost due 	 * to a malloc error.  So, try to go back to the place from which 	 * the cursor started, knowing that it may no longer be available. 	 * 	 * We depend on at least one line number being set in the text 	 * chain. 	 */
for|for
control|(
name|lno
operator|=
name|tiqh
operator|->
name|cqh_first
operator|->
name|lno
init|;
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|==
name|NULL
operator|&&
name|lno
operator|>
literal|0
condition|;
operator|--
name|lno
control|)
empty_stmt|;
name|sp
operator|->
name|lno
operator|=
name|lno
operator|==
literal|0
condition|?
literal|1
else|:
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
comment|/* Redraw the screen, just in case. */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * txt_hex --  *	Let the user insert any character value they want.  *  * !!!  * This is an extension.  The pattern "^Vx[0-9a-fA-F]*" is a way  * for the user to specify a character value which their keyboard  * may not be able to enter.  */
end_comment

begin_function
specifier|static
name|int
name|txt_hex
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|,
name|was_hex
parameter_list|,
name|pushcp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|was_hex
decl_stmt|;
name|CHAR_T
modifier|*
name|pushcp
decl_stmt|;
block|{
name|CHAR_T
name|ch
decl_stmt|,
name|savec
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|off
decl_stmt|;
name|u_long
name|value
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|wp
decl_stmt|;
comment|/* 	 * Null-terminate the string.  Since nul isn't a legal hex value, 	 * this should be okay, and lets us use a local routine, which 	 * presumably understands the character set, to convert the value. 	 */
name|savec
operator|=
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
index|]
expr_stmt|;
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Find the previous HEX_CH. */
for|for
control|(
name|off
operator|=
name|sp
operator|->
name|cno
operator|-
literal|1
operator|,
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|off
operator|,
name|len
operator|=
literal|0
init|;
condition|;
operator|--
name|p
operator|,
operator|--
name|off
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|HEX_CH
condition|)
block|{
name|wp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
break|break;
block|}
operator|++
name|len
expr_stmt|;
comment|/* If not on this line, there's nothing to do. */
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|ai
operator|||
name|off
operator|==
name|tp
operator|->
name|offset
condition|)
goto|goto
name|nothex
goto|;
block|}
comment|/* If no length, then it wasn't a hex value. */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|nothex
goto|;
comment|/* Get the value. */
name|value
operator|=
name|strtol
argument_list|(
name|wp
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|LONG_MIN
operator|||
name|value
operator|==
name|LONG_MAX
operator|||
name|value
operator|>
name|MAX_CHAR_T
condition|)
block|{
name|nothex
label|:
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
index|]
operator|=
name|savec
expr_stmt|;
operator|*
name|was_hex
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ch
operator|=
operator|*
name|pushcp
expr_stmt|;
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|CH_NOMAP
operator||
name|CH_QUOTED
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ch
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|CH_NOMAP
operator||
name|CH_QUOTED
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
index|]
operator|=
name|savec
expr_stmt|;
comment|/* Move the cursor to the start of the hex value, adjust the length. */
name|sp
operator|->
name|cno
operator|-=
name|len
operator|+
literal|1
expr_stmt|;
name|tp
operator|->
name|len
operator|-=
name|len
operator|+
literal|1
expr_stmt|;
comment|/* Copy any insert characters back. */
if|if
condition|(
name|tp
operator|->
name|insert
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
name|tp
operator|->
name|owrite
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
name|tp
operator|->
name|owrite
operator|+
name|len
operator|+
literal|1
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
operator|*
name|was_hex
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Txt_indent and txt_outdent are truly strange.  ^T and ^D do movements  * to the next or previous shiftwidth value, i.e. for a 1-based numbering,  * with shiftwidth=3, ^T moves a cursor on the 7th, 8th or 9th column to  * the 10th column, and ^D moves it back.  *  * !!!  * The ^T and ^D characters in historical vi only had special meaning when  * they were the first characters typed after entering text input mode.  * Since normal erase characters couldn't erase autoindent (in this case  * ^T) characters, this meant that inserting text into previously existing  * text was quite strange, ^T only worked if it was the first keystroke,  * and then it could only be erased by using ^D.  This implementation treats  * ^T specially anywhere it occurs in the input, and permits the standard  * erase characters to erase characters inserted using it.  *  * XXX  * Technically, txt_indent, txt_outdent should part of the screen interface,  * as they require knowledge of the size of a space character on the screen.  * (Not the size of tabs, because tabs are logically composed of spaces.)  * They're left in the text code  because they're complicated, not to mention  * the gruesome awareness that if spaces aren't a single column on the screen  * for any language, we're into some serious, ah, for lack of a better word,  * "issues".  */
end_comment

begin_comment
comment|/*  * txt_indent --  *	Handle ^T indents.  */
end_comment

begin_function
specifier|static
name|int
name|txt_indent
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
block|{
name|u_long
name|sw
decl_stmt|,
name|ts
decl_stmt|;
name|size_t
name|cno
decl_stmt|,
name|off
decl_stmt|,
name|scno
decl_stmt|,
name|spaces
decl_stmt|,
name|tabs
decl_stmt|;
name|ts
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_TABSTOP
argument_list|)
expr_stmt|;
name|sw
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_SHIFTWIDTH
argument_list|)
expr_stmt|;
comment|/* Get the current screen column. */
for|for
control|(
name|off
operator|=
name|scno
operator|=
literal|0
init|;
name|off
operator|<
name|sp
operator|->
name|cno
condition|;
operator|++
name|off
control|)
if|if
condition|(
name|tp
operator|->
name|lb
index|[
name|off
index|]
operator|==
literal|'\t'
condition|)
name|scno
operator|+=
name|STOP_OFF
argument_list|(
name|scno
argument_list|,
name|ts
argument_list|)
expr_stmt|;
else|else
operator|++
name|scno
expr_stmt|;
comment|/* Count up spaces/tabs needed to get to the target. */
for|for
control|(
name|cno
operator|=
name|scno
operator|,
name|scno
operator|+=
name|STOP_OFF
argument_list|(
name|scno
argument_list|,
name|sw
argument_list|)
operator|,
name|tabs
operator|=
literal|0
init|;
name|cno
operator|+
name|STOP_OFF
argument_list|(
name|cno
argument_list|,
name|ts
argument_list|)
operator|<=
name|scno
condition|;
operator|++
name|tabs
control|)
name|cno
operator|+=
name|STOP_OFF
argument_list|(
name|cno
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|spaces
operator|=
name|scno
operator|-
name|cno
expr_stmt|;
comment|/* Put space/tab characters in place of any overwrite characters. */
for|for
control|(
init|;
name|tp
operator|->
name|owrite
operator|&&
name|tabs
condition|;
operator|--
name|tp
operator|->
name|owrite
operator|,
operator|--
name|tabs
operator|,
operator|++
name|tp
operator|->
name|ai
control|)
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|++
index|]
operator|=
literal|'\t'
expr_stmt|;
for|for
control|(
init|;
name|tp
operator|->
name|owrite
operator|&&
name|spaces
condition|;
operator|--
name|tp
operator|->
name|owrite
operator|,
operator|--
name|spaces
operator|,
operator|++
name|tp
operator|->
name|ai
control|)
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|!
name|tabs
operator|&&
operator|!
name|spaces
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Make sure there's enough room. */
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
name|spaces
operator|+
name|tabs
argument_list|)
expr_stmt|;
comment|/* Move the insert characters out of the way. */
if|if
condition|(
name|tp
operator|->
name|insert
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
name|spaces
operator|+
name|tabs
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
comment|/* Add new space/tab characters. */
for|for
control|(
init|;
name|tabs
operator|--
condition|;
operator|++
name|tp
operator|->
name|len
operator|,
operator|++
name|tp
operator|->
name|ai
control|)
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|++
index|]
operator|=
literal|'\t'
expr_stmt|;
for|for
control|(
init|;
name|spaces
operator|--
condition|;
operator|++
name|tp
operator|->
name|len
operator|,
operator|++
name|tp
operator|->
name|ai
control|)
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_outdent --  *	Handle ^D outdents.  *  */
end_comment

begin_function
specifier|static
name|int
name|txt_outdent
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
block|{
name|u_long
name|sw
decl_stmt|,
name|ts
decl_stmt|;
name|size_t
name|cno
decl_stmt|,
name|off
decl_stmt|,
name|scno
decl_stmt|,
name|spaces
decl_stmt|;
name|ts
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_TABSTOP
argument_list|)
expr_stmt|;
name|sw
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_SHIFTWIDTH
argument_list|)
expr_stmt|;
comment|/* Get the current screen column. */
for|for
control|(
name|off
operator|=
name|scno
operator|=
literal|0
init|;
name|off
operator|<
name|sp
operator|->
name|cno
condition|;
operator|++
name|off
control|)
if|if
condition|(
name|tp
operator|->
name|lb
index|[
name|off
index|]
operator|==
literal|'\t'
condition|)
name|scno
operator|+=
name|STOP_OFF
argument_list|(
name|scno
argument_list|,
name|ts
argument_list|)
expr_stmt|;
else|else
operator|++
name|scno
expr_stmt|;
comment|/* Get the previous shiftwidth column. */
for|for
control|(
name|cno
operator|=
name|scno
init|;
operator|--
name|scno
operator|%
name|sw
operator|!=
literal|0
condition|;
control|)
empty_stmt|;
comment|/* Decrement characters until less than or equal to that slot. */
for|for
control|(
init|;
name|cno
operator|>
name|scno
condition|;
operator|--
name|sp
operator|->
name|cno
operator|,
operator|--
name|tp
operator|->
name|ai
operator|,
operator|++
name|tp
operator|->
name|owrite
control|)
if|if
condition|(
name|tp
operator|->
name|lb
index|[
operator|--
name|off
index|]
operator|==
literal|'\t'
condition|)
name|cno
operator|-=
name|STOP_OFF
argument_list|(
name|cno
argument_list|,
name|ts
argument_list|)
expr_stmt|;
else|else
operator|--
name|cno
expr_stmt|;
comment|/* Spaces needed to get to the target. */
name|spaces
operator|=
name|scno
operator|-
name|cno
expr_stmt|;
comment|/* Maybe just a delete. */
if|if
condition|(
name|spaces
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Make sure there's enough room. */
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|lb_len
argument_list|,
name|tp
operator|->
name|len
operator|+
name|spaces
argument_list|)
expr_stmt|;
comment|/* Use up any overwrite characters. */
for|for
control|(
init|;
name|tp
operator|->
name|owrite
operator|&&
name|spaces
condition|;
operator|--
name|spaces
operator|,
operator|++
name|tp
operator|->
name|ai
operator|,
operator|--
name|tp
operator|->
name|owrite
control|)
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* Maybe that was enough. */
if|if
condition|(
name|spaces
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Move the insert characters out of the way. */
if|if
condition|(
name|tp
operator|->
name|insert
condition|)
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
operator|+
name|spaces
argument_list|,
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
argument_list|,
name|tp
operator|->
name|insert
argument_list|)
expr_stmt|;
comment|/* Add new space characters. */
for|for
control|(
init|;
name|spaces
operator|--
condition|;
operator|++
name|tp
operator|->
name|len
operator|,
operator|++
name|tp
operator|->
name|ai
control|)
name|tp
operator|->
name|lb
index|[
name|sp
operator|->
name|cno
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_resolve --  *	Resolve the input text chain into the file.  */
end_comment

begin_function
specifier|static
name|int
name|txt_resolve
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|tiqh
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|TEXTH
modifier|*
name|tiqh
decl_stmt|;
block|{
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
comment|/* The first line replaces a current line. */
name|tp
operator|=
name|tiqh
operator|->
name|cqh_first
expr_stmt|;
if|if
condition|(
name|file_sline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tp
operator|->
name|lno
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* All subsequent lines are appended into the file. */
for|for
control|(
name|lno
operator|=
name|tp
operator|->
name|lno
init|;
operator|(
name|tp
operator|=
name|tp
operator|->
name|q
operator|.
name|cqe_next
operator|)
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|sp
operator|->
name|tiq
condition|;
operator|++
name|lno
control|)
if|if
condition|(
name|file_aline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
literal|0
argument_list|,
name|lno
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_showmatch --  *	Show a character match.  *  * !!!  * Historic vi tried to display matches even in the :colon command line.  * I think not.  */
end_comment

begin_function
specifier|static
name|void
name|txt_showmatch
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|struct
name|timeval
name|second
decl_stmt|;
name|VCS
name|cs
decl_stmt|;
name|MARK
name|m
decl_stmt|;
name|fd_set
name|zero
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|endc
decl_stmt|,
name|startc
decl_stmt|;
comment|/* 	 * Do a refresh first, in case the v_ntext() code hasn't done 	 * one in awhile, so the user can see what we're complaining 	 * about. 	 */
if|if
condition|(
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return;
comment|/* 	 * We don't display the match if it's not on the screen.  Find 	 * out what the first character on the screen is. 	 */
if|if
condition|(
name|sp
operator|->
name|s_position
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|,
name|P_TOP
argument_list|)
condition|)
return|return;
comment|/* Initialize the getc() interface. */
name|cs
operator|.
name|cs_lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|cs
operator|.
name|cs_cno
operator|=
name|sp
operator|->
name|cno
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cs_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cs
argument_list|)
condition|)
return|return;
name|startc
operator|=
operator|(
name|endc
operator|=
name|cs
operator|.
name|cs_ch
operator|)
operator|==
literal|')'
condition|?
literal|'('
else|:
literal|'{'
expr_stmt|;
comment|/* Search for the match. */
for|for
control|(
name|cnt
operator|=
literal|1
init|;
condition|;
control|)
block|{
if|if
condition|(
name|cs_prev
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cs
argument_list|)
condition|)
return|return;
if|if
condition|(
name|cs
operator|.
name|cs_lno
operator|<
name|m
operator|.
name|lno
operator|||
name|cs
operator|.
name|cs_lno
operator|==
name|m
operator|.
name|lno
operator|&&
name|cs
operator|.
name|cs_cno
operator|<
name|m
operator|.
name|cno
condition|)
return|return;
if|if
condition|(
name|cs
operator|.
name|cs_flags
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cs
operator|.
name|cs_flags
operator|==
name|CS_EOF
operator|||
name|cs
operator|.
name|cs_flags
operator|==
name|CS_SOF
condition|)
block|{
operator|(
name|void
operator|)
name|sp
operator|->
name|s_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
continue|continue;
block|}
if|if
condition|(
name|cs
operator|.
name|cs_ch
operator|==
name|endc
condition|)
operator|++
name|cnt
expr_stmt|;
elseif|else
if|if
condition|(
name|cs
operator|.
name|cs_ch
operator|==
name|startc
operator|&&
operator|--
name|cnt
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Move to the match. */
name|m
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|sp
operator|->
name|lno
operator|=
name|cs
operator|.
name|cs_lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|cs
operator|.
name|cs_cno
expr_stmt|;
operator|(
name|void
operator|)
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* 	 * Sleep(3) is eight system calls.  Do it fast -- besides, 	 * I don't want to wait an entire second. 	 */
name|FD_ZERO
argument_list|(
operator|&
name|zero
argument_list|)
expr_stmt|;
name|second
operator|.
name|tv_sec
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_MATCHTIME
argument_list|)
operator|/
literal|10
expr_stmt|;
name|second
operator|.
name|tv_usec
operator|=
operator|(
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_MATCHTIME
argument_list|)
operator|%
literal|10
operator|)
operator|*
literal|100000L
expr_stmt|;
operator|(
name|void
operator|)
name|select
argument_list|(
literal|0
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|second
argument_list|)
expr_stmt|;
comment|/* Return to the current location. */
name|sp
operator|->
name|lno
operator|=
name|m
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|m
operator|.
name|cno
expr_stmt|;
operator|(
name|void
operator|)
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * txt_margin --  *	Handle margin wrap.  *  * !!!  * Historic vi belled the user each time a character was entered after  * crossing the margin until a space was entered which could be used to  * break the line.  I don't, it tends to wake the cats.  */
end_comment

begin_function
specifier|static
name|int
name|txt_margin
parameter_list|(
name|sp
parameter_list|,
name|tp
parameter_list|,
name|didbreak
parameter_list|,
name|pushcp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|didbreak
decl_stmt|;
name|CHAR_T
modifier|*
name|pushcp
decl_stmt|;
block|{
name|CHAR_T
name|ch
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|off
decl_stmt|,
name|tlen
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|wp
decl_stmt|;
comment|/* Find the closest previous blank. */
for|for
control|(
name|off
operator|=
name|sp
operator|->
name|cno
operator|-
literal|1
operator|,
name|p
operator|=
name|tp
operator|->
name|lb
operator|+
name|off
operator|,
name|len
operator|=
literal|0
init|;
condition|;
operator|--
name|p
operator|,
operator|--
name|off
control|)
block|{
if|if
condition|(
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|wp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
break|break;
block|}
operator|++
name|len
expr_stmt|;
comment|/* If it's the beginning of the line, there's nothing to do. */
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|ai
operator|||
name|off
operator|==
name|tp
operator|->
name|offset
condition|)
block|{
operator|*
name|didbreak
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Historic practice is to delete any trailing whitespace 	 * from the previous line. 	 */
for|for
control|(
name|tlen
operator|=
name|len
init|;
condition|;
operator|--
name|p
operator|,
operator|--
name|off
control|)
block|{
if|if
condition|(
operator|!
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
operator|++
name|tlen
expr_stmt|;
if|if
condition|(
name|off
operator|==
name|tp
operator|->
name|ai
operator|||
name|off
operator|==
name|tp
operator|->
name|offset
condition|)
break|break;
block|}
name|ch
operator|=
operator|*
name|pushcp
expr_stmt|;
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|CH_NOMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|len
operator|&&
name|term_push
argument_list|(
name|sp
argument_list|,
name|wp
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|CH_NOMAP
operator||
name|CH_QUOTED
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ch
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|CH_NOMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sp
operator|->
name|cno
operator|-=
name|tlen
expr_stmt|;
name|tp
operator|->
name|owrite
operator|+=
name|tlen
expr_stmt|;
operator|*
name|didbreak
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * txt_Rcleanup --  *	Resolve the input line for the 'R' command.  */
end_comment

begin_function
specifier|static
name|void
name|txt_Rcleanup
parameter_list|(
name|sp
parameter_list|,
name|tiqh
parameter_list|,
name|tp
parameter_list|,
name|lp
parameter_list|,
name|len
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXTH
modifier|*
name|tiqh
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
specifier|const
name|char
modifier|*
name|lp
decl_stmt|;
specifier|const
name|size_t
name|len
decl_stmt|;
block|{
name|size_t
name|tmp
decl_stmt|;
comment|/* 	 * The 'R' command restores any overwritable characters in the 	 * first line to the original characters.  Check to make sure 	 * that the cursor hasn't moved beyond the end of the original 	 * line. 	 */
if|if
condition|(
name|tp
operator|!=
name|tiqh
operator|->
name|cqh_first
operator|||
name|tp
operator|->
name|owrite
operator|==
literal|0
operator|||
name|sp
operator|->
name|cno
operator|>=
name|len
condition|)
return|return;
comment|/* Restore whatever we can restore from the original line. */
name|tmp
operator|=
name|MIN
argument_list|(
name|tp
operator|->
name|owrite
argument_list|,
name|len
operator|-
name|sp
operator|->
name|cno
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|tp
operator|->
name|lb
operator|+
name|sp
operator|->
name|cno
argument_list|,
name|lp
operator|+
name|sp
operator|->
name|cno
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 	 * There can be more overwrite characters if the user extended the 	 * line and then erased it.  What we have to do is delete whatever 	 * the user inserted and then erased.  Regardless, we increase the 	 * insert character count to make the TEXT structure look right. 	 * (There shouldn't be any insert characters as 'R' replaces the 	 * entire line; if there are, this code isn't going to work). 	 */
if|if
condition|(
name|tp
operator|->
name|owrite
operator|>
name|tmp
condition|)
name|tp
operator|->
name|len
operator|-=
name|tp
operator|->
name|owrite
operator|-
name|tmp
expr_stmt|;
name|tp
operator|->
name|owrite
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|insert
operator|=
name|tmp
expr_stmt|;
block|}
end_function

end_unit

