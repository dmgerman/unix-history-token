begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* modify.c */
end_comment

begin_comment
comment|/* This file contains the low-level file modification functions:  *	delete(frommark, tomark)	- removes line or portions of lines  *	add(frommark, text)		- inserts new text  *	change(frommark, tomark, text)	- delete, then add  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG2
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|dbg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|debout
argument_list|(
argument|msg
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|,
modifier|*
name|arg4
decl_stmt|,
modifier|*
name|arg5
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|dbg
condition|)
block|{
name|dbg
operator|=
name|fopen
argument_list|(
literal|"debug.out"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbg
condition|)
return|return;
name|setbuf
argument_list|(
name|dbg
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dbg
argument_list|,
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG2 */
end_comment

begin_comment
comment|/* delete a range of text from the file */
end_comment

begin_function
name|void
name|delete
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
comment|/* first char to be deleted */
name|MARK
name|tomark
decl_stmt|;
comment|/* AFTER last char to be deleted */
block|{
name|int
name|i
decl_stmt|;
comment|/* used to move thru logical blocks */
name|REG
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* used to scan thru text of the blk */
name|REG
name|char
modifier|*
name|cpy
decl_stmt|;
comment|/* used when copying chars */
name|BLK
modifier|*
name|blk
decl_stmt|;
comment|/* a text block */
name|long
name|l
decl_stmt|;
comment|/* a line number */
name|MARK
name|m
decl_stmt|;
comment|/* a traveling version of frommark */
ifdef|#
directive|ifdef
name|DEBUG2
name|debout
argument_list|(
literal|"delete(%ld.%d, %ld.%d)\n"
argument_list|,
name|markline
argument_list|(
name|frommark
argument_list|)
argument_list|,
name|markidx
argument_list|(
name|frommark
argument_list|)
argument_list|,
name|markline
argument_list|(
name|tomark
argument_list|)
argument_list|,
name|markidx
argument_list|(
name|tomark
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* if not deleting anything, quit now */
if|if
condition|(
name|frommark
operator|==
name|tomark
condition|)
block|{
return|return;
block|}
comment|/* This is a change */
name|changes
operator|++
expr_stmt|;
name|significant
operator|=
name|TRUE
expr_stmt|;
comment|/* supply clues to the redraw module */
name|redrawrange
argument_list|(
name|markline
argument_list|(
name|frommark
argument_list|)
argument_list|,
name|markline
argument_list|(
name|tomark
argument_list|)
argument_list|,
name|markline
argument_list|(
name|frommark
argument_list|)
argument_list|)
expr_stmt|;
comment|/* adjust marks 'a through 'z and '' as needed */
name|l
operator|=
name|markline
argument_list|(
name|tomark
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMARKS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mark
index|[
name|i
index|]
operator|<
name|frommark
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|mark
index|[
name|i
index|]
operator|<
name|tomark
condition|)
block|{
name|mark
index|[
name|i
index|]
operator|=
name|MARK_UNSET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|markline
argument_list|(
name|mark
index|[
name|i
index|]
argument_list|)
operator|==
name|l
condition|)
block|{
if|if
condition|(
name|markline
argument_list|(
name|frommark
argument_list|)
operator|==
name|l
condition|)
block|{
name|mark
index|[
name|i
index|]
operator|-=
name|markidx
argument_list|(
name|tomark
argument_list|)
operator|-
name|markidx
argument_list|(
name|frommark
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mark
index|[
name|i
index|]
operator|-=
name|markidx
argument_list|(
name|tomark
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mark
index|[
name|i
index|]
operator|-=
name|MARK_AT_LINE
argument_list|(
name|l
operator|-
name|markline
argument_list|(
name|frommark
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reporting... */
if|if
condition|(
name|markidx
argument_list|(
name|frommark
argument_list|)
operator|==
literal|0
operator|&&
name|markidx
argument_list|(
name|tomark
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rptlines
operator|=
name|markline
argument_list|(
name|tomark
argument_list|)
operator|-
name|markline
argument_list|(
name|frommark
argument_list|)
expr_stmt|;
name|rptlabel
operator|=
literal|"deleted"
expr_stmt|;
block|}
comment|/* find the block containing frommark */
name|l
operator|=
name|markline
argument_list|(
name|frommark
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|lnum
index|[
name|i
index|]
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{ 	}
comment|/* process each affected block... */
for|for
control|(
name|m
operator|=
name|frommark
init|;
name|m
operator|<
name|tomark
operator|&&
name|lnum
index|[
name|i
index|]
operator|<
name|INFINITY
condition|;
name|m
operator|=
name|MARK_AT_LINE
argument_list|(
name|lnum
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1
argument_list|)
control|)
block|{
comment|/* fetch the block */
name|blk
operator|=
name|blkget
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* find the mark in the block */
name|scan
operator|=
name|blk
operator|->
name|c
expr_stmt|;
for|for
control|(
name|l
operator|=
name|markline
argument_list|(
name|m
argument_list|)
operator|-
name|lnum
index|[
name|i
operator|-
literal|1
index|]
operator|-
literal|1
init|;
name|l
operator|>
literal|0
condition|;
name|l
operator|--
control|)
block|{
while|while
condition|(
operator|*
name|scan
operator|++
operator|!=
literal|'\n'
condition|)
block|{ 			}
block|}
name|scan
operator|+=
name|markidx
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* figure out where the changes to this block end */
if|if
condition|(
name|markline
argument_list|(
name|tomark
argument_list|)
operator|>
name|lnum
index|[
name|i
index|]
condition|)
block|{
name|cpy
operator|=
name|blk
operator|->
name|c
operator|+
name|BLKSIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|markline
argument_list|(
name|tomark
argument_list|)
operator|==
name|markline
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|cpy
operator|=
name|scan
operator|-
name|markidx
argument_list|(
name|m
argument_list|)
operator|+
name|markidx
argument_list|(
name|tomark
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cpy
operator|=
name|scan
expr_stmt|;
for|for
control|(
name|l
operator|=
name|markline
argument_list|(
name|tomark
argument_list|)
operator|-
name|markline
argument_list|(
name|m
argument_list|)
init|;
name|l
operator|>
literal|0
condition|;
name|l
operator|--
control|)
block|{
while|while
condition|(
operator|*
name|cpy
operator|++
operator|!=
literal|'\n'
condition|)
block|{ 				}
block|}
name|cpy
operator|+=
name|markidx
argument_list|(
name|tomark
argument_list|)
expr_stmt|;
block|}
comment|/* delete the stuff by moving chars within this block */
while|while
condition|(
name|cpy
operator|<
name|blk
operator|->
name|c
operator|+
name|BLKSIZE
condition|)
block|{
operator|*
name|scan
operator|++
operator|=
operator|*
name|cpy
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|scan
operator|<
name|blk
operator|->
name|c
operator|+
name|BLKSIZE
condition|)
block|{
operator|*
name|scan
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* adjust tomark to allow for lines deleted from this block */
name|tomark
operator|-=
name|MARK_AT_LINE
argument_list|(
name|lnum
index|[
name|i
index|]
operator|+
literal|1
operator|-
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if this block isn't empty now, then advance i */
if|if
condition|(
operator|*
name|blk
operator|->
name|c
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
comment|/* the buffer has changed.  Update hdr and lnum. */
name|blkdirty
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
comment|/* must have at least 1 line */
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
block|{
name|blk
operator|=
name|blkadd
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|blk
operator|->
name|c
index|[
literal|0
index|]
operator|=
literal|'\n'
expr_stmt|;
name|blkdirty
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|MARK_FIRST
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* add some text at a specific place in the file */
end_comment

begin_function
name|void
name|add
parameter_list|(
name|atmark
parameter_list|,
name|newtext
parameter_list|)
name|MARK
name|atmark
decl_stmt|;
comment|/* where to insert the new text */
name|char
modifier|*
name|newtext
decl_stmt|;
comment|/* NUL-terminated string to insert */
block|{
name|REG
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* used to move through string */
name|REG
name|char
modifier|*
name|build
decl_stmt|;
comment|/* used while copying chars */
name|int
name|addlines
decl_stmt|;
comment|/* number of lines we're adding */
name|int
name|lastpart
decl_stmt|;
comment|/* size of last partial line */
name|BLK
modifier|*
name|blk
decl_stmt|;
comment|/* the block to be modified */
name|int
name|blkno
decl_stmt|;
comment|/* the logical block# of (*blk) */
name|REG
name|char
modifier|*
name|newptr
decl_stmt|;
comment|/* where new text starts in blk */
name|BLK
name|buf
decl_stmt|;
comment|/* holds chars from orig blk */
name|BLK
name|linebuf
decl_stmt|;
comment|/* holds part of line that didn't fit */
name|BLK
modifier|*
name|following
decl_stmt|;
comment|/* the BLK following the last BLK */
name|int
name|i
decl_stmt|;
name|long
name|l
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG2
name|debout
argument_list|(
literal|"add(%ld.%d, \"%s\")\n"
argument_list|,
name|markline
argument_list|(
name|atmark
argument_list|)
argument_list|,
name|markidx
argument_list|(
name|atmark
argument_list|)
argument_list|,
name|newtext
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|lint
name|buf
operator|.
name|c
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* if not adding anything, return now */
if|if
condition|(
operator|!
operator|*
name|newtext
condition|)
block|{
return|return;
block|}
comment|/* This is a change */
name|changes
operator|++
expr_stmt|;
name|significant
operator|=
name|TRUE
expr_stmt|;
comment|/* count the number of lines in the new text */
for|for
control|(
name|scan
operator|=
name|newtext
operator|,
name|lastpart
operator|=
name|addlines
operator|=
literal|0
init|;
operator|*
name|scan
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|scan
operator|++
operator|==
literal|'\n'
condition|)
block|{
name|addlines
operator|++
expr_stmt|;
name|lastpart
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lastpart
operator|++
expr_stmt|;
block|}
block|}
comment|/* Reporting... */
if|if
condition|(
name|lastpart
operator|==
literal|0
operator|&&
name|markidx
argument_list|(
name|atmark
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rptlines
operator|=
name|addlines
expr_stmt|;
name|rptlabel
operator|=
literal|"added"
expr_stmt|;
block|}
comment|/* extract the line# from atmark */
name|l
operator|=
name|markline
argument_list|(
name|atmark
argument_list|)
expr_stmt|;
comment|/* supply clues to the redraw module */
if|if
condition|(
operator|(
name|markidx
argument_list|(
name|atmark
argument_list|)
operator|==
literal|0
operator|&&
name|lastpart
operator|==
literal|0
operator|)
operator|||
name|addlines
operator|==
literal|0
condition|)
block|{
name|redrawrange
argument_list|(
name|l
argument_list|,
name|l
argument_list|,
name|l
operator|+
name|addlines
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* make sure the last line gets redrawn -- it was 		 * split, so its appearance has changed 		 */
name|redrawrange
argument_list|(
name|l
argument_list|,
name|l
operator|+
literal|1L
argument_list|,
name|l
operator|+
name|addlines
operator|+
literal|1L
argument_list|)
expr_stmt|;
block|}
comment|/* adjust marks 'a through 'z and '' as needed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMARKS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mark
index|[
name|i
index|]
operator|<
name|atmark
condition|)
block|{
comment|/* earlier line, or earlier in same line: no change */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|markline
argument_list|(
name|mark
index|[
name|i
index|]
argument_list|)
operator|>
name|l
condition|)
block|{
comment|/* later line: move down a whole number of lines */
name|mark
index|[
name|i
index|]
operator|+=
name|MARK_AT_LINE
argument_list|(
name|addlines
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* later in same line */
if|if
condition|(
name|addlines
operator|>
literal|0
condition|)
block|{
comment|/* multi-line add, which split this line: 				 * move down, and possibly left or right, 				 * depending on where the split was and how 				 * much text was inserted after the last \n 				 */
name|mark
index|[
name|i
index|]
operator|+=
name|MARK_AT_LINE
argument_list|(
name|addlines
argument_list|)
operator|+
name|lastpart
operator|-
name|markidx
argument_list|(
name|atmark
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* totally within this line: move right */
name|mark
index|[
name|i
index|]
operator|+=
name|lastpart
expr_stmt|;
block|}
block|}
block|}
comment|/* get the block to be modified */
for|for
control|(
name|blkno
operator|=
literal|1
init|;
name|lnum
index|[
name|blkno
index|]
operator|<
name|l
operator|&&
name|lnum
index|[
name|blkno
operator|+
literal|1
index|]
operator|<
name|INFINITY
condition|;
name|blkno
operator|++
control|)
block|{ 	}
name|blk
operator|=
name|blkget
argument_list|(
name|blkno
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|*
name|blk
expr_stmt|;
comment|/* figure out where the new text starts */
for|for
control|(
name|newptr
operator|=
name|buf
operator|.
name|c
operator|,
name|l
operator|=
name|markline
argument_list|(
name|atmark
argument_list|)
operator|-
name|lnum
index|[
name|blkno
operator|-
literal|1
index|]
operator|-
literal|1
init|;
name|l
operator|>
literal|0
condition|;
name|l
operator|--
control|)
block|{
while|while
condition|(
operator|*
name|newptr
operator|++
operator|!=
literal|'\n'
condition|)
block|{ 		}
block|}
name|newptr
operator|+=
name|markidx
argument_list|(
name|atmark
argument_list|)
expr_stmt|;
comment|/* keep start of old block */
name|build
operator|=
name|blk
operator|->
name|c
operator|+
call|(
name|int
call|)
argument_list|(
name|newptr
operator|-
name|buf
operator|.
name|c
argument_list|)
expr_stmt|;
comment|/* fill this block (or blocks) from the newtext string */
while|while
condition|(
operator|*
name|newtext
condition|)
block|{
while|while
condition|(
operator|*
name|newtext
operator|&&
name|build
operator|<
name|blk
operator|->
name|c
operator|+
name|BLKSIZE
operator|-
literal|1
condition|)
block|{
operator|*
name|build
operator|++
operator|=
operator|*
name|newtext
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|newtext
condition|)
block|{
comment|/* save the excess */
for|for
control|(
name|scan
operator|=
name|linebuf
operator|.
name|c
operator|+
name|BLKSIZE
init|;
name|build
operator|>
name|blk
operator|->
name|c
operator|&&
name|build
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|;
control|)
block|{
operator|*
operator|--
name|scan
operator|=
operator|*
operator|--
name|build
expr_stmt|;
block|}
comment|/* write the block */
while|while
condition|(
name|build
operator|<
name|blk
operator|->
name|c
operator|+
name|BLKSIZE
condition|)
block|{
operator|*
name|build
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|blkdirty
argument_list|(
name|blk
argument_list|)
expr_stmt|;
comment|/* add another block */
name|blkno
operator|++
expr_stmt|;
name|blk
operator|=
name|blkadd
argument_list|(
name|blkno
argument_list|)
expr_stmt|;
comment|/* copy in the excess from last time */
for|for
control|(
name|build
operator|=
name|blk
operator|->
name|c
init|;
name|scan
operator|<
name|linebuf
operator|.
name|c
operator|+
name|BLKSIZE
condition|;
control|)
block|{
operator|*
name|build
operator|++
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* fill this block(s) from remainder of orig block */
while|while
condition|(
name|newptr
operator|<
name|buf
operator|.
name|c
operator|+
name|BLKSIZE
operator|&&
operator|*
name|newptr
condition|)
block|{
while|while
condition|(
name|newptr
operator|<
name|buf
operator|.
name|c
operator|+
name|BLKSIZE
operator|&&
operator|*
name|newptr
operator|&&
name|build
operator|<
name|blk
operator|->
name|c
operator|+
name|BLKSIZE
operator|-
literal|1
condition|)
block|{
operator|*
name|build
operator|++
operator|=
operator|*
name|newptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|newptr
operator|<
name|buf
operator|.
name|c
operator|+
name|BLKSIZE
operator|&&
operator|*
name|newptr
condition|)
block|{
comment|/* save the excess */
for|for
control|(
name|scan
operator|=
name|linebuf
operator|.
name|c
operator|+
name|BLKSIZE
init|;
name|build
operator|>
name|blk
operator|->
name|c
operator|&&
name|build
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|;
control|)
block|{
operator|*
operator|--
name|scan
operator|=
operator|*
operator|--
name|build
expr_stmt|;
block|}
comment|/* write the block */
while|while
condition|(
name|build
operator|<
name|blk
operator|->
name|c
operator|+
name|BLKSIZE
condition|)
block|{
operator|*
name|build
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|blkdirty
argument_list|(
name|blk
argument_list|)
expr_stmt|;
comment|/* add another block */
name|blkno
operator|++
expr_stmt|;
name|blk
operator|=
name|blkadd
argument_list|(
name|blkno
argument_list|)
expr_stmt|;
comment|/* copy in the excess from last time */
for|for
control|(
name|build
operator|=
name|blk
operator|->
name|c
init|;
name|scan
operator|<
name|linebuf
operator|.
name|c
operator|+
name|BLKSIZE
condition|;
control|)
block|{
operator|*
name|build
operator|++
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* see if we can combine our last block with the following block */
if|if
condition|(
name|lnum
index|[
name|blkno
index|]
operator|<
name|nlines
operator|&&
name|lnum
index|[
name|blkno
operator|+
literal|1
index|]
operator|-
name|lnum
index|[
name|blkno
index|]
operator|<
operator|(
name|BLKSIZE
operator|>>
literal|6
operator|)
condition|)
block|{
comment|/* hey, we probably can!  Get the following block& see... */
name|following
operator|=
name|blkget
argument_list|(
name|blkno
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|following
operator|->
name|c
argument_list|)
operator|+
operator|(
name|build
operator|-
name|blk
operator|->
name|c
operator|)
operator|<
call|(
name|unsigned
call|)
argument_list|(
name|BLKSIZE
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* we can!  Copy text from following to blk */
for|for
control|(
name|scan
operator|=
name|following
operator|->
name|c
init|;
operator|*
name|scan
condition|;
control|)
block|{
operator|*
name|build
operator|++
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|build
operator|<
name|blk
operator|->
name|c
operator|+
name|BLKSIZE
condition|)
block|{
operator|*
name|build
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|blkdirty
argument_list|(
name|blk
argument_list|)
expr_stmt|;
comment|/* pretend the following was the last blk */
name|blk
operator|=
name|following
expr_stmt|;
name|build
operator|=
name|blk
operator|->
name|c
expr_stmt|;
block|}
block|}
comment|/* that last block is dirty by now */
while|while
condition|(
name|build
operator|<
name|blk
operator|->
name|c
operator|+
name|BLKSIZE
condition|)
block|{
operator|*
name|build
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|blkdirty
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* change the text of a file */
end_comment

begin_function
name|void
name|change
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|newtext
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|char
modifier|*
name|newtext
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|long
name|l
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|BLK
modifier|*
name|blk
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG2
name|debout
argument_list|(
literal|"change(%ld.%d, %ld.%d, \"%s\")\n"
argument_list|,
name|markline
argument_list|(
name|frommark
argument_list|)
argument_list|,
name|markidx
argument_list|(
name|frommark
argument_list|)
argument_list|,
name|markline
argument_list|(
name|tomark
argument_list|)
argument_list|,
name|markidx
argument_list|(
name|tomark
argument_list|)
argument_list|,
name|newtext
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* optimize for single-character replacement */
if|if
condition|(
name|frommark
operator|+
literal|1
operator|==
name|tomark
operator|&&
name|newtext
index|[
literal|0
index|]
operator|&&
operator|!
name|newtext
index|[
literal|1
index|]
operator|&&
name|newtext
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/* find the block containing frommark */
name|l
operator|=
name|markline
argument_list|(
name|frommark
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|lnum
index|[
name|i
index|]
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{ 		}
comment|/* get the block */
name|blk
operator|=
name|blkget
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* find the line within the block */
for|for
control|(
name|text
operator|=
name|blk
operator|->
name|c
operator|,
name|i
operator|=
name|l
operator|-
name|lnum
index|[
name|i
operator|-
literal|1
index|]
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|text
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|text
operator|==
literal|'\n'
condition|)
block|{
name|i
operator|--
expr_stmt|;
block|}
block|}
comment|/* replace the char */
name|text
operator|+=
name|markidx
argument_list|(
name|frommark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|text
operator|==
name|newtext
index|[
literal|0
index|]
condition|)
block|{
comment|/* no change was needed - same char */
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|text
operator|!=
literal|'\n'
condition|)
block|{
comment|/* This is a change */
name|changes
operator|++
expr_stmt|;
name|significant
operator|=
name|TRUE
expr_stmt|;
name|ChangeText
block|{
operator|*
name|text
operator|=
name|newtext
index|[
literal|0
index|]
expr_stmt|;
name|blkdirty
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
name|redrawrange
argument_list|(
name|markline
argument_list|(
name|frommark
argument_list|)
argument_list|,
name|markline
argument_list|(
name|tomark
argument_list|)
argument_list|,
name|markline
argument_list|(
name|frommark
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* else it is a complex change involving newline... */
block|}
comment|/* couldn't optimize, so do delete& add */
name|ChangeText
block|{
name|delete
argument_list|(
name|frommark
argument_list|,
name|tomark
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|frommark
argument_list|,
name|newtext
argument_list|)
expr_stmt|;
name|rptlabel
operator|=
literal|"changed"
expr_stmt|;
block|}
block|}
end_function

end_unit

