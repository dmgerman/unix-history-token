begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* system.c  -- UNIX version */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains a new version of the system() function and related stuff.  *  * Entry points are:  *	system(cmd)		- run a single shell command  *	wildcard(names)		- expand wildcard characters in filanames  *	filter(m,n,cmd,back)	- run text lines through a filter program  *  * This is probably the single least portable file in the program.  The code  * shown here should work correctly if it links at all; it will work on UNIX  * and any O.S./Compiler combination which adheres to UNIX forking conventions.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|XDOS
end_ifndef

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ANY_UNIX
end_if

begin_comment
comment|/* This is a new version of the system() function.  The only difference  * between this one and the library one is: this one uses the o_shell option.  */
end_comment

begin_function
name|int
name|system
parameter_list|(
name|cmd
parameter_list|)
ifdef|#
directive|ifdef
name|__STDC__
specifier|const
endif|#
directive|endif
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* a command to run */
block|{
name|int
name|pid
decl_stmt|;
comment|/* process ID of child */
name|int
name|died
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* exit status of the command */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|pid
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* error */
name|msg
argument_list|(
literal|"fork() failed"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* child */
comment|/* for the child, close all files except stdin/out/err */
for|for
control|(
name|status
operator|=
literal|3
init|;
name|status
operator|<
literal|60
operator|&&
operator|(
name|close
argument_list|(
name|status
argument_list|)
operator|,
name|errno
operator|!=
name|EINVAL
operator|)
condition|;
name|status
operator|++
control|)
block|{ 		}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|o_shell
condition|)
block|{
name|execle
argument_list|(
name|o_shell
argument_list|,
name|o_shell
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|environ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execle
argument_list|(
name|o_shell
argument_list|,
name|o_shell
argument_list|,
literal|"-c"
argument_list|,
name|cmd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|environ
argument_list|)
expr_stmt|;
block|}
name|msg
argument_list|(
literal|"execle(\"%s\", ...) failed"
argument_list|,
name|o_shell
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* if we get here, the exec failed */
default|default:
comment|/* parent */
do|do
block|{
name|died
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|died
operator|>=
literal|0
operator|&&
name|died
operator|!=
name|pid
condition|)
do|;
if|if
condition|(
name|died
operator|<
literal|0
condition|)
block|{
name|status
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|trapint
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* This private function opens a pipe from a filter.  It is similar to the  * system() function above, and to popen(cmd, "r").  */
end_comment

begin_function
name|int
name|rpipe
parameter_list|(
name|cmd
parameter_list|,
name|in
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* the filter command to use */
name|int
name|in
decl_stmt|;
comment|/* the fd to use for stdin */
block|{
name|int
name|r0w1
index|[
literal|2
index|]
decl_stmt|;
comment|/* the pipe fd's */
comment|/* make the pipe */
if|if
condition|(
name|pipe
argument_list|(
name|r0w1
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|/* pipe failed */
block|}
comment|/* The parent process (elvis) ignores signals while the filter runs. 	 * The child (the filter program) will reset this, so that it can 	 * catch the signal. 	 */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* error */
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
comment|/* child */
comment|/* close the "read" end of the pipe */
name|close
argument_list|(
name|r0w1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* redirect stdout to go to the "write" end of the pipe */
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|r0w1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|r0w1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|r0w1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* redirect stdin */
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
comment|/* the filter should accept SIGINT signals */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* exec the shell to run the command */
name|execle
argument_list|(
name|o_shell
argument_list|,
name|o_shell
argument_list|,
literal|"-c"
argument_list|,
name|cmd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|environ
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* if we get here, exec failed */
default|default:
comment|/* parent */
comment|/* close the "write" end of the pipe */
name|close
argument_list|(
name|r0w1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|r0w1
index|[
literal|0
index|]
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* non-DOS */
end_comment

begin_if
if|#
directive|if
name|OSK
end_if

begin_comment
comment|/* This private function opens a pipe from a filter.  It is similar to the  * system() function above, and to popen(cmd, "r").  */
end_comment

begin_function
name|int
name|rpipe
parameter_list|(
name|cmd
parameter_list|,
name|in
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* the filter command to use */
name|int
name|in
decl_stmt|;
comment|/* the fd to use for stdin */
block|{
return|return
name|osk_popen
argument_list|(
name|cmd
argument_list|,
literal|"r"
argument_list|,
name|in
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ANY_UNIX
operator|||
name|OSK
end_if

begin_comment
comment|/* This function closes the pipe opened by rpipe(), and returns 0 for success */
end_comment

begin_function
name|int
name|rpclose
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|trapint
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* non-DOS */
end_comment

begin_comment
comment|/* This function expands wildcards in a filename or filenames.  It does this  * by running the "echo" command on the filenames via the shell; it is assumed  * that the shell will expand the names for you.  If for any reason it can't  * run echo, then it returns the names unmodified.  */
end_comment

begin_if
if|#
directive|if
name|MSDOS
operator|||
name|TOS
end_if

begin_define
define|#
directive|define
name|PROG
value|"wildcard "
end_define

begin_define
define|#
directive|define
name|PROGLEN
value|9
end_define

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PROG
value|"echo "
end_define

begin_define
define|#
directive|define
name|PROGLEN
value|5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|AMIGA
end_if

begin_function
name|char
modifier|*
name|wildcard
parameter_list|(
name|names
parameter_list|)
name|char
modifier|*
name|names
decl_stmt|;
block|{
if|#
directive|if
name|VMS
comment|/*     We could use expand() [vmswild.c], but what's the point on VMS?     Anyway, echo is the wrong thing to do, it takes too long to build    a subprocess on VMS and any "echo" program would have to be supplied    by elvis.  More importantly, many VMS utilities expand names     themselves (the shell doesn't do any expansion) so the concept is    non-native.  jdc */
return|return
name|names
return|;
else|#
directive|else
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|fd
decl_stmt|;
name|REG
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
comment|/* build the echo command */
if|if
condition|(
name|names
operator|!=
name|tmpblk
operator|.
name|c
condition|)
block|{
comment|/* the names aren't in tmpblk.c, so we can do it the easy way */
name|strcpy
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
name|PROG
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* the names are already in tmpblk.c, so shift them to make 		 * room for the word "echo " 		 */
for|for
control|(
name|s
operator|=
name|names
operator|+
name|strlen
argument_list|(
name|names
argument_list|)
operator|+
literal|1
operator|,
name|d
operator|=
name|s
operator|+
name|PROGLEN
init|;
name|s
operator|>
name|names
condition|;
control|)
block|{
operator|*
operator|--
name|d
operator|=
operator|*
operator|--
name|s
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|names
argument_list|,
name|PROG
argument_list|,
name|PROGLEN
argument_list|)
expr_stmt|;
block|}
comment|/* run the command& read the resulting names */
name|fd
operator|=
name|rpipe
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
name|names
return|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|j
operator|=
name|tread
argument_list|(
name|fd
argument_list|,
name|tmpblk
operator|.
name|c
operator|+
name|i
argument_list|,
name|BLKSIZE
operator|-
name|i
argument_list|)
expr_stmt|;
name|i
operator|+=
name|j
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|>
literal|0
condition|)
do|;
comment|/* successful? */
if|if
condition|(
name|rpclose
argument_list|(
name|fd
argument_list|)
operator|==
literal|0
operator|&&
name|j
operator|==
literal|0
operator|&&
name|i
operator|<
name|BLKSIZE
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* "i-1" so we clip off the newline */
return|return
name|tmpblk
operator|.
name|c
return|;
block|}
else|else
block|{
return|return
name|names
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function runs a range of lines through a filter program, and replaces  * the original text with the filtered version.  As a special case, if "to"  * is MARK_UNSET, then it runs the filter program with stdin coming from  * /dev/null, and inserts any output lines.  */
end_comment

begin_function
name|int
name|filter
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|cmd
parameter_list|,
name|back
parameter_list|)
name|MARK
name|from
decl_stmt|,
name|to
decl_stmt|;
comment|/* the range of lines to filter */
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* the filter command */
name|int
name|back
decl_stmt|;
comment|/* boolean: will we read lines back? */
block|{
name|int
name|scratch
decl_stmt|;
comment|/* fd of the scratch file */
name|int
name|fd
decl_stmt|;
comment|/* fd of the pipe from the filter */
name|char
name|scrout
index|[
literal|50
index|]
decl_stmt|;
comment|/* name of the scratch out file */
name|MARK
name|new
decl_stmt|;
comment|/* place where new text should go */
name|long
name|sent
decl_stmt|,
name|rcvd
decl_stmt|;
comment|/* number of lines sent/received */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* write the lines (if specified) to a temp file */
if|if
condition|(
name|to
condition|)
block|{
comment|/* we have lines */
if|#
directive|if
name|MSDOS
operator|||
name|TOS
name|strcpy
argument_list|(
name|scrout
argument_list|,
name|o_directory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|scrout
argument_list|)
operator|)
operator|&&
operator|!
name|strchr
argument_list|(
literal|"\\/:"
argument_list|,
name|scrout
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
name|scrout
index|[
name|i
operator|++
index|]
operator|=
name|SLASH
expr_stmt|;
name|strcpy
argument_list|(
name|scrout
operator|+
name|i
argument_list|,
name|SCRATCHOUT
operator|+
literal|3
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|scrout
argument_list|,
name|SCRATCHOUT
argument_list|,
name|o_directory
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mktemp
argument_list|(
name|scrout
argument_list|)
expr_stmt|;
name|cmd_write
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|CMD_BANG
argument_list|,
name|FALSE
argument_list|,
name|scrout
argument_list|)
expr_stmt|;
name|sent
operator|=
name|markline
argument_list|(
name|to
argument_list|)
operator|-
name|markline
argument_list|(
name|from
argument_list|)
operator|+
literal|1L
expr_stmt|;
comment|/* use those lines as stdin */
name|scratch
operator|=
name|open
argument_list|(
name|scrout
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch
operator|<
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|scrout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|scratch
operator|=
literal|0
expr_stmt|;
name|sent
operator|=
literal|0L
expr_stmt|;
block|}
comment|/* start the filter program */
if|#
directive|if
name|VMS
comment|/*  	   VMS doesn't know a thing about file descriptor 0.  The rpipe 	   concept is non-portable.  Hence we need a file name argument. 	*/
name|fd
operator|=
name|rpipe
argument_list|(
name|cmd
argument_list|,
name|scratch
argument_list|,
name|scrout
argument_list|)
expr_stmt|;
else|#
directive|else
name|fd
operator|=
name|rpipe
argument_list|(
name|cmd
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|to
condition|)
block|{
name|close
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|scrout
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|back
condition|)
block|{
name|ChangeText
block|{
comment|/* adjust MARKs for whole lines, and set "new" */
name|from
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|to
condition|)
block|{
name|to
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|to
operator|+=
name|BLKSIZE
expr_stmt|;
name|new
operator|=
name|to
expr_stmt|;
block|}
else|else
block|{
name|new
operator|=
name|from
operator|+
name|BLKSIZE
expr_stmt|;
block|}
if|#
directive|if
name|VMS
comment|/* Reading from a VMS mailbox (pipe) is record oriented... */
define|#
directive|define
name|tread
value|vms_pread
endif|#
directive|endif
comment|/* repeatedly read in new text and add it */
name|rcvd
operator|=
literal|0L
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|tread
argument_list|(
name|fd
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|,
name|BLKSIZE
operator|-
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|add
argument_list|(
name|new
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
if|#
directive|if
name|VMS
comment|/* What!  An advantage to record oriented reads? */
name|new
operator|+=
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
name|new
operator|=
operator|(
name|new
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|BLKSIZE
expr_stmt|;
name|rcvd
operator|++
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tmpblk
operator|.
name|c
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tmpblk
operator|.
name|c
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
name|new
operator|=
operator|(
name|new
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|BLKSIZE
expr_stmt|;
name|rcvd
operator|++
expr_stmt|;
block|}
else|else
block|{
name|new
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* delete old text, if any */
if|if
condition|(
name|to
condition|)
block|{
name|cut
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|delete
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* read the command's output, and copy it to the screen */
while|while
condition|(
operator|(
name|i
operator|=
name|tread
argument_list|(
name|fd
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|,
name|BLKSIZE
operator|-
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|addch
argument_list|(
name|tmpblk
operator|.
name|c
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|rcvd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Reporting... */
if|if
condition|(
name|sent
operator|>=
operator|*
name|o_report
operator|||
name|rcvd
operator|>=
operator|*
name|o_report
condition|)
block|{
if|if
condition|(
name|sent
operator|>
literal|0L
operator|&&
name|rcvd
operator|>
literal|0L
condition|)
block|{
name|msg
argument_list|(
literal|"%ld lines out, %ld lines back"
argument_list|,
name|sent
argument_list|,
name|rcvd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sent
operator|>
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"%ld lines written to filter"
argument_list|,
name|sent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
argument_list|(
literal|"%ld lines read from filter"
argument_list|,
name|rcvd
argument_list|)
expr_stmt|;
block|}
block|}
name|rptlines
operator|=
literal|0L
expr_stmt|;
comment|/* cleanup */
name|rpclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
condition|)
block|{
name|close
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|scrout
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

