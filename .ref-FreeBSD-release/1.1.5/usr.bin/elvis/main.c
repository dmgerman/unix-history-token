begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* main.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains the main() function of vi */
end_comment

begin_comment
comment|/* HACK! bcc needs to disable use of precompiled headers for this file,    or else command line args will not be passed to elvis */
end_comment

begin_if
if|#
directive|if
name|__BORLANDC__
end_if

begin_include
include|#
directive|include
file|"borland.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_function_decl
specifier|extern
name|SIGTYPE
name|trapint
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* defined below */
end_comment

begin_decl_stmt
name|jmp_buf
name|jmpenv
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DIGRAPH
end_ifndef

begin_expr_stmt
specifier|static
name|init_digraphs
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|AMIGA
end_if

begin_include
include|#
directive|include
file|"amiwild.c"
end_include

begin_expr_stmt
name|main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
else|#
directive|else
if|#
directive|if
name|VMS
include|#
directive|include
file|"vmswild.c"
expr|main
operator|(
name|argc
operator|,
name|argv
operator|)
else|#
directive|else
name|void
expr|main
operator|(
name|argc
operator|,
name|argv
operator|)
endif|#
directive|endif
endif|#
directive|endif
name|int
name|argc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cmd
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|char
modifier|*
name|err
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|tag
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* set mode to MODE_VI or MODE_EX depending on program name */
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'x'
case|:
comment|/* "ex" */
name|mode
operator|=
name|MODE_EX
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* "view" */
name|mode
operator|=
name|MODE_VI
expr_stmt|;
operator|*
name|o_readonly
operator|=
name|TRUE
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
case|case
literal|'t'
case|:
comment|/* "edit" or "input" */
name|mode
operator|=
name|MODE_VI
expr_stmt|;
operator|*
name|o_inputmode
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* "vi" or "elvis" */
name|mode
operator|=
name|MODE_VI
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|DEBUG
ifdef|#
directive|ifdef
name|SIGQUIT
comment|/* normally, we ignore SIGQUIT.  SIGINT is trapped later */
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* temporarily ignore SIGINT */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* start curses */
name|initscr
argument_list|()
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|scrollok
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* arrange for deadly signals to be caught */
ifdef|#
directive|ifdef
name|SIGHUP
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|deathtrap
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|DEBUG
ifdef|#
directive|ifdef
name|SIGILL
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|deathtrap
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGBUS
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|deathtrap
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGSEGV
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|deathtrap
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGSYS
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|deathtrap
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* !DEBUG */
ifdef|#
directive|ifdef
name|SIGPIPE
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|deathtrap
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|deathtrap
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGUSR1
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|deathtrap
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGUSR2
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|deathtrap
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* initialize the options - must be done after initscr(), so that 	 * we can alter LINES and COLS if necessary. 	 */
name|initopts
argument_list|()
expr_stmt|;
comment|/* map the arrow keys.  The KU,KD,KL,and KR variables correspond to 	 * the :ku=: (etc.) termcap capabilities.  The variables are defined 	 * as part of the curses package. 	 */
if|if
condition|(
name|has_KU
condition|)
name|mapkey
argument_list|(
name|has_KU
argument_list|,
literal|"k"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Up>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_KD
condition|)
name|mapkey
argument_list|(
name|has_KD
argument_list|,
literal|"j"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Down>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_KL
condition|)
name|mapkey
argument_list|(
name|has_KL
argument_list|,
literal|"h"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Left>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_KR
condition|)
name|mapkey
argument_list|(
name|has_KR
argument_list|,
literal|"l"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Right>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_HM
condition|)
name|mapkey
argument_list|(
name|has_HM
argument_list|,
literal|"^"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Home>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_EN
condition|)
name|mapkey
argument_list|(
name|has_EN
argument_list|,
literal|"$"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<End>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_PU
condition|)
name|mapkey
argument_list|(
name|has_PU
argument_list|,
literal|"\002"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<PageUp>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_PD
condition|)
name|mapkey
argument_list|(
name|has_PD
argument_list|,
literal|"\006"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<PageDn>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_KI
condition|)
name|mapkey
argument_list|(
name|has_KI
argument_list|,
literal|"i"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Insert>"
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS
if|#
directive|if
name|RAINBOW
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"rainbow"
argument_list|,
name|o_term
argument_list|)
condition|)
block|{
name|mapkey
argument_list|(
literal|"\033[1~"
argument_list|,
literal|"/"
argument_list|,
name|WHEN_VICMD
argument_list|,
literal|"<Find>"
argument_list|)
expr_stmt|;
name|mapkey
argument_list|(
literal|"\033[3~"
argument_list|,
literal|"x"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Remove>"
argument_list|)
expr_stmt|;
name|mapkey
argument_list|(
literal|"\033[4~"
argument_list|,
literal|"v"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Select>"
argument_list|)
expr_stmt|;
name|mapkey
argument_list|(
literal|"\033[17~"
argument_list|,
literal|":sh\n"
argument_list|,
name|WHEN_VICMD
argument_list|,
literal|"<Intrpt>"
argument_list|)
expr_stmt|;
name|mapkey
argument_list|(
literal|"\033[19~"
argument_list|,
literal|":q\n"
argument_list|,
name|WHEN_VICMD
argument_list|,
literal|"<Cancel>"
argument_list|)
expr_stmt|;
name|mapkey
argument_list|(
literal|"\033[21~"
argument_list|,
literal|"ZZ"
argument_list|,
name|WHEN_VICMD
argument_list|,
literal|"<Exit>"
argument_list|)
expr_stmt|;
name|mapkey
argument_list|(
literal|"\033[26~"
argument_list|,
literal|"V"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<AddlOp>"
argument_list|)
expr_stmt|;
name|mapkey
argument_list|(
literal|"\033[28~"
argument_list|,
literal|"\\"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Help>"
argument_list|)
expr_stmt|;
name|mapkey
argument_list|(
literal|"\033[29~"
argument_list|,
literal|"K"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Do>"
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* RAINBOW */
block|{
name|mapkey
argument_list|(
literal|"#S"
argument_list|,
literal|"x"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Delete>"
argument_list|)
expr_stmt|;
name|mapkey
argument_list|(
literal|"#s"
argument_list|,
literal|"B"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"^<Left>"
argument_list|)
expr_stmt|;
name|mapkey
argument_list|(
literal|"#t"
argument_list|,
literal|"W"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"^<Right>"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* not MSDOS */
if|#
directive|if
name|COHERENT
name|mapkey
argument_list|(
literal|"\033[P"
argument_list|,
literal|"x"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Del>"
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|AMIGA
name|mapkey
argument_list|(
literal|"\233?~"
argument_list|,
literal|"\\"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Help>"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ERASEKEY
operator|!=
literal|'\177'
condition|)
block|{
name|mapkey
argument_list|(
literal|"\177"
argument_list|,
literal|"x"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Del>"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_DIGRAPH
name|init_digraphs
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* NO_DIGRAPH */
comment|/* process any flags */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
operator|&&
operator|*
name|argv
index|[
name|i
index|]
operator|==
literal|'-'
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'R'
case|:
comment|/* readonly */
operator|*
name|o_readonly
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
case|case
literal|'r'
case|:
comment|/* recover */
name|msg
argument_list|(
literal|"Use the `elvrec` program to recover lost files"
argument_list|)
expr_stmt|;
name|endmsgs
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* tag */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
condition|)
block|{
name|tag
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
name|tag
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
comment|/* vi mode */
name|mode
operator|=
name|MODE_VI
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* ex mode */
name|mode
operator|=
name|MODE_EX
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
case|case
literal|'i'
case|:
comment|/* input mode */
operator|*
name|o_inputmode
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ERRLIST
case|case
literal|'m'
case|:
comment|/* use "errlist" as the errlist */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
condition|)
block|{
name|err
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|argc
condition|)
block|{
name|err
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
literal|""
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CRUNCH
case|case
literal|'c'
case|:
comment|/* run the following command, later */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
condition|)
block|{
name|cmd
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
comment|/* set the window size */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
condition|)
block|{
operator|*
name|o_window
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
name|wset
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|o_window
operator|=
name|atoi
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
name|wset
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|msg
argument_list|(
literal|"Ignoring unknown flag \"%s\""
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if we were given an initial ex command, save it... */
if|if
condition|(
name|i
operator|<
name|argc
operator|&&
operator|*
name|argv
index|[
name|i
index|]
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
name|cmd
operator|=
name|argv
index|[
name|i
operator|++
index|]
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
literal|"$"
expr_stmt|;
comment|/* "vi + file" means start at EOF */
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/* the remaining args are file names. */
if|if
condition|(
name|i
operator|<
name|argc
condition|)
block|{
name|strcpy
argument_list|(
name|args
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|argc
operator|&&
name|strlen
argument_list|(
name|args
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|<
sizeof|sizeof
name|args
condition|)
block|{
name|strcat
argument_list|(
name|args
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|args
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|MSDOS
operator|||
name|TOS
comment|/* expand wildcard characters, if necessary */
if|if
condition|(
name|strchr
argument_list|(
name|args
argument_list|,
literal|'*'
argument_list|)
operator|||
name|strchr
argument_list|(
name|args
argument_list|,
literal|'?'
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|args
argument_list|,
name|wildcard
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|strcpy
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|cmd_args
argument_list|(
name|MARK_UNSET
argument_list|,
name|MARK_UNSET
argument_list|,
name|CMD_ARGS
argument_list|,
name|TRUE
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* empty args list */
name|args
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nargs
operator|=
literal|1
expr_stmt|;
name|argno
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* perform the .exrc files and EXINIT environment variable */
ifdef|#
directive|ifdef
name|SYSEXRC
name|doexrc
argument_list|(
name|SYSEXRC
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HMEXRC
name|str
operator|=
name|gethome
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|&&
operator|*
name|str
condition|)
block|{
name|strcpy
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|tmpblk
operator|.
name|c
operator|+
name|strlen
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|VMS
if|#
directive|if
name|AMIGA
comment|/* Don't SLASH a device. "Elvis:.exrc" */
if|if
condition|(
name|str
index|[
operator|-
literal|1
index|]
operator|!=
name|COLON
operator|&&
name|str
index|[
operator|-
literal|1
index|]
operator|!=
name|SLASH
condition|)
else|#
directive|else
if|if
condition|(
name|str
index|[
operator|-
literal|1
index|]
operator|!=
name|SLASH
condition|)
endif|#
directive|endif
block|{
operator|*
name|str
operator|++
operator|=
name|SLASH
expr_stmt|;
block|}
endif|#
directive|endif
name|strcpy
argument_list|(
name|str
argument_list|,
name|HMEXRC
argument_list|)
expr_stmt|;
name|doexrc
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CRUNCH
if|if
condition|(
operator|*
name|o_exrc
condition|)
endif|#
directive|endif
block|{
name|doexrc
argument_list|(
name|EXRC
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EXINIT
name|str
operator|=
name|getenv
argument_list|(
name|EXINIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
condition|)
block|{
name|exstring
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
name|ctrl
argument_list|(
literal|'V'
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* search for a tag (or an error) now, if desired */
name|blkinit
argument_list|()
expr_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
name|cmd_tag
argument_list|(
name|MARK_UNSET
argument_list|,
name|MARK_FIRST
argument_list|,
name|CMD_TAG
argument_list|,
literal|0
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_ERRLIST
elseif|else
if|if
condition|(
name|err
condition|)
block|{
name|cmd_errlist
argument_list|(
name|MARK_FIRST
argument_list|,
name|MARK_FIRST
argument_list|,
name|CMD_ERRLIST
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* if no tag/err, or tag failed, then start with first arg */
if|if
condition|(
name|tmpfd
operator|<
literal|0
condition|)
block|{
comment|/* start with first arg */
name|cmd_next
argument_list|(
name|MARK_UNSET
argument_list|,
name|MARK_UNSET
argument_list|,
name|CMD_NEXT
argument_list|,
name|FALSE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* pretend to do something, just to force a recoverable 		 * version of the file out to disk 		 */
name|ChangeText
block|{ 		}
name|clrflag
argument_list|(
name|file
argument_list|,
name|MODIFIED
argument_list|)
expr_stmt|;
block|}
comment|/* now we do the immediate ex command that we noticed before */
if|if
condition|(
name|cmd
condition|)
block|{
name|doexcmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|/* repeatedly call ex() or vi() (depending on the mode) until the 	 * mode is set to MODE_QUIT 	 */
while|while
condition|(
name|mode
operator|!=
name|MODE_QUIT
condition|)
block|{
if|if
condition|(
name|setjmp
argument_list|(
name|jmpenv
argument_list|)
condition|)
block|{
comment|/* Maybe we just aborted a change? */
name|abortdo
argument_list|()
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|trapint
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_VI
case|:
name|vi
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_EX
case|:
name|ex
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
default|default:
name|msg
argument_list|(
literal|"mode = %d?"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MODE_QUIT
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* free up the cut buffers */
name|cutend
argument_list|()
expr_stmt|;
comment|/* end curses */
ifndef|#
directive|ifndef
name|NO_CURSORSHAPE
if|if
condition|(
name|has_CQ
condition|)
name|do_CQ
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|endmsgs
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|exitcode
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|SIGTYPE
name|trapint
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|beep
argument_list|()
expr_stmt|;
name|resume_curses
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|abortdo
argument_list|()
expr_stmt|;
if|#
directive|if
name|OSK
name|sigmask
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|signo
argument_list|,
name|trapint
argument_list|)
expr_stmt|;
name|doingglobal
operator|=
name|FALSE
expr_stmt|;
name|longjmp
argument_list|(
name|jmpenv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DIGRAPH
end_ifndef

begin_comment
comment|/* This stuff us used to build the default digraphs table. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|digtable
index|[]
index|[
literal|4
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|CS_IBMPC
literal|"C,\200"
block|,
literal|"u\"\1"
block|,
literal|"e'\2"
block|,
literal|"a^\3"
block|,
literal|"a\"\4"
block|,
literal|"a`\5"
block|,
literal|"a@\6"
block|,
literal|"c,\7"
block|,
literal|"e^\10"
block|,
literal|"e\"\211"
block|,
literal|"e`\12"
block|,
literal|"i\"\13"
block|,
literal|"i^\14"
block|,
literal|"i`\15"
block|,
literal|"A\"\16"
block|,
literal|"A@\17"
block|,
literal|"E'\20"
block|,
literal|"ae\21"
block|,
literal|"AE\22"
block|,
literal|"o^\23"
block|,
literal|"o\"\24"
block|,
literal|"o`\25"
block|,
literal|"u^\26"
block|,
literal|"u`\27"
block|,
literal|"y\"\30"
block|,
literal|"O\"\31"
block|,
literal|"U\"\32"
block|,
literal|"a'\240"
block|,
literal|"i'!"
block|,
literal|"o'\""
block|,
literal|"u'#"
block|,
literal|"n~$"
block|,
literal|"N~%"
block|,
literal|"a-&"
block|,
literal|"o-'"
block|,
literal|"~?("
block|,
literal|"~!-"
block|,
literal|"\"<."
block|,
literal|"\">/"
block|,
ifdef|#
directive|ifdef
name|CS_SPECIAL
literal|"2/+"
block|,
literal|"4/,"
block|,
literal|"^+;"
block|,
literal|"^q<"
block|,
literal|"^c="
block|,
literal|"^r>"
block|,
literal|"^t?"
block|,
literal|"pp]"
block|,
literal|"^^^"
block|,
literal|"oo_"
block|,
literal|"*a`"
block|,
literal|"*ba"
block|,
literal|"*pc"
block|,
literal|"*Sd"
block|,
literal|"*se"
block|,
literal|"*uf"
block|,
literal|"*tg"
block|,
literal|"*Ph"
block|,
literal|"*Ti"
block|,
literal|"*Oj"
block|,
literal|"*dk"
block|,
literal|"*Hl"
block|,
literal|"*hm"
block|,
literal|"*En"
block|,
literal|"*No"
block|,
literal|"eqp"
block|,
literal|"pmq"
block|,
literal|"ger"
block|,
literal|"les"
block|,
literal|"*It"
block|,
literal|"*iu"
block|,
literal|"*/v"
block|,
literal|"*=w"
block|,
literal|"sq{"
block|,
literal|"^n|"
block|,
literal|"^2}"
block|,
literal|"^3~"
block|,
literal|"^_\377"
block|,
endif|#
directive|endif
comment|/* CS_SPECIAL */
endif|#
directive|endif
comment|/* CS_IBMPC */
ifdef|#
directive|ifdef
name|CS_LATIN1
literal|"~!!"
block|,
literal|"a-*"
block|,
literal|"\">+"
block|,
literal|"o-:"
block|,
literal|"\"<>"
block|,
literal|"~??"
block|,
literal|"A`@"
block|,
literal|"A'A"
block|,
literal|"A^B"
block|,
literal|"A~C"
block|,
literal|"A\"D"
block|,
literal|"A@E"
block|,
literal|"AEF"
block|,
literal|"C,G"
block|,
literal|"E`H"
block|,
literal|"E'I"
block|,
literal|"E^J"
block|,
literal|"E\"K"
block|,
literal|"I`L"
block|,
literal|"I'M"
block|,
literal|"I^N"
block|,
literal|"I\"O"
block|,
literal|"-DP"
block|,
literal|"N~Q"
block|,
literal|"O`R"
block|,
literal|"O'S"
block|,
literal|"O^T"
block|,
literal|"O~U"
block|,
literal|"O\"V"
block|,
literal|"O/X"
block|,
literal|"U`Y"
block|,
literal|"U'Z"
block|,
literal|"U^["
block|,
literal|"U\"\\"
block|,
literal|"Y'_"
block|,
literal|"a``"
block|,
literal|"a'a"
block|,
literal|"a^b"
block|,
literal|"a~c"
block|,
literal|"a\"d"
block|,
literal|"a@e"
block|,
literal|"aef"
block|,
literal|"c,g"
block|,
literal|"e`h"
block|,
literal|"e'i"
block|,
literal|"e^j"
block|,
literal|"e\"k"
block|,
literal|"i`l"
block|,
literal|"i'm"
block|,
literal|"i^n"
block|,
literal|"i\"o"
block|,
literal|"-dp"
block|,
literal|"n~q"
block|,
literal|"o`r"
block|,
literal|"o's"
block|,
literal|"o^t"
block|,
literal|"o~u"
block|,
literal|"o\"v"
block|,
literal|"o/x"
block|,
literal|"u`y"
block|,
literal|"u'z"
block|,
literal|"u^{"
block|,
literal|"u\"|"
block|,
literal|"y'~"
block|,
endif|#
directive|endif
comment|/* CS_LATIN1 */
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|init_digraphs
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|digtable
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|do_digraph
argument_list|(
name|FALSE
argument_list|,
name|digtable
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|do_digraph
argument_list|(
name|FALSE
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_DIGRAPH */
end_comment

end_unit

