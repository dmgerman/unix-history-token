begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cmd2.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains some of the commands - mostly ones that change text */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|REGEX
end_ifdef

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"regexp.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TOS
end_if

begin_include
include|#
directive|include
file|<stat.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|OSK
end_if

begin_include
include|#
directive|include
file|"osk.h"
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|AMIGA
end_if

begin_include
include|#
directive|include
file|"amistat.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|REGEX
end_ifdef

begin_decl_stmt
name|int
name|patlock
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lock substitute pattern */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_substitute
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
comment|/* rest of the command line */
block|{
name|char
modifier|*
name|line
decl_stmt|;
comment|/* a line from the file */
ifdef|#
directive|ifdef
name|REGEX
specifier|static
name|regex_t
modifier|*
name|ore
init|=
name|NULL
decl_stmt|;
comment|/* old regex */
name|regex_t
modifier|*
name|optpat
parameter_list|()
function_decl|;
name|regex_t
modifier|*
name|re
init|=
name|NULL
decl_stmt|;
name|regmatch_t
name|rm
index|[
name|SE_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|int
name|n
decl_stmt|;
else|#
directive|else
name|regexp
modifier|*
name|re
decl_stmt|;
comment|/* the compiled search expression */
endif|#
directive|endif
name|char
modifier|*
name|eol
decl_stmt|;
name|char
modifier|*
name|subst
decl_stmt|;
comment|/* the substitution string */
specifier|static
name|char
modifier|*
name|osubst
decl_stmt|;
name|char
modifier|*
name|opt
decl_stmt|;
comment|/* substitution options */
name|long
name|l
decl_stmt|;
comment|/* a line number */
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
comment|/* used during subtitutions */
name|char
modifier|*
name|conf
decl_stmt|;
comment|/* used during confirmation */
name|long
name|chline
decl_stmt|;
comment|/* # of lines changed */
name|long
name|chsub
decl_stmt|;
comment|/* # of substitutions made */
specifier|static
name|optp
expr_stmt|;
comment|/* boolean option: print when done? */
specifier|static
name|optg
expr_stmt|;
comment|/* boolean option: substitute globally in line? */
specifier|static
name|optc
expr_stmt|;
comment|/* boolean option: confirm before subst? */
ifndef|#
directive|ifndef
name|CRUNCH
name|long
name|oldnlines
decl_stmt|;
endif|#
directive|endif
comment|/* for now, assume this will fail */
name|rptlines
operator|=
operator|-
literal|1L
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|CMD_SUBAGAIN
operator|||
operator|!
operator|*
name|extra
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_MAGIC
if|if
condition|(
operator|*
name|o_magic
condition|)
name|subst
operator|=
literal|"~"
expr_stmt|;
else|else
endif|#
directive|endif
name|subst
operator|=
literal|"\\~"
expr_stmt|;
ifdef|#
directive|ifdef
name|REGEX
comment|/* get the previous substitute pattern; not necessarily 		 * the previous pattern. 		 */
if|if
condition|(
operator|(
name|re
operator|=
name|ore
operator|)
operator|==
name|NULL
condition|)
name|msg
argument_list|(
literal|"RE error: no previous pattern"
argument_list|)
expr_stmt|;
else|#
directive|else
name|re
operator|=
name|regcomp
argument_list|(
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* if visual "&", then turn off the "p" and "c" options */
if|if
condition|(
name|bang
condition|)
block|{
name|optp
operator|=
name|optc
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
comment|/* CMD_SUBSTITUTE */
block|{
comment|/* make sure we got a search pattern */
if|if
condition|(
operator|*
name|extra
operator|==
literal|' '
operator|||
operator|*
name|extra
operator|==
literal|'\n'
condition|)
block|{
name|msg
argument_list|(
literal|"Usage: s/regular expression/new text/"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* parse& compile the search pattern */
name|subst
operator|=
name|parseptrn
argument_list|(
name|extra
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REGEX
if|if
condition|(
name|re
operator|=
name|optpat
argument_list|(
name|extra
operator|+
literal|1
argument_list|)
condition|)
name|patlock
operator|=
literal|1
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|re
operator|!=
name|ore
operator|&&
name|ore
condition|)
block|{
name|regfree
argument_list|(
name|ore
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ore
argument_list|)
expr_stmt|;
block|}
name|ore
operator|=
name|re
expr_stmt|;
else|#
directive|else
name|re
operator|=
name|regcomp
argument_list|(
name|extra
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* abort if RE error -- error message already given by regcomp() */
if|if
condition|(
operator|!
name|re
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|cmd
operator|==
name|CMD_SUBSTITUTE
condition|)
block|{
comment|/* parse the substitution string& find the option string */
for|for
control|(
name|opt
operator|=
name|subst
init|;
operator|*
name|opt
operator|&&
operator|*
name|opt
operator|!=
operator|*
name|extra
condition|;
name|opt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|opt
operator|==
literal|'\\'
operator|&&
name|opt
index|[
literal|1
index|]
condition|)
block|{
name|opt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|opt
condition|)
block|{
operator|*
name|opt
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* analyse the option string */
if|if
condition|(
operator|!
operator|*
name|o_edcompatible
condition|)
block|{
name|optp
operator|=
name|optg
operator|=
name|optc
operator|=
name|FALSE
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|opt
condition|)
block|{
switch|switch
condition|(
operator|*
name|opt
operator|++
condition|)
block|{
case|case
literal|'p'
case|:
name|optp
operator|=
operator|!
name|optp
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|optg
operator|=
operator|!
name|optg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|optc
operator|=
operator|!
name|optc
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
break|break;
default|default:
name|msg
argument_list|(
literal|"Subst options are p, c, and g -- not %c"
argument_list|,
name|opt
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* if "c" or "p" flag was given, and we're in visual mode, then NEWLINE */
if|if
condition|(
operator|(
name|optc
operator|||
name|optp
operator|)
operator|&&
name|mode
operator|==
name|MODE_VI
condition|)
block|{
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
block|}
name|ChangeText
block|{
comment|/* reset the change counters */
name|chline
operator|=
name|chsub
operator|=
literal|0L
expr_stmt|;
comment|/* for each selected line */
for|for
control|(
name|l
operator|=
name|markline
argument_list|(
name|frommark
argument_list|)
init|;
name|l
operator|<=
name|markline
argument_list|(
name|tomark
argument_list|)
condition|;
name|l
operator|++
control|)
block|{
comment|/* fetch the line */
name|line
operator|=
name|fetchline
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|eol
operator|=
name|line
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* if it contains the search pattern... */
ifdef|#
directive|ifdef
name|REGEX
if|if
condition|(
operator|!
name|regexec
argument_list|(
name|re
argument_list|,
name|line
argument_list|,
name|SE_MAX
argument_list|,
name|rm
argument_list|,
literal|0
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|regexec
argument_list|(
name|re
argument_list|,
name|line
argument_list|,
name|TRUE
argument_list|)
condition|)
endif|#
directive|endif
block|{
comment|/* increment the line change counter */
name|chline
operator|++
expr_stmt|;
comment|/* initialize the pointers */
name|s
operator|=
name|line
expr_stmt|;
name|d
operator|=
name|tmpblk
operator|.
name|c
expr_stmt|;
comment|/* do once or globally ... */
do|do
block|{
ifdef|#
directive|ifdef
name|REGEX
name|startp
operator|=
name|s
operator|+
name|rm
index|[
literal|0
index|]
operator|.
name|rm_so
expr_stmt|;
name|endp
operator|=
name|s
operator|+
name|rm
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CRUNCH
comment|/* confirm, if necessary */
if|if
condition|(
name|optc
condition|)
block|{
ifdef|#
directive|ifdef
name|REGEX
for|for
control|(
name|conf
operator|=
name|line
init|;
name|conf
operator|<
name|startp
condition|;
name|conf
operator|++
control|)
else|#
directive|else
for|for
control|(
name|conf
operator|=
name|line
init|;
name|conf
operator|<
name|re
operator|->
name|startp
index|[
literal|0
index|]
condition|;
name|conf
operator|++
control|)
endif|#
directive|endif
name|addch
argument_list|(
operator|*
name|conf
argument_list|)
expr_stmt|;
name|standout
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|REGEX
for|for
control|(
init|;
name|conf
operator|<
name|endp
condition|;
name|conf
operator|++
control|)
else|#
directive|else
for|for
control|(
init|;
name|conf
operator|<
name|re
operator|->
name|endp
index|[
literal|0
index|]
condition|;
name|conf
operator|++
control|)
endif|#
directive|endif
name|addch
argument_list|(
operator|*
name|conf
argument_list|)
expr_stmt|;
name|standend
argument_list|()
expr_stmt|;
for|for
control|(
init|;
operator|*
name|conf
condition|;
name|conf
operator|++
control|)
name|addch
argument_list|(
operator|*
name|conf
argument_list|)
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|getkey
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'y'
condition|)
block|{
comment|/* copy accross the original chars */
ifdef|#
directive|ifdef
name|REGEX
while|while
condition|(
name|s
operator|<
name|endp
condition|)
else|#
directive|else
while|while
condition|(
name|s
operator|<
name|re
operator|->
name|endp
index|[
literal|0
index|]
condition|)
endif|#
directive|endif
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* skip to next match on this line, if any */
goto|goto
name|Continue
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* not CRUNCH */
comment|/* increment the substitution change counter */
name|chsub
operator|++
expr_stmt|;
comment|/* copy stuff from before the match */
ifdef|#
directive|ifdef
name|REGEX
while|while
condition|(
name|s
operator|<
name|startp
condition|)
else|#
directive|else
while|while
condition|(
name|s
operator|<
name|re
operator|->
name|startp
index|[
literal|0
index|]
condition|)
endif|#
directive|endif
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
comment|/* substitute for the matched part */
ifdef|#
directive|ifdef
name|REGEX
if|if
condition|(
name|regsub
argument_list|(
name|rm
argument_list|,
name|startp
argument_list|,
name|endp
argument_list|,
name|subst
argument_list|,
name|d
argument_list|)
operator|<
literal|0
condition|)
return|return;
else|#
directive|else
if|if
condition|(
name|regsub
argument_list|(
name|re
argument_list|,
name|subst
argument_list|,
name|d
argument_list|)
operator|<
literal|0
condition|)
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REGEX
name|s
operator|=
name|endp
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|re
operator|->
name|endp
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
name|d
operator|+=
name|strlen
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|Continue
label|:
empty_stmt|;
ifndef|#
directive|ifndef
name|REGEX
comment|/* if this regexp could conceivably match 					 * a zero-length string, then require at 					 * least 1 unmatched character between 					 * matches. 					 */
if|if
condition|(
name|re
operator|->
name|minlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|s
condition|)
break|break;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|REGEX
do|while
condition|(
operator|*
name|s
operator|&&
name|optg
operator|&&
name|rm
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|&&
operator|!
name|regexec
argument_list|(
name|re
argument_list|,
name|s
argument_list|,
name|SE_MAX
argument_list|,
name|rm
argument_list|,
name|REG_NOTBOL
argument_list|)
condition|)
do|;
if|if
condition|(
name|eol
operator|-
name|s
operator|>
literal|0
operator|&&
operator|!
name|rm
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|&&
name|optg
condition|)
block|{
name|msg
argument_list|(
literal|"RE error: line too long"
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
while|while
condition|(
name|optg
operator|&&
name|regexec
argument_list|(
name|re
argument_list|,
name|s
argument_list|,
name|FALSE
argument_list|)
condition|)
empty_stmt|;
endif|#
directive|endif
comment|/* copy stuff from after the match */
while|while
condition|(
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
comment|/* yes, ASSIGNMENT! */
block|{ 				}
ifndef|#
directive|ifndef
name|CRUNCH
comment|/* NOTE: since the substitution text is allowed to have ^Ms which are 				 * translated into newlines, it is possible that the number of lines 				 * in the file will increase after each line has been substituted. 				 * we need to adjust for this. 				 */
name|oldnlines
operator|=
name|nlines
expr_stmt|;
endif|#
directive|endif
comment|/* replace the old version of the line with the new */
name|d
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|d
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|change
argument_list|(
name|MARK_AT_LINE
argument_list|(
name|l
argument_list|)
argument_list|,
name|MARK_AT_LINE
argument_list|(
name|l
operator|+
literal|1
argument_list|)
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CRUNCH
name|l
operator|+=
name|nlines
operator|-
name|oldnlines
expr_stmt|;
name|tomark
operator|+=
name|MARK_AT_LINE
argument_list|(
name|nlines
operator|-
name|oldnlines
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* if supposed to print it, do so */
if|if
condition|(
name|optp
condition|)
block|{
name|addstr
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
block|}
comment|/* move the cursor to that line */
name|cursor
operator|=
name|MARK_AT_LINE
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* free the regexp */
ifndef|#
directive|ifndef
name|REGEX
name|_free_
argument_list|(
name|re
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* if done from within a ":g" command, then finish silently */
if|if
condition|(
name|doingglobal
condition|)
block|{
name|rptlines
operator|=
name|chline
expr_stmt|;
name|rptlabel
operator|=
literal|"changed"
expr_stmt|;
return|return;
block|}
comment|/* Reporting */
if|if
condition|(
name|chsub
operator|==
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Substitution failed"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chline
operator|>=
operator|*
name|o_report
condition|)
block|{
name|msg
argument_list|(
literal|"%ld substitutions on %ld lines"
argument_list|,
name|chsub
argument_list|,
name|chline
argument_list|)
expr_stmt|;
block|}
name|rptlines
operator|=
literal|0L
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_delete
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|MARK
name|curs2
decl_stmt|;
comment|/* an altered form of the cursor */
comment|/* choose your cut buffer */
if|if
condition|(
operator|*
name|extra
operator|==
literal|'"'
condition|)
block|{
name|extra
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|extra
condition|)
block|{
name|cutname
argument_list|(
operator|*
name|extra
argument_list|)
expr_stmt|;
block|}
comment|/* make sure we're talking about whole lines here */
name|frommark
operator|=
name|frommark
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|tomark
operator|=
operator|(
name|tomark
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|BLKSIZE
expr_stmt|;
comment|/* yank the lines */
name|cut
argument_list|(
name|frommark
argument_list|,
name|tomark
argument_list|)
expr_stmt|;
comment|/* if CMD_DELETE then delete the lines */
if|if
condition|(
name|cmd
operator|!=
name|CMD_YANK
condition|)
block|{
name|curs2
operator|=
name|cursor
expr_stmt|;
name|ChangeText
block|{
comment|/* delete the lines */
name|delete
argument_list|(
name|frommark
argument_list|,
name|tomark
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curs2
operator|>
name|tomark
condition|)
block|{
name|cursor
operator|=
name|curs2
operator|-
name|tomark
operator|+
name|frommark
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curs2
operator|>
name|frommark
condition|)
block|{
name|cursor
operator|=
name|frommark
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_append
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|long
name|l
decl_stmt|;
comment|/* line counter */
ifndef|#
directive|ifndef
name|CRUNCH
comment|/* if '!' then toggle auto-indent */
if|if
condition|(
name|bang
condition|)
block|{
operator|*
name|o_autoindent
operator|=
operator|!
operator|*
name|o_autoindent
expr_stmt|;
block|}
endif|#
directive|endif
name|ChangeText
block|{
comment|/* if we're doing a change, delete the old version */
if|if
condition|(
name|cmd
operator|==
name|CMD_CHANGE
condition|)
block|{
comment|/* delete 'em */
name|cmd_delete
argument_list|(
name|frommark
argument_list|,
name|tomark
argument_list|,
name|cmd
argument_list|,
name|bang
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
comment|/* new lines start at the frommark line, or after it */
name|l
operator|=
name|markline
argument_list|(
name|frommark
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|CMD_APPEND
condition|)
block|{
name|l
operator|++
expr_stmt|;
block|}
comment|/* get lines until no more lines, or "." line, and insert them */
while|while
condition|(
name|vgets
argument_list|(
literal|'\0'
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|,
name|BLKSIZE
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
literal|"."
argument_list|)
condition|)
block|{
break|break;
block|}
name|strcat
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|MARK_AT_LINE
argument_list|(
name|l
argument_list|)
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
block|}
comment|/* on the odd chance that we're calling this from vi mode ... */
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_put
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
comment|/* choose your cut buffer */
if|if
condition|(
operator|*
name|extra
operator|==
literal|'"'
condition|)
block|{
name|extra
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|extra
condition|)
block|{
name|cutname
argument_list|(
operator|*
name|extra
argument_list|)
expr_stmt|;
block|}
comment|/* paste it */
name|ChangeText
block|{
name|cursor
operator|=
name|paste
argument_list|(
name|frommark
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_join
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|long
name|l
decl_stmt|;
name|char
modifier|*
name|scan
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* length of the new line */
comment|/* if only one line is specified, assume the following one joins too */
if|if
condition|(
name|markline
argument_list|(
name|frommark
argument_list|)
operator|==
name|nlines
condition|)
block|{
name|msg
argument_list|(
literal|"Nothing to join with this line"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|markline
argument_list|(
name|frommark
argument_list|)
operator|==
name|markline
argument_list|(
name|tomark
argument_list|)
condition|)
block|{
name|tomark
operator|+=
name|BLKSIZE
expr_stmt|;
block|}
comment|/* get the first line */
name|l
operator|=
name|markline
argument_list|(
name|frommark
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
name|fetchline
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
comment|/* build the longer line */
while|while
condition|(
operator|++
name|l
operator|<=
name|markline
argument_list|(
name|tomark
argument_list|)
condition|)
block|{
comment|/* get the next line */
name|scan
operator|=
name|fetchline
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* remove any leading whitespace */
while|while
condition|(
operator|*
name|scan
operator|==
literal|'\t'
operator|||
operator|*
name|scan
operator|==
literal|' '
condition|)
block|{
name|scan
operator|++
expr_stmt|;
block|}
comment|/* see if the line will fit */
if|if
condition|(
name|strlen
argument_list|(
name|scan
argument_list|)
operator|+
name|len
operator|+
literal|3
operator|>
operator|(
name|unsigned
operator|)
name|BLKSIZE
condition|)
block|{
name|msg
argument_list|(
literal|"Can't join -- the resulting line would be too long"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* catenate it, with a space (or two) in between */
if|if
condition|(
operator|!
name|bang
condition|)
block|{
if|if
condition|(
name|len
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|tmpblk
operator|.
name|c
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|||
name|tmpblk
operator|.
name|c
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'?'
operator|||
name|tmpblk
operator|.
name|c
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'!'
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|len
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|tmpblk
operator|.
name|c
index|[
name|len
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmpblk
operator|.
name|c
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|len
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
block|}
name|strcpy
argument_list|(
name|tmpblk
operator|.
name|c
operator|+
name|len
argument_list|,
name|scan
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
name|tmpblk
operator|.
name|c
index|[
name|len
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|tmpblk
operator|.
name|c
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* make the change */
name|ChangeText
block|{
name|frommark
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|tomark
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|tomark
operator|+=
name|BLKSIZE
expr_stmt|;
name|change
argument_list|(
name|frommark
argument_list|,
name|tomark
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Reporting... */
name|rptlines
operator|=
name|markline
argument_list|(
name|tomark
argument_list|)
operator|-
name|markline
argument_list|(
name|frommark
argument_list|)
operator|-
literal|1L
expr_stmt|;
name|rptlabel
operator|=
literal|"joined"
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_shift
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|long
name|l
decl_stmt|;
comment|/* line number counter */
name|int
name|oldidx
decl_stmt|;
comment|/* number of chars previously used for indent */
name|int
name|newidx
decl_stmt|;
comment|/* number of chars in the new indent string */
name|int
name|oldcol
decl_stmt|;
comment|/* previous indent amount */
name|int
name|newcol
decl_stmt|;
comment|/* new indent amount */
name|char
modifier|*
name|text
decl_stmt|;
comment|/* pointer to the old line's text */
name|ChangeText
block|{
comment|/* for each line to shift... */
for|for
control|(
name|l
operator|=
name|markline
argument_list|(
name|frommark
argument_list|)
init|;
name|l
operator|<=
name|markline
argument_list|(
name|tomark
argument_list|)
condition|;
name|l
operator|++
control|)
block|{
comment|/* get the line - ignore empty lines unless ! mode */
name|text
operator|=
name|fetchline
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|text
operator|&&
operator|!
name|bang
condition|)
continue|continue;
comment|/* calc oldidx and oldcol */
for|for
control|(
name|oldidx
operator|=
literal|0
operator|,
name|oldcol
operator|=
literal|0
init|;
name|text
index|[
name|oldidx
index|]
operator|==
literal|' '
operator|||
name|text
index|[
name|oldidx
index|]
operator|==
literal|'\t'
condition|;
name|oldidx
operator|++
control|)
block|{
if|if
condition|(
name|text
index|[
name|oldidx
index|]
operator|==
literal|' '
condition|)
block|{
name|oldcol
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|oldcol
operator|+=
operator|*
name|o_tabstop
operator|-
operator|(
name|oldcol
operator|%
operator|*
name|o_tabstop
operator|)
expr_stmt|;
block|}
block|}
comment|/* calc newcol */
if|if
condition|(
name|cmd
operator|==
name|CMD_SHIFTR
condition|)
block|{
name|newcol
operator|=
name|oldcol
operator|+
operator|(
operator|*
name|o_shiftwidth
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
else|else
block|{
name|newcol
operator|=
name|oldcol
operator|-
operator|(
operator|*
name|o_shiftwidth
operator|&
literal|0xff
operator|)
expr_stmt|;
if|if
condition|(
name|newcol
operator|<
literal|0
condition|)
name|newcol
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if no change, then skip to next line */
if|if
condition|(
name|oldcol
operator|==
name|newcol
condition|)
continue|continue;
comment|/* build a new indent string */
name|newidx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|o_autotab
condition|)
block|{
while|while
condition|(
name|newcol
operator|>=
operator|*
name|o_tabstop
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|newidx
operator|++
index|]
operator|=
literal|'\t'
expr_stmt|;
name|newcol
operator|-=
operator|*
name|o_tabstop
expr_stmt|;
block|}
block|}
while|while
condition|(
name|newcol
operator|>
literal|0
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|newidx
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|newcol
operator|--
expr_stmt|;
block|}
name|tmpblk
operator|.
name|c
index|[
name|newidx
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* change the old indent string into the new */
name|change
argument_list|(
name|MARK_AT_LINE
argument_list|(
name|l
argument_list|)
argument_list|,
name|MARK_AT_LINE
argument_list|(
name|l
argument_list|)
operator|+
name|oldidx
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reporting... */
name|rptlines
operator|=
name|markline
argument_list|(
name|tomark
argument_list|)
operator|-
name|markline
argument_list|(
name|frommark
argument_list|)
operator|+
literal|1L
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|CMD_SHIFTR
condition|)
block|{
name|rptlabel
operator|=
literal|">ed"
expr_stmt|;
block|}
else|else
block|{
name|rptlabel
operator|=
literal|"<ed"
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_read
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|rc
decl_stmt|;
comment|/* used while reading from the file */
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* used for finding NUL characters */
name|int
name|hadnul
decl_stmt|;
comment|/* boolean: any NULs found? */
name|int
name|addnl
decl_stmt|;
comment|/* boolean: forced to add newlines? */
name|int
name|len
decl_stmt|;
comment|/* number of chars in current line */
name|long
name|lines
decl_stmt|;
comment|/* number of lines in current block */
name|struct
name|stat
name|statb
decl_stmt|;
comment|/* special case: if ":r !cmd" then let the filter() function do it */
if|if
condition|(
name|extra
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
block|{
name|filter
argument_list|(
name|frommark
argument_list|,
name|MARK_UNSET
argument_list|,
name|extra
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* open the file */
name|fd
operator|=
name|open
argument_list|(
name|extra
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Can't open \"%s\""
argument_list|,
name|extra
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
if|if
condition|(
name|stat
argument_list|(
name|extra
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Can't stat \"%s\""
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|TOS
if|if
condition|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IJDIR
condition|)
else|#
directive|else
if|#
directive|if
name|OSK
if|if
condition|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFDIR
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
endif|#
directive|endif
endif|#
directive|endif
block|{
name|msg
argument_list|(
literal|"\"%s\" is not a regular file"
argument_list|,
name|extra
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* not CRUNCH */
comment|/* get blocks from the file, and add them */
name|ChangeText
block|{
comment|/* insertion starts at the line following frommark */
name|tomark
operator|=
name|frommark
operator|=
operator|(
name|frommark
operator||
operator|(
name|BLKSIZE
operator|-
literal|1L
operator|)
operator|)
operator|+
literal|1L
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|hadnul
operator|=
name|addnl
operator|=
name|FALSE
expr_stmt|;
comment|/* add an extra newline, so partial lines at the end of 		 * the file don't trip us up 		 */
name|add
argument_list|(
name|tomark
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* for each chunk of text... */
while|while
condition|(
operator|(
name|rc
operator|=
name|tread
argument_list|(
name|fd
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|,
name|BLKSIZE
operator|-
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* count newlines, convert NULs, etc. ... */
for|for
control|(
name|lines
operator|=
literal|0
operator|,
name|scan
operator|=
name|tmpblk
operator|.
name|c
init|;
name|rc
operator|>
literal|0
condition|;
name|rc
operator|--
operator|,
name|scan
operator|++
control|)
block|{
comment|/* break up long lines */
if|if
condition|(
operator|*
name|scan
operator|!=
literal|'\n'
operator|&&
name|len
operator|+
literal|2
operator|>
name|BLKSIZE
condition|)
block|{
operator|*
name|scan
operator|=
literal|'\n'
expr_stmt|;
name|addnl
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* protect against NUL chars in file */
if|if
condition|(
operator|!
operator|*
name|scan
condition|)
block|{
operator|*
name|scan
operator|=
literal|0x80
expr_stmt|;
name|hadnul
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* starting a new line? */
if|if
condition|(
operator|*
name|scan
operator|==
literal|'\n'
condition|)
block|{
comment|/* reset length at newline */
name|len
operator|=
literal|0
expr_stmt|;
name|lines
operator|++
expr_stmt|;
block|}
else|else
block|{
name|len
operator|++
expr_stmt|;
block|}
block|}
comment|/* add the text */
operator|*
name|scan
operator|=
literal|'\0'
expr_stmt|;
name|add
argument_list|(
name|tomark
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
name|tomark
operator|+=
name|MARK_AT_LINE
argument_list|(
name|lines
argument_list|)
operator|+
name|len
operator|-
name|markidx
argument_list|(
name|tomark
argument_list|)
expr_stmt|;
block|}
comment|/* if partial last line, then retain that first newline */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Last line had no newline"
argument_list|)
expr_stmt|;
name|tomark
operator|+=
name|BLKSIZE
expr_stmt|;
comment|/*<- for the rptlines calc */
block|}
else|else
comment|/* delete that first newline */
block|{
name|delete
argument_list|(
name|tomark
argument_list|,
operator|(
name|tomark
operator||
operator|(
name|BLKSIZE
operator|-
literal|1L
operator|)
operator|)
operator|+
literal|1L
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* close the file */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Reporting... */
name|rptlines
operator|=
name|markline
argument_list|(
name|tomark
argument_list|)
operator|-
name|markline
argument_list|(
name|frommark
argument_list|)
expr_stmt|;
name|rptlabel
operator|=
literal|"read"
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|MODE_EX
condition|)
block|{
name|cursor
operator|=
operator|(
name|tomark
operator|&
operator|~
name|BLKSIZE
operator|)
operator|-
name|BLKSIZE
expr_stmt|;
block|}
else|else
block|{
name|cursor
operator|=
name|frommark
expr_stmt|;
block|}
if|if
condition|(
name|addnl
condition|)
name|msg
argument_list|(
literal|"Newlines were added to break up long lines"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hadnul
condition|)
name|msg
argument_list|(
literal|"NULs were converted to 0x80"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_undo
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|undo
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print the selected lines */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_print
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|REG
name|char
modifier|*
name|scan
decl_stmt|;
name|REG
name|long
name|l
decl_stmt|;
name|REG
name|int
name|col
decl_stmt|;
for|for
control|(
name|l
operator|=
name|markline
argument_list|(
name|frommark
argument_list|)
init|;
name|l
operator|<=
name|markline
argument_list|(
name|tomark
argument_list|)
condition|;
name|l
operator|++
control|)
block|{
comment|/* display a line number, if CMD_NUMBER */
if|if
condition|(
name|cmd
operator|==
name|CMD_NUMBER
condition|)
block|{
name|sprintf
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
literal|"%6ld  "
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
name|col
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|col
operator|=
literal|0
expr_stmt|;
block|}
comment|/* get the next line& display it */
for|for
control|(
name|scan
operator|=
name|fetchline
argument_list|(
name|l
argument_list|)
init|;
operator|*
name|scan
condition|;
name|scan
operator|++
control|)
block|{
comment|/* expand tabs to the proper width */
if|if
condition|(
operator|*
name|scan
operator|==
literal|'\t'
operator|&&
name|cmd
operator|!=
name|CMD_LIST
condition|)
block|{
do|do
block|{
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|col
operator|%
operator|*
name|o_tabstop
operator|!=
literal|0
condition|)
do|;
block|}
elseif|else
if|if
condition|(
operator|*
name|scan
operator|>=
literal|1
operator|&&
operator|*
name|scan
operator|<
literal|' '
operator|||
operator|*
name|scan
operator|==
literal|'\177'
condition|)
block|{
name|qaddch
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
operator|*
name|scan
operator|^
literal|0x40
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|scan
operator|&
literal|0x80
operator|)
operator|&&
name|cmd
operator|==
name|CMD_LIST
condition|)
block|{
name|sprintf
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
literal|"\\%03o"
argument_list|,
name|UCHAR
argument_list|(
operator|*
name|scan
argument_list|)
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|qaddch
argument_list|(
operator|*
name|scan
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
comment|/* wrap at the edge of the screen */
if|if
condition|(
operator|!
name|has_AM
operator|&&
name|col
operator|>=
name|COLS
condition|)
block|{
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|col
operator|-=
name|COLS
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cmd
operator|==
name|CMD_LIST
condition|)
block|{
name|qaddch
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
block|}
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
block|}
comment|/* leave the cursor on the last line printed */
name|cursor
operator|=
name|tomark
expr_stmt|;
block|}
end_function

begin_comment
comment|/* move or copy selected lines */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_move
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|MARK
name|destmark
decl_stmt|;
comment|/* parse the destination linespec.  No defaults.  Line 0 is okay */
name|destmark
operator|=
name|cursor
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|extra
argument_list|,
literal|"0"
argument_list|)
condition|)
block|{
name|destmark
operator|=
literal|0L
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|linespec
argument_list|(
name|extra
argument_list|,
operator|&
name|destmark
argument_list|)
operator|==
name|extra
operator|||
operator|!
name|destmark
condition|)
block|{
name|msg
argument_list|(
literal|"invalid destination address"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* flesh the marks out to encompass whole lines */
name|frommark
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|tomark
operator|=
operator|(
name|tomark
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|BLKSIZE
expr_stmt|;
name|destmark
operator|=
operator|(
name|destmark
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|BLKSIZE
expr_stmt|;
comment|/* make sure the destination is valid */
if|if
condition|(
name|cmd
operator|==
name|CMD_MOVE
operator|&&
name|destmark
operator|>=
name|frommark
operator|&&
name|destmark
operator|<
name|tomark
condition|)
block|{
name|msg
argument_list|(
literal|"invalid destination address"
argument_list|)
expr_stmt|;
block|}
comment|/* Do it */
name|ChangeText
block|{
comment|/* save the text to a cut buffer */
name|cutname
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|cut
argument_list|(
name|frommark
argument_list|,
name|tomark
argument_list|)
expr_stmt|;
comment|/* if we're not copying, delete the old text& adjust destmark */
if|if
condition|(
name|cmd
operator|!=
name|CMD_COPY
condition|)
block|{
name|delete
argument_list|(
name|frommark
argument_list|,
name|tomark
argument_list|)
expr_stmt|;
if|if
condition|(
name|destmark
operator|>=
name|frommark
condition|)
block|{
name|destmark
operator|-=
operator|(
name|tomark
operator|-
name|frommark
operator|)
expr_stmt|;
block|}
block|}
comment|/* add the new text */
name|paste
argument_list|(
name|destmark
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* move the cursor to the last line of the moved text */
name|cursor
operator|=
name|destmark
operator|+
operator|(
name|tomark
operator|-
name|frommark
operator|)
operator|-
name|BLKSIZE
expr_stmt|;
if|if
condition|(
name|cursor
operator|<
name|MARK_FIRST
operator|||
name|cursor
operator|>=
name|MARK_LAST
operator|+
name|BLKSIZE
condition|)
block|{
name|cursor
operator|=
name|MARK_LAST
expr_stmt|;
block|}
comment|/* Reporting... */
name|rptlabel
operator|=
operator|(
operator|(
name|cmd
operator|==
name|CMD_COPY
operator|)
condition|?
literal|"copied"
else|:
literal|"moved"
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* execute EX commands from a file */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_source
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
comment|/* must have a filename */
if|if
condition|(
operator|!
operator|*
name|extra
condition|)
block|{
name|msg
argument_list|(
literal|"\"source\" requires a filename"
argument_list|)
expr_stmt|;
return|return;
block|}
name|doexrc
argument_list|(
name|extra
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_AT
end_ifndef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_at
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
specifier|static
name|nest
operator|=
name|FALSE
expr_stmt|;
name|int
name|result
decl_stmt|;
name|char
name|buf
index|[
name|MAXRCLEN
index|]
decl_stmt|;
comment|/* don't allow nested macros */
if|if
condition|(
name|nest
condition|)
block|{
name|msg
argument_list|(
literal|"@ macros can't be nested"
argument_list|)
expr_stmt|;
return|return;
block|}
name|nest
operator|=
name|TRUE
expr_stmt|;
comment|/* require a buffer name */
if|if
condition|(
operator|*
name|extra
operator|==
literal|'"'
condition|)
name|extra
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|extra
operator|||
operator|!
name|isascii
argument_list|(
operator|*
name|extra
argument_list|)
operator|||
operator|!
name|islower
argument_list|(
operator|*
name|extra
argument_list|)
condition|)
block|{
name|msg
argument_list|(
literal|"@ requires a cut buffer name (a-z)"
argument_list|)
expr_stmt|;
block|}
comment|/* get the contents of the buffer */
name|result
operator|=
name|cb2str
argument_list|(
operator|*
name|extra
argument_list|,
name|buf
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<=
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"buffer \"%c is empty"
argument_list|,
operator|*
name|extra
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|>=
sizeof|sizeof
name|buf
condition|)
block|{
name|msg
argument_list|(
literal|"buffer \"%c is too large to execute"
argument_list|,
operator|*
name|extra
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* execute the contents of the buffer as ex commands */
name|exstring
argument_list|(
name|buf
argument_list|,
name|result
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
block|}
name|nest
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

