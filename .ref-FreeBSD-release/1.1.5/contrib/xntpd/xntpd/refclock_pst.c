begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_pst - driver for the PSTI 1010/1020 WWV clock  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|PST
argument_list|)
operator|||
name|defined
argument_list|(
name|PSTCLK
argument_list|)
operator|||
name|defined
argument_list|(
name|PSTPPS
argument_list|)
operator|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_BSD_TTYS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYSV_TTYS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STREAM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PSTCLK
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/clkdefs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PSTCLK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STREAM */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PSTPPS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ppsclock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PSTPPS */
end_comment

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * This driver is in good measure due to David Schachter, who wrote  * the firmware for the PST clock.  Not that he is to blame for  * any of this, but he kindly loaned me a clock to allow me to  * debug this.  *  * Postscript:  *  * The strategy in here is actually pretty good, especially if  * you try to support the clock on something lacking low order  * clock bits like a Sun, since all the business which is done  * before taking a time stamp tends to randomize the taking of  * the stamp with respect to the timer interrupt.  It is, however,  * a big cpu hog, and in some ways is a bit of a waste since, as  * it turns out, the PST clock can give you no better than a  * millisecond precision and it doesn't pay to try to push it  * harder.  *  * In any event, like the first waffle off the iron, this one  * should probably be tossed.  My current preference would be  * to retain the 12-a-minute schedule, but to use the QU command  * instead of the QD and QT, and to only send a QM command with  * the 12th poll of the minute to get the minutes-since-sync  * and the station.  Need to get a clock which supports QU,  * however.  *  * End postscript  *  * This driver polls the clock using the QM, QT and QD commands.  * Ntpd actually uses QU instead of the last two, something I would  * like to have done as well since it gives you the day and time  * atom, but the firmware in the clock I had (X04.01.999) didn't know  * about this command.  *  * The QM command produces output like:  *  *	O6B532352823C00270322  *	   b     c  deeee  *  * We use (b) for the time zone, (c) to see whether time is available,  * (d) to tell whether we are sync'd to WWV or WWVH, and (e) to determine  * the number of minutes since the last signal was received.  We  * don't trust the clock for more than about 20 minutes on its own.  * After this, we keep taking the time but mark the clock unsynchronized.  *  * The QT command returns something that looks like this:  *  *	18:57:50.263D  *  * Note that this particular sample is in 24 hour format, local time  * (daylight savings time even).  We allow just about anything for  * this (sigh) since this leaves the clock owner free to set the  * display mode in whatever way he finds convenient for setting  * his watch.  *  * The QD command returns:  *  *	89/10/19/292  *  * We actually only use the day-of-the-year here.  We use the year  * only to determine whether the PST clock thinks the current year  * has 365 or 366 days in it.  *  * At the current writing, this code expects to be using a BSD-style  * terminal driver.  It will compile code which uses the CLKLDISC  * line discipline if it thinks this is available, but use cooked  * mode otherwise.  The cooked mode stuff may not have been tested.  */
end_comment

begin_comment
comment|/*  * Definitions  */
end_comment

begin_define
define|#
directive|define
name|MAXUNITS
value|4
end_define

begin_comment
comment|/* maximum number of PST units permitted */
end_comment

begin_define
define|#
directive|define
name|PSTDEV
value|"/dev/pst%d"
end_define

begin_comment
comment|/* device we open.  %d is unit number */
end_comment

begin_define
define|#
directive|define
name|NPSTSAMPS
value|12
end_define

begin_comment
comment|/* take 12 PST samples per minute */
end_comment

begin_comment
comment|/*  * Other constant stuff  */
end_comment

begin_define
define|#
directive|define
name|PSTPRECISION
value|(-9)
end_define

begin_comment
comment|/* what the heck */
end_comment

begin_define
define|#
directive|define
name|WWVREFID
value|"WWV\0"
end_define

begin_define
define|#
directive|define
name|WWVHREFID
value|"WWVH"
end_define

begin_define
define|#
directive|define
name|PSTHSREFID
value|0x7f7f030a
end_define

begin_comment
comment|/* 127.127.3.10 refid for hi strata */
end_comment

begin_comment
comment|/*  * Parameters for the clock  */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B9600
end_define

begin_define
define|#
directive|define
name|PSTMAGIC2
value|('\r' | 0x80)
end_define

begin_comment
comment|/* HP-UX uses this also now */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CLKLDISC
end_ifdef

begin_define
define|#
directive|define
name|PSTMAGIC1
value|'\r'
end_define

begin_define
define|#
directive|define
name|PSTEOL
value|'\r'
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PSTEOL
value|'\n'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Description of clock.  We fill in whether it is a 1010 or 1020,  * and the firmware revision, using the QV command.  */
end_comment

begin_define
define|#
directive|define
name|PSTDESCLEN
value|64
end_define

begin_define
define|#
directive|define
name|PSTDESCRIPTION
value|"%s %s (%s) WWV/H Receiver"
end_define

begin_define
define|#
directive|define
name|PSTDEFDESC
value|"PSTI/Traconex 10?0 (V??.??) WWV/H Receiver"
end_define

begin_comment
comment|/*  * Length of the PST time code.  This must be the length of the output  * of the QM command, plus QT, plus QD, plus two spaces.  We make it  * big just on principle.  */
end_comment

begin_define
define|#
directive|define
name|PSTCODELEN
value|(128)
end_define

begin_comment
comment|/*  * Minimum and maximum lengths  */
end_comment

begin_define
define|#
directive|define
name|PSTMINQVLEN
value|(16)
end_define

begin_define
define|#
directive|define
name|PSTMAXQVLEN
value|(24)
end_define

begin_define
define|#
directive|define
name|PSTMINQMLEN
value|(19)
end_define

begin_define
define|#
directive|define
name|PSTMAXQMLEN
value|(32)
end_define

begin_define
define|#
directive|define
name|PSTMINQDLEN
value|(12)
end_define

begin_define
define|#
directive|define
name|PSTMAXQDLEN
value|(12)
end_define

begin_define
define|#
directive|define
name|PSTMINQTLEN
value|(14)
end_define

begin_define
define|#
directive|define
name|PSTMAXQTLEN
value|(14)
end_define

begin_comment
comment|/*  * It turns out that the QT command does *not* adjust for transmission  * delays.  Since the QT command returns 15 characters at 9600 baud,  * the adjustment for this should be 15.6 ms.  We'll default to this,  * but don't let this stop you from fiddling with the fudge factors  * to make things come out right  */
end_comment

begin_define
define|#
directive|define
name|PSTQTFUDGE
value|0x04000000
end_define

begin_comment
comment|/* about 15.6 ms */
end_comment

begin_comment
comment|/*  * Default propagation delays.  About right for Toronto  */
end_comment

begin_define
define|#
directive|define
name|DEFWWVPROP
value|0x01eb851f
end_define

begin_comment
comment|/* about 7.5 ms */
end_comment

begin_define
define|#
directive|define
name|DEFWWVHPROP
value|0x06c8b439
end_define

begin_comment
comment|/* about 26.5 ms */
end_comment

begin_comment
comment|/*  * Maximum propagation delay we believe.  125 ms as an l_fp fraction  */
end_comment

begin_define
define|#
directive|define
name|PSTMAXPROP
value|0x20000000
end_define

begin_comment
comment|/*  * Default minutes since an update.  */
end_comment

begin_define
define|#
directive|define
name|DEFMAXFREERUN
value|(20)
end_define

begin_comment
comment|/*  * Hack to avoid excercising the multiplier.  I have no pride.  */
end_comment

begin_define
define|#
directive|define
name|MULBY10
parameter_list|(
name|x
parameter_list|)
value|(((x)<<3) + ((x)<<1))
end_define

begin_comment
comment|/*  * PST unit control structure.  */
end_comment

begin_struct
struct|struct
name|pstunit
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* associated peer structure */
name|struct
name|event
name|psttimer
decl_stmt|;
comment|/* timeout timer structure */
name|struct
name|refclockio
name|pstio
decl_stmt|;
comment|/* given to the I/O handler */
name|l_fp
name|rectimes
index|[
name|NPSTSAMPS
index|]
decl_stmt|;
comment|/* times we received this stuff */
name|l_fp
name|reftimes
index|[
name|NPSTSAMPS
index|]
decl_stmt|;
comment|/* times of codes received */
name|l_fp
name|lastrec
decl_stmt|;
comment|/* last receive time */
name|l_fp
name|lastref
decl_stmt|;
comment|/* last reference time */
name|char
name|description
index|[
name|PSTDESCLEN
index|]
decl_stmt|;
comment|/* description of clock */
name|char
name|lastcode
index|[
name|PSTCODELEN
index|]
decl_stmt|;
comment|/* last code we received */
name|u_char
name|lencode
decl_stmt|;
comment|/* length of the last code */
name|u_char
name|nextsample
decl_stmt|;
comment|/* the next offset expected */
name|u_char
name|unit
decl_stmt|;
comment|/* unit number for this guy */
name|u_char
name|state
decl_stmt|;
comment|/* what we're waiting for */
name|s_char
name|station
decl_stmt|;
comment|/* WWV or WWVH? */
name|u_char
name|flags
decl_stmt|;
comment|/* flag byte */
name|u_char
name|status
decl_stmt|;
comment|/* clock status */
name|u_char
name|lastevent
decl_stmt|;
comment|/* last clock event */
name|u_char
name|timezone
decl_stmt|;
comment|/* hour offset to time zone */
name|u_char
name|errors
decl_stmt|;
comment|/* number of errors detected */
name|u_char
name|year
decl_stmt|;
comment|/* year reported by clock */
name|u_char
name|month
decl_stmt|;
comment|/* month, from clock */
name|u_char
name|monthday
decl_stmt|;
comment|/* day, from clock */
name|u_char
name|hour
decl_stmt|;
comment|/* hour of day */
name|u_char
name|minute
decl_stmt|;
comment|/* minute of day */
name|u_char
name|second
decl_stmt|;
comment|/* second of day */
name|u_char
name|leap
decl_stmt|;
comment|/* leap indicators */
name|s_char
name|tzoffset
decl_stmt|;
comment|/* time zone offset */
name|u_char
name|reason
decl_stmt|;
comment|/* reason for failure */
name|u_short
name|millisecond
decl_stmt|;
comment|/* millisecond of day */
name|u_short
name|yearday
decl_stmt|;
comment|/* day of the year */
name|u_short
name|timesincesync
decl_stmt|;
comment|/* time since radio got sample */
name|U_LONG
name|yearstart
decl_stmt|;
comment|/* NTP time at year start */
name|U_LONG
name|lastupdate
decl_stmt|;
comment|/* last time data received */
name|U_LONG
name|polls
decl_stmt|;
comment|/* number of polls */
name|U_LONG
name|noreply
decl_stmt|;
comment|/* number of time outs */
name|U_LONG
name|badformat
decl_stmt|;
comment|/* number of bad format responses */
name|U_LONG
name|baddata
decl_stmt|;
comment|/* number of invalid time codes */
name|U_LONG
name|timestarted
decl_stmt|;
comment|/* time we started this */
block|}
struct|;
end_struct

begin_comment
comment|/*  * States we might be in  */
end_comment

begin_define
define|#
directive|define
name|STATE_IDLE
value|0
end_define

begin_comment
comment|/* not doing anything in particular */
end_comment

begin_define
define|#
directive|define
name|STATE_QV
value|1
end_define

begin_comment
comment|/* trying to get version */
end_comment

begin_define
define|#
directive|define
name|STATE_QM
value|2
end_define

begin_comment
comment|/* sent QM */
end_comment

begin_define
define|#
directive|define
name|STATE_QD
value|3
end_define

begin_comment
comment|/* sent QD */
end_comment

begin_define
define|#
directive|define
name|STATE_QT
value|4
end_define

begin_comment
comment|/* send QT */
end_comment

begin_comment
comment|/*  * Status flags  */
end_comment

begin_define
define|#
directive|define
name|PST_LEAPYEAR
value|0x1
end_define

begin_comment
comment|/* pst clock thinks it is a leap year */
end_comment

begin_define
define|#
directive|define
name|PST_SIGFAULT
value|0x2
end_define

begin_comment
comment|/* signal fault */
end_comment

begin_define
define|#
directive|define
name|PST_HARDERR
value|0x4
end_define

begin_comment
comment|/* hardware error */
end_comment

begin_define
define|#
directive|define
name|PST_NOTIME
value|0x8
end_define

begin_comment
comment|/* no time available */
end_comment

begin_define
define|#
directive|define
name|PST_WWVH
value|0x10
end_define

begin_comment
comment|/* synchronized to WWVH */
end_comment

begin_define
define|#
directive|define
name|PST_DOQV
value|0x20
end_define

begin_comment
comment|/* get version, reinit delays */
end_comment

begin_define
define|#
directive|define
name|PST_DORESET
value|0x40
end_define

begin_comment
comment|/* reset the clock */
end_comment

begin_comment
comment|/*  * The PST often encodes stuff by adding an ASCII '0' to it.  The  * largest range of values encoded this way is 0 through 31, or '0'  * through 'O'.  These macroes manipulate these values.  */
end_comment

begin_define
define|#
directive|define
name|ISVALIDPST
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= 'O')
end_define

begin_define
define|#
directive|define
name|PSTTOBIN
parameter_list|(
name|c
parameter_list|)
value|((int)(c) - '0')
end_define

begin_define
define|#
directive|define
name|BINTOPST
parameter_list|(
name|c
parameter_list|)
value|((char)((c) + '0'))
end_define

begin_comment
comment|/*  * Status bits.  Look at the QM command  */
end_comment

begin_define
define|#
directive|define
name|SIGFAULT
value|0x1
end_define

begin_define
define|#
directive|define
name|HARDFAULT
value|0x2
end_define

begin_define
define|#
directive|define
name|OUTOFSPEC
value|0x4
end_define

begin_define
define|#
directive|define
name|TIMEAVAILABLE
value|0x8
end_define

begin_comment
comment|/*  * Module reason codes  */
end_comment

begin_define
define|#
directive|define
name|QVREASON
value|20
end_define

begin_define
define|#
directive|define
name|QMREASON
value|40
end_define

begin_define
define|#
directive|define
name|QDREASON
value|60
end_define

begin_define
define|#
directive|define
name|QTREASON
value|80
end_define

begin_comment
comment|/*  * Station i.d. characters in QM output  */
end_comment

begin_define
define|#
directive|define
name|WWV_CHAR
value|'C'
end_define

begin_define
define|#
directive|define
name|WWVH_CHAR
value|'H'
end_define

begin_comment
comment|/*  * We allow a few errors, but if we get more than 12 seconds behind  * the schedule we start from sample 0 again.  4 seconds is the minimum  * time between time out routine executions.  */
end_comment

begin_define
define|#
directive|define
name|PSTMAXDELAY
value|12
end_define

begin_define
define|#
directive|define
name|PSTMINTIMEOUT
value|4
end_define

begin_comment
comment|/*  * The PST polling schedule.  We poll 12 times per 64 seconds (far too  * many, but what the heck).  The polls are scheduled to finish in this  * time with the assumption that the timer is good for no better than  * 4 second resolution.  If we get too far behind (due to bad samples  * or no responses) we start over.  */
end_comment

begin_struct
struct|struct
name|pstsched
block|{
name|u_short
name|nextinterval
decl_stmt|;
name|u_short
name|tooold
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pstsched
name|psttab
index|[
name|NPSTSAMPS
index|]
init|=
block|{
block|{
literal|4
block|,
name|PSTMAXDELAY
operator|+
literal|1
block|}
block|,
block|{
literal|4
block|,
name|PSTMAXDELAY
operator|+
literal|1
operator|+
literal|4
block|}
block|,
block|{
literal|8
block|,
name|PSTMAXDELAY
operator|+
literal|1
operator|+
literal|4
operator|+
literal|4
block|}
block|,
block|{
literal|4
block|,
name|PSTMAXDELAY
operator|+
literal|1
operator|+
literal|4
operator|+
literal|4
operator|+
literal|8
block|}
block|,
block|{
literal|8
block|,
name|PSTMAXDELAY
operator|+
literal|1
operator|+
literal|4
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
block|}
block|,
block|{
literal|4
block|,
name|PSTMAXDELAY
operator|+
literal|1
operator|+
literal|4
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
operator|+
literal|8
block|}
block|,
block|{
literal|4
block|,
name|PSTMAXDELAY
operator|+
literal|1
operator|+
literal|4
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
block|}
block|,
block|{
literal|8
block|,
name|PSTMAXDELAY
operator|+
literal|1
operator|+
literal|4
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
operator|+
literal|4
block|}
block|,
block|{
literal|4
block|,
name|PSTMAXDELAY
operator|+
literal|1
operator|+
literal|4
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
operator|+
literal|4
operator|+
literal|8
block|}
block|,
block|{
literal|8
block|,
name|PSTMAXDELAY
operator|+
literal|1
operator|+
literal|4
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
block|}
block|,
block|{
literal|4
block|,
name|PSTMAXDELAY
operator|+
literal|1
operator|+
literal|4
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
operator|+
literal|8
block|}
block|,
block|{
literal|4
block|,
name|PSTMAXDELAY
operator|+
literal|1
operator|+
literal|4
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
operator|+
literal|8
operator|+
literal|4
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Data space for the unit structures.  Note that we allocate these on  * the fly, but never give them back.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pstunit
modifier|*
name|pstunits
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|unitinuse
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Structure to keep processed propagation data in.  */
end_comment

begin_struct
struct|struct
name|pst_propagate
block|{
name|U_LONG
name|remainder
decl_stmt|;
comment|/* left over submillisecond remainder */
name|char
name|msbchar
decl_stmt|;
comment|/* character for high order bits */
name|char
name|lsbchar
decl_stmt|;
comment|/* character for low order bits */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Keep the fudge factors separately so they can be set even  * when no clock is configured.  */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|wwv_prop_delay
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_fp
name|wwvh_prop_delay
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pst_propagate
name|wwv_prop_data
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pst_propagate
name|wwvh_prop_data
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|stratumtouse
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|sloppyclock
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|freerun
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Pointer to the default description  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pstdefdesc
init|=
name|PSTDEFDESC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * macro for writing to the clock, printing an error if we fail  */
end_comment

begin_define
define|#
directive|define
name|pst_send
parameter_list|(
name|pst
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|)
define|\
value|if (write((pst)->pstio.fd, (str), (len))< 0) \ 		pst_write_error((pst))
end_define

begin_comment
comment|/*  * macro for resetting the clock structure to zero  */
end_comment

begin_define
define|#
directive|define
name|pst_reset
parameter_list|(
name|pst
parameter_list|)
define|\
value|do { \ 		pst->nextsample = 0; \ 		pst->station = 0; \ 		pst->leap = 0; \ 	} while (0)
end_define

begin_comment
comment|/*  * macro for event reporting  */
end_comment

begin_define
define|#
directive|define
name|pst_event
parameter_list|(
name|pst
parameter_list|,
name|evnt_code
parameter_list|)
define|\
value|do { \ 		if ((pst)->status != (u_char)(evnt_code)) \ 			pst_do_event((pst), (evnt_code)); \ 	} while (0)
end_define

begin_comment
comment|/*  * Imported from the timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|U_LONG
name|current_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|event
name|timerqueue
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from ntp_loopfilter module  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fdpps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pps file descriptor */
end_comment

begin_comment
comment|/*  * Imported from ntpd module  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global debug flag */
end_comment

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|pst_init
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pst_start
name|P
argument_list|(
operator|(
name|u_int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pst_shutdown
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pst_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pst_process
name|P
argument_list|(
operator|(
expr|struct
name|pstunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pst_control
name|P
argument_list|(
operator|(
name|u_int
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|refclockstat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pst_buginfo
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|refclockbug
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pst_write_error
name|P
argument_list|(
operator|(
expr|struct
name|pstunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pst_timeout
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pst_QV_process
name|P
argument_list|(
operator|(
expr|struct
name|pstunit
operator|*
operator|,
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pst_QM_process
name|P
argument_list|(
operator|(
expr|struct
name|pstunit
operator|*
operator|,
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pst_QD_process
name|P
argument_list|(
operator|(
expr|struct
name|pstunit
operator|*
operator|,
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pst_QT_process
name|P
argument_list|(
operator|(
expr|struct
name|pstunit
operator|*
operator|,
expr|struct
name|recvbuf
operator|*
operator|,
name|l_fp
operator|*
operator|,
name|l_fp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pst_do_event
name|P
argument_list|(
operator|(
expr|struct
name|pstunit
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pst_compute_delay
name|P
argument_list|(
operator|(
name|U_LONG
operator|,
expr|struct
name|pst_propagate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_pst
init|=
block|{
name|pst_start
block|,
name|pst_shutdown
block|,
name|noentry
block|,
name|pst_control
block|,
name|pst_init
block|,
name|pst_buginfo
block|,
name|NOFLAGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * pst_init - initialize internal PST driver data  */
end_comment

begin_function
specifier|static
name|void
name|pst_init
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Just zero the data arrays 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pstunits
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|pstunits
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|unitinuse
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|unitinuse
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize fudge factors to default. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXUNITS
condition|;
name|i
operator|++
control|)
block|{
name|wwv_prop_delay
index|[
name|i
index|]
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|wwv_prop_delay
index|[
name|i
index|]
operator|.
name|l_uf
operator|=
name|DEFWWVPROP
expr_stmt|;
name|pst_compute_delay
argument_list|(
name|DEFWWVPROP
argument_list|,
operator|&
name|wwv_prop_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|wwvh_prop_delay
index|[
name|i
index|]
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|wwvh_prop_delay
index|[
name|i
index|]
operator|.
name|l_uf
operator|=
name|DEFWWVHPROP
expr_stmt|;
name|pst_compute_delay
argument_list|(
name|DEFWWVHPROP
argument_list|,
operator|&
name|wwvh_prop_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|stratumtouse
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|sloppyclock
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|freerun
index|[
name|i
index|]
operator|=
name|DEFMAXFREERUN
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * pst_start - open the PST device and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|pst_start
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|u_int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|pstunit
modifier|*
name|pst
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|fd232
decl_stmt|;
name|char
name|pstdev
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * Check configuration info 	 */
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_start: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_start: unit %d in use"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Open serial port 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pstdev
argument_list|,
name|PSTDEV
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fd232
operator|=
name|open
argument_list|(
name|pstdev
argument_list|,
name|O_RDWR
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd232
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_start: open of %s: %m"
argument_list|,
name|pstdev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
comment|/* 	 * System V serial line parameters (termio interface) 	 * 	 */
block|{
name|struct
name|termio
name|ttyb
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_start: ioctl(%s, TCGETA): %m"
argument_list|,
name|pstdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
name|ttyb
operator|.
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
operator||
name|ICRNL
expr_stmt|;
name|ttyb
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|ttyb
operator|.
name|c_cflag
operator|=
name|SPEED232
operator||
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
name|ttyb
operator|.
name|c_lflag
operator|=
name|ICANON
expr_stmt|;
name|ttyb
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyb
operator|.
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_start: ioctl(%s, TCSETA): %m"
argument_list|,
name|pstdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_SYSV_TTYS */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
comment|/* 	 * POSIX serial line parameters (termios interface) 	 * 	 * The PSTCLK option provides timestamping at the driver level.  	 * It requires the tty_clk streams module. 	 * 	 * The PSTPPS option provides timestamping at the driver level. 	 * It uses a 1-pps signal and level converter (gadget box) and 	 * requires the ppsclock streams module and SunOS 4.1.1 or 	 * later. 	 */
block|{
name|struct
name|termios
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
name|ttyp
operator|=
operator|&
name|ttyb
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd232
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_start: tcgetattr(%s): %m"
argument_list|,
name|pstdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
name|ttyp
operator|->
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
operator||
name|ICRNL
expr_stmt|;
name|ttyp
operator|->
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cflag
operator|=
name|SPEED232
operator||
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
name|ttyp
operator|->
name|c_lflag
operator|=
name|ICANON
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyp
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd232
argument_list|,
name|TCSANOW
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_start: tcsetattr(%s): %m"
argument_list|,
name|pstdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
if|if
condition|(
name|tcflush
argument_list|(
name|fd232
argument_list|,
name|TCIOFLUSH
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_start: tcflush(%s): %m"
argument_list|,
name|pstdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_TERMIOS */
ifdef|#
directive|ifdef
name|STREAM
if|#
directive|if
name|defined
argument_list|(
name|PSTCLK
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|I_PUSH
argument_list|,
literal|"clk"
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_start: ioctl(%s, I_PUSH, clk): %m"
argument_list|,
name|pstdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|CLK_SETSTR
argument_list|,
literal|"\n"
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_start: ioctl(%s, CLK_SETSTR): %m"
argument_list|,
name|pstdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PSTCLK */
if|#
directive|if
name|defined
argument_list|(
name|PSTPPS
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|I_PUSH
argument_list|,
literal|"ppsclock"
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_start: ioctl(%s, I_PUSH, ppsclock): %m"
argument_list|,
name|pstdev
argument_list|)
expr_stmt|;
else|else
name|fdpps
operator|=
name|fd232
expr_stmt|;
endif|#
directive|endif
comment|/* PSTPPS */
endif|#
directive|endif
comment|/* STREAM */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
comment|/* 	 * 4.3bsd serial line parameters (sgttyb interface) 	 * 	 * The PSTCLK option provides timestamping at the driver level.  	 * It requires the tty_clk line discipline and 4.3bsd or later. 	 */
block|{
name|struct
name|sgttyb
name|ttyb
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PSTCLK
argument_list|)
name|int
name|ldisc
init|=
name|CLKLDISC
decl_stmt|;
endif|#
directive|endif
comment|/* PSTCLK */
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_start: ioctl(%s, TIOCGETP): %m"
argument_list|,
name|pstdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
name|ttyb
operator|.
name|sg_ispeed
operator|=
name|ttyb
operator|.
name|sg_ospeed
operator|=
name|SPEED232
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PSTCLK
argument_list|)
name|ttyb
operator|.
name|sg_erase
operator|=
name|ttyb
operator|.
name|sg_kill
operator|=
literal|'\r'
expr_stmt|;
name|ttyb
operator|.
name|sg_flags
operator|=
name|RAW
expr_stmt|;
else|#
directive|else
name|ttyb
operator|.
name|sg_erase
operator|=
name|ttyb
operator|.
name|sg_kill
operator|=
literal|'\0'
expr_stmt|;
name|ttyb
operator|.
name|sg_flags
operator|=
name|EVENP
operator||
name|ODDP
operator||
name|CRMOD
expr_stmt|;
endif|#
directive|endif
comment|/* PSTCLK */
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_start: ioctl(%s, TIOCSETP): %m"
argument_list|,
name|pstdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PSTCLK
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|ldisc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_start: ioctl(%s, TIOCSETD): %m"
argument_list|,
name|pstdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
endif|#
directive|endif
comment|/* PSTCLK */
block|}
endif|#
directive|endif
comment|/* HAVE_BSD_TTYS */
comment|/* 	 * Allocate unit structure 	 */
if|if
condition|(
name|pstunits
index|[
name|unit
index|]
operator|!=
literal|0
condition|)
block|{
name|pst
operator|=
name|pstunits
index|[
name|unit
index|]
expr_stmt|;
comment|/* The one we want is okay */
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXUNITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|unitinuse
index|[
name|i
index|]
operator|&&
name|pstunits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|MAXUNITS
condition|)
block|{
comment|/* 			 * Reclaim this one 			 */
name|pst
operator|=
name|pstunits
index|[
name|i
index|]
expr_stmt|;
name|pstunits
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pst
operator|=
operator|(
expr|struct
name|pstunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pstunit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pst
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pstunit
argument_list|)
argument_list|)
expr_stmt|;
name|pstunits
index|[
name|unit
index|]
operator|=
name|pst
expr_stmt|;
comment|/* 	 * Set up the structure 	 */
name|pst
operator|->
name|peer
operator|=
name|peer
expr_stmt|;
name|pst
operator|->
name|unit
operator|=
operator|(
name|u_char
operator|)
name|unit
expr_stmt|;
name|pst
operator|->
name|state
operator|=
name|STATE_IDLE
expr_stmt|;
name|pst
operator|->
name|flags
operator||=
name|PST_DOQV
expr_stmt|;
name|pst
operator|->
name|timestarted
operator|=
name|current_time
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pst
operator|->
name|description
argument_list|,
name|pstdefdesc
argument_list|)
expr_stmt|;
name|pst
operator|->
name|psttimer
operator|.
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|pst
expr_stmt|;
name|pst
operator|->
name|psttimer
operator|.
name|event_handler
operator|=
name|pst_timeout
expr_stmt|;
name|pst
operator|->
name|pstio
operator|.
name|clock_recv
operator|=
name|pst_receive
expr_stmt|;
name|pst
operator|->
name|pstio
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|pst
expr_stmt|;
name|pst
operator|->
name|pstio
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pst
operator|->
name|pstio
operator|.
name|fd
operator|=
name|fd232
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pst
operator|->
name|pstio
argument_list|)
condition|)
block|{
goto|goto
name|screwed
goto|;
block|}
comment|/* 	 * All done.  Initialize a few random peer variables, then 	 * start the timer and return success. 	 */
name|peer
operator|->
name|precision
operator|=
name|PSTPRECISION
expr_stmt|;
name|peer
operator|->
name|rootdelay
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|rootdispersion
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|stratumtouse
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|stratumtouse
index|[
name|unit
index|]
operator|<=
literal|1
condition|)
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peer
operator|->
name|refid
argument_list|,
name|WWVREFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|peer
operator|->
name|refid
operator|=
name|htonl
argument_list|(
name|PSTHSREFID
argument_list|)
expr_stmt|;
name|pst
operator|->
name|psttimer
operator|.
name|event_time
operator|=
name|current_time
operator|+
name|PSTMINTIMEOUT
expr_stmt|;
name|TIMER_ENQUEUE
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|pst
operator|->
name|psttimer
argument_list|)
expr_stmt|;
name|unitinuse
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
comment|/* 	 * Something broke; abandon ship. 	 */
name|screwed
label|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd232
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pst_shutdown - shut down a PST clock  */
end_comment

begin_function
specifier|static
name|void
name|pst_shutdown
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|pstunit
modifier|*
name|pst
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_shutdown: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_shutdown: unit %d not in use"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Tell the I/O module to turn us off, and dequeue timer 	 * if any.  We're history. 	 */
name|pst
operator|=
name|pstunits
index|[
name|unit
index|]
expr_stmt|;
name|TIMER_DEQUEUE
argument_list|(
operator|&
name|pst
operator|->
name|psttimer
argument_list|)
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pst
operator|->
name|pstio
argument_list|)
expr_stmt|;
name|unitinuse
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pst_write_error - complain about writes to the clock  */
end_comment

begin_function
specifier|static
name|void
name|pst_write_error
parameter_list|(
name|pst
parameter_list|)
name|struct
name|pstunit
modifier|*
name|pst
decl_stmt|;
block|{
comment|/* 	 * This will fill syslog is something is really wrong.  Should 	 * throttle it back. 	 */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_write_error: unit %d: %m"
argument_list|,
name|pst
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pst_timeout - process a timeout event  */
end_comment

begin_function
specifier|static
name|void
name|pst_timeout
parameter_list|(
name|fakepeer
parameter_list|)
name|struct
name|peer
modifier|*
name|fakepeer
decl_stmt|;
block|{
specifier|register
name|struct
name|pstunit
modifier|*
name|pst
decl_stmt|;
name|U_LONG
name|poll
decl_stmt|;
comment|/* 	 * The timeout routine always initiates a chain of 	 * query-responses from the clock, by sending either 	 * a QV command (if we need to (re)set the propagation 	 * delays into the clock), a QM command or an SRY 	 * command (after a leap second).  The pst_receive() 	 * routine should complete the set of queries on its own 	 * LONG before the next time out is due, so if we see any 	 * state in here other than idle it means the clock hasn't 	 * responded. 	 */
name|pst
operator|=
operator|(
expr|struct
name|pstunit
operator|*
operator|)
name|fakepeer
expr_stmt|;
switch|switch
condition|(
name|pst
operator|->
name|state
condition|)
block|{
case|case
name|STATE_IDLE
case|:
name|poll
operator|=
operator|(
name|U_LONG
operator|)
name|psttab
index|[
name|pst
operator|->
name|nextsample
index|]
operator|.
name|nextinterval
expr_stmt|;
break|break;
comment|/* all is well */
case|case
name|STATE_QV
case|:
name|pst
operator|->
name|flags
operator||=
name|PST_DOQV
expr_stmt|;
comment|/* no response, do QV again */
comment|/*FALLSTHROUGH*/
case|case
name|STATE_QM
case|:
case|case
name|STATE_QD
case|:
case|case
name|STATE_QT
case|:
name|pst
operator|->
name|noreply
operator|++
expr_stmt|;
comment|/* mark the lack of response */
name|poll
operator|=
name|PSTMINTIMEOUT
expr_stmt|;
comment|/* minimum time poll */
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_timeout: unit %d invalid state %d"
argument_list|,
name|pst
operator|->
name|unit
argument_list|,
name|pst
operator|->
name|state
argument_list|)
expr_stmt|;
name|poll
operator|=
name|PSTMINTIMEOUT
expr_stmt|;
comment|/* minimum time poll */
break|break;
block|}
if|if
condition|(
name|pst
operator|->
name|flags
operator|&
name|PST_DORESET
condition|)
block|{
comment|/* 		 * Do a reset.  At the next interrupt, start with 		 * a QV command to set in the delays. 		 */
name|pst
operator|->
name|flags
operator|&=
operator|~
name|PST_DORESET
expr_stmt|;
name|pst
operator|->
name|flags
operator||=
name|PST_DOQV
expr_stmt|;
name|pst
operator|->
name|state
operator|=
name|STATE_IDLE
expr_stmt|;
name|pst_send
argument_list|(
name|pst
argument_list|,
literal|"\003SRY"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pst
operator|->
name|flags
operator|&
name|PST_DOQV
condition|)
block|{
name|pst
operator|->
name|polls
operator|++
expr_stmt|;
name|pst
operator|->
name|flags
operator|&=
operator|~
name|PST_DOQV
expr_stmt|;
name|pst
operator|->
name|state
operator|=
name|STATE_QV
expr_stmt|;
name|pst_send
argument_list|(
name|pst
argument_list|,
literal|"\003QV"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pst
operator|->
name|polls
operator|++
expr_stmt|;
name|pst
operator|->
name|state
operator|=
name|STATE_QM
expr_stmt|;
name|pst_send
argument_list|(
name|pst
argument_list|,
literal|"\003QM"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|pst
operator|->
name|psttimer
operator|.
name|event_time
operator|+=
name|poll
expr_stmt|;
name|TIMER_ENQUEUE
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|pst
operator|->
name|psttimer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pst_QV_process - decode the results of a QV poll and insert fudge  *		    factors into the clock.  */
end_comment

begin_function
specifier|static
name|int
name|pst_QV_process
parameter_list|(
name|pst
parameter_list|,
name|rbufp
parameter_list|)
specifier|register
name|struct
name|pstunit
modifier|*
name|pst
decl_stmt|;
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|model
decl_stmt|;
name|char
modifier|*
name|company
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|char
name|wwvdelay
index|[
literal|6
index|]
init|=
block|{
literal|'S'
block|,
literal|'C'
block|,
literal|'\0'
block|,
literal|'S'
block|,
literal|'E'
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
name|char
name|wwvhdelay
index|[
literal|6
index|]
init|=
block|{
literal|'S'
block|,
literal|'H'
block|,
literal|'\0'
block|,
literal|'S'
block|,
literal|'G'
block|,
literal|'\0'
block|}
decl_stmt|;
comment|/* 	 * The output of the QV command looks like: 	 * 	 * PSTI ITS V04.01.000\r 	 * 	 * or 	 * 	 * TRAC ITS V04.01.000\r 	 * 	 * or 	 * 	 * TRACONEX TS V05.02.001\r 	 * 	 * The minimum length of the string is about 16 characters. 	 * The maximum length is sort of unbounded, but we get suspicious 	 * if it is more than 34. 	 */
name|len
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|PSTMAXQVLEN
operator|+
literal|10
condition|)
name|len
operator|=
name|PSTMAXQVLEN
operator|+
literal|10
expr_stmt|;
name|bp
operator|=
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
name|cp
operator|=
name|pst
operator|->
name|lastcode
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
operator|(
operator|*
name|bp
operator|++
operator|)
operator|&
literal|0x7f
expr_stmt|;
comment|/* strip parity */
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
name|cp
operator|++
expr_stmt|;
block|}
name|pst
operator|->
name|lencode
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cp
operator|-
name|pst
operator|->
name|lastcode
argument_list|)
expr_stmt|;
comment|/* 	 * Okay, got all printable characters from the string 	 * copied.  We expect to have been terminated by the 	 * EOL character.  If not, forget it.  If the length 	 * is insane, forget it. 	 */
if|if
condition|(
operator|*
name|cp
operator|!=
name|PSTEOL
operator|||
name|pst
operator|->
name|lencode
operator|<
name|PSTMINQVLEN
operator|||
name|pst
operator|->
name|lencode
operator|>
name|PSTMAXQVLEN
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QVREASON
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Now, format check what we can.  Dump it at the least 	 * sign of trouble. 	 */
name|cp
operator|=
name|pst
operator|->
name|lastcode
expr_stmt|;
name|model
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'P'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|'S'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|'T'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|'I'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|' '
condition|)
block|{
name|cp
operator|=
name|pst
operator|->
name|lastcode
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'T'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|'R'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|'A'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|'C'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|' '
condition|)
block|{
name|cp
operator|=
name|pst
operator|->
name|lastcode
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'T'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|'R'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|'A'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|'C'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|'O'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|'N'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|'E'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|'X'
operator|||
operator|*
name|cp
operator|!=
literal|' '
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QVREASON
operator|+
literal|2
expr_stmt|;
return|return
literal|0
return|;
block|}
name|company
operator|=
literal|"Traconex"
expr_stmt|;
name|model
operator|=
literal|"1030"
expr_stmt|;
block|}
name|company
operator|=
literal|"Traconex"
expr_stmt|;
block|}
else|else
block|{
name|company
operator|=
literal|"Precision Standard Time"
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'M'
condition|)
name|model
operator|=
literal|"1010"
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'I'
condition|)
name|model
operator|=
literal|"1020"
expr_stmt|;
elseif|else
if|if
condition|(
name|model
operator|==
name|NULL
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QVREASON
operator|+
literal|3
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'T'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|'S'
operator|||
operator|*
name|cp
operator|++
operator|!=
literal|' '
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QVREASON
operator|+
literal|4
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'X'
operator|&&
operator|*
name|cp
operator|!=
literal|'V'
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QVREASON
operator|+
literal|5
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Next is the version.  Copy it into the buffer. 	 */
name|bp
operator|=
name|buf
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'.'
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Final bit of fluff is to set the description 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pst
operator|->
name|description
argument_list|,
name|PSTDESCRIPTION
argument_list|,
name|company
argument_list|,
name|model
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* 	 * Now the serious stuff.  Since we are now sure that the 	 * clock is there, we can be fairly sure that the delay 	 * setting commands will take.  Send them. 	 */
name|wwvdelay
index|[
literal|2
index|]
operator|=
name|wwv_prop_data
index|[
name|pst
operator|->
name|unit
index|]
operator|.
name|msbchar
expr_stmt|;
name|wwvdelay
index|[
literal|5
index|]
operator|=
name|wwv_prop_data
index|[
name|pst
operator|->
name|unit
index|]
operator|.
name|lsbchar
expr_stmt|;
name|pst_send
argument_list|(
name|pst
argument_list|,
name|wwvdelay
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* 	 * Same thing for WWVH 	 */
name|wwvhdelay
index|[
literal|2
index|]
operator|=
name|wwvh_prop_data
index|[
name|pst
operator|->
name|unit
index|]
operator|.
name|msbchar
expr_stmt|;
name|wwvhdelay
index|[
literal|5
index|]
operator|=
name|wwvh_prop_data
index|[
name|pst
operator|->
name|unit
index|]
operator|.
name|lsbchar
expr_stmt|;
name|pst_send
argument_list|(
name|pst
argument_list|,
name|wwvhdelay
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* 	 * Should be okay.  Return positive response. 	 */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * pst_QM_process - process the output of a QM command  */
end_comment

begin_function
specifier|static
name|int
name|pst_QM_process
parameter_list|(
name|pst
parameter_list|,
name|rbufp
parameter_list|)
specifier|register
name|struct
name|pstunit
modifier|*
name|pst
decl_stmt|;
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
comment|/* 	 * The output of the QM command looks like: 	 *  	 * O6B532352823C00270322 	 * 	 * The minimum length of the string is 19 characters. 	 * The maximum length is sort of unbounded, but we get suspicious 	 * if it is more than 42. 	 */
name|n
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|PSTMAXQMLEN
operator|+
literal|10
condition|)
name|n
operator|=
name|PSTMAXQMLEN
operator|+
literal|10
expr_stmt|;
name|bp
operator|=
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
name|cp
operator|=
name|pst
operator|->
name|lastcode
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
operator|(
operator|*
name|bp
operator|++
operator|)
operator|&
literal|0x7f
expr_stmt|;
comment|/* strip parity */
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
name|cp
operator|++
expr_stmt|;
block|}
name|pst
operator|->
name|lencode
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cp
operator|-
name|pst
operator|->
name|lastcode
argument_list|)
expr_stmt|;
comment|/* 	 * Okay, got all printable characters from the string 	 * copied.  We expect to have been terminated by the 	 * EOL character.  If not, forget it.  If the length 	 * is insane, forget it. 	 */
if|if
condition|(
operator|*
name|cp
operator|!=
name|PSTEOL
operator|||
name|pst
operator|->
name|lencode
operator|<
name|PSTMINQMLEN
operator|||
name|pst
operator|->
name|lencode
operator|>
name|PSTMAXQMLEN
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QMREASON
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Ensure that the first PSTMINQMLEN characters are valid with 	 * respect to the way the clock encodes binary data. 	 */
name|cp
operator|=
name|pst
operator|->
name|lastcode
expr_stmt|;
name|n
operator|=
name|pst
operator|->
name|lencode
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ISVALIDPST
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QMREASON
operator|+
literal|2
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Collect information we are interested in. 	 */
name|cp
operator|=
name|pst
operator|->
name|lastcode
expr_stmt|;
name|pst
operator|->
name|timezone
operator|=
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pst
operator|->
name|timezone
operator|>
literal|23
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QMREASON
operator|+
literal|3
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pst
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PST_LEAPYEAR
operator||
name|PST_SIGFAULT
operator||
name|PST_HARDERR
operator||
name|PST_NOTIME
operator||
name|PST_WWVH
operator|)
expr_stmt|;
name|n
operator|=
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|15
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QMREASON
operator|+
literal|4
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|n
operator|+
literal|2
operator|)
operator|&
literal|0x3
operator|)
operator|==
literal|0
condition|)
name|pst
operator|->
name|flags
operator||=
name|PST_LEAPYEAR
expr_stmt|;
name|n
operator|=
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|15
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QMREASON
operator|+
literal|5
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|n
operator|&
name|SIGFAULT
condition|)
name|pst
operator|->
name|flags
operator||=
name|PST_SIGFAULT
expr_stmt|;
if|if
condition|(
name|n
operator|&
name|HARDFAULT
condition|)
name|pst
operator|->
name|flags
operator||=
name|PST_HARDERR
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|n
operator|&
name|TIMEAVAILABLE
operator|)
condition|)
name|pst
operator|->
name|flags
operator||=
name|PST_NOTIME
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|12
index|]
operator|==
literal|'H'
condition|)
block|{
name|pst
operator|->
name|flags
operator||=
name|PST_WWVH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
index|[
literal|12
index|]
operator|==
literal|'C'
condition|)
block|{
name|pst
operator|->
name|flags
operator|&=
operator|~
name|PST_WWVH
expr_stmt|;
block|}
else|else
block|{
name|pst
operator|->
name|reason
operator|=
name|QMREASON
operator|+
literal|6
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|wwv_prop_data
index|[
name|pst
operator|->
name|unit
index|]
operator|.
name|msbchar
operator|!=
name|cp
index|[
literal|5
index|]
operator|||
name|wwv_prop_data
index|[
name|pst
operator|->
name|unit
index|]
operator|.
name|lsbchar
operator|!=
name|cp
index|[
literal|6
index|]
operator|||
name|wwvh_prop_data
index|[
name|pst
operator|->
name|unit
index|]
operator|.
name|msbchar
operator|!=
name|cp
index|[
literal|7
index|]
operator|||
name|wwvh_prop_data
index|[
name|pst
operator|->
name|unit
index|]
operator|.
name|lsbchar
operator|!=
name|cp
index|[
literal|8
index|]
condition|)
name|pst
operator|->
name|flags
operator||=
name|PST_DOQV
expr_stmt|;
name|bp
operator|=
name|cp
operator|+
literal|13
expr_stmt|;
name|pst
operator|->
name|timesincesync
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bp
operator|<
operator|(
name|cp
operator|+
literal|17
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QMREASON
operator|+
literal|6
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pst
operator|->
name|timesincesync
operator|=
name|MULBY10
argument_list|(
name|pst
operator|->
name|timesincesync
argument_list|)
operator|+
name|PSTTOBIN
argument_list|(
operator|*
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
comment|/* 	 * That's about all we can do.  Return success. 	 */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * pst_QD_process - process the output of a QD command  */
end_comment

begin_function
specifier|static
name|int
name|pst_QD_process
parameter_list|(
name|pst
parameter_list|,
name|rbufp
parameter_list|)
specifier|register
name|struct
name|pstunit
modifier|*
name|pst
decl_stmt|;
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|cpstart
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* 	 * The output of the QM command looks like: 	 *  	 * 88/05/17/138\r 	 * 	 * The minimum length of the string is 12 characters as is 	 * the maximum length. 	 */
name|n
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|PSTMAXQDLEN
operator|+
literal|10
condition|)
name|n
operator|=
name|PSTMAXQDLEN
operator|+
literal|10
expr_stmt|;
name|bp
operator|=
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
name|cp
operator|=
operator|&
name|pst
operator|->
name|lastcode
index|[
name|pst
operator|->
name|lencode
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|cpstart
operator|=
name|cp
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
operator|(
operator|*
name|bp
operator|++
operator|)
operator|&
literal|0x7f
expr_stmt|;
comment|/* strip parity */
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
name|cp
operator|++
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|cp
operator|-
name|cpstart
operator|)
expr_stmt|;
name|pst
operator|->
name|lencode
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cp
operator|-
name|pst
operator|->
name|lastcode
argument_list|)
expr_stmt|;
comment|/* 	 * Okay, got all printable characters from the string 	 * copied.  We expect to have been terminated by the 	 * EOL character.  If not, forget it.  If the length 	 * is insane, forget it. 	 */
if|if
condition|(
operator|*
name|cp
operator|!=
name|PSTEOL
operator|||
name|len
operator|<
name|PSTMINQDLEN
operator|||
name|len
operator|>
name|PSTMAXQDLEN
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QDREASON
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Ensure that the characters are formatted validly.  They 	 * are either digits or '/'s. 	 */
name|cp
operator|=
name|cpstart
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|)
operator|||
name|cp
index|[
literal|2
index|]
operator|!=
literal|'/'
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|3
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|4
index|]
argument_list|)
operator|||
name|cp
index|[
literal|5
index|]
operator|!=
literal|'/'
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|6
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|7
index|]
argument_list|)
operator|||
name|cp
index|[
literal|8
index|]
operator|!=
literal|'/'
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|9
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|10
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|11
index|]
argument_list|)
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QDREASON
operator|+
literal|2
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Decode into year, month, day and year day 	 */
name|pst
operator|->
name|year
operator|=
name|MULBY10
argument_list|(
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|+
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pst
operator|->
name|month
operator|=
name|MULBY10
argument_list|(
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|3
index|]
argument_list|)
argument_list|)
operator|+
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|pst
operator|->
name|monthday
operator|=
name|MULBY10
argument_list|(
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|6
index|]
argument_list|)
argument_list|)
operator|+
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|pst
operator|->
name|yearday
operator|=
name|MULBY10
argument_list|(
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|9
index|]
argument_list|)
argument_list|)
operator|+
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
name|pst
operator|->
name|yearday
operator|=
name|MULBY10
argument_list|(
name|pst
operator|->
name|yearday
argument_list|)
operator|+
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Format check these. 	 */
if|if
condition|(
name|pst
operator|->
name|month
operator|>
literal|12
operator|||
name|pst
operator|->
name|monthday
operator|>
literal|31
operator|||
name|pst
operator|->
name|yearday
operator|>
literal|366
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QDREASON
operator|+
literal|3
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|pst
operator|->
name|flags
operator|&
name|PST_LEAPYEAR
operator|)
operator|&&
name|pst
operator|->
name|yearday
operator|>
literal|365
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QDREASON
operator|+
literal|4
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Done all we can. 	 */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * pst_QT_process - process the output of a QT command, return the times  */
end_comment

begin_function
specifier|static
name|int
name|pst_QT_process
parameter_list|(
name|pst
parameter_list|,
name|rbufp
parameter_list|,
name|tsclk
parameter_list|,
name|tsrec
parameter_list|)
specifier|register
name|struct
name|pstunit
modifier|*
name|pst
decl_stmt|;
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
name|l_fp
modifier|*
name|tsclk
decl_stmt|;
name|l_fp
modifier|*
name|tsrec
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|cpstart
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hour
decl_stmt|;
name|int
name|minute
decl_stmt|;
name|int
name|second
decl_stmt|;
name|int
name|msec
decl_stmt|;
name|int
name|tzoff
decl_stmt|;
comment|/* 	 * The output of the QT command looks like: 	 *  	 * A09:57:50.263D  	 *  	 * The minimum length of the string is 14 characters as is 	 * the maximum length. 	 */
name|n
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|PSTMAXQTLEN
operator|+
literal|10
condition|)
name|n
operator|=
name|PSTMAXQTLEN
operator|+
literal|10
expr_stmt|;
name|bp
operator|=
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
name|cp
operator|=
operator|&
name|pst
operator|->
name|lastcode
index|[
name|pst
operator|->
name|lencode
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|cpstart
operator|=
name|cp
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
operator|(
operator|*
name|bp
operator|++
operator|)
operator|&
literal|0x7f
expr_stmt|;
comment|/* strip parity */
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
name|cp
operator|++
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|cp
operator|-
name|cpstart
operator|)
expr_stmt|;
name|pst
operator|->
name|lencode
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cp
operator|-
name|pst
operator|->
name|lastcode
argument_list|)
expr_stmt|;
comment|/* 	 * Okay, got all printable characters from the string 	 * copied.  We expect to have been terminated by the 	 * EOL character.  If not, forget it.  If the length 	 * is insane, forget it. 	 */
if|if
condition|(
operator|*
name|cp
operator|!=
name|PSTEOL
operator|||
name|len
operator|<
name|PSTMINQTLEN
operator|||
name|len
operator|>
name|PSTMAXQTLEN
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QTREASON
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|PSTCLK
comment|/* 	 * Receive time stamp should be in buffer after the code. 	 * Make sure we have enough characters in there. 	 */
if|if
condition|(
operator|&
name|rbufp
operator|->
name|recv_buffer
index|[
name|rbufp
operator|->
name|recv_length
index|]
operator|-
name|bp
operator|<
literal|8
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QTREASON
operator|+
literal|2
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|buftvtots
argument_list|(
name|bp
argument_list|,
name|tsrec
argument_list|)
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QTREASON
operator|+
literal|3
expr_stmt|;
return|return
literal|0
return|;
block|}
else|#
directive|else
comment|/* 	 * Use the timestamp collected with the input. 	 */
operator|*
name|tsrec
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Ensure that the characters are formatted validly.  Mostly 	 * digits, but the occasional `:' and `.'. 	 */
name|cp
operator|=
name|cpstart
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|2
index|]
argument_list|)
operator|||
name|cp
index|[
literal|3
index|]
operator|!=
literal|':'
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|4
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|5
index|]
argument_list|)
operator|||
name|cp
index|[
literal|6
index|]
operator|!=
literal|':'
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|7
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|8
index|]
argument_list|)
operator|||
name|cp
index|[
literal|9
index|]
operator|!=
literal|'.'
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|10
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|11
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|cp
index|[
literal|12
index|]
argument_list|)
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QTREASON
operator|+
literal|4
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Extract the hour, minute, second and millisecond 	 */
name|hour
operator|=
name|MULBY10
argument_list|(
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|+
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|minute
operator|=
name|MULBY10
argument_list|(
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|4
index|]
argument_list|)
argument_list|)
operator|+
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|second
operator|=
name|MULBY10
argument_list|(
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|7
index|]
argument_list|)
argument_list|)
operator|+
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|msec
operator|=
name|MULBY10
argument_list|(
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|10
index|]
argument_list|)
argument_list|)
operator|+
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|msec
operator|=
name|MULBY10
argument_list|(
name|msec
argument_list|)
operator|+
name|PSTTOBIN
argument_list|(
name|cp
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|minute
operator|>
literal|59
operator|||
name|second
operator|>
literal|59
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QTREASON
operator|+
literal|5
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Trouble here.  Adjust the hours for AM/PM, if this is 	 * on, and for daylight saving time. 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'A'
condition|)
block|{
if|if
condition|(
name|hour
operator|>
literal|12
operator|||
name|hour
operator|==
literal|0
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QTREASON
operator|+
literal|5
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|hour
operator|==
literal|12
condition|)
name|hour
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'P'
condition|)
block|{
if|if
condition|(
name|hour
operator|>
literal|12
operator|||
name|hour
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|hour
operator|<
literal|12
condition|)
name|hour
operator|+=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|!=
literal|' '
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QTREASON
operator|+
literal|6
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|cp
index|[
literal|13
index|]
operator|==
literal|'D'
condition|)
name|tzoff
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
index|[
literal|13
index|]
operator|==
literal|' '
condition|)
name|tzoff
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|pst
operator|->
name|reason
operator|=
name|QTREASON
operator|+
literal|7
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Adjust for the timezone.  The PST manual is screwy here. 	 * it says the timezone is an integer in the range 0 to 23, 	 * but this doesn't allow us to tell the difference between 	 * +12 and -12.  Assume the 12 hour timezone is west of 	 * GMT. 	 */
if|if
condition|(
name|pst
operator|->
name|timezone
operator|<=
literal|12
condition|)
name|tzoff
operator|+=
name|pst
operator|->
name|timezone
expr_stmt|;
else|else
name|tzoff
operator|-=
operator|(
literal|24
operator|-
name|pst
operator|->
name|timezone
operator|)
expr_stmt|;
comment|/* 	 * Record for posterity 	 */
name|pst
operator|->
name|hour
operator|=
operator|(
name|u_char
operator|)
name|hour
expr_stmt|;
name|pst
operator|->
name|minute
operator|=
operator|(
name|u_char
operator|)
name|minute
expr_stmt|;
name|pst
operator|->
name|second
operator|=
operator|(
name|u_char
operator|)
name|second
expr_stmt|;
name|pst
operator|->
name|millisecond
operator|=
operator|(
name|u_short
operator|)
name|msec
expr_stmt|;
name|pst
operator|->
name|tzoffset
operator|=
operator|(
name|s_char
operator|)
name|tzoff
expr_stmt|;
comment|/* 	 * All that to get the day-hour-minute-second.  Turn this 	 * into the seconds part of a time stamp.  Also use the 	 * milliseconds part directly as the fractional part. 	 */
name|MSUTOTSF
argument_list|(
name|msec
argument_list|,
name|tsclk
operator|->
name|l_uf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clocktime
argument_list|(
operator|(
name|int
operator|)
name|pst
operator|->
name|yearday
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|tzoff
argument_list|,
name|tsrec
operator|->
name|l_ui
argument_list|,
operator|&
name|pst
operator|->
name|yearstart
argument_list|,
operator|&
name|tsclk
operator|->
name|l_ui
argument_list|)
condition|)
block|{
name|pst
operator|->
name|reason
operator|=
name|QTREASON
operator|+
literal|8
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Add in the fudge 	 */
if|if
condition|(
name|pst
operator|->
name|flags
operator|&
name|PST_WWVH
condition|)
name|L_ADDUF
argument_list|(
name|tsclk
argument_list|,
name|wwvh_prop_data
index|[
name|pst
operator|->
name|unit
index|]
operator|.
name|remainder
argument_list|)
expr_stmt|;
else|else
name|L_ADDUF
argument_list|(
name|tsclk
argument_list|,
name|wwv_prop_data
index|[
name|pst
operator|->
name|unit
index|]
operator|.
name|remainder
argument_list|)
expr_stmt|;
comment|/* 	 * Glad that's over with 	 */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * pst_do_event - update our status and report any changes  */
end_comment

begin_function
specifier|static
name|void
name|pst_do_event
parameter_list|(
name|pst
parameter_list|,
name|evnt_code
parameter_list|)
specifier|register
name|struct
name|pstunit
modifier|*
name|pst
decl_stmt|;
name|int
name|evnt_code
decl_stmt|;
block|{
if|if
condition|(
name|pst
operator|->
name|status
operator|!=
operator|(
name|u_char
operator|)
name|evnt_code
condition|)
block|{
name|pst
operator|->
name|status
operator|=
operator|(
name|u_char
operator|)
name|evnt_code
expr_stmt|;
if|if
condition|(
name|evnt_code
operator|!=
name|CEVNT_NOMINAL
condition|)
name|pst
operator|->
name|lastevent
operator|=
operator|(
name|u_char
operator|)
name|evnt_code
expr_stmt|;
comment|/* 		 * Should trap this, but the trap code isn't up to 		 * it yet. 		 */
block|}
block|}
end_function

begin_comment
comment|/*  * pst_process - process the data collected to produce an offset estimate  */
end_comment

begin_function
specifier|static
name|void
name|pst_process
parameter_list|(
name|pst
parameter_list|)
specifier|register
name|struct
name|pstunit
modifier|*
name|pst
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|U_LONG
name|tmp_ui
decl_stmt|;
specifier|register
name|U_LONG
name|tmp_uf
decl_stmt|;
specifier|register
name|U_LONG
name|date_ui
decl_stmt|;
specifier|register
name|U_LONG
name|date_uf
decl_stmt|;
name|u_fp
name|dispersion
decl_stmt|;
name|l_fp
name|off
index|[
name|NPSTSAMPS
index|]
decl_stmt|;
comment|/* 	 * Compute offsets from the raw data.  Sort them into 	 * ascending order. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPSTSAMPS
condition|;
name|i
operator|++
control|)
block|{
name|tmp_ui
operator|=
name|pst
operator|->
name|reftimes
index|[
name|i
index|]
operator|.
name|l_ui
expr_stmt|;
name|tmp_uf
operator|=
name|pst
operator|->
name|reftimes
index|[
name|i
index|]
operator|.
name|l_uf
expr_stmt|;
name|M_SUB
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|,
name|pst
operator|->
name|rectimes
index|[
name|i
index|]
operator|.
name|l_ui
argument_list|,
name|pst
operator|->
name|rectimes
index|[
name|i
index|]
operator|.
name|l_uf
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|i
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
block|{
if|if
condition|(
name|M_ISGEQ
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|,
name|off
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|l_ui
argument_list|,
name|off
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|l_uf
argument_list|)
condition|)
break|break;
name|off
index|[
name|n
index|]
operator|=
name|off
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|off
index|[
name|n
index|]
operator|.
name|l_ui
operator|=
name|tmp_ui
expr_stmt|;
name|off
index|[
name|n
index|]
operator|.
name|l_uf
operator|=
name|tmp_uf
expr_stmt|;
block|}
comment|/* 	 * Reject the furthest from the median until 8 samples left 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|NPSTSAMPS
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|-
name|i
operator|)
operator|>
literal|8
condition|)
block|{
name|tmp_ui
operator|=
name|off
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|l_ui
expr_stmt|;
name|tmp_uf
operator|=
name|off
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|l_uf
expr_stmt|;
name|date_ui
operator|=
name|off
index|[
operator|(
name|n
operator|+
name|i
operator|)
operator|/
literal|2
index|]
operator|.
name|l_ui
expr_stmt|;
name|date_uf
operator|=
name|off
index|[
operator|(
name|n
operator|+
name|i
operator|)
operator|/
literal|2
index|]
operator|.
name|l_uf
expr_stmt|;
name|M_SUB
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|,
name|date_ui
argument_list|,
name|date_uf
argument_list|)
expr_stmt|;
name|M_SUB
argument_list|(
name|date_ui
argument_list|,
name|date_uf
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_ui
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_uf
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_ISHIS
argument_list|(
name|date_ui
argument_list|,
name|date_uf
argument_list|,
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
condition|)
block|{
comment|/* 			 * reject low end 			 */
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * reject high end 			 */
name|n
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * Compute the dispersion based on the difference between the 	 * extremes of the remaining offsets. 	 */
name|tmp_ui
operator|=
name|off
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|l_ui
expr_stmt|;
name|tmp_uf
operator|=
name|off
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|l_uf
expr_stmt|;
name|M_SUB
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_ui
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|dispersion
operator|=
name|MFPTOFP
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
expr_stmt|;
comment|/* 	 * Now compute the offset estimate.  If the sloppy clock 	 * flag is set, average the remainder, otherwise pick the 	 * median. 	 */
if|if
condition|(
name|sloppyclock
index|[
name|pst
operator|->
name|unit
index|]
condition|)
block|{
name|tmp_ui
operator|=
name|tmp_uf
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|M_ADD
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_ui
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|M_RSHIFT
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
expr_stmt|;
name|M_RSHIFT
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
expr_stmt|;
name|M_RSHIFT
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|off
index|[
literal|0
index|]
operator|.
name|l_ui
operator|=
name|tmp_ui
expr_stmt|;
name|off
index|[
literal|0
index|]
operator|.
name|l_uf
operator|=
name|tmp_uf
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
operator|(
name|n
operator|+
name|i
operator|)
operator|/
literal|2
expr_stmt|;
block|}
comment|/* 	 * Add the default PST QT delay into this. 	 */
name|L_ADDUF
argument_list|(
operator|&
name|off
index|[
name|i
index|]
argument_list|,
name|PSTQTFUDGE
argument_list|)
expr_stmt|;
comment|/* 	 * Set the reference ID to the appropriate station 	 */
if|if
condition|(
name|stratumtouse
index|[
name|pst
operator|->
name|unit
index|]
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|pst
operator|->
name|station
operator|>=
literal|0
condition|)
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pst
operator|->
name|peer
operator|->
name|refid
argument_list|,
name|WWVREFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pst
operator|->
name|peer
operator|->
name|refid
argument_list|,
name|WWVHREFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Give the data to the reference clock support code 	 */
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|pst
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|pst
operator|->
name|lastcode
argument_list|)
expr_stmt|;
name|refclock_receive
argument_list|(
name|pst
operator|->
name|peer
argument_list|,
operator|&
name|off
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|dispersion
argument_list|,
operator|&
name|pst
operator|->
name|reftimes
index|[
name|NPSTSAMPS
operator|-
literal|1
index|]
argument_list|,
operator|&
name|pst
operator|->
name|rectimes
index|[
name|NPSTSAMPS
operator|-
literal|1
index|]
argument_list|,
name|pst
operator|->
name|leap
argument_list|)
expr_stmt|;
comment|/* 	 * If the don't-sync flag isn't on, we're nominal. 	 */
if|if
condition|(
name|pst
operator|->
name|leap
operator|==
literal|0
condition|)
name|pst_event
argument_list|(
name|pst
argument_list|,
name|CEVNT_NOMINAL
argument_list|)
expr_stmt|;
name|pst_reset
argument_list|(
name|pst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pst_receive - receive data from a PST clock, call the appropriate  *		 routine to process it, and advance the state.  */
end_comment

begin_function
specifier|static
name|void
name|pst_receive
parameter_list|(
name|rbufp
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
specifier|register
name|struct
name|pstunit
modifier|*
name|pst
decl_stmt|;
specifier|register
name|U_LONG
name|tmp
decl_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|pstunit
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
comment|/* 	 * Process based on the current state. 	 */
switch|switch
condition|(
name|pst
operator|->
name|state
condition|)
block|{
case|case
name|STATE_IDLE
case|:
return|return;
comment|/* Ignore the input */
case|case
name|STATE_QV
case|:
if|if
condition|(
operator|!
name|pst_QV_process
argument_list|(
name|pst
argument_list|,
name|rbufp
argument_list|)
condition|)
block|{
comment|/* 			 * Set the state to idle, but request another 			 * QV poll. 			 */
name|pst
operator|->
name|badformat
operator|++
expr_stmt|;
name|pst_event
argument_list|(
name|pst
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
name|pst
operator|->
name|state
operator|=
name|STATE_IDLE
expr_stmt|;
name|pst
operator|->
name|flags
operator||=
name|PST_DOQV
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This went okay.  Advance the state to 			 * QM and send the request. 			 */
name|pst
operator|->
name|state
operator|=
name|STATE_QM
expr_stmt|;
name|pst_send
argument_list|(
name|pst
argument_list|,
literal|"QM"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|STATE_QM
case|:
if|if
condition|(
operator|!
name|pst_QM_process
argument_list|(
name|pst
argument_list|,
name|rbufp
argument_list|)
condition|)
block|{
comment|/* 			 * Idle us and note the error 			 */
name|pst
operator|->
name|badformat
operator|++
expr_stmt|;
name|pst_event
argument_list|(
name|pst
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
name|pst
operator|->
name|state
operator|=
name|STATE_IDLE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pst
operator|->
name|flags
operator|&
name|PST_NOTIME
condition|)
block|{
comment|/* 			 * Here we aren't getting any time because the 			 * clock is still searching.  Don't bother 			 * looking for anything.  Remove any leap 			 * second hold, however, since this should 			 * ensure the clock is sensible. 			 */
name|pst_event
argument_list|(
name|pst
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
name|pst
operator|->
name|state
operator|=
name|STATE_IDLE
expr_stmt|;
if|if
condition|(
name|pst
operator|->
name|nextsample
operator|>
literal|0
condition|)
name|pst_reset
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* Make sure rate low */
return|return;
block|}
comment|/* 		 * Next is QD.  Do it. 		 */
name|pst
operator|->
name|state
operator|=
name|STATE_QD
expr_stmt|;
name|pst_send
argument_list|(
name|pst
argument_list|,
literal|"QD"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
case|case
name|STATE_QD
case|:
if|if
condition|(
operator|!
name|pst_QD_process
argument_list|(
name|pst
argument_list|,
name|rbufp
argument_list|)
condition|)
block|{
comment|/* 			 * Idle us and note the error 			 */
name|pst
operator|->
name|badformat
operator|++
expr_stmt|;
name|pst_event
argument_list|(
name|pst
argument_list|,
name|CEVNT_BADDATE
argument_list|)
expr_stmt|;
name|pst
operator|->
name|state
operator|=
name|STATE_IDLE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Last step is QT. 			 */
name|pst
operator|->
name|state
operator|=
name|STATE_QT
expr_stmt|;
name|pst_send
argument_list|(
name|pst
argument_list|,
literal|"QT"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|STATE_QT
case|:
name|pst
operator|->
name|state
operator|=
name|STATE_IDLE
expr_stmt|;
if|if
condition|(
operator|!
name|pst_QT_process
argument_list|(
name|pst
argument_list|,
name|rbufp
argument_list|,
operator|&
name|pst
operator|->
name|lastref
argument_list|,
operator|&
name|pst
operator|->
name|lastrec
argument_list|)
condition|)
block|{
comment|/* 			 * Note the error 			 */
name|pst
operator|->
name|baddata
operator|++
expr_stmt|;
name|pst_event
argument_list|(
name|pst
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_receive: unit %d invalid state %d"
argument_list|,
name|pst
operator|->
name|unit
argument_list|,
name|pst
operator|->
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * You may not have noticed this, but the only way we end up 	 * out here is if we've completed polling and have a couple of 	 * valid time stamps.  First see if we should reset the 	 * structure. 	 */
if|if
condition|(
name|pst
operator|->
name|nextsample
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
name|pst
operator|->
name|lastrec
operator|.
name|l_ui
operator|-
name|pst
operator|->
name|rectimes
index|[
literal|0
index|]
operator|.
name|l_ui
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
operator|(
name|U_LONG
operator|)
name|psttab
index|[
name|pst
operator|->
name|nextsample
index|]
operator|.
name|tooold
condition|)
name|pst_reset
argument_list|(
name|pst
argument_list|)
expr_stmt|;
block|}
name|pst
operator|->
name|rectimes
index|[
name|pst
operator|->
name|nextsample
index|]
operator|=
name|pst
operator|->
name|lastrec
expr_stmt|;
name|pst
operator|->
name|reftimes
index|[
name|pst
operator|->
name|nextsample
index|]
operator|=
name|pst
operator|->
name|lastref
expr_stmt|;
name|pst
operator|->
name|nextsample
operator|++
expr_stmt|;
if|if
condition|(
name|pst
operator|->
name|flags
operator|&
name|PST_WWVH
condition|)
name|pst
operator|->
name|station
operator|--
expr_stmt|;
else|else
name|pst
operator|->
name|station
operator|++
expr_stmt|;
if|if
condition|(
name|pst
operator|->
name|flags
operator|&
operator|(
name|PST_SIGFAULT
operator||
name|PST_HARDERR
operator|)
condition|)
block|{
name|pst_event
argument_list|(
name|pst
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
name|pst
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pst
operator|->
name|timesincesync
operator|>
name|freerun
index|[
name|pst
operator|->
name|unit
index|]
condition|)
block|{
name|pst_event
argument_list|(
name|pst
argument_list|,
name|CEVNT_PROP
argument_list|)
expr_stmt|;
name|pst
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
block|}
if|if
condition|(
name|pst
operator|->
name|nextsample
operator|>=
name|NPSTSAMPS
condition|)
name|pst_process
argument_list|(
name|pst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pst_compute_delay - compute appropriate things to tell clock about delays  */
end_comment

begin_function
specifier|static
name|void
name|pst_compute_delay
parameter_list|(
name|prop_delay
parameter_list|,
name|prop_data
parameter_list|)
name|U_LONG
name|prop_delay
decl_stmt|;
name|struct
name|pst_propagate
modifier|*
name|prop_data
decl_stmt|;
block|{
specifier|register
name|int
name|code
decl_stmt|;
specifier|register
name|U_LONG
name|tsf
decl_stmt|;
comment|/* 	 * Convert (truncate) the delay to milliseconds.  Save the 	 * characters needed to send this to the clock and compute 	 * the remainder to be added in later. 	 */
name|code
operator|=
name|tsftomsu
argument_list|(
name|prop_delay
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MSUTOTSF
argument_list|(
name|code
argument_list|,
name|tsf
argument_list|)
expr_stmt|;
name|prop_data
operator|->
name|remainder
operator|=
name|prop_delay
operator|-
name|tsf
expr_stmt|;
if|if
condition|(
name|prop_data
operator|->
name|remainder
operator|&
literal|0x80000000
condition|)
name|prop_data
operator|->
name|remainder
operator|=
literal|0
expr_stmt|;
name|prop_data
operator|->
name|msbchar
operator|=
name|BINTOPST
argument_list|(
operator|(
name|code
operator|>>
literal|2
operator|)
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
name|prop_data
operator|->
name|lsbchar
operator|=
name|BINTOPST
argument_list|(
name|code
operator|&
literal|0x3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pst_control - set fudge factors, return statistics  */
end_comment

begin_function
specifier|static
name|void
name|pst_control
parameter_list|(
name|unit
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|u_int
name|unit
decl_stmt|;
name|struct
name|refclockstat
modifier|*
name|in
decl_stmt|;
name|struct
name|refclockstat
modifier|*
name|out
decl_stmt|;
block|{
specifier|register
name|struct
name|pstunit
modifier|*
name|pst
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_control: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
name|int
name|doqv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME1
condition|)
if|if
condition|(
name|in
operator|->
name|fudgetime1
operator|.
name|l_ui
operator|==
literal|0
operator|&&
name|in
operator|->
name|fudgetime1
operator|.
name|l_uf
operator|<=
name|PSTMAXPROP
condition|)
block|{
name|wwv_prop_delay
index|[
name|unit
index|]
operator|=
name|in
operator|->
name|fudgetime1
expr_stmt|;
name|doqv
operator|=
literal|1
expr_stmt|;
name|pst_compute_delay
argument_list|(
name|wwv_prop_delay
index|[
name|unit
index|]
operator|.
name|l_uf
argument_list|,
operator|&
name|wwv_prop_data
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME2
condition|)
if|if
condition|(
name|in
operator|->
name|fudgetime2
operator|.
name|l_ui
operator|==
literal|0
operator|&&
name|in
operator|->
name|fudgetime2
operator|.
name|l_uf
operator|<=
name|PSTMAXPROP
condition|)
block|{
name|wwvh_prop_delay
index|[
name|unit
index|]
operator|=
name|in
operator|->
name|fudgetime2
expr_stmt|;
name|doqv
operator|=
literal|1
expr_stmt|;
name|pst_compute_delay
argument_list|(
name|wwvh_prop_delay
index|[
name|unit
index|]
operator|.
name|l_uf
argument_list|,
operator|&
name|wwvh_prop_data
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL1
condition|)
block|{
name|stratumtouse
index|[
name|unit
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|in
operator|->
name|fudgeval1
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL2
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|fudgeval2
operator|>
literal|0
operator|&&
name|in
operator|->
name|fudgeval2
operator|<
literal|9990
condition|)
name|freerun
index|[
name|unit
index|]
operator|=
operator|(
name|u_short
operator|)
name|in
operator|->
name|fudgeval2
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG1
condition|)
block|{
name|sloppyclock
index|[
name|unit
index|]
operator|=
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG1
expr_stmt|;
block|}
if|if
condition|(
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
comment|/* 			 * Should actually reselect clock, but 			 * will wait for the next timecode 			 */
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL1
condition|)
block|{
name|pstunits
index|[
name|unit
index|]
operator|->
name|peer
operator|->
name|stratum
operator|=
name|stratumtouse
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|stratumtouse
index|[
name|unit
index|]
operator|>
literal|1
condition|)
name|pstunits
index|[
name|unit
index|]
operator|->
name|peer
operator|->
name|refid
operator|=
name|htonl
argument_list|(
name|PSTHSREFID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG3
operator|)
operator|&&
operator|(
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG3
operator|)
condition|)
block|{
name|pstunits
index|[
name|unit
index|]
operator|->
name|flags
operator||=
name|PST_DORESET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|doqv
operator|||
operator|(
operator|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG2
operator|)
operator|&&
operator|(
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG2
operator|)
operator|)
condition|)
block|{
name|pstunits
index|[
name|unit
index|]
operator|->
name|flags
operator||=
name|PST_DOQV
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|out
operator|!=
literal|0
condition|)
block|{
name|out
operator|->
name|type
operator|=
name|REFCLK_WWV_PST
expr_stmt|;
name|out
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|haveflags
operator|=
name|CLK_HAVETIME1
operator||
name|CLK_HAVETIME2
operator||
name|CLK_HAVEVAL1
operator||
name|CLK_HAVEVAL2
operator||
name|CLK_HAVEFLAG1
expr_stmt|;
name|out
operator|->
name|fudgetime1
operator|=
name|wwv_prop_delay
index|[
name|unit
index|]
expr_stmt|;
name|out
operator|->
name|fudgetime2
operator|=
name|wwvh_prop_delay
index|[
name|unit
index|]
expr_stmt|;
name|out
operator|->
name|fudgeval1
operator|=
operator|(
name|LONG
operator|)
name|stratumtouse
index|[
name|unit
index|]
expr_stmt|;
name|out
operator|->
name|fudgeval2
operator|=
operator|(
name|LONG
operator|)
name|freerun
index|[
name|unit
index|]
expr_stmt|;
name|out
operator|->
name|flags
operator|=
name|sloppyclock
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|pst
operator|=
name|pstunits
index|[
name|unit
index|]
expr_stmt|;
name|out
operator|->
name|clockdesc
operator|=
name|pst
operator|->
name|description
expr_stmt|;
name|out
operator|->
name|lencode
operator|=
name|pst
operator|->
name|lencode
expr_stmt|;
name|out
operator|->
name|lastcode
operator|=
name|pst
operator|->
name|lastcode
expr_stmt|;
name|out
operator|->
name|timereset
operator|=
name|current_time
operator|-
name|pst
operator|->
name|timestarted
expr_stmt|;
name|out
operator|->
name|polls
operator|=
name|pst
operator|->
name|polls
expr_stmt|;
name|out
operator|->
name|noresponse
operator|=
name|pst
operator|->
name|noreply
expr_stmt|;
name|out
operator|->
name|badformat
operator|=
name|pst
operator|->
name|badformat
expr_stmt|;
name|out
operator|->
name|baddata
operator|=
name|pst
operator|->
name|baddata
expr_stmt|;
name|out
operator|->
name|lastevent
operator|=
name|pst
operator|->
name|lastevent
expr_stmt|;
name|out
operator|->
name|currentstatus
operator|=
name|pst
operator|->
name|status
expr_stmt|;
block|}
else|else
block|{
name|out
operator|->
name|clockdesc
operator|=
name|pstdefdesc
expr_stmt|;
name|out
operator|->
name|lencode
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|lastcode
operator|=
literal|""
expr_stmt|;
name|out
operator|->
name|polls
operator|=
name|out
operator|->
name|noresponse
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|badformat
operator|=
name|out
operator|->
name|baddata
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|timereset
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|currentstatus
operator|=
name|out
operator|->
name|lastevent
operator|=
name|CEVNT_NOMINAL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * pst_buginfo - return clock dependent debugging info  */
end_comment

begin_function
specifier|static
name|void
name|pst_buginfo
parameter_list|(
name|unit
parameter_list|,
name|bug
parameter_list|)
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|refclockbug
modifier|*
name|bug
decl_stmt|;
block|{
specifier|register
name|struct
name|pstunit
modifier|*
name|pst
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|bug
operator|->
name|nvalues
operator|=
name|bug
operator|->
name|ntimes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pst_buginfo: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|unitinuse
index|[
name|unit
index|]
condition|)
return|return;
name|pst
operator|=
name|pstunits
index|[
name|unit
index|]
expr_stmt|;
name|bug
operator|->
name|nvalues
operator|=
literal|14
expr_stmt|;
name|bug
operator|->
name|svalues
operator|=
operator|(
literal|1
operator|<<
literal|10
operator|)
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|0
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|pst
operator|->
name|nextsample
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|1
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|pst
operator|->
name|state
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|2
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|pst
operator|->
name|reason
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|3
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|pst
operator|->
name|flags
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|4
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|pst
operator|->
name|yearday
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|5
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|pst
operator|->
name|hour
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|6
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|pst
operator|->
name|minute
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|7
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|pst
operator|->
name|second
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|8
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|pst
operator|->
name|millisecond
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|9
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|pst
operator|->
name|timezone
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|10
index|]
operator|=
call|(
name|U_LONG
call|)
argument_list|(
operator|(
name|LONG
operator|)
name|pst
operator|->
name|tzoffset
argument_list|)
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|11
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|pst
operator|->
name|timesincesync
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|12
index|]
operator|=
name|pst
operator|->
name|yearstart
expr_stmt|;
name|bug
operator|->
name|ntimes
operator|=
operator|(
operator|(
name|NPSTSAMPS
operator|*
literal|2
operator|)
operator|+
literal|2
operator|)
operator|>
name|NCLKBUGTIMES
condition|?
name|NCLKBUGTIMES
else|:
operator|(
operator|(
name|NPSTSAMPS
operator|*
literal|2
operator|)
operator|+
literal|2
operator|)
expr_stmt|;
name|bug
operator|->
name|stimes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|bug
operator|->
name|ntimes
operator|-
literal|2
operator|)
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|bug
operator|->
name|times
index|[
literal|2
operator|*
name|i
index|]
operator|=
name|pst
operator|->
name|rectimes
index|[
name|i
index|]
expr_stmt|;
name|bug
operator|->
name|times
index|[
operator|(
literal|2
operator|*
name|i
operator|)
operator|+
literal|1
index|]
operator|=
name|pst
operator|->
name|reftimes
index|[
name|i
index|]
expr_stmt|;
block|}
name|bug
operator|->
name|times
index|[
name|bug
operator|->
name|ntimes
operator|-
literal|2
index|]
operator|=
name|pst
operator|->
name|lastrec
expr_stmt|;
name|bug
operator|->
name|times
index|[
name|bug
operator|->
name|ntimes
operator|-
literal|1
index|]
operator|=
name|pst
operator|->
name|lastref
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

