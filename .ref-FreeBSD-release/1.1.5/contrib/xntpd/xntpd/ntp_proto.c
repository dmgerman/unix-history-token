begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ntp_proto.c,v 3.1 1993/07/06 01:11:23 jbj Exp  * ntp_proto.c - NTP version 3 protocol machinery  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_comment
comment|/*  * System variables are declared here.  See Section 3.2 of  * the specification.  */
end_comment

begin_decl_stmt
name|u_char
name|sys_leap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system leap indicator */
end_comment

begin_decl_stmt
name|u_char
name|sys_stratum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stratum of system */
end_comment

begin_decl_stmt
name|s_char
name|sys_precision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local clock precision */
end_comment

begin_decl_stmt
name|s_fp
name|sys_rootdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* distance to current sync source */
end_comment

begin_decl_stmt
name|u_fp
name|sys_rootdispersion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dispersion of system clock */
end_comment

begin_decl_stmt
name|U_LONG
name|sys_refid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference source for local clock */
end_comment

begin_decl_stmt
name|l_fp
name|sys_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* combined offset from clock_select */
end_comment

begin_decl_stmt
name|u_fp
name|sys_maxd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dispersion of selected peer */
end_comment

begin_decl_stmt
name|l_fp
name|sys_reftime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time we were last updated */
end_comment

begin_decl_stmt
name|l_fp
name|sys_refskew
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* accumulated skew since last update */
end_comment

begin_decl_stmt
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our current peer */
end_comment

begin_decl_stmt
name|u_char
name|sys_poll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* log2 of desired system poll interval */
end_comment

begin_decl_stmt
specifier|extern
name|LONG
name|sys_clock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* second part of current time - now in systime.c */
end_comment

begin_decl_stmt
name|LONG
name|sys_lastselect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sys_clock at last synch-dist update */
end_comment

begin_comment
comment|/*  * Non-specified system state variables.  */
end_comment

begin_decl_stmt
name|int
name|sys_bclient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we set our time to broadcasts */
end_comment

begin_decl_stmt
name|U_LONG
name|sys_bdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default delay to use for broadcasting */
end_comment

begin_decl_stmt
name|int
name|sys_authenticate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* authenticate time used for syncing */
end_comment

begin_decl_stmt
name|U_LONG
name|sys_authdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ts fraction, time it takes for encrypt() */
end_comment

begin_comment
comment|/*  * Statistics counters  */
end_comment

begin_decl_stmt
name|U_LONG
name|sys_stattime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time when we started recording */
end_comment

begin_decl_stmt
name|U_LONG
name|sys_badstratum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets with invalid incoming stratum */
end_comment

begin_decl_stmt
name|U_LONG
name|sys_oldversionpkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* old version packets received */
end_comment

begin_decl_stmt
name|U_LONG
name|sys_newversionpkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new version packets received */
end_comment

begin_decl_stmt
name|U_LONG
name|sys_unknownversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't know version packets */
end_comment

begin_decl_stmt
name|U_LONG
name|sys_badlength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets with bad length */
end_comment

begin_decl_stmt
name|U_LONG
name|sys_processed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets processed */
end_comment

begin_decl_stmt
name|U_LONG
name|sys_badauth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets dropped because of authorization */
end_comment

begin_decl_stmt
name|U_LONG
name|sys_limitrejected
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pkts rejected due toclient count per net */
end_comment

begin_comment
comment|/*  * Imported from ntp_timer.c  */
end_comment

begin_decl_stmt
specifier|extern
name|U_LONG
name|current_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|event
name|timerqueue
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from ntp_io.c  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|interface
modifier|*
name|any_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from ntp_loopfilter.c  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|pps_control
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|U_LONG
name|pps_update
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The peer hash table.  Imported from ntp_peer.c  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|peer
modifier|*
name|peer_hash
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|peer_hash_count
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * debug flag  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_all
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * transmit - Transmit Procedure.  See Section 3.4.1 of the specification.  */
end_comment

begin_function
name|void
name|transmit
parameter_list|(
name|peer
parameter_list|)
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
comment|/* packet to send */
name|U_LONG
name|peer_timer
decl_stmt|;
if|if
condition|(
operator|(
name|peer
operator|->
name|hmode
operator|!=
name|MODE_BROADCAST
operator|&&
name|peer
operator|->
name|hmode
operator|!=
name|MODE_BCLIENT
operator|)
operator|||
operator|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BROADCAST
operator|&&
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
operator|)
condition|)
block|{
name|U_LONG
name|xkeyid
decl_stmt|;
comment|/* 		 * Figure out which keyid to include in the packet 		 */
if|if
condition|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
operator|)
operator|&&
operator|(
name|peer
operator|->
name|flags
operator|&
operator|(
name|FLAG_CONFIG
operator||
name|FLAG_AUTHENTIC
operator|)
operator|)
operator|&&
name|authhavekey
argument_list|(
name|peer
operator|->
name|keyid
argument_list|)
condition|)
block|{
name|xkeyid
operator|=
name|peer
operator|->
name|keyid
expr_stmt|;
block|}
else|else
block|{
name|xkeyid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Make up a packet to send. 		 */
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|peer
operator|->
name|version
argument_list|,
name|peer
operator|->
name|hmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_stratum
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|sys_rootdelay
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|sys_rootdispersion
operator|+
operator|(
name|FP_SECOND
operator|>>
operator|(
operator|-
operator|(
name|int
operator|)
name|sys_precision
operator|)
operator|)
operator|+
name|LFPTOFP
argument_list|(
operator|&
name|sys_refskew
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|xpkt
operator|.
name|org
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|rec
argument_list|,
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
comment|/* 		 * Decide whether to authenticate or not.  If so, call encrypt() 		 * to fill in the rest of the frame.  If not, just add in the 		 * xmt timestamp and send it quick. 		 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
condition|)
block|{
name|int
name|sendlen
decl_stmt|;
name|xpkt
operator|.
name|keyid
operator|=
name|htonl
argument_list|(
name|xkeyid
argument_list|)
expr_stmt|;
name|auth1crypt
argument_list|(
name|xkeyid
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|L_ADDUF
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
name|sys_authdelay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendlen
operator|=
name|auth2crypt
argument_list|(
name|xkeyid
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
operator|(
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|peer
operator|->
name|dstadr
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
operator|+
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"transmit auth to %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
operator|(
name|peer
operator|->
name|srcadr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Get xmt timestamp, then send it without mac field 			 */
name|get_systime
argument_list|(
operator|&
operator|(
name|peer
operator|->
name|xmt
operator|)
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
operator|(
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|peer
operator|->
name|dstadr
argument_list|,
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"transmit to %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
operator|(
name|peer
operator|->
name|srcadr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|peer
operator|->
name|hmode
operator|!=
name|MODE_BROADCAST
condition|)
block|{
name|u_char
name|opeer_reach
decl_stmt|;
comment|/* 		 * Determine reachability and diddle things if we 		 * haven't heard from the host for a while. 		 */
name|opeer_reach
operator|=
name|peer
operator|->
name|reach
expr_stmt|;
name|peer
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opeer_reach
operator|!=
literal|0
condition|)
name|report_event
argument_list|(
name|EVNT_UNREACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
comment|/* 			 * Clear this guy out.  No need to redo clock 			 * selection since by now this guy won't be a player 			 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
block|{
if|if
condition|(
name|opeer_reach
operator|!=
literal|0
condition|)
block|{
name|peer_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
block|}
block|}
else|else
block|{
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 			 * While we have a chance, if our system peer 			 * is zero or his stratum is greater than the 			 * last known stratum of this guy, make sure 			 * hpoll is clamped to the minimum before 			 * resetting the timer. 			 * If the peer has been unreachable for a while 			 * and we have a system peer who is at least his 			 * equal, we may want to ramp his polling interval 			 * up to avoid the useless traffic. 			 */
if|if
condition|(
name|sys_peer
operator|==
literal|0
operator|||
name|sys_peer
operator|->
name|stratum
operator|>
name|peer
operator|->
name|stratum
condition|)
block|{
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|peer
operator|->
name|unreach
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|peer
operator|->
name|unreach
operator|<
literal|16
condition|)
block|{
name|peer
operator|->
name|unreach
operator|++
expr_stmt|;
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|hpoll
operator|<
name|peer
operator|->
name|maxpoll
condition|)
block|{
name|peer
operator|->
name|hpoll
operator|++
expr_stmt|;
name|peer
operator|->
name|ppoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
block|}
block|}
comment|/* 		 * Update reachability and poll variables 		 */
block|}
elseif|else
if|if
condition|(
operator|(
name|opeer_reach
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
block|{
name|l_fp
name|off
decl_stmt|;
if|if
condition|(
name|peer
operator|->
name|valid
operator|>
literal|0
condition|)
name|peer
operator|->
name|valid
operator|--
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|hpoll
operator|>
name|peer
operator|->
name|minpoll
condition|)
name|peer
operator|->
name|hpoll
operator|--
expr_stmt|;
name|off
operator|.
name|l_ui
operator|=
name|off
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
name|clock_filter
argument_list|(
name|peer
argument_list|,
operator|&
name|off
argument_list|,
operator|(
name|s_fp
operator|)
literal|0
argument_list|,
operator|(
name|u_fp
operator|)
name|NTP_MAXDISPERSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SYSPEER
condition|)
name|clock_select
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|peer
operator|->
name|valid
operator|<
name|NTP_SHIFT
condition|)
block|{
name|peer
operator|->
name|valid
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|peer
operator|->
name|hpoll
operator|<
name|peer
operator|->
name|maxpoll
condition|)
name|peer
operator|->
name|hpoll
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Finally, adjust the hpoll variable for special conditions. 	 */
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BCLIENT
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|ppoll
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SYSPEER
operator|&&
name|peer
operator|->
name|hpoll
operator|>
name|sys_poll
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|max
argument_list|(
name|peer
operator|->
name|minpoll
argument_list|,
name|sys_poll
argument_list|)
expr_stmt|;
comment|/* 	 * Arrange for our next timeout.  hpoll will be less than 	 * maxpoll for sure. 	 */
if|if
condition|(
name|peer
operator|->
name|event_timer
operator|.
name|next
operator|!=
literal|0
condition|)
comment|/* 		 * Oops, someone did already. 		 */
name|TIMER_DEQUEUE
argument_list|(
operator|&
name|peer
operator|->
name|event_timer
argument_list|)
expr_stmt|;
name|peer_timer
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|max
argument_list|(
operator|(
name|u_char
operator|)
name|min
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|)
expr_stmt|;
name|peer
operator|->
name|event_timer
operator|.
name|event_time
operator|=
name|current_time
operator|+
name|peer_timer
expr_stmt|;
name|TIMER_ENQUEUE
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|peer
operator|->
name|event_timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * receive - Receive Procedure.  See section 3.4.2 in the specification.  */
end_comment

begin_function
name|void
name|receive
parameter_list|(
name|rbufp
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
specifier|register
name|u_char
name|hismode
decl_stmt|;
name|int
specifier|restrict
expr_stmt|;
name|int
name|has_mac
decl_stmt|;
name|int
name|trustable
decl_stmt|;
name|int
name|is_authentic
decl_stmt|;
name|U_LONG
name|hiskeyid
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer2
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"receive from %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Let the monitoring software take a look at this first. 	 */
name|monitor
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
comment|/* 	 * Get the restrictions on this guy.  If we're to ignore him, 	 * go no further. 	 */
specifier|restrict
operator|=
name|restrictions
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
if|if
condition|(
specifier|restrict
operator|&
name|RES_IGNORE
condition|)
return|return;
comment|/* 	 * Get a pointer to the packet. 	 */
name|pkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
comment|/* 	 * Catch packets whose version number we can't deal with 	 */
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|>=
name|NTP_VERSION
condition|)
block|{
name|sys_newversionpkt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|>=
name|NTP_OLDVERSION
condition|)
block|{
name|sys_oldversionpkt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sys_unknownversion
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Catch private mode packets.  Dump it if queries not allowed. 	 */
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|MODE_PRIVATE
condition|)
block|{
if|if
condition|(
specifier|restrict
operator|&
name|RES_NOQUERY
condition|)
return|return;
name|process_private
argument_list|(
name|rbufp
argument_list|,
operator|(
operator|(
specifier|restrict
operator|&
name|RES_NOMODIFY
operator|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Same with control mode packets. 	 */
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|MODE_CONTROL
condition|)
block|{
if|if
condition|(
specifier|restrict
operator|&
name|RES_NOQUERY
condition|)
return|return;
name|process_control
argument_list|(
name|rbufp
argument_list|,
specifier|restrict
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * See if we're allowed to serve this guy time.  If not, ignore 	 * him. 	 */
if|if
condition|(
specifier|restrict
operator|&
name|RES_DONTSERVE
condition|)
return|return;
comment|/* 	 * See if we only accept limited number of clients 	 * from the net this guy is from. 	 * Note: the flag is determined dynamically within restrictions() 	 */
if|if
condition|(
specifier|restrict
operator|&
name|RES_LIMITED
condition|)
block|{
specifier|extern
name|U_LONG
name|client_limit
decl_stmt|;
name|sys_limitrejected
operator|++
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"rejected mode %d request from %s - per net client limit (%d) exceeded"
argument_list|,
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|client_limit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Dump anything with a putrid stratum.  These will most likely 	 * come from someone trying to poll us with ntpdc. 	 */
if|if
condition|(
name|pkt
operator|->
name|stratum
operator|>
name|NTP_MAXSTRATUM
condition|)
block|{
name|sys_badstratum
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Find the peer.  This will return a null if this guy 	 * isn't in the database. 	 */
name|peer
operator|=
name|findpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|)
expr_stmt|;
comment|/* 	 * Check the length for validity, drop the packet if it is 	 * not as expected. 	 * 	 * If this is a client mode poll, go no further.  Send back 	 * his time and drop it. 	 * 	 * The scheme we use for authentication is this.  If we are 	 * running in non-authenticated mode, we accept both frames 	 * which are authenticated and frames which aren't, but don't 	 * authenticate.  We do record whether the frame had a mac field 	 * or not so we know what to do on output. 	 * 	 * If we are running in authenticated mode, we only trust frames 	 * which have authentication attached, which are validated and 	 * which are using one of our trusted keys.  We respond to all 	 * other pollers without saving any state.  If a host we are 	 * passively peering with changes his key from a trusted one to 	 * an untrusted one, we immediately unpeer with him, reselect 	 * the clock and treat him as an unmemorable client (this is 	 * a small denial-of-service hole I'll have to think about). 	 * If a similar event occurs with a configured peer we drop the 	 * frame and hope he'll revert to our key again.  If we get a 	 * frame which can't be authenticated with the given key, we 	 * drop it.  Either we disagree on the keys or someone is trying 	 * some funny stuff. 	 */
comment|/* 	 * here we assume that any packet with an authenticator is at 	 * least LEN_PKT_MAC bytes long, which means at least 96 bits 	 */
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|>=
name|LEN_PKT_MAC
condition|)
block|{
name|has_mac
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|LEN_PKT_NOMAC
expr_stmt|;
name|hiskeyid
operator|=
name|ntohl
argument_list|(
name|pkt
operator|->
name|keyid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"receive: pkt is %d octets, mac %d octets long, keyid %d\n"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|,
name|has_mac
argument_list|,
name|hiskeyid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|==
name|LEN_PKT_NOMAC
condition|)
block|{
name|hiskeyid
operator|=
literal|0
expr_stmt|;
name|has_mac
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"receive: bad length %d (not> %d or == %d)\n"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|,
name|LEN_PKT_MAC
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sys_badlength
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Figure out his mode and validate it. 	 */
name|hismode
operator|=
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"receive: his mode %d\n"
argument_list|,
name|hismode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|NTP_OLDVERSION
operator|&&
name|hismode
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Easy.  If it is from the NTP port it is 		 * a sym act, else client. 		 */
if|if
condition|(
name|SRCPORT
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
operator|==
name|NTP_PORT
condition|)
name|hismode
operator|=
name|MODE_ACTIVE
expr_stmt|;
else|else
name|hismode
operator|=
name|MODE_CLIENT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hismode
operator|!=
name|MODE_ACTIVE
operator|&&
name|hismode
operator|!=
name|MODE_PASSIVE
operator|&&
name|hismode
operator|!=
name|MODE_SERVER
operator|&&
name|hismode
operator|!=
name|MODE_CLIENT
operator|&&
name|hismode
operator|!=
name|MODE_BROADCAST
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bad mode %d received from %s"
argument_list|,
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * If he included a mac field, decrypt it to see if it is authentic. 	 */
name|is_authentic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|has_mac
condition|)
block|{
if|if
condition|(
name|authhavekey
argument_list|(
name|hiskeyid
argument_list|)
condition|)
block|{
if|if
condition|(
name|authdecrypt
argument_list|(
name|hiskeyid
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
name|pkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
condition|)
block|{
name|is_authentic
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"receive: authdecrypt succeeds\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|sys_badauth
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"receive: authdecrypt fails\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
comment|/* 	 * If this is someone we don't remember from a previous association, 	 * dispatch him now.  Either we send something back quick, we 	 * ignore him, or we allocate some memory for him and let 	 * him continue. 	 */
if|if
condition|(
name|peer
operator|==
literal|0
condition|)
block|{
name|int
name|mymode
decl_stmt|;
name|mymode
operator|=
name|MODE_PASSIVE
expr_stmt|;
switch|switch
condition|(
name|hismode
condition|)
block|{
case|case
name|MODE_ACTIVE
case|:
comment|/* 			 * See if this guy qualifies as being the least 			 * bit memorable.  If so we keep him around for 			 * later.  If not, send his time quick. 			 */
if|if
condition|(
specifier|restrict
operator|&
name|RES_NOPEER
condition|)
block|{
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
operator|(
name|int
operator|)
name|hismode
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|MODE_PASSIVE
case|:
ifdef|#
directive|ifdef
name|MCAST
comment|/* process the packet to determine the rt-delay */
endif|#
directive|endif
comment|/* MCAST */
case|case
name|MODE_SERVER
case|:
comment|/* 			 * These are obvious errors.  Ignore. 			 */
return|return;
case|case
name|MODE_CLIENT
case|:
comment|/* 			 * Send it back quick and go home. 			 */
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
operator|(
name|int
operator|)
name|hismode
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
return|return;
case|case
name|MODE_BROADCAST
case|:
comment|/* 			 * Sort of a repeat of the above... 			 */
comment|/* 			if ((restrict& RES_NOPEER) || !sys_bclient) 				return; */
name|mymode
operator|=
name|MODE_BCLIENT
expr_stmt|;
break|break;
block|}
comment|/* 		 * Okay, we're going to keep him around.  Allocate him 		 * some memory. 		 */
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|mymode
argument_list|,
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|NTP_MINDPOLL
argument_list|,
name|NTP_MAXPOLL
argument_list|,
literal|0
argument_list|,
name|hiskeyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The only way this can happen is if the 			 * source address looks like a reference 			 * clock.  Since this is an illegal address 			 * this is one of those "can't happen" things. 			 */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"receive() failed to peer with %s, mode %d"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|mymode
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Mark the time of reception 	 */
name|peer
operator|->
name|timereceived
operator|=
name|current_time
expr_stmt|;
comment|/* 	 * If the peer isn't configured, set his keyid and authenable 	 * status based on the packet. 	 */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
condition|)
block|{
if|if
condition|(
name|has_mac
condition|)
block|{
name|peer
operator|->
name|keyid
operator|=
name|hiskeyid
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|FLAG_AUTHENABLE
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|->
name|keyid
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_AUTHENABLE
expr_stmt|;
block|}
block|}
comment|/* 	 * If this message was authenticated properly, note this 	 * in the flags. 	 */
if|if
condition|(
name|is_authentic
condition|)
block|{
name|peer
operator|->
name|flags
operator||=
name|FLAG_AUTHENTIC
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If this guy is authenable, and has been authenticated 		 * in the past, but just failed the authentic test, report 		 * the event. 		 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
operator|&&
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENTIC
condition|)
name|report_event
argument_list|(
name|EVNT_PEERAUTH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_AUTHENTIC
expr_stmt|;
block|}
comment|/* 	 * Determine if this guy is basically trustable. 	 */
if|if
condition|(
specifier|restrict
operator|&
name|RES_DONTTRUST
condition|)
name|trustable
operator|=
literal|0
expr_stmt|;
else|else
name|trustable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sys_authenticate
operator|&&
name|trustable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
operator|||
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
operator|)
condition|)
name|trustable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|has_mac
condition|)
block|{
if|if
condition|(
name|authistrusted
argument_list|(
name|hiskeyid
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_authentic
condition|)
block|{
name|trustable
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|trustable
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|badauth
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Dispose of the packet based on our respective modes.  We 	 * don't drive this with a table, though we probably could. 	 */
switch|switch
condition|(
name|peer
operator|->
name|hmode
condition|)
block|{
case|case
name|MODE_ACTIVE
case|:
case|case
name|MODE_CLIENT
case|:
comment|/* 		 * Active mode associations are configured.  If the data 		 * isn't trustable, ignore it and hope this guy brightens 		 * up.  Else accept any data we get and process it. 		 */
switch|switch
condition|(
name|hismode
condition|)
block|{
case|case
name|MODE_ACTIVE
case|:
case|case
name|MODE_PASSIVE
case|:
case|case
name|MODE_SERVER
case|:
name|process_packet
argument_list|(
name|peer
argument_list|,
name|pkt
argument_list|,
operator|&
operator|(
name|rbufp
operator|->
name|recv_time
operator|)
argument_list|,
name|has_mac
argument_list|,
name|trustable
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_CLIENT
case|:
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_ACTIVE
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|hismode
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
return|return;
case|case
name|MODE_BROADCAST
case|:
comment|/* 			 * No good for us, we want real time. 			 */
break|break;
block|}
break|break;
case|case
name|MODE_PASSIVE
case|:
comment|/* 		 * Passive mode associations are (in the current 		 * implementation) always dynamic.  If we get an 		 * invalid header, break the connection.  I hate 		 * doing this since it seems like a waste.  Oh, well. 		 */
switch|switch
condition|(
name|hismode
condition|)
block|{
case|case
name|MODE_ACTIVE
case|:
if|if
condition|(
name|process_packet
argument_list|(
name|peer
argument_list|,
name|pkt
argument_list|,
operator|&
operator|(
name|rbufp
operator|->
name|recv_time
operator|)
argument_list|,
name|has_mac
argument_list|,
name|trustable
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
operator|(
name|int
operator|)
name|hismode
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MODE_PASSIVE
case|:
case|case
name|MODE_SERVER
case|:
case|case
name|MODE_BROADCAST
case|:
comment|/* 			 * These are errors.  Just ignore the packet. 			 * If he doesn't straighten himself out this 			 * association will eventually be disolved. 			 */
break|break;
case|case
name|MODE_CLIENT
case|:
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|hismode
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|MODE_BCLIENT
case|:
comment|/* 		 * Broadcast client pseudo-mode.  We accept both server 		 * and broadcast data.  Passive mode data is an error. 		 */
switch|switch
condition|(
name|hismode
condition|)
block|{
case|case
name|MODE_ACTIVE
case|:
comment|/* 			 * This guy wants to give us real time when we've 			 * been existing on lousy broadcasts!  Create a 			 * passive mode association and do it that way, 			 * but keep the old one in case the packet turns 			 * out to be bad. 			 */
name|peer2
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_PASSIVE
argument_list|,
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|NTP_MINDPOLL
argument_list|,
name|NTP_MAXPOLL
argument_list|,
literal|0
argument_list|,
name|hiskeyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|process_packet
argument_list|(
name|peer2
argument_list|,
name|pkt
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
name|has_mac
argument_list|,
name|trustable
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Strange situation.  We've been receiving 				 * broadcasts from him which we liked, but 				 * we don't like his active mode stuff. 				 * Keep his old peer structure and send 				 * him some time quickly, we'll figure it 				 * out later. 				 */
name|unpeer
argument_list|(
name|peer2
argument_list|)
expr_stmt|;
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
operator|(
name|int
operator|)
name|hismode
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 				 * Drop the old association 				 */
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_PASSIVE
case|:
break|break;
case|case
name|MODE_SERVER
case|:
case|case
name|MODE_BROADCAST
case|:
name|process_packet
argument_list|(
name|peer
argument_list|,
name|pkt
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
name|has_mac
argument_list|,
name|trustable
argument_list|)
expr_stmt|;
comment|/* 			 * We don't test for invalid headers. 			 * Let him time out. 			 */
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * process_packet - Packet Procedure, a la Section 3.4.3 of the specification.  *	  	    Or almost, at least.  If we're in here we have a reasonable  *		    expectation that we will be having a long term relationship  *		    with this host.  */
end_comment

begin_function
name|int
name|process_packet
parameter_list|(
name|peer
parameter_list|,
name|pkt
parameter_list|,
name|recv_ts
parameter_list|,
name|has_mac
parameter_list|,
name|trustable
parameter_list|)
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
name|l_fp
modifier|*
name|recv_ts
decl_stmt|;
name|int
name|has_mac
decl_stmt|;
name|int
name|trustable
decl_stmt|;
comment|/* used as "valid header" */
block|{
name|U_LONG
name|t23_ui
init|=
literal|0
decl_stmt|,
name|t23_uf
init|=
literal|0
decl_stmt|;
name|U_LONG
name|t10_ui
decl_stmt|,
name|t10_uf
decl_stmt|;
name|s_fp
name|di
decl_stmt|,
name|ei
decl_stmt|,
name|p_dist
decl_stmt|,
name|p_disp
decl_stmt|;
name|l_fp
name|ci
decl_stmt|,
name|p_rec
decl_stmt|,
name|p_xmt
decl_stmt|,
name|p_org
decl_stmt|;
name|int
name|randomize
decl_stmt|;
name|u_char
name|ostratum
decl_stmt|,
name|oreach
decl_stmt|;
name|sys_processed
operator|++
expr_stmt|;
name|peer
operator|->
name|processed
operator|++
expr_stmt|;
name|p_dist
operator|=
name|NTOHS_FP
argument_list|(
name|pkt
operator|->
name|rootdelay
argument_list|)
expr_stmt|;
name|p_disp
operator|=
name|NTOHS_FP
argument_list|(
name|pkt
operator|->
name|rootdispersion
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|rec
argument_list|,
operator|&
name|p_rec
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|xmt
argument_list|,
operator|&
name|p_xmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_BROADCAST
condition|)
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|org
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
else|else
name|p_org
operator|=
name|peer
operator|->
name|rec
expr_stmt|;
name|peer
operator|->
name|rec
operator|=
operator|*
name|recv_ts
expr_stmt|;
name|peer
operator|->
name|flash
operator|=
literal|0
expr_stmt|;
name|randomize
operator|=
name|POLL_RANDOMCHANGE
expr_stmt|;
comment|/* 	 * Test for old or duplicate packets (tests 1 through 3). 	 */
if|if
condition|(
name|L_ISHIS
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|p_xmt
argument_list|)
condition|)
comment|/* count old packets */
name|peer
operator|->
name|oldpkt
operator|++
expr_stmt|;
if|if
condition|(
name|L_ISEQU
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|p_xmt
argument_list|)
condition|)
comment|/* test 1 */
name|peer
operator|->
name|flash
operator||=
name|TEST1
expr_stmt|;
comment|/* duplicate packet */
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_BROADCAST
condition|)
block|{
if|if
condition|(
operator|!
name|L_ISEQU
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|p_org
argument_list|)
condition|)
block|{
comment|/* test 2 */
name|randomize
operator|=
name|POLL_MAKERANDOM
expr_stmt|;
name|peer
operator|->
name|bogusorg
operator|++
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST2
expr_stmt|;
comment|/* bogus packet */
block|}
if|if
condition|(
operator|(
name|p_rec
operator|.
name|l_ui
operator|==
literal|0
operator|&&
name|p_rec
operator|.
name|l_uf
operator|==
literal|0
operator|)
operator|||
operator|(
name|p_org
operator|.
name|l_ui
operator|==
literal|0
operator|&&
name|p_org
operator|.
name|l_uf
operator|==
literal|0
operator|)
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST3
expr_stmt|;
comment|/* unsynchronized */
block|}
else|else
block|{
if|if
condition|(
name|p_org
operator|.
name|l_ui
operator|==
literal|0
operator|&&
name|p_org
operator|.
name|l_uf
operator|==
literal|0
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST3
expr_stmt|;
comment|/* unsynchronized */
block|}
name|peer
operator|->
name|org
operator|=
name|p_xmt
expr_stmt|;
comment|/* reuse byte-swapped pkt->xmt */
name|peer
operator|->
name|ppoll
operator|=
name|pkt
operator|->
name|ppoll
expr_stmt|;
comment|/* 	 * Call poll_update().  This will either start us, if the 	 * association is new, or drop the polling interval if the 	 * association is existing and ppoll has been reduced. 	 */
name|poll_update
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|,
name|randomize
argument_list|)
expr_stmt|;
comment|/* 	 * Test for valid header (tests 5 through 8) 	 */
if|if
condition|(
name|trustable
operator|==
literal|0
condition|)
comment|/* test 5 */
name|peer
operator|->
name|flash
operator||=
name|TEST5
expr_stmt|;
comment|/* authentication failed */
if|if
condition|(
name|PKT_LEAP
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|LEAP_NOTINSYNC
operator|||
comment|/* test 6 */
name|p_xmt
operator|.
name|l_ui
operator|<
name|ntohl
argument_list|(
name|pkt
operator|->
name|reftime
operator|.
name|l_ui
argument_list|)
operator|||
name|p_xmt
operator|.
name|l_ui
operator|>=
operator|(
name|ntohl
argument_list|(
name|pkt
operator|->
name|reftime
operator|.
name|l_ui
argument_list|)
operator|+
name|NTP_MAXAGE
operator|)
condition|)
block|{
name|peer
operator|->
name|seltooold
operator|++
expr_stmt|;
comment|/* test 6 */
name|peer
operator|->
name|flash
operator||=
name|TEST6
expr_stmt|;
comment|/* peer clock unsynchronized */
block|}
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
operator|&&
comment|/* test 7 */
operator|(
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
operator|>=
name|NTP_MAXSTRATUM
operator|||
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
operator|>
name|sys_stratum
operator|)
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST7
expr_stmt|;
comment|/* peer stratum out of bounds */
if|if
condition|(
name|p_dist
operator|>=
name|NTP_MAXDISPERSE
comment|/* test 8 */
operator|||
name|p_dist
operator|<=
operator|(
operator|-
name|NTP_MAXDISPERSE
operator|)
operator|||
name|p_disp
operator|>=
name|NTP_MAXDISPERSE
condition|)
block|{
name|peer
operator|->
name|disttoolarge
operator|++
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST8
expr_stmt|;
comment|/* delay/dispersion too big */
block|}
comment|/* 	 * If the packet header is invalid (tests 5 through 8), exit 	 */
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
operator|(
name|TEST5
operator||
name|TEST6
operator||
name|TEST7
operator||
name|TEST8
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"invalid packet header %s %02x\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Valid header; update our state. 	 */
name|peer
operator|->
name|leap
operator|=
name|PKT_LEAP
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|peer
operator|->
name|pmode
operator|=
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_mac
condition|)
name|peer
operator|->
name|pkeyid
operator|=
name|ntohl
argument_list|(
name|pkt
operator|->
name|keyid
argument_list|)
expr_stmt|;
else|else
name|peer
operator|->
name|pkeyid
operator|=
literal|0
expr_stmt|;
name|ostratum
operator|=
name|peer
operator|->
name|stratum
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|pkt
operator|->
name|precision
expr_stmt|;
name|peer
operator|->
name|rootdelay
operator|=
name|p_dist
expr_stmt|;
name|peer
operator|->
name|rootdispersion
operator|=
name|p_disp
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|pkt
operator|->
name|refid
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|reftime
argument_list|,
operator|&
name|peer
operator|->
name|reftime
argument_list|)
expr_stmt|;
name|oreach
operator|=
name|peer
operator|->
name|reach
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
block|{
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
comment|/* 		 * If this guy was previously unreachable, set his 		 * polling interval to the minimum and reset the 		 * unreach counter. 		 */
name|peer
operator|->
name|unreach
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
block|}
name|peer
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
comment|/* 	 * If running in a normal polled association, calculate the round 	 * trip delay (di) and the clock offset (ci).  We use the equations 	 * (reordered from those in the spec): 	 * 	 * d = (t2 - t3) - (t1 - t0) 	 * c = ((t2 - t3) + (t1 - t0)) / 2 	 * 	 * If running as a broadcast client, these change.  di becomes 	 * equal to two times our broadcast delay, while the offset 	 * becomes equal to: 	 * 	 * c = (t1 - t0) + estbdelay 	 */
name|t10_ui
operator|=
name|p_xmt
operator|.
name|l_ui
expr_stmt|;
comment|/* pkt->xmt == t1 */
name|t10_uf
operator|=
name|p_xmt
operator|.
name|l_uf
expr_stmt|;
name|M_SUB
argument_list|(
name|t10_ui
argument_list|,
name|t10_uf
argument_list|,
name|peer
operator|->
name|rec
operator|.
name|l_ui
argument_list|,
name|peer
operator|->
name|rec
operator|.
name|l_uf
argument_list|)
expr_stmt|;
comment|/*peer->rec==t0*/
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_BROADCAST
condition|)
block|{
name|t23_ui
operator|=
name|p_rec
operator|.
name|l_ui
expr_stmt|;
comment|/* pkt->rec == t2 */
name|t23_uf
operator|=
name|p_rec
operator|.
name|l_uf
expr_stmt|;
name|M_SUB
argument_list|(
name|t23_ui
argument_list|,
name|t23_uf
argument_list|,
name|p_org
operator|.
name|l_ui
argument_list|,
name|p_org
operator|.
name|l_uf
argument_list|)
expr_stmt|;
comment|/*pkt->org==t3*/
block|}
comment|/* now have (t2 - t3) and (t0 - t1).  Calculate (ci), (di) and (ei) */
name|ci
operator|.
name|l_ui
operator|=
name|t10_ui
expr_stmt|;
name|ci
operator|.
name|l_uf
operator|=
name|t10_uf
expr_stmt|;
name|ei
operator|=
operator|(
name|FP_SECOND
operator|>>
operator|(
operator|-
operator|(
name|int
operator|)
name|sys_precision
operator|)
operator|)
expr_stmt|;
comment|/* 	 * If broadcast mode, time of last reception has been fiddled 	 * to p_org, rather than originate timestamp. We use this to 	 * augment dispersion and previously calcuated estbdelay as 	 * the delay. We know NTP_SKEWFACTOR == 16, which accounts for 	 * the simplified ei calculation. 	 */
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|MODE_BROADCAST
condition|)
block|{
name|M_ADDUF
argument_list|(
name|ci
operator|.
name|l_ui
argument_list|,
name|ci
operator|.
name|l_uf
argument_list|,
name|peer
operator|->
name|estbdelay
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|di
operator|=
name|MFPTOFP
argument_list|(
literal|0
argument_list|,
name|peer
operator|->
name|estbdelay
argument_list|)
expr_stmt|;
name|ei
operator|+=
name|peer
operator|->
name|rec
operator|.
name|l_ui
operator|-
name|p_org
operator|.
name|l_ui
expr_stmt|;
block|}
else|else
block|{
name|M_ADD
argument_list|(
name|ci
operator|.
name|l_ui
argument_list|,
name|ci
operator|.
name|l_uf
argument_list|,
name|t23_ui
argument_list|,
name|t23_uf
argument_list|)
expr_stmt|;
name|M_RSHIFT
argument_list|(
name|ci
operator|.
name|l_i
argument_list|,
name|ci
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|M_SUB
argument_list|(
name|t23_ui
argument_list|,
name|t23_uf
argument_list|,
name|t10_ui
argument_list|,
name|t10_uf
argument_list|)
expr_stmt|;
name|di
operator|=
name|MFPTOFP
argument_list|(
name|t23_ui
argument_list|,
name|t23_uf
argument_list|)
expr_stmt|;
name|ei
operator|+=
name|peer
operator|->
name|rec
operator|.
name|l_ui
operator|-
name|p_org
operator|.
name|l_ui
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"offset: %s, delay %s, error %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|ci
argument_list|,
literal|9
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|di
argument_list|,
literal|4
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|ei
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|di
operator|>=
name|NTP_MAXDISPERSE
operator|||
name|di
operator|<=
operator|(
operator|-
name|NTP_MAXDISPERSE
operator|)
operator|||
name|ei
operator|>=
name|NTP_MAXDISPERSE
condition|)
block|{
comment|/* test 4 */
name|peer
operator|->
name|bogusdelay
operator|++
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST4
expr_stmt|;
comment|/* delay/dispersion too big */
block|}
comment|/* 	 * If the packet data is invalid (tests 1 through 4), exit 	 */
if|if
condition|(
name|peer
operator|->
name|flash
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"invalid packet data %s %02x\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If there was a reachability change report it even 		 * though the packet was bogus. 		 */
if|if
condition|(
name|oreach
operator|==
literal|0
condition|)
name|report_event
argument_list|(
name|EVNT_REACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * This one is valid.  Mark it so, give it to clock_filter(), 	 */
name|clock_filter
argument_list|(
name|peer
argument_list|,
operator|&
name|ci
argument_list|,
name|di
argument_list|,
operator|(
name|u_fp
operator|)
name|ei
argument_list|)
expr_stmt|;
comment|/* 	 * If this guy was previously unreachable, report him 	 * reachable. 	 * Note we do this here so that the peer values we return are 	 * the updated ones. 	 */
if|if
condition|(
name|oreach
operator|==
literal|0
condition|)
block|{
name|report_event
argument_list|(
name|EVNT_REACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"proto: peer reach %d\n"
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
comment|/* 	 * Now update the clock. 	 */
name|clock_update
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * clock_update - Clock-update procedure, see section 3.4.5.  */
end_comment

begin_function
name|void
name|clock_update
parameter_list|(
name|peer
parameter_list|)
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
name|u_char
name|oleap
decl_stmt|;
name|u_char
name|ostratum
decl_stmt|;
name|s_fp
name|d
decl_stmt|;
specifier|extern
name|u_char
name|leap_mask
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_update(%s)\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|record_peer_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|,
operator|&
name|peer
operator|->
name|offset
argument_list|,
name|peer
operator|->
name|delay
argument_list|,
name|peer
operator|->
name|dispersion
argument_list|)
expr_stmt|;
comment|/* 	 * Call the clock selection algorithm to see 	 * if this update causes the peer to change. 	 */
name|clock_select
argument_list|()
expr_stmt|;
comment|/* 	 * Quit if this peer isn't the system peer.  Other peers 	 * used in the combined offset are not allowed to set 	 * system variables or update the clock. 	 */
if|if
condition|(
name|peer
operator|!=
name|sys_peer
condition|)
return|return;
comment|/* 	 * Quit if the sys_peer is too far away. 	 */
if|if
condition|(
name|peer
operator|->
name|synch
operator|>=
name|NTP_MAXDISTANCE
condition|)
return|return;
comment|/* 	 * Update the system state 	 */
name|oleap
operator|=
name|sys_leap
expr_stmt|;
name|ostratum
operator|=
name|sys_stratum
expr_stmt|;
comment|/* 	 * get leap value (usually the peer leap unless overridden by local configuration) 	 */
name|sys_leap
operator|=
name|leap_actual
argument_list|(
name|peer
operator|->
name|leap
operator|&
name|leap_mask
argument_list|)
expr_stmt|;
comment|/* 	 * N.B. peer->stratum was guaranteed to be less than 	 * NTP_MAXSTRATUM by the receive procedure. 	 * We assume peer->update == sys_clock because 	 * clock_filter was called right before this function. 	 * If the pps signal is in control, the system variables are 	 * set in the ntp_loopfilter.c module. 	 */
if|if
condition|(
operator|!
name|pps_control
condition|)
block|{
name|sys_stratum
operator|=
name|peer
operator|->
name|stratum
operator|+
literal|1
expr_stmt|;
name|d
operator|=
name|peer
operator|->
name|delay
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
name|sys_rootdelay
operator|=
name|peer
operator|->
name|rootdelay
operator|+
name|d
expr_stmt|;
name|sys_maxd
operator|=
name|peer
operator|->
name|dispersion
operator|+
name|peer
operator|->
name|selectdisp
expr_stmt|;
name|d
operator|=
name|peer
operator|->
name|soffset
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
name|d
operator|+=
name|sys_maxd
expr_stmt|;
if|if
condition|(
operator|!
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
operator|&&
name|d
operator|<
name|NTP_MINDISPERSE
condition|)
name|d
operator|=
name|NTP_MINDISPERSE
expr_stmt|;
name|sys_rootdispersion
operator|=
name|peer
operator|->
name|rootdispersion
operator|+
name|d
expr_stmt|;
block|}
comment|/* 	 * Hack for reference clocks.  Sigh.  This is the 	 * only real silly part, though, so the analogy isn't 	 * bad. 	 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
operator|&&
name|peer
operator|->
name|stratum
operator|==
name|STRATUM_REFCLOCK
condition|)
name|sys_refid
operator|=
name|peer
operator|->
name|refid
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pps_control
condition|)
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sys_refid
argument_list|,
name|PPSREFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|sys_refid
operator|=
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
comment|/* 	 * Report changes.  Note that we never sync to 	 * an unsynchronized host. 	 */
if|if
condition|(
name|oleap
operator|==
name|LEAP_NOTINSYNC
condition|)
name|report_event
argument_list|(
name|EVNT_SYNCCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ostratum
operator|!=
name|sys_stratum
condition|)
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|sys_reftime
operator|=
name|peer
operator|->
name|rec
expr_stmt|;
name|sys_refskew
operator|.
name|l_i
operator|=
literal|0
expr_stmt|;
name|sys_refskew
operator|.
name|l_f
operator|=
name|NTP_SKEWINC
expr_stmt|;
switch|switch
condition|(
name|local_clock
argument_list|(
operator|&
name|sys_offset
argument_list|,
name|peer
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* 		 * Clock is too screwed up.  Just exit for now. 		 */
name|report_event
argument_list|(
name|EVNT_SYSFAULT
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|0
case|:
comment|/* 		 * Clock was slewed.  Continue on normally. 		 */
break|break;
case|case
literal|1
case|:
comment|/* 		 * Clock was stepped.  Clear filter registers 		 * of all peers. 		 */
name|clear_all
argument_list|()
expr_stmt|;
name|leap_process
argument_list|()
expr_stmt|;
comment|/* reset the leap interrupt */
name|sys_leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|sys_refskew
operator|.
name|l_i
operator|=
name|NTP_MAXSKEW
expr_stmt|;
name|sys_refskew
operator|.
name|l_f
operator|=
literal|0
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_CLOCKRESET
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sys_stratum
operator|>
literal|1
condition|)
name|sys_refid
operator|=
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
else|else
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|sys_refid
operator|=
name|peer
operator|->
name|refid
expr_stmt|;
else|else
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sys_refid
argument_list|,
name|PPSREFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * poll_update - update peer poll interval.  See Section 3.4.8 of the spec.  */
end_comment

begin_function
name|void
name|poll_update
parameter_list|(
name|peer
parameter_list|,
name|new_hpoll
parameter_list|,
name|randomize
parameter_list|)
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|unsigned
name|int
name|new_hpoll
decl_stmt|;
name|int
name|randomize
decl_stmt|;
block|{
specifier|register
name|struct
name|event
modifier|*
name|evp
decl_stmt|;
specifier|register
name|U_LONG
name|new_timer
decl_stmt|;
name|u_char
name|newpoll
decl_stmt|,
name|oldpoll
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"poll_update(%s, %d, %d)\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|new_hpoll
argument_list|,
name|randomize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Catch reference clocks here.  The polling interval for a 	 * reference clock is fixed and needn't be maintained by us. 	 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
operator|||
name|peer
operator|->
name|hmode
operator|==
name|MODE_BROADCAST
condition|)
return|return;
comment|/* 	 * This routine * will randomly perturb the new peer.timer if 	 * requested, to try to prevent synchronization with the remote 	 * peer from occuring.  There are three options, based on the 	 * value of randomize: 	 * 	 * POLL_NOTRANDOM - essentially the spec algorithm.  If 	 * peer.timer is greater than the new polling interval, 	 * drop it to the new interval. 	 * 	 * POLL_RANDOMCHANGE - make changes randomly.  If peer.timer 	 * must be changed, based on the comparison about, randomly 	 * perturb the new value of peer.timer. 	 * 	 * POLL_MAKERANDOM - make next interval random.  Calculate 	 * a randomly perturbed poll interval.  If this value is 	 * less that peer.timer, update peer.timer. 	 */
name|oldpoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BCLIENT
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|ppoll
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SYSPEER
operator|)
operator|&&
name|new_hpoll
operator|>
name|sys_poll
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|max
argument_list|(
name|peer
operator|->
name|minpoll
argument_list|,
name|sys_poll
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|new_hpoll
operator|>
name|peer
operator|->
name|maxpoll
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
elseif|else
if|if
condition|(
name|new_hpoll
operator|<
name|peer
operator|->
name|minpoll
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
else|else
name|peer
operator|->
name|hpoll
operator|=
name|new_hpoll
expr_stmt|;
block|}
comment|/* hpoll<= maxpoll for sure */
name|newpoll
operator|=
name|max
argument_list|(
operator|(
name|u_char
operator|)
name|min
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|)
expr_stmt|;
if|if
condition|(
name|randomize
operator|==
name|POLL_MAKERANDOM
operator|||
operator|(
name|randomize
operator|==
name|POLL_RANDOMCHANGE
operator|&&
name|newpoll
operator|!=
name|oldpoll
operator|)
condition|)
name|new_timer
operator|=
operator|(
literal|1
operator|<<
operator|(
name|newpoll
operator|-
literal|1
operator|)
operator|)
operator|+
name|ranp2
argument_list|(
name|newpoll
operator|-
literal|1
argument_list|)
operator|+
name|current_time
expr_stmt|;
else|else
name|new_timer
operator|=
operator|(
literal|1
operator|<<
name|newpoll
operator|)
operator|+
name|current_time
expr_stmt|;
name|evp
operator|=
operator|&
operator|(
name|peer
operator|->
name|event_timer
operator|)
expr_stmt|;
if|if
condition|(
name|evp
operator|->
name|next
operator|==
literal|0
operator|||
name|evp
operator|->
name|event_time
operator|>
name|new_timer
condition|)
block|{
name|TIMER_DEQUEUE
argument_list|(
name|evp
argument_list|)
expr_stmt|;
name|evp
operator|->
name|event_time
operator|=
name|new_timer
expr_stmt|;
name|TIMER_ENQUEUE
argument_list|(
name|timerqueue
argument_list|,
name|evp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * clear_all - clear all peer filter registers.  This is done after  *	       a step change in the time.  */
end_comment

begin_function
specifier|static
name|void
name|clear_all
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
condition|;
name|i
operator|++
control|)
for|for
control|(
name|peer
operator|=
name|peer_hash
index|[
name|i
index|]
init|;
name|peer
operator|!=
literal|0
condition|;
name|peer
operator|=
name|peer
operator|->
name|next
control|)
block|{
comment|/* 			 * We used to drop all unconfigured pollers here. 			 * The problem with doing this is that if your best 			 * time source is unconfigured (there are reasons 			 * for doing this) and you drop him, he may not 			 * get around to polling you for a long time.  Hang 			 * on to everyone, dropping their polling intervals 			 * to the minimum. 			 */
name|peer_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear sys_peer.  We'll sync to one later. 	 */
name|sys_peer
operator|=
literal|0
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clear - clear peer filter registers.  See Section 3.4.7 of the spec.  */
end_comment

begin_function
name|void
name|peer_clear
parameter_list|(
name|peer
parameter_list|)
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clear(%s)\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|CLEAR_TO_ZERO
argument_list|(
name|peer
argument_list|)
argument_list|,
literal|0
argument_list|,
name|LEN_CLEAR_TO_ZERO
argument_list|)
expr_stmt|;
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|peer
operator|->
name|dispersion
operator|=
name|NTP_MAXDISPERSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
name|peer
operator|->
name|filter_error
index|[
name|i
index|]
operator|=
name|NTP_MAXDISPERSE
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|,
name|POLL_RANDOMCHANGE
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
comment|/* 	 * Clear out the selection counters 	 */
name|peer
operator|->
name|candidate
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|select
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|correct
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|was_sane
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Since we have a chance to correct possible funniness in 	 * our selection of interfaces on a multihomed host, do so 	 * by setting us to no particular interface. 	 */
name|peer
operator|->
name|dstadr
operator|=
name|any_interface
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clock_filter - add incoming clock sample to filter register and run  *		  the filter procedure to find the best sample.  */
end_comment

begin_function
name|void
name|clock_filter
parameter_list|(
name|peer
parameter_list|,
name|sample_offset
parameter_list|,
name|sample_delay
parameter_list|,
name|sample_error
parameter_list|)
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|l_fp
modifier|*
name|sample_offset
decl_stmt|;
name|s_fp
name|sample_delay
decl_stmt|;
name|u_fp
name|sample_error
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|ord
decl_stmt|;
specifier|register
name|s_fp
name|sample_distance
decl_stmt|,
name|sample_soffset
decl_stmt|,
name|skew
decl_stmt|;
name|s_fp
name|distance
index|[
name|NTP_SHIFT
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_filter(%s, %s, %s, %s)\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
name|sample_offset
argument_list|,
literal|6
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|sample_delay
argument_list|,
literal|5
argument_list|)
argument_list|,
name|ufptoa
argument_list|(
name|sample_error
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Update sample errors and calculate distances. 	 * We know NTP_SKEWFACTOR == 16 	 */
name|skew
operator|=
name|sys_clock
operator|-
name|peer
operator|->
name|update
expr_stmt|;
name|peer
operator|->
name|update
operator|=
name|sys_clock
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
name|distance
index|[
name|i
index|]
operator|=
name|peer
operator|->
name|filter_error
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|filter_error
index|[
name|i
index|]
operator|<
name|NTP_MAXDISPERSE
condition|)
block|{
name|peer
operator|->
name|filter_error
index|[
name|i
index|]
operator|+=
name|skew
expr_stmt|;
name|distance
index|[
name|i
index|]
operator|+=
operator|(
name|peer
operator|->
name|filter_delay
index|[
name|i
index|]
operator|>>
literal|1
operator|)
expr_stmt|;
block|}
block|}
comment|/* 	 * We keep a sort by distance of the current contents of the 	 * shift registers.  We update this by (1) removing the 	 * register we are going to be replacing from the sort, and 	 * (2) reinserting it based on the new distance value. 	 */
name|ord
operator|=
name|peer
operator|->
name|filter_order
expr_stmt|;
name|sample_distance
operator|=
name|sample_error
operator|+
operator|(
name|sample_delay
operator|>>
literal|1
operator|)
expr_stmt|;
name|sample_soffset
operator|=
name|LFPTOFP
argument_list|(
name|sample_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
operator|-
literal|1
condition|;
name|i
operator|++
control|)
comment|/* find old value */
if|if
condition|(
name|ord
index|[
name|i
index|]
operator|==
name|peer
operator|->
name|filter_nextpt
condition|)
break|break;
for|for
control|(
init|;
name|i
operator|<
name|NTP_SHIFT
operator|-
literal|1
condition|;
name|i
operator|++
control|)
comment|/* i is current, move everything up */
name|ord
index|[
name|i
index|]
operator|=
name|ord
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Here, last slot in ord[] is empty */
if|if
condition|(
name|sample_error
operator|>=
name|NTP_MAXDISPERSE
condition|)
comment|/* 		 * Last slot for this guy. 		 */
name|i
operator|=
name|NTP_SHIFT
operator|-
literal|1
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|u_fp
modifier|*
name|errorp
decl_stmt|;
name|errorp
operator|=
name|peer
operator|->
name|filter_error
expr_stmt|;
comment|/* 		 * Find where he goes in, then shift everyone else down 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|errorp
index|[
name|ord
index|[
name|i
index|]
index|]
operator|>=
name|NTP_MAXDISPERSE
operator|||
name|sample_distance
operator|<=
name|distance
index|[
name|ord
index|[
name|i
index|]
index|]
condition|)
break|break;
for|for
control|(
name|j
operator|=
name|NTP_SHIFT
operator|-
literal|1
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
name|ord
index|[
name|j
index|]
operator|=
name|ord
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|ord
index|[
name|i
index|]
operator|=
name|peer
operator|->
name|filter_nextpt
expr_stmt|;
comment|/* 	 * Got everything in order.  Insert sample in current register 	 * and increment nextpt. 	 */
name|peer
operator|->
name|filter_delay
index|[
name|peer
operator|->
name|filter_nextpt
index|]
operator|=
name|sample_delay
expr_stmt|;
name|peer
operator|->
name|filter_offset
index|[
name|peer
operator|->
name|filter_nextpt
index|]
operator|=
operator|*
name|sample_offset
expr_stmt|;
name|peer
operator|->
name|filter_soffset
index|[
name|peer
operator|->
name|filter_nextpt
index|]
operator|=
name|sample_soffset
expr_stmt|;
name|peer
operator|->
name|filter_error
index|[
name|peer
operator|->
name|filter_nextpt
index|]
operator|=
name|sample_error
expr_stmt|;
name|distance
index|[
name|peer
operator|->
name|filter_nextpt
index|]
operator|=
name|sample_distance
expr_stmt|;
name|peer
operator|->
name|filter_nextpt
operator|++
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|filter_nextpt
operator|>=
name|NTP_SHIFT
condition|)
name|peer
operator|->
name|filter_nextpt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Now compute the dispersion, and assign values to delay and 	 * offset.  If there are no samples in the register, delay and 	 * offset are not touched and dispersion is set to the maximum. 	 */
if|if
condition|(
name|peer
operator|->
name|filter_error
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|>=
name|NTP_MAXDISPERSE
condition|)
block|{
name|peer
operator|->
name|dispersion
operator|=
name|NTP_MAXDISPERSE
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|s_fp
name|d
decl_stmt|;
name|peer
operator|->
name|delay
operator|=
name|peer
operator|->
name|filter_delay
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
name|peer
operator|->
name|offset
operator|=
name|peer
operator|->
name|filter_offset
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
name|peer
operator|->
name|soffset
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|peer
operator|->
name|offset
argument_list|)
expr_stmt|;
name|peer
operator|->
name|dispersion
operator|=
name|peer
operator|->
name|filter_error
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|peer
operator|->
name|filter_error
index|[
name|ord
index|[
name|i
index|]
index|]
operator|>=
name|NTP_MAXDISPERSE
condition|)
name|d
operator|=
name|NTP_MAXDISPERSE
expr_stmt|;
else|else
block|{
name|d
operator|=
name|peer
operator|->
name|filter_soffset
index|[
name|ord
index|[
name|i
index|]
index|]
operator|-
name|peer
operator|->
name|filter_soffset
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|NTP_MAXDISPERSE
condition|)
name|d
operator|=
name|NTP_MAXDISPERSE
expr_stmt|;
block|}
comment|/* 			 * XXX This *knows* NTP_FILTER is 1/2 			 */
name|peer
operator|->
name|dispersion
operator|+=
call|(
name|u_fp
call|)
argument_list|(
name|d
argument_list|)
operator|>>
name|i
expr_stmt|;
block|}
comment|/* 		 * Calculate synchronization distance backdated to 		 * sys_lastselect (clock_select will fix it). 		 * We know NTP_SKEWFACTOR == 16 		 */
name|d
operator|=
name|peer
operator|->
name|delay
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
name|d
operator|+=
name|peer
operator|->
name|rootdelay
expr_stmt|;
name|peer
operator|->
name|synch
operator|=
operator|(
name|d
operator|>>
literal|1
operator|)
operator|+
name|peer
operator|->
name|rootdispersion
operator|+
name|peer
operator|->
name|dispersion
operator|-
operator|(
name|sys_clock
operator|-
name|sys_lastselect
operator|)
expr_stmt|;
block|}
comment|/* 	 * We're done 	 */
block|}
end_function

begin_comment
comment|/*  * clock_select - find the pick-of-the-litter clock  */
end_comment

begin_function
name|void
name|clock_select
parameter_list|()
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|nlist
decl_stmt|,
name|nl3
decl_stmt|;
specifier|register
name|s_fp
name|d
decl_stmt|,
name|e
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|allow
decl_stmt|,
name|found
decl_stmt|,
name|k
decl_stmt|;
comment|/* XXX correct? */
name|s_fp
name|low
init|=
literal|0x7ffffff
decl_stmt|;
name|s_fp
name|high
init|=
literal|0x00000000
decl_stmt|;
name|u_fp
name|synch
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|,
name|error
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|;
name|struct
name|peer
modifier|*
name|osys_peer
decl_stmt|;
specifier|static
name|int
name|list_alloc
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|endpoint
modifier|*
name|endpoint
decl_stmt|;
specifier|static
name|int
modifier|*
name|index
decl_stmt|;
specifier|static
name|struct
name|peer
modifier|*
modifier|*
name|peer_list
decl_stmt|;
specifier|static
name|int
name|endpoint_size
init|=
literal|0
decl_stmt|,
name|index_size
init|=
literal|0
decl_stmt|,
name|peer_list_size
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"clock_select()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nlist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HASH_SIZE
condition|;
name|n
operator|++
control|)
name|nlist
operator|+=
name|peer_hash_count
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
name|list_alloc
condition|)
block|{
if|if
condition|(
name|list_alloc
operator|>
literal|0
condition|)
block|{
name|free
argument_list|(
name|endpoint
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|peer_list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|list_alloc
operator|<
name|nlist
condition|)
block|{
name|list_alloc
operator|+=
literal|5
expr_stmt|;
name|endpoint_size
operator|+=
literal|5
operator|*
literal|3
operator|*
sizeof|sizeof
expr|*
name|endpoint
expr_stmt|;
name|index_size
operator|+=
literal|5
operator|*
literal|3
operator|*
sizeof|sizeof
expr|*
name|index
expr_stmt|;
name|peer_list_size
operator|+=
literal|5
operator|*
sizeof|sizeof
expr|*
name|peer_list
expr_stmt|;
block|}
name|endpoint
operator|=
operator|(
expr|struct
name|endpoint
operator|*
operator|)
name|emalloc
argument_list|(
name|endpoint_size
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|int
operator|*
operator|)
name|emalloc
argument_list|(
name|index_size
argument_list|)
expr_stmt|;
name|peer_list
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
name|peer_list_size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This first chunk of code is supposed to go through all 	 * peers we know about to find the NTP_MAXLIST peers which 	 * are most likely to succeed.  We run through the list 	 * doing the sanity checks and trying to insert anyone who 	 * looks okay.  We are at all times aware that we should 	 * only keep samples from the top two strata and we only need 	 * NTP_MAXLIST of them. 	 */
name|nlist
operator|=
name|nl3
operator|=
literal|0
expr_stmt|;
comment|/* none yet */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HASH_SIZE
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|peer
operator|=
name|peer_hash
index|[
name|n
index|]
init|;
name|peer
operator|!=
literal|0
condition|;
name|peer
operator|=
name|peer
operator|->
name|next
control|)
block|{
comment|/* 			 * Clear peer selection stats 			 */
name|peer
operator|->
name|was_sane
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|correct
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|candidate
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|select
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_SYSPEER
expr_stmt|;
comment|/* 			 * Update synch distance (NTP_SKEWFACTOR == 16) 			 */
name|peer
operator|->
name|synch
operator|+=
operator|(
name|sys_clock
operator|-
name|sys_lastselect
operator|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
continue|continue;
comment|/* unreachable */
if|if
condition|(
name|peer
operator|->
name|stratum
operator|>
literal|1
operator|&&
name|peer
operator|->
name|refid
operator|==
name|peer
operator|->
name|dstadr
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
continue|continue;
comment|/* sync loop */
if|if
condition|(
name|peer
operator|->
name|stratum
operator|>=
name|NTP_MAXSTRATUM
operator|||
name|peer
operator|->
name|stratum
operator|>
name|sys_stratum
condition|)
continue|continue;
comment|/* bad stratum  */
if|if
condition|(
name|peer
operator|->
name|dispersion
operator|>=
name|NTP_MAXDISPERSE
condition|)
block|{
name|peer
operator|->
name|seldisptoolarge
operator|++
expr_stmt|;
continue|continue;
comment|/* too noisy or broken */
block|}
if|if
condition|(
name|peer
operator|->
name|org
operator|.
name|l_ui
operator|<
name|peer
operator|->
name|reftime
operator|.
name|l_ui
condition|)
block|{
name|peer
operator|->
name|selbroken
operator|++
expr_stmt|;
continue|continue;
comment|/* very broken host */
block|}
comment|/* 			 * This one seems sane. 			 */
name|peer
operator|->
name|was_sane
operator|=
literal|1
expr_stmt|;
name|peer_list
index|[
name|nlist
operator|++
index|]
operator|=
name|peer
expr_stmt|;
comment|/* 			 * Insert each interval endpoint on the sorted list. 			 */
name|e
operator|=
name|peer
operator|->
name|soffset
operator|+
name|peer
operator|->
name|synch
expr_stmt|;
comment|/* Upper end */
for|for
control|(
name|i
operator|=
name|nl3
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|index
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|index
index|[
name|i
index|]
expr_stmt|;
block|}
name|index
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
literal|1
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
name|e
operator|-=
name|peer
operator|->
name|synch
expr_stmt|;
comment|/* Center point */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|index
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|index
index|[
name|i
index|]
expr_stmt|;
block|}
name|index
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
name|e
operator|-=
name|peer
operator|->
name|synch
expr_stmt|;
comment|/* Lower end */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|index
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|index
index|[
name|i
index|]
expr_stmt|;
block|}
name|index
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
operator|-
literal|1
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
block|}
block|}
name|sys_lastselect
operator|=
name|sys_clock
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl3
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"select: endpoint %2d %s\n"
argument_list|,
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|type
argument_list|,
name|fptoa
argument_list|(
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|val
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|nl3
operator|-
literal|1
expr_stmt|;
name|allow
operator|=
name|nlist
expr_stmt|;
comment|/* falsetickers assumed */
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|allow
operator|>
literal|0
condition|)
block|{
name|allow
operator|--
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|i
operator|<=
name|j
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|+=
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|type
operator|==
literal|0
condition|)
name|found
operator|++
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|i
operator|<=
name|j
condition|;
name|j
operator|--
control|)
block|{
name|n
operator|+=
name|endpoint
index|[
name|index
index|[
name|j
index|]
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|endpoint
index|[
name|index
index|[
name|j
index|]
index|]
operator|.
name|type
operator|==
literal|0
condition|)
name|found
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|>
name|allow
condition|)
break|break;
name|low
operator|=
name|endpoint
index|[
name|index
index|[
name|i
operator|++
index|]
index|]
operator|.
name|val
expr_stmt|;
name|high
operator|=
name|endpoint
index|[
name|index
index|[
name|j
operator|--
index|]
index|]
operator|.
name|val
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|allow
operator|<<
literal|1
operator|)
operator|>=
name|nlist
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_select: no intersection\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_peer
operator|!=
literal|0
condition|)
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|sys_peer
operator|=
literal|0
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"select: low %s high %s\n"
argument_list|,
name|fptoa
argument_list|(
name|low
argument_list|,
literal|6
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|high
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Clustering algorithm. Process intersection list to discard 	 * outlyers. First, construct candidate list in cluster order. 	 * Cluster order is determined by the sum of peer 	 * synchronization distance plus scaled stratum. 	 */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|soffset
operator|<
name|low
operator|||
name|high
operator|<
name|peer
operator|->
name|soffset
condition|)
continue|continue;
name|peer
operator|->
name|correct
operator|=
literal|1
expr_stmt|;
name|d
operator|=
name|peer
operator|->
name|synch
operator|+
operator|(
operator|(
name|U_LONG
operator|)
name|peer
operator|->
name|stratum
operator|<<
name|NTP_DISPFACTOR
operator|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|NTP_MAXCLOCK
condition|)
block|{
if|if
condition|(
name|d
operator|>=
name|synch
index|[
name|j
operator|-
literal|1
index|]
condition|)
continue|continue;
else|else
name|j
operator|--
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|j
init|;
name|k
operator|>
literal|0
condition|;
name|k
operator|--
control|)
block|{
if|if
condition|(
name|d
operator|>=
name|synch
index|[
name|k
operator|-
literal|1
index|]
condition|)
break|break;
name|synch
index|[
name|k
index|]
operator|=
name|synch
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
name|peer_list
index|[
name|k
index|]
operator|=
name|peer_list
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|peer_list
index|[
name|k
index|]
operator|=
name|peer
expr_stmt|;
name|synch
index|[
name|k
index|]
operator|=
name|d
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|nlist
operator|=
name|j
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"select: candidate %s cdist %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer_list
index|[
name|i
index|]
operator|->
name|srcadr
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|synch
index|[
name|i
index|]
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Now, prune outlyers by root dispersion. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
name|peer
operator|->
name|candidate
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|error
index|[
name|i
index|]
operator|=
name|peer_list
index|[
name|i
index|]
operator|->
name|rootdispersion
operator|+
name|peer_list
index|[
name|i
index|]
operator|->
name|dispersion
operator|+
operator|(
name|sys_clock
operator|-
name|peer_list
index|[
name|i
index|]
operator|->
name|update
operator|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|u_fp
name|maxd
init|=
literal|0
decl_stmt|;
name|e
operator|=
name|error
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
name|i
operator|=
name|nlist
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|u_fp
name|sdisp
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
name|nlist
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|d
operator|=
name|peer_list
index|[
name|i
index|]
operator|->
name|soffset
operator|-
name|peer_list
index|[
name|j
index|]
operator|->
name|soffset
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
name|sdisp
operator|+=
name|d
expr_stmt|;
name|sdisp
operator|=
operator|(
operator|(
name|sdisp
operator|>>
literal|1
operator|)
operator|+
name|sdisp
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
name|peer_list
index|[
name|i
index|]
operator|->
name|selectdisp
operator|=
name|sdisp
expr_stmt|;
if|if
condition|(
name|sdisp
operator|>
name|maxd
condition|)
block|{
name|maxd
operator|=
name|sdisp
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|error
index|[
name|i
index|]
operator|<
name|e
condition|)
name|e
operator|=
name|error
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|nlist
operator|<=
name|NTP_MINCLOCK
operator|||
name|maxd
operator|<=
name|e
operator|||
name|peer_list
index|[
name|k
index|]
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
break|break;
for|for
control|(
name|j
operator|=
name|k
operator|+
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
block|{
name|peer_list
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|peer_list
index|[
name|j
index|]
expr_stmt|;
name|error
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|error
index|[
name|j
index|]
expr_stmt|;
block|}
name|nlist
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"select: survivor %s offset %s, cdist %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer_list
index|[
name|i
index|]
operator|->
name|srcadr
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|peer_list
index|[
name|i
index|]
operator|->
name|offset
argument_list|,
literal|6
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|synch
index|[
name|i
index|]
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * What remains is a list of less than NTP_MINCLOCK peers. 	 * First record their order, then choose a peer.  If the 	 * head of the list has a lower stratum than sys_peer 	 * choose him right off.  If not, see if sys_peer is in 	 * the list.  If so, keep him.  If not, take the top of 	 * the list anyway. Also, clamp the polling intervals. 	 */
name|osys_peer
operator|=
name|sys_peer
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nlist
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|peer_list
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
name|sys_peer
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
name|peer_list
index|[
name|i
index|]
operator|->
name|select
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|peer_list
index|[
name|i
index|]
operator|->
name|flags
operator||=
name|FLAG_SYSPEER
expr_stmt|;
name|poll_update
argument_list|(
name|peer_list
index|[
name|i
index|]
argument_list|,
name|peer_list
index|[
name|i
index|]
operator|->
name|hpoll
argument_list|,
name|POLL_RANDOMCHANGE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sys_peer
operator|==
literal|0
operator|||
name|sys_peer
operator|->
name|stratum
operator|>
name|peer_list
index|[
literal|0
index|]
operator|->
name|stratum
condition|)
block|{
name|sys_peer
operator|=
name|peer_list
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|peer_list
index|[
name|i
index|]
operator|==
name|sys_peer
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|nlist
condition|)
name|sys_peer
operator|=
name|peer_list
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* 	 * If we got a new system peer from all of this, report the event. 	 */
if|if
condition|(
name|osys_peer
operator|!=
name|sys_peer
condition|)
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Combine the offsets of the survivors to form a weighted 	 * offset. 	 */
name|clock_combine
argument_list|(
name|peer_list
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clock_combine - combine offsets from selected peers  *  * Note: this routine uses only those peers at the lowest stratum.  * Strictly speaking, this is at variance with the spec.  */
end_comment

begin_function
name|void
name|clock_combine
parameter_list|(
name|peers
parameter_list|,
name|npeers
parameter_list|)
name|struct
name|peer
modifier|*
modifier|*
name|peers
decl_stmt|;
name|int
name|npeers
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|u_fp
name|a
decl_stmt|,
name|b
decl_stmt|,
name|d
decl_stmt|;
name|u_fp
name|synch
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|;
name|l_fp
name|coffset
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|;
name|l_fp
name|diff
decl_stmt|;
comment|/* 	 * Sort peers by cluster distance as in the outlyer algorithm. If 	 * the preferred peer is found, use its offset only. 	 */
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npeers
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|peers
index|[
name|i
index|]
operator|->
name|stratum
operator|>
name|sys_peer
operator|->
name|stratum
condition|)
continue|continue;
if|if
condition|(
name|peers
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
block|{
name|sys_offset
operator|=
name|peers
index|[
name|i
index|]
operator|->
name|offset
expr_stmt|;
name|pps_update
operator|=
name|current_time
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"combine: prefer offset %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|sys_offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|d
operator|=
name|peers
index|[
name|i
index|]
operator|->
name|synch
expr_stmt|;
for|for
control|(
name|j
operator|=
name|k
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|synch
index|[
name|j
operator|-
literal|1
index|]
operator|<=
name|d
condition|)
break|break;
name|synch
index|[
name|j
index|]
operator|=
name|synch
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|coffset
index|[
name|j
index|]
operator|=
name|coffset
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|synch
index|[
name|j
index|]
operator|=
name|d
expr_stmt|;
name|coffset
index|[
name|j
index|]
operator|=
name|peers
index|[
name|i
index|]
operator|->
name|offset
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
comment|/* 	 * Succesively combine the two offsets with the highest 	 * distance and enter the result into the sorted list. 	 */
for|for
control|(
name|i
operator|=
name|k
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* 		 * The possible weights for the most distant offset 		 * are 1/2, 1/4, 1/8 and zero. We combine the synch 		 * distances as if they were variances of the offsets; 		 * the given weights allow us to stay within 16/15 of 		 * the optimum combined variance at each step, and 		 * within 8/7 on any series. 		 * 		 * The breakeven points for the weigths are found 		 * where the smaller distance is 3/8, 3/16 and 1/16 		 * of the sum, respectively. 		 */
name|d
operator|=
name|synch
index|[
name|i
index|]
expr_stmt|;
name|a
operator|=
operator|(
name|d
operator|+
name|synch
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* (d1+d2)/4 */
name|b
operator|=
name|a
operator|>>
literal|1
expr_stmt|;
comment|/* (d1+d2)/8 */
if|if
condition|(
name|d
operator|<=
operator|(
name|b
operator|>>
literal|1
operator|)
condition|)
comment|/* d1<= (d1+d2)/16 */
comment|/* 			 * Below 1/16, no combination is done, 			 * we just drop the distant offset. 			 */
continue|continue;
comment|/* 		 * The offsets are combined by shifting their 		 * difference the appropriate number of times and 		 * adding it back in. 		 */
name|diff
operator|=
name|coffset
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|coffset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|L_RSHIFT
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|a
operator|+
name|b
condition|)
block|{
comment|/* d1>= 3(d1+d2)/8 */
comment|/* 			 * Above 3/8, the weight is 1/2, and the 			 * combined distance is (d1+d2)/4 			 */
name|d
operator|=
name|a
expr_stmt|;
block|}
else|else
block|{
name|a
operator|>>=
literal|2
expr_stmt|;
comment|/* (d1+d2)/16 */
name|L_RSHIFT
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|a
operator|+
name|b
condition|)
block|{
comment|/* d1>= 3(d1+d2)/16 */
comment|/* 				 * Between 3/16 and 3/8, the weight 				 * is 1/4, and the combined distance 				 * is (9d1+d2)/16 = d1/2 + (d1+d2)/16 				 */
name|d
operator|=
operator|(
name|d
operator|>>
literal|1
operator|)
operator|+
name|a
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Between 1/16 and 3/16, the weight 				 * is 1/8, and the combined distance 				 * is (49d1+d2)/64 = 3d1/4+(d1+d2)/64 				 * (We know d> a, so the shift is safe). 				 */
name|L_RSHIFT
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
name|d
operator|-=
operator|(
name|d
operator|-
name|a
operator|)
operator|>>
literal|2
expr_stmt|;
block|}
block|}
comment|/* 		 * Now we can make the combined offset and insert it 		 * in the list. 		 */
name|L_ADD
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|coffset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|d
operator|>=
name|synch
index|[
name|j
operator|-
literal|1
index|]
condition|)
break|break;
name|synch
index|[
name|j
index|]
operator|=
name|synch
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|coffset
index|[
name|j
index|]
operator|=
name|coffset
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|synch
index|[
name|j
index|]
operator|=
name|d
expr_stmt|;
name|coffset
index|[
name|j
index|]
operator|=
name|diff
expr_stmt|;
block|}
comment|/* 	 * The result is put where clock_update() can find it. 	 */
name|sys_offset
operator|=
name|coffset
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"combine: offset %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|sys_offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * fast_xmit - fast path send for stateless (non-)associations  */
end_comment

begin_function
name|void
name|fast_xmit
parameter_list|(
name|rbufp
parameter_list|,
name|rmode
parameter_list|,
name|authentic
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
name|int
name|rmode
decl_stmt|;
name|int
name|authentic
decl_stmt|;
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
specifier|register
name|struct
name|pkt
modifier|*
name|rpkt
decl_stmt|;
name|u_char
name|xmode
decl_stmt|;
name|u_short
name|xkey
init|=
literal|0
decl_stmt|;
name|int
name|docrypt
init|=
literal|0
decl_stmt|;
name|l_fp
name|xmt_ts
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"fast_xmit(%s, %d)\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|rmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Make up new packet and send it quick 	 */
name|rpkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
if|if
condition|(
name|rmode
operator|==
name|MODE_ACTIVE
condition|)
name|xmode
operator|=
name|MODE_PASSIVE
expr_stmt|;
else|else
name|xmode
operator|=
name|MODE_SERVER
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|>=
name|LEN_PKT_MAC
condition|)
block|{
name|docrypt
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|LEN_PKT_NOMAC
expr_stmt|;
if|if
condition|(
name|authentic
condition|)
name|xkey
operator|=
name|ntohl
argument_list|(
name|rpkt
operator|->
name|keyid
argument_list|)
expr_stmt|;
block|}
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_stratum
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|max
argument_list|(
name|NTP_MINPOLL
argument_list|,
name|rpkt
operator|->
name|ppoll
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|sys_rootdelay
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|sys_rootdispersion
operator|+
operator|(
name|FP_SECOND
operator|>>
operator|(
operator|-
operator|(
name|int
operator|)
name|sys_precision
operator|)
operator|)
operator|+
name|LFPTOFP
argument_list|(
operator|&
name|sys_refskew
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|org
operator|=
name|rpkt
operator|->
name|xmt
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
comment|/* 	 * If we are encrypting, do it.  Else don't.  Easy. 	 */
if|if
condition|(
name|docrypt
condition|)
block|{
name|int
name|maclen
decl_stmt|;
name|xpkt
operator|.
name|keyid
operator|=
name|htonl
argument_list|(
name|xkey
argument_list|)
expr_stmt|;
name|auth1crypt
argument_list|(
name|xkey
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|L_ADDUF
argument_list|(
operator|&
name|xmt_ts
argument_list|,
name|sys_authdelay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|maclen
operator|=
name|auth2crypt
argument_list|(
name|xkey
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
operator|+
name|maclen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Get xmt timestamp, then send it without mac field 		 */
name|get_systime
argument_list|(
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the precision of the system clock by watching how the current time  * changes as we read it repeatedly.  *  * struct timeval is only good to 1us, which may cause problems as machines  * get faster, but until then the logic goes:  *  * If a machine has precision (i.e. accurate timing info)> 1us, then it will  * probably use the "unused" low order bits as a counter (to force time to be  * a strictly increaing variable), incrementing it each time any process  * requests the time [[ or maybe time will stand still ? ]].  *  * SO: the logic goes:  *  *	IF	the difference from the last time is "small" (< MINSTEP)  *	THEN	this machine is "counting" with the low order bits  *	ELIF	this is not the first time round the loop  *	THEN	this machine *WAS* counting, and has now stepped  *	ELSE	this machine has precision< time to read clock  *  * SO: if it exits on the first loop, assume "full accuracy" (1us)  *     otherwise, take the log2(observered difference, rounded UP)  *  * MINLOOPS> 1 ensures that even if there is a STEP between the initial call  * and the first loop, it doesn't stop too early.  * Making it even greater allows MINSTEP to be reduced, assuming that the  * chance of MINSTEP-1 other processes getting in and calling gettimeofday  * between this processes's calls.  * Reducing MINSTEP may be necessary as this sets an upper bound for the time  * to actually call gettimeofday.  */
end_comment

begin_define
define|#
directive|define
name|DUSECS
value|1000000
end_define

begin_comment
comment|/* us's as returned by gettime */
end_comment

begin_define
define|#
directive|define
name|HUSECS
value|(1024*1024)
end_define

begin_comment
comment|/* Hex us's -- used when shifting etc */
end_comment

begin_define
define|#
directive|define
name|MINSTEP
value|5
end_define

begin_comment
comment|/* some systems increment uS on each call */
end_comment

begin_comment
comment|/* Don't use "1" as some *other* process may read too*/
end_comment

begin_comment
comment|/*We assume no system actually *ANSWERS* in this time*/
end_comment

begin_define
define|#
directive|define
name|MAXLOOPS
value|DUSECS
end_define

begin_comment
comment|/* if no STEP in a complete second, then FAST machine*/
end_comment

begin_define
define|#
directive|define
name|MINLOOPS
value|2
end_define

begin_comment
comment|/* ensure at least this many loops */
end_comment

begin_function
name|int
name|default_get_precision
parameter_list|()
block|{
name|struct
name|timeval
name|tp
decl_stmt|;
name|struct
name|timezone
name|tzp
decl_stmt|;
name|long
name|last
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|diff
decl_stmt|;
name|long
name|val
decl_stmt|;
name|int
name|minsteps
init|=
literal|2
decl_stmt|;
comment|/* need at least this many steps */
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
expr_stmt|;
name|last
operator|=
name|tp
operator|.
name|tv_usec
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
operator|--
name|minsteps
init|;
name|i
operator|<
name|MAXLOOPS
condition|;
name|i
operator|++
control|)
block|{
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
expr_stmt|;
name|diff
operator|=
name|tp
operator|.
name|tv_usec
operator|-
name|last
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|+=
name|DUSECS
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|MINSTEP
condition|)
if|if
condition|(
name|minsteps
operator|--
operator|<=
literal|0
condition|)
break|break;
name|last
operator|=
name|tp
operator|.
name|tv_usec
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"precision calculation given %dus after %d loop%s"
argument_list|,
name|diff
argument_list|,
name|i
argument_list|,
operator|(
name|i
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|diff
operator|=
operator|(
name|diff
operator|*
literal|3
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* round it up 1.5 is approx sqrt(2) */
if|if
condition|(
name|i
operator|>=
name|MAXLOOPS
condition|)
name|diff
operator|=
literal|1
expr_stmt|;
comment|/* No STEP, so FAST machine */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|diff
operator|=
literal|1
expr_stmt|;
comment|/* time to read clock>= precision */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|val
operator|=
name|HUSECS
init|;
name|val
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|val
operator|>>=
literal|1
control|)
if|if
condition|(
name|diff
operator|>=
name|val
condition|)
return|return
name|i
return|;
return|return
name|DEFAULT_SYS_PRECISION
comment|/* Something's BUST, so lie ! */
return|;
block|}
end_function

begin_comment
comment|/*  * init_proto - initialize the protocol module's data  */
end_comment

begin_function
name|void
name|init_proto
parameter_list|()
block|{
name|l_fp
name|dummy
decl_stmt|;
comment|/* 	 * Fill in the sys_* stuff.  Default is don't listen 	 * to broadcasting, don't authenticate. 	 */
name|sys_leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|sys_precision
operator|=
operator|(
name|s_char
operator|)
name|default_get_precision
argument_list|()
expr_stmt|;
name|sys_rootdelay
operator|=
literal|0
expr_stmt|;
name|sys_rootdispersion
operator|=
literal|0
expr_stmt|;
name|sys_refid
operator|=
literal|0
expr_stmt|;
name|sys_reftime
operator|.
name|l_ui
operator|=
name|sys_reftime
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
name|sys_refskew
operator|.
name|l_i
operator|=
name|NTP_MAXSKEW
expr_stmt|;
name|sys_refskew
operator|.
name|l_f
operator|=
literal|0
expr_stmt|;
name|sys_peer
operator|=
literal|0
expr_stmt|;
name|sys_poll
operator|=
name|NTP_MINPOLL
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|sys_lastselect
operator|=
name|sys_clock
expr_stmt|;
name|sys_bclient
operator|=
literal|0
expr_stmt|;
name|sys_bdelay
operator|=
name|DEFBROADDELAY
expr_stmt|;
name|sys_authenticate
operator|=
literal|0
expr_stmt|;
name|sys_stattime
operator|=
literal|0
expr_stmt|;
name|sys_badstratum
operator|=
literal|0
expr_stmt|;
name|sys_oldversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_newversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_badlength
operator|=
literal|0
expr_stmt|;
name|sys_unknownversion
operator|=
literal|0
expr_stmt|;
name|sys_processed
operator|=
literal|0
expr_stmt|;
name|sys_badauth
operator|=
literal|0
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"default precision is initialized to 2**%d"
argument_list|,
name|sys_precision
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * proto_config - configure the protocol module  */
end_comment

begin_function
name|void
name|proto_config
parameter_list|(
name|item
parameter_list|,
name|value
parameter_list|)
name|int
name|item
decl_stmt|;
name|U_LONG
name|value
decl_stmt|;
block|{
comment|/* 	 * Figure out what he wants to change, then do it 	 */
switch|switch
condition|(
name|item
condition|)
block|{
case|case
name|PROTO_BROADCLIENT
case|:
comment|/* 		 * Turn on/off facility to listen to broadcasts 		 */
name|sys_bclient
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|io_setbclient
argument_list|()
expr_stmt|;
else|else
name|io_unsetbclient
argument_list|()
expr_stmt|;
break|break;
case|case
name|PROTO_MULTICAST_ADD
case|:
comment|/* 		 * Add multicast group address 		 */
if|if
condition|(
operator|!
name|sys_bclient
condition|)
block|{
name|sys_bclient
operator|=
literal|1
expr_stmt|;
name|io_setbclient
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MCAST
name|io_multicast_add
argument_list|(
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MCAST */
break|break;
case|case
name|PROTO_MULTICAST_DEL
case|:
comment|/* 		 * Delete multicast group address 		 */
ifdef|#
directive|ifdef
name|MCAST
name|io_multicast_del
argument_list|(
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MCAST */
break|break;
case|case
name|PROTO_PRECISION
case|:
comment|/* 		 * Set system precision 		 */
name|sys_precision
operator|=
operator|(
name|s_char
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_BROADDELAY
case|:
comment|/* 		 * Set default broadcast delay 		 */
name|sys_bdelay
operator|=
operator|(
operator|(
name|value
operator|)
operator|+
literal|0x00000800
operator|)
operator|&
literal|0xfffff000
expr_stmt|;
break|break;
case|case
name|PROTO_AUTHENTICATE
case|:
comment|/* 		 * Specify the use of authenticated data 		 */
name|sys_authenticate
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_AUTHDELAY
case|:
comment|/* 		 * Provide an authentication delay value.  Round it to 		 * the microsecond.  This is crude. 		 */
name|sys_authdelay
operator|=
operator|(
operator|(
name|value
operator|)
operator|+
literal|0x00000800
operator|)
operator|&
literal|0xfffff000
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Log this error 		 */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"proto_config: illegal item %d, value %ld"
argument_list|,
name|item
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * proto_clr_stats - clear protocol stat counters  */
end_comment

begin_function
name|void
name|proto_clr_stats
parameter_list|()
block|{
name|sys_badstratum
operator|=
literal|0
expr_stmt|;
name|sys_oldversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_newversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_unknownversion
operator|=
literal|0
expr_stmt|;
name|sys_badlength
operator|=
literal|0
expr_stmt|;
name|sys_processed
operator|=
literal|0
expr_stmt|;
name|sys_badauth
operator|=
literal|0
expr_stmt|;
name|sys_stattime
operator|=
name|current_time
expr_stmt|;
name|sys_limitrejected
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

