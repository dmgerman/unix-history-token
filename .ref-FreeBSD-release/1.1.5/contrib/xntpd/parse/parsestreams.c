begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * /src/NTP/REPOSITORY/v3/parse/parsestreams.c,v 3.19 1994/02/24 16:33:54 kardel Exp  *    * parsestreams.c,v 3.19 1994/02/24 16:33:54 kardel Exp  *  * STREAMS module for reference clocks  * (SunOS4.x)  *  * Copyright (c) 1989,1990,1991,1992,1993,1994  * Frank Kardel Friedrich-Alexander Universitaet Erlangen-Nuernberg  *                                      * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"parsestreams.c,v 3.19 1994/02/24 16:33:54 kardel Exp"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sys/types.h"
end_include

begin_include
include|#
directive|include
file|"sys/conf.h"
end_include

begin_include
include|#
directive|include
file|"sys/buf.h"
end_include

begin_include
include|#
directive|include
file|"sys/param.h"
end_include

begin_include
include|#
directive|include
file|"sys/sysmacros.h"
end_include

begin_include
include|#
directive|include
file|"sys/errno.h"
end_include

begin_include
include|#
directive|include
file|"sys/time.h"
end_include

begin_include
include|#
directive|include
file|"sundev/mbvar.h"
end_include

begin_include
include|#
directive|include
file|"sun/autoconf.h"
end_include

begin_include
include|#
directive|include
file|"sys/stream.h"
end_include

begin_include
include|#
directive|include
file|"sys/stropts.h"
end_include

begin_include
include|#
directive|include
file|"sys/dir.h"
end_include

begin_include
include|#
directive|include
file|"sys/signal.h"
end_include

begin_include
include|#
directive|include
file|"sys/termios.h"
end_include

begin_include
include|#
directive|include
file|"sys/termio.h"
end_include

begin_include
include|#
directive|include
file|"sys/ttold.h"
end_include

begin_include
include|#
directive|include
file|"sys/user.h"
end_include

begin_include
include|#
directive|include
file|"sys/errno.h"
end_include

begin_include
include|#
directive|include
file|"sys/tty.h"
end_include

begin_include
include|#
directive|include
file|"machine/cpu.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VDDRV
end_ifdef

begin_include
include|#
directive|include
file|"sun/vddrv.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * no protypes here !  */
end_comment

begin_define
define|#
directive|define
name|P
parameter_list|(
name|x
parameter_list|)
value|()
end_define

begin_comment
comment|/*  * use microtime instead of uniqtime if advised to  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MICROTIME
end_ifdef

begin_define
define|#
directive|define
name|uniqtime
value|microtime
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HAVE_NO_NICE
end_define

begin_comment
comment|/* for the NTP headerfiles */
end_comment

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"sys/parsestreams.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VDDRV
end_ifdef

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|parsebusy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------- loadable driver section -----------------------------*/
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|streamtab
name|parseinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vdldrv
name|parsesync_vd
init|=
block|{
name|VDMAGIC_PSEUDO
block|,
comment|/* nothing like a real driver - a STREAMS module */
literal|"PARSE        "
block|,
comment|/* name this baby - keep room for revision number */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * strings support usually not in kernel  */
end_comment

begin_function
specifier|static
name|int
name|strlen
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|++
condition|)
block|{
name|c
operator|++
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|strncpy
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|&&
name|t
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|--
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
condition|)
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|strcmp
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|t
operator|||
operator|(
name|s
operator|==
name|t
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|!
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|-
operator|*
name|t
operator|++
operator|)
operator|&&
operator|*
name|s
operator|&&
operator|*
name|t
condition|)
comment|/* empty loop */
empty_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|strncmp
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|t
operator|||
operator|(
name|s
operator|==
name|t
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
while|while
condition|(
name|n
operator|--
operator|&&
operator|!
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|-
operator|*
name|t
operator|++
operator|)
operator|&&
operator|*
name|s
operator|&&
operator|*
name|t
condition|)
comment|/* empty loop */
empty_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * driver init routine  * since no mechanism gets us into and out of the fmodsw, we have to  * do it ourselves  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|xxxinit
parameter_list|(
name|fc
parameter_list|,
name|vdp
parameter_list|,
name|vdi
parameter_list|,
name|vds
parameter_list|)
name|unsigned
name|int
name|fc
decl_stmt|;
name|struct
name|vddrv
modifier|*
name|vdp
decl_stmt|;
name|addr_t
name|vdi
decl_stmt|;
name|struct
name|vdstat
modifier|*
name|vds
decl_stmt|;
block|{
specifier|extern
name|struct
name|fmodsw
name|fmodsw
index|[]
decl_stmt|;
specifier|extern
name|int
name|fmodcnt
decl_stmt|;
name|struct
name|fmodsw
modifier|*
name|fm
init|=
name|fmodsw
decl_stmt|;
name|struct
name|fmodsw
modifier|*
name|fmend
init|=
operator|&
name|fmodsw
index|[
name|fmodcnt
index|]
decl_stmt|;
name|struct
name|fmodsw
modifier|*
name|ifm
init|=
operator|(
expr|struct
name|fmodsw
operator|*
operator|)
literal|0
decl_stmt|;
name|char
modifier|*
name|mname
init|=
name|parseinfo
operator|.
name|st_rdinit
operator|->
name|qi_minfo
operator|->
name|mi_idname
decl_stmt|;
switch|switch
condition|(
name|fc
condition|)
block|{
case|case
name|VDLOAD
case|:
name|vdp
operator|->
name|vdd_vdtab
operator|=
operator|(
expr|struct
name|vdlinkage
operator|*
operator|)
operator|&
name|parsesync_vd
expr_stmt|;
comment|/*        * now, jog along fmodsw scanning for an empty slot        * and deposit our name there        */
while|while
condition|(
name|fm
operator|<=
name|fmend
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|fm
operator|->
name|f_name
argument_list|,
name|mname
argument_list|,
name|FMNAMESZ
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"vddrinit[%s]: STREAMS module already loaded.\n"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifm
operator|==
operator|(
expr|struct
name|fmodsw
operator|*
operator|)
literal|0
operator|)
operator|&&
operator|(
name|fm
operator|->
name|f_name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|fm
operator|->
name|f_str
operator|==
operator|(
expr|struct
name|streamtab
operator|*
operator|)
literal|0
operator|)
condition|)
block|{
comment|/* 		 * got one - so move in 		 */
name|ifm
operator|=
name|fm
expr_stmt|;
break|break;
block|}
name|fm
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ifm
operator|==
operator|(
expr|struct
name|fmodsw
operator|*
operator|)
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vddrinit[%s]: no slot free for STREAMS module\n"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
else|else
block|{
specifier|static
name|char
name|revision
index|[]
init|=
literal|"3.19"
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|S
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|strncpy
argument_list|(
name|ifm
operator|->
name|f_name
argument_list|,
name|mname
argument_list|,
name|FMNAMESZ
argument_list|)
expr_stmt|;
name|ifm
operator|->
name|f_name
index|[
name|FMNAMESZ
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ifm
operator|->
name|f_str
operator|=
operator|&
name|parseinfo
expr_stmt|;
comment|/* 	   * copy RCS revision into Drv_name 	   * 	   * are we forcing RCS here to do things it was not built for ? 	   */
name|s
operator|=
name|revision
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
block|{
comment|/* 	       * skip "$Revision: " 	       * if present. - not necessary on a -kv co (cvs export) 	       */
while|while
condition|(
operator|*
name|s
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|' '
operator|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|t
operator|=
name|parsesync_vd
operator|.
name|Drv_name
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
operator|(
operator|*
name|t
operator|!=
literal|' '
operator|)
condition|)
block|{
name|t
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|t
operator|==
literal|' '
condition|)
name|t
operator|++
expr_stmt|;
name|S
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|S
operator|&&
operator|(
operator|(
operator|(
operator|*
name|S
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|S
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
operator|*
name|S
operator|==
literal|'.'
operator|)
operator|)
condition|)
block|{
name|S
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|&&
operator|*
name|t
operator|&&
operator|(
name|S
operator|>
name|s
operator|)
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|t
argument_list|)
operator|>=
operator|(
name|S
operator|-
name|s
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
name|S
operator|-
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|VDUNLOAD
case|:
if|if
condition|(
name|parsebusy
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vddrinit[%s]: STREAMS module has still %d instances active.\n"
argument_list|,
name|mname
argument_list|,
name|parsebusy
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
else|else
block|{
while|while
condition|(
name|fm
operator|<=
name|fmend
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|fm
operator|->
name|f_name
argument_list|,
name|mname
argument_list|,
name|FMNAMESZ
argument_list|)
condition|)
block|{
comment|/* 		   * got it - kill entry 		   */
name|fm
operator|->
name|f_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fm
operator|->
name|f_str
operator|=
operator|(
expr|struct
name|streamtab
operator|*
operator|)
literal|0
expr_stmt|;
name|fm
operator|++
expr_stmt|;
break|break;
block|}
name|fm
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fm
operator|>
name|fmend
condition|)
block|{
name|printf
argument_list|(
literal|"vddrinit[%s]: cannot find entry for STREAMS module\n"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|VDSTAT
case|:
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
name|EIO
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*--------------- stream module definition ----------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|parseopen
argument_list|()
decl_stmt|,
name|parseclose
argument_list|()
decl_stmt|,
name|parsewput
argument_list|()
decl_stmt|,
name|parserput
argument_list|()
decl_stmt|,
name|parsersvc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|module_info
name|driverinfo
init|=
block|{
literal|0
block|,
comment|/* module ID number */
literal|"parse"
block|,
comment|/* module name */
literal|0
block|,
comment|/* minimum accepted packet size */
name|INFPSZ
block|,
comment|/* maximum accepted packet size */
literal|1
block|,
comment|/* high water mark - flow control */
literal|0
comment|/* low water mark - flow control */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|qinit
name|rinit
init|=
comment|/* read queue definition */
block|{
name|parserput
block|,
comment|/* put procedure */
name|parsersvc
block|,
comment|/* service procedure */
name|parseopen
block|,
comment|/* open procedure */
name|parseclose
block|,
comment|/* close procedure */
name|NULL
block|,
comment|/* admin procedure - NOT USED FOR NOW */
operator|&
name|driverinfo
block|,
comment|/* information structure */
name|NULL
comment|/* statistics */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|qinit
name|winit
init|=
comment|/* write queue definition */
block|{
name|parsewput
block|,
comment|/* put procedure */
name|NULL
block|,
comment|/* service procedure */
name|NULL
block|,
comment|/* open procedure */
name|NULL
block|,
comment|/* close procedure */
name|NULL
block|,
comment|/* admin procedure - NOT USED FOR NOW */
operator|&
name|driverinfo
block|,
comment|/* information structure */
name|NULL
comment|/* statistics */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|streamtab
name|parseinfo
init|=
comment|/* stream info element for dpr driver */
block|{
operator|&
name|rinit
block|,
comment|/* read queue */
operator|&
name|winit
block|,
comment|/* write queue */
name|NULL
block|,
comment|/* read mux */
name|NULL
block|,
comment|/* write mux */
name|NULL
comment|/* module auto push */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------- driver data structures ----------------------------*/
end_comment

begin_comment
comment|/*  * we usually have an inverted signal - but you  * can change this to suit your needs  */
end_comment

begin_decl_stmt
name|int
name|cd_invert
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* invert status of CD line - PPS support via CD input */
end_comment

begin_decl_stmt
name|int
name|parsedebug
init|=
operator|~
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|uniqtime
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*--------------- module implementation -----------------------------*/
end_comment

begin_define
define|#
directive|define
name|TIMEVAL_USADD
parameter_list|(
name|_X_
parameter_list|,
name|_US_
parameter_list|)
value|{\ 				    (_X_)->tv_usec += (_US_);\ 			            if ((_X_)->tv_usec>= 1000000)\ 				      {\ 					 (_X_)->tv_sec++;\ 					 (_X_)->tv_usec -= 1000000;\ 				      }\ 				 } while (0)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun4c
argument_list|)
operator|&&
name|defined
argument_list|(
name|DEBUG_CD
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sun4c/cpu.h>
end_include

begin_include
include|#
directive|include
file|<sun4c/auxio.h>
end_include

begin_define
define|#
directive|define
name|SET_LED
parameter_list|(
name|_X_
parameter_list|)
value|(((cpu& CPU_ARCH) == SUN4C_ARCH) ? *(u_char *)AUXIO_REG = AUX_MBO|AUX_EJECT|((_X_)?AUX_LED:0) : 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SET_LED
parameter_list|(
name|_X_
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|init_linemon
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|close_linemon
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * keep here MACHINE AND OS AND ENVIRONMENT DEPENDENT  * timing constants  *  * FOR ABSOLUTE PRECISION YOU NEED TO MEASURE THE TIMING  * SKEW BETWEEN THE HW-PPS SIGNAL AND KERNEL uniqtime()  * YOURSELF.  *  * YOU MUST BE QUALIFIED APPROPRIATELY FOR THESE TYPE  * OF HW MANIPULATION !  *  * you need an oscilloscope and the permission for HW work  * in order to figure out these timing constants/variables  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|xsdelay
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assume an SS2 */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|stdelay
init|=
literal|350
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|delays
block|{
name|unsigned
name|char
name|mask
decl_stmt|;
comment|/* what to check for */
name|unsigned
name|char
name|type
decl_stmt|;
comment|/* what to match */
name|unsigned
name|long
name|xsdelay
decl_stmt|;
comment|/* external status direct delay in us */
name|unsigned
name|long
name|stdelay
decl_stmt|;
comment|/* STREAMS message delay (M_[UN]HANGUP) */
block|}
name|isr_delays
index|[]
init|=
block|{
comment|/*    * WARNING: must still be measured - currently taken from Craig Leres ppsdev    */
ifdef|#
directive|ifdef
name|sun4c
block|{
name|CPU_ARCH
operator||
name|CPU_MACH
block|,
name|CPU_SUN4C_50
block|,
literal|10
block|,
literal|350
block|}
block|,
block|{
name|CPU_ARCH
operator||
name|CPU_MACH
block|,
name|CPU_SUN4C_65
block|,
literal|15
block|,
literal|700
block|}
block|,
block|{
name|CPU_ARCH
operator||
name|CPU_MACH
block|,
name|CPU_SUN4C_75
block|,
literal|10
block|,
literal|350
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|sun4m
block|{
name|CPU_ARCH
operator||
name|CPU_MACH
block|,
name|CPU_SUN4M_50
block|,
literal|8
block|,
literal|250
block|}
block|,
block|{
name|CPU_ARCH
operator||
name|CPU_MACH
block|,
name|CPU_SUN4M_690
block|,
literal|8
block|,
literal|250
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,}
block|}
struct|;
end_struct

begin_function
name|void
name|setup_delays
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|isr_delays
index|[
name|i
index|]
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cpu
operator|&
name|isr_delays
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|==
name|isr_delays
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
name|xsdelay
operator|=
name|isr_delays
index|[
name|i
index|]
operator|.
name|xsdelay
expr_stmt|;
name|stdelay
operator|=
name|isr_delays
index|[
name|i
index|]
operator|.
name|stdelay
expr_stmt|;
return|return;
block|}
block|}
name|printf
argument_list|(
literal|"parse: WARNING: PPS kernel fudge factors unknown for this machine (Type 0x%x) - assuming SS2 (Sun4/75)\n"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|setup_delays
parameter_list|()
end_define

begin_comment
comment|/* empty - no need for clobbering kernel with this */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|xsdelay
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assume nothing */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|stdelay
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|M_PARSE
value|0x0001
end_define

begin_define
define|#
directive|define
name|M_NOPARSE
value|0x0002
end_define

begin_function
specifier|static
name|int
name|setup_stream
parameter_list|(
name|q
parameter_list|,
name|mode
parameter_list|)
name|queue_t
modifier|*
name|q
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|mblk_t
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stroptions
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|struct
name|stroptions
modifier|*
name|str
init|=
operator|(
expr|struct
name|stroptions
operator|*
operator|)
name|mp
operator|->
name|b_rptr
decl_stmt|;
name|str
operator|->
name|so_flags
operator|=
name|SO_READOPT
operator||
name|SO_HIWAT
operator||
name|SO_LOWAT
expr_stmt|;
name|str
operator|->
name|so_readopt
operator|=
operator|(
name|mode
operator|==
name|M_PARSE
operator|)
condition|?
name|RMSGD
else|:
name|RNORM
expr_stmt|;
name|str
operator|->
name|so_hiwat
operator|=
operator|(
name|mode
operator|==
name|M_PARSE
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
else|:
literal|256
expr_stmt|;
name|str
operator|->
name|so_lowat
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_SETOPTS
expr_stmt|;
name|mp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|stroptions
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|putctl1
argument_list|(
name|WR
argument_list|(
name|q
argument_list|)
operator|->
name|q_next
argument_list|,
name|M_CTL
argument_list|,
operator|(
name|mode
operator|==
name|M_PARSE
operator|)
condition|?
name|MC_SERVICEIMM
else|:
name|MC_SERVICEDEF
argument_list|)
return|;
block|}
else|else
block|{
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: setup_stream - FAILED - no MEMORY for allocb\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|parseopen
parameter_list|(
name|q
parameter_list|,
name|dev
parameter_list|,
name|flag
parameter_list|,
name|sflag
parameter_list|)
name|queue_t
modifier|*
name|q
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|sflag
decl_stmt|;
block|{
specifier|register
name|mblk_t
modifier|*
name|mp
decl_stmt|;
specifier|register
name|parsestream_t
modifier|*
name|parse
decl_stmt|;
specifier|static
name|int
name|notice
init|=
literal|0
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflag
operator|!=
name|MODOPEN
condition|)
block|{
comment|/* open only for modules */
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN - FAILED - not MODOPEN\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|OPENFAIL
return|;
block|}
if|if
condition|(
name|q
operator|->
name|q_ptr
operator|!=
operator|(
name|caddr_t
operator|)
name|NULL
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EBUSY
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN - FAILED - EXCLUSIVE ONLY\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|OPENFAIL
return|;
block|}
ifdef|#
directive|ifdef
name|VDDRV
name|parsebusy
operator|++
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|q_ptr
operator|=
operator|(
name|caddr_t
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|parsestream_t
argument_list|)
argument_list|)
expr_stmt|;
name|WR
argument_list|(
name|q
argument_list|)
operator|->
name|q_ptr
operator|=
name|q
operator|->
name|q_ptr
expr_stmt|;
name|parse
operator|=
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|parse
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parse
argument_list|)
argument_list|)
expr_stmt|;
name|parse
operator|->
name|parse_queue
operator|=
name|q
expr_stmt|;
name|parse
operator|->
name|parse_status
operator|=
name|PARSE_ENABLE
expr_stmt|;
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|serial
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|parse_ioinit
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
condition|)
block|{
comment|/*        * ok guys - beat it        */
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|parse
argument_list|,
sizeof|sizeof
argument_list|(
name|parsestream_t
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VDDRV
name|parsebusy
operator|--
expr_stmt|;
endif|#
directive|endif
return|return
name|OPENFAIL
return|;
block|}
if|if
condition|(
name|setup_stream
argument_list|(
name|q
argument_list|,
name|M_PARSE
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|init_linemon
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* hook up PPS ISR routines if possible */
name|setup_delays
argument_list|()
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN - SUCCEEDED\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*        * I know that you know the delete key, but you didn't write this        * code, did you ? - So, keep the message in here.        */
if|if
condition|(
operator|!
name|notice
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Copyright (c) 1991-1994, Frank Kardel\n"
argument_list|,
name|parsesync_vd
operator|.
name|Drv_name
argument_list|)
expr_stmt|;
name|notice
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
else|else
block|{
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|parse
argument_list|,
sizeof|sizeof
argument_list|(
name|parsestream_t
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VDDRV
name|parsebusy
operator|--
expr_stmt|;
endif|#
directive|endif
return|return
name|OPENFAIL
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|parseclose
parameter_list|(
name|q
parameter_list|,
name|flags
parameter_list|)
name|queue_t
modifier|*
name|q
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
specifier|register
name|unsigned
name|long
name|s
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_CLOSE
argument_list|,
operator|(
literal|"parse: CLOSE\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|parse_dqueue
condition|)
name|close_linemon
argument_list|(
name|parse
operator|->
name|parse_dqueue
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|parse
operator|->
name|parse_dqueue
operator|=
operator|(
name|queue_t
operator|*
operator|)
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|parse_ioend
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|parse
argument_list|,
sizeof|sizeof
argument_list|(
name|parsestream_t
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_ptr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
name|WR
argument_list|(
name|q
argument_list|)
operator|->
name|q_ptr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|VDDRV
name|parsebusy
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * move unrecognized stuff upward  */
end_comment

begin_expr_stmt
specifier|static
name|parsersvc
argument_list|(
argument|q
argument_list|)
name|queue_t
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|mblk_t
modifier|*
name|mp
decl_stmt|;
while|while
condition|(
name|mp
operator|=
name|getq
argument_list|(
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
name|canput
argument_list|(
name|q
operator|->
name|q_next
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RSVC
argument_list|,
operator|(
literal|"parse: RSVC - putnext\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putbq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RSVC
argument_list|,
operator|(
literal|"parse: RSVC - flow control wait\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * do ioctls and  * send stuff down - dont care about  * flow control  */
end_comment

begin_function
specifier|static
name|int
name|parsewput
parameter_list|(
name|q
parameter_list|,
name|mp
parameter_list|)
name|queue_t
modifier|*
name|q
decl_stmt|;
specifier|register
name|mblk_t
modifier|*
name|mp
decl_stmt|;
block|{
specifier|register
name|int
name|ok
init|=
literal|1
decl_stmt|;
specifier|register
name|mblk_t
modifier|*
name|datap
decl_stmt|;
specifier|register
name|struct
name|iocblk
modifier|*
name|iocp
decl_stmt|;
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
condition|)
block|{
default|default:
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_IOCTL
case|:
name|iocp
operator|=
operator|(
expr|struct
name|iocblk
operator|*
operator|)
name|mp
operator|->
name|b_rptr
expr_stmt|;
switch|switch
condition|(
name|iocp
operator|->
name|ioc_cmd
condition|)
block|{
default|default:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - forward M_IOCTL\n"
operator|)
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CIOGETEV
case|:
comment|/* 	   * taken from Craig Leres ppsclock module (and modified) 	   */
name|datap
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ppsclockev
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
expr_stmt|;
if|if
condition|(
name|datap
operator|==
name|NULL
operator|||
name|mp
operator|->
name|b_cont
condition|)
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCNAK
expr_stmt|;
name|iocp
operator|->
name|ioc_error
operator|=
operator|(
name|datap
operator|==
name|NULL
operator|)
condition|?
name|ENOMEM
else|:
name|EINVAL
expr_stmt|;
if|if
condition|(
name|datap
operator|!=
name|NULL
condition|)
name|freeb
argument_list|(
name|datap
argument_list|)
expr_stmt|;
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
name|mp
operator|->
name|b_cont
operator|=
name|datap
expr_stmt|;
operator|*
operator|(
expr|struct
name|ppsclockev
operator|*
operator|)
name|datap
operator|->
name|b_wptr
operator|=
name|parse
operator|->
name|parse_ppsclockev
expr_stmt|;
name|datap
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ppsclockev
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|datap
operator|->
name|b_wptr
argument_list|)
expr_stmt|;
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCACK
expr_stmt|;
name|iocp
operator|->
name|ioc_count
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ppsclockev
argument_list|)
expr_stmt|;
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_ENABLE
case|:
case|case
name|PARSEIOC_DISABLE
case|:
block|{
name|parse
operator|->
name|parse_status
operator|=
operator|(
name|parse
operator|->
name|parse_status
operator|&
operator|~
name|PARSE_ENABLE
operator|)
operator||
operator|(
name|iocp
operator|->
name|ioc_cmd
operator|==
name|PARSEIOC_ENABLE
operator|)
condition|?
name|PARSE_ENABLE
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|setup_stream
argument_list|(
name|RD
argument_list|(
name|q
argument_list|)
argument_list|,
operator|(
name|parse
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
condition|?
name|M_PARSE
else|:
name|M_NOPARSE
argument_list|)
condition|)
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCNAK
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCACK
expr_stmt|;
block|}
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PARSEIOC_SETSTAT
case|:
case|case
name|PARSEIOC_GETSTAT
case|:
case|case
name|PARSEIOC_TIMECODE
case|:
case|case
name|PARSEIOC_SETFMT
case|:
case|case
name|PARSEIOC_GETFMT
case|:
case|case
name|PARSEIOC_SETCS
case|:
if|if
condition|(
name|iocp
operator|->
name|ioc_count
operator|==
sizeof|sizeof
argument_list|(
name|parsectl_t
argument_list|)
condition|)
block|{
name|parsectl_t
modifier|*
name|dct
init|=
operator|(
name|parsectl_t
operator|*
operator|)
name|mp
operator|->
name|b_cont
operator|->
name|b_rptr
decl_stmt|;
switch|switch
condition|(
name|iocp
operator|->
name|ioc_cmd
condition|)
block|{
case|case
name|PARSEIOC_GETSTAT
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_GETSTAT\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_getstat
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_SETSTAT
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_SETSTAT\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_setstat
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_TIMECODE
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_TIMECODE\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_timecode
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_SETFMT
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_SETFMT\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_setfmt
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_GETFMT
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_GETFMT\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_getfmt
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_SETCS
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_SETCS\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_setcs
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
block|}
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|ok
condition|?
name|M_IOCACK
else|:
name|M_IOCNAK
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCNAK
expr_stmt|;
block|}
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput qreply - %s\n"
operator|,
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|==
name|M_IOCNAK
operator|)
condition|?
literal|"M_IOCNAK"
else|:
literal|"M_IOCACK"
operator|)
argument_list|)
expr_stmt|;
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * read characters from streams buffers  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|rdchar
parameter_list|(
name|mp
parameter_list|)
specifier|register
name|mblk_t
modifier|*
modifier|*
name|mp
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|mp
operator|!=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_wptr
operator|-
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_rptr
condition|)
block|{
return|return
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_rptr
operator|++
operator|)
argument_list|)
return|;
block|}
else|else
block|{
specifier|register
name|mblk_t
modifier|*
name|mmp
init|=
operator|*
name|mp
decl_stmt|;
operator|*
name|mp
operator|=
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_cont
expr_stmt|;
name|freeb
argument_list|(
name|mmp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|~
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * convert incoming data  */
end_comment

begin_function
specifier|static
name|int
name|parserput
parameter_list|(
name|q
parameter_list|,
name|mp
parameter_list|)
name|queue_t
modifier|*
name|q
decl_stmt|;
name|mblk_t
modifier|*
name|mp
decl_stmt|;
block|{
name|unsigned
name|char
name|type
decl_stmt|;
switch|switch
condition|(
name|type
operator|=
name|mp
operator|->
name|b_datap
operator|->
name|db_type
condition|)
block|{
default|default:
comment|/*        * anything we don't know will be put on queue        * the service routine will move it to the next one        */
name|parseprintf
argument_list|(
name|DD_RPUT
argument_list|,
operator|(
literal|"parse: parserput - forward type 0x%x\n"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|canput
argument_list|(
name|q
operator|->
name|q_next
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
name|putq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BREAK
case|:
case|case
name|M_DATA
case|:
block|{
specifier|register
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
specifier|register
name|mblk_t
modifier|*
name|nmp
decl_stmt|;
specifier|register
name|unsigned
name|long
name|ch
decl_stmt|;
name|timestamp_t
name|ctime
decl_stmt|;
comment|/* 	 * get time on packet delivery 	 */
name|uniqtime
argument_list|(
operator|&
name|ctime
operator|.
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|parse
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_RPUT
argument_list|,
operator|(
literal|"parse: parserput - parser disabled - forward type 0x%x\n"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|canput
argument_list|(
name|q
operator|->
name|q_next
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
name|putq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parseprintf
argument_list|(
name|DD_RPUT
argument_list|,
operator|(
literal|"parse: parserput - M_%s\n"
operator|,
operator|(
name|type
operator|==
name|M_DATA
operator|)
condition|?
literal|"DATA"
else|:
literal|"BREAK"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|M_DATA
condition|)
block|{
comment|/* 		 * parse packet looking for start an end characters 		 */
while|while
condition|(
name|mp
operator|!=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|ch
operator|=
name|rdchar
argument_list|(
operator|&
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
operator|~
literal|0
operator|&&
name|parse_ioread
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|,
operator|(
name|char
operator|)
name|ch
argument_list|,
operator|&
name|ctime
argument_list|)
condition|)
block|{
comment|/* 			 * up up and away (hopefully ...) 			 * don't press it if resources are tight or nobody wants it 			 */
name|nmp
operator|=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|canput
argument_list|(
name|parse
operator|->
name|parse_queue
operator|->
name|q_next
argument_list|)
operator|&&
operator|(
name|nmp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|parse
operator|->
name|parse_io
operator|.
name|parse_dtime
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|b_rptr
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|parse
operator|->
name|parse_queue
argument_list|,
name|nmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
condition|)
name|freemsg
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|parse_ioread
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|,
operator|&
name|ctime
argument_list|)
condition|)
block|{
comment|/* 		     * up up and away (hopefully ...) 		     * don't press it if resources are tight or nobody wants it 		     */
name|nmp
operator|=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|canput
argument_list|(
name|parse
operator|->
name|parse_queue
operator|->
name|q_next
argument_list|)
operator|&&
operator|(
name|nmp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|parse
operator|->
name|parse_io
operator|.
name|parse_dtime
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|b_rptr
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|parse
operator|->
name|parse_queue
argument_list|,
name|nmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
condition|)
name|freemsg
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
block|}
name|freemsg
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/*        * CD PPS support for non direct ISR hack        */
case|case
name|M_HANGUP
case|:
case|case
name|M_UNHANGUP
case|:
block|{
specifier|register
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
name|timestamp_t
name|ctime
decl_stmt|;
specifier|register
name|mblk_t
modifier|*
name|nmp
decl_stmt|;
specifier|register
name|int
name|status
init|=
name|cd_invert
operator|^
operator|(
name|type
operator|==
name|M_HANGUP
operator|)
decl_stmt|;
name|SET_LED
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|uniqtime
argument_list|(
operator|&
name|ctime
operator|.
name|tv
argument_list|)
expr_stmt|;
name|TIMEVAL_USADD
argument_list|(
operator|&
name|ctime
operator|.
name|tv
argument_list|,
name|stdelay
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RPUT
argument_list|,
operator|(
literal|"parse: parserput - M_%sHANGUP\n"
operator|,
operator|(
name|type
operator|==
name|M_HANGUP
operator|)
condition|?
literal|""
else|:
literal|"UN"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|parse
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
operator|&&
name|parse_iopps
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|,
name|status
condition|?
name|SYNC_ONE
else|:
name|SYNC_ZERO
argument_list|,
operator|&
name|ctime
argument_list|)
condition|)
block|{
name|nmp
operator|=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|canput
argument_list|(
name|parse
operator|->
name|parse_queue
operator|->
name|q_next
argument_list|)
operator|&&
operator|(
name|nmp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|parse
operator|->
name|parse_io
operator|.
name|parse_dtime
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|b_rptr
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|parse
operator|->
name|parse_queue
argument_list|,
name|nmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
condition|)
name|freemsg
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
name|freemsg
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|canput
argument_list|(
name|q
operator|->
name|q_next
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
name|putq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|=
name|ctime
operator|.
name|tv
expr_stmt|;
operator|++
operator|(
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|serial
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function_decl
specifier|static
name|int
name|init_zs_linemon
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* handle line monitor for "zs" driver */
end_comment

begin_function_decl
specifier|static
name|void
name|close_zs_linemon
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zs_xsisr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* zs external status interupt handler */
end_comment

begin_comment
comment|/*-------------------- CD isr status monitor ---------------*/
end_comment

begin_function
specifier|static
name|int
name|init_linemon
parameter_list|(
name|q
parameter_list|)
specifier|register
name|queue_t
modifier|*
name|q
decl_stmt|;
block|{
specifier|register
name|queue_t
modifier|*
name|dq
decl_stmt|;
name|dq
operator|=
name|WR
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/*    * we ARE doing very bad things down here (basically stealing ISR    * hooks)    *    * so we chase down the STREAMS stack searching for the driver    * and if this is a known driver we insert our ISR routine for    * status changes in to the ExternalStatus handling hook    */
while|while
condition|(
name|dq
operator|->
name|q_next
condition|)
block|{
name|dq
operator|=
name|dq
operator|->
name|q_next
expr_stmt|;
comment|/* skip down to driver */
block|}
comment|/*    * find appropriate driver dependent routine    */
if|if
condition|(
name|dq
operator|->
name|q_qinfo
operator|&&
name|dq
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
specifier|register
name|char
modifier|*
name|dname
init|=
name|dq
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"init_linemon: driver is \"%s\"\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sun
if|if
condition|(
name|dname
operator|&&
operator|!
name|strcmp
argument_list|(
name|dname
argument_list|,
literal|"zs"
argument_list|)
condition|)
block|{
return|return
name|init_zs_linemon
argument_list|(
name|dq
argument_list|,
name|q
argument_list|)
return|;
block|}
else|else
endif|#
directive|endif
block|{
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"init_linemon: driver \"%s\" not suitable for CD monitoring\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"init_linemon: cannot find driver\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|close_linemon
parameter_list|(
name|q
parameter_list|,
name|my_q
parameter_list|)
specifier|register
name|queue_t
modifier|*
name|q
decl_stmt|;
specifier|register
name|queue_t
modifier|*
name|my_q
decl_stmt|;
block|{
comment|/*    * find appropriate driver dependent routine    */
if|if
condition|(
name|q
operator|->
name|q_qinfo
operator|&&
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
specifier|register
name|char
modifier|*
name|dname
init|=
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
decl_stmt|;
ifdef|#
directive|ifdef
name|sun
if|if
condition|(
name|dname
operator|&&
operator|!
name|strcmp
argument_list|(
name|dname
argument_list|,
literal|"zs"
argument_list|)
condition|)
block|{
name|close_zs_linemon
argument_list|(
name|q
argument_list|,
name|my_q
argument_list|)
expr_stmt|;
return|return;
block|}
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"close_linemon: cannot find driver close routine for \"%s\"\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"close_linemon: cannot find driver name\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_include
include|#
directive|include
file|<sundev/zsreg.h>
end_include

begin_include
include|#
directive|include
file|<sundev/zscom.h>
end_include

begin_include
include|#
directive|include
file|<sundev/zsvar.h>
end_include

begin_struct
struct|struct
name|savedzsops
block|{
name|struct
name|zsops
name|zsops
decl_stmt|;
name|struct
name|zsops
modifier|*
name|oldzsops
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|zsops
modifier|*
name|emergencyzs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|init_zs_linemon
parameter_list|(
name|q
parameter_list|,
name|my_q
parameter_list|)
specifier|register
name|queue_t
modifier|*
name|q
decl_stmt|;
specifier|register
name|queue_t
modifier|*
name|my_q
decl_stmt|;
block|{
specifier|register
name|struct
name|zscom
modifier|*
name|zs
decl_stmt|;
specifier|register
name|struct
name|savedzsops
modifier|*
name|szs
decl_stmt|;
specifier|register
name|parsestream_t
modifier|*
name|parsestream
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|my_q
operator|->
name|q_ptr
decl_stmt|;
comment|/*    * we expect the zsaline pointer in the q_data pointer    * from there on we insert our on EXTERNAL/STATUS ISR routine    * into the interrupt path, before the standard handler    */
name|zs
operator|=
operator|(
operator|(
expr|struct
name|zsaline
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|za_common
expr_stmt|;
if|if
condition|(
operator|!
name|zs
condition|)
block|{
comment|/*        * well - not found on startup - just say no (shouldn't happen though)        */
return|return
literal|0
return|;
block|}
else|else
block|{
name|unsigned
name|long
name|s
decl_stmt|;
comment|/*        * we do a direct replacement, in case others fiddle also        * if somebody else grabs our hook and we disconnect        * we are in DEEP trouble - panic is likely to be next, sorry        */
name|szs
operator|=
operator|(
expr|struct
name|savedzsops
operator|*
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|savedzsops
argument_list|)
argument_list|)
expr_stmt|;
name|parsestream
operator|->
name|parse_data
operator|=
operator|(
name|void
operator|*
operator|)
name|szs
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|parsestream
operator|->
name|parse_dqueue
operator|=
name|q
expr_stmt|;
comment|/* remember driver */
name|szs
operator|->
name|zsops
operator|=
operator|*
name|zs
operator|->
name|zs_ops
expr_stmt|;
name|szs
operator|->
name|zsops
operator|.
name|zsop_xsint
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|zs_xsisr
expr_stmt|;
comment|/* place our bastard */
name|szs
operator|->
name|oldzsops
operator|=
name|zs
operator|->
name|zs_ops
expr_stmt|;
name|emergencyzs
operator|=
name|zs
operator|->
name|zs_ops
expr_stmt|;
name|zsopinit
argument_list|(
name|zs
argument_list|,
operator|&
name|szs
operator|->
name|zsops
argument_list|)
expr_stmt|;
comment|/* hook it up */
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"init_zs_linemon: CD monitor installed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * unregister our ISR routine - must call under splhigh()  */
end_comment

begin_function
specifier|static
name|void
name|close_zs_linemon
parameter_list|(
name|q
parameter_list|,
name|my_q
parameter_list|)
specifier|register
name|queue_t
modifier|*
name|q
decl_stmt|;
specifier|register
name|queue_t
modifier|*
name|my_q
decl_stmt|;
block|{
specifier|register
name|struct
name|zscom
modifier|*
name|zs
decl_stmt|;
specifier|register
name|parsestream_t
modifier|*
name|parsestream
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|my_q
operator|->
name|q_ptr
decl_stmt|;
name|zs
operator|=
operator|(
operator|(
expr|struct
name|zsaline
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|za_common
expr_stmt|;
if|if
condition|(
operator|!
name|zs
condition|)
block|{
comment|/*        * well - not found on startup - just say no (shouldn't happen though)        */
return|return;
block|}
else|else
block|{
specifier|register
name|struct
name|savedzsops
modifier|*
name|szs
init|=
operator|(
expr|struct
name|savedzsops
operator|*
operator|)
name|parsestream
operator|->
name|parse_data
decl_stmt|;
name|zsopinit
argument_list|(
name|zs
argument_list|,
name|szs
operator|->
name|oldzsops
argument_list|)
expr_stmt|;
comment|/* reset to previous handler functions */
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|szs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|savedzsops
argument_list|)
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"close_zs_linemon: CD monitor deleted\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MAXDEPTH
value|50
end_define

begin_comment
comment|/* maximum allowed stream crawl */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PPS_SYNC
end_ifdef

begin_extern
extern|extern hardpps(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|struct
name|timeval
name|time
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * take external status interrupt (only CD interests us)  */
end_comment

begin_function
specifier|static
name|void
name|zs_xsisr
parameter_list|(
name|zs
parameter_list|)
specifier|register
name|struct
name|zscom
modifier|*
name|zs
decl_stmt|;
block|{
specifier|register
name|struct
name|zsaline
modifier|*
name|za
init|=
operator|(
expr|struct
name|zsaline
operator|*
operator|)
name|zs
operator|->
name|zs_priv
decl_stmt|;
specifier|register
name|struct
name|zscc_device
modifier|*
name|zsaddr
init|=
name|zs
operator|->
name|zs_addr
decl_stmt|;
specifier|register
name|queue_t
modifier|*
name|q
decl_stmt|;
specifier|register
name|unsigned
name|char
name|zsstatus
decl_stmt|;
specifier|register
name|int
name|loopcheck
decl_stmt|;
specifier|register
name|char
modifier|*
name|dname
decl_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
specifier|register
name|int
name|s
decl_stmt|;
specifier|register
name|long
name|usec
decl_stmt|;
endif|#
directive|endif
comment|/*    * pick up current state    */
name|zsstatus
operator|=
name|zsaddr
operator|->
name|zscc_control
expr_stmt|;
if|if
condition|(
operator|(
name|za
operator|->
name|za_rr0
operator|^
name|zsstatus
operator|)
operator|&
operator|(
name|ZSRR0_CD
operator||
name|ZSRR0_SYNC
operator|)
condition|)
block|{
name|timestamp_t
name|cdevent
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
comment|/*        * CONDITIONAL external measurement support        */
name|SET_LED
argument_list|(
name|zsstatus
operator|&
operator|(
name|ZSRR0_CD
operator||
name|ZSRR0_SYNC
operator|)
argument_list|)
expr_stmt|;
comment|/* 				 * inconsistent with upper SET_LED, but this 				 * is for oscilloscope business anyway and we 				 * are just interested in edge delays in the 				 * lower us range 				 */
ifdef|#
directive|ifdef
name|PPS_SYNC
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|usec
operator|=
name|time
operator|.
name|tv_usec
expr_stmt|;
endif|#
directive|endif
comment|/*        * time stamp        */
name|uniqtime
argument_list|(
operator|&
name|cdevent
operator|.
name|tv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*        * logical state        */
name|status
operator|=
name|cd_invert
condition|?
operator|(
name|zsstatus
operator|&
operator|(
name|ZSRR0_CD
operator||
name|ZSRR0_SYNC
operator|)
operator|)
operator|==
literal|0
else|:
operator|(
name|zsstatus
operator|&
operator|(
name|ZSRR0_CD
operator||
name|ZSRR0_SYNC
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
if|if
condition|(
name|status
condition|)
block|{
name|usec
operator|=
name|cdevent
operator|.
name|tv
operator|.
name|tv_usec
operator|-
name|usec
expr_stmt|;
if|if
condition|(
name|usec
operator|<
literal|0
condition|)
name|usec
operator|+=
literal|1000000
expr_stmt|;
name|hardpps
argument_list|(
operator|&
name|cdevent
operator|.
name|tv
argument_list|,
name|usec
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|TIMEVAL_USADD
argument_list|(
operator|&
name|cdevent
operator|.
name|tv
argument_list|,
name|xsdelay
argument_list|)
expr_stmt|;
name|q
operator|=
name|za
operator|->
name|za_ttycommon
operator|.
name|t_readq
expr_stmt|;
comment|/*        * ok - now the hard part - find ourself        */
name|loopcheck
operator|=
name|MAXDEPTH
expr_stmt|;
while|while
condition|(
name|q
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|q_qinfo
operator|&&
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
name|dname
operator|=
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dname
argument_list|,
name|parseinfo
operator|.
name|st_rdinit
operator|->
name|qi_minfo
operator|->
name|mi_idname
argument_list|)
condition|)
block|{
comment|/* 		   * back home - phew (hopping along stream queues might 		   * prove dangerous to your health) 		   */
if|if
condition|(
operator|(
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
operator|&&
name|parse_iopps
argument_list|(
operator|&
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_io
argument_list|,
name|status
condition|?
name|SYNC_ONE
else|:
name|SYNC_ZERO
argument_list|,
operator|&
name|cdevent
argument_list|)
condition|)
block|{
comment|/* 		       * XXX - currently we do not pass up the message, as 		       * we should. 		       * for a correct behaviour wee need to block out 		       * processing until parse_iodone has been posted via 		       * a softcall-ed routine which does the message pass-up 		       * right now PPS information relies on input being 		       * received 		       */
name|parse_iodone
argument_list|(
operator|&
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_io
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
block|{
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|=
name|cdevent
operator|.
name|tv
expr_stmt|;
operator|++
operator|(
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_ppsclockev
operator|.
name|serial
operator|)
expr_stmt|;
block|}
name|parseprintf
argument_list|(
name|DD_ISR
argument_list|,
operator|(
literal|"zs_xsisr: CD event %s has been posted for \"%s\"\n"
operator|,
name|status
condition|?
literal|"ONE"
else|:
literal|"ZERO"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|q
operator|=
name|q
operator|->
name|q_next
expr_stmt|;
if|if
condition|(
operator|!
name|loopcheck
operator|--
condition|)
block|{
name|panic
argument_list|(
literal|"zs_xsisr: STREAMS Queue corrupted - CD event"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*        * only pretend that CD has been handled        */
name|za
operator|->
name|za_rr0
operator|=
name|za
operator|->
name|za_rr0
operator|&
operator|~
operator|(
name|ZSRR0_CD
operator||
name|ZSRR0_SYNC
operator|)
operator||
name|zsstatus
operator|&
operator|(
name|ZSRR0_CD
operator||
name|ZSRR0_SYNC
operator|)
expr_stmt|;
name|ZSDELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|za
operator|->
name|za_rr0
operator|^
name|zsstatus
operator|)
operator|&
operator|~
operator|(
name|ZSRR0_CD
operator||
name|ZSRR0_SYNC
operator|)
operator|)
condition|)
block|{
comment|/* 	   * all done - kill status indication and return 	   */
name|zsaddr
operator|->
name|zscc_control
operator|=
name|ZSWR0_RESET_STATUS
expr_stmt|;
comment|/* might kill other conditions here */
return|return;
block|}
block|}
comment|/*    * we are now gathered here to process some unusual external status    * interrupts.    * any CD events have also been handled and shouldn't be processed    * by the original routine (unless we have a VERY busy port pin)    * some initializations are done here, which could have been done before for    * both code paths but have been avioded for minimum path length to    * the uniq_time routine    */
name|dname
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|q
operator|=
name|za
operator|->
name|za_ttycommon
operator|.
name|t_readq
expr_stmt|;
name|loopcheck
operator|=
name|MAXDEPTH
expr_stmt|;
comment|/*    * the real thing for everything else ...    */
while|while
condition|(
name|q
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|q_qinfo
operator|&&
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
name|dname
operator|=
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dname
argument_list|,
name|parseinfo
operator|.
name|st_rdinit
operator|->
name|qi_minfo
operator|->
name|mi_idname
argument_list|)
condition|)
block|{
specifier|register
name|int
function_decl|(
modifier|*
name|zsisr
function_decl|)
parameter_list|()
function_decl|;
comment|/* 	       * back home - phew (hopping along stream queues might 	       * prove dangerous to your health) 	       */
if|if
condition|(
name|zsisr
operator|=
operator|(
operator|(
expr|struct
name|savedzsops
operator|*
operator|)
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_data
operator|)
operator|->
name|oldzsops
operator|->
name|zsop_xsint
condition|)
operator|(
name|void
operator|)
name|zsisr
argument_list|(
name|zs
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"zs_xsisr: unable to locate original ISR"
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_ISR
argument_list|,
operator|(
literal|"zs_xsisr: non CD event was processed for \"%s\"\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
comment|/* 	       * now back to our program ... 	       */
return|return;
block|}
block|}
name|q
operator|=
name|q
operator|->
name|q_next
expr_stmt|;
if|if
condition|(
operator|!
name|loopcheck
operator|--
condition|)
block|{
name|panic
argument_list|(
literal|"zs_xsisr: STREAMS Queue corrupted - non CD event"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * last resort - shouldn't even come here as it indicates    * corrupted TTY structures    */
name|printf
argument_list|(
literal|"zs_zsisr: looking for \"%s\" - found \"%s\" - taking EMERGENCY path\n"
argument_list|,
name|parseinfo
operator|.
name|st_rdinit
operator|->
name|qi_minfo
operator|->
name|mi_idname
argument_list|,
name|dname
condition|?
name|dname
else|:
literal|"-NIL-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|emergencyzs
operator|&&
name|emergencyzs
operator|->
name|zsop_xsint
condition|)
name|emergencyzs
operator|->
name|zsop_xsint
argument_list|(
name|zs
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"zs_xsisr: no emergency ISR handler"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sun */
end_comment

begin_comment
comment|/*  * History:  *  * parsestreams.c,v  * Revision 3.19  1994/02/24  16:33:54  kardel  * CD events can also be posted on sync flag  *  * Revision 3.18  1994/02/24  14:12:58  kardel  * initial PPS_SYNC support version  *  * Revision 3.17  1994/02/20  15:18:02  kardel  * rcs id cleanup  *  * Revision 3.16  1994/02/15  22:39:50  kardel  * memory leak on open failure closed  *  * Revision 3.15  1994/02/13  19:16:50  kardel  * updated verbose Copyright message  *  * Revision 3.14  1994/02/02  17:45:38  kardel  * rcs ids fixed  *  * Revision 3.12  1994/01/25  19:05:30  kardel  * 94/01/23 reconcilation  *  * Revision 3.11  1994/01/23  17:22:07  kardel  * 1994 reconcilation  *  * Revision 3.10  1993/12/15  12:48:58  kardel  * fixed message loss on M_*HANHUP messages  *  * Revision 3.9  1993/11/05  15:34:55  kardel  * shut up nice feature detection  *  * Revision 3.8  1993/10/22  14:27:56  kardel  * Oct. 22nd 1993 reconcilation  *  * Revision 3.7  1993/10/10  18:13:53  kardel  * Makefile reorganisation, file relocation  *  * Revision 3.6  1993/10/09  15:01:18  kardel  * file structure unified  *  * Revision 3.5  1993/10/04  07:59:31  kardel  * Well, at least we should know that a the tv_usec field should be in the range 0..999999  *  * Revision 3.4  1993/09/26  23:41:33  kardel  * new parse driver logic  *  * Revision 3.3  1993/09/11  00:38:34  kardel  * LINEMON must also cover M_[UN]HANGUP handling  *  * Revision 3.2  1993/07/06  10:02:56  kardel  * DCF77 driver goes generic...  *  */
end_comment

end_unit

