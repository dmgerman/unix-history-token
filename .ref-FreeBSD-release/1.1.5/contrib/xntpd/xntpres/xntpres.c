begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* xntpres.c,v 3.1 1993/07/06 01:12:09 jbj Exp  * xntpres - process configuration entries which require use of the resolver  *  * This is meant to be run by xntpd on the fly.  It is not guaranteed  * to work properly if run by hand.  This is actually a quick hack to  * stave off violence from people who hate using numbers in the  * configuration file (at least I hope the rest of the daemon is  * better than this).  Also might provide some ideas about how one  * might go about autoconfiguring an NTP distribution network.  *  * Usage is:  *   xntpres [-d] [-r] keyid keyfile configuration_data  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"ntp_select.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_malloc.h"
end_include

begin_include
include|#
directive|include
file|"ntp_request.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_comment
comment|/*  * Each item we are to resolve and configure gets one of these  * structures defined for it.  */
end_comment

begin_struct
struct|struct
name|conf_entry
block|{
name|struct
name|conf_entry
modifier|*
name|ce_next
decl_stmt|;
name|char
modifier|*
name|ce_name
decl_stmt|;
comment|/* name we are trying to resolve */
name|struct
name|conf_peer
name|ce_config
decl_stmt|;
comment|/* configuration info for peer */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ce_peeraddr
value|ce_config.peeraddr
end_define

begin_define
define|#
directive|define
name|ce_hmode
value|ce_config.hmode
end_define

begin_define
define|#
directive|define
name|ce_version
value|ce_config.version
end_define

begin_define
define|#
directive|define
name|ce_minpoll
value|ce_config.minpoll
end_define

begin_define
define|#
directive|define
name|ce_maxpoll
value|ce_config.maxpoll
end_define

begin_define
define|#
directive|define
name|ce_flags
value|ce_config.flags
end_define

begin_define
define|#
directive|define
name|ce_ttl
value|ce_config.ttl
end_define

begin_define
define|#
directive|define
name|ce_keyid
value|ce_config.keyid
end_define

begin_comment
comment|/*  * confentries is a pointer to the list of configuration entries  * we have left to do.  */
end_comment

begin_decl_stmt
name|struct
name|conf_entry
modifier|*
name|confentries
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We take an interrupt every thirty seconds, at which time we decrement  * config_timer and resolve_timer.  The former is set to 2, so we retry  * unsucessful reconfigurations every minute.  The latter is set to  * an exponentially increasing value which starts at 2 and increases to  * 32.  When this expires we retry failed name resolutions.  *  * We sleep SLEEPTIME seconds before doing anything, to give the server  * time to arrange itself.  */
end_comment

begin_define
define|#
directive|define
name|MINRESOLVE
value|2
end_define

begin_define
define|#
directive|define
name|MAXRESOLVE
value|32
end_define

begin_define
define|#
directive|define
name|CONFIG_TIME
value|2
end_define

begin_define
define|#
directive|define
name|ALARM_TIME
value|30
end_define

begin_define
define|#
directive|define
name|SLEEPTIME
value|2
end_define

begin_decl_stmt
name|int
name|config_timer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|resolve_timer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|resolve_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next value of resolve timer */
end_comment

begin_comment
comment|/*  * Big hack attack  */
end_comment

begin_define
define|#
directive|define
name|LOCALHOST
value|0x7f000001
end_define

begin_comment
comment|/* 127.0.0.1, in hex, of course */
end_comment

begin_define
define|#
directive|define
name|SKEWTIME
value|0x08000000
end_define

begin_comment
comment|/* 0.03125 seconds as a l_fp fraction */
end_comment

begin_comment
comment|/*  * Select time out.  Set to 2 seconds.  The server is on the local machine,  * after all.  */
end_comment

begin_define
define|#
directive|define
name|TIMEOUT_SEC
value|2
end_define

begin_define
define|#
directive|define
name|TIMEOUT_USEC
value|0
end_define

begin_comment
comment|/*  * Input processing.  The data on each line in the configuration file  * is supposed to consist of entries in the following order  */
end_comment

begin_define
define|#
directive|define
name|TOK_HOSTNAME
value|0
end_define

begin_define
define|#
directive|define
name|TOK_HMODE
value|1
end_define

begin_define
define|#
directive|define
name|TOK_VERSION
value|2
end_define

begin_define
define|#
directive|define
name|TOK_MINPOLL
value|3
end_define

begin_define
define|#
directive|define
name|TOK_MAXPOLL
value|4
end_define

begin_define
define|#
directive|define
name|TOK_FLAGS
value|5
end_define

begin_define
define|#
directive|define
name|TOK_TTL
value|6
end_define

begin_define
define|#
directive|define
name|TOK_KEYID
value|7
end_define

begin_define
define|#
directive|define
name|NUMTOK
value|8
end_define

begin_define
define|#
directive|define
name|MAXLINESIZE
value|512
end_define

begin_comment
comment|/*  * File descriptor for ntp request code.  */
end_comment

begin_decl_stmt
name|int
name|sockfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Misc. data from argument processing  */
end_comment

begin_decl_stmt
name|int
name|removefile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* remove configuration file when done */
end_comment

begin_decl_stmt
name|U_LONG
name|req_keyid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* request keyid */
end_comment

begin_decl_stmt
name|char
modifier|*
name|keyfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file where keys are kept */
end_comment

begin_decl_stmt
name|char
modifier|*
name|conffile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of the file with configuration info */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|bong
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|checkparent
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|removeentry
name|P
argument_list|(
operator|(
expr|struct
name|conf_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addentry
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|U_LONG
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|findhostaddr
name|P
argument_list|(
operator|(
expr|struct
name|conf_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|openntp
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|request
name|P
argument_list|(
operator|(
expr|struct
name|conf_peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nexttoken
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|readconf
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doconfigure
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * main - parse arguments and handle options  */
end_comment

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|errflg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
specifier|extern
name|int
name|ntp_optind
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Better get syslog open early since stderr messages are likely 	 * ending up in the twilight zone 	 */
name|cp
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
name|cp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
name|cp
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|LOG_DAEMON
name|openlog
argument_list|(
name|cp
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|LOG_NTP
define|#
directive|define
name|LOG_NTP
value|LOG_DAEMON
endif|#
directive|endif
name|openlog
argument_list|(
name|cp
argument_list|,
name|LOG_PID
operator||
name|LOG_NDELAY
argument_list|,
name|LOG_NTP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* DEBUG */
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_INFO
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG_DAEMON */
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|Version
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ntp_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"dr"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
operator|++
name|debug
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|++
name|removefile
expr_stmt|;
break|break;
default|default:
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|errflg
operator|||
operator|(
name|ntp_optind
operator|+
literal|3
operator|)
operator|!=
name|argc
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-d] [-r] keyid keyfile conffile\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"exiting due to usage error"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|atouint
argument_list|(
name|argv
index|[
name|ntp_optind
index|]
argument_list|,
operator|&
name|req_keyid
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"undecodeable keyid %s"
argument_list|,
name|argv
index|[
name|ntp_optind
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|keyfile
operator|=
name|argv
index|[
name|ntp_optind
operator|+
literal|1
index|]
expr_stmt|;
name|conffile
operator|=
name|argv
index|[
name|ntp_optind
operator|+
literal|2
index|]
expr_stmt|;
comment|/* 	 * Make sure we have the key we need 	 */
if|if
condition|(
operator|!
name|authreadkeys
argument_list|(
name|keyfile
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|req_keyid
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"request keyid %lu not found in %s"
argument_list|,
name|req_keyid
argument_list|,
name|keyfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Read the configuration info 	 */
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|conffile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't open configuration file %s: %m"
argument_list|,
name|conffile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|readconf
argument_list|(
name|in
argument_list|,
name|conffile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|removefile
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|conffile
argument_list|)
expr_stmt|;
comment|/* 	 * Sleep a little to make sure the server is completely up 	 */
name|sleep
argument_list|(
name|SLEEPTIME
argument_list|)
expr_stmt|;
comment|/* 	 * Make a first cut at resolving the bunch 	 */
name|doconfigure
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|confentries
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* done that quick */
comment|/* 	 * Here we've got some problem children.  Set up the timer 	 * and wait for it. 	 */
name|resolve_value
operator|=
name|resolve_timer
operator|=
name|MINRESOLVE
expr_stmt|;
name|config_timer
operator|=
name|CONFIG_TIME
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|bong
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|ALARM_TIME
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|confentries
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|checkparent
argument_list|()
expr_stmt|;
if|if
condition|(
name|resolve_timer
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|resolve_value
operator|<
name|MAXRESOLVE
condition|)
name|resolve_value
operator|<<=
literal|1
expr_stmt|;
name|resolve_timer
operator|=
name|resolve_value
expr_stmt|;
name|config_timer
operator|=
name|CONFIG_TIME
expr_stmt|;
name|doconfigure
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|config_timer
operator|==
literal|0
condition|)
block|{
name|config_timer
operator|=
name|CONFIG_TIME
expr_stmt|;
name|doconfigure
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * There is a race in here.  Is okay, though, since 		 * all it does is delay things by 30 seconds. 		 */
operator|(
name|void
operator|)
name|pause
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * bong - service and reschedule an alarm() interrupt  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|bong
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|config_timer
operator|>
literal|0
condition|)
name|config_timer
operator|--
expr_stmt|;
if|if
condition|(
name|resolve_timer
operator|>
literal|0
condition|)
name|resolve_timer
operator|--
expr_stmt|;
name|alarm
argument_list|(
name|ALARM_TIME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * checkparent - see if our parent process is still running  */
end_comment

begin_function
specifier|static
name|void
name|checkparent
parameter_list|()
block|{
comment|/* 	 * If our parent (the server) has died we will have been 	 * inherited by init.  If so, exit. 	 */
if|if
condition|(
name|getppid
argument_list|()
operator|==
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"parent died before we finished, exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * removeentry - we are done with an entry, remove it from the list  */
end_comment

begin_function
specifier|static
name|void
name|removeentry
parameter_list|(
name|entry
parameter_list|)
name|struct
name|conf_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|conf_entry
modifier|*
name|ce
decl_stmt|;
name|ce
operator|=
name|confentries
expr_stmt|;
if|if
condition|(
name|ce
operator|==
name|entry
condition|)
block|{
name|confentries
operator|=
name|ce
operator|->
name|ce_next
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|ce
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ce
operator|->
name|ce_next
operator|==
name|entry
condition|)
block|{
name|ce
operator|->
name|ce_next
operator|=
name|entry
operator|->
name|ce_next
expr_stmt|;
return|return;
block|}
name|ce
operator|=
name|ce
operator|->
name|ce_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * addentry - add an entry to the configuration list  */
end_comment

begin_function
specifier|static
name|void
name|addentry
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|,
name|version
parameter_list|,
name|minpoll
parameter_list|,
name|maxpoll
parameter_list|,
name|flags
parameter_list|,
name|ttl
parameter_list|,
name|keyid
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|version
decl_stmt|;
name|int
name|minpoll
decl_stmt|;
name|int
name|maxpoll
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|ttl
decl_stmt|;
name|U_LONG
name|keyid
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|conf_entry
modifier|*
name|ce
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|emalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|cp
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ce
operator|=
operator|(
expr|struct
name|conf_entry
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|conf_entry
argument_list|)
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_name
operator|=
name|cp
expr_stmt|;
name|ce
operator|->
name|ce_peeraddr
operator|=
literal|0
expr_stmt|;
name|ce
operator|->
name|ce_hmode
operator|=
operator|(
name|u_char
operator|)
name|mode
expr_stmt|;
name|ce
operator|->
name|ce_version
operator|=
operator|(
name|u_char
operator|)
name|version
expr_stmt|;
name|ce
operator|->
name|ce_minpoll
operator|=
operator|(
name|u_char
operator|)
name|minpoll
expr_stmt|;
name|ce
operator|->
name|ce_maxpoll
operator|=
operator|(
name|u_char
operator|)
name|maxpoll
expr_stmt|;
name|ce
operator|->
name|ce_flags
operator|=
operator|(
name|u_char
operator|)
name|flags
expr_stmt|;
name|ce
operator|->
name|ce_ttl
operator|=
operator|(
name|u_char
operator|)
name|ttl
expr_stmt|;
name|ce
operator|->
name|ce_keyid
operator|=
name|htonl
argument_list|(
name|keyid
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|confentries
operator|==
name|NULL
condition|)
block|{
name|confentries
operator|=
name|ce
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|conf_entry
modifier|*
name|cep
decl_stmt|;
for|for
control|(
name|cep
operator|=
name|confentries
init|;
name|cep
operator|->
name|ce_next
operator|!=
name|NULL
condition|;
name|cep
operator|=
name|cep
operator|->
name|ce_next
control|)
comment|/* nothing */
empty_stmt|;
name|cep
operator|->
name|ce_next
operator|=
name|ce
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * findhostaddr - resolve a host name into an address  *  * The routine sticks the address into the entry's ce_peeraddr if it  * gets one.  It returns 1 for "success" and 0 for an uncorrectable  * failure.  Note that "success" includes try again errors.  You can  * tell that you got a try again since ce_peeraddr will still be zero.  */
end_comment

begin_function
specifier|static
name|int
name|findhostaddr
parameter_list|(
name|entry
parameter_list|)
name|struct
name|conf_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|checkparent
argument_list|()
expr_stmt|;
comment|/* make sure our guy is still running */
name|hp
operator|=
name|gethostbyname
argument_list|(
name|entry
operator|->
name|ce_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|NODNS
comment|/* 		 * If the resolver is in use, see if the failure is 		 * temporary.  If so, return success. 		 */
specifier|extern
name|int
name|h_errno
decl_stmt|;
if|if
condition|(
name|h_errno
operator|==
name|TRY_AGAIN
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Use the first address.  We don't have any way to 	 * tell preferences and older gethostbyname() implementations 	 * only return one. 	 */
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|entry
operator|->
name|ce_peeraddr
operator|)
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * openntp - open a socket to the ntp server  */
end_comment

begin_function
specifier|static
name|void
name|openntp
parameter_list|()
block|{
name|struct
name|sockaddr_in
name|saddr
decl_stmt|;
if|if
condition|(
name|sockfd
operator|>=
literal|0
condition|)
return|return;
name|sockfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket() failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|saddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
expr_stmt|;
name|saddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|saddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
comment|/* trash */
name|saddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|LOCALHOST
argument_list|)
expr_stmt|;
comment|/* garbage */
comment|/*          * Make the socket non-blocking.  We'll wait with select()          */
if|#
directive|if
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|sockfd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(O_NONBLOCK) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|FNDELAY
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|sockfd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|NEED
name|NON
name|BLOCKING
name|IO
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"connect() failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * request - send a configuration request to the server, wait for a response  */
end_comment

begin_function
specifier|static
name|int
name|request
parameter_list|(
name|conf
parameter_list|)
name|struct
name|conf_peer
modifier|*
name|conf
decl_stmt|;
block|{
name|fd_set
name|fdset
decl_stmt|;
name|struct
name|timeval
name|tvout
decl_stmt|;
name|struct
name|req_pkt
name|reqpkt
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
name|int
name|n
decl_stmt|;
name|checkparent
argument_list|()
expr_stmt|;
comment|/* make sure our guy is still running */
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
name|openntp
argument_list|()
expr_stmt|;
comment|/* 	 * Try to clear out any previously received traffic so it 	 * doesn't fool us.  Note the socket is nonblocking. 	 */
while|while
condition|(
name|read
argument_list|(
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
name|REQ_LEN_MAC
argument_list|)
operator|>
literal|0
condition|)
comment|/* nothing */
empty_stmt|;
comment|/* 	 * Make up a request packet with the configuration info 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reqpkt
argument_list|)
argument_list|)
expr_stmt|;
name|reqpkt
operator|.
name|rm_vn_mode
operator|=
name|RM_VN_MODE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reqpkt
operator|.
name|auth_seq
operator|=
name|AUTH_SEQ
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* authenticated, no seq */
name|reqpkt
operator|.
name|implementation
operator|=
name|IMPL_XNTPD
expr_stmt|;
comment|/* local implementation */
name|reqpkt
operator|.
name|request
operator|=
name|REQ_CONFIG
expr_stmt|;
comment|/* configure a new peer */
name|reqpkt
operator|.
name|err_nitems
operator|=
name|ERR_NITEMS
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* one item */
name|reqpkt
operator|.
name|mbz_itemsize
operator|=
name|MBZ_ITEMSIZE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|conf_peer
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|reqpkt
operator|.
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|conf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|conf_peer
argument_list|)
argument_list|)
expr_stmt|;
name|reqpkt
operator|.
name|keyid
operator|=
name|htonl
argument_list|(
name|req_keyid
argument_list|)
expr_stmt|;
name|auth1crypt
argument_list|(
name|req_keyid
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
name|REQ_LEN_NOMAC
argument_list|)
expr_stmt|;
name|gettstamp
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|M_ADDUF
argument_list|(
name|ts
operator|.
name|l_ui
argument_list|,
name|ts
operator|.
name|l_uf
argument_list|,
name|SKEWTIME
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|reqpkt
operator|.
name|tstamp
argument_list|)
expr_stmt|;
name|n
operator|=
name|auth2crypt
argument_list|(
name|req_keyid
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
name|REQ_LEN_NOMAC
argument_list|)
expr_stmt|;
comment|/* 	 * Done.  Send it. 	 */
name|n
operator|=
name|write
argument_list|(
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
name|REQ_LEN_NOMAC
operator|+
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"send to NTP server failed: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* maybe should exit */
block|}
comment|/* 	 * Wait for a response.  A weakness of the mode 7 protocol used 	 * is that there is no way to associate a response with a 	 * particular request, i.e. the response to this configuration 	 * request is indistinguishable from that to any other.  I should 	 * fix this some day.  In any event, the time out is fairly 	 * pessimistic to make sure that if an answer is coming back 	 * at all, we get it. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|fdset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sockfd
argument_list|,
operator|&
name|fdset
argument_list|)
expr_stmt|;
name|tvout
operator|.
name|tv_sec
operator|=
name|TIMEOUT_SEC
expr_stmt|;
name|tvout
operator|.
name|tv_usec
operator|=
name|TIMEOUT_USEC
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|sockfd
operator|+
literal|1
argument_list|,
operator|&
name|fdset
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvout
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select() fails: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|n
operator|=
name|read
argument_list|(
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
name|REQ_LEN_MAC
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"read() fails: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
continue|continue;
block|}
comment|/* 		 * Got one.  Check through to make sure it is what 		 * we expect. 		 */
if|if
condition|(
name|n
operator|<
name|RESP_HEADER_SIZE
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"received runt response (%d octets)"
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|ISRESPONSE
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"received non-response packet\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|ISMORE
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"received fragmented packet\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|INFO_VERSION
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
operator|!=
name|NTP_VERSION
operator|||
name|INFO_MODE
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
operator|!=
name|MODE_PRIVATE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"version (%d) or mode (%d) incorrect\n"
argument_list|,
name|INFO_VERSION
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
argument_list|,
name|INFO_MODE
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|INFO_SEQ
argument_list|(
name|reqpkt
operator|.
name|auth_seq
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"nonzero sequence number (%d)\n"
argument_list|,
name|INFO_SEQ
argument_list|(
name|reqpkt
operator|.
name|auth_seq
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|reqpkt
operator|.
name|implementation
operator|!=
name|IMPL_XNTPD
operator|||
name|reqpkt
operator|.
name|request
operator|!=
name|REQ_CONFIG
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"implementation (%d) or request (%d) incorrect\n"
argument_list|,
name|reqpkt
operator|.
name|implementation
argument_list|,
name|reqpkt
operator|.
name|request
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|INFO_NITEMS
argument_list|(
name|reqpkt
operator|.
name|err_nitems
argument_list|)
operator|!=
literal|0
operator|||
name|INFO_MBZ
argument_list|(
name|reqpkt
operator|.
name|mbz_itemsize
argument_list|)
operator|!=
literal|0
operator|||
name|INFO_ITEMSIZE
argument_list|(
name|reqpkt
operator|.
name|mbz_itemsize
operator|!=
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"nitems (%d) mbz (%d) or itemsize (%d) nonzero\n"
argument_list|,
name|INFO_NITEMS
argument_list|(
name|reqpkt
operator|.
name|err_nitems
argument_list|)
argument_list|,
name|INFO_MBZ
argument_list|(
name|reqpkt
operator|.
name|mbz_itemsize
argument_list|)
argument_list|,
name|INFO_ITEMSIZE
argument_list|(
name|reqpkt
operator|.
name|mbz_itemsize
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
name|n
operator|=
name|INFO_ERR
argument_list|(
name|reqpkt
operator|.
name|err_nitems
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|INFO_OKAY
case|:
comment|/* success */
return|return
literal|1
return|;
case|case
name|INFO_ERR_IMPL
case|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server reports implementation mismatch!!"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|INFO_ERR_REQ
case|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server claims configuration request is unknown"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|INFO_ERR_FMT
case|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server indicates a format error occured(!!)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|INFO_ERR_NODATA
case|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server indicates no data available (shouldn't happen)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|INFO_ERR_AUTH
case|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server returns a permission denied error"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server returns unknown error code %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * nexttoken - return the next token from a line  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|nexttoken
parameter_list|(
name|lptr
parameter_list|)
name|char
modifier|*
modifier|*
name|lptr
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|tstart
decl_stmt|;
name|cp
operator|=
operator|*
name|lptr
expr_stmt|;
comment|/* 	 * Skip leading white space 	 */
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* 	 * If this is the end of the line, return nothing. 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
operator|||
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|lptr
operator|=
name|cp
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * Must be the start of a token.  Record the pointer and look 	 * for the end. 	 */
name|tstart
operator|=
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* 	 * Terminate the token with a \0.  If this isn't the end of the 	 * line, space to the next character. 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
operator|||
operator|*
name|cp
operator|==
literal|'\0'
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|lptr
operator|=
name|cp
expr_stmt|;
return|return
name|tstart
return|;
block|}
end_function

begin_comment
comment|/*  * readconf - read the configuration information out of the file we  *	      were passed.  Note that since the file is supposed to be  *	      machine generated, we bail out at the first sign of trouble.  */
end_comment

begin_function
specifier|static
name|void
name|readconf
parameter_list|(
name|fp
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|token
index|[
name|NUMTOK
index|]
decl_stmt|;
name|U_LONG
name|intval
index|[
name|NUMTOK
index|]
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINESIZE
index|]
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|MAXLINESIZE
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|bp
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMTOK
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|token
index|[
name|i
index|]
operator|=
name|nexttoken
argument_list|(
operator|&
name|bp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"tokenizing error in file `%s', quitting"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NUMTOK
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|atouint
argument_list|(
name|token
index|[
name|i
index|]
argument_list|,
operator|&
name|intval
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"format error for integer token `%s', file `%s', quitting"
argument_list|,
name|token
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|intval
index|[
name|TOK_HMODE
index|]
operator|!=
name|MODE_ACTIVE
operator|&&
name|intval
index|[
name|TOK_HMODE
index|]
operator|!=
name|MODE_CLIENT
operator|&&
name|intval
index|[
name|TOK_HMODE
index|]
operator|!=
name|MODE_BROADCAST
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid mode (%d) in file %s"
argument_list|,
name|intval
index|[
name|TOK_HMODE
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intval
index|[
name|TOK_VERSION
index|]
operator|>
name|NTP_VERSION
operator|||
name|intval
index|[
name|TOK_VERSION
index|]
operator|<
name|NTP_OLDVERSION
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid version (%d) in file %s"
argument_list|,
name|intval
index|[
name|TOK_VERSION
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intval
index|[
name|TOK_MINPOLL
index|]
operator|<
name|NTP_MINPOLL
operator|||
name|intval
index|[
name|TOK_MINPOLL
index|]
operator|>
name|NTP_MAXPOLL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid MINPOLL value (%d) in file %s"
argument_list|,
name|intval
index|[
name|TOK_MINPOLL
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intval
index|[
name|TOK_MAXPOLL
index|]
operator|<
name|NTP_MINPOLL
operator|||
name|intval
index|[
name|TOK_MAXPOLL
index|]
operator|>
name|NTP_MAXPOLL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid MAXPOLL value (%d) in file %s"
argument_list|,
name|intval
index|[
name|TOK_MAXPOLL
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|intval
index|[
name|TOK_FLAGS
index|]
operator|&
operator|~
operator|(
name|FLAG_AUTHENABLE
operator||
name|FLAG_PREFER
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid flags (%d) in file %s"
argument_list|,
name|intval
index|[
name|TOK_FLAGS
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|intval
index|[
name|TOK_FLAGS
index|]
operator|&
name|FLAG_AUTHENABLE
condition|)
name|flags
operator||=
name|CONF_FLAG_AUTHENABLE
expr_stmt|;
if|if
condition|(
name|intval
index|[
name|TOK_FLAGS
index|]
operator|&
name|FLAG_PREFER
condition|)
name|flags
operator||=
name|CONF_FLAG_PREFER
expr_stmt|;
comment|/* 		 * This is as good as we can check it.  Add it in. 		 */
name|addentry
argument_list|(
name|token
index|[
name|TOK_HOSTNAME
index|]
argument_list|,
operator|(
name|int
operator|)
name|intval
index|[
name|TOK_HMODE
index|]
argument_list|,
operator|(
name|int
operator|)
name|intval
index|[
name|TOK_VERSION
index|]
argument_list|,
operator|(
name|int
operator|)
name|intval
index|[
name|TOK_MINPOLL
index|]
argument_list|,
operator|(
name|int
operator|)
name|intval
index|[
name|TOK_MAXPOLL
index|]
argument_list|,
name|flags
argument_list|,
operator|(
name|int
operator|)
name|intval
index|[
name|TOK_TTL
index|]
argument_list|,
name|intval
index|[
name|TOK_KEYID
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * doconfigure - attempt to resolve names and configure the server  */
end_comment

begin_function
specifier|static
name|void
name|doconfigure
parameter_list|(
name|dores
parameter_list|)
name|int
name|dores
decl_stmt|;
block|{
specifier|register
name|struct
name|conf_entry
modifier|*
name|ce
decl_stmt|;
specifier|register
name|struct
name|conf_entry
modifier|*
name|ceremove
decl_stmt|;
name|ce
operator|=
name|confentries
expr_stmt|;
while|while
condition|(
name|ce
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dores
operator|&&
name|ce
operator|->
name|ce_peeraddr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|findhostaddr
argument_list|(
name|ce
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"couldn't resolve `%s', giving up on it"
argument_list|,
name|ce
operator|->
name|ce_name
argument_list|)
expr_stmt|;
name|ceremove
operator|=
name|ce
expr_stmt|;
name|ce
operator|=
name|ceremove
operator|->
name|ce_next
expr_stmt|;
name|removeentry
argument_list|(
name|ceremove
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|ce
operator|->
name|ce_peeraddr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|request
argument_list|(
operator|&
name|ce
operator|->
name|ce_config
argument_list|)
condition|)
block|{
name|ceremove
operator|=
name|ce
expr_stmt|;
name|ce
operator|=
name|ceremove
operator|->
name|ce_next
expr_stmt|;
name|removeentry
argument_list|(
name|ceremove
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|ce
operator|=
name|ce
operator|->
name|ce_next
expr_stmt|;
block|}
block|}
end_function

end_unit

