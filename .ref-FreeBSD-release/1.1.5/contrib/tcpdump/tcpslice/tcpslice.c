begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1987-1990 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1987-1990 The Regents of the University of California.\nAll rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#)$Header: tcpslice.c,v 1.10 92/06/02 17:57:44 mccanne Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * tcpslice - extract pieces of and/or glue together tcpdump files  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/timeb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|"savefile.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_decl_stmt
name|int
name|tflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global that util routines are sensitive to */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|thiszone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gmt to local correction in trace file */
end_comment

begin_comment
comment|/* Length of saved portion of packet. */
end_comment

begin_decl_stmt
name|int
name|snaplen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of saved portion of data past link level protocol.  */
end_comment

begin_decl_stmt
name|int
name|snapdlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Precision of clock used to generate trace file. */
end_comment

begin_decl_stmt
name|int
name|precision
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|linkinfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Style in which to print timestamps; RAW is "secs.usecs"; READABLE is  * ala the Unix "date" tool; and PARSEABLE is tcpslice's custom format,  * designed to be easy to parse.  The default is RAW.  */
end_comment

begin_enum
enum|enum
name|stamp_styles
block|{
name|TIMESTAMP_RAW
block|,
name|TIMESTAMP_READABLE
block|,
name|TIMESTAMP_PARSEABLE
block|}
enum|;
end_enum

begin_decl_stmt
name|enum
name|stamp_styles
name|timestamp_style
init|=
name|TIMESTAMP_RAW
decl_stmt|;
end_decl_stmt

begin_function_decl
name|time_t
name|gwtm2secs
parameter_list|(
comment|/* struct tm *tmp */
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|long
name|local_time_zone
parameter_list|(
comment|/* timestamp */
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|timeval
name|parse_time
parameter_list|(
comment|/* time_string, base_time*/
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fill_tm
parameter_list|(
comment|/* time_string, is_delta, t, usecs_addr */
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|get_file_range
parameter_list|(
comment|/* filename, first_time, last_time */
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|timeval
name|first_packet_time
parameter_list|(
comment|/* filename */
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|extract_slice
parameter_list|(
comment|/* filename, start_time, stop_time */
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|timestamp_to_string
parameter_list|(
comment|/* timestamp */
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_times
parameter_list|(
comment|/* filename */
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|op
decl_stmt|;
name|int
name|dump_flag
init|=
literal|0
decl_stmt|;
name|int
name|report_times
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|start_time_string
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|stop_time_string
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|write_file_name
init|=
literal|"-"
decl_stmt|;
comment|/* default is stdout */
name|struct
name|timeval
name|first_time
decl_stmt|,
name|start_time
decl_stmt|,
name|stop_time
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|,
name|opterr
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|op
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"dRrtw:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'d'
case|:
name|dump_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
operator|++
name|report_times
expr_stmt|;
name|timestamp_style
operator|=
name|TIMESTAMP_RAW
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|++
name|report_times
expr_stmt|;
name|timestamp_style
operator|=
name|TIMESTAMP_READABLE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|++
name|report_times
expr_stmt|;
name|timestamp_style
operator|=
name|TIMESTAMP_PARSEABLE
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|write_file_name
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|report_times
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"only one of -R, -r, or -t can be specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
comment|/* See if the next argument looks like a possible 		 * start time, and if so assume it is one. 		 */
if|if
condition|(
name|isdigit
argument_list|(
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
argument_list|)
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
name|start_time_string
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
if|if
condition|(
name|isdigit
argument_list|(
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
argument_list|)
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
name|stop_time_string
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|optind
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|"at least one input file must be given"
argument_list|)
expr_stmt|;
name|first_time
operator|=
name|first_packet_time
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|sf_readfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_time_string
condition|)
name|start_time
operator|=
name|parse_time
argument_list|(
name|start_time_string
argument_list|,
name|first_time
argument_list|)
expr_stmt|;
else|else
name|start_time
operator|=
name|first_time
expr_stmt|;
if|if
condition|(
name|stop_time_string
condition|)
name|stop_time
operator|=
name|parse_time
argument_list|(
name|stop_time_string
argument_list|,
name|start_time
argument_list|)
expr_stmt|;
else|else
block|{
name|stop_time
operator|=
name|start_time
expr_stmt|;
name|stop_time
operator|.
name|tv_sec
operator|+=
literal|86400
operator|*
literal|3660
expr_stmt|;
comment|/* + 10 years; "forever" */
block|}
if|if
condition|(
name|report_times
condition|)
block|{
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
operator|++
name|optind
control|)
name|dump_times
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_flag
condition|)
block|{
name|printf
argument_list|(
literal|"start\t%s\nstop\t%s\n"
argument_list|,
name|timestamp_to_string
argument_list|(
operator|&
name|start_time
argument_list|)
argument_list|,
name|timestamp_to_string
argument_list|(
operator|&
name|stop_time
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|report_times
operator|&&
operator|!
name|dump_flag
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|write_file_name
argument_list|,
literal|"-"
argument_list|)
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"stdout is a terminal; redirect or use -w"
argument_list|)
expr_stmt|;
name|sf_write_init
argument_list|(
name|write_file_name
argument_list|,
name|linkinfo
argument_list|,
name|thiszone
argument_list|,
name|snaplen
argument_list|,
name|precision
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
operator|++
name|optind
control|)
name|extract_slice
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
operator|&
name|start_time
argument_list|,
operator|&
name|stop_time
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|sf_writefile
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if a string matches the format for a timestamp,  * 0 otherwise.  */
end_comment

begin_function
name|int
name|is_timestamp
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|str
argument_list|)
operator|||
operator|*
name|str
operator|==
literal|'.'
condition|)
operator|++
name|str
expr_stmt|;
return|return
operator|*
name|str
operator|==
literal|'\0'
return|;
block|}
end_function

begin_comment
comment|/* Return the correction in seconds for the local time zone with respect  * to Greenwich time.  */
end_comment

begin_function
name|long
name|local_time_zone
parameter_list|(
name|timestamp
parameter_list|)
name|long
name|timestamp
decl_stmt|;
block|{
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
name|long
name|localzone
decl_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|tz
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"tcpslice: gettimeofday"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|localzone
operator|=
name|tz
operator|.
name|tz_minuteswest
operator|*
operator|-
literal|60
expr_stmt|;
if|if
condition|(
name|localtime
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|timestamp
argument_list|)
operator|->
name|tm_isdst
condition|)
name|localzone
operator|+=
literal|3600
expr_stmt|;
return|return
name|localzone
return|;
block|}
end_function

begin_comment
comment|/* Given a string specifying a time (or a time offset) and a "base time"  * from which to compute offsets and fill in defaults, returns a timeval  * containing the specified time.  */
end_comment

begin_function
name|struct
name|timeval
name|parse_time
parameter_list|(
name|time_string
parameter_list|,
name|base_time
parameter_list|)
name|char
modifier|*
name|time_string
decl_stmt|;
name|struct
name|timeval
name|base_time
decl_stmt|;
block|{
name|struct
name|tm
modifier|*
name|bt
init|=
name|localtime
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|base_time
operator|.
name|tv_sec
argument_list|)
decl_stmt|;
name|struct
name|tm
name|t
decl_stmt|;
name|struct
name|timeval
name|result
decl_stmt|;
name|time_t
name|usecs
init|=
literal|0
decl_stmt|;
name|int
name|is_delta
init|=
operator|(
name|time_string
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
decl_stmt|;
if|if
condition|(
name|is_delta
condition|)
operator|++
name|time_string
expr_stmt|;
comment|/* skip over '+' sign */
if|if
condition|(
name|is_timestamp
argument_list|(
name|time_string
argument_list|)
condition|)
block|{
comment|/* interpret as a raw timestamp or timestamp offset */
name|char
modifier|*
name|time_ptr
decl_stmt|;
name|result
operator|.
name|tv_sec
operator|=
name|atoi
argument_list|(
name|time_string
argument_list|)
expr_stmt|;
name|time_ptr
operator|=
name|strchr
argument_list|(
name|time_string
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_ptr
condition|)
block|{
comment|/* microseconds are specified, too */
name|int
name|num_digits
init|=
name|strlen
argument_list|(
name|time_ptr
operator|+
literal|1
argument_list|)
decl_stmt|;
name|result
operator|.
name|tv_usec
operator|=
name|atoi
argument_list|(
name|time_ptr
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* turn 123.456 into 123 seconds plus 456000 usec */
while|while
condition|(
name|num_digits
operator|++
operator|<
literal|6
condition|)
name|result
operator|.
name|tv_usec
operator|*=
literal|10
expr_stmt|;
block|}
else|else
name|result
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_delta
condition|)
block|{
name|result
operator|.
name|tv_sec
operator|+=
name|base_time
operator|.
name|tv_sec
expr_stmt|;
name|result
operator|.
name|tv_usec
operator|+=
name|base_time
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|tv_usec
operator|>
literal|1000000
condition|)
block|{
name|result
operator|.
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
operator|++
name|result
operator|.
name|tv_sec
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
if|if
condition|(
name|is_delta
condition|)
block|{
name|t
operator|=
operator|*
name|bt
expr_stmt|;
name|usecs
operator|=
name|base_time
operator|.
name|tv_usec
expr_stmt|;
block|}
else|else
block|{
comment|/* Zero struct (easy way around lack of tm_gmtoff/tm_zone 		 * under older systems) */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set values to "not set" flag so we can later identify 		 * and default them. 		 */
name|t
operator|.
name|tm_sec
operator|=
name|t
operator|.
name|tm_min
operator|=
name|t
operator|.
name|tm_hour
operator|=
name|t
operator|.
name|tm_mday
operator|=
name|t
operator|.
name|tm_mon
operator|=
name|t
operator|.
name|tm_year
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|fill_tm
argument_list|(
name|time_string
argument_list|,
name|is_delta
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|usecs
argument_list|)
expr_stmt|;
comment|/* Now until we reach a field that was specified, fill in the 	 * missing fields from the base time. 	 */
define|#
directive|define
name|CHECK_FIELD
parameter_list|(
name|field_name
parameter_list|)
define|\
value|if (t.field_name< 0) 			\ 		t.field_name = bt->field_name;	\ 	else					\ 		break
do|do
block|{
comment|/* bogus do-while loop so "break" in CHECK_FIELD will work */
name|CHECK_FIELD
argument_list|(
name|tm_year
argument_list|)
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|tm_mon
argument_list|)
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|tm_mday
argument_list|)
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|tm_hour
argument_list|)
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|tm_min
argument_list|)
expr_stmt|;
name|CHECK_FIELD
argument_list|(
name|tm_sec
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|/* Set remaining unspecified fields to 0. */
define|#
directive|define
name|ZERO_FIELD_IF_NOT_SET
parameter_list|(
name|field_name
parameter_list|,
name|zero_val
parameter_list|)
define|\
value|if (t.field_name< 0)				\ 		t.field_name = zero_val
if|if
condition|(
operator|!
name|is_delta
condition|)
block|{
name|ZERO_FIELD_IF_NOT_SET
argument_list|(
name|tm_year
argument_list|,
literal|90
argument_list|)
expr_stmt|;
comment|/* should never happen */
name|ZERO_FIELD_IF_NOT_SET
argument_list|(
name|tm_mon
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZERO_FIELD_IF_NOT_SET
argument_list|(
name|tm_mday
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ZERO_FIELD_IF_NOT_SET
argument_list|(
name|tm_hour
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZERO_FIELD_IF_NOT_SET
argument_list|(
name|tm_min
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZERO_FIELD_IF_NOT_SET
argument_list|(
name|tm_sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|tv_sec
operator|=
name|gwtm2secs
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|result
operator|.
name|tv_sec
operator|-=
name|local_time_zone
argument_list|(
name|result
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|result
operator|.
name|tv_usec
operator|=
name|usecs
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Fill in (or add to, if is_delta is true) the time values in the  * tm struct "t" as specified by the time specified in the string  * "time_string".  "usecs_addr" is updated with the specified number  * of microseconds, if any.  */
end_comment

begin_function
name|void
name|fill_tm
parameter_list|(
name|time_string
parameter_list|,
name|is_delta
parameter_list|,
name|t
parameter_list|,
name|usecs_addr
parameter_list|)
name|char
modifier|*
name|time_string
decl_stmt|;
name|int
name|is_delta
decl_stmt|;
comment|/* if true, add times in instead of replacing */
name|struct
name|tm
modifier|*
name|t
decl_stmt|;
comment|/* tm struct to be filled from time_string */
name|time_t
modifier|*
name|usecs_addr
decl_stmt|;
block|{
name|char
modifier|*
name|t_start
decl_stmt|,
modifier|*
name|t_stop
decl_stmt|,
name|format_ch
decl_stmt|;
name|int
name|val
decl_stmt|;
define|#
directive|define
name|SET_VAL
parameter_list|(
name|lhs
parameter_list|,
name|rhs
parameter_list|)
define|\
value|if (is_delta)		\ 		lhs += rhs;	\ 	else			\ 		lhs = rhs
comment|/* Loop through the time string parsing one specification at 	 * a time.  Each specification has the form<number><letter> 	 * where<number> indicates the amount of time and<letter> 	 * the units. 	 */
for|for
control|(
name|t_stop
operator|=
name|t_start
operator|=
name|time_string
init|;
operator|*
name|t_start
condition|;
name|t_start
operator|=
operator|++
name|t_stop
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|t_start
argument_list|)
condition|)
name|error
argument_list|(
literal|"bad date format %s, problem starting at %s"
argument_list|,
name|time_string
argument_list|,
name|t_start
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|t_stop
argument_list|)
condition|)
operator|++
name|t_stop
expr_stmt|;
if|if
condition|(
operator|!
name|t_stop
condition|)
name|error
argument_list|(
literal|"bad date format %s, problem starting at %s"
argument_list|,
name|time_string
argument_list|,
name|t_start
argument_list|)
expr_stmt|;
name|val
operator|=
name|atoi
argument_list|(
name|t_start
argument_list|)
expr_stmt|;
name|format_ch
operator|=
operator|*
name|t_stop
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|format_ch
argument_list|)
condition|)
name|format_ch
operator|=
name|tolower
argument_list|(
name|format_ch
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|format_ch
condition|)
block|{
case|case
literal|'y'
case|:
if|if
condition|(
name|val
operator|>
literal|1900
condition|)
name|val
operator|-=
literal|1900
expr_stmt|;
name|SET_VAL
argument_list|(
name|t
operator|->
name|tm_year
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|strchr
argument_list|(
name|t_stop
operator|+
literal|1
argument_list|,
literal|'D'
argument_list|)
operator|||
name|strchr
argument_list|(
name|t_stop
operator|+
literal|1
argument_list|,
literal|'d'
argument_list|)
condition|)
comment|/* it's months */
name|SET_VAL
argument_list|(
name|t
operator|->
name|tm_mon
argument_list|,
name|val
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* it's minutes */
name|SET_VAL
argument_list|(
name|t
operator|->
name|tm_min
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|SET_VAL
argument_list|(
name|t
operator|->
name|tm_mday
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|SET_VAL
argument_list|(
name|t
operator|->
name|tm_hour
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|SET_VAL
argument_list|(
name|t
operator|->
name|tm_sec
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|SET_VAL
argument_list|(
operator|*
name|usecs_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"bad date format %s, problem starting at %s"
argument_list|,
name|time_string
argument_list|,
name|t_start
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return in first_time and last_time the timestamps of the first and  * last packets in the given file.  */
end_comment

begin_function
name|void
name|get_file_range
parameter_list|(
name|filename
parameter_list|,
name|first_time
parameter_list|,
name|last_time
parameter_list|)
name|char
name|filename
index|[]
decl_stmt|;
name|struct
name|timeval
modifier|*
name|first_time
decl_stmt|;
name|struct
name|timeval
modifier|*
name|last_time
decl_stmt|;
block|{
operator|*
name|first_time
operator|=
name|first_packet_time
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sf_find_end
argument_list|(
name|first_time
argument_list|,
name|last_time
argument_list|)
condition|)
name|error
argument_list|(
literal|"couldn't find final packet in file %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the timestamp of the first packet in the given tcpdump save  * file, which as a side-effect is initialized for further save-file  * reading.  */
end_comment

begin_function
name|struct
name|timeval
name|first_packet_time
parameter_list|(
name|filename
parameter_list|)
name|char
name|filename
index|[]
decl_stmt|;
block|{
name|struct
name|packet_header
name|hdr
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|sf_read_init
argument_list|(
name|filename
argument_list|,
operator|&
name|linkinfo
argument_list|,
operator|&
name|thiszone
argument_list|,
operator|&
name|snaplen
argument_list|,
operator|&
name|precision
argument_list|)
condition|)
name|error
argument_list|(
literal|"bad tcpdump file %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|snaplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf_next_packet
argument_list|(
operator|&
name|hdr
argument_list|,
name|buf
argument_list|,
name|snaplen
argument_list|)
condition|)
name|error
argument_list|(
literal|"bad status reading first packet in %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
return|return
name|hdr
operator|.
name|ts
return|;
block|}
end_function

begin_comment
comment|/* Extract from the given file all packets with timestamps between  * the two time values given (inclusive).  These packets are written  * to the save file output set up by a previous call to sf_write_init().  * Upon return, start_time is adjusted to reflect a time just after  * that of the last packet written to the output.  */
end_comment

begin_function
name|void
name|extract_slice
parameter_list|(
name|filename
parameter_list|,
name|start_time
parameter_list|,
name|stop_time
parameter_list|)
name|char
name|filename
index|[]
decl_stmt|;
name|struct
name|timeval
modifier|*
name|start_time
decl_stmt|;
name|struct
name|timeval
modifier|*
name|stop_time
decl_stmt|;
block|{
name|long
name|start_pos
decl_stmt|,
name|stop_pos
decl_stmt|;
name|struct
name|timeval
name|file_start_time
decl_stmt|,
name|file_stop_time
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|packet_header
name|hdr
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|sf_read_init
argument_list|(
name|filename
argument_list|,
operator|&
name|linkinfo
argument_list|,
operator|&
name|thiszone
argument_list|,
operator|&
name|snaplen
argument_list|,
operator|&
name|precision
argument_list|)
condition|)
name|error
argument_list|(
literal|"bad tcpdump file %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|snaplen
argument_list|)
expr_stmt|;
name|start_pos
operator|=
name|ftell
argument_list|(
name|sf_readfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|sf_next_packet
argument_list|(
operator|&
name|hdr
argument_list|,
name|buf
argument_list|,
name|snaplen
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"bad status %d reading packet in %s"
argument_list|,
name|status
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|file_start_time
operator|=
name|hdr
operator|.
name|ts
expr_stmt|;
if|if
condition|(
operator|!
name|sf_find_end
argument_list|(
operator|&
name|file_start_time
argument_list|,
operator|&
name|file_stop_time
argument_list|)
condition|)
name|error
argument_list|(
literal|"problems finding end packet of file %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|stop_pos
operator|=
name|ftell
argument_list|(
name|sf_readfile
argument_list|)
expr_stmt|;
comment|/* sf_find_packet() requires that the time it's passed as its last 	 * argument be in the range [min_time, max_time], so we enforce 	 * that constraint here. 	 */
if|if
condition|(
name|sf_timestamp_less_than
argument_list|(
name|start_time
argument_list|,
operator|&
name|file_start_time
argument_list|)
condition|)
operator|*
name|start_time
operator|=
name|file_start_time
expr_stmt|;
if|if
condition|(
name|sf_timestamp_less_than
argument_list|(
operator|&
name|file_stop_time
argument_list|,
name|start_time
argument_list|)
condition|)
return|return;
comment|/* there aren't any packets of interest in the file */
name|sf_find_packet
argument_list|(
operator|&
name|file_start_time
argument_list|,
name|start_pos
argument_list|,
operator|&
name|file_stop_time
argument_list|,
name|stop_pos
argument_list|,
name|start_time
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|timeval
modifier|*
name|timestamp
decl_stmt|;
name|status
operator|=
name|sf_next_packet
argument_list|(
operator|&
name|hdr
argument_list|,
name|buf
argument_list|,
name|snaplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|status
operator|!=
name|SFERR_EOF
condition|)
name|error
argument_list|(
literal|"bad status %d reading packet in %s"
argument_list|,
name|status
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
block|}
name|timestamp
operator|=
operator|&
name|hdr
operator|.
name|ts
expr_stmt|;
if|if
condition|(
operator|!
name|sf_timestamp_less_than
argument_list|(
name|timestamp
argument_list|,
name|start_time
argument_list|)
condition|)
block|{
comment|/* packet is recent enough */
if|if
condition|(
name|sf_timestamp_less_than
argument_list|(
name|stop_time
argument_list|,
name|timestamp
argument_list|)
condition|)
comment|/* We've gone beyond the end of the region 				 * of interest ... We're done with this file. 				 */
break|break;
name|sf_write
argument_list|(
name|buf
argument_list|,
name|timestamp
argument_list|,
operator|(
name|int
operator|)
name|hdr
operator|.
name|len
argument_list|,
operator|(
name|int
operator|)
name|hdr
operator|.
name|caplen
argument_list|)
expr_stmt|;
operator|*
name|start_time
operator|=
operator|*
name|timestamp
expr_stmt|;
comment|/* We know that each packet is guaranteed to have 			 * a unique timestamp, so we push forward the 			 * allowed minimum time to weed out duplicate 			 * packets. 			 */
operator|++
name|start_time
operator|->
name|tv_usec
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|sf_readfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translates a timestamp to the time format specified by the user.  * Returns a pointer to the translation residing in a static buffer.  * There are two such buffers, which are alternated on subseqeuent  * calls, so two calls may be made to this routine without worrying  * about the results of the first call being overwritten by the  * results of the second.  */
end_comment

begin_function
name|char
modifier|*
name|timestamp_to_string
parameter_list|(
name|timestamp
parameter_list|)
name|struct
name|timeval
modifier|*
name|timestamp
decl_stmt|;
block|{
name|struct
name|tm
modifier|*
name|t
decl_stmt|;
define|#
directive|define
name|NUM_BUFFERS
value|2
specifier|static
name|char
name|buffers
index|[
name|NUM_BUFFERS
index|]
index|[
literal|128
index|]
decl_stmt|;
specifier|static
name|int
name|buffer_to_use
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|buffers
index|[
name|buffer_to_use
index|]
expr_stmt|;
name|buffer_to_use
operator|=
operator|(
name|buffer_to_use
operator|+
literal|1
operator|)
operator|%
name|NUM_BUFFERS
expr_stmt|;
switch|switch
condition|(
name|timestamp_style
condition|)
block|{
case|case
name|TIMESTAMP_RAW
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d.%d"
argument_list|,
name|timestamp
operator|->
name|tv_sec
argument_list|,
name|timestamp
operator|->
name|tv_usec
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIMESTAMP_READABLE
case|:
name|t
operator|=
name|localtime
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|timestamp
operator|->
name|tv_sec
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|asctime
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* nuke final newline */
break|break;
case|case
name|TIMESTAMP_PARSEABLE
case|:
name|t
operator|=
name|localtime
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|timestamp
operator|->
name|tv_sec
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%02dy%02dm%02dd%02dh%02dm%02ds%06du"
argument_list|,
name|t
operator|->
name|tm_year
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|,
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|,
name|timestamp
operator|->
name|tv_usec
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Given a tcpdump save filename, reports on the times of the first  * and last packets in the file.  */
end_comment

begin_function
name|void
name|dump_times
parameter_list|(
name|filename
parameter_list|)
name|char
name|filename
index|[]
decl_stmt|;
block|{
name|struct
name|timeval
name|first_time
decl_stmt|,
name|last_time
decl_stmt|;
name|get_file_range
argument_list|(
name|filename
argument_list|,
operator|&
name|first_time
argument_list|,
operator|&
name|last_time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\t%s\t%s\n"
argument_list|,
name|filename
argument_list|,
name|timestamp_to_string
argument_list|(
operator|&
name|first_time
argument_list|)
argument_list|,
name|timestamp_to_string
argument_list|(
operator|&
name|last_time
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tcpslice for tcpdump version %d.%d\n"
argument_list|,
name|VERSION_MAJOR
argument_list|,
name|VERSION_MINOR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: tcpslice [-dRrt] [-w file] [start-time [end-time]] file ... \n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

