begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* display.c -- readline redisplay facility. */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 1, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|strchr
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strchr
argument_list|()
decl_stmt|,
modifier|*
name|strrchr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !strchr&& !__STDC__ */
end_comment

begin_comment
comment|/* Global and pseudo-global variables and functions    imported from readline.c. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|readline_echoing_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|term_clreol
decl_stmt|,
modifier|*
name|term_im
decl_stmt|,
modifier|*
name|term_ic
decl_stmt|,
modifier|*
name|term_ei
decl_stmt|,
modifier|*
name|term_DC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Termcap variables. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|term_up
decl_stmt|,
modifier|*
name|term_dc
decl_stmt|,
modifier|*
name|term_cr
decl_stmt|,
modifier|*
name|term_IC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screenheight
decl_stmt|,
name|screenwidth
decl_stmt|,
name|screenchars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|terminal_can_insert
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|_rl_output_some_chars
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|_rl_output_character_function
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|_rl_output_meta_chars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_rl_horizontal_scroll_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_rl_mark_modified_lines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_rl_prefer_visible_bell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pseudo-global functions (local to the readline library) exported    by this file. */
end_comment

begin_decl_stmt
name|void
name|_rl_move_cursor_relative
argument_list|()
decl_stmt|,
name|_rl_output_some_chars
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|_rl_move_vert
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|update_line
argument_list|()
decl_stmt|,
name|clear_to_eol
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_chars
argument_list|()
decl_stmt|,
name|insert_some_chars
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Display stuff				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* This is the stuff that is hard for me.  I never seem to write good    display routines in C.  Let's see how I do this time. */
end_comment

begin_comment
comment|/* (PWP) Well... Good for a simple line updater, but totally ignores    the problems of input lines longer than the screen width.     update_line and the code that calls it makes a multiple line,    automatically wrapping line update.  Carefull attention needs    to be paid to the vertical position variables.     handling of terminals with autowrap on (incl. DEC braindamage)    could be improved a bit.  Right now I just cheat and decrement    screenwidth by one. */
end_comment

begin_comment
comment|/* Keep two buffers; one which reflects the current contents of the    screen, and the other to draw what we think the new contents should    be.  Then compare the buffers, and make whatever changes to the    screen itself that we should.  Finally, make the buffer that we    just drew into be the one which reflects the current contents of the    screen, and place the cursor where it belongs.     Commands that want to can fix the display themselves, and then let    this function know that the display has been fixed by setting the    RL_DISPLAY_FIXED variable.  This is good for efficiency. */
end_comment

begin_comment
comment|/* Global variables declared here. */
end_comment

begin_comment
comment|/* What YOU turn on when you have handled all redisplay yourself. */
end_comment

begin_decl_stmt
name|int
name|rl_display_fixed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The stuff that gets printed out before the actual text of the line.    This is usually pointing to rl_prompt. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_display_prompt
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pseudo-global variables declared here. */
end_comment

begin_comment
comment|/* The visible cursor position.  If you print some text, adjust this. */
end_comment

begin_decl_stmt
name|int
name|_rl_last_c_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_rl_last_v_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of lines currently on screen minus 1. */
end_comment

begin_decl_stmt
name|int
name|_rl_vis_botlin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables used only in this file. */
end_comment

begin_comment
comment|/* The last left edge of text that was displayed.  This is used when    doing horizontal scrolling.  It shifts in thirds of a screenwidth. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_lmargin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The line display buffers.  One is the line currently displayed on    the screen.  The other is the line about to be displayed. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|visible_line
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|invisible_line
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A buffer for `modeline' messages. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|msg_buf
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero forces the redisplay even if we thought it was unnecessary. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|forced_display
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default and initial buffer size.  Can grow. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_size
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_prompt_string
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|local_prompt
decl_stmt|,
modifier|*
name|local_prompt_prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|visible_length
decl_stmt|,
name|prefix_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of invisible characters in the line currently being    displayed on the screen. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|visible_wrap_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The length (buffer offset) of the first line of the last (possibly    multi-line) buffer displayed on the screen. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|visible_first_line_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand the prompt string S and return the number of visible    characters in *LP, if LP is not null.  This is currently more-or-less    a placeholder for expansion. */
end_comment

begin_comment
comment|/* Current implementation: 	\001 (^A) start non-visible characters 	\002 (^B) end non-visible characters    all characters except \001 and \002 (following a \001) are copied to    the returned string; all characters except those between \001 and    \002 are assumed to be `visible'. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|expand_prompt
parameter_list|(
name|pmt
parameter_list|,
name|lp
parameter_list|)
name|char
modifier|*
name|pmt
decl_stmt|;
name|int
modifier|*
name|lp
decl_stmt|;
block|{
name|char
modifier|*
name|r
decl_stmt|,
modifier|*
name|ret
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|,
name|rl
decl_stmt|,
name|ignoring
decl_stmt|;
comment|/* Short-circuit if we can. */
if|if
condition|(
name|strchr
argument_list|(
name|pmt
argument_list|,
name|RL_PROMPT_START_IGNORE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|savestring
argument_list|(
name|pmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
condition|)
operator|*
name|lp
operator|=
name|strlen
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|l
operator|=
name|strlen
argument_list|(
name|pmt
argument_list|)
expr_stmt|;
name|r
operator|=
name|ret
operator|=
name|xmalloc
argument_list|(
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|rl
operator|=
name|ignoring
operator|=
literal|0
operator|,
name|p
operator|=
name|pmt
init|;
name|p
operator|&&
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
comment|/* This code strips the invisible character string markers 	 RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE */
if|if
condition|(
operator|*
name|p
operator|==
name|RL_PROMPT_START_IGNORE
condition|)
block|{
name|ignoring
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ignoring
operator|&&
operator|*
name|p
operator|==
name|RL_PROMPT_END_IGNORE
condition|)
block|{
name|ignoring
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
block|{
operator|*
name|r
operator|++
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|ignoring
condition|)
name|rl
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lp
condition|)
operator|*
name|lp
operator|=
name|rl
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Expand the prompt string into the various display components, if  * necessary.  *  * local_prompt = expanded last line of string in rl_display_prompt  *		  (portion after the final newline)  * local_prompt_prefix = portion before last newline of rl_display_prompt,  *			 expanded via expand_prompt  * visible_length = number of visible characters in local_prompt  * prefix_length = number of visible characters in local_prompt_prefix  *  * This function is called once per call to readline().  It may also be  * called arbitrarily to expand the primary prompt.  *  * The return value is the number of visible characters on the last line  * of the (possibly multi-line) prompt.  */
end_comment

begin_function
name|int
name|rl_expand_prompt
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Clear out any saved values. */
if|if
condition|(
name|local_prompt
condition|)
name|free
argument_list|(
name|local_prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_prompt_prefix
condition|)
name|free
argument_list|(
name|local_prompt_prefix
argument_list|)
expr_stmt|;
name|local_prompt
operator|=
name|local_prompt_prefix
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|prompt
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
comment|/* The prompt is only one line. */
name|local_prompt
operator|=
name|expand_prompt
argument_list|(
name|prompt
argument_list|,
operator|&
name|visible_length
argument_list|)
expr_stmt|;
name|local_prompt_prefix
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|visible_length
operator|)
return|;
block|}
else|else
block|{
comment|/* The prompt spans multiple lines. */
name|t
operator|=
operator|++
name|p
expr_stmt|;
name|local_prompt
operator|=
name|expand_prompt
argument_list|(
name|p
argument_list|,
operator|&
name|visible_length
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|t
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
comment|/* The portion of the prompt string up to and including the 	 final newline is now null-terminated. */
name|local_prompt_prefix
operator|=
name|expand_prompt
argument_list|(
name|prompt
argument_list|,
operator|&
name|prefix_length
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|prefix_length
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Basic redisplay algorithm. */
end_comment

begin_function
name|void
name|rl_redisplay
parameter_list|()
block|{
specifier|register
name|int
name|in
decl_stmt|,
name|out
decl_stmt|,
name|c
decl_stmt|,
name|linenum
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
init|=
name|invisible_line
decl_stmt|;
name|int
name|c_pos
init|=
literal|0
decl_stmt|,
name|inv_botlin
init|=
literal|0
decl_stmt|,
name|wrap_offset
decl_stmt|,
name|wrap_column
decl_stmt|;
name|char
modifier|*
name|prompt_this_line
decl_stmt|;
if|if
condition|(
operator|!
name|readline_echoing_p
condition|)
return|return;
if|if
condition|(
operator|!
name|rl_display_prompt
condition|)
name|rl_display_prompt
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|!
name|invisible_line
condition|)
block|{
name|visible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
name|invisible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
name|line
operator|=
name|invisible_line
expr_stmt|;
for|for
control|(
name|in
operator|=
literal|0
init|;
name|in
operator|<
name|line_size
condition|;
name|in
operator|++
control|)
block|{
name|visible_line
index|[
name|in
index|]
operator|=
literal|0
expr_stmt|;
name|invisible_line
index|[
name|in
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|rl_on_new_line
argument_list|()
expr_stmt|;
block|}
comment|/* Draw the line into the buffer. */
name|c_pos
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Mark the line as modified or not.  We only do this for history      lines. */
name|out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|_rl_mark_modified_lines
operator|&&
name|current_history
argument_list|()
operator|&&
name|rl_undo_list
condition|)
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'*'
expr_stmt|;
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* If someone thought that the redisplay was handled, but the currently      visible line has a different modification state than the one about      to become visible, then correct the caller's misconception. */
if|if
condition|(
name|visible_line
index|[
literal|0
index|]
operator|!=
name|invisible_line
index|[
literal|0
index|]
condition|)
name|rl_display_fixed
operator|=
literal|0
expr_stmt|;
comment|/* If the prompt to be displayed is the `primary' readline prompt (the      one passed to readline()), use the values we have already expanded.      If not, use what's already in rl_display_prompt.  WRAP_OFFSET is the      number of non-visible characters in the prompt string. */
if|if
condition|(
name|rl_display_prompt
operator|==
name|rl_prompt
condition|)
block|{
name|int
name|local_len
init|=
name|strlen
argument_list|(
name|local_prompt
argument_list|)
decl_stmt|;
if|if
condition|(
name|local_prompt_prefix
operator|&&
name|forced_display
condition|)
name|_rl_output_some_chars
argument_list|(
name|local_prompt_prefix
argument_list|,
name|strlen
argument_list|(
name|local_prompt_prefix
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_prompt
condition|)
name|strncpy
argument_list|(
name|line
operator|+
name|out
argument_list|,
name|local_prompt
argument_list|,
name|local_len
argument_list|)
expr_stmt|;
name|out
operator|+=
name|local_len
expr_stmt|;
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wrap_offset
operator|=
name|local_len
operator|-
name|visible_length
expr_stmt|;
block|}
else|else
block|{
name|int
name|pmtlen
decl_stmt|;
name|prompt_this_line
operator|=
name|strrchr
argument_list|(
name|rl_display_prompt
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prompt_this_line
condition|)
name|prompt_this_line
operator|=
name|rl_display_prompt
expr_stmt|;
else|else
block|{
name|prompt_this_line
operator|++
expr_stmt|;
if|if
condition|(
name|forced_display
condition|)
name|_rl_output_some_chars
argument_list|(
name|rl_display_prompt
argument_list|,
name|prompt_this_line
operator|-
name|rl_display_prompt
argument_list|)
expr_stmt|;
block|}
name|pmtlen
operator|=
name|strlen
argument_list|(
name|prompt_this_line
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|line
operator|+
name|out
argument_list|,
name|prompt_this_line
argument_list|,
name|pmtlen
argument_list|)
expr_stmt|;
name|out
operator|+=
name|pmtlen
expr_stmt|;
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wrap_offset
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|in
operator|=
literal|0
init|;
name|in
operator|<
name|rl_end
condition|;
name|in
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|rl_line_buffer
index|[
name|in
index|]
expr_stmt|;
if|if
condition|(
name|out
operator|+
literal|8
operator|>=
name|line_size
condition|)
comment|/* XXX - 8 for \t */
block|{
name|line_size
operator|*=
literal|2
expr_stmt|;
name|visible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|visible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|invisible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|invisible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|line
operator|=
name|invisible_line
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|==
name|rl_point
condition|)
name|c_pos
operator|=
name|out
expr_stmt|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|_rl_output_meta_chars
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|line
operator|+
name|out
argument_list|,
literal|"\\%o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|line
index|[
name|out
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DISPLAY_TABS
argument_list|)
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
specifier|register
name|int
name|newout
init|=
operator|(
name|out
operator||
operator|(
name|int
operator|)
literal|7
operator|)
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|out
operator|<
name|newout
condition|)
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|c
operator|<
literal|' '
condition|)
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'^'
expr_stmt|;
name|line
index|[
name|out
operator|++
index|]
operator|=
name|UNCTRL
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* XXX was c ^ 0x40 */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|127
condition|)
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'^'
expr_stmt|;
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
name|line
index|[
name|out
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c_pos
operator|<
literal|0
condition|)
name|c_pos
operator|=
name|out
expr_stmt|;
comment|/* C_POS == position in buffer where cursor should be placed. */
comment|/* PWP: now is when things get a bit hairy.  The visible and invisible      line buffers are really multiple lines, which would wrap every      (screenwidth - 1) characters.  Go through each in turn, finding      the changed region and updating it.  The line order is top to bottom. */
comment|/* If we can move the cursor up and down, then use multiple lines,      otherwise, let long lines display in a single terminal line, and      horizontally scroll it. */
if|if
condition|(
operator|!
name|_rl_horizontal_scroll_mode
operator|&&
name|term_up
operator|&&
operator|*
name|term_up
condition|)
block|{
name|int
name|total_screen_chars
init|=
name|screenchars
decl_stmt|;
name|int
name|nleft
decl_stmt|,
name|cursor_linenum
decl_stmt|,
name|pos
decl_stmt|;
if|if
condition|(
operator|!
name|rl_display_fixed
operator|||
name|forced_display
condition|)
block|{
name|forced_display
operator|=
literal|0
expr_stmt|;
comment|/* If we have more than a screenful of material to display, then 	     only display a screenful.  We should display the last screen, 	     not the first.  I'll fix this in a minute. */
if|if
condition|(
name|out
operator|>=
name|total_screen_chars
condition|)
name|out
operator|=
name|total_screen_chars
operator|-
literal|1
expr_stmt|;
comment|/* Number of screen lines to display.  The first line wraps at 	     (screenwidth + wrap_offset) chars, the rest of the lines have 	     screenwidth chars. */
name|nleft
operator|=
name|out
operator|-
name|screenwidth
operator|-
name|wrap_offset
expr_stmt|;
if|if
condition|(
name|nleft
operator|>
literal|0
condition|)
name|inv_botlin
operator|=
literal|1
operator|+
name|nleft
operator|/
name|screenwidth
expr_stmt|;
else|else
name|inv_botlin
operator|=
literal|0
expr_stmt|;
comment|/* The first line is at character position 0 in the buffer.  The 	     second and subsequent lines start at N * screenwidth, offset by 	     OFFSET.  OFFSET is wrap_offset for the invisible line and 	     visible_wrap_offset for the line currently displayed. */
define|#
directive|define
name|L_OFFSET
parameter_list|(
name|n
parameter_list|,
name|offset
parameter_list|)
value|((n)> 0 ? ((n) * screenwidth) + (offset) : 0)
define|#
directive|define
name|VIS_CHARS
parameter_list|(
name|line
parameter_list|)
value|&visible_line[L_OFFSET((line), visible_wrap_offset)]
define|#
directive|define
name|VIS_LINE
parameter_list|(
name|line
parameter_list|)
value|((line)> _rl_vis_botlin) ? "" : VIS_CHARS(line)
define|#
directive|define
name|INV_LINE
parameter_list|(
name|line
parameter_list|)
value|&invisible_line[L_OFFSET((line), wrap_offset)]
comment|/* For each line in the buffer, do the updating display. */
for|for
control|(
name|linenum
operator|=
literal|0
init|;
name|linenum
operator|<=
name|inv_botlin
condition|;
name|linenum
operator|++
control|)
block|{
name|update_line
argument_list|(
name|VIS_LINE
argument_list|(
name|linenum
argument_list|)
argument_list|,
name|INV_LINE
argument_list|(
name|linenum
argument_list|)
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
comment|/* If this is the line with the prompt, we might need to 		 compensate for invisible characters in the new line. Do 		 this only if there is not more than one new line (which 		 implies that we completely overwrite the old visible line) 		 and the new line is shorter than the old. */
if|if
condition|(
name|linenum
operator|==
literal|0
operator|&&
name|inv_botlin
operator|==
literal|0
operator|&&
operator|(
name|wrap_offset
operator|>
name|visible_wrap_offset
operator|)
operator|&&
operator|(
name|_rl_last_c_pos
operator|<
name|visible_first_line_len
operator|)
condition|)
block|{
name|nleft
operator|=
name|screenwidth
operator|+
name|wrap_offset
operator|-
name|_rl_last_c_pos
expr_stmt|;
name|clear_to_eol
argument_list|(
name|nleft
argument_list|)
expr_stmt|;
block|}
comment|/* Since the new first line is now visible, save its length. */
if|if
condition|(
name|linenum
operator|==
literal|0
condition|)
name|visible_first_line_len
operator|=
name|_rl_last_c_pos
expr_stmt|;
block|}
comment|/* We may have deleted some lines.  If so, clear the left over 	     blank ones at the bottom out. */
if|if
condition|(
name|_rl_vis_botlin
operator|>
name|inv_botlin
condition|)
block|{
name|char
modifier|*
name|tt
decl_stmt|;
for|for
control|(
init|;
name|linenum
operator|<=
name|_rl_vis_botlin
condition|;
name|linenum
operator|++
control|)
block|{
name|tt
operator|=
name|VIS_CHARS
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
name|_rl_move_vert
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
name|_rl_move_cursor_relative
argument_list|(
literal|0
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|clear_to_eol
argument_list|(
operator|(
name|linenum
operator|==
name|_rl_vis_botlin
operator|)
condition|?
name|strlen
argument_list|(
name|tt
argument_list|)
else|:
name|screenwidth
argument_list|)
expr_stmt|;
block|}
block|}
name|_rl_vis_botlin
operator|=
name|inv_botlin
expr_stmt|;
comment|/* Move the cursor where it should be. */
comment|/* Which line? */
name|nleft
operator|=
name|c_pos
operator|-
name|screenwidth
operator|-
name|wrap_offset
expr_stmt|;
if|if
condition|(
name|nleft
operator|>
literal|0
condition|)
name|cursor_linenum
operator|=
literal|1
operator|+
name|nleft
operator|/
name|screenwidth
expr_stmt|;
else|else
name|cursor_linenum
operator|=
literal|0
expr_stmt|;
name|_rl_move_vert
argument_list|(
name|cursor_linenum
argument_list|)
expr_stmt|;
comment|/* Where on that line?  And where does that line start 	     in the buffer? */
name|pos
operator|=
name|L_OFFSET
argument_list|(
name|cursor_linenum
argument_list|,
name|wrap_offset
argument_list|)
expr_stmt|;
name|nleft
operator|=
name|c_pos
operator|-
name|pos
expr_stmt|;
name|_rl_move_cursor_relative
argument_list|(
name|nleft
argument_list|,
operator|&
name|invisible_line
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Do horizontal scrolling. */
block|{
name|int
name|lmargin
decl_stmt|;
comment|/* Always at top line. */
name|_rl_last_v_pos
operator|=
literal|0
expr_stmt|;
comment|/* If the display position of the cursor would be off the edge 	 of the screen, start the display of this line at an offset that 	 leaves the cursor on the screen. */
if|if
condition|(
name|c_pos
operator|-
name|last_lmargin
operator|>
name|screenwidth
operator|-
literal|2
condition|)
name|lmargin
operator|=
operator|(
name|c_pos
operator|/
operator|(
name|screenwidth
operator|/
literal|3
operator|)
operator|-
literal|2
operator|)
operator|*
operator|(
name|screenwidth
operator|/
literal|3
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c_pos
operator|-
name|last_lmargin
operator|<
literal|1
condition|)
name|lmargin
operator|=
operator|(
operator|(
name|c_pos
operator|-
literal|1
operator|)
operator|/
operator|(
name|screenwidth
operator|/
literal|3
operator|)
operator|)
operator|*
operator|(
name|screenwidth
operator|/
literal|3
operator|)
expr_stmt|;
else|else
name|lmargin
operator|=
name|last_lmargin
expr_stmt|;
comment|/* If the first character on the screen isn't the first character 	 in the display line, indicate this with a special character. */
if|if
condition|(
name|lmargin
operator|>
literal|0
condition|)
name|line
index|[
name|lmargin
index|]
operator|=
literal|'<'
expr_stmt|;
if|if
condition|(
name|lmargin
operator|+
name|screenwidth
operator|<
name|out
condition|)
name|line
index|[
name|lmargin
operator|+
name|screenwidth
operator|-
literal|1
index|]
operator|=
literal|'>'
expr_stmt|;
if|if
condition|(
operator|!
name|rl_display_fixed
operator|||
name|forced_display
operator|||
name|lmargin
operator|!=
name|last_lmargin
condition|)
block|{
name|forced_display
operator|=
literal|0
expr_stmt|;
name|update_line
argument_list|(
operator|&
name|visible_line
index|[
name|last_lmargin
index|]
argument_list|,
operator|&
name|invisible_line
index|[
name|lmargin
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_rl_move_cursor_relative
argument_list|(
name|c_pos
operator|-
name|lmargin
argument_list|,
operator|&
name|invisible_line
index|[
name|lmargin
index|]
argument_list|)
expr_stmt|;
name|last_lmargin
operator|=
name|lmargin
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
comment|/* Swap visible and non-visible lines. */
block|{
name|char
modifier|*
name|temp
init|=
name|visible_line
decl_stmt|;
name|visible_line
operator|=
name|invisible_line
expr_stmt|;
name|invisible_line
operator|=
name|temp
expr_stmt|;
name|rl_display_fixed
operator|=
literal|0
expr_stmt|;
name|visible_wrap_offset
operator|=
name|wrap_offset
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* PWP: update_line() is based on finding the middle difference of each    line on the screen; vis:  			     /old first difference 	/beginning of line   |	      /old last same       /old EOL 	v		     v	      v		    v old:	eddie> Oh, my little gruntle-buggy is to me, as lurgid as new:	eddie> Oh, my little buggy says to me, as lurgid as 	^		     ^	^			   ^ 	\beginning of line   |	\new last same	   \new end of line 			     \new first difference     All are character pointers for the sake of speed.  Special cases for    no differences, as well as for end of line additions must be handeled.     Could be made even smarter, but this works well enough */
end_comment

begin_function
specifier|static
name|void
name|update_line
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|,
name|current_line
parameter_list|)
specifier|register
name|char
modifier|*
name|old
decl_stmt|,
decl|*
name|new
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|current_line
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ofd
decl_stmt|,
modifier|*
name|ols
decl_stmt|,
modifier|*
name|oe
decl_stmt|,
modifier|*
name|nfd
decl_stmt|,
modifier|*
name|nls
decl_stmt|,
modifier|*
name|ne
decl_stmt|;
name|int
name|lendiff
decl_stmt|,
name|wsatend
decl_stmt|;
comment|/* Find first difference. */
for|for
control|(
name|ofd
operator|=
name|old
operator|,
name|nfd
operator|=
name|new
init|;
operator|(
name|ofd
operator|-
name|old
operator|<
name|screenwidth
operator|)
operator|&&
operator|*
name|ofd
operator|&&
operator|(
operator|*
name|ofd
operator|==
operator|*
name|nfd
operator|)
condition|;
name|ofd
operator|++
operator|,
name|nfd
operator|++
control|)
empty_stmt|;
comment|/* Move to the end of the screen line. */
for|for
control|(
name|oe
operator|=
name|ofd
init|;
operator|(
operator|(
name|oe
operator|-
name|old
operator|)
operator|<
name|screenwidth
operator|)
operator|&&
operator|*
name|oe
condition|;
name|oe
operator|++
control|)
empty_stmt|;
for|for
control|(
name|ne
operator|=
name|nfd
init|;
operator|(
operator|(
name|ne
operator|-
name|new
operator|)
operator|<
name|screenwidth
operator|)
operator|&&
operator|*
name|ne
condition|;
name|ne
operator|++
control|)
empty_stmt|;
comment|/* If no difference, continue to next line. */
if|if
condition|(
name|ofd
operator|==
name|oe
operator|&&
name|nfd
operator|==
name|ne
condition|)
return|return;
name|wsatend
operator|=
literal|1
expr_stmt|;
comment|/* flag for trailing whitespace */
name|ols
operator|=
name|oe
operator|-
literal|1
expr_stmt|;
comment|/* find last same */
name|nls
operator|=
name|ne
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|ols
operator|>
name|ofd
operator|)
operator|&&
operator|(
name|nls
operator|>
name|nfd
operator|)
operator|&&
operator|(
operator|*
name|ols
operator|==
operator|*
name|nls
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|ols
operator|!=
literal|' '
condition|)
name|wsatend
operator|=
literal|0
expr_stmt|;
name|ols
operator|--
expr_stmt|;
name|nls
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|wsatend
condition|)
block|{
name|ols
operator|=
name|oe
expr_stmt|;
name|nls
operator|=
name|ne
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ols
operator|!=
operator|*
name|nls
condition|)
block|{
if|if
condition|(
operator|*
name|ols
condition|)
comment|/* don't step past the NUL */
name|ols
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|nls
condition|)
name|nls
operator|++
expr_stmt|;
block|}
name|_rl_move_vert
argument_list|(
name|current_line
argument_list|)
expr_stmt|;
name|_rl_move_cursor_relative
argument_list|(
name|ofd
operator|-
name|old
argument_list|,
name|old
argument_list|)
expr_stmt|;
comment|/* if (len (new)> len (old)) */
name|lendiff
operator|=
operator|(
name|nls
operator|-
name|nfd
operator|)
operator|-
operator|(
name|ols
operator|-
name|ofd
operator|)
expr_stmt|;
comment|/* Insert (diff (len (old), len (new)) ch. */
if|if
condition|(
name|lendiff
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|terminal_can_insert
condition|)
block|{
comment|/* Sometimes it is cheaper to print the characters rather than 	     use the terminal's capabilities. */
if|if
condition|(
operator|(
literal|2
operator|*
operator|(
name|ne
operator|-
name|nfd
operator|)
operator|)
operator|<
name|lendiff
operator|&&
operator|!
name|term_IC
condition|)
block|{
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
operator|(
name|ne
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
operator|(
name|ne
operator|-
name|nfd
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|ols
condition|)
block|{
name|insert_some_chars
argument_list|(
name|nfd
argument_list|,
name|lendiff
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|lendiff
expr_stmt|;
block|}
else|else
block|{
comment|/* At the end of a line the characters do not have to 		     be "inserted".  They can just be placed on the screen. */
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
name|lendiff
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|lendiff
expr_stmt|;
block|}
comment|/* Copy (new) chars to screen from first diff to last match. */
if|if
condition|(
operator|(
operator|(
name|nls
operator|-
name|nfd
operator|)
operator|-
name|lendiff
operator|)
operator|>
literal|0
condition|)
block|{
name|_rl_output_some_chars
argument_list|(
operator|&
name|nfd
index|[
name|lendiff
index|]
argument_list|,
operator|(
operator|(
name|nls
operator|-
name|nfd
operator|)
operator|-
name|lendiff
operator|)
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
operator|(
operator|(
name|nls
operator|-
name|nfd
operator|)
operator|-
name|lendiff
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* cannot insert chars, write to EOL */
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
operator|(
name|ne
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
operator|(
name|ne
operator|-
name|nfd
operator|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Delete characters from line. */
block|{
comment|/* If possible and inexpensive to use terminal deletion, then do so. */
if|if
condition|(
name|term_dc
operator|&&
operator|(
literal|2
operator|*
operator|(
name|ne
operator|-
name|nfd
operator|)
operator|)
operator|>=
operator|(
operator|-
name|lendiff
operator|)
condition|)
block|{
if|if
condition|(
name|lendiff
condition|)
name|delete_chars
argument_list|(
operator|-
name|lendiff
argument_list|)
expr_stmt|;
comment|/* delete (diff) characters */
comment|/* Copy (new) chars to screen from first diff to last match */
if|if
condition|(
operator|(
name|nls
operator|-
name|nfd
operator|)
operator|>
literal|0
condition|)
block|{
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
operator|(
name|nls
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
operator|(
name|nls
operator|-
name|nfd
operator|)
expr_stmt|;
block|}
block|}
comment|/* Otherwise, print over the existing material. */
else|else
block|{
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
operator|(
name|ne
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
operator|(
name|ne
operator|-
name|nfd
operator|)
expr_stmt|;
name|clear_to_eol
argument_list|(
operator|(
name|oe
operator|-
name|old
operator|)
operator|-
operator|(
name|ne
operator|-
name|new
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Tell the update routines that we have moved onto a new (empty) line. */
end_comment

begin_macro
name|rl_on_new_line
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|visible_line
condition|)
name|visible_line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|_rl_last_v_pos
operator|=
literal|0
expr_stmt|;
name|_rl_vis_botlin
operator|=
name|last_lmargin
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Actually update the display, period. */
end_comment

begin_macro
name|rl_forced_update_display
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|visible_line
condition|)
block|{
specifier|register
name|char
modifier|*
name|temp
init|=
name|visible_line
decl_stmt|;
while|while
condition|(
operator|*
name|temp
condition|)
operator|*
name|temp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|rl_on_new_line
argument_list|()
expr_stmt|;
name|forced_display
operator|++
expr_stmt|;
name|rl_redisplay
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Move the cursor from _rl_last_c_pos to NEW, which are buffer indices.    DATA is the contents of the screen line of interest; i.e., where    the movement is being done. */
end_comment

begin_function
name|void
name|_rl_move_cursor_relative
parameter_list|(
name|new
parameter_list|,
name|data
parameter_list|)
name|int
name|new
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* It may be faster to output a CR, and then move forwards instead      of moving backwards. */
if|if
condition|(
name|new
operator|+
literal|1
operator|<
name|_rl_last_c_pos
operator|-
name|new
condition|)
block|{
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|_rl_last_c_pos
operator|==
name|new
condition|)
return|return;
if|if
condition|(
name|_rl_last_c_pos
operator|<
name|new
condition|)
block|{
comment|/* Move the cursor forward.  We do it by printing the command 	 to move the cursor forward if there is one, else print that 	 portion of the output buffer again.  Which is cheaper? */
comment|/* The above comment is left here for posterity.  It is faster 	 to print one character (non-control) than to print a control 	 sequence telling the terminal to move forward one character. 	 That kind of control is for people who don't know what the 	 data is underneath the cursor. */
if|#
directive|if
name|defined
argument_list|(
name|HACK_TERMCAP_MOTION
argument_list|)
specifier|extern
name|char
modifier|*
name|term_forward_char
decl_stmt|;
if|if
condition|(
name|term_forward_char
condition|)
for|for
control|(
name|i
operator|=
name|_rl_last_c_pos
init|;
name|i
operator|<
name|new
condition|;
name|i
operator|++
control|)
name|tputs
argument_list|(
name|term_forward_char
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|_rl_last_c_pos
init|;
name|i
operator|<
name|new
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
name|data
index|[
name|i
index|]
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
name|_rl_last_c_pos
init|;
name|i
operator|<
name|new
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
name|data
index|[
name|i
index|]
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HACK_TERMCAP_MOTION */
block|}
else|else
name|backspace
argument_list|(
name|_rl_last_c_pos
operator|-
name|new
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* PWP: move the cursor up or down. */
end_comment

begin_function
name|void
name|_rl_move_vert
parameter_list|(
name|to
parameter_list|)
name|int
name|to
decl_stmt|;
block|{
specifier|register
name|int
name|delta
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|_rl_last_v_pos
operator|==
name|to
operator|||
name|to
operator|>
name|screenheight
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
block|{
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
name|ScreenGetCursor
argument_list|(
operator|&
name|row
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|ScreenSetCursor
argument_list|(
operator|(
name|row
operator|+
name|to
operator|-
name|_rl_last_v_pos
operator|)
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !__GO32__ */
if|if
condition|(
operator|(
name|delta
operator|=
name|to
operator|-
name|_rl_last_v_pos
operator|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|delta
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* delta< 0 */
if|if
condition|(
name|term_up
operator|&&
operator|*
name|term_up
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|-
name|delta
condition|;
name|i
operator|++
control|)
name|tputs
argument_list|(
name|term_up
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !__GO32__ */
name|_rl_last_v_pos
operator|=
name|to
expr_stmt|;
comment|/* Now TO is here */
block|}
end_function

begin_comment
comment|/* Physically print C on rl_outstream.  This is for functions which know    how to optimize the display.  Return the number of characters output. */
end_comment

begin_macro
name|rl_show_char
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|_rl_output_meta_chars
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"M-"
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
name|c
operator|=
name|UNMETA
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DISPLAY_TABS
argument_list|)
if|if
condition|(
name|c
operator|<
literal|32
operator|&&
name|c
operator|!=
literal|'\t'
condition|)
else|#
directive|else
if|if
condition|(
name|c
operator|<
literal|32
condition|)
endif|#
directive|endif
comment|/* !DISPLAY_TABS */
block|{
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"C-"
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
name|c
operator|+=
literal|64
expr_stmt|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_block

begin_function
name|int
name|rl_character_len
parameter_list|(
name|c
parameter_list|,
name|pos
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|,
name|pos
decl_stmt|;
block|{
if|if
condition|(
name|META_CHAR
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
operator|(
name|_rl_output_meta_chars
operator|==
literal|0
operator|)
condition|?
literal|4
else|:
literal|1
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DISPLAY_TABS
argument_list|)
return|return
operator|(
operator|(
operator|(
name|pos
operator||
operator|(
name|int
operator|)
literal|7
operator|)
operator|+
literal|1
operator|)
operator|-
name|pos
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|2
operator|)
return|;
endif|#
directive|endif
comment|/* !DISPLAY_TABS */
block|}
return|return
operator|(
operator|(
name|isprint
argument_list|(
name|c
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* How to print things in the "echo-area".  The prompt is treated as a    mini-modeline. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VARARGS_H
argument_list|)
end_if

begin_macro
name|rl_message
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|msg_buf
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|rl_display_prompt
operator|=
name|msg_buf
expr_stmt|;
name|rl_redisplay
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAVE_VARARGS_H */
end_comment

begin_macro
name|rl_message
argument_list|(
argument|format
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sprintf
argument_list|(
name|msg_buf
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|rl_display_prompt
operator|=
name|msg_buf
expr_stmt|;
name|rl_redisplay
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_VARARGS_H */
end_comment

begin_comment
comment|/* How to clear things from the "echo-area". */
end_comment

begin_macro
name|rl_clear_message
argument_list|()
end_macro

begin_block
block|{
name|rl_display_prompt
operator|=
name|rl_prompt
expr_stmt|;
name|rl_redisplay
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|rl_reset_line_state
argument_list|()
end_macro

begin_block
block|{
name|rl_on_new_line
argument_list|()
expr_stmt|;
name|rl_display_prompt
operator|=
name|rl_prompt
condition|?
name|rl_prompt
else|:
literal|""
expr_stmt|;
name|forced_display
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Quick redisplay hack when erasing characters at the end of the line. */
end_comment

begin_function
name|void
name|_rl_erase_at_end_of_line
parameter_list|(
name|l
parameter_list|)
name|int
name|l
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|backspace
argument_list|(
name|l
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|backspace
argument_list|(
name|l
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|visible_line
index|[
operator|--
name|_rl_last_c_pos
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_display_fixed
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear to the end of the line.  COUNT is the minimum    number of character spaces to clear, */
end_comment

begin_function
specifier|static
name|void
name|clear_to_eol
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
if|if
condition|(
name|term_clreol
condition|)
block|{
name|tputs
argument_list|(
name|term_clreol
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* !__GO32__ */
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Do one more character space. */
name|count
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|backspace
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert COUNT characters from STRING to the output stream. */
end_comment

begin_function
specifier|static
name|void
name|insert_some_chars
parameter_list|(
name|string
parameter_list|,
name|count
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|int
name|row
decl_stmt|,
name|col
decl_stmt|,
name|width
decl_stmt|;
name|char
modifier|*
name|row_start
decl_stmt|;
name|ScreenGetCursor
argument_list|(
operator|&
name|row
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|width
operator|=
name|ScreenCols
argument_list|()
expr_stmt|;
name|row_start
operator|=
name|ScreenPrimary
operator|+
operator|(
name|row
operator|*
name|width
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|row_start
operator|+
name|col
operator|+
name|count
argument_list|,
name|row_start
operator|+
name|col
argument_list|,
name|width
operator|-
name|col
operator|-
name|count
argument_list|)
expr_stmt|;
comment|/* Place the text on the screen. */
name|_rl_output_some_chars
argument_list|(
name|string
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_GO32 */
comment|/* If IC is defined, then we do not have to "enter" insert mode. */
if|if
condition|(
name|term_IC
condition|)
block|{
name|char
modifier|*
name|tgoto
argument_list|()
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|tgoto
argument_list|(
name|term_IC
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
name|_rl_output_some_chars
argument_list|(
name|string
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If we have to turn on insert-mode, then do so. */
if|if
condition|(
name|term_im
operator|&&
operator|*
name|term_im
condition|)
name|tputs
argument_list|(
name|term_im
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
comment|/* If there is a special command for inserting characters, then 	 use that first to open up the space. */
if|if
condition|(
name|term_ic
operator|&&
operator|*
name|term_ic
condition|)
block|{
for|for
control|(
name|i
operator|=
name|count
init|;
name|i
operator|--
condition|;
control|)
name|tputs
argument_list|(
name|term_ic
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
comment|/* Print the text. */
name|_rl_output_some_chars
argument_list|(
name|string
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* If there is a string to turn off insert mode, we had best use 	 it now. */
if|if
condition|(
name|term_ei
operator|&&
operator|*
name|term_ei
condition|)
name|tputs
argument_list|(
name|term_ei
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !__GO32__ */
block|}
end_function

begin_comment
comment|/* Delete COUNT characters from the display line. */
end_comment

begin_function
specifier|static
name|void
name|delete_chars
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|int
name|row
decl_stmt|,
name|col
decl_stmt|,
name|width
decl_stmt|;
name|char
modifier|*
name|row_start
decl_stmt|;
name|ScreenGetCursor
argument_list|(
operator|&
name|row
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|width
operator|=
name|ScreenCols
argument_list|()
expr_stmt|;
name|row_start
operator|=
name|ScreenPrimary
operator|+
operator|(
name|row
operator|*
name|width
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|row_start
operator|+
name|col
argument_list|,
name|row_start
operator|+
name|col
operator|+
name|count
argument_list|,
name|width
operator|-
name|col
operator|-
name|count
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|row_start
operator|+
name|width
operator|-
name|count
argument_list|,
literal|0
argument_list|,
name|count
operator|*
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_GO32 */
if|if
condition|(
name|count
operator|>
name|screenwidth
condition|)
return|return;
if|if
condition|(
name|term_DC
operator|&&
operator|*
name|term_DC
condition|)
block|{
name|char
modifier|*
name|tgoto
argument_list|()
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|tgoto
argument_list|(
name|term_DC
argument_list|,
name|count
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
name|count
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|term_dc
operator|&&
operator|*
name|term_dc
condition|)
while|while
condition|(
name|count
operator|--
condition|)
name|tputs
argument_list|(
name|term_dc
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !__GO32__ */
block|}
end_function

end_unit

