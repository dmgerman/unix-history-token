begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* access.c    Check access to files by the user and by the daemon.  */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|"uudefs.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* See if the user has access to a file, to prevent the setuid uucp    and uux programs handing out unauthorized access.  */
end_comment

begin_function
name|boolean
name|fsysdep_access
parameter_list|(
name|zfile
parameter_list|)
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
block|{
if|if
condition|(
name|access
argument_list|(
name|zfile
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s"
argument_list|,
name|zfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* See if the daemon has access to a file.  This is called if a file    is not being transferred to the spool directory, since if the    daemon does not have access the later transfer will fail.  We    assume that the daemon will have the same euid (or egid) as the one    we are running under.  If our uid (gid) and euid (egid) are the    same, we assume that we have access.  Note that is not important    for security, since the check will be (implicitly) done again when    the daemon tries to transfer the file.  This routine should work    whether the UUCP programs are installed setuid or setgid.  */
end_comment

begin_function
name|boolean
name|fsysdep_daemon_access
parameter_list|(
name|zfile
parameter_list|)
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|uid_t
name|ieuid
decl_stmt|,
name|iuid
decl_stmt|,
name|iegid
decl_stmt|,
name|igid
decl_stmt|;
name|boolean
name|fok
decl_stmt|;
name|ieuid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|ieuid
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|iuid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|iegid
operator|=
name|getegid
argument_list|()
expr_stmt|;
name|igid
operator|=
name|getgid
argument_list|()
expr_stmt|;
comment|/* If our effective uid and gid are the same as our real uid and      gid, we assume the daemon will have access to the file.  */
if|if
condition|(
name|ieuid
operator|==
name|iuid
operator|&&
name|iegid
operator|==
name|igid
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|stat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zfile
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"stat (%s): %s"
argument_list|,
name|zfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If our euid is not our uid, but it is the file's uid, see if the      owner has read access.  Otherwise, if our egid is not our gid,      but it is the file's gid, see if the group has read access.      Otherwise, see if the world has read access.  We know from the      above check that at least one of our euid and egid are different,      so that is the only one we want to check.  This check could fail      if the UUCP programs were both setuid and setgid, but why would      they be?  */
if|if
condition|(
name|ieuid
operator|!=
name|iuid
operator|&&
name|ieuid
operator|==
name|s
operator|.
name|st_uid
condition|)
name|fok
operator|=
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_IRUSR
operator|)
operator|!=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|iegid
operator|!=
name|igid
operator|&&
name|iegid
operator|==
name|s
operator|.
name|st_gid
condition|)
name|fok
operator|=
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_IRGRP
operator|)
operator|!=
literal|0
expr_stmt|;
else|else
name|fok
operator|=
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_IROTH
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fok
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: cannot be read by daemon"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

