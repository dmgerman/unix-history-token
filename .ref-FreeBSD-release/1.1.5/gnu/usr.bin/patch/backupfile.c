begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* backupfile.c -- make Emacs style backup file names    Copyright (C) 1990, 1991, 1992 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by David MacKenzie<djm@gnu.ai.mit.edu>.    Some algorithms adapted from GNU Emacs. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"backupfile.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DIRENT
argument_list|)
operator|||
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_define
define|#
directive|define
name|NLENGTH
parameter_list|(
name|direct
parameter_list|)
value|(strlen((direct)->d_name))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not (DIRENT or _POSIX_VERSION) */
end_comment

begin_define
define|#
directive|define
name|dirent
value|direct
end_define

begin_define
define|#
directive|define
name|NLENGTH
parameter_list|(
name|direct
parameter_list|)
value|((direct)->d_namlen)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SYSNDIR
end_ifdef

begin_include
include|#
directive|include
file|<sys/ndir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSNDIR */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSDIR
end_ifdef

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSDIR */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NDIR
end_ifdef

begin_include
include|#
directive|include
file|<ndir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NDIR */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DIRENT or _POSIX_VERSION */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|isascii
end_ifndef

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|c
parameter_list|)
value|(isdigit ((unsigned char) (c)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|c
parameter_list|)
value|(isascii (c)&& isdigit (c))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_comment
comment|/* POSIX does not require that the d_ino field be present, and some    systems do not provide it. */
end_comment

begin_define
define|#
directive|define
name|REAL_DIR_ENTRY
parameter_list|(
name|dp
parameter_list|)
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|REAL_DIR_ENTRY
parameter_list|(
name|dp
parameter_list|)
value|((dp)->d_ino != 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Which type of backup file names are generated. */
end_comment

begin_decl_stmt
name|enum
name|backup_type
name|backup_type
init|=
name|none
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The extension added to file names to produce a simple (as opposed    to numbered) backup file name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|simple_backup_suffix
init|=
literal|"~"
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|basename
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|dirname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|find_backup_file_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|make_version_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|max_backup_version
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|version_number
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return NAME with any leading path stripped off.  */
end_comment

begin_function
name|char
modifier|*
name|basename
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|r
init|=
name|name
decl_stmt|,
modifier|*
name|p
init|=
name|name
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'/'
condition|)
name|r
operator|=
name|p
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NODIR
end_ifndef

begin_comment
comment|/* Return the name of the new backup file for file FILE,    allocated with malloc.  Return 0 if out of memory.    FILE must not end with a '/' unless it is the root directory.    Do not call this function if backup_type == none. */
end_comment

begin_function
name|char
modifier|*
name|find_backup_file_name
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|base_versions
decl_stmt|;
name|int
name|highest_backup
decl_stmt|;
if|if
condition|(
name|backup_type
operator|==
name|simple
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
name|strlen
argument_list|(
name|simple_backup_suffix
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|addext
argument_list|(
name|s
argument_list|,
name|simple_backup_suffix
argument_list|,
literal|'~'
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|base_versions
operator|=
name|concat
argument_list|(
name|basename
argument_list|(
name|file
argument_list|)
argument_list|,
literal|".~"
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_versions
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|dir
operator|=
name|dirname
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|base_versions
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|highest_backup
operator|=
name|max_backup_version
argument_list|(
name|base_versions
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base_versions
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|backup_type
operator|==
name|numbered_existing
operator|&&
name|highest_backup
operator|==
literal|0
condition|)
return|return
name|concat
argument_list|(
name|file
argument_list|,
name|simple_backup_suffix
argument_list|)
return|;
return|return
name|make_version_name
argument_list|(
name|file
argument_list|,
name|highest_backup
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of the highest-numbered backup file for file    FILE in directory DIR.  If there are no numbered backups    of FILE in DIR, or an error occurs reading DIR, return 0.    FILE should already have ".~" appended to it. */
end_comment

begin_function
specifier|static
name|int
name|max_backup_version
parameter_list|(
name|file
parameter_list|,
name|dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|,
decl|*
name|dir
decl_stmt|;
end_function

begin_block
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|int
name|highest_version
decl_stmt|;
name|int
name|this_version
decl_stmt|;
name|int
name|file_name_length
decl_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dirp
condition|)
return|return
literal|0
return|;
name|highest_version
operator|=
literal|0
expr_stmt|;
name|file_name_length
operator|=
name|strlen
argument_list|(
name|file
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|REAL_DIR_ENTRY
argument_list|(
name|dp
argument_list|)
operator|||
name|NLENGTH
argument_list|(
name|dp
argument_list|)
operator|<=
name|file_name_length
condition|)
continue|continue;
name|this_version
operator|=
name|version_number
argument_list|(
name|file
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|file_name_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_version
operator|>
name|highest_version
condition|)
name|highest_version
operator|=
name|this_version
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
name|highest_version
return|;
block|}
end_block

begin_comment
comment|/* Return a string, allocated with malloc, containing    "FILE.~VERSION~".  Return 0 if out of memory. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|make_version_name
parameter_list|(
name|file
parameter_list|,
name|version
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|version
decl_stmt|;
block|{
name|char
modifier|*
name|backup_name
decl_stmt|;
name|backup_name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|backup_name
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|sprintf
argument_list|(
name|backup_name
argument_list|,
literal|"%s.~%d~"
argument_list|,
name|file
argument_list|,
name|version
argument_list|)
expr_stmt|;
return|return
name|backup_name
return|;
block|}
end_function

begin_comment
comment|/* If BACKUP is a numbered backup of BASE, return its version number;    otherwise return 0.  BASE_LENGTH is the length of BASE.    BASE should already have ".~" appended to it. */
end_comment

begin_function
specifier|static
name|int
name|version_number
parameter_list|(
name|base
parameter_list|,
name|backup
parameter_list|,
name|base_length
parameter_list|)
name|char
modifier|*
name|base
decl_stmt|;
name|char
modifier|*
name|backup
decl_stmt|;
name|int
name|base_length
decl_stmt|;
block|{
name|int
name|version
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|version
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|base
argument_list|,
name|backup
argument_list|,
name|base_length
argument_list|)
operator|&&
name|ISDIGIT
argument_list|(
name|backup
index|[
name|base_length
index|]
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|&
name|backup
index|[
name|base_length
index|]
init|;
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
name|version
operator|=
name|version
operator|*
literal|10
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'~'
operator|||
name|p
index|[
literal|1
index|]
condition|)
name|version
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|version
return|;
block|}
end_function

begin_comment
comment|/* Return the newly-allocated concatenation of STR1 and STR2.    If out of memory, return 0. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|concat
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|)
name|char
modifier|*
name|str1
decl_stmt|,
decl|*
name|str2
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|newstr
decl_stmt|;
name|char
name|str1_length
init|=
name|strlen
argument_list|(
name|str1
argument_list|)
decl_stmt|;
name|newstr
operator|=
name|malloc
argument_list|(
name|str1_length
operator|+
name|strlen
argument_list|(
name|str2
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newstr
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|strcpy
argument_list|(
name|newstr
argument_list|,
name|str1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newstr
operator|+
name|str1_length
argument_list|,
name|str2
argument_list|)
expr_stmt|;
return|return
name|newstr
return|;
block|}
end_block

begin_comment
comment|/* Return the leading directories part of PATH,    allocated with malloc.  If out of memory, return 0.    Assumes that trailing slashes have already been    removed.  */
end_comment

begin_function
name|char
modifier|*
name|dirname
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|char
modifier|*
name|newpath
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* Length of result, not including NUL. */
name|slash
operator|=
name|basename
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|==
name|path
condition|)
block|{
comment|/* File is in the current directory.  */
name|path
operator|=
literal|"."
expr_stmt|;
name|length
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Remove any trailing slashes from result. */
while|while
condition|(
operator|*
operator|--
name|slash
operator|==
literal|'/'
operator|&&
name|slash
operator|>
name|path
condition|)
empty_stmt|;
name|length
operator|=
name|slash
operator|-
name|path
operator|+
literal|1
expr_stmt|;
block|}
name|newpath
operator|=
name|malloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpath
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|strncpy
argument_list|(
name|newpath
argument_list|,
name|path
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|newpath
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|newpath
return|;
block|}
end_function

begin_comment
comment|/* If ARG is an unambiguous match for an element of the    null-terminated array OPTLIST, return the index in OPTLIST    of the matched element, else -1 if it does not match any element    or -2 if it is ambiguous (is a prefix of more than one element). */
end_comment

begin_function
name|int
name|argmatch
parameter_list|(
name|arg
parameter_list|,
name|optlist
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
modifier|*
name|optlist
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Temporary index in OPTLIST. */
name|int
name|arglen
decl_stmt|;
comment|/* Length of ARG. */
name|int
name|matchind
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Index of first nonexact match. */
name|int
name|ambiguous
init|=
literal|0
decl_stmt|;
comment|/* If nonzero, multiple nonexact match(es). */
name|arglen
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Test all elements for either exact match or abbreviated matches.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|optlist
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|optlist
index|[
name|i
index|]
argument_list|,
name|arg
argument_list|,
name|arglen
argument_list|)
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|optlist
index|[
name|i
index|]
argument_list|)
operator|==
name|arglen
condition|)
comment|/* Exact match found.  */
return|return
name|i
return|;
elseif|else
if|if
condition|(
name|matchind
operator|==
operator|-
literal|1
condition|)
comment|/* First nonexact match found.  */
name|matchind
operator|=
name|i
expr_stmt|;
else|else
comment|/* Second nonexact match found.  */
name|ambiguous
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ambiguous
condition|)
return|return
operator|-
literal|2
return|;
else|else
return|return
name|matchind
return|;
block|}
end_function

begin_comment
comment|/* Error reporting for argmatch.    KIND is a description of the type of entity that was being matched.    VALUE is the invalid value that was given.    PROBLEM is the return value from argmatch. */
end_comment

begin_function
name|void
name|invalid_arg
parameter_list|(
name|kind
parameter_list|,
name|value
parameter_list|,
name|problem
parameter_list|)
name|char
modifier|*
name|kind
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|problem
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"patch: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|problem
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
else|else
comment|/* Assume -2. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ambiguous"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s `%s'\n"
argument_list|,
name|kind
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|backup_args
index|[]
init|=
block|{
literal|"never"
block|,
literal|"simple"
block|,
literal|"nil"
block|,
literal|"existing"
block|,
literal|"t"
block|,
literal|"numbered"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|backup_type
name|backup_types
index|[]
init|=
block|{
name|simple
block|,
name|simple
block|,
name|numbered_existing
block|,
name|numbered_existing
block|,
name|numbered
block|,
name|numbered
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the type of backup indicated by VERSION.    Unique abbreviations are accepted. */
end_comment

begin_function
name|enum
name|backup_type
name|get_version
parameter_list|(
name|version
parameter_list|)
name|char
modifier|*
name|version
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|version
operator|==
literal|0
operator|||
operator|*
name|version
operator|==
literal|0
condition|)
return|return
name|numbered_existing
return|;
name|i
operator|=
name|argmatch
argument_list|(
name|version
argument_list|,
name|backup_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
return|return
name|backup_types
index|[
name|i
index|]
return|;
name|invalid_arg
argument_list|(
literal|"version control type"
argument_list|,
name|version
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NODIR */
end_comment

begin_comment
comment|/* Append to FILENAME the extension EXT, unless the result would be too long,    in which case just append the character E.  */
end_comment

begin_function
name|void
name|addext
parameter_list|(
name|filename
parameter_list|,
name|ext
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|ext
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|s
init|=
name|basename
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|int
name|slen
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|,
name|extlen
init|=
name|strlen
argument_list|(
name|ext
argument_list|)
decl_stmt|;
name|long
name|slen_max
init|=
operator|-
literal|1
decl_stmt|;
if|#
directive|if
name|HAVE_PATHCONF
operator|&&
name|defined
argument_list|(
name|_PC_NAME_MAX
argument_list|)
ifndef|#
directive|ifndef
name|_POSIX_NAME_MAX
define|#
directive|define
name|_POSIX_NAME_MAX
value|14
endif|#
directive|endif
if|if
condition|(
name|slen
operator|+
name|extlen
operator|<=
name|_POSIX_NAME_MAX
condition|)
comment|/* The file name is so short there's no need to call pathconf.  */
name|slen_max
operator|=
name|_POSIX_NAME_MAX
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|==
name|filename
condition|)
name|slen_max
operator|=
name|pathconf
argument_list|(
literal|"."
argument_list|,
name|_PC_NAME_MAX
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|c
init|=
operator|*
name|s
decl_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
name|slen_max
operator|=
name|pathconf
argument_list|(
name|filename
argument_list|,
name|_PC_NAME_MAX
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|slen_max
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LONG_FILE_NAMES
name|slen_max
operator|=
literal|255
expr_stmt|;
else|#
directive|else
name|slen_max
operator|=
literal|14
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|slen
operator|+
name|extlen
operator|<=
name|slen_max
condition|)
name|strcpy
argument_list|(
name|s
operator|+
name|slen
argument_list|,
name|ext
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|slen_max
operator|<=
name|slen
condition|)
block|{
comment|/* Try to preserve difference between .h .c etc.  */
if|if
condition|(
name|slen
operator|==
name|slen_max
operator|&&
name|s
index|[
name|slen
operator|-
literal|2
index|]
operator|==
literal|'.'
condition|)
name|s
index|[
name|slen
operator|-
literal|2
index|]
operator|=
name|s
index|[
name|slen
operator|-
literal|1
index|]
expr_stmt|;
name|slen
operator|=
name|slen_max
operator|-
literal|1
expr_stmt|;
block|}
name|s
index|[
name|slen
index|]
operator|=
name|e
expr_stmt|;
name|s
index|[
name|slen
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

end_unit

