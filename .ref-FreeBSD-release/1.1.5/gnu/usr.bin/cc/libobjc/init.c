begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU Objective C Runtime initialization     Copyright (C) 1993 Free Software Foundation, Inc.  Author: Kresten Krab Thorup  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the    terms of the GNU General Public License as published by the Free Software    Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more    details.  You should have received a copy of the GNU General Public License along with    GNU CC; see the file COPYING.  If not, write to the Free Software    Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files compiled with    GCC to produce an executable, this does not cause the resulting executable    to be covered by the GNU General Public License. This exception does not    however invalidate any other reasons why the executable file might be    covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_comment
comment|/* The version number of this runtime.  This must match the number     defined in gcc (objc-act.c) */
end_comment

begin_define
define|#
directive|define
name|OBJC_VERSION
value|5
end_define

begin_define
define|#
directive|define
name|PROTOCOL_VERSION
value|2
end_define

begin_comment
comment|/* This list contains all modules currently loaded into the runtime */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|objc_list
modifier|*
name|__objc_module_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This list contains all proto_list's not yet assigned class links */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|objc_list
modifier|*
name|unclaimed_proto_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check compiler vs runtime version */
end_comment

begin_function_decl
specifier|static
name|void
name|init_check_module_version
parameter_list|(
name|Module_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Assign isa links to protos */
end_comment

begin_function_decl
specifier|static
name|void
name|__objc_init_protocols
parameter_list|(
name|struct
name|objc_protocol_list
modifier|*
name|protos
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add protocol to class */
end_comment

begin_function_decl
specifier|static
name|void
name|__objc_class_add_protocols
parameter_list|(
name|Class
modifier|*
parameter_list|,
name|struct
name|objc_protocol_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Is all categories/classes resolved? */
end_comment

begin_decl_stmt
name|BOOL
name|__objc_dangling_categories
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function is called by constructor functions generated for each    module compiled.  (_GLOBAL_$I$...) The purpose of this function is to    gather the module pointers so that they may be processed by the    initialization routines as soon as possible */
end_comment

begin_function
name|void
name|__objc_exec_class
parameter_list|(
name|Module_t
name|module
parameter_list|)
block|{
comment|/* Has we processed any constructors previously?  This flag used to       indicate that some global data structures need to be built.  */
specifier|static
name|BOOL
name|previous_constructors
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|objc_list
modifier|*
name|unclaimed_categories
init|=
literal|0
decl_stmt|;
comment|/* The symbol table (defined in objc.h) generated by gcc */
name|Symtab_t
name|symtab
init|=
name|module
operator|->
name|symtab
decl_stmt|;
comment|/* Entry used to traverse hash lists */
name|struct
name|objc_list
modifier|*
modifier|*
name|cell
decl_stmt|;
comment|/* The table of selector references for this module */
name|SEL
modifier|*
name|selectors
init|=
name|symtab
operator|->
name|refs
decl_stmt|;
comment|/* dummy counter */
name|int
name|i
decl_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"received module: %s\n"
argument_list|,
name|module
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* check gcc version */
name|init_check_module_version
argument_list|(
name|module
argument_list|)
expr_stmt|;
comment|/* On the first call of this routine, initialize some data structures.  */
if|if
condition|(
operator|!
name|previous_constructors
condition|)
block|{
name|__objc_init_selector_tables
argument_list|()
expr_stmt|;
name|__objc_init_class_tables
argument_list|()
expr_stmt|;
name|__objc_init_dispatch_tables
argument_list|()
expr_stmt|;
name|previous_constructors
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Save the module pointer for later processing. (not currently used) */
name|__objc_module_list
operator|=
name|list_cons
argument_list|(
name|module
argument_list|,
name|__objc_module_list
argument_list|)
expr_stmt|;
comment|/* Parse the classes in the load module and gather selector information.  */
name|DEBUG_PRINTF
argument_list|(
literal|"gathering selectors from module: %s\n"
argument_list|,
name|module
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab
operator|->
name|cls_def_cnt
condition|;
operator|++
name|i
control|)
block|{
name|Class
modifier|*
name|class
init|=
operator|(
name|Class
operator|*
operator|)
name|symtab
operator|->
name|defs
index|[
name|i
index|]
decl_stmt|;
comment|/* Make sure we have what we think.  */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CLS_ISMETA
argument_list|(
name|class
operator|->
name|class_pointer
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"phase 1, processing class: %s\n"
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Store the class in the class table and assign class numbers.  */
name|__objc_add_class_to_hash
argument_list|(
name|class
argument_list|)
expr_stmt|;
comment|/* Register all of the selectors in the class and meta class.  */
name|__objc_register_selectors_from_class
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|__objc_register_selectors_from_class
argument_list|(
operator|(
name|Class
operator|*
operator|)
name|class
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
comment|/* Install the fake dispatch tables */
name|__objc_install_premature_dtable
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|__objc_install_premature_dtable
argument_list|(
name|class
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|->
name|protocols
condition|)
name|__objc_init_protocols
argument_list|(
name|class
operator|->
name|protocols
argument_list|)
expr_stmt|;
block|}
comment|/* Replace referenced selectors from names to SEL's.  */
if|if
condition|(
name|selectors
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|selectors
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
name|selectors
index|[
name|i
index|]
operator|=
name|sel_register_name
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|selectors
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Process category information from the module.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab
operator|->
name|cat_def_cnt
condition|;
operator|++
name|i
control|)
block|{
name|Category_t
name|category
init|=
name|symtab
operator|->
name|defs
index|[
name|i
operator|+
name|symtab
operator|->
name|cls_def_cnt
index|]
decl_stmt|;
name|Class
modifier|*
name|class
init|=
name|objc_lookup_class
argument_list|(
name|category
operator|->
name|class_name
argument_list|)
decl_stmt|;
comment|/* If the class for the category exists then append its methods.  */
if|if
condition|(
name|class
condition|)
block|{
name|DEBUG_PRINTF
argument_list|(
literal|"processing categories from (module,object): %s, %s\n"
argument_list|,
name|module
operator|->
name|name
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Do instance methods.  */
if|if
condition|(
name|category
operator|->
name|instance_methods
condition|)
name|class_add_method_list
argument_list|(
name|class
argument_list|,
name|category
operator|->
name|instance_methods
argument_list|)
expr_stmt|;
comment|/* Do class methods.  */
if|if
condition|(
name|category
operator|->
name|class_methods
condition|)
name|class_add_method_list
argument_list|(
operator|(
name|Class
operator|*
operator|)
name|class
operator|->
name|class_pointer
argument_list|,
name|category
operator|->
name|class_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|->
name|protocols
condition|)
block|{
name|__objc_init_protocols
argument_list|(
name|category
operator|->
name|protocols
argument_list|)
expr_stmt|;
name|__objc_class_add_protocols
argument_list|(
name|class
argument_list|,
name|category
operator|->
name|protocols
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The object to which the category methods belong can't be found. 	     Save the information.  */
name|unclaimed_categories
operator|=
name|list_cons
argument_list|(
name|category
argument_list|,
name|unclaimed_categories
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Scan the unclaimed category hash.  Attempt to attach any unclaimed      categories to objects.  */
for|for
control|(
name|cell
operator|=
operator|&
name|unclaimed_categories
init|;
operator|*
name|cell
condition|;
operator|*
name|cell
operator|&&
operator|(
operator|(
name|cell
operator|=
operator|&
operator|(
operator|*
name|cell
operator|)
operator|->
name|tail
operator|)
operator|)
control|)
block|{
name|Category_t
name|category
init|=
operator|(
operator|*
name|cell
operator|)
operator|->
name|head
decl_stmt|;
name|Class
modifier|*
name|class
init|=
name|objc_lookup_class
argument_list|(
name|category
operator|->
name|class_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|class
condition|)
block|{
name|DEBUG_PRINTF
argument_list|(
literal|"attaching stored categories to object: %s\n"
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
name|list_remove_head
argument_list|(
name|cell
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|->
name|instance_methods
condition|)
name|class_add_method_list
argument_list|(
name|class
argument_list|,
name|category
operator|->
name|instance_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|->
name|class_methods
condition|)
name|class_add_method_list
argument_list|(
operator|(
name|Class
operator|*
operator|)
name|class
operator|->
name|class_pointer
argument_list|,
name|category
operator|->
name|class_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|->
name|protocols
condition|)
block|{
name|__objc_init_protocols
argument_list|(
name|category
operator|->
name|protocols
argument_list|)
expr_stmt|;
name|__objc_class_add_protocols
argument_list|(
name|class
argument_list|,
name|category
operator|->
name|protocols
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|unclaimed_proto_list
operator|&&
name|objc_lookup_class
argument_list|(
literal|"Protocol"
argument_list|)
condition|)
block|{
name|list_mapcar
argument_list|(
name|unclaimed_proto_list
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|__objc_init_protocols
argument_list|)
expr_stmt|;
name|list_free
argument_list|(
name|unclaimed_proto_list
argument_list|)
expr_stmt|;
name|unclaimed_proto_list
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sanity check the version of gcc used to compile `module'*/
end_comment

begin_function
specifier|static
name|void
name|init_check_module_version
parameter_list|(
name|Module_t
name|module
parameter_list|)
block|{
if|if
condition|(
operator|(
name|module
operator|->
name|version
operator|!=
name|OBJC_VERSION
operator|)
operator|||
operator|(
name|module
operator|->
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|Module
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Module %s version %d doesn't match runtime %d\n"
argument_list|,
name|module
operator|->
name|name
argument_list|,
name|module
operator|->
name|version
argument_list|,
name|OBJC_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|module
operator|->
name|version
operator|>
name|OBJC_VERSION
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Runtime (libobjc.a) is out of date\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|module
operator|->
name|version
operator|<
name|OBJC_VERSION
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Compiler (gcc) is out of date\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Objective C internal error -- bad Module size\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__objc_init_protocols
parameter_list|(
name|struct
name|objc_protocol_list
modifier|*
name|protos
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|Class
modifier|*
name|proto_class
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|protos
condition|)
return|return;
if|if
condition|(
operator|!
name|proto_class
condition|)
name|proto_class
operator|=
name|objc_lookup_class
argument_list|(
literal|"Protocol"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proto_class
condition|)
block|{
name|unclaimed_proto_list
operator|=
name|list_cons
argument_list|(
name|protos
argument_list|,
name|unclaimed_proto_list
argument_list|)
expr_stmt|;
return|return;
block|}
name|assert
argument_list|(
name|protos
operator|->
name|next
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* only single ones allowed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|protos
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|objc_protocol
modifier|*
name|aProto
init|=
name|protos
operator|->
name|list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|aProto
operator|->
name|class_pointer
operator|)
operator|==
name|PROTOCOL_VERSION
condition|)
block|{
comment|/* assign class pointer */
name|aProto
operator|->
name|class_pointer
operator|=
name|proto_class
expr_stmt|;
comment|/* init super protocols */
name|__objc_init_protocols
argument_list|(
name|aProto
operator|->
name|protocol_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|protos
operator|->
name|list
index|[
name|i
index|]
operator|->
name|class_pointer
operator|!=
name|proto_class
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Version %d doesn't match runtime protocol version %d\n"
argument_list|,
operator|(
operator|(
name|size_t
operator|)
name|protos
operator|->
name|list
index|[
name|i
index|]
operator|->
name|class_pointer
operator|)
argument_list|,
name|PROTOCOL_VERSION
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__objc_class_add_protocols
parameter_list|(
name|Class
modifier|*
name|class
parameter_list|,
name|struct
name|objc_protocol_list
modifier|*
name|protos
parameter_list|)
block|{
comment|/* Well... */
if|if
condition|(
operator|!
name|protos
condition|)
return|return;
comment|/* Add it... */
name|protos
operator|->
name|next
operator|=
name|class
operator|->
name|protocols
expr_stmt|;
name|class
operator|->
name|protocols
operator|=
name|protos
expr_stmt|;
block|}
end_function

end_unit

