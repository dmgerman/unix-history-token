begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions related to building classes and their related objects.    Copyright (C) 1987, 1992, 1993 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* High-level class interface. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
end_ifdef

begin_include
include|#
directive|include
file|"cp-decl.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Way of stacking class types.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|current_class_base
decl_stmt|,
modifier|*
name|current_class_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_class_stacksize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_class_depth
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|class_level
block|{
comment|/* The previous class level.  */
name|struct
name|class_level
modifier|*
name|level_chain
decl_stmt|;
comment|/* The class instance variable, as a PARM_DECL.  */
name|tree
name|decl
decl_stmt|;
comment|/* The class instance variable, as an object.  */
name|tree
name|object
decl_stmt|;
comment|/* The virtual function table pointer      for the class instance variable.  */
name|tree
name|vtable_decl
decl_stmt|;
comment|/* Name of the current class.  */
name|tree
name|name
decl_stmt|;
comment|/* Type of the current class.  */
name|tree
name|type
decl_stmt|;
comment|/* Flags for this class level.  */
name|int
name|this_is_variable
decl_stmt|;
name|int
name|memoized_lookups
decl_stmt|;
name|int
name|save_memoized
decl_stmt|;
name|int
name|unused
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|tree
name|current_class_decl
decl_stmt|,
name|C_C_D
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PARM_DECL: the class instance variable */
end_comment

begin_decl_stmt
name|tree
name|current_vtable_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following two can be derived from the previous one */
end_comment

begin_decl_stmt
name|tree
name|current_class_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IDENTIFIER_NODE: name of current class */
end_comment

begin_decl_stmt
name|tree
name|current_class_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _TYPE: the type of the current class */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|prev_class_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _TYPE: the previous type that was a class */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|get_vfield_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|the_null_vtable_entry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Way of stacking language names.  */
end_comment

begin_decl_stmt
name|tree
modifier|*
name|current_lang_base
decl_stmt|,
modifier|*
name|current_lang_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_lang_stacksize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names of languages we recognize.  */
end_comment

begin_decl_stmt
name|tree
name|lang_name_c
decl_stmt|,
name|lang_name_cplusplus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|current_lang_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When layout out an aggregate type, the size of the    basetypes (virtual and non-virtual) is passed to layout_record    via this node.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|base_layout_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables shared between cp-class.c and cp-call.c.  */
end_comment

begin_decl_stmt
name|int
name|n_vtables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_entries
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_searches
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_elems
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_convert_harshness
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_compute_conversion_costs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_build_method_call
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_inner_fields_searched
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Virtual baseclass things.  */
end_comment

begin_function
name|tree
name|build_vbase_pointer
parameter_list|(
name|exp
parameter_list|,
name|type
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|VBASE_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|VBASE_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|exp
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build multi-level access to EXPR using hierarchy path PATH.    CODE is PLUS_EXPR if we are going with the grain,    and MINUS_EXPR if we are not (in which case, we cannot traverse    virtual baseclass links).     TYPE is the type we want this path to have on exit.     ALIAS_THIS is non-zero if EXPR in an expression involving `this'.  */
end_comment

begin_function
name|tree
name|build_vbase_path
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|expr
parameter_list|,
name|path
parameter_list|,
name|alias_this
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|,
name|path
decl_stmt|;
name|int
name|alias_this
decl_stmt|;
block|{
specifier|register
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|tree
name|last
init|=
name|NULL_TREE
decl_stmt|,
name|last_virtual
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|nonnull
init|=
literal|0
decl_stmt|;
name|int
name|fixed_type_p
init|=
name|resolves_to_fixed_type_p
argument_list|(
name|expr
argument_list|,
operator|&
name|nonnull
argument_list|)
decl_stmt|;
name|tree
name|null_expr
init|=
literal|0
decl_stmt|,
name|nonnull_expr
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
name|tree
name|offset
init|=
name|integer_zero_node
decl_stmt|;
if|if
condition|(
operator|!
name|fixed_type_p
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|nonnull_expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|tree
name|reverse_path
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|path
condition|)
block|{
name|tree
name|r
init|=
name|copy_node
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|reverse_path
expr_stmt|;
name|reverse_path
operator|=
name|r
expr_stmt|;
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
name|path
operator|=
name|reverse_path
expr_stmt|;
block|}
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|path
condition|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|last_virtual
operator|=
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
block|{
name|changed
operator|=
operator|!
name|fixed_type_p
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
specifier|extern
name|int
name|flag_assume_nonnull_objects
decl_stmt|;
name|tree
name|ind
decl_stmt|;
if|if
condition|(
name|last
condition|)
name|nonnull_expr
operator|=
name|convert_pointer_to
argument_list|(
name|last
argument_list|,
name|nonnull_expr
argument_list|)
expr_stmt|;
name|ind
operator|=
name|build_indirect_ref
argument_list|(
name|nonnull_expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nonnull_expr
operator|=
name|build_vbase_pointer
argument_list|(
name|ind
argument_list|,
name|last_virtual
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonnull
operator|==
literal|0
operator|&&
operator|!
name|flag_assume_nonnull_objects
operator|&&
name|null_expr
operator|==
name|NULL_TREE
condition|)
block|{
name|null_expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|last_virtual
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|last_virtual
argument_list|)
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|null_expr
argument_list|,
name|nonnull_expr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* else we'll figure out the offset below.  */
comment|/* Happens in the case of parse errors.  */
if|if
condition|(
name|nonnull_expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|error_with_aggr_type
argument_list|(
name|last_virtual
argument_list|,
literal|"cannot cast up from virtual baseclass `%s'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|last
operator|=
name|path
expr_stmt|;
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* LAST is now the last basetype assoc on the path.  */
comment|/* A pointer to a virtual base member of a non-null object      is non-null.  Therefore, we only need to test for zeroness once.      Make EXPR the canonical expression to deal with here.  */
if|if
condition|(
name|null_expr
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
operator|=
name|nonnull_expr
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|nonnull_expr
argument_list|)
expr_stmt|;
block|}
else|else
name|expr
operator|=
name|nonnull_expr
expr_stmt|;
comment|/* If we go through any virtual base pointers, make sure that      casts to BASETYPE from the last virtual base class use      the right value for BASETYPE.  */
if|if
condition|(
name|changed
condition|)
block|{
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
operator|==
name|BINFO_TYPE
argument_list|(
name|last
argument_list|)
condition|)
name|basetype
operator|=
name|intype
expr_stmt|;
else|else
block|{
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|last
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|basetype
operator|=
name|last
expr_stmt|;
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|last_virtual
condition|)
block|{
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo_member
argument_list|(
name|last_virtual
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|basetype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* why unconditionally set this? (mrs) see deja-gnu/g++.mike/net15.C 	 for a test case. */
block|code = PLUS_EXPR;
endif|#
directive|endif
block|}
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|offset
argument_list|)
condition|)
block|{
comment|/* For multiple inheritance: if `this' can be set by any 	 function, then it could be 0 on entry to any function. 	 Preserve such zeroness here.  Otherwise, only in the 	 case of constructors need we worry, and in those cases, 	 it will be zero, or initialized to some legal value to 	 which we may add.  */
if|if
condition|(
name|nonnull
operator|==
literal|0
operator|&&
operator|(
name|alias_this
operator|==
literal|0
operator|||
name|flag_this_is_variable
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|null_expr
condition|)
name|TREE_TYPE
argument_list|(
name|null_expr
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
name|null_expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|null_expr
argument_list|,
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|offset
argument_list|)
return|;
block|}
comment|/* Cannot change the TREE_TYPE of a NOP_EXPR here, since it may      be used multiple times in initialization of multiple inheritance.  */
if|if
condition|(
name|null_expr
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
else|else
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Virtual function things.  */
end_comment

begin_comment
comment|/* Virtual functions to be dealt with after laying out our    base classes.  Usually this is used only when classes have virtual    baseclasses, but it can happen also when classes have non-virtual    baseclasses if the derived class overrides baseclass functions    at different offsets.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|pending_hard_virtuals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|doing_hard_virtuals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The names of the entries in the virtual table structure.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|delta_name
decl_stmt|,
name|pfn_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX This is set but never used.  (bpk) */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Temporary binfo list to memoize lookups of the left-most non-virtual    baseclass B in a lattice topped by T.  B can appear multiple times    in the lattice.    TREE_PURPOSE is B's TYPE_MAIN_VARIANT.    TREE_VALUE is the path by which B is reached from T.    TREE_TYPE is B's real type.     If TREE_TYPE is NULL_TREE, it means that B was reached via    a virtual baseclass.    N.B.: This list consists of nodes on the temporary obstack.  */
end_comment

begin_endif
unit|static tree leftmost_baseclasses;
endif|#
directive|endif
end_endif

begin_comment
comment|/* Build an entry in the virtual function table.    DELTA is the offset for the `this' pointer.    PFN is an ADDR_EXPR containing a pointer to the virtual function.    Note that the index (DELTA2) in the virtual function table    is always 0.  */
end_comment

begin_function
name|tree
name|build_vtable_entry
parameter_list|(
name|delta
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|delta
decl_stmt|,
name|pfn
decl_stmt|;
block|{
name|tree
name|elems
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|delta
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|pfn
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|entry
init|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|vtable_entry_type
argument_list|,
name|NULL_TREE
argument_list|,
name|elems
argument_list|)
decl_stmt|;
comment|/* DELTA is constructed by `size_int', which means it may be an      unsigned quantity on some platforms.  Therefore, we cannot use      `int_fits_type_p', because when DELTA is really negative,      `force_fit_type' will make it look like a very large number.  */
if|if
condition|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|short_integer_type_node
argument_list|)
argument_list|)
operator|<
name|TREE_INT_CST_LOW
argument_list|(
name|delta
argument_list|)
operator|)
operator|||
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|delta
argument_list|)
operator|<
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|short_integer_type_node
argument_list|)
argument_list|)
operator|)
condition|)
name|sorry
argument_list|(
literal|"object size exceeds built-in limit for virtual function table implementation"
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtable_entries
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Given an object INSTANCE, return an expression which yields    the virtual function corresponding to INDEX.  There are many special    cases for INSTANCE which we take care of here, mainly to avoid    creating extra tree nodes when we don't have to.  */
end_comment

begin_function
name|tree
name|build_vfn_ref
parameter_list|(
name|ptr_to_instptr
parameter_list|,
name|instance
parameter_list|,
name|index
parameter_list|)
name|tree
modifier|*
name|ptr_to_instptr
decl_stmt|,
name|instance
decl_stmt|;
name|tree
name|index
decl_stmt|;
block|{
specifier|extern
name|int
name|building_cleanup
decl_stmt|;
name|tree
name|vtbl
decl_stmt|,
name|aref
decl_stmt|;
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
name|C_C_D
condition|)
block|{
if|if
condition|(
name|current_vtable_decl
operator|==
name|NULL_TREE
operator|||
name|current_vtable_decl
operator|==
name|error_mark_node
operator|||
operator|!
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|DECL_FCONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
argument_list|,
name|basetype
argument_list|)
condition|)
name|vtbl
operator|=
name|build_indirect_ref
argument_list|(
name|build_vfield_ref
argument_list|(
name|instance
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|vtbl
operator|=
name|current_vtable_decl
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|optimize
condition|)
block|{
comment|/* Try to figure out what a reference refers to, and 	     access its virtual function table directly.  */
name|tree
name|ref
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|ref
operator|=
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|ref
operator|=
name|instance
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
condition|)
block|{
name|tree
name|init
init|=
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
name|instance
operator|=
name|init
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
name|vtbl
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
else|else
name|vtbl
operator|=
name|build_indirect_ref
argument_list|(
name|build_vfield_ref
argument_list|(
name|instance
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|assemble_external
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|aref
operator|=
name|build_array_ref
argument_list|(
name|vtbl
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|building_cleanup
operator|&&
name|TREE_CODE
argument_list|(
name|aref
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|TREE_OPERAND
argument_list|(
name|aref
argument_list|,
literal|0
argument_list|)
operator|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|aref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ptr_to_instptr
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|ptr_to_instptr
argument_list|)
argument_list|,
operator|*
name|ptr_to_instptr
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|delta_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|pfn_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set TREE_PUBLIC and/or TREE_EXTERN on the vtable DECL,    based on TYPE and other static flags.     Note that anything public is tagged TREE_PUBLIC, whether    it's public in this file or in another one.  */
end_comment

begin_function
specifier|static
name|void
name|import_export_vtable
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|;
block|{
if|if
condition|(
name|write_virtuals
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|write_virtuals
operator|!=
literal|0
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|<
literal|0
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the name of the virtual function table (as an IDENTIFIER_NODE)    for the given TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vtable_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type_id
init|=
name|build_typename_overload
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|VTABLE_NAME_FORMAT
argument_list|)
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|type_id
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|type_id
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ptr
index|[
name|i
index|]
operator|==
name|OPERATOR_TYPENAME_FORMAT
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
while|while
condition|(
name|ptr
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|ptr
index|[
name|i
index|]
operator|<=
literal|'9'
condition|)
name|i
operator|+=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VTABLE_NAME_FORMAT
argument_list|,
name|ptr
operator|+
name|i
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a virtual function for type TYPE.    If BINFO is non-NULL, build the vtable starting with the initial    approximation that it is the same as the one which is the head of    the association list.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtable
parameter_list|(
name|binfo
parameter_list|,
name|type
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|name
init|=
name|get_vtable_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|virtuals
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
name|virtuals
operator|=
name|copy_list
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|virtuals
operator|=
name|NULL_TREE
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtables
operator|+=
literal|1
expr_stmt|;
name|n_vtable_elems
operator|+=
name|list_length
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set TREE_PUBLIC and TREE_EXTERN as appropriate.  */
name|import_export_vtable
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|decl
operator|=
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Initialize the association list for this type, based      on our first approximation.  */
name|TYPE_BINFO_VTABLE
argument_list|(
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|type
argument_list|)
operator|=
name|virtuals
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|&&
name|write_virtuals
operator|>=
literal|0
condition|)
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Remember which class this vtable is really for.  */
block|if (binfo)     DECL_VPARENT (decl) = BINFO_TYPE (binfo);   else     DECL_VPARENT (decl) = type;
endif|#
directive|endif
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SET_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Give TYPE a new virtual function table which is initialized    with a skeleton-copy of its original initialization.  The only    entry that changes is the `delta' entry, so we can really    share a lot of structure.     FOR_TYPE is the derived type which caused this table to    be needed.     BINFO is the type association which provided TYPE for FOR_TYPE.     The way we update BASE_BINFO's vtable information is just to change the    association information in FOR_TYPE's association list.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_fresh_vtable
parameter_list|(
name|binfo
parameter_list|,
name|base_binfo
parameter_list|,
name|for_type
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|base_binfo
decl_stmt|,
name|for_type
decl_stmt|;
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|orig_decl
init|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|build_type_pathname
argument_list|(
name|VTABLE_NAME_FORMAT
argument_list|,
name|basetype
argument_list|,
name|for_type
argument_list|)
decl_stmt|;
name|tree
name|new_decl
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|path
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* Remember which class this vtable is really for.  */
if|#
directive|if
literal|0
block|DECL_VPARENT (new_decl) = BINFO_TYPE (base_binfo);
endif|#
directive|endif
name|DECL_CONTEXT
argument_list|(
name|new_decl
argument_list|)
operator|=
name|for_type
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|pushdecl_top_level
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|orig_decl
argument_list|)
expr_stmt|;
comment|/* Make fresh virtual list, so we can smash it later.  */
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
operator|=
name|copy_list
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Install the value for `headof' if that's what we're doing.  */
if|if
condition|(
name|flag_dossier
condition|)
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
operator|=
name|build_vtable_entry
argument_list|(
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtables
operator|+=
literal|1
expr_stmt|;
name|n_vtable_elems
operator|+=
name|list_length
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set TREE_PUBLIC and TREE_EXTERN as appropriate.  */
name|import_export_vtable
argument_list|(
name|new_decl
argument_list|,
name|for_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|my_friendly_assert
argument_list|(
name|binfo
operator|==
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
argument_list|,
literal|170
argument_list|)
expr_stmt|;
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|SET_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* Mark all types between FOR_TYPE and TYPE as having been      touched, so that if we change virtual function table entries,      new vtables will be initialized.  We may reach the virtual      baseclass via ambiguous intervening baseclasses.  This      loop makes sure we get through to the actual baseclass we marked.       Also, update the vtable entries to reflect the overrides      of the top-most class (short of the top type).  */
do|do
block|{
name|result
operator|=
name|get_base_distance
argument_list|(
name|basetype
argument_list|,
name|for_type
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|for_type
operator|=
name|path
expr_stmt|;
while|while
condition|(
name|path
condition|)
block|{
name|tree
name|path_binfo
init|=
name|path
decl_stmt|;
name|tree
name|path_type
init|=
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
condition|)
name|path_binfo
operator|=
name|binfo_member
argument_list|(
name|path_type
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
name|SET_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|path_binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
operator|&&
name|CLASSTYPE_VFIELD
argument_list|(
name|path_type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|path_type
argument_list|)
argument_list|)
operator|)
comment|/* This is the baseclass just before the original FOR_TYPE.  */
operator|&&
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|old_virtuals
init|=
name|TREE_CHAIN
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|new_virtuals
init|=
name|TREE_CHAIN
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|path_binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_dossier
condition|)
block|{
name|old_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|old_virtuals
argument_list|)
expr_stmt|;
name|new_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|new_virtuals
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|old_virtuals
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|old_virtuals
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|new_virtuals
argument_list|)
expr_stmt|;
name|old_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|old_virtuals
argument_list|)
expr_stmt|;
name|new_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|new_virtuals
argument_list|)
expr_stmt|;
block|}
block|}
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|result
operator|==
operator|-
literal|2
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Access the virtual function table entry that logically    contains BASE_FNDECL.  VIRTUALS is the virtual function table's    initializer.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vtable_entry
parameter_list|(
name|virtuals
parameter_list|,
name|base_fndecl
parameter_list|)
name|tree
name|virtuals
decl_stmt|,
name|base_fndecl
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|i
init|=
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
name|BITS_PER_WORD
ifdef|#
directive|ifdef
name|VTABLE_USES_MASK
operator|&&
literal|0
endif|#
directive|endif
condition|?
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_VINDEX
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
operator|&
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
else|:
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_VINDEX
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtable_searches
operator|+=
name|i
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
block|}
return|return
name|virtuals
return|;
block|}
end_function

begin_comment
comment|/* Put new entry ENTRY into virtual function table initializer    VIRTUALS.  The virtual function table is for type CONTEXT.     Also update DECL_VINDEX (FNDECL).  */
end_comment

begin_function
specifier|static
name|void
name|modify_vtable_entry
parameter_list|(
name|old_entry_in_list
parameter_list|,
name|new_entry
parameter_list|,
name|fndecl
parameter_list|,
name|context
parameter_list|)
name|tree
name|old_entry_in_list
decl_stmt|,
name|new_entry
decl_stmt|,
name|fndecl
decl_stmt|,
name|context
decl_stmt|;
block|{
name|tree
name|base_pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|old_entry_in_list
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|vindex
decl_stmt|;
comment|/* We can't put in the really right offset information      here, since we have not yet laid out the class to      take into account virtual base classes.  */
name|TREE_VALUE
argument_list|(
name|old_entry_in_list
argument_list|)
operator|=
name|new_entry
expr_stmt|;
name|vindex
operator|=
name|DECL_VINDEX
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base_pfn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|=
name|vindex
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|vindex
argument_list|)
condition|)
block|{
name|tree
name|elts
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|new_entry
argument_list|)
decl_stmt|;
name|tree
name|vfield
init|=
name|CLASSTYPE_VFIELD
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|doing_hard_virtuals
condition|)
block|{
name|pending_hard_virtuals
operator|=
name|tree_cons
argument_list|(
name|fndecl
argument_list|,
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|new_entry
argument_list|)
argument_list|,
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|pending_hard_virtuals
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|base_pfn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|my_friendly_abort (3);
comment|/* Compute the relative offset of vtable we are really looking for.  */
block|TREE_VALUE (elts) = size_binop (PLUS_EXPR, 					  size_int (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (vfield))
comment|/* ??? This may be wrong. */
block|/ BITS_PER_UNIT), 					  TREE_VALUE (elts));
comment|/* Say what index to use when we use that vtable.  */
ifndef|#
directive|ifndef
name|VTABLE_USES_MASK
block|vindex = build_int_2 (TREE_INT_CST_LOW (vindex)& ~((unsigned HOST_WIDE_INT) 1<< (BITS_PER_WORD -1)), 0);
endif|#
directive|endif
block|TREE_VALUE (TREE_CHAIN (elts)) = vindex;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check to ensure that the virtual function table slot in VFIELD,    found by DECL_VINDEX of the BASE_FNDECL is in fact from a parent    virtual function table that is the same parent as for the    BASE_FNDECL given to us.  */
end_comment

begin_function
specifier|static
name|int
name|related_vslot
parameter_list|(
name|base_fndecl
parameter_list|,
name|vfields
parameter_list|,
name|type
parameter_list|)
name|tree
name|base_fndecl
decl_stmt|,
name|vfields
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|base_context
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base
decl_stmt|;
name|tree
name|path
decl_stmt|;
name|int
name|distance
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|vfields
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|base
operator|=
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL_TREE
condition|)
name|base
operator|=
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
comment|/* The simple right way to do this is to ensure that the context of      the base virtual function is found along the leftmost path      between the most derived type associated with the vfield and the      current type.  */
name|distance
operator|=
name|get_base_distance
argument_list|(
name|base
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|distance
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|path
condition|)
block|{
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
operator|==
name|base_context
condition|)
return|return
literal|1
return|;
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* given: 		Rr 	       / \ 	      Mm  Hh 	       \ / 	        P       make sure we fill in P's vtable for H with overrides of r,      but be cautious of virtual base classes.  */
comment|/* Combine the two below after debugging. */
if|if
condition|(
name|get_base_distance
argument_list|(
name|base_context
argument_list|,
name|base
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
while|while
condition|(
name|path
condition|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
condition|)
return|return
literal|0
return|;
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Modify virtual function tables in lattice topped by T to    place FNDECL in tables which previously held BASE_FNDECL.    PFN is just FNDECL wrapped in an ADDR_EXPR, so that it    is suitable for placement directly into an initializer.     All distinct virtual function tables that this type uses    must be updated.  */
end_comment

begin_function
specifier|static
name|void
name|modify_vtable_entries
parameter_list|(
name|t
parameter_list|,
name|fndecl
parameter_list|,
name|base_fndecl
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|fndecl
decl_stmt|,
name|base_fndecl
decl_stmt|,
name|pfn
decl_stmt|;
block|{
name|tree
name|base_offset
decl_stmt|,
name|offset
decl_stmt|;
name|tree
name|base_context
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|base_fndecl
argument_list|)
decl_stmt|;
name|tree
name|context
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|vfield
init|=
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|vfields
decl_stmt|,
name|vbases
decl_stmt|;
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|base_fndecl
argument_list|)
expr_stmt|;
name|offset
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|t
operator|&&
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|offset
operator|=
name|virtual_offset
argument_list|(
name|context
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|binfo
init|=
name|binfo_value
argument_list|(
name|context
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For each layer of base class (i.e., the first base class, and each      virtual base class from that one), modify the virtual function table      of the derived class to contain the new virtual function.      A class has as many vfields as it has virtual base classes (total).  */
for|for
control|(
name|vfields
operator|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
init|;
name|vfields
condition|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
control|)
block|{
name|int
name|normal
init|=
literal|1
decl_stmt|;
name|tree
name|binfo
decl_stmt|,
name|this_offset
decl_stmt|;
name|tree
name|base
decl_stmt|,
name|path
decl_stmt|;
comment|/* This can go away when the new searching strategy as a little mileage on it. */
define|#
directive|define
name|NEW_SEARCH
value|1
if|#
directive|if
name|NEW_SEARCH
if|if
condition|(
operator|!
name|related_vslot
argument_list|(
name|base_fndecl
argument_list|,
name|vfields
argument_list|,
name|t
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* Find the right base class for this derived class, call it BASE.  */
name|base
operator|=
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
if|#
directive|if
name|NEW_SEARCH
operator|==
literal|0
if|if
condition|(
name|base
operator|!=
name|base_context
condition|)
block|{
comment|/* If BASE_FNDECL is not contained in the vtable accessed by 	     the vslot, don't try to modify the vtable. 	      	     Virtual functions from virtual baseclasses are not in derived 	     virtual function tables.  This is an implementation decision; 	     it keeps there from being a combinatorial explosion in the 	     number of different vtables which must be maintained.  */
comment|/* In this case, we need to know whether BASE is derived 	     from BASE_CONTEXT in any case, even the case where the 	     derivation is ambiguous.  */
name|int
name|distance
init|=
name|get_base_distance
argument_list|(
name|base
argument_list|,
name|base_context
argument_list|,
literal|0
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|<
literal|0
operator|&&
name|distance
operator|!=
operator|-
literal|2
condition|)
continue|continue;
comment|/* BASE_FNDECL is defined in a class derived from 	     the base class owning this VFIELD.  */
block|}
endif|#
directive|endif
comment|/* Get the path starting from the deepest base class CONTEXT 	 of T (i.e., first defn of BASE_FNDECL).  */
name|get_base_distance
argument_list|(
name|base_context
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
comment|/* Get our best approximation of what to use for constructing 	 the virtual function table for T.  */
do|do
block|{
comment|/* Walk from base toward derived, stopping at the 	     most derived baseclass that matters.  That baseclass 	     is exactly the one which provides the vtable along 	     the VFIELD spine, but no more.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|base
operator|=
name|path
expr_stmt|;
name|binfo
operator|=
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|(
name|BINFO_TYPE
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
operator|)
operator|||
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|base
operator|=
name|path
expr_stmt|;
name|binfo
operator|=
name|base
expr_stmt|;
break|break;
block|}
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/* Find the right offset for the this pointer based on the base 	 class we just found.  */
name|base_offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|this_offset
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset
argument_list|,
name|base_offset
argument_list|)
expr_stmt|;
comment|/* Make sure we can modify the derived association with immunity.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|copy_binfo
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We call this case NORMAL iff this virtual function table 	 pointer field has its storage reserved in this class. 	 This is normally the case without virtual baseclasses 	 or off-center multiple baseclasses.  */
name|normal
operator|=
operator|(
name|vfield
operator|!=
name|NULL_TREE
operator|&&
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
operator|==
name|DECL_FCONTEXT
argument_list|(
name|vfield
argument_list|)
operator|&&
operator|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|normal
operator|&&
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
condition|)
comment|/* Everything looks normal so far...check that we are really 	   working from VFIELD's basetype, and not some other appearance 	   of that basetype in the lattice.  */
name|normal
operator|=
operator|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
operator|==
name|get_binfo
argument_list|(
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|normal
condition|)
block|{
comment|/* In this case, it is *type*'s vtable we are modifying. 	     We start with the approximation that it's vtable is that 	     of the immediate base class.  */
name|base_context
operator|=
name|t
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is our very own copy of `basetype' to play with. 	     Later, we will fill in all the virtual functions 	     that override the virtual functions in these base classes 	     which are not defined by the current type.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|base
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|modify_vtable_entry
argument_list|(
name|get_vtable_entry
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|base_fndecl
argument_list|)
argument_list|,
name|build_vtable_entry
argument_list|(
name|this_offset
argument_list|,
name|pfn
argument_list|)
argument_list|,
name|fndecl
argument_list|,
name|base_context
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|this_offset
decl_stmt|;
name|tree
name|base
decl_stmt|,
name|path
decl_stmt|;
if|if
condition|(
operator|!
name|BINFO_VTABLE
argument_list|(
name|vbases
argument_list|)
condition|)
comment|/* There are only two ways that a type can fail to have 	   virtual functions: neither it nor any of its base 	   types define virtual functions (in which case 	   no updating need be done), or virtual functions 	   accessible to it come from virtual base classes 	   (in which case we have or will get them modified 	   in other passes of this loop).  */
continue|continue;
name|base
operator|=
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
name|path
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|base
operator|!=
name|base_context
operator|&&
name|get_base_distance
argument_list|(
name|base_context
argument_list|,
name|base
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|path
condition|)
name|this_offset
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|this_offset
operator|=
name|offset
expr_stmt|;
comment|/* Doesn't matter if not actually from this virtual base class,          but shouldn't come from deeper virtual baseclasses.  The enclosing 	 loop should take care of such baseclasses.  */
while|while
condition|(
name|path
condition|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
condition|)
goto|goto
name|skip
goto|;
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
name|base_offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
name|this_offset
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|this_offset
argument_list|,
name|base_offset
argument_list|)
expr_stmt|;
comment|/* Make sure we can modify the derived association with immunity.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|copy_binfo
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is our very own copy of `basetype' to play with.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|vbases
argument_list|)
condition|)
block|{
name|tree
name|context_binfo
init|=
name|binfo_value
argument_list|(
name|base_context
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|prepare_fresh_vtable
argument_list|(
name|vbases
argument_list|,
name|context_binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|modify_vtable_entry
argument_list|(
name|get_vtable_entry
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|base_fndecl
argument_list|)
argument_list|,
name|build_vtable_entry
argument_list|(
name|this_offset
argument_list|,
name|pfn
argument_list|)
argument_list|,
name|fndecl
argument_list|,
name|base_context
argument_list|)
expr_stmt|;
name|skip
label|:
block|{}
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|add_virtual_function
parameter_list|(
name|pending_virtuals
parameter_list|,
name|has_virtual
parameter_list|,
name|x
parameter_list|,
name|t
parameter_list|)
name|tree
name|pending_virtuals
decl_stmt|;
name|int
modifier|*
name|has_virtual
decl_stmt|;
name|tree
name|x
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Structure type. */
block|{
name|int
name|debug_vbase
init|=
literal|1
decl_stmt|;
comment|/* FUNCTION_TYPEs and OFFSET_TYPEs no longer freely      convert to void *.  Make such a conversion here.  */
name|tree
name|vfn
init|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|x
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vfn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* current_class_type may be NULL_TREE in case of error.  */
if|if
condition|(
name|current_class_type
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
comment|/* If the virtual function is a redefinition of a prior one,      figure out in which base class the new definition goes,      and if necessary, make a fresh virtual function table      to hold that entry.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|tree
name|entry
init|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|vfn
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_dossier
operator|&&
operator|*
name|has_virtual
operator|==
literal|0
condition|)
block|{
comment|/* CLASSTYPE_DOSSIER is only used as a Boolean (NULL or not). */
name|CLASSTYPE_DOSSIER
argument_list|(
name|t
argument_list|)
operator|=
name|integer_one_node
expr_stmt|;
operator|*
name|has_virtual
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Build a new INT_CST for this DECL_VINDEX.  */
ifdef|#
directive|ifdef
name|VTABLE_USES_MASK
name|SET_DECL_VINDEX
argument_list|(
name|x
argument_list|,
name|build_int_2
argument_list|(
operator|++
operator|(
operator|*
name|has_virtual
operator|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
specifier|static
name|tree
name|index_table
index|[
literal|256
index|]
decl_stmt|;
name|tree
name|index
decl_stmt|;
name|int
name|i
init|=
operator|++
operator|(
operator|*
name|has_virtual
operator|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|256
operator|||
name|index_table
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|index
operator|=
name|build_int_2
argument_list|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator||
name|i
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|256
condition|)
name|index_table
index|[
name|i
index|]
operator|=
name|index
expr_stmt|;
block|}
else|else
name|index
operator|=
name|index_table
index|[
name|i
index|]
expr_stmt|;
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
operator|=
name|index
expr_stmt|;
block|}
endif|#
directive|endif
name|pending_virtuals
operator|=
name|tree_cons
argument_list|(
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
argument_list|,
name|entry
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
block|}
comment|/* Happens if declared twice in class or we're not in a class definition.      We will give error later or we've already given it.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|current_class_type
operator|==
name|NULL_TREE
condition|)
return|return
name|pending_virtuals
return|;
elseif|else
if|if
condition|(
name|debug_vbase
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
comment|/* Need an entry in some other virtual function table.          Deal with this after we have laid out our virtual base classes.  */
name|pending_hard_virtuals
operator|=
name|temp_tree_cons
argument_list|(
name|x
argument_list|,
name|vfn
argument_list|,
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Need an entry in some other virtual function table.          We can do this now.  */
name|tree
name|base_fndecl_list
init|=
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
decl_stmt|,
name|base_fndecls
decl_stmt|,
name|prev
init|=
literal|0
decl_stmt|;
name|tree
name|vtable_context
init|=
name|DECL_FCONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|true_base_fndecl
init|=
literal|0
decl_stmt|;
comment|/* First assign DECL_VINDEX from the base vfn with which 	 we share our vtable.  */
name|base_fndecls
operator|=
name|base_fndecl_list
expr_stmt|;
while|while
condition|(
name|base_fndecls
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|DECL_FCONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|vtable_context
condition|)
block|{
name|true_base_fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
name|modify_vtable_entries
argument_list|(
name|current_class_type
argument_list|,
name|x
argument_list|,
name|true_base_fndecl
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
else|else
name|base_fndecl_list
operator|=
name|prev
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|base_fndecls
expr_stmt|;
name|base_fndecls
operator|=
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
comment|/* Now fill in the rest of the vtables.  */
name|base_fndecls
operator|=
name|base_fndecl_list
expr_stmt|;
while|while
condition|(
name|base_fndecls
condition|)
block|{
comment|/* If we haven't found one we like, first one wins.  */
if|if
condition|(
name|true_base_fndecl
operator|==
literal|0
condition|)
name|true_base_fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
name|modify_vtable_entries
argument_list|(
name|current_class_type
argument_list|,
name|x
argument_list|,
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
name|base_fndecls
operator|=
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|true_base_fndecl
argument_list|)
expr_stmt|;
block|}
return|return
name|pending_virtuals
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Obstack on which to build the vector of class methods.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|class_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add method METHOD to class TYPE.  This is used when a method    has been defined which did not initially appear in the class definition,    and helps cut down on spurious error messages.     FIELDS is the entry in the METHOD_VEC vector entry of the class type where    the method should be added.  */
end_comment

begin_function
name|void
name|add_method
parameter_list|(
name|type
parameter_list|,
name|fields
parameter_list|,
name|method
parameter_list|)
name|tree
name|type
decl_stmt|,
decl|*
name|fields
decl_stmt|,
name|method
decl_stmt|;
end_function

begin_block
block|{
comment|/* We must make a copy of METHOD here, since we must be sure that      we have exclusive title to this method's DECL_CHAIN.  */
name|tree
name|decl
decl_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
block|{
name|decl
operator|=
name|copy_node
argument_list|(
name|method
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|processing_template_decl
operator|||
operator|!
name|uses_template_parms
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
name|make_function_rtl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|method
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fields
operator|&&
operator|*
name|fields
condition|)
block|{
comment|/* Take care not to hide destructor.  */
name|DECL_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_CHAIN
argument_list|(
operator|*
name|fields
argument_list|)
expr_stmt|;
name|DECL_CHAIN
argument_list|(
operator|*
name|fields
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|method_vec
init|=
name|make_node
argument_list|(
name|TREE_VEC
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? Is it possible for there to have been enough room in the 	     current chunk for the tree_vec structure but not a tree_vec 	     plus a tree*?  Will this work in that case?  */
name|obstack_free
argument_list|(
name|current_obstack
argument_list|,
name|method_vec
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
name|current_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_vec
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
literal|2
expr_stmt|;
name|obstack_finish
argument_list|(
name|current_obstack
argument_list|)
expr_stmt|;
block|}
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|method_vec
expr_stmt|;
block|}
else|else
block|{
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
comment|/* Adding a new ctor or dtor.  This is easy because our          METHOD_VEC always has a slot for such entries.  */
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* TREE_VEC_ELT (method_vec, 0) = decl; */
if|if
condition|(
name|decl
operator|!=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|DECL_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is trickier.  We try to extend the TREE_VEC in-place, 	     but if that does not work, we copy all its data to a new 	     TREE_VEC that's large enough.  */
name|struct
name|obstack
modifier|*
name|ob
init|=
operator|&
name|class_obstack
decl_stmt|;
name|tree
modifier|*
name|end
init|=
operator|(
name|tree
operator|*
operator|)
name|obstack_next_free
argument_list|(
name|ob
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
condition|)
block|{
name|ob
operator|=
name|current_obstack
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|+=
literal|1
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|len
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|method_vec
operator|=
name|copy_node
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|-=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tree
name|tmp_vec
init|=
operator|(
name|tree
operator|)
name|obstack_base
argument_list|(
name|ob
argument_list|)
decl_stmt|;
if|if
condition|(
name|obstack_room
argument_list|(
name|ob
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
condition|)
block|{
name|obstack_blank
argument_list|(
name|ob
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_VEC
index|]
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|+
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_vec
operator|=
operator|(
name|tree
operator|)
name|obstack_base
argument_list|(
name|ob
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|method_vec
argument_list|,
name|tmp_vec
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_VEC
index|]
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|+
operator|(
name|len
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|method_vec
operator|=
name|tmp_vec
expr_stmt|;
block|}
else|else
name|obstack_blank
argument_list|(
name|ob
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|obstack_finish
argument_list|(
name|ob
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|len
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
name|len
operator|+
literal|1
expr_stmt|;
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|method_vec
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* ??? May be better to know whether these can be extended?  */
name|tree
name|baselink_vec
init|=
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|baselink_vec
argument_list|)
operator|+=
literal|1
expr_stmt|;
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|copy_node
argument_list|(
name|baselink_vec
argument_list|)
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|baselink_vec
argument_list|)
operator|-=
literal|1
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|len
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Subroutines of finish_struct.  */
end_comment

begin_comment
comment|/* Look through the list of fields for this struct, deleting    duplicates as we go.  This must be recursive to handle    anonymous unions.     FIELD is the field which may not appear anywhere in FIELDS.    FIELD_PTR, if non-null, is the starting point at which    chained deletions may take place.    The value returned is the first acceptable entry found    in FIELDS.     Note that anonymous fields which are not of UNION_TYPE are    not duplicates, they are just anonymous fields.  This happens    when we have unnamed bitfields, for example.  */
end_comment

begin_function
specifier|static
name|tree
name|delete_duplicate_fields_1
parameter_list|(
name|field
parameter_list|,
name|field_ptr
parameter_list|,
name|fields
parameter_list|)
name|tree
name|field
decl_stmt|,
decl|*
name|field_ptr
decl_stmt|,
name|fields
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|x
decl_stmt|;
name|tree
name|prev
init|=
name|field_ptr
condition|?
operator|*
name|field_ptr
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
return|return
name|fields
return|;
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
name|fields
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|x
argument_list|,
name|field_ptr
argument_list|,
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|fields
expr_stmt|;
return|return
name|fields
return|;
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|prev
operator|=
name|x
operator|,
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
continue|continue;
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|field
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"duplicate enum value `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"duplicate field `%s' (as enum and non-enum)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"duplicate class scope type `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"duplicate field `%s' (as type and non-type)"
argument_list|)
expr_stmt|;
else|else
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"duplicate member `%s'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|fields
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|delete_duplicate_fields
parameter_list|(
name|fields
parameter_list|)
name|tree
name|fields
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
operator|&&
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|x
argument_list|,
operator|&
name|x
argument_list|,
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change the visibility of T::FDECL to VISIBILITY.    Return 1 if change was legit, otherwise return 0.  */
end_comment

begin_function
specifier|static
name|int
name|alter_visibility
parameter_list|(
name|t
parameter_list|,
name|fdecl
parameter_list|,
name|visibility
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|fdecl
decl_stmt|;
name|enum
name|visibility_type
name|visibility
decl_stmt|;
block|{
name|tree
name|elem
init|=
name|purpose_member
argument_list|(
name|t
argument_list|,
name|DECL_VISIBILITY
argument_list|(
name|fdecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|elem
operator|&&
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
operator|!=
operator|(
name|tree
operator|)
name|visibility
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fdecl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
name|TREE_TYPE
argument_list|(
name|fdecl
argument_list|)
argument_list|,
literal|"conflicting visibility specifications for method `%s', ignored"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"conflicting visibility specifications for field `%s', ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fdecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|fdecl
argument_list|)
operator|&&
name|visibility
operator|!=
name|visibility_private
condition|)
name|error_with_decl
argument_list|(
name|fdecl
argument_list|,
literal|"cannot make private `%s' non-private"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|fdecl
argument_list|)
operator|&&
name|visibility
operator|==
name|visibility_public
condition|)
name|error_with_decl
argument_list|(
name|fdecl
argument_list|,
literal|"cannot make protected `%s' public"
argument_list|)
expr_stmt|;
comment|/* ARM 11.3: an access declaration may not be used to restrict access      to a member that is accessible in the base class.  */
elseif|else
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|fdecl
argument_list|)
operator|&&
operator|(
name|visibility
operator|==
name|visibility_private
operator|||
name|visibility
operator|==
name|visibility_protected
operator|)
condition|)
name|error_with_decl
argument_list|(
name|fdecl
argument_list|,
literal|"cannot reduce visibility of public member `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|elem
operator|==
name|NULL_TREE
condition|)
block|{
name|DECL_VISIBILITY
argument_list|(
name|fdecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|t
argument_list|,
operator|(
name|tree
operator|)
name|visibility
argument_list|,
name|DECL_VISIBILITY
argument_list|(
name|fdecl
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|get_vfield_offset
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If FOR_TYPE needs to reinitialize virtual function table pointers    for TYPE's sub-objects, add such reinitializations to BASE_INIT_LIST.    Returns BASE_INIT_LIST appropriately modified.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_fixup_vptrs
parameter_list|(
name|for_type
parameter_list|,
name|binfo
parameter_list|,
name|base_init_list
parameter_list|)
name|tree
name|for_type
decl_stmt|,
name|binfo
decl_stmt|,
name|base_init_list
decl_stmt|;
block|{
comment|/* Now reinitialize any slots that don't fall under our virtual      function table pointer.  */
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
name|tree
name|base_binfo
init|=
name|get_binfo
argument_list|(
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|,
name|for_type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|base_offset
init|=
name|get_vfield_offset
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|base_offset
argument_list|,
name|get_vfield_offset
argument_list|(
name|TYPE_BINFO
argument_list|(
name|for_type
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|base_offset
argument_list|,
name|get_vfield_offset
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
name|base_init_list
operator|=
name|tree_cons
argument_list|(
name|error_mark_node
argument_list|,
name|base_binfo
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
block|}
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
return|return
name|base_init_list
return|;
block|}
end_function

begin_comment
comment|/* If TYPE does not have a constructor, then the compiler must    manually deal with all of the initialization this type requires.     If a base initializer exists only to fill in the virtual function    table pointer, then we mark that fact with the TREE_VIRTUAL bit.    This way, we avoid multiple initializations of the same field by    each virtual function table up the class hierarchy.     Virtual base class pointers are not initialized here.  They are    initialized only at the "top level" of object creation.  If we    initialized them here, we would have to skip a lot of work.  */
end_comment

begin_function
specifier|static
name|void
name|build_class_init_list
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|base_init_list
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|member_init_list
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Since we build member_init_list and base_init_list using      tree_cons, backwards fields the all through work.  */
name|tree
name|x
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|member_init_list
operator|=
name|tree_cons
argument_list|(
name|x
argument_list|,
name|type
argument_list|,
name|member_init_list
argument_list|)
expr_stmt|;
block|}
name|member_init_list
operator|=
name|nreverse
argument_list|(
name|member_init_list
argument_list|)
expr_stmt|;
comment|/* We will end up doing this last.  Need special marker      to avoid infinite regress.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|base_init_list
operator|=
name|build_tree_list
argument_list|(
name|error_mark_node
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|TREE_VALUE
argument_list|(
name|base_init_list
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|base_init_list
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Each base class which needs to have initialization      of some kind gets to make such requests known here.  */
for|for
control|(
name|i
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|blist
decl_stmt|;
comment|/* Don't initialize virtual baseclasses this way.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
comment|/* ...and the last shall come first...  */
name|base_init_list
operator|=
name|maybe_fixup_vptrs
argument_list|(
name|type
argument_list|,
name|base_binfo
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
name|base_init_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|blist
operator|=
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL_TREE
condition|)
comment|/* Nothing to initialize.  */
continue|continue;
comment|/* ...ditto...  */
name|base_init_list
operator|=
name|maybe_fixup_vptrs
argument_list|(
name|type
argument_list|,
name|base_binfo
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
comment|/* This is normally true for single inheritance. 	 The win is we can shrink the chain of initializations 	 to be done by only converting to the actual type 	 we are interested in.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|blist
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|blist
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
operator|&&
name|tree_int_cst_equal
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|TREE_VALUE
argument_list|(
name|blist
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|base_init_list
condition|)
block|{
comment|/* Does it do more than just fill in a 		 virtual function table pointer?  */
if|if
condition|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|blist
argument_list|)
condition|)
name|base_init_list
operator|=
name|build_tree_list
argument_list|(
name|blist
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
comment|/* Can we get by just with the virtual function table 		 pointer that it fills in?  */
elseif|else
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|base_init_list
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|base_init_list
argument_list|)
operator|==
literal|0
condition|)
name|base_init_list
operator|=
name|blist
expr_stmt|;
comment|/* Maybe, but it is not obvious as the previous case.  */
elseif|else
if|if
condition|(
operator|!
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|last
init|=
name|tree_last
argument_list|(
name|base_init_list
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|last
operator|=
name|tree_last
argument_list|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
operator|==
literal|0
condition|)
name|base_init_list
operator|=
name|build_tree_list
argument_list|(
name|blist
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|base_init_list
operator|=
name|blist
expr_stmt|;
block|}
else|else
block|{
comment|/* The function expand_aggr_init knows how to do the 	     initialization of `basetype' without getting 	     an explicit `blist'.  */
if|if
condition|(
name|base_init_list
condition|)
name|base_init_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
else|else
name|base_init_list
operator|=
name|CLASSTYPE_BINFO_AS_LIST
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|base_init_list
condition|)
if|if
condition|(
name|member_init_list
condition|)
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|base_init_list
argument_list|,
name|member_init_list
argument_list|)
expr_stmt|;
else|else
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|base_init_list
expr_stmt|;
elseif|else
if|if
condition|(
name|member_init_list
condition|)
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|member_init_list
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|base_info
block|{
name|int
name|has_virtual
decl_stmt|;
name|int
name|max_has_virtual
decl_stmt|;
name|int
name|n_ancestors
decl_stmt|;
name|tree
name|vfield
decl_stmt|;
name|tree
name|vfields
decl_stmt|;
name|char
name|needs_default_ctor
decl_stmt|;
name|char
name|cant_have_default_ctor
decl_stmt|;
name|char
name|needs_const_ctor
decl_stmt|;
name|char
name|cant_have_const_ctor
decl_stmt|;
name|char
name|members_need_dtors
decl_stmt|;
name|char
name|needs_virtual_dtor
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Record information about type T derived from its base classes.    Store most of that information in T itself, and place the    remaining information in the struct BASE_INFO.     Propagate basetype offsets throughout the lattice.  Note that the    lattice topped by T is really a pair: it's a DAG that gives the    structure of the derivation hierarchy, and it's a list of the    virtual baseclasses that appear anywhere in the DAG.  When a vbase    type appears in the DAG, it's offset is 0, and it's children start    their offsets from that point.  When a vbase type appears in the list,    its offset is the offset it has in the hierarchy, and its children's    offsets include that offset in theirs.     Returns the index of the first base class to have virtual functions,    or zero if no such base class.  */
end_comment

begin_function
specifier|static
name|int
name|finish_base_struct
parameter_list|(
name|t
parameter_list|,
name|b
parameter_list|,
name|binfos
parameter_list|)
name|tree
name|t
decl_stmt|;
name|struct
name|base_info
modifier|*
name|b
decl_stmt|;
name|tree
name|binfos
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|first_vfn_base_index
init|=
operator|-
literal|1
decl_stmt|;
name|bzero
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|base_info
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
comment|/* If the type of basetype is incomplete, then 	 we already complained about that fact 	 (and we should have fixed it up as well).  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* The base type is of incomplete type.  It is 	     probably best to pretend that it does not 	     exist.  */
if|if
condition|(
name|i
operator|==
name|n_baseclasses
operator|-
literal|1
condition|)
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|-=
literal|1
expr_stmt|;
name|n_baseclasses
operator|-=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|+
literal|1
operator|<
name|n_baseclasses
condition|;
name|j
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
name|b
operator|->
name|members_need_dtors
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
name|b
operator|->
name|needs_default_ctor
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
name|b
operator|->
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_GETS_CONST_INIT_REF
argument_list|(
name|basetype
argument_list|)
condition|)
name|b
operator|->
name|needs_const_ctor
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_GETS_INIT_REF
argument_list|(
name|basetype
argument_list|)
condition|)
name|b
operator|->
name|cant_have_const_ctor
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_ALTERS_VISIBILITIES_P
argument_list|(
name|t
argument_list|)
operator||=
name|CLASSTYPE_ALTERS_VISIBILITIES_P
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|n_ancestors
operator|+=
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_GETS_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_GETS_INIT_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
if|#
directive|if
literal|0
comment|/* This cannot be done, as prepare_fresh_vtable wants to modify 	     binfos associated with vfields anywhere in the hierarchy, not 	     just immediate base classes.  Due to unsharing, the compiler 	     might consume 3% more memory on a real program. 	     */
expr|&& ! BINFO_OFFSET_ZEROP (base_binfo)
endif|#
directive|endif
operator|&&
name|BINFO_BASETYPES
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|tree
name|base_binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|tree
name|chain
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Now unshare the structure beneath BASE_BINFO.  */
for|for
control|(
name|j
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|base_binfos
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tree
name|base_base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_base_binfo
argument_list|)
condition|)
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|j
argument_list|)
operator|=
name|make_binfo
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|BINFO_VTABLE
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|chain
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|base_base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|chain
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|base_base_binfo
argument_list|)
expr_stmt|;
block|}
comment|/* Completely unshare potentially shared data, and 	     update what is ours.  */
name|propagate_binfo_offsets
argument_list|(
name|base_binfo
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|t
argument_list|)
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
comment|/* If there's going to be a destructor needed, make 	     sure it will be virtual.  */
name|b
operator|->
name|needs_virtual_dtor
operator|=
literal|1
expr_stmt|;
comment|/* Don't borrow virtuals from virtual baseclasses.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|first_vfn_base_index
operator|<
literal|0
condition|)
block|{
name|first_vfn_base_index
operator|=
name|i
expr_stmt|;
name|b
operator|->
name|has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|vfield
operator|=
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|vfields
operator|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|b
operator|->
name|vfield
expr_stmt|;
block|}
else|else
block|{
comment|/* Only add unique vfields, and flatten them out as we go.  */
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
if|if
condition|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
decl_stmt|;
name|b
operator|->
name|vfields
operator|=
name|tree_cons
argument_list|(
name|base_binfo
argument_list|,
name|value
argument_list|,
name|b
operator|->
name|vfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
name|VF_NORMAL_VALUE
argument_list|(
name|b
operator|->
name|vfields
argument_list|)
operator|=
name|basetype
expr_stmt|;
else|else
name|VF_NORMAL_VALUE
argument_list|(
name|b
operator|->
name|vfields
argument_list|)
operator|=
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|has_virtual
operator|==
literal|0
condition|)
block|{
name|first_vfn_base_index
operator|=
name|i
expr_stmt|;
name|b
operator|->
name|has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|vfield
operator|=
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|b
operator|->
name|vfield
expr_stmt|;
block|}
block|}
block|}
block|}
block|{
name|tree
name|vfields
decl_stmt|;
comment|/* Find the base class with the largest number of virtual functions.  */
for|for
control|(
name|vfields
operator|=
name|b
operator|->
name|vfields
init|;
name|vfields
condition|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
control|)
block|{
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
operator|>
name|b
operator|->
name|max_has_virtual
condition|)
name|b
operator|->
name|max_has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
operator|&&
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
operator|>
name|b
operator|->
name|max_has_virtual
condition|)
name|b
operator|->
name|max_has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|b
operator|->
name|vfield
operator|==
literal|0
condition|)
comment|/* If all virtual functions come only from virtual baseclasses.  */
return|return
operator|-
literal|1
return|;
return|return
name|first_vfn_base_index
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|typecode_p
parameter_list|(
name|type
parameter_list|,
name|code
parameter_list|)
name|tree
name|type
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|code
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|code
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set memoizing fields and bits of T (and its variants) for later use.    MAX_HAS_VIRTUAL is the largest size of any T's virtual function tables.  */
end_comment

begin_function
specifier|static
name|void
name|finish_struct_bits
parameter_list|(
name|t
parameter_list|,
name|max_has_virtual
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|max_has_virtual
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Fix up variants (if any).  */
name|tree
name|variants
init|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|variants
condition|)
block|{
comment|/* These fields are in the _TYPE part of the node, not in 	 the TYPE_LANG_SPECIFIC component, so they are not shared.  */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_VIRTUAL_P
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Copy whatever these are holding today.  */
name|TYPE_MIN_VALUE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_baseclasses
operator|&&
name|max_has_virtual
condition|)
block|{
comment|/* Done by `finish_struct' for classes without baseclasses.  */
name|int
name|has_abstract_virtuals
init|=
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|has_abstract_virtuals
operator||=
operator|(
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|has_abstract_virtuals
condition|)
break|break;
block|}
if|if
condition|(
name|has_abstract_virtuals
condition|)
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|get_abstract_virtuals
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_baseclasses
condition|)
block|{
comment|/* Notice whether this class has type conversion functions defined. 	 Also report whether joining two types yields an ambiguity in the 	 virtual function table, e.g., 	  	 struct A { virtual int f (); }; 	 struct B { virtual int f (); }; 	 struct C : A, B { / * no f (); * / };	/ / error, ambiguous 	 */
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|n_binfos
init|=
name|list_length
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|vbases
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|,
name|basetype
decl_stmt|;
name|int
name|n_vbases
init|=
name|list_length
argument_list|(
name|vbases
argument_list|)
decl_stmt|,
name|j
decl_stmt|;
name|build_mi_virtuals
argument_list|(
name|n_binfos
operator|+
name|n_vbases
operator|*
name|n_baseclasses
argument_list|,
name|max_has_virtual
argument_list|)
expr_stmt|;
comment|/* Fill in virtual function table with values which do not come 	 "normal"ly, i.e., those which come from virtual and/or 	 non-leftmost base classes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|binfo
condition|;
name|binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
comment|/* Virtual functions from virtual baseclasses are done below.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|virtuals
init|=
name|TREE_CHAIN
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_dossier
condition|)
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
name|add_mi_virtuals
argument_list|(
operator|++
name|i
argument_list|,
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tree
name|this_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|basetype
argument_list|,
name|this_binfo
argument_list|)
condition|)
block|{
name|tree
name|virtuals
init|=
name|TREE_CHAIN
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|vbases
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_dossier
condition|)
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
name|add_mi_virtuals
argument_list|(
operator|++
name|i
argument_list|,
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|TYPE_HAS_CONVERSION
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CLASSTYPE_MAX_DEPTH
argument_list|(
name|basetype
argument_list|)
operator|>=
name|CLASSTYPE_MAX_DEPTH
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_MAX_DEPTH
argument_list|(
name|t
argument_list|)
operator|=
name|CLASSTYPE_MAX_DEPTH
argument_list|(
name|basetype
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|report_ambiguous_mi_virtuals
argument_list|(
name|n_binfos
operator|+
name|n_vbases
operator|*
name|n_baseclasses
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Now that we know what the virtual function table looks like, 	 fix up offsets in the presence of virtual base classes.  */
block|if (n_vbases) 	fixup_vbase_offsets (t);
endif|#
directive|endif
block|}
comment|/* Need to test METHOD_VEC here in case all methods      (conversions and otherwise) are inherited.  */
if|if
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|t
argument_list|)
operator|&&
name|method_vec
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|first_conversions
index|[
name|last_conversion_type
index|]
decl_stmt|;
name|tree
name|last_conversions
index|[
name|last_conversion_type
index|]
decl_stmt|;
name|enum
name|conversion_type
name|conv_index
decl_stmt|;
name|tree
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|first_conversions
argument_list|,
sizeof|sizeof
argument_list|(
name|first_conversions
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|last_conversions
argument_list|,
sizeof|sizeof
argument_list|(
name|last_conversions
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
init|;
name|tmp
operator|!=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
condition|;
name|tmp
operator|+=
literal|1
control|)
block|{
comment|/* ??? This should compare DECL_NAME (*tmp) == ansi_opname[TYPE_EXPR].  */
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
operator|*
name|tmp
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|tmp
argument_list|)
decl_stmt|;
name|tree
name|return_type
init|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
argument_list|,
literal|171
argument_list|)
expr_stmt|;
if|if
condition|(
name|typecode_p
argument_list|(
name|return_type
argument_list|,
name|POINTER_TYPE
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|return_type
argument_list|)
argument_list|)
condition|)
name|conv_index
operator|=
name|constptr_conv
expr_stmt|;
else|else
name|conv_index
operator|=
name|ptr_conv
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typecode_p
argument_list|(
name|return_type
argument_list|,
name|INTEGER_TYPE
argument_list|)
condition|)
block|{
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|conv_index
operator|=
name|int_conv
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typecode_p
argument_list|(
name|return_type
argument_list|,
name|REAL_TYPE
argument_list|)
condition|)
block|{
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|conv_index
operator|=
name|real_conv
expr_stmt|;
block|}
else|else
continue|continue;
if|if
condition|(
name|first_conversions
index|[
operator|(
name|int
operator|)
name|conv_index
index|]
operator|==
name|NULL_TREE
condition|)
name|first_conversions
index|[
operator|(
name|int
operator|)
name|conv_index
index|]
operator|=
operator|*
name|tmp
expr_stmt|;
name|last_conversions
index|[
operator|(
name|int
operator|)
name|conv_index
index|]
operator|=
operator|*
name|tmp
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|last_conversion_type
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|first_conversions
index|[
name|i
index|]
operator|!=
name|last_conversions
index|[
name|i
index|]
condition|)
name|CLASSTYPE_CONVERSION
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|CLASSTYPE_CONVERSION
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|first_conversions
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* If this type has constructors, force its mode to be BLKmode,      and force its TREE_ADDRESSABLE bit to be nonzero.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|variants
init|=
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|DECL_MODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
while|while
condition|(
name|variants
condition|)
block|{
name|TYPE_MODE
argument_list|(
name|variants
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|variants
argument_list|)
operator|=
literal|1
expr_stmt|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Warn about duplicate methods in fn_fields.  Also compact method    lists so that lookup can be made faster.     Algorithm: Outer loop builds lists by method name.  Inner loop    checks for redundant method names within a list.     Data Structure: List of method lists.  The outer list is a    TREE_LIST, whose TREE_PURPOSE field is the field name and the    TREE_VALUE is the TREE_CHAIN of the FUNCTION_DECLs.  Friends are    chained in the same way as member functions, but they live in the    TREE_TYPE field of the outer list.  That allows them to be quickly    deleted, and requires no extra storage.     If there are any constructors/destructors, they are moved to the    front of the list.  This makes pushclass more efficient.     We also link each field which has shares a name with its baseclass    to the head of the list of fields for that base class.  This allows    us to reduce search time in places like `build_method_call' to    consider only reasonably likely functions.  */
end_comment

begin_function
specifier|static
name|tree
name|finish_struct_methods
parameter_list|(
name|t
parameter_list|,
name|fn_fields
parameter_list|,
name|nonprivate_method
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|fn_fields
decl_stmt|;
name|int
name|nonprivate_method
decl_stmt|;
block|{
name|tree
name|method_vec
decl_stmt|;
name|tree
name|name
init|=
name|constructor_name
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Now prepare to gather fn_fields into vector.  */
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|class_obstack
expr_stmt|;
name|method_vec
operator|=
name|make_node
argument_list|(
name|TREE_VEC
argument_list|)
expr_stmt|;
comment|/* Room has been saved for constructors and destructors.  */
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
comment|/* Now make this a live vector.  */
name|obstack_free
argument_list|(
operator|&
name|class_obstack
argument_list|,
name|method_vec
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|class_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_vec
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|fn_fields
condition|)
block|{
comment|/* NEXT Pointer, TEST Pointer, and BASE Pointer.  */
name|tree
name|nextp
decl_stmt|,
modifier|*
name|testp
decl_stmt|;
name|tree
name|fn_name
init|=
name|DECL_NAME
argument_list|(
name|fn_fields
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn_name
operator|==
name|NULL_TREE
condition|)
name|fn_name
operator|=
name|name
expr_stmt|;
name|nextp
operator|=
name|TREE_CHAIN
argument_list|(
name|fn_fields
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fn_fields
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Constructors are handled easily in search routines. 	 Besides, we know we won't find any, so do not bother looking.  */
if|if
condition|(
name|fn_name
operator|==
name|name
operator|&&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
else|else
block|{
name|testp
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|testp
operator|==
name|NULL_TREE
condition|)
name|testp
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|testp
operator|<
operator|(
name|HOST_WIDE_INT
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|class_obstack
argument_list|)
operator|)
operator|&&
name|DECL_NAME
argument_list|(
operator|*
name|testp
argument_list|)
operator|!=
name|fn_name
condition|)
name|testp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|HOST_WIDE_INT
operator|)
name|testp
operator|<
operator|(
name|HOST_WIDE_INT
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|class_obstack
argument_list|)
condition|)
block|{
name|tree
name|x
decl_stmt|,
name|prev_x
decl_stmt|;
for|for
control|(
name|x
operator|=
operator|*
name|testp
init|;
name|x
condition|;
name|x
operator|=
name|DECL_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fn_fields
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
condition|)
block|{
comment|/* ANSI C++ June 5 1992 WP 12.5.5.1 */
name|error_with_decl
argument_list|(
name|fn_fields
argument_list|,
literal|"operator delete cannot be overloaded"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"previous declaration here"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fn_fields
argument_list|)
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* We complain about multiple destructors on sight, 			 so we do not repeat the warning here.  Friend-friend 			 ambiguities are warned about outside this loop.  */
if|if
condition|(
operator|!
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fn_fields
argument_list|)
argument_list|)
condition|)
name|error_with_file_and_line
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|fn_fields
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|fn_fields
argument_list|)
argument_list|,
literal|"ambiguous method `%s' in structure"
argument_list|,
name|lang_printable_name
argument_list|(
name|fn_fields
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|prev_x
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
literal|0
condition|)
if|if
condition|(
operator|*
name|testp
condition|)
name|DECL_CHAIN
argument_list|(
name|prev_x
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
else|else
operator|*
name|testp
operator|=
name|fn_fields
expr_stmt|;
block|}
else|else
block|{
name|obstack_ptr_grow
argument_list|(
operator|&
name|class_obstack
argument_list|,
name|fn_fields
argument_list|)
expr_stmt|;
name|method_vec
operator|=
operator|(
name|tree
operator|)
name|obstack_base
argument_list|(
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
block|}
block|}
name|fn_fields
operator|=
name|nextp
expr_stmt|;
block|}
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|class_obstack
argument_list|)
operator|-
operator|(
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
operator|=
name|method_vec
expr_stmt|;
if|if
condition|(
name|nonprivate_method
operator|==
literal|0
operator|&&
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
operator|||
name|TREE_VIA_PROTECTED
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|nonprivate_method
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nonprivate_method
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"all member functions in class `%s' are private"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If there are constructors (and destructors), they are at the      front.  Place destructors at very front.  Also warn if all      constructors and/or destructors are private (in which case this      class is effectively unusable.  */
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|dtor
decl_stmt|,
name|prev
decl_stmt|;
for|for
control|(
name|dtor
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
init|;
name|dtor
condition|;
name|prev
operator|=
name|dtor
operator|,
name|dtor
operator|=
name|DECL_CHAIN
argument_list|(
name|dtor
argument_list|)
control|)
block|{
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|dtor
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|dtor
argument_list|)
operator|&&
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|warning_with_decl
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"class `%s' only defines a private destructor and has no friends"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Wild parse errors can cause this to happen.  */
if|if
condition|(
name|dtor
operator|==
name|NULL_TREE
condition|)
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dtor
operator|!=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|DECL_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|DECL_CHAIN
argument_list|(
name|dtor
argument_list|)
expr_stmt|;
name|DECL_CHAIN
argument_list|(
name|dtor
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|dtor
expr_stmt|;
block|}
block|}
comment|/* Now for each member function (except for constructors and      destructors), compute where member functions of the same      name reside in base classes.  */
if|if
condition|(
name|n_baseclasses
operator|!=
literal|0
operator|&&
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|>
literal|1
condition|)
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
name|tree
name|baselink_vec
init|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|int
name|any_links
init|=
literal|0
decl_stmt|;
name|tree
name|baselink_binfo
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|TREE_VEC_ELT
argument_list|(
name|baselink_vec
argument_list|,
name|i
argument_list|)
operator|=
name|get_baselinks
argument_list|(
name|baselink_binfo
argument_list|,
name|t
argument_list|,
name|DECL_NAME
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|baselink_vec
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|any_links
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|any_links
operator|!=
literal|0
condition|)
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|t
argument_list|)
operator|=
name|baselink_vec
expr_stmt|;
else|else
name|obstack_free
argument_list|(
name|current_obstack
argument_list|,
name|baselink_vec
argument_list|)
expr_stmt|;
block|}
comment|/* Now add the methods to the TYPE_METHODS of T, arranged in a chain.  */
block|{
name|tree
name|x
decl_stmt|,
name|last_x
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|limit
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|DECL_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|last_x
operator|!=
name|NULL_TREE
condition|)
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|x
expr_stmt|;
name|last_x
operator|=
name|x
expr_stmt|;
block|}
block|}
comment|/* Put ctors and dtors at the front of the list.  */
name|x
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
while|while
condition|(
name|DECL_CHAIN
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Let's avoid being circular about this.  */
if|if
condition|(
name|x
operator|==
name|DECL_CHAIN
argument_list|(
name|x
argument_list|)
condition|)
break|break;
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|DECL_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|>
literal|1
condition|)
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|TYPE_METHODS (t) = TREE_VEC_ELT (method_vec, 0)     ? TREE_VEC_ELT (method_vec, 0) : TREE_VEC_ELT (method_vec, 1);
else|#
directive|else
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|method_vec
expr_stmt|;
endif|#
directive|endif
return|return
name|method_vec
return|;
block|}
end_function

begin_comment
comment|/* Emit error when a duplicate definition of a type is seen.  Patch up. */
end_comment

begin_function
name|void
name|duplicate_tag_error
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|char
modifier|*
name|err_name
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|err_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|error
argument_list|(
literal|"redefinition of `union %s'"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|error
argument_list|(
literal|"redefinition of `struct %s'"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"redefinition of tag %s"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
comment|/* Pretend we haven't defined this type.  */
comment|/* All of the component_decl's were TREE_CHAINed together in the parser.      finish_struct_methods walks these chains and assembles all methods with      the same base name into DECL_CHAINs. Now we don't need the parser chains      anymore, so we unravel them.    */
comment|/*    * This used to be in finish_struct, but it turns out that the    * TREE_CHAIN is used by dbxout_type_methods and perhaps some other things...    */
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|tv
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|tv
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|unchain
init|=
name|TREE_VEC_ELT
argument_list|(
name|tv
argument_list|,
name|i
argument_list|)
decl_stmt|;
while|while
condition|(
name|unchain
operator|!=
name|NULL_TREE
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|unchain
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|unchain
operator|=
name|DECL_CHAIN
argument_list|(
name|unchain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|as_list
init|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfo_as_list
init|=
name|CLASSTYPE_BINFO_AS_LIST
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|interface_only
init|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|interface_unknown
init|=
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
argument_list|)
expr_stmt|;
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_AS_LIST
argument_list|(
name|t
argument_list|)
operator|=
name|as_list
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|CLASSTYPE_BINFO_AS_LIST
argument_list|(
name|t
argument_list|)
operator|=
name|binfo_as_list
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
operator|=
name|interface_unknown
expr_stmt|;
name|CLASSTYPE_VBASE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|TYPE_REDEFINED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration    (or C++ class declaration).     For C++, we must handle the building of derived classes.    Also, C++ allows static class members.  The way that this is    handled is to keep the field name where it is (as the DECL_NAME    of the field), and place the overloaded decl in the DECL_FIELD_BITPOS    of the field.  layout_record and layout_union will know about this.     More C++ hair: inline functions have text in their    DECL_PENDING_INLINE_INFO nodes which must somehow be parsed into    meaningful tree structure.  After the struct has been laid out, set    things up so that this can happen.     And still more: virtual functions.  In the case of single inheritance,    when a new virtual function is seen which redefines a virtual function    from the base class, the new virtual function is placed into    the virtual function table at exactly the same address that    it had in the base class.  When this is extended to multiple    inheritance, the same thing happens, except that multiple virtual    function tables must be maintained.  The first virtual function    table is treated in exactly the same way as in the case of single    inheritance.  Additional virtual function tables have different    DELTAs, which tell how to adjust `this' to point to the right thing.     LIST_OF_FIELDLISTS is just that.  The elements of the list are    TREE_LIST elements, whose TREE_PURPOSE field tells what visibility    the list has, and the TREE_VALUE slot gives the actual fields.     If flag_all_virtual == 1, then we lay all functions into    the virtual function table, as though they were declared    virtual.  Constructors do not lay down in the virtual function table.     If flag_all_virtual == 2, then we lay all functions into    the virtual function table, such that virtual functions    occupy a space by themselves, and then all functions    of the class occupy a space by themselves.  This is illustrated    in the following diagram:     class A; class B : A;  	Class A's vtbl:			Class B's vtbl:     --------------------------------------------------------------------    | A's virtual functions|		| B's virtual functions		|    |			  |		| (may inherit some from A).	|     --------------------------------------------------------------------    | All of A's functions |		| All of A's functions		|    | (such as a->A::f).	  |		| (such as b->A::f)		|     -------------------------------------------------------------------- 					| B's new virtual functions	| 					| (not defined in A.)		| 					 ------------------------------- 					| All of B's functions		| 					| (such as b->B::f)		| 					 -------------------------------     this allows the program to make references to any function, virtual    or otherwise in a type-consistent manner.  */
end_comment

begin_function
name|tree
name|finish_struct
parameter_list|(
name|t
parameter_list|,
name|list_of_fieldlists
parameter_list|,
name|warn_anon
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|list_of_fieldlists
decl_stmt|;
name|int
name|warn_anon
decl_stmt|;
block|{
specifier|extern
name|int
name|interface_only
decl_stmt|,
name|interface_unknown
decl_stmt|;
name|int
name|old
decl_stmt|;
name|int
name|round_up_size
init|=
literal|1
decl_stmt|;
comment|/* Set non-zero to debug using default functions.      Not set by program.  */
specifier|static
name|int
name|debug_default_functions
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|x
decl_stmt|,
name|last_x
decl_stmt|,
name|method_vec
decl_stmt|;
name|int
name|needs_ctor
init|=
literal|0
decl_stmt|,
name|needs_dtor
init|=
literal|0
decl_stmt|;
name|int
name|members_need_dtors
decl_stmt|,
name|needs_virtual_dtor
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|,
name|fields
decl_stmt|,
name|fn_fields
decl_stmt|,
name|tail
decl_stmt|;
name|enum
name|visibility_type
name|visibility
decl_stmt|;
name|int
name|all_virtual
decl_stmt|;
name|int
name|has_virtual
decl_stmt|;
name|int
name|max_has_virtual
decl_stmt|;
name|tree
name|pending_virtuals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|abstract_virtuals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|vfield
decl_stmt|;
name|tree
name|vfields
decl_stmt|;
name|int
name|needs_default_ctor
decl_stmt|;
name|int
name|cant_have_default_ctor
decl_stmt|;
name|int
name|needs_const_ctor
decl_stmt|;
name|int
name|cant_have_const_ctor
decl_stmt|;
comment|/* The index of the first base class which has virtual      functions.  Only applied to non-virtual baseclasses.  */
name|int
name|first_vfn_base_index
decl_stmt|;
name|int
name|n_baseclasses
decl_stmt|;
name|int
name|any_default_members
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|err_name
decl_stmt|;
name|int
name|const_sans_init
init|=
literal|0
decl_stmt|;
name|int
name|ref_sans_init
init|=
literal|0
decl_stmt|;
name|int
name|nonprivate_method
init|=
literal|0
decl_stmt|;
name|tree
name|t_binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
specifier|extern
name|int
name|lineno
decl_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|name
argument_list|)
operator|=
name|input_filename
expr_stmt|;
comment|/* For TYPE_DECL that are not typedefs (those marked with a line number 	 of zero, we don't want to mark them as real typedefs.  If this fails 	 one needs to make sure real typedefs have a previous line number, 	 even if it is wrong, that way the below will fill in the right line 	 number.  (mrs) */
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|name
argument_list|)
condition|)
name|DECL_SOURCE_LINE
argument_list|(
name|name
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|err_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_anon
operator|&&
name|code
operator|!=
name|UNION_TYPE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"un-usable class ignored (anonymous classes and unions are useless)"
argument_list|)
expr_stmt|;
name|err_name
operator|=
literal|"(anon)"
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This is set here, but it's never actually used anywhere.  (bpk) */
block|leftmost_baseclasses = NULL_TREE;
endif|#
directive|endif
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|error
argument_list|(
literal|"redefinition of `union %s'"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|error
argument_list|(
literal|"redefinition of `struct %s'"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|172
argument_list|)
expr_stmt|;
name|popclass
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If this type was previously laid out as a forward reference,      make sure we lay it out again.  */
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
operator|=
name|interface_unknown
expr_stmt|;
if|if
condition|(
name|flag_dossier
condition|)
name|build_t_desc
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|old
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
comment|/* Install struct as DECL_FIELD_CONTEXT of each field decl.      Also process specified field sizes.      Set DECL_FIELD_SIZE to the specified size, or 0 if none specified.      The specified size is found in the DECL_INITIAL.      Store 0 there, except for ": 0" fields (so we can find them      and delete them, below).  */
if|if
condition|(
name|t_binfo
operator|&&
name|BINFO_BASETYPES
argument_list|(
name|t_binfo
argument_list|)
condition|)
name|n_baseclasses
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|t_binfo
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|n_baseclasses
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n_baseclasses
operator|>
literal|0
condition|)
block|{
name|struct
name|base_info
name|base_info
decl_stmt|;
comment|/* If using multiple inheritance, this may cause variants of our 	 basetypes to be used (instead of their canonical forms).  */
name|fields
operator|=
name|layout_basetypes
argument_list|(
name|t
argument_list|,
name|BINFO_BASETYPES
argument_list|(
name|t_binfo
argument_list|)
argument_list|)
expr_stmt|;
name|last_x
operator|=
name|tree_last
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|first_vfn_base_index
operator|=
name|finish_base_struct
argument_list|(
name|t
argument_list|,
operator|&
name|base_info
argument_list|,
name|BINFO_BASETYPES
argument_list|(
name|t_binfo
argument_list|)
argument_list|)
expr_stmt|;
name|has_virtual
operator|=
name|base_info
operator|.
name|has_virtual
expr_stmt|;
name|max_has_virtual
operator|=
name|base_info
operator|.
name|max_has_virtual
expr_stmt|;
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|t
argument_list|)
operator|+=
name|base_info
operator|.
name|n_ancestors
expr_stmt|;
name|vfield
operator|=
name|base_info
operator|.
name|vfield
expr_stmt|;
name|vfields
operator|=
name|base_info
operator|.
name|vfields
expr_stmt|;
name|needs_default_ctor
operator|=
name|base_info
operator|.
name|needs_default_ctor
expr_stmt|;
name|cant_have_default_ctor
operator|=
name|base_info
operator|.
name|cant_have_default_ctor
expr_stmt|;
name|needs_const_ctor
operator|=
name|base_info
operator|.
name|needs_const_ctor
expr_stmt|;
name|cant_have_const_ctor
operator|=
name|base_info
operator|.
name|cant_have_const_ctor
expr_stmt|;
name|members_need_dtors
operator|=
name|base_info
operator|.
name|members_need_dtors
expr_stmt|;
name|needs_virtual_dtor
operator|=
name|base_info
operator|.
name|needs_virtual_dtor
expr_stmt|;
name|n_baseclasses
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|t_binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first_vfn_base_index
operator|=
operator|-
literal|1
expr_stmt|;
name|has_virtual
operator|=
literal|0
expr_stmt|;
name|max_has_virtual
operator|=
name|has_virtual
expr_stmt|;
name|vfield
operator|=
name|NULL_TREE
expr_stmt|;
name|vfields
operator|=
name|NULL_TREE
expr_stmt|;
name|fields
operator|=
name|NULL_TREE
expr_stmt|;
name|last_x
operator|=
name|NULL_TREE
expr_stmt|;
name|needs_default_ctor
operator|=
literal|0
expr_stmt|;
name|cant_have_default_ctor
operator|=
literal|0
expr_stmt|;
name|needs_const_ctor
operator|=
literal|0
expr_stmt|;
name|cant_have_const_ctor
operator|=
literal|0
expr_stmt|;
name|members_need_dtors
operator|=
literal|0
expr_stmt|;
name|needs_virtual_dtor
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|write_virtuals
operator|==
literal|3
operator|&&
operator|!
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
operator|&&
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
block|{
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|t
argument_list|)
operator|=
operator|!
name|interface_only
expr_stmt|;
block|}
comment|/* The three of these are approximations which may later be      modified.  Needed at this point to make add_virtual_function      and modify_vtable_entries work.  */
name|TREE_CHAIN
argument_list|(
name|t_binfo
argument_list|)
operator|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|t_binfo
expr_stmt|;
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|vfields
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|fn_fields
operator|=
name|NULL_TREE
expr_stmt|;
name|tail
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|last_x
operator|&&
name|list_of_fieldlists
condition|)
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_all_virtual
operator|==
literal|1
operator|&&
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|t
argument_list|)
condition|)
name|all_virtual
operator|=
literal|1
expr_stmt|;
else|else
name|all_virtual
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nonprivate_method
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|list_of_fieldlists
operator|&&
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|visibility_default
condition|)
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|visibility_public
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|list_of_fieldlists
operator|&&
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|visibility_default
condition|)
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|visibility_private
expr_stmt|;
while|while
condition|(
name|list_of_fieldlists
condition|)
block|{
name|visibility
operator|=
operator|(
expr|enum
name|visibility_type
operator|)
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|TREE_PRIVATE
argument_list|(
name|x
argument_list|)
operator|=
name|visibility
operator|==
name|visibility_private
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|x
argument_list|)
operator|=
name|visibility
operator|==
name|visibility_protected
expr_stmt|;
name|GNU_xref_member
argument_list|(
name|current_class_name
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
if|#
directive|if
literal|0
comment|/* @@ Um.  This doesn't seem to be handled properly, at 		 least in my PT test cases.  Not sure if it's really 		 supposed to work for non-PT cases.  Let's find out.  */
block|static tree t, d;               d = DECL_NAME (x);               t = TYPE_IDENTIFIER (TREE_TYPE (x)); 	      if (d == t) continue; 	      if (IDENTIFIER_TEMPLATE (t)) 		{ 		  t = DECL_NAME (TREE_PURPOSE (IDENTIFIER_TEMPLATE (t))); 		  my_friendly_assert (t == d, 173); 		  continue; 		} 	      else if (IDENTIFIER_CLASS_VALUE (t)) 		my_friendly_assert (TREE_TYPE (DECL_NAME (d)) 				    == TREE_TYPE (DECL_NAME (TREE_TYPE (t))), 				    174); 	      else 		abort ();
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Clear out this flag.  	         @@ Doug may figure out how to break 		 @@ this with nested classes and friends.  */
name|DECL_IN_AGGR_P
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
name|nonprivate_method
operator||=
operator|!
name|TREE_PRIVATE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If this was an evil function, don't keep it in class.  */
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|last_x
condition|)
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fn_fields
condition|)
name|fn_fields
operator|=
name|x
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|=
name|x
expr_stmt|;
name|tail
operator|=
name|x
expr_stmt|;
if|#
directive|if
literal|0
comment|/* ??? What if we have duplicate declarations 		 in T's definition?  */
block|if (DECL_CLASS_CONTEXT (x)) 		continue;
endif|#
directive|endif
name|DECL_CLASS_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The name of the field is the original field name 		 Save this in auxiliary field for later overloading.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|all_virtual
operator|==
literal|1
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
name|pending_virtuals
operator|=
name|add_virtual_function
argument_list|(
name|pending_virtuals
argument_list|,
operator|&
name|has_virtual
argument_list|,
name|x
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|x
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Handle visibility declarations.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
name|tree
name|fdecl
init|=
name|TREE_OPERAND
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|last_x
condition|)
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Make type T see field decl FDECL with 		 the visibility VISIBILITY.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fdecl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|fdecl
operator|=
name|TREE_VALUE
argument_list|(
name|fdecl
argument_list|)
expr_stmt|;
while|while
condition|(
name|fdecl
condition|)
block|{
if|if
condition|(
name|alter_visibility
argument_list|(
name|t
argument_list|,
name|fdecl
argument_list|,
name|visibility
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|fdecl
operator|=
name|DECL_CHAIN
argument_list|(
name|fdecl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|alter_visibility
argument_list|(
name|t
argument_list|,
name|fdecl
argument_list|,
name|visibility
argument_list|)
expr_stmt|;
name|CLASSTYPE_ALTERS_VISIBILITIES_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* If this is of reference type, check if it needs an init.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
name|ref_sans_init
operator|=
literal|1
expr_stmt|;
comment|/* ``A local class cannot have static data members.'' ARM 9.4 */
if|if
condition|(
name|current_function_decl
operator|&&
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"field `%s' in local class cannot be static"
argument_list|)
expr_stmt|;
comment|/* When this goes into scope, it will be a non-local reference.  */
name|DECL_NONLOCAL
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Perform error checking that did not get done in grokdeclarator.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"field `%s' invalidly declared function type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"field `%s' invalidly declared method type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"field `%s' invalidly declared offset type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
comment|/* If the field has a bogus type, don't bother with it.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Never let anything with uninheritable virtuals 		     make it through without complaint.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|abstract_virtuals_error
argument_list|(
name|x
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|needs_default_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_GETS_CONST_INIT_REF
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|needs_const_ctor
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_GETS_INIT_REF
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|cant_have_const_ctor
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
condition|)
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If any field is const, the structure type is pseudo-const.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
name|const_sans_init
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* A field that is pseudo-const makes the structure likewise.  */
name|tree
name|t1
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
if|if
condition|(
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t1
argument_list|)
condition|)
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t1
argument_list|)
condition|)
name|const_sans_init
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
comment|/* Unions cannot have static members.  */
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"field `%s' declared static in union"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fields
condition|)
name|fields
operator|=
name|x
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* We could be making an extern "C" function a friend. */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_CLASS_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* We set DECL_BIT_FIELD tentatively in grokbitfield. 	     If the type and width are valid, we'll keep it set. 	     Otherwise, the flag is cleared.  */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Invalid bit-field size done by grokfield.  */
comment|/* Detect invalid bit-field type.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"bit-field `%s' has invalid type"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|pedantic
operator|&&
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|integer_type_node
operator|&&
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|unsigned_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"bit-field `%s' type invalid in ANSI C++"
argument_list|)
expr_stmt|;
comment|/* Detect and ignore out of range field width.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
specifier|register
name|int
name|width
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"negative width in bit-field `%s'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|==
literal|0
operator|&&
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"zero width for bit-field `%s'"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|unsigned
operator|)
name|width
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"width of `%s' exceeds its type"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process valid field width.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
specifier|register
name|int
name|width
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EMPTY_FIELD_BOUNDARY
comment|/* field size 0 => mark following field as "aligned" */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_ALIGN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|EMPTY_FIELD_BOUNDARY
argument_list|)
expr_stmt|;
comment|/* field of size 0 at the end => round up the size.  */
else|else
name|round_up_size
operator|=
name|EMPTY_FIELD_BOUNDARY
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|=
name|width
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Traditionally a bit field is unsigned 			 even if declared signed.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
block|}
else|else
comment|/* Non-bit-fields are aligned for their type.  */
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"member `%s' with constructor or destructor not allowed in union"
argument_list|)
expr_stmt|;
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_GETS_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_GETS_INIT_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
block|{
comment|/* Array of record type doesn't matter for this bit.  */
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|needs_ctor
operator||=
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|needs_dtor
operator||=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|members_need_dtors
operator||=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_GETS_CONST_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_GETS_CONST_INIT_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_GETS_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_GETS_INIT_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* `build_class_init_list' does not recognize non-FIELD_DECLs.  */
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
operator|&&
name|any_default_members
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"multiple fields in union initialized"
argument_list|)
expr_stmt|;
name|any_default_members
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|last_x
operator|=
name|x
expr_stmt|;
block|}
name|list_of_fieldlists
operator|=
name|TREE_CHAIN
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
comment|/* link the tail while we have it! */
if|if
condition|(
name|last_x
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|list_of_fieldlists
operator|&&
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tail
condition|)
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If this type has any constant members which did not come      with their own initialization, mark that fact here.  It is      not an error here, since such types can be saved either by their      constructors, or by fortuitous initialization.  */
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|)
operator|=
name|const_sans_init
expr_stmt|;
name|CLASSTYPE_REF_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|)
operator|=
name|ref_sans_init
expr_stmt|;
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|abstract_virtuals
expr_stmt|;
if|if
condition|(
name|members_need_dtors
operator|&&
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Here we must cons up a destructor on the fly.  */
name|tree
name|dtor
init|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
name|needs_virtual_dtor
operator|!=
literal|0
argument_list|)
decl_stmt|;
comment|/* If we couldn't make it work, then pretend we didn't need it.  */
if|if
condition|(
name|dtor
operator|==
name|void_type_node
condition|)
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|fn_fields
condition|)
name|fn_fields
operator|=
name|dtor
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|=
name|dtor
expr_stmt|;
name|tail
operator|=
name|dtor
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|dtor
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|needs_virtual_dtor
operator|||
name|pending_virtuals
operator|!=
name|NULL_TREE
operator|||
name|pending_hard_virtuals
operator|!=
name|NULL_TREE
operator|)
condition|)
name|DECL_VINDEX
argument_list|(
name|dtor
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|dtor
argument_list|)
condition|)
name|pending_virtuals
operator|=
name|add_virtual_function
argument_list|(
name|pending_virtuals
argument_list|,
operator|&
name|has_virtual
argument_list|,
name|dtor
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|nonprivate_method
operator|=
literal|1
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug_default_functions
condition|)
block|{
if|if
condition|(
operator|(
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|||
name|needs_ctor
operator|)
operator|&&
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|default_fn
init|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
name|fn_fields
operator|=
name|default_fn
expr_stmt|;
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|default_fn
operator|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
name|fn_fields
operator|=
name|default_fn
expr_stmt|;
name|nonprivate_method
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|needs_default_ctor
operator|&&
operator|!
name|cant_have_default_ctor
condition|)
block|{
name|tree
name|default_fn
init|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
name|fn_fields
operator|=
name|default_fn
expr_stmt|;
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|nonprivate_method
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fn_fields
condition|)
block|{
name|method_vec
operator|=
name|finish_struct_methods
argument_list|(
name|t
argument_list|,
name|fn_fields
argument_list|,
name|nonprivate_method
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|int
name|nonprivate_ctor
init|=
literal|0
decl_stmt|;
name|tree
name|ctor
decl_stmt|;
for|for
control|(
name|ctor
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
init|;
name|ctor
condition|;
name|ctor
operator|=
name|DECL_CHAIN
argument_list|(
name|ctor
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_PRIVATE
argument_list|(
name|ctor
argument_list|)
condition|)
block|{
name|nonprivate_ctor
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nonprivate_ctor
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"class `%s' only defines private constructors and has no friends"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|method_vec
operator|=
literal|0
expr_stmt|;
comment|/* Just in case these got accidentally 	 filled in by syntax errors.  */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|vfield
operator|==
name|NULL_TREE
operator|&&
name|has_virtual
condition|)
block|{
comment|/* We build this decl with ptr_type_node, and 	 change the type when we know what it should be.  */
name|vfield
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_vfield_name
argument_list|(
name|t
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
comment|/* If you change any of the below, take a look at all the 	 other VFIELD_BASEs and VTABLE_BASEs in the code, and change 	 them too. */
name|DECL_ASSEMBLER_NAME
argument_list|(
name|vfield
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|VFIELD_BASE
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|vfield
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_FCONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|vfield
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|vfield
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_DOSSIER
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* vfield is always first entry in structure.  */
name|TREE_CHAIN
argument_list|(
name|vfield
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|vfield
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_x
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|==
literal|0
argument_list|,
literal|175
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|last_x
operator|=
name|vfield
expr_stmt|;
block|}
else|else
name|fields
operator|=
name|vfield
expr_stmt|;
name|vfields
operator|=
name|chainon
argument_list|(
name|vfields
argument_list|,
name|CLASSTYPE_AS_LIST
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now DECL_INITIAL is null on all members except for zero-width bit-fields.      And they have already done their work.       C++: maybe we will support default field initialization some day...  */
comment|/* Delete all zero-width bit-fields from the front of the fieldlist */
while|while
condition|(
name|fields
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|fields
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|fields
argument_list|)
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
comment|/* Delete all such fields from the rest of the fields.  */
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Delete all duplicate fields from the fields */
name|delete_duplicate_fields
argument_list|(
name|fields
argument_list|)
expr_stmt|;
comment|/* Now we have the final fieldlist for the data fields.  Record it,      then lay out the structure or union (including the fields).  */
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fields
expr_stmt|;
comment|/* If there's a :0 field at the end, round the size to the      EMPTY_FIELD_BOUNDARY.  */
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|round_up_size
expr_stmt|;
comment|/* Pass layout information about base classes to layout_type, if any.  */
if|if
condition|(
name|n_baseclasses
condition|)
block|{
name|tree
name|pseudo_basetype
init|=
name|TREE_TYPE
argument_list|(
name|base_layout_decl
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|base_layout_decl
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|base_layout_decl
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|pseudo_basetype
argument_list|)
operator|=
name|CLASSTYPE_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|pseudo_basetype
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|pseudo_basetype
argument_list|)
operator|=
name|CLASSTYPE_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|base_layout_decl
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|pseudo_basetype
argument_list|)
expr_stmt|;
block|}
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_baseclasses
condition|)
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* C++: do not let empty structures exist.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
comment|/* Set the TYPE_DECL for this type to contain the right      value for DECL_OFFSET, so that we can use it as part      of a COMPONENT_REF for multiple inheritance.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|layout_decl
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now fix up any virtual base class types that we      left lying around.  We must get these done      before we try to lay out the virtual function table.  */
name|doing_hard_virtuals
operator|=
literal|1
expr_stmt|;
name|pending_hard_virtuals
operator|=
name|nreverse
argument_list|(
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|vbases
decl_stmt|;
name|max_has_virtual
operator|=
name|layout_vbasetypes
argument_list|(
name|t
argument_list|,
name|max_has_virtual
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_N_VBASECLASSES
argument_list|(
name|t
argument_list|)
operator|=
name|list_length
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
comment|/* This loop makes all the entries in the virtual function tables 	 of interest contain the "latest" version of the functions 	 we have defined.  */
while|while
condition|(
name|vbases
condition|)
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|vbases
argument_list|)
decl_stmt|;
if|if
condition|(
name|virtuals
condition|)
block|{
comment|/* Get past the `null' vtable entry...  */
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
comment|/* and the `dossier' vtable entry if we're doing dossiers.  */
if|if
condition|(
name|flag_dossier
condition|)
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|virtuals
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|get_first_matching_virtual
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|base_fndecl
argument_list|,
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|context
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|!=
name|base_fndecl
operator|&&
name|context
operator|!=
name|t
condition|)
block|{
name|tree
name|base_context
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|base_fndecl
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|NULL_TREE
decl_stmt|,
name|these_virtuals
decl_stmt|;
if|#
directive|if
literal|0
block|unsigned HOST_WIDE_INT i 		    = (TREE_INT_CST_LOW (DECL_VINDEX (base_fndecl))& (((unsigned HOST_WIDE_INT)1<<(BITS_PER_WORD-1))-1));
endif|#
directive|endif
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|context
argument_list|)
condition|)
name|binfo
operator|=
name|virtual_member
argument_list|(
name|base_context
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|NULL_TREE
condition|)
name|binfo
operator|=
name|binfo_value
argument_list|(
name|base_context
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|!=
name|NULL_TREE
condition|)
block|{
if|#
directive|if
literal|1
name|pfn
operator|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|get_vtable_entry
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|base_fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|these_virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|these_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|these_virtuals
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|these_virtuals
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|modify_vtable_entries
argument_list|(
name|t
argument_list|,
name|decl
argument_list|,
name|base_fndecl
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
block|}
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
comment|/* Update dossier info with offsets for virtual baseclasses.  */
if|if
condition|(
name|flag_dossier
operator|&&
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|vbases
argument_list|)
condition|)
name|prepare_fresh_vtable
argument_list|(
name|vbases
argument_list|,
name|vbases
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|pending_hard_virtuals
condition|)
block|{
comment|/* Need an entry in some other virtual function table.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|pending_hard_virtuals
argument_list|)
condition|)
block|{
comment|/* This is how we modify entries when a vfn's index changes 	     between derived and base type.  */
name|modify_vtable_entries
argument_list|(
name|t
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pending_hard_virtuals
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|pending_hard_virtuals
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|pending_hard_virtuals
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is how we modify entries when a vfn comes from 	     a virtual baseclass.  */
name|tree
name|base_fndecls
init|=
name|DECL_VINDEX
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|pending_hard_virtuals
argument_list|)
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|base_fndecls
operator|!=
name|error_mark_node
argument_list|,
literal|176
argument_list|)
expr_stmt|;
while|while
condition|(
name|base_fndecls
condition|)
block|{
name|modify_vtable_entries
argument_list|(
name|t
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pending_hard_virtuals
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|pending_hard_virtuals
argument_list|)
argument_list|)
expr_stmt|;
name|base_fndecls
operator|=
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
block|}
name|pending_hard_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
block|}
name|doing_hard_virtuals
operator|=
literal|0
expr_stmt|;
comment|/* Under our model of GC, every C++ class gets its own virtual      function table, at least virtually.  */
if|if
condition|(
name|pending_virtuals
operator|||
name|CLASSTYPE_DOSSIER
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pending_virtuals
operator|=
name|nreverse
argument_list|(
name|pending_virtuals
argument_list|)
expr_stmt|;
comment|/* We must enter these virtuals into the table.  */
if|if
condition|(
name|first_vfn_base_index
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|flag_dossier
condition|)
name|pending_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|build_t_desc
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
name|pending_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|the_null_vtable_entry
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
name|build_vtable
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here we know enough to change the type of our virtual 	     function table, but we will wait until later this function.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|binfo_value
argument_list|(
name|TYPE_BINFO_BASETYPE
argument_list|(
name|t
argument_list|,
name|first_vfn_base_index
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Update the dossier pointer for this class.  */
if|if
condition|(
name|flag_dossier
condition|)
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|build_t_desc
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this type has basetypes with constructors, then those 	 constructors might clobber the virtual function table.  But 	 they don't if the derived class shares the exact vtable of the base 	 class.  */
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first_vfn_base_index
operator|>=
literal|0
condition|)
block|{
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* This class contributes nothing new to the virtual function 	 table.  However, it may have declared functions which 	 went into the virtual function table "inherited" from the 	 base class.  If so, we grab a copy of those updated functions, 	 and pretend they are ours.  */
comment|/* See if we should steal the virtual info from base class.  */
if|if
condition|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|!=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
condition|)
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|has_virtual
operator|>
name|max_has_virtual
condition|)
name|max_has_virtual
operator|=
name|has_virtual
expr_stmt|;
if|if
condition|(
name|max_has_virtual
operator|||
name|first_vfn_base_index
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|VTABLE_USES_MASK
if|if
condition|(
name|max_has_virtual
operator|>=
name|VINDEX_MAX
condition|)
block|{
name|error
argument_list|(
literal|"too many virtual functions for class `%s' (VINDEX_MAX< %d)"
argument_list|,
name|err_name
argument_list|,
name|has_virtual
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_VSIZE
argument_list|(
name|t
argument_list|)
operator|=
name|has_virtual
expr_stmt|;
if|if
condition|(
name|first_vfn_base_index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|pending_virtuals
condition|)
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_virtual
condition|)
block|{
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|pending_virtuals
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|>=
literal|0
condition|)
name|DECL_VIRTUAL_P
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Now lay out the virtual function table.  */
if|if
condition|(
name|has_virtual
condition|)
block|{
name|tree
name|atype
decl_stmt|,
name|itype
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
operator|==
name|ptr_type_node
condition|)
block|{
comment|/* We must create a pointer to this table because 	     the one inherited from base class does not exist. 	     We will fill in the type when we know what it 	     should really be.  Use `size_int' so values are memoized 	     in common cases.  */
name|itype
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|has_virtual
argument_list|)
argument_list|)
expr_stmt|;
name|atype
operator|=
name|build_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_virtual
operator|!=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|atype
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We must extend (or create) the boundaries on this array, 		 because we picked up virtual functions from multiple 		 base classes.  */
name|itype
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|has_virtual
argument_list|)
argument_list|)
expr_stmt|;
name|atype
operator|=
name|build_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
name|vfield
operator|=
name|copy_node
argument_list|(
name|vfield
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
block|}
block|}
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|atype
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|atype
expr_stmt|;
name|layout_decl
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|first_vfn_base_index
operator|>=
literal|0
condition|)
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|vfields
expr_stmt|;
comment|/* Set all appropriate CLASSTYPE_... flags for this type      and its variants.  */
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|needs_ctor
operator|||
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
operator|(
operator|(
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|)
operator|||
name|has_virtual
operator|||
name|any_default_members
operator|||
name|first_vfn_base_index
operator|>=
literal|0
operator|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|needs_dtor
operator|||
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_struct_bits
argument_list|(
name|t
argument_list|,
name|max_has_virtual
argument_list|)
expr_stmt|;
comment|/* Promote each bit-field's type to int if it is narrower than that.      There's more: complete the rtl for any static member objects which      is of the same type we're working on.   */
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|&&
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|==
name|t
condition|)
block|{
name|DECL_MODE
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now add the tags, if any, to the list of TYPE_DECLs      defined for this type.  */
if|if
condition|(
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|x
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|last_x
operator|=
name|tree_last
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|x
condition|)
block|{
name|tree
name|tag
init|=
name|build_lang_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_CONTEXT
argument_list|(
name|tag
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|tag
argument_list|)
operator|=
name|t
expr_stmt|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|last_x
operator|=
name|chainon
argument_list|(
name|last_x
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|last_x
expr_stmt|;
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
comment|/* Mark the fact that constructor for T 	     could affect anybody inheriting from T 	     who wants to initialize vtables for VFIELDS's type.  */
if|if
condition|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|vfields
argument_list|)
operator|=
literal|1
expr_stmt|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|any_default_members
operator|!=
literal|0
condition|)
name|build_class_init_list
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
condition|)
name|build_class_init_list
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
block|{
if|if
condition|(
operator|!
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|t
argument_list|)
condition|)
name|embrace_waiting_friends
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Write out inline function definitions.  */
name|do_inline_function_hair
argument_list|(
name|t
argument_list|,
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|if (!TYPE_USES_COMPLEX_INHERITANCE (t)) 	TYPE_NONCOPIED_PARTS (t) = build_tree_list (default_conversion (TYPE_BINFO_VTABLE (t)), vfield);
endif|#
directive|endif
if|if
condition|(
operator|(
name|flag_this_is_variable
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|tree
name|vtbl_ptr
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|VPTR_NAME
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_REGISTER
argument_list|(
name|vtbl_ptr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_VTBL_PTR
argument_list|(
name|t
argument_list|)
operator|=
name|vtbl_ptr
expr_stmt|;
block|}
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|!=
name|t
condition|)
block|{
name|tree
name|binfo
init|=
name|binfo_value
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|tree
name|offset
init|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|vfield
operator|=
name|copy_node
argument_list|(
name|vfield
argument_list|)
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|vfield
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|offset
argument_list|)
condition|)
name|offset
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|offset
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_FIELD_BITPOS
argument_list|(
name|vfield
argument_list|)
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|vfield
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
block|}
if|if
condition|(
name|warn_nonvdtor
operator|&&
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_VINDEX
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|warning
argument_list|(
literal|"class `%s' has virtual functions but non-virtual destructor"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
block|}
comment|/* Make the rtl for any new vtables we have created, and unmark      the base types we marked.  */
name|unmark_finished_struct
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_BEING_DEFINED
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_dossier
operator|&&
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|variants
decl_stmt|;
name|tree
name|tdecl
decl_stmt|;
comment|/* Now instantiate its type descriptors.  */
name|tdecl
operator|=
name|TREE_OPERAND
argument_list|(
name|build_t_desc
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variants
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|build_type_variant
argument_list|(
name|variants
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|variants
condition|)
block|{
name|build_t_desc
argument_list|(
name|variants
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
expr_stmt|;
block|}
name|variants
operator|=
name|build_reference_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|build_type_variant
argument_list|(
name|variants
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|variants
condition|)
block|{
name|build_t_desc
argument_list|(
name|variants
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|DECL_VPARENT (tdecl) = t;
endif|#
directive|endif
name|DECL_CONTEXT
argument_list|(
name|tdecl
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
comment|/* Still need to instantiate this C struct's type descriptor.  */
elseif|else
if|if
condition|(
name|flag_dossier
operator|&&
operator|!
name|CLASSTYPE_DOSSIER
argument_list|(
name|t
argument_list|)
condition|)
name|build_t_desc
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
condition|)
name|undo_template_name_overload
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_class_type
condition|)
name|popclass
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"trying to finish struct, but kicked out due to previous parse errors."
argument_list|)
expr_stmt|;
name|hack_incomplete_structures
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_struct
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This has to be done after we have sorted out what to do with      the enclosing type.  */
comment|/* Be smarter about nested classes here.  If a type is nested,      only output it if we would output the enclosing type.  */
block|if (DECL_CONTEXT (TYPE_NAME (t))&& TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (TYPE_NAME (t)))) == 't')     DECL_IGNORED_P (TYPE_NAME (t)) = TREE_ASM_WRITTEN (TYPE_NAME (t));
endif|#
directive|endif
comment|/* If the type has methods, we want to think about cutting down      the amount of symbol table stuff we output.  The value stored in      the TYPE_DECL's DECL_IGNORED_P slot is a first approximation.      For example, if a member function is seen and we decide to      write out that member function, then we can change the value      of the DECL_IGNORED_P slot, and the type will be output when      that member function's debug info is written out.  */
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
condition|)
block|{
specifier|extern
name|tree
name|pending_vtables
decl_stmt|;
comment|/* Don't output full info about any type 	 which does not have its implementation defined here.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|&&
name|write_virtuals
operator|==
literal|2
condition|)
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
operator|(
name|value_member
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|,
name|pending_vtables
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
condition|)
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Only a first approximation!  */
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
condition|)
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
name|global_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return non-zero if the effective type of INSTANCE is static.    Used to determine whether the virtual function table is needed    or not.     *NONNULL is set iff INSTANCE can be known to be nonnull, regardless    of our knowledge of its type.  */
end_comment

begin_function
name|int
name|resolves_to_fixed_type_p
parameter_list|(
name|instance
parameter_list|,
name|nonnull
parameter_list|)
name|tree
name|instance
decl_stmt|;
name|int
modifier|*
name|nonnull
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
comment|/* Check that we are not going through a cast of some sort.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|instance
operator|=
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* fall through...  */
case|case
name|CALL_EXPR
case|:
comment|/* This is a call to a constructor, hence it's never zero.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|instance
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|SAVE_EXPR
case|:
comment|/* This is a call to a constructor, hence it's never zero.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|instance
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|RTL_EXPR
case|:
comment|/* This is a call to `new', hence it's never zero.  */
if|if
condition|(
name|TREE_CALLS_NEW
argument_list|(
name|instance
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
comment|/* Propagate nonnull.  */
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|1
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|WITH_CLEANUP_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
comment|/* fall through... */
case|case
name|VAR_DECL
case|:
case|case
name|FIELD_DECL
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* fall through... */
case|case
name|TARGET_EXPR
case|:
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|nonnull
condition|)
block|{
if|if
condition|(
name|instance
operator|==
name|current_class_decl
operator|&&
name|flag_this_is_variable
operator|<=
literal|0
condition|)
block|{
comment|/* Some people still use `this = 0' inside destructors.  */
operator|*
name|nonnull
operator|=
operator|!
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In a constructor, we know our type.  */
if|if
condition|(
name|flag_this_is_variable
operator|<
literal|0
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
comment|/* Reference variables should be references to objects.  */
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_class_processing
parameter_list|()
block|{
name|current_class_depth
operator|=
literal|0
expr_stmt|;
name|current_class_stacksize
operator|=
literal|10
expr_stmt|;
name|current_class_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|current_class_stacksize
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|current_class_stack
operator|=
name|current_class_base
expr_stmt|;
name|current_lang_stacksize
operator|=
literal|10
expr_stmt|;
name|current_lang_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|current_lang_stacksize
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|current_lang_stack
operator|=
name|current_lang_base
expr_stmt|;
name|delta_name
operator|=
name|get_identifier
argument_list|(
name|VTABLE_DELTA_NAME
argument_list|)
expr_stmt|;
name|pfn_name
operator|=
name|get_identifier
argument_list|(
name|VTABLE_PFN_NAME
argument_list|)
expr_stmt|;
comment|/* Keep these values lying around.  */
name|the_null_vtable_entry
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|base_layout_decl
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|base_layout_decl
argument_list|)
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set current scope to NAME. CODE tells us if this is a    STRUCT, UNION, or ENUM environment.     NAME may end up being NULL_TREE if this is an anonymous or    late-bound struct (as in "struct { ... } foo;")  */
end_comment

begin_comment
comment|/* Here's a subroutine we need because C lacks lambdas.  */
end_comment

begin_function
specifier|static
name|void
name|unuse_fields
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fields
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|TREE_USED
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|unuse_fields
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set global variables CURRENT_CLASS_NAME and CURRENT_CLASS_TYPE to    appropriate values, found by looking up the type definition of    NAME (as a CODE).     If MODIFY is 1, we set IDENTIFIER_CLASS_VALUE's of names    which can be seen locally to the class.  They are shadowed by    any subsequent local declaration (including parameter names).     If MODIFY is 2, we set IDENTIFIER_CLASS_VALUE's of names    which have static meaning (i.e., static members, static    member functions, enum declarations, etc).     If MODIFY is 3, we set IDENTIFIER_CLASS_VALUE of names    which can be seen locally to the class (as in 1), but    know that we are doing this for declaration purposes    (i.e. friend foo::bar (int)).     So that we may avoid calls to lookup_name, we cache the _TYPE    nodes of local TYPE_DECLs in the TREE_TYPE field of the name.     For multiple inheritance, we perform a two-pass depth-first search    of the type lattice.  The first pass performs a pre-order search,    marking types after the type has had its fields installed in    the appropriate IDENTIFIER_CLASS_VALUE slot.  The second pass merely    unmarks the marked types.  If a field or member function name    appears in an ambiguous way, the IDENTIFIER_CLASS_VALUE of    that name becomes `error_mark_node'.  */
end_comment

begin_function
name|void
name|pushclass
parameter_list|(
name|type
parameter_list|,
name|modify
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|modify
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pushclass"
argument_list|)
expr_stmt|;
name|debug_bindings_indentation
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
name|push_memoized_context
argument_list|(
name|type
argument_list|,
name|modify
argument_list|)
expr_stmt|;
name|current_class_depth
operator|++
expr_stmt|;
operator|*
name|current_class_stack
operator|++
operator|=
name|current_class_name
expr_stmt|;
operator|*
name|current_class_stack
operator|++
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|current_class_stack
operator|>=
name|current_class_base
operator|+
name|current_class_stacksize
condition|)
block|{
name|current_class_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|current_class_base
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
operator|(
name|current_class_stacksize
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
name|current_class_stack
operator|=
name|current_class_base
operator|+
name|current_class_stacksize
expr_stmt|;
name|current_class_stacksize
operator|+=
literal|10
expr_stmt|;
block|}
name|current_class_name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current_class_name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|current_class_name
operator|=
name|DECL_NAME
argument_list|(
name|current_class_name
argument_list|)
expr_stmt|;
name|current_class_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|prev_class_type
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|type
operator|!=
name|prev_class_type
operator|||
name|TYPE_SIZE
argument_list|(
name|prev_class_type
argument_list|)
operator|==
name|NULL_TREE
comment|/* ??? Is this necessary any more?  */
operator|||
name|IDENTIFIER_TEMPLATE
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|prev_class_type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|current_class_depth
operator|==
literal|1
operator|||
name|modify
operator|==
literal|3
operator|)
condition|)
block|{
comment|/* Forcibly remove any old class remnants.  */
name|popclass
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|prev_class_type
operator|=
literal|0
expr_stmt|;
block|}
name|pushlevel_class
argument_list|()
expr_stmt|;
if|if
condition|(
name|modify
condition|)
block|{
name|tree
name|tags
decl_stmt|;
name|tree
name|this_fndecl
init|=
name|current_function_decl
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|current_function_decl
operator|=
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
else|else
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
condition|)
block|{
name|declare_uninstantiated_type_level
argument_list|()
expr_stmt|;
name|overload_template_name
argument_list|(
name|current_class_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|prev_class_type
condition|)
block|{
name|build_mi_matrix
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|push_class_decls
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|free_mi_matrix
argument_list|()
expr_stmt|;
name|prev_class_type
operator|=
name|type
expr_stmt|;
block|}
else|else
name|unuse_fields
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|tags
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
init|;
name|tags
condition|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
control|)
block|{
name|TREE_NONLOCAL_FLAG
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
condition|)
continue|continue;
name|pushtag
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|current_function_decl
operator|=
name|this_fndecl
expr_stmt|;
block|}
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_push_class
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|debug_bindings_indentation
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Get out of the current class scope. If we were in a class scope    previously, that is the one popped to.  The flag MODIFY tells    whether the current scope declarations needs to be modified    as a result of popping to the previous scope.  */
end_comment

begin_function
name|void
name|popclass
parameter_list|(
name|modify
parameter_list|)
name|int
name|modify
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"popclass"
argument_list|)
expr_stmt|;
name|debug_bindings_indentation
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_pop_class
argument_list|()
expr_stmt|;
if|if
condition|(
name|modify
operator|<
literal|0
condition|)
block|{
comment|/* Back this old class out completely.  */
name|tree
name|tags
init|=
name|CLASSTYPE_TAGS
argument_list|(
name|prev_class_type
argument_list|)
decl_stmt|;
name|pop_class_decls
argument_list|(
name|prev_class_type
argument_list|)
expr_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
name|TREE_NONLOCAL_FLAG
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|modify
condition|)
block|{
comment|/* Just remove from this class what didn't make 	 it into IDENTIFIER_CLASS_VALUE.  */
name|tree
name|tags
init|=
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
name|TREE_NONLOCAL_FLAG
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
condition|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current_class_type
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
condition|)
name|undo_template_name_overload
argument_list|(
name|current_class_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel_class
argument_list|()
expr_stmt|;
name|current_class_depth
operator|--
expr_stmt|;
name|current_class_type
operator|=
operator|*
operator|--
name|current_class_stack
expr_stmt|;
name|current_class_name
operator|=
operator|*
operator|--
name|current_class_stack
expr_stmt|;
if|if
condition|(
name|current_class_type
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_VTBL_PTR
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|current_vtable_decl
operator|=
name|lookup_name
argument_list|(
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VTBL_PTR
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_vtable_decl
condition|)
name|current_vtable_decl
operator|=
name|build_indirect_ref
argument_list|(
name|current_vtable_decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|current_class_decl
operator|=
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
name|THIS_NAME
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_class_decl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_class_decl
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|temp
decl_stmt|;
comment|/* Can't call build_indirect_ref here, because it has special 		 logic to return C_C_D given this argument.  */
name|C_C_D
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|current_class_type
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
name|temp
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_class_decl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|C_C_D
argument_list|)
operator|=
name|TYPE_READONLY
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|C_C_D
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|C_C_D
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
name|C_C_D
operator|=
name|current_class_decl
expr_stmt|;
block|}
else|else
name|C_C_D
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|current_class_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|current_vtable_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|C_C_D
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|pop_memoized_context
argument_list|(
name|modify
argument_list|)
expr_stmt|;
name|ret
label|:
empty_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|debug_bindings_indentation
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Set global variables CURRENT_LANG_NAME to appropriate value    so that behavior of name-mangling machinery is correct.  */
end_comment

begin_function
name|void
name|push_lang_context
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
operator|*
name|current_lang_stack
operator|++
operator|=
name|current_lang_name
expr_stmt|;
if|if
condition|(
name|current_lang_stack
operator|>=
name|current_lang_base
operator|+
name|current_lang_stacksize
condition|)
block|{
name|current_lang_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|current_lang_base
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
operator|(
name|current_lang_stacksize
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
name|current_lang_stack
operator|=
name|current_lang_base
operator|+
name|current_lang_stacksize
expr_stmt|;
name|current_lang_stacksize
operator|+=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|lang_name_cplusplus
condition|)
block|{
name|strict_prototype
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
name|current_lang_name
operator|=
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|lang_name_c
condition|)
block|{
name|strict_prototype
operator|=
name|strict_prototypes_lang_c
expr_stmt|;
name|current_lang_name
operator|=
name|name
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"language string `\"%s\"' not recognized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_push_lang
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get out of the current language scope.  */
end_comment

begin_function
name|void
name|pop_lang_context
parameter_list|()
block|{
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_pop_lang
argument_list|()
expr_stmt|;
name|current_lang_name
operator|=
operator|*
operator|--
name|current_lang_stack
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
name|strict_prototype
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|strict_prototype
operator|=
name|strict_prototypes_lang_c
expr_stmt|;
block|}
end_function

begin_function
name|int
name|root_lang_context_p
parameter_list|()
block|{
return|return
name|current_lang_stack
operator|==
name|current_lang_base
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Type instantiation routines.  */
end_comment

begin_comment
comment|/* This function will instantiate the type of the expression given    in RHS to match the type of LHSTYPE.  If LHSTYPE is NULL_TREE,    or other errors exist, the TREE_TYPE of RHS will be ERROR_MARK_NODE.     This function is used in build_modify_expr, convert_arguments,    build_c_cast, and compute_conversion_costs.  */
end_comment

begin_function
name|tree
name|instantiate_type
parameter_list|(
name|lhstype
parameter_list|,
name|rhs
parameter_list|,
name|complain
parameter_list|)
name|tree
name|lhstype
decl_stmt|,
name|rhs
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|UNKNOWN_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
operator|(
name|type_unknown_p
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
return|return
name|rhs
return|;
comment|/* This should really only be used when attempting to distinguish      what sort of a pointer to function we have.  For now, any      arithmetic operation which is not supported on pointers      is rejected as an error.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|TYPE_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|CONSTRUCTOR
case|:
case|case
name|BUFFER_REF
case|:
name|my_friendly_abort
argument_list|(
literal|177
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
name|lhstype
operator|=
name|build_pointer_type
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|rhs
return|;
case|case
name|NOP_EXPR
case|:
name|rhs
operator|=
name|copy_node
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
name|complain
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|function
init|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|field
argument_list|,
name|complain
argument_list|)
decl_stmt|;
if|if
condition|(
name|function
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|185
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|tree
name|base
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|base_ptr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|base
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|base_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|base_ptr
operator|=
name|convert_pointer_to
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|,
name|base_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_vfn_ref
argument_list|(
operator|&
name|base_ptr
argument_list|,
name|base
argument_list|,
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
argument_list|)
return|;
block|}
return|return
name|function
return|;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
argument_list|,
literal|178
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
argument_list|,
literal|179
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
comment|/* First look for an exact match  */
while|while
condition|(
name|field
operator|&&
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|!=
name|lhstype
condition|)
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|field
expr_stmt|;
return|return
name|rhs
return|;
block|}
comment|/* No exact match found, look for a compatible function.  */
name|field
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|field
operator|&&
operator|!
name|comptypes
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|field
expr_stmt|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
while|while
condition|(
name|field
operator|&&
operator|!
name|comptypes
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"ambiguous overload for COMPONENT_REF requested"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no appropriate overload exists for COMPONENT_REF"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|rhs
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|elem
decl_stmt|,
name|baselink
decl_stmt|,
name|name
decl_stmt|;
name|int
name|globals
init|=
name|overloaded_globals_p
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
comment|/* If there's only one function we know about, return that.  */
if|if
condition|(
name|globals
operator|>
literal|0
operator|&&
name|TREE_CHAIN
argument_list|(
name|rhs
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
return|;
comment|/* First look for an exact match.  Search either overloaded 	   functions or member functions.  May have to undo what 	   `default_conversion' might do to lhstype.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"invalid type combination for overload"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|globals
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"cannot resolve overloaded function `%s' based on non-function type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|globals
operator|>
literal|0
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|180
argument_list|)
expr_stmt|;
name|elem
operator|=
name|rhs
expr_stmt|;
while|while
condition|(
name|elem
condition|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
argument_list|)
operator|!=
name|lhstype
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
else|else
return|return
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
return|;
comment|/* No exact match found, look for a compatible function.  */
name|elem
operator|=
name|rhs
expr_stmt|;
while|while
condition|(
name|elem
operator|&&
operator|!
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
name|tree
name|save_elem
init|=
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
decl_stmt|;
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
operator|&&
operator|!
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"ambiguous overload for overloaded function requested"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|save_elem
return|;
block|}
if|if
condition|(
name|complain
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|rhs
argument_list|)
condition|)
name|error
argument_list|(
literal|"no appropriate overload for overloaded function `%s' exists"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"function `%s' has inappropriate type signature"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_NONLOCAL_FLAG
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
comment|/* Got to get it as a baselink.  */
name|rhs
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|rhs
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|rhs
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|181
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|rhs
operator|=
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|182
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|baselink
operator|=
name|rhs
init|;
name|baselink
condition|;
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
control|)
block|{
name|elem
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
condition|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
operator|!=
name|lhstype
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
else|else
return|return
name|elem
return|;
block|}
comment|/* No exact match found, look for a compatible method.  */
for|for
control|(
name|baselink
operator|=
name|rhs
init|;
name|baselink
condition|;
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
control|)
block|{
name|elem
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
operator|&&
operator|!
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
name|tree
name|save_elem
init|=
name|elem
decl_stmt|;
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
operator|&&
operator|!
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"ambiguous overload for overloaded method requested"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|save_elem
return|;
block|}
name|name
operator|=
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|globals
operator|<
literal|0
condition|)
block|{
comment|/* Try to instantiate from non-member functions.  */
name|rhs
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* This code seems to be missing a `return'.  */
name|my_friendly_abort
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
name|complain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no static member functions named `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
case|case
name|CALL_EXPR
case|:
comment|/* This is too hard for now.  */
name|my_friendly_abort
argument_list|(
literal|183
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|FFS_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"illegal operation on uninstantiated type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|type_unknown_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|MODIFY_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"type for resolving address of overloaded function must be pointer type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|ENTRY_VALUE_EXPR
case|:
name|my_friendly_abort
argument_list|(
literal|184
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|185
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the name of the virtual function pointer field    (as an IDENTIFIER_NODE) for the given TYPE.  Note that    this may have to look back through base types to find the    ultimate field name.  (For single inheritance, these could    all be the same name.  Who knows for multiple inheritance).  */
end_comment

begin_function
specifier|static
name|tree
name|get_vfield_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
while|while
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|VFIELD_NAME_FORMAT
argument_list|)
operator|+
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VFIELD_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|print_class_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"convert_harshness = %d\n"
argument_list|,
name|n_convert_harshness
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compute_conversion_costs = %d\n"
argument_list|,
name|n_compute_conversion_costs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"build_method_call = %d (inner = %d)\n"
argument_list|,
name|n_build_method_call
argument_list|,
name|n_inner_fields_searched
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_vtables
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtables = %d; vtable searches = %d\n"
argument_list|,
name|n_vtables
argument_list|,
name|n_vtable_searches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtable entries = %d; vtable elems = %d\n"
argument_list|,
name|n_vtable_entries
argument_list|,
name|n_vtable_elems
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

