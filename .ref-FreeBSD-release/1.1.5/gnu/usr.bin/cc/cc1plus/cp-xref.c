begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Code for handling XREF output from GNU C++.    Copyright (C) 1992, 1993 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|getpwd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The character(s) used to join a directory specification (obtained with    getwd or equivalent) with a non-absolute file name.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FILE_NAME_JOINER
end_ifndef

begin_define
define|#
directive|define
name|FILE_NAME_JOINER
value|"/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero if NAME as a file name is absolute.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FILE_NAME_ABSOLUTE_P
end_ifndef

begin_define
define|#
directive|define
name|FILE_NAME_ABSOLUTE_P
parameter_list|(
name|NAME
parameter_list|)
value|(NAME[0] == '/')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For cross referencing.  */
end_comment

begin_decl_stmt
name|int
name|flag_gnu_xref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*	Common definitions						*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PALLOC
parameter_list|(
name|typ
parameter_list|)
value|((typ *) calloc(1,sizeof(typ)))
end_define

begin_comment
comment|/* Return a malloc'd copy of STR.  */
end_comment

begin_define
define|#
directive|define
name|SALLOC
parameter_list|(
name|str
parameter_list|)
define|\
value|((char *) ((str) == NULL ? NULL	\ 	    : (char *) strcpy ((char *) malloc (strlen ((str)) + 1), (str))))
end_define

begin_define
define|#
directive|define
name|SFREE
parameter_list|(
name|str
parameter_list|)
value|(str != NULL&& (free(str),0))
end_define

begin_define
define|#
directive|define
name|STREQL
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(strcmp((s1),(s2)) == 0)
end_define

begin_define
define|#
directive|define
name|STRNEQ
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(strcmp((s1),(s2)) != 0)
end_define

begin_define
define|#
directive|define
name|STRLSS
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(strcmp((s1),(s2))< 0)
end_define

begin_define
define|#
directive|define
name|STRLEQ
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(strcmp((s1),(s2))<= 0)
end_define

begin_define
define|#
directive|define
name|STRGTR
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(strcmp((s1),(s2))> 0)
end_define

begin_define
define|#
directive|define
name|STRGEQ
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(strcmp((s1),(s2))>= 0)
end_define

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*	Type definitions						*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_typedef
typedef|typedef
name|struct
name|_XREF_FILE
modifier|*
name|XREF_FILE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|_XREF_SCOPE
modifier|*
name|XREF_SCOPE
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_XREF_FILE
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|outname
decl_stmt|;
name|XREF_FILE
name|next
decl_stmt|;
block|}
name|XREF_FILE_INFO
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_XREF_SCOPE
block|{
name|int
name|gid
decl_stmt|;
name|int
name|lid
decl_stmt|;
name|XREF_FILE
name|file
decl_stmt|;
name|int
name|start
decl_stmt|;
name|XREF_SCOPE
name|outer
decl_stmt|;
block|}
name|XREF_SCOPE_INFO
typedef|;
end_typedef

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*	Local storage							*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
name|doing_xref
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|xref_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|xref_name
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XREF_FILE
name|all_files
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wd_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XREF_SCOPE
name|cur_scope
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|scope_ctr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XREF_FILE
name|last_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|last_fndecl
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*	Forward definitions						*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_function_decl
specifier|extern
name|void
name|GNU_xref_begin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|GNU_xref_end
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|GNU_xref_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|GNU_xref_start_scope
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|GNU_xref_end_scope
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|GNU_xref_ref
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|GNU_xref_decl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|GNU_xref_call
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|GNU_xref_function
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|GNU_xref_assign
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|GNU_xref_hier
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|GNU_xref_member
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_assign
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|XREF_FILE
name|find_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|filename
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|fctname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|declname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|simplify_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|fixname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|open_xref_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|type_as_string
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Start cross referencing.  FILE is the name of the file we xref.  */
end_comment

begin_function
name|void
name|GNU_xref_begin
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|doing_xref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|file
operator|!=
name|NULL
operator|&&
name|STRNEQ
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|open_xref_file
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|GNU_xref_file
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish cross-referencing.  ERRCNT is the number of errors    we encountered.  */
end_comment

begin_function
name|void
name|GNU_xref_end
parameter_list|(
name|ect
parameter_list|)
name|int
name|ect
decl_stmt|;
block|{
name|XREF_FILE
name|xf
decl_stmt|;
if|if
condition|(
operator|!
name|doing_xref
condition|)
return|return;
name|xf
operator|=
name|find_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|xf
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|cur_scope
operator|!=
name|NULL
condition|)
name|GNU_xref_end_scope
argument_list|(
name|cur_scope
operator|->
name|gid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|doing_xref
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xref_file
operator|==
name|NULL
condition|)
return|return;
name|fclose
argument_list|(
name|xref_file
argument_list|)
expr_stmt|;
name|xref_file
operator|=
name|NULL
expr_stmt|;
name|all_files
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ect
operator|>
literal|0
condition|)
name|unlink
argument_list|(
name|xref_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out xref for file named NAME.  */
end_comment

begin_function
name|void
name|GNU_xref_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|XREF_FILE
name|xf
decl_stmt|;
if|if
condition|(
operator|!
name|doing_xref
operator|||
name|name
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|xref_file
operator|==
name|NULL
condition|)
block|{
name|open_xref_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|doing_xref
condition|)
return|return;
block|}
if|if
condition|(
name|all_files
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|xref_file
argument_list|,
literal|"SCP * 0 0 0 0 RESET\n"
argument_list|)
expr_stmt|;
name|xf
operator|=
name|find_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|xf
operator|!=
name|NULL
condition|)
return|return;
name|xf
operator|=
name|PALLOC
argument_list|(
name|XREF_FILE_INFO
argument_list|)
expr_stmt|;
name|xf
operator|->
name|name
operator|=
name|SALLOC
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|xf
operator|->
name|next
operator|=
name|all_files
expr_stmt|;
name|all_files
operator|=
name|xf
expr_stmt|;
if|if
condition|(
name|wd_name
operator|==
name|NULL
condition|)
name|wd_name
operator|=
name|getpwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_NAME_ABSOLUTE_P
argument_list|(
name|name
argument_list|)
operator|||
operator|!
name|wd_name
condition|)
name|xf
operator|->
name|outname
operator|=
name|xf
operator|->
name|name
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|nmbuf
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|wd_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|FILE_NAME_JOINER
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|nmbuf
argument_list|,
literal|"%s%s%s"
argument_list|,
name|wd_name
argument_list|,
name|FILE_NAME_JOINER
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|nmbuf
expr_stmt|;
name|xf
operator|->
name|outname
operator|=
name|nmbuf
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|xref_file
argument_list|,
literal|"FIL %s %s 0\n"
argument_list|,
name|name
argument_list|,
name|wd_name
argument_list|)
expr_stmt|;
name|filename
argument_list|(
name|xf
argument_list|)
expr_stmt|;
name|fctname
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a scope identified at level ID.  */
end_comment

begin_function
name|void
name|GNU_xref_start_scope
parameter_list|(
name|id
parameter_list|)
name|HOST_WIDE_INT
name|id
decl_stmt|;
block|{
name|XREF_SCOPE
name|xs
decl_stmt|;
name|XREF_FILE
name|xf
decl_stmt|;
if|if
condition|(
operator|!
name|doing_xref
condition|)
return|return;
name|xf
operator|=
name|find_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|xs
operator|=
name|PALLOC
argument_list|(
name|XREF_SCOPE_INFO
argument_list|)
expr_stmt|;
name|xs
operator|->
name|file
operator|=
name|xf
expr_stmt|;
name|xs
operator|->
name|start
operator|=
name|lineno
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|start
operator|<=
literal|0
condition|)
name|xs
operator|->
name|start
operator|=
literal|1
expr_stmt|;
name|xs
operator|->
name|gid
operator|=
name|id
expr_stmt|;
name|xs
operator|->
name|lid
operator|=
operator|++
name|scope_ctr
expr_stmt|;
name|xs
operator|->
name|outer
operator|=
name|cur_scope
expr_stmt|;
name|cur_scope
operator|=
name|xs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a scope at level ID.    INID is ???    PRM is ???    KEEP is nonzero iff this scope is retained (nonzero if it's    a compiler-generated invisible scope).    TRNS is ???  */
end_comment

begin_function
name|void
name|GNU_xref_end_scope
parameter_list|(
name|id
parameter_list|,
name|inid
parameter_list|,
name|prm
parameter_list|,
name|keep
parameter_list|,
name|trns
parameter_list|)
name|HOST_WIDE_INT
name|id
decl_stmt|;
name|HOST_WIDE_INT
name|inid
decl_stmt|;
name|int
name|prm
decl_stmt|,
name|keep
decl_stmt|,
name|trns
decl_stmt|;
block|{
name|XREF_FILE
name|xf
decl_stmt|;
name|XREF_SCOPE
name|xs
decl_stmt|,
name|lxs
decl_stmt|,
name|oxs
decl_stmt|;
name|char
modifier|*
name|stype
decl_stmt|;
if|if
condition|(
operator|!
name|doing_xref
condition|)
return|return;
name|xf
operator|=
name|find_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|xf
operator|==
name|NULL
condition|)
return|return;
name|lxs
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|xs
operator|=
name|cur_scope
init|;
name|xs
operator|!=
name|NULL
condition|;
name|xs
operator|=
name|xs
operator|->
name|outer
control|)
block|{
if|if
condition|(
name|xs
operator|->
name|gid
operator|==
name|id
condition|)
break|break;
name|lxs
operator|=
name|xs
expr_stmt|;
block|}
if|if
condition|(
name|xs
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|inid
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|oxs
operator|=
name|cur_scope
init|;
name|oxs
operator|!=
name|NULL
condition|;
name|oxs
operator|=
name|oxs
operator|->
name|outer
control|)
block|{
if|if
condition|(
name|oxs
operator|->
name|gid
operator|==
name|inid
condition|)
break|break;
block|}
if|if
condition|(
name|oxs
operator|==
name|NULL
condition|)
return|return;
name|inid
operator|=
name|oxs
operator|->
name|lid
expr_stmt|;
block|}
if|if
condition|(
name|prm
operator|==
literal|2
condition|)
name|stype
operator|=
literal|"SUE"
expr_stmt|;
elseif|else
if|if
condition|(
name|prm
operator|!=
literal|0
condition|)
name|stype
operator|=
literal|"ARGS"
expr_stmt|;
elseif|else
if|if
condition|(
name|keep
operator|==
literal|2
operator|||
name|inid
operator|!=
literal|0
condition|)
name|stype
operator|=
literal|"INTERN"
expr_stmt|;
else|else
name|stype
operator|=
literal|"EXTERN"
expr_stmt|;
name|fprintf
argument_list|(
name|xref_file
argument_list|,
literal|"SCP %s %d %d %d %d %s\n"
argument_list|,
name|filename
argument_list|(
name|xf
argument_list|)
argument_list|,
name|xs
operator|->
name|start
argument_list|,
name|lineno
argument_list|,
name|xs
operator|->
name|lid
argument_list|,
name|inid
argument_list|,
name|stype
argument_list|)
expr_stmt|;
if|if
condition|(
name|lxs
operator|==
name|NULL
condition|)
name|cur_scope
operator|=
name|xs
operator|->
name|outer
expr_stmt|;
else|else
name|lxs
operator|->
name|outer
operator|=
name|xs
operator|->
name|outer
expr_stmt|;
name|free
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a reference to NAME in FNDECL.  */
end_comment

begin_function
name|void
name|GNU_xref_ref
parameter_list|(
name|fndecl
parameter_list|,
name|name
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|XREF_FILE
name|xf
decl_stmt|;
if|if
condition|(
operator|!
name|doing_xref
condition|)
return|return;
name|xf
operator|=
name|find_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|xf
operator|==
name|NULL
condition|)
return|return;
name|fprintf
argument_list|(
name|xref_file
argument_list|,
literal|"REF %s %d %s %s\n"
argument_list|,
name|filename
argument_list|(
name|xf
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|fctname
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a reference to DECL in FNDECL.  */
end_comment

begin_function
name|void
name|GNU_xref_decl
parameter_list|(
name|fndecl
parameter_list|,
name|decl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|XREF_FILE
name|xf
decl_stmt|,
name|xf1
decl_stmt|;
name|char
modifier|*
name|cls
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
literal|10240
index|]
decl_stmt|;
name|int
name|uselin
decl_stmt|;
if|if
condition|(
operator|!
name|doing_xref
condition|)
return|return;
name|xf
operator|=
name|find_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|xf
operator|==
name|NULL
condition|)
return|return;
name|uselin
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|cls
operator|=
literal|"TYPEDEF"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|cls
operator|=
literal|"FIELD"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|fndecl
operator|==
name|NULL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
condition|)
name|cls
operator|=
literal|"CONST"
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|cls
operator|=
literal|"EXTERN"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|cls
operator|=
literal|"EXTDEF"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|cls
operator|=
literal|"STATIC"
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
name|cls
operator|=
literal|"REGISTER"
expr_stmt|;
else|else
name|cls
operator|=
literal|"AUTO"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|cls
operator|=
literal|"PARAM"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|cls
operator|=
literal|"FIELD"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|cls
operator|=
literal|"CONST"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|cls
operator|=
literal|"EXTERN"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|cls
operator|=
literal|"EFUNCTION"
expr_stmt|;
else|else
name|cls
operator|=
literal|"SFUNCTION"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|cls
operator|=
literal|"LABEL"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|cls
operator|=
literal|"UNIONID"
expr_stmt|;
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|uselin
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|decl
argument_list|)
condition|)
name|cls
operator|=
literal|"CLASSID"
expr_stmt|;
else|else
name|cls
operator|=
literal|"STRUCTID"
expr_stmt|;
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|uselin
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|cls
operator|=
literal|"ENUMID"
expr_stmt|;
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|uselin
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|cls
operator|=
literal|"UNKNOWN"
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL
operator|||
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|uselin
operator|&&
name|decl
operator|->
name|decl
operator|.
name|linenum
operator|>
literal|0
operator|&&
name|decl
operator|->
name|decl
operator|.
name|filename
operator|!=
name|NULL
condition|)
block|{
name|xf1
operator|=
name|find_file
argument_list|(
name|decl
operator|->
name|decl
operator|.
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|xf1
operator|!=
name|NULL
condition|)
block|{
name|lineno
operator|=
name|decl
operator|->
name|decl
operator|.
name|linenum
expr_stmt|;
name|xf
operator|=
name|xf1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|type_as_string
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|simplify_type
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|xref_file
argument_list|,
literal|"DCL %s %d %s %d %s %s %s\n"
argument_list|,
name|filename
argument_list|(
name|xf
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|name
argument_list|,
operator|(
name|cur_scope
operator|!=
name|NULL
condition|?
name|cur_scope
operator|->
name|lid
else|:
literal|0
operator|)
argument_list|,
name|cls
argument_list|,
name|fctname
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQL
argument_list|(
name|cls
argument_list|,
literal|"STRUCTID"
argument_list|)
operator|||
name|STREQL
argument_list|(
name|cls
argument_list|,
literal|"UNIONID"
argument_list|)
condition|)
block|{
name|cls
operator|=
literal|"CLASSID"
expr_stmt|;
name|fprintf
argument_list|(
name|xref_file
argument_list|,
literal|"DCL %s %d %s %d %s %s %s\n"
argument_list|,
name|filename
argument_list|(
name|xf
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|name
argument_list|,
operator|(
name|cur_scope
operator|!=
name|NULL
condition|?
name|cur_scope
operator|->
name|lid
else|:
literal|0
operator|)
argument_list|,
name|cls
argument_list|,
name|fctname
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a reference to a call to NAME in FNDECL.  */
end_comment

begin_function
name|void
name|GNU_xref_call
parameter_list|(
name|fndecl
parameter_list|,
name|name
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|XREF_FILE
name|xf
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|doing_xref
condition|)
return|return;
name|xf
operator|=
name|find_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|xf
operator|==
name|NULL
condition|)
return|return;
name|name
operator|=
name|fixname
argument_list|(
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|name
init|;
operator|*
name|s
operator|!=
literal|0
condition|;
operator|++
name|s
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'_'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
name|GNU_xref_ref
argument_list|(
name|fndecl
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|xref_file
argument_list|,
literal|"CAL %s %d %s %s\n"
argument_list|,
name|filename
argument_list|(
name|xf
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|name
argument_list|,
name|fctname
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output cross-reference info about FNDECL.  If non-NULL,    ARGS are the arguments for the function (i.e., before the FUNCTION_DECL    has been fully built).  */
end_comment

begin_function
name|void
name|GNU_xref_function
parameter_list|(
name|fndecl
parameter_list|,
name|args
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|XREF_FILE
name|xf
decl_stmt|;
name|int
name|ct
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|doing_xref
condition|)
return|return;
name|xf
operator|=
name|find_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|xf
operator|==
name|NULL
condition|)
return|return;
name|ct
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|args
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|GNU_xref_decl
argument_list|(
name|NULL
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|args
operator|!=
name|NULL
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|GNU_xref_decl
argument_list|(
name|fndecl
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|!=
literal|0
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|declname
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|ct
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|xref_file
argument_list|,
literal|"PRC %s %d %s %d %d %s\n"
argument_list|,
name|filename
argument_list|(
name|xf
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|declname
argument_list|(
name|fndecl
argument_list|)
argument_list|,
operator|(
name|cur_scope
operator|!=
name|NULL
condition|?
name|cur_scope
operator|->
name|lid
else|:
literal|0
operator|)
argument_list|,
name|ct
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output cross-reference info about an assignment to NAME.  */
end_comment

begin_function
name|void
name|GNU_xref_assign
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|XREF_FILE
name|xf
decl_stmt|;
if|if
condition|(
operator|!
name|doing_xref
condition|)
return|return;
name|xf
operator|=
name|find_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|xf
operator|==
name|NULL
condition|)
return|return;
name|gen_assign
argument_list|(
name|xf
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_assign
parameter_list|(
name|xf
parameter_list|,
name|name
parameter_list|)
name|XREF_FILE
name|xf
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
name|IDENTIFIER_NODE
case|:
name|s
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
name|s
operator|=
name|declname
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
name|gen_assign
argument_list|(
name|xf
argument_list|,
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|gen_assign
argument_list|(
name|xf
argument_list|,
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDIRECT_REF
case|:
case|case
name|OFFSET_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|BUFFER_REF
case|:
name|gen_assign
argument_list|(
name|xf
argument_list|,
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
name|gen_assign
argument_list|(
name|xf
argument_list|,
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default :
break|break;
block|}
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|xref_file
argument_list|,
literal|"ASG %s %d %s\n"
argument_list|,
name|filename
argument_list|(
name|xf
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output cross-reference info about a class hierarchy.    CLS is the class type of interest.  BASE is a baseclass    for CLS.  PUB and VIRT give the visibility info about    the class derivation.  FRND is nonzero iff BASE is a friend    of CLS.     ??? Needs to handle nested classes.  */
end_comment

begin_function
name|void
name|GNU_xref_hier
parameter_list|(
name|cls
parameter_list|,
name|base
parameter_list|,
name|pub
parameter_list|,
name|virt
parameter_list|,
name|frnd
parameter_list|)
name|char
modifier|*
name|cls
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|pub
decl_stmt|;
name|int
name|virt
decl_stmt|;
name|int
name|frnd
decl_stmt|;
block|{
name|XREF_FILE
name|xf
decl_stmt|;
if|if
condition|(
operator|!
name|doing_xref
condition|)
return|return;
name|xf
operator|=
name|find_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|xf
operator|==
name|NULL
condition|)
return|return;
name|fprintf
argument_list|(
name|xref_file
argument_list|,
literal|"HIE %s %d %s %s %d %d %d\n"
argument_list|,
name|filename
argument_list|(
name|xf
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|cls
argument_list|,
name|base
argument_list|,
name|pub
argument_list|,
name|virt
argument_list|,
name|frnd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output cross-reference info about class members.  CLS    is the containing type; FLD is the class member.  */
end_comment

begin_function
name|void
name|GNU_xref_member
parameter_list|(
name|cls
parameter_list|,
name|fld
parameter_list|)
name|tree
name|cls
decl_stmt|;
name|tree
name|fld
decl_stmt|;
block|{
name|XREF_FILE
name|xf
decl_stmt|;
name|char
modifier|*
name|prot
decl_stmt|;
name|int
name|confg
decl_stmt|,
name|pure
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
name|bufa
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|doing_xref
condition|)
return|return;
name|xf
operator|=
name|find_file
argument_list|(
name|fld
operator|->
name|decl
operator|.
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|xf
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|fld
argument_list|)
condition|)
name|prot
operator|=
literal|"PRIVATE"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|fld
argument_list|)
condition|)
name|prot
operator|=
literal|"PROTECTED"
expr_stmt|;
else|else
name|prot
operator|=
literal|"PUBLIC"
expr_stmt|;
name|confg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fld
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONST_MEMFUNC_P
argument_list|(
name|fld
argument_list|)
condition|)
name|confg
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fld
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|confg
operator|=
literal|1
expr_stmt|;
name|pure
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fld
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|fld
argument_list|)
condition|)
name|pure
operator|=
literal|1
expr_stmt|;
name|d
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|cls
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d%s"
argument_list|,
name|strlen
argument_list|(
name|d
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bufa
argument_list|,
name|declname
argument_list|(
name|fld
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XREF_SHORT_MEMBER_NAMES
for|for
control|(
name|p
operator|=
operator|&
name|bufa
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|p
index|[
literal|2
index|]
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'C'
operator|&&
name|p
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|p
index|[
literal|3
index|]
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|p
index|[
literal|3
index|]
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
name|fprintf
argument_list|(
name|xref_file
argument_list|,
literal|"MEM %s %d %s %s %s %d %d %d %d %d %d %d\n"
argument_list|,
name|filename
argument_list|(
name|xf
argument_list|)
argument_list|,
name|fld
operator|->
name|decl
operator|.
name|linenum
argument_list|,
name|d
argument_list|,
name|bufa
argument_list|,
name|prot
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|fld
argument_list|)
operator|==
name|FUNCTION_DECL
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|,
operator|(
name|DECL_INLINE
argument_list|(
name|fld
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
operator|(
name|DECL_FRIEND_P
argument_list|(
name|fld
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
operator|(
name|DECL_VINDEX
argument_list|(
name|fld
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
operator|(
name|TREE_STATIC
argument_list|(
name|fld
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
name|pure
argument_list|,
name|confg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find file entry given name.  */
end_comment

begin_function
specifier|static
name|XREF_FILE
name|find_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|XREF_FILE
name|xf
decl_stmt|;
for|for
control|(
name|xf
operator|=
name|all_files
init|;
name|xf
operator|!=
name|NULL
condition|;
name|xf
operator|=
name|xf
operator|->
name|next
control|)
block|{
if|if
condition|(
name|STREQL
argument_list|(
name|name
argument_list|,
name|xf
operator|->
name|name
argument_list|)
condition|)
break|break;
block|}
return|return
name|xf
return|;
block|}
end_function

begin_comment
comment|/* Return filename for output purposes.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|filename
parameter_list|(
name|xf
parameter_list|)
name|XREF_FILE
name|xf
decl_stmt|;
block|{
if|if
condition|(
name|xf
operator|==
name|NULL
condition|)
block|{
name|last_file
operator|=
name|NULL
expr_stmt|;
return|return
literal|"*"
return|;
block|}
if|if
condition|(
name|last_file
operator|==
name|xf
condition|)
return|return
literal|"*"
return|;
name|last_file
operator|=
name|xf
expr_stmt|;
return|return
name|xf
operator|->
name|outname
return|;
block|}
end_function

begin_comment
comment|/* Return function name for output purposes.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fctname
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
specifier|static
name|char
name|fctbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|fndecl
operator|==
name|NULL
operator|&&
name|last_fndecl
operator|==
name|NULL
condition|)
return|return
literal|"*"
return|;
if|if
condition|(
name|fndecl
operator|==
name|NULL
condition|)
block|{
name|last_fndecl
operator|=
name|NULL
expr_stmt|;
return|return
literal|"*TOP*"
return|;
block|}
if|if
condition|(
name|fndecl
operator|==
name|last_fndecl
condition|)
return|return
literal|"*"
return|;
name|last_fndecl
operator|=
name|fndecl
expr_stmt|;
name|s
operator|=
name|declname
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|s
operator|=
name|fixname
argument_list|(
name|s
argument_list|,
name|fctbuf
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Return decl name for output purposes.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|declname
parameter_list|(
name|dcl
parameter_list|)
name|tree
name|dcl
decl_stmt|;
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|dcl
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|"?"
return|;
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|dcl
argument_list|)
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|dcl
argument_list|)
argument_list|)
return|;
else|else
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|dcl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Simplify a type string by removing unneeded parenthesis.  */
end_comment

begin_function
specifier|static
name|void
name|simplify_type
parameter_list|(
name|typ
parameter_list|)
name|char
modifier|*
name|typ
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|lvl
decl_stmt|,
name|i
decl_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|typ
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
name|typ
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
name|typ
index|[
operator|--
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|7
operator|&&
name|STREQL
argument_list|(
operator|&
name|typ
index|[
name|i
operator|-
literal|5
index|]
argument_list|,
literal|"const"
argument_list|)
condition|)
block|{
name|typ
index|[
name|i
operator|-
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|-=
literal|5
expr_stmt|;
block|}
if|if
condition|(
name|typ
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|')'
condition|)
return|return;
name|s
operator|=
operator|&
name|typ
index|[
name|i
operator|-
literal|2
index|]
expr_stmt|;
name|lvl
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|')'
condition|)
operator|++
name|lvl
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
operator|--
name|lvl
expr_stmt|;
if|if
condition|(
name|lvl
operator|==
literal|0
condition|)
block|{
name|s
index|[
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
name|s
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
operator|--
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
operator|&&
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|')'
condition|)
block|{
operator|--
name|s
expr_stmt|;
operator|--
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
name|s
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'('
condition|)
operator|--
name|s
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
name|s
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Fixup a function name (take care of embedded spaces).  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fixname
parameter_list|(
name|nam
parameter_list|,
name|buf
parameter_list|)
name|char
modifier|*
name|nam
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|fg
decl_stmt|;
name|s
operator|=
name|nam
expr_stmt|;
name|t
operator|=
name|buf
expr_stmt|;
name|fg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
block|{
operator|*
name|t
operator|++
operator|=
literal|'\36'
expr_stmt|;
operator|++
name|fg
expr_stmt|;
block|}
else|else
operator|*
name|t
operator|++
operator|=
operator|*
name|s
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
operator|*
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fg
operator|==
literal|0
condition|)
return|return
name|nam
return|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Open file for xrefing.  */
end_comment

begin_function
specifier|static
name|void
name|open_xref_file
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|XREF_FILE_NAME
name|XREF_FILE_NAME
argument_list|(
name|xref_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|rindex
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|sprintf
argument_list|(
name|xref_name
argument_list|,
literal|".%s.gxref"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|s
expr_stmt|;
name|strcpy
argument_list|(
name|xref_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|t
operator|=
name|rindex
argument_list|(
name|xref_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|++
name|t
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'.'
expr_stmt|;
name|strcpy
argument_list|(
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|t
argument_list|,
literal|".gxref"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* no XREF_FILE_NAME */
name|xref_file
operator|=
name|fopen
argument_list|(
name|xref_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xref_file
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Can't create cross-reference file `%s'"
argument_list|,
name|xref_name
argument_list|)
expr_stmt|;
name|doing_xref
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

