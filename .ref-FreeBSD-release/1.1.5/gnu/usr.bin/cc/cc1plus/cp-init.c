begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle initialization things in C++.    Copyright (C) 1987, 1989, 1992, 1993 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* High-level class interface. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_comment
comment|/* In C++, structures with well-defined constructors are initialized by    those constructors, unasked.  CURRENT_BASE_INIT_LIST    holds a list of stmts for a BASE_INIT term in the grammar.    This list has one element for each base class which must be    initialized.  The list elements are [basename, init], with    type basetype.  This allows the possibly anachronistic form    (assuming d : a, b, c) "d (int a) : c(a+5), b (a-4), a (a+3)"    where each successive term can be handed down the constructor    line.  Perhaps this was not intended.  */
end_comment

begin_decl_stmt
name|tree
name|current_base_init_list
decl_stmt|,
name|current_member_init_list
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|emit_base_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|check_base_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_aggr_vbase_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|expand_member_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|expand_aggr_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_aggr_init_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_recursive_init_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_recursive_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|tree
name|expand_vec_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|tree
name|build_vec_delete
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|add_friend
argument_list|()
decl_stmt|,
name|add_friends
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cache _builtin_new and _builtin_delete exprs.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|BIN
decl_stmt|,
name|BID
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|minus_one
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up local variable for this file.  MUST BE CALLED AFTER    INIT_DECL_PROCESSING.  */
end_comment

begin_decl_stmt
name|tree
name|BI_header_type
decl_stmt|,
name|BI_header_size
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_init_processing
parameter_list|()
block|{
name|tree
name|op_id
decl_stmt|;
name|tree
name|fields
index|[
literal|2
index|]
decl_stmt|;
comment|/* Define implicit `operator new' and `operator delete' functions.  */
name|BIN
operator|=
name|default_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|BIN
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BID
operator|=
name|default_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|BID
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|minus_one
operator|=
name|build_int_2
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|op_id
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|op_id
argument_list|)
operator|=
name|BIN
expr_stmt|;
name|op_id
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|op_id
argument_list|)
operator|=
name|BID
expr_stmt|;
comment|/* Define the structure that holds header information for      arrays allocated via operator new.  */
name|BI_header_type
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"nelts"
argument_list|)
argument_list|,
name|sizetype
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"ptr_2comp"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|BI_header_type
argument_list|,
literal|"__new_cookie"
argument_list|,
name|fields
argument_list|,
literal|1
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
name|BI_header_size
operator|=
name|size_in_bytes
argument_list|(
name|BI_header_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recursive subroutine of emit_base_init.  For main type T,    recursively initialize the vfields of the base type PARENT.    RECURSE is non-zero when this function is being called    recursively.  */
end_comment

begin_function
specifier|static
name|void
name|init_vfields
parameter_list|(
name|t
parameter_list|,
name|parent
parameter_list|,
name|recurse
parameter_list|)
name|tree
name|t
decl_stmt|,
name|parent
decl_stmt|;
name|int
name|recurse
decl_stmt|;
block|{
name|tree
name|vfields
decl_stmt|;
comment|/* Initialize all the virtual function table fields that      do not come from virtual base classes.  */
name|vfields
operator|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|parent
argument_list|)
expr_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
name|tree
name|basetype
init|=
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
condition|?
name|TYPE_MAIN_VARIANT
argument_list|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
else|:
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
decl_stmt|;
comment|/* If the vtable installed by the constructor was not 	 the right one, fix that here.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|vfields
argument_list|)
operator|&&
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|(
name|recurse
operator|>
literal|0
operator|||
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
comment|/* BASE_INIT_LIST has already initialized the immediate basetypes.  */
operator|||
name|get_base_distance
argument_list|(
name|basetype
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
operator|>
literal|1
operator|)
condition|)
block|{
name|tree
name|binfo
init|=
name|binfo_value
argument_list|(
name|basetype
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|recurse
operator|!=
literal|0
operator|&&
operator|(
name|binfo
operator|!=
name|binfo_value
argument_list|(
name|basetype
argument_list|,
name|parent
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|recurse
operator|==
literal|0
operator|&&
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|!=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
operator|)
condition|)
block|{
name|tree
name|ptr
init|=
name|convert_pointer_to
argument_list|(
name|binfo
argument_list|,
name|current_class_decl
argument_list|)
decl_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_virtual_init
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|binfo
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|init_vfields
argument_list|(
name|t
argument_list|,
name|basetype
argument_list|,
name|recurse
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Perform whatever initialization have yet to be done on the    base class of the class variable.  These actions are in    the global variable CURRENT_BASE_INIT_LIST.  Such an    action could be NULL_TREE, meaning that the user has explicitly    called the base class constructor with no arguments.     If there is a need for a call to a constructor, we    must surround that call with a pushlevel/poplevel pair,    since we are technically at the PARM level of scope.     Argument IMMEDIATELY, if zero, forces a new sequence to be generated    to contain these new insns, so it can be emitted later.  This sequence    is saved in the global variable BASE_INIT_INSNS.  Otherwise, the insns    are emitted into the current sequence.     Note that emit_base_init does *not* initialize virtual    base classes.  That is done specially, elsewhere.  */
end_comment

begin_function
name|void
name|emit_base_init
parameter_list|(
name|t
parameter_list|,
name|immediately
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|immediately
decl_stmt|;
block|{
specifier|extern
name|tree
name|in_charge_identifier
decl_stmt|;
name|tree
name|member
decl_stmt|,
name|decl
decl_stmt|,
name|vbases
decl_stmt|;
name|tree
name|init_list
decl_stmt|;
name|int
name|pass
decl_stmt|,
name|start
decl_stmt|;
name|tree
name|t_binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|t_binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|fields_to_unmark
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|!
name|immediately
condition|)
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
comment|/* As a matter of principle, `start_sequence' should do this.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* Always emit a line number note so we can step into constructors.  */
name|emit_line_note_force
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In this case, we always need IN_CHARGE_NODE, because we have      to know whether to deallocate or not before exiting.  */
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
operator|&&
name|lookup_name
argument_list|(
name|in_charge_identifier
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|in_charge_node
init|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|in_charge_identifier
argument_list|,
name|integer_type_node
argument_list|)
argument_list|)
decl_stmt|;
name|store_init_value
argument_list|(
name|in_charge_node
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|current_class_decl
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|expand_decl
argument_list|(
name|in_charge_node
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|in_charge_node
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|pass
operator|=
name|start
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|tree
name|vbase_init_list
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|init_list
operator|=
name|current_base_init_list
init|;
name|init_list
condition|;
name|init_list
operator|=
name|TREE_CHAIN
argument_list|(
name|init_list
argument_list|)
control|)
block|{
name|tree
name|basename
init|=
name|TREE_PURPOSE
argument_list|(
name|init_list
argument_list|)
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|tree
name|init
init|=
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
decl_stmt|;
if|if
condition|(
name|basename
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Initializer for single base class.  Must not 		 use multiple inheritance or this is ambiguous.  */
switch|switch
condition|(
name|n_baseclasses
condition|)
block|{
case|case
literal|0
case|:
name|error
argument_list|(
literal|"type `%s' does not have a base class to initialize"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_class_name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
break|break;
default|default:
name|error
argument_list|(
literal|"unnamed initializer ambiguous for type `%s' which uses multiple inheritance"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_class_name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_aggr_typedef
argument_list|(
name|basename
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|binfo
operator|=
name|binfo_or_else
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|basename
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|NULL_TREE
condition|)
continue|continue;
comment|/* Virtual base classes are special cases.  Their initializers 		 are recorded with this constructor, and they are used when 		 this constructor is the top-level constructor called.  */
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
comment|/* Otherwise, if it is not an immediate base class, complain.  */
for|for
control|(
name|i
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"type `%s' is not an immediate base class of type `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|basename
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|current_class_name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
else|else
continue|continue;
comment|/* The base initialization list goes up to the first 	     base class which can actually use it.  */
if|if
condition|(
name|pass
operator|==
name|start
condition|)
block|{
name|char
modifier|*
name|msgp
init|=
operator|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|)
condition|?
literal|"cannot pass initialization up to class `%s'"
else|:
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|&&
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_VEC_LENGTH
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* ?? This should be fixed in RENO by forcing 		     default constructors to exist.  */
name|SET_BINFO_BASEINIT_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|msgp
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|error_with_aggr_type
argument_list|(
name|binfo
argument_list|,
name|msgp
argument_list|)
expr_stmt|;
else|else
name|msgp
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|msgp
operator|=
literal|"no constructor found for initialization of `%s'"
expr_stmt|;
name|error
argument_list|(
name|msgp
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|basename
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BINFO_BASEINIT_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|msgp
operator|=
literal|"class `%s' initializer already specified"
expr_stmt|;
name|error
argument_list|(
name|msgp
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|basename
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msgp
condition|)
continue|continue;
name|SET_BINFO_BASEINIT_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|vbase_init_list
operator|=
name|tree_cons
argument_list|(
name|init
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|vbase_init_list
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
continue|continue;
name|member
operator|=
name|convert_pointer_to
argument_list|(
name|binfo
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
name|expand_aggr_init_1
argument_list|(
name|t_binfo
argument_list|,
literal|0
argument_list|,
name|build_indirect_ref
argument_list|(
name|member
argument_list|,
literal|0
argument_list|)
argument_list|,
name|init
argument_list|,
name|BINFO_OFFSET_ZEROP
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|LOOKUP_PROTECTED_OK
operator||
name|LOOKUP_COMPLAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|cplus_expand_start_try
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|push_exception_cleanup
argument_list|(
name|member
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|tree
name|first_arg
init|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|vbases
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|first_arg
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* If there are virtual baseclasses without initialization 		 specified, and this is a default X(X&) constructor, 		 build the initialization list so that each virtual baseclass 		 of the new object is initialized from the virtual baseclass 		 of the incoming arg.  */
name|tree
name|init_arg
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_CHAIN
argument_list|(
name|first_arg
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
if|if
condition|(
name|BINFO_BASEINIT_MARKED
argument_list|(
name|vbases
argument_list|)
operator|==
literal|0
condition|)
block|{
name|member
operator|=
name|convert_pointer_to
argument_list|(
name|vbases
argument_list|,
name|init_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|==
name|init_arg
condition|)
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|first_arg
argument_list|)
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
operator|=
name|build_reference_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
expr_stmt|;
name|vbase_init_list
operator|=
name|tree_cons
argument_list|(
name|convert_from_reference
argument_list|(
name|member
argument_list|)
argument_list|,
name|vbases
argument_list|,
name|vbase_init_list
argument_list|)
expr_stmt|;
name|SET_BINFO_BASEINIT_MARKED
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|expand_start_cond
argument_list|(
name|first_arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_aggr_vbase_init
argument_list|(
name|t_binfo
argument_list|,
name|C_C_D
argument_list|,
name|current_class_decl
argument_list|,
name|vbase_init_list
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_vbase_vtables_init
argument_list|(
name|t_binfo
argument_list|,
name|t_binfo
argument_list|,
name|C_C_D
argument_list|,
name|current_class_decl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
block|}
name|current_base_init_list
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now, perform default initialization of all base classes which      have not yet been initialized, and unmark baseclasses which      have been initialized.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base
init|=
name|current_class_decl
decl_stmt|;
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|&&
operator|!
name|BINFO_BASEINIT_MARKED
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|tree
name|ref
decl_stmt|;
if|if
condition|(
name|BINFO_OFFSET_ZEROP
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|base
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
else|else
name|base
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
argument_list|,
name|current_class_decl
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
name|ref
operator|=
name|build_indirect_ref
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_aggr_init_1
argument_list|(
name|t_binfo
argument_list|,
literal|0
argument_list|,
name|ref
argument_list|,
name|NULL_TREE
argument_list|,
name|BINFO_OFFSET_ZEROP
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|LOOKUP_PROTECTED_OK
operator||
name|LOOKUP_COMPLAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|cplus_expand_start_try
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|push_exception_cleanup
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|CLEAR_BINFO_BASEINIT_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
name|CLEAR_BINFO_BASEINIT_MARKED
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
comment|/* Initialize all the virtual function table fields that      do not come from virtual base classes.  */
name|init_vfields
argument_list|(
name|t
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|t
argument_list|)
condition|)
name|expand_expr_stmt
argument_list|(
name|build_virtual_init
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|current_class_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Members we through expand_member_init.  We initialize all the members      needing initialization that did not get it so far.  */
for|for
control|(
init|;
name|current_member_init_list
condition|;
name|current_member_init_list
operator|=
name|TREE_CHAIN
argument_list|(
name|current_member_init_list
argument_list|)
control|)
block|{
name|tree
name|name
init|=
name|TREE_PURPOSE
argument_list|(
name|current_member_init_list
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|TREE_VALUE
argument_list|(
name|current_member_init_list
argument_list|)
decl_stmt|;
name|tree
name|field
init|=
operator|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|COMPONENT_REF
condition|?
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
else|:
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* If one member shadows another, get the outermost one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|field
operator|=
name|TREE_VALUE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_type_context
argument_list|(
name|field
argument_list|)
operator|!=
name|current_class_type
condition|)
name|error
argument_list|(
literal|"field `%s' not in immediate context"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
argument_list|,
literal|"field `%s::%s' is static; only point of initialization is its declaration"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|field
argument_list|)
condition|)
name|error
argument_list|(
literal|"multiple initializations given for member `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Mark this node as having been initialized.  */
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
operator|!=
name|t
condition|)
name|fields_to_unmark
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|field
argument_list|,
name|fields_to_unmark
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
comment|/* Initialization of anonymous union.  */
name|expand_assignment
argument_list|(
name|name
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|decl
operator|=
name|build_component_ref
argument_list|(
name|C_C_D
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Initialization of one array from another.  */
name|expand_vec_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|,
name|decl
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|init
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"types without constructors must have complete initializers"
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"initializer list treated as compound expression"
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_compound_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
else|else
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|decl
argument_list|,
name|INIT_EXPR
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cplus_expand_start_try
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|push_exception_cleanup
argument_list|(
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
block|{
comment|/* All we care about is this unique member.  It contains 	 all the information we need to know, and that right early.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|member
argument_list|)
condition|?
name|error_mark_node
else|:
name|DECL_INITIAL
argument_list|(
name|member
argument_list|)
decl_stmt|;
comment|/* Unmark this field.  If it is from an anonymous union,          then unmark the field recursively.  */
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|member
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_ANON_UNION_ELEM
argument_list|(
name|member
argument_list|)
condition|)
name|emit_base_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Member had explicit initializer.  */
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|init
condition|)
name|init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_component_ref
argument_list|(
name|C_C_D
argument_list|,
name|DECL_NAME
argument_list|(
name|member
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|init
condition|)
block|{
name|decl
operator|=
name|build_component_ref
argument_list|(
name|C_C_D
argument_list|,
name|DECL_NAME
argument_list|(
name|member
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|decl
argument_list|,
name|INIT_EXPR
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|warning
argument_list|(
literal|"uninitialized reference member `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|member
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cplus_expand_start_try
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|push_exception_cleanup
argument_list|(
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Unmark fields which are initialized for the base class.  */
while|while
condition|(
name|fields_to_unmark
condition|)
block|{
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|TREE_VALUE
argument_list|(
name|fields_to_unmark
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|fields_to_unmark
operator|=
name|TREE_CHAIN
argument_list|(
name|fields_to_unmark
argument_list|)
expr_stmt|;
block|}
comment|/* It is possible for the initializers to need cleanups.      Expand those cleanups now that all the initialization      has been done.  */
name|expand_cleanups_to
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|immediately
condition|)
block|{
specifier|extern
name|rtx
name|base_init_insns
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|base_init_insns
operator|==
literal|0
argument_list|,
literal|207
argument_list|)
expr_stmt|;
name|base_init_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* All the implicit try blocks we built up will be zapped      when we come to a real binding contour boundary.  */
block|}
end_function

begin_comment
comment|/* Check that all fields are properly initialized after    an assignment to `this'.  */
end_comment

begin_function
name|void
name|check_base_init
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|member
decl_stmt|;
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|member
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|member
argument_list|)
condition|)
name|error
argument_list|(
literal|"field `%s' used before initialized (after assignment to `this')"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|member
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This code sets up the virtual function tables appropriate for    the pointer DECL.  It is a one-ply initialization.     BINFO is the exact type that DECL is supposed to be.  In    multiple inheritance, this might mean "C's A" if C : A, B.  */
end_comment

begin_function
name|tree
name|build_virtual_init
parameter_list|(
name|main_binfo
parameter_list|,
name|binfo
parameter_list|,
name|decl
parameter_list|)
name|tree
name|main_binfo
decl_stmt|,
name|binfo
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|vtbl
decl_stmt|,
name|vtbl_ptr
decl_stmt|;
name|tree
name|vtype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|type
operator|=
name|binfo
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|46
argument_list|)
expr_stmt|;
name|vtype
operator|=
name|DECL_CONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This code suggests that it's time to rewrite how we handle      replicated baseclasses in G++.  */
block|if (get_base_distance (vtype, TREE_TYPE (TREE_TYPE (decl)), 			 0, (tree *) 0) == -2)     {       tree binfos = TYPE_BINFO_BASETYPES (TREE_TYPE (TREE_TYPE (decl)));       int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;       tree result = NULL_TREE;        for (i = n_baselinks-1; i>= 0; i--) 	{ 	  tree base_binfo = TREE_VEC_ELT (binfos, i); 	  tree this_decl;  	  if (get_base_distance (vtype, BINFO_TYPE (base_binfo), 0, 0) == -1) 	    continue;  	  if (TREE_VIA_VIRTUAL (base_binfo)) 	    this_decl = build_vbase_pointer (build_indirect_ref (decl), BINFO_TYPE (base_binfo)); 	  else if (BINFO_OFFSET_ZEROP (base_binfo)) 	    this_decl = build1 (NOP_EXPR, TYPE_POINTER_TO (BINFO_TYPE (base_binfo)), 				decl); 	  else 	    this_decl = build (PLUS_EXPR, TYPE_POINTER_TO (BINFO_TYPE (base_binfo)), 			       decl, BINFO_OFFSET (base_binfo)); 	  result = tree_cons (NULL_TREE, build_virtual_init (main_binfo, base_binfo, this_decl), result); 	}       return build_compound_expr (result);     }
endif|#
directive|endif
block|{
if|#
directive|if
literal|1
if|#
directive|if
literal|1
name|vtbl
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo_value
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* The below does not work when we have to step through the 	 vfield, on our way down to the most base class for the 	 vfield. */
name|vtbl
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo_value
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|main_binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|my_friendly_assert
argument_list|(
name|BINFO_TYPE
argument_list|(
name|main_binfo
argument_list|)
operator|==
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|208
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|BINFO_VTABLE
argument_list|(
name|main_binfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 1 */
name|assemble_external
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|vtbl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|vtbl
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|)
argument_list|,
name|vtbl
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|convert_pointer_to
argument_list|(
name|vtype
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|vtbl_ptr
operator|=
name|build_vfield_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|vtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtbl_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Have to convert VTBL since array sizes may be different.  */
return|return
name|build_modify_expr
argument_list|(
name|vtbl_ptr
argument_list|,
name|NOP_EXPR
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtbl_ptr
argument_list|)
argument_list|,
name|vtbl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of `expand_aggr_vbase_init'.    BINFO is the binfo of the type that is being initialized.    INIT_LIST is the list of initializers for the virtual baseclass.  */
end_comment

begin_function
specifier|static
name|void
name|expand_aggr_vbase_init_1
parameter_list|(
name|binfo
parameter_list|,
name|exp
parameter_list|,
name|addr
parameter_list|,
name|init_list
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|exp
decl_stmt|,
name|addr
decl_stmt|,
name|init_list
decl_stmt|;
block|{
name|tree
name|init
init|=
name|value_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|init_list
argument_list|)
decl_stmt|;
name|tree
name|ref
init|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|init
condition|)
name|init
operator|=
name|TREE_PURPOSE
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* Call constructors, but don't set up vtables.  */
name|expand_aggr_init_1
argument_list|(
name|binfo
argument_list|,
name|exp
argument_list|,
name|ref
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
name|LOOKUP_PROTECTED_OK
operator||
name|LOOKUP_COMPLAIN
operator||
name|LOOKUP_SPECULATIVELY
argument_list|)
expr_stmt|;
name|CLEAR_BINFO_VBASE_INIT_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize this object's virtual base class pointers.  This must be    done only at the top-level of the object being constructed.     INIT_LIST is list of initialization for constructor to perform.  */
end_comment

begin_function
specifier|static
name|void
name|expand_aggr_vbase_init
parameter_list|(
name|binfo
parameter_list|,
name|exp
parameter_list|,
name|addr
parameter_list|,
name|init_list
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|tree
name|addr
decl_stmt|;
name|tree
name|init_list
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|result
init|=
name|init_vbase_pointers
argument_list|(
name|type
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|tree
name|vbases
decl_stmt|;
if|if
condition|(
name|result
condition|)
name|expand_expr_stmt
argument_list|(
name|build_compound_expr
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark everything as having an initializer 	 (either explicit or default).  */
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
name|SET_BINFO_VBASE_INIT_MARKED
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
comment|/* First, initialize baseclasses which could be baseclasses 	 for other virtual baseclasses.  */
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
comment|/* Don't initialize twice.  */
if|if
condition|(
name|BINFO_VBASE_INIT_MARKED
argument_list|(
name|vbases
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|result
decl_stmt|;
while|while
condition|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
operator|!=
name|BINFO_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tmp
argument_list|)
argument_list|)
condition|)
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|expand_aggr_vbase_init_1
argument_list|(
name|vbases
argument_list|,
name|exp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|init_list
argument_list|)
expr_stmt|;
block|}
comment|/* Now initialize the baseclasses which don't have virtual baseclasses.  */
for|for
control|(
init|;
name|result
condition|;
name|result
operator|=
name|TREE_CHAIN
argument_list|(
name|result
argument_list|)
control|)
comment|/* Don't initialize twice.  */
if|if
condition|(
name|BINFO_VBASE_INIT_MARKED
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|result
argument_list|)
argument_list|)
condition|)
block|{
name|my_friendly_abort
argument_list|(
literal|47
argument_list|)
expr_stmt|;
name|expand_aggr_vbase_init_1
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|result
argument_list|)
argument_list|,
name|exp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|result
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|init_list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Subroutine to perform parser actions for member initialization.    S_ID is the scoped identifier.    NAME is the name of the member.    INIT is the initializer, or `void_type_node' if none.  */
end_comment

begin_function
name|void
name|do_member_init
parameter_list|(
name|s_id
parameter_list|,
name|name
parameter_list|,
name|init
parameter_list|)
name|tree
name|s_id
decl_stmt|,
name|name
decl_stmt|,
name|init
decl_stmt|;
block|{
name|tree
name|binfo
decl_stmt|,
name|base
decl_stmt|;
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
operator|!
name|is_aggr_typedef
argument_list|(
name|s_id
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|binfo
operator|=
name|get_binfo
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|s_id
argument_list|)
argument_list|,
name|current_class_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|binfo
operator|==
literal|0
condition|)
block|{
name|error_not_base_type
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|s_id
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return;
block|}
name|base
operator|=
name|convert_pointer_to
argument_list|(
name|binfo
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
name|expand_member_init
argument_list|(
name|build_indirect_ref
argument_list|(
name|base
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|name
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function to give error message if member initialization specification    is erroneous.  FIELD is the member we decided to initialize.    TYPE is the type for which the initialization is being performed.    FIELD must be a member of TYPE, or the base type from which FIELD    comes must not need a constructor.        MEMBER_NAME is the name of the member.  */
end_comment

begin_function
specifier|static
name|int
name|member_init_ok_or_else
parameter_list|(
name|field
parameter_list|,
name|type
parameter_list|,
name|member_name
parameter_list|)
name|tree
name|field
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|char
modifier|*
name|member_name
decl_stmt|;
block|{
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|type
argument_list|,
literal|"class `%s' does not have any field named `%s'"
argument_list|,
name|member_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
operator|!=
name|type
operator|&&
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"member `%s' comes from base class needing constructor"
argument_list|,
name|member_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If NAME is a viable field name for the aggregate DECL,    and PARMS is a viable parameter list, then expand an _EXPR    which describes this initialization.     Note that we do not need to chase through the class's base classes    to look for NAME, because if it's in that list, it will be handled    by the constructor for that base class.     We do not yet have a fixed-point finder to instantiate types    being fed to overloaded constructors.  If there is a unique    constructor, then argument types can be got from that one.     If INIT is non-NULL, then it the initialization should    be placed in `current_base_init_list', where it will be processed    by `emit_base_init'.  */
end_comment

begin_function
name|void
name|expand_member_init
parameter_list|(
name|exp
parameter_list|,
name|name
parameter_list|,
name|init
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|name
decl_stmt|,
name|init
decl_stmt|;
block|{
specifier|extern
name|tree
name|ptr_type_node
decl_stmt|;
comment|/* should be in tree.h */
name|tree
name|basetype
init|=
name|NULL_TREE
decl_stmt|,
name|field
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|tree
name|rval
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|actual_name
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL_TREE
condition|)
return|return;
comment|/* complain about this later */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
switch|switch
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|error
argument_list|(
literal|"base class initializer specified, but no base class to initialize"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
name|basetype
operator|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"initializer for unnamed base class ambiguous"
argument_list|)
expr_stmt|;
name|error_with_aggr_type
argument_list|(
name|type
argument_list|,
literal|"(type `%s' uses multiple inheritance)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|init
condition|)
block|{
comment|/* The grammar should not allow fields which have names 	 that are TYPENAMEs.  Therefore, if the field has 	 a non-NULL TREE_TYPE, we may assume that this is an 	 attempt to initialize a base class member of the current 	 type.  Otherwise, it is an attempt to initialize a 	 member field.  */
if|if
condition|(
name|init
operator|==
name|void_type_node
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
operator|||
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tree
name|base_init
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
if|if
condition|(
name|basetype
condition|)
name|name
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"no base class to initialize"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|basetype
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
operator|!=
name|type
operator|&&
operator|!
name|binfo_member
argument_list|(
name|basetype
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|binfo_member
argument_list|(
name|basetype
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
condition|)
goto|goto
name|try_member
goto|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"type `%s' is not an immediate or virtual basetype for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"type `%s' is not an immediate basetype for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|purpose_member
argument_list|(
name|name
argument_list|,
name|current_base_init_list
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"base class `%s' already initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|base_init
operator|=
name|build_tree_list
argument_list|(
name|name
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|base_init
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|current_base_init_list
operator|=
name|chainon
argument_list|(
name|current_base_init_list
argument_list|,
name|base_init
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|member_init
decl_stmt|;
name|try_member
label|:
name|field
operator|=
name|lookup_field
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|member_init_ok_or_else
argument_list|(
name|field
argument_list|,
name|type
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
return|return;
if|if
condition|(
name|purpose_member
argument_list|(
name|name
argument_list|,
name|current_member_init_list
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"field `%s' already initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|member_init
operator|=
name|build_tree_list
argument_list|(
name|name
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|member_init
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|current_member_init_list
operator|=
name|chainon
argument_list|(
name|current_member_init_list
argument_list|,
name|member_init
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
block|{
name|compiler_error
argument_list|(
literal|"expand_member_init: name == NULL_TREE"
argument_list|)
expr_stmt|;
return|return;
block|}
name|basetype
operator|=
name|type
expr_stmt|;
name|field
operator|=
name|lookup_field
argument_list|(
name|basetype
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|member_init_ok_or_else
argument_list|(
name|field
argument_list|,
name|basetype
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* now see if there is a constructor for this type      which will take these args. */
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|parmtypes
decl_stmt|,
name|fndecl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
comment|/* just know that we've seen something for this node */
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|actual_name
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|parm
operator|=
name|build_component_ref
argument_list|(
name|exp
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now get to the constructor.  */
name|fndecl
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get past destructor, if any.  */
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|fndecl
operator|=
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|209
argument_list|)
expr_stmt|;
comment|/* If the field is unique, we can use the parameter 	 types to guide possible type instantiation.  */
if|if
condition|(
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* There was a confusion here between 	     FIELD and FNDECL.  The following code 	     should be correct, but abort is here 	     to make sure.  */
name|my_friendly_abort
argument_list|(
literal|48
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|FUNCTION_ARG_CHAIN
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parmtypes
operator|=
name|NULL_TREE
expr_stmt|;
name|fndecl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|init
operator|=
name|convert_arguments
argument_list|(
name|parm
argument_list|,
name|parmtypes
argument_list|,
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|NULL_TREE
operator|||
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|rval
operator|=
name|build_method_call
argument_list|(
name|NULL_TREE
argument_list|,
name|actual_name
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|rval
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Now, fill in the first parm with our guy */
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rval
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|parm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|ptr_type_node
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|parm
operator|=
name|build_component_ref
argument_list|(
name|exp
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_aggr_init
argument_list|(
name|parm
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rval
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Now initialize the member.  It does not have to      be of aggregate type to receive initialization.  */
if|if
condition|(
name|rval
operator|!=
name|error_mark_node
condition|)
name|expand_expr_stmt
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is like `expand_member_init', only it stores one aggregate    value into another.     INIT comes in two flavors: it is either a value which    is to be stored in EXP, or it is a parameter list    to go to a constructor, which will operate on EXP.    If `init' is a CONSTRUCTOR, then we emit a warning message,    explaining that such initializations are illegal.     ALIAS_THIS is nonzero iff we are initializing something which is    essentially an alias for C_C_D.  In this case, the base constructor    may move it on us, and we must keep track of such deviations.     If INIT resolves to a CALL_EXPR which happens to return    something of the type we are looking for, then we know    that we can safely use that call to perform the    initialization.     The virtual function table pointer cannot be set up here, because    we do not really know its type.     Virtual baseclass pointers are also set up here.     This never calls operator=().     When initializing, nothing is CONST.     A default copy constructor may have to be used to perform the    initialization.     A constructor or a conversion operator may have to be used to    perform the initialization, but not both, as it would be ambiguous.    */
end_comment

begin_function
name|void
name|expand_aggr_init
parameter_list|(
name|exp
parameter_list|,
name|init
parameter_list|,
name|alias_this
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|init
decl_stmt|;
name|int
name|alias_this
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|was_const
init|=
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return;
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Must arrange to initialize each element of EXP 	 from elements of INIT.  */
name|int
name|was_const_elts
init|=
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|itype
init|=
name|init
condition|?
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|was_const_elts
condition|)
block|{
name|tree
name|atype
init|=
name|build_cplus_array_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|init
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|)
condition|)
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|atype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|atype
expr_stmt|;
block|}
name|expand_vec_init
argument_list|(
name|exp
argument_list|,
name|exp
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|init
argument_list|,
name|init
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|=
name|was_const
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|itype
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARM_DECL
condition|)
comment|/* just know that we've seen something for this node */
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If initializing from a GNU C CONSTRUCTOR, consider the elts in the      constructor as parameters to an implicit GNU C++ constructor.  */
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|==
name|type
condition|)
name|init
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|expand_aggr_init_1
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|exp
argument_list|,
name|exp
argument_list|,
name|init
argument_list|,
name|alias_this
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|=
name|was_const
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_default_init
parameter_list|(
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|exp
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|,
name|alias_this
parameter_list|,
name|flags
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|true_exp
decl_stmt|,
name|exp
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|int
name|alias_this
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
comment|/* It fails because there may not be a constructor which takes      its own type as the first (or only parameter), but which does      take other types via a conversion.  So, if the thing initializing      the expression is a unit element of type X, first try X(X&),      followed by initialization by X.  If neither of these work      out, then look hard.  */
name|tree
name|rval
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|xxref_init_possible
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|parms
operator|=
name|init
expr_stmt|;
if|if
condition|(
name|parms
condition|)
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
condition|)
block|{
name|rval
operator|=
name|convert_for_initialization
argument_list|(
name|exp
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|rval
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|parms
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|type
argument_list|)
operator|||
name|init
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|xxref_init_possible
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|xxref_init_possible
operator|=
name|LOOKUP_SPECULATIVELY
expr_stmt|;
name|flags
operator|&=
operator|~
name|LOOKUP_COMPLAIN
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|true_exp
operator|==
name|exp
condition|)
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|parms
argument_list|)
expr_stmt|;
else|else
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LOOKUP_HAS_IN_CHARGE
expr_stmt|;
block|}
name|rval
operator|=
name|build_method_call
argument_list|(
name|exp
argument_list|,
name|constructor_name
argument_list|(
name|type
argument_list|)
argument_list|,
name|parms
argument_list|,
name|binfo
argument_list|,
name|flags
operator||
name|xxref_init_possible
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NULL_TREE
operator|&&
name|xxref_init_possible
condition|)
block|{
comment|/* It is an error to implement a default copy constructor if 	 (see ARM 12.8 for details) ... one case being if another 	 copy constructor already exists. */
name|tree
name|init_type
init|=
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|init_type
operator|=
name|TREE_TYPE
argument_list|(
name|init_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|init_type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|init_type
argument_list|)
operator|&&
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|type
argument_list|,
name|init_type
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|expand_aggr_vbase_init
argument_list|(
name|binfo
argument_list|,
name|exp
argument_list|,
name|addr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_vbase_vtables_init
argument_list|(
name|binfo
argument_list|,
name|binfo
argument_list|,
name|exp
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|exp
argument_list|,
name|INIT_EXPR
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|rval
operator|=
name|build_method_call
argument_list|(
name|exp
argument_list|,
name|constructor_name
argument_list|(
name|type
argument_list|)
argument_list|,
name|parms
argument_list|,
name|binfo
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* Private, protected, or otherwise unavailable.  */
if|if
condition|(
name|rval
operator|==
name|error_mark_node
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
operator|)
condition|)
name|error_with_aggr_type
argument_list|(
name|binfo
argument_list|,
literal|"in base initialization for class `%s'"
argument_list|)
expr_stmt|;
comment|/* A valid initialization using constructor.  */
elseif|else
if|if
condition|(
name|rval
operator|!=
name|error_mark_node
operator|&&
name|rval
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* p. 222: if the base class assigns to `this', then that 	 value is used in the derived class.  */
if|if
condition|(
operator|(
name|flag_this_is_variable
operator|&
literal|1
operator|)
operator|&&
name|alias_this
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|current_class_decl
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|current_class_decl
argument_list|,
name|rval
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_expr_stmt
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parms
operator|&&
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* If we are initializing one aggregate value 	 from another, and though there are constructors, 	 and none accept the initializer, just do a bitwise 	 copy.  	 The above sounds wrong, ``If a class has any copy 	 constructor defined, the default copy constructor will 	 not be generated.'' 12.8 Copying Class Objects  (mrs)  	 @@ This should reject initializer which a constructor 	 @@ rejected on visibility gounds, but there is 	 @@ no way right now to recognize that case with 	 @@ just `error_mark_node'.  */
name|tree
name|itype
decl_stmt|;
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|itype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|init
operator|=
name|convert_from_reference
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
name|itype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|itype
argument_list|)
expr_stmt|;
comment|/* This is currently how the default X(X&) constructor 	 is implemented.  */
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|,
name|itype
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|warning ("bitwise copy in initialization of type `%s'", 		   TYPE_NAME_STRING (type));
endif|#
directive|endif
name|rval
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error_with_aggr_type
argument_list|(
name|binfo
argument_list|,
literal|"in base initialization for class `%s',"
argument_list|)
expr_stmt|;
name|error_with_aggr_type
argument_list|(
name|type
argument_list|,
literal|"invalid initializer to constructor for type `%s'"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|init
operator|==
name|NULL_TREE
condition|)
name|my_friendly_assert
argument_list|(
name|parms
operator|==
name|NULL_TREE
argument_list|,
literal|210
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms
operator|==
name|NULL_TREE
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|error_with_aggr_type
argument_list|(
name|binfo
argument_list|,
literal|"virtual baseclass `%s' does not have default initializer"
argument_list|)
expr_stmt|;
else|else
block|{
name|error_with_aggr_type
argument_list|(
name|binfo
argument_list|,
literal|"in base initialization for class `%s',"
argument_list|)
expr_stmt|;
comment|/* This will make an error message for us.  */
name|build_method_call
argument_list|(
name|exp
argument_list|,
name|constructor_name
argument_list|(
name|type
argument_list|)
argument_list|,
name|parms
argument_list|,
name|binfo
argument_list|,
operator|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|?
name|LOOKUP_NORMAL
operator||
name|LOOKUP_HAS_IN_CHARGE
else|:
name|LOOKUP_NORMAL
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Constructor has been called, but vtables may be for TYPE      rather than for FOR_TYPE.  */
block|}
end_function

begin_comment
comment|/* This function is responsible for initializing EXP with INIT    (if any).     BINFO is the binfo of the type for who we are performing the    initialization.  For example, if W is a virtual base class of A and B,    and C : A, B.    If we are initializing B, then W must contain B's W vtable, whereas    were we initializing C, W must contain C's W vtable.     TRUE_EXP is nonzero if it is the true expression being initialized.    In this case, it may be EXP, or may just contain EXP.  The reason we    need this is because if EXP is a base element of TRUE_EXP, we    don't necessarily know by looking at EXP where its virtual    baseclass fields should really be pointing.  But we do know    from TRUE_EXP.  In constructors, we don't know anything about    the value being initialized.     ALIAS_THIS serves the same purpose it serves for expand_aggr_init.     FLAGS is just passes to `build_method_call'.  See that function for    its description.  */
end_comment

begin_function
specifier|static
name|void
name|expand_aggr_init_1
parameter_list|(
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|exp
parameter_list|,
name|init
parameter_list|,
name|alias_this
parameter_list|,
name|flags
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|true_exp
decl_stmt|,
name|exp
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|int
name|alias_this
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|init_type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|init
operator|!=
name|error_mark_node
operator|&&
name|type
operator|!=
name|error_mark_node
argument_list|,
literal|211
argument_list|)
expr_stmt|;
comment|/* Use a function returning the desired type to initialize EXP for us.      If the function is a constructor, and its first argument is      NULL_TREE, know that it was meant for us--just slide exp on      in and expand the constructor.  Constructors now come      as TARGET_EXPRs.  */
if|if
condition|(
name|init
condition|)
block|{
name|tree
name|init_list
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|init_list
operator|=
name|init
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
name|init_type
operator|=
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init_type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|#
directive|if
literal|0
comment|/* These lines are found troublesome 5/11/89.  */
block|if (TREE_CODE (init_type) == REFERENCE_TYPE) 	    init_type = TREE_TYPE (init_type);
endif|#
directive|endif
comment|/* This happens when we use C++'s functional cast notation. 	     If the types match, then just use the TARGET_EXPR 	     directly.  Otherwise, we need to create the initializer 	     separately from the object being initialized.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
if|if
condition|(
name|init_type
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|RESULT_DECL
condition|)
comment|/* Unify the initialization targets.  */
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|else
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|init_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|TREE_RAISES (init) = ??
endif|#
directive|endif
if|if
condition|(
name|init_list
condition|)
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
operator|=
name|init
expr_stmt|;
block|}
block|}
if|if
condition|(
name|init_type
operator|==
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CALL_EXPR
if|#
directive|if
literal|0
comment|/* It is legal to directly initialize from a CALL_EXPR 		 without going through X(X&), apparently.  */
condition|&& ! TYPE_GETS_INIT_REF (type)
endif|#
directive|endif
condition|)
block|{
comment|/* A CALL_EXPR is a legitimate form of initialization, so 		 we should not print this warning message.  */
if|#
directive|if
literal|0
comment|/* Should have gone away due to 5/11/89 change.  */
block|if (TREE_CODE (TREE_TYPE (init)) == REFERENCE_TYPE) 		init = convert_from_reference (init);
endif|#
directive|endif
name|expand_assignment
argument_list|(
name|exp
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
comment|/* Failing this assertion means that the return value 		     from receives multiple initializations.  */
name|my_friendly_assert
argument_list|(
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|==
name|error_mark_node
argument_list|,
literal|212
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|=
name|init
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|init_type
operator|==
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
comment|/* Push value to be initialized into the cond, where possible. 	         Avoid spurious warning messages when initializing the 		 result of this function.  */
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
operator|=
name|build_modify_expr
argument_list|(
name|exp
argument_list|,
name|INIT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|2
argument_list|)
operator|=
name|build_modify_expr
argument_list|(
name|exp
argument_list|,
name|INIT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|=
name|init
expr_stmt|;
name|expand_expr
argument_list|(
name|init
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* We did not know what we were initializing before.  Now we do.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
name|tree
name|tmp
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|integer_zero_node
condition|)
block|{
comment|/* In order for this to work for RESULT_DECLs, if their 		 type has a constructor, then they must be BLKmode 		 so that they will be meaningfully addressable.  */
name|tree
name|arg
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|TREE_RAISES (init) = ??
endif|#
directive|endif
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias_this
condition|)
block|{
name|expand_assignment
argument_list|(
name|current_function_decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp
operator|==
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"return value from function receives multiple initializations"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|=
name|init
expr_stmt|;
block|}
name|expand_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Handle this case: when calling a constructor: xyzzy foo(bar); 	 which really means:  xyzzy foo = bar; Ugh!  	 We can also be called with an initializer for an object 	 which has virtual functions, but no constructors.  In that 	 case, we perform the assignment first, then initialize 	 the virtual function table pointer fields.  */
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|init_list
operator|&&
name|TREE_CHAIN
argument_list|(
name|init_list
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"initializer list being treated as compound expression"
argument_list|)
expr_stmt|;
name|init
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|build_compound_expr
argument_list|(
name|init_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
operator|&&
name|flag_pic
operator|==
literal|0
condition|)
name|store_init_value
argument_list|(
name|exp
argument_list|,
name|init
argument_list|)
expr_stmt|;
else|else
name|expand_assignment
argument_list|(
name|exp
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|type
argument_list|)
condition|)
name|expand_recursive_init
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|exp
argument_list|,
name|init
argument_list|,
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|type
argument_list|)
argument_list|,
name|alias_this
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* See whether we can go through a type conversion operator. 	 This wins over going through a non-existent constructor.  If 	 there is a constructor, it is ambiguous.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
name|tree
name|ttype
init|=
name|TREE_CODE
argument_list|(
name|init_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|init_type
argument_list|)
else|:
name|init_type
decl_stmt|;
if|if
condition|(
name|ttype
operator|!=
name|type
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ttype
argument_list|)
condition|)
block|{
name|tree
name|rval
init|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
comment|/* See if there is a constructor for``type'' that takes a 		     ``ttype''-typed object. */
name|tree
name|parms
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
decl_stmt|;
name|tree
name|as_cons
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|as_cons
operator|=
name|build_method_call
argument_list|(
name|exp
argument_list|,
name|constructor_name
argument_list|(
name|type
argument_list|)
argument_list|,
name|parms
argument_list|,
name|binfo
argument_list|,
name|LOOKUP_SPECULATIVELY
operator||
name|LOOKUP_NO_CONVERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|as_cons
operator|!=
name|NULL_TREE
operator|&&
name|as_cons
operator|!=
name|error_mark_node
condition|)
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* ANSI C++ June 5 1992 WP 12.3.2.6.1 */
name|error
argument_list|(
literal|"ambiguity between conversion to `%s' and constructor"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_assignment
argument_list|(
name|exp
argument_list|,
name|rval
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
comment|/* Handle default copy constructors here, does not matter if there is      a constructor or not.  */
if|if
condition|(
name|type
operator|==
name|init_type
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|expand_default_init
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|exp
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|alias_this
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Not sure why this is here... */
elseif|else
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|expand_default_init
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|exp
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|alias_this
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|expand_vec_init
argument_list|(
name|exp
argument_list|,
name|exp
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|sorry
argument_list|(
literal|"arrays of objects with virtual functions but no constructors"
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_recursive_init
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|exp
argument_list|,
name|init
argument_list|,
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|type
argument_list|)
argument_list|,
name|alias_this
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A pointer which holds the initializer.  First call to    expand_aggr_init gets this value pointed to, and sets it to init_null.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|init_ptr
decl_stmt|,
name|init_null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subroutine of expand_recursive_init:     ADDR is the address of the expression being initialized.    INIT_LIST is the cons-list of initializations to be performed.    ALIAS_THIS is its same, lovable self.  */
end_comment

begin_function
specifier|static
name|void
name|expand_recursive_init_1
parameter_list|(
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|addr
parameter_list|,
name|init_list
parameter_list|,
name|alias_this
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|true_exp
decl_stmt|,
name|addr
decl_stmt|;
name|tree
name|init_list
decl_stmt|;
name|int
name|alias_this
decl_stmt|;
block|{
while|while
condition|(
name|init_list
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|init_list
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|init_list
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|tree
name|member
init|=
name|TREE_PURPOSE
argument_list|(
name|init_list
argument_list|)
decl_stmt|;
name|tree
name|subexp
init|=
name|build_indirect_ref
argument_list|(
name|convert_pointer_to
argument_list|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|member_base
init|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|,
name|subexp
argument_list|,
name|member
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
condition|)
name|expand_aggr_init
argument_list|(
name|member_base
argument_list|,
name|DECL_INITIAL
argument_list|(
name|member
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
condition|)
block|{
name|member_base
operator|=
name|save_expr
argument_list|(
name|default_conversion
argument_list|(
name|member_base
argument_list|)
argument_list|)
expr_stmt|;
name|expand_vec_init
argument_list|(
name|member
argument_list|,
name|member_base
argument_list|,
name|array_type_nelts
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
argument_list|,
name|DECL_INITIAL
argument_list|(
name|member
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|member_base
argument_list|,
name|INIT_EXPR
argument_list|,
name|DECL_INITIAL
argument_list|(
name|member
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|init_list
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|expand_recursive_init_1
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|addr
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|init_list
argument_list|)
argument_list|,
name|alias_this
argument_list|)
expr_stmt|;
name|expand_recursive_init_1
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|addr
argument_list|,
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
argument_list|,
name|alias_this
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|init_list
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
comment|/* Only initialize the virtual function tables if we 		 are initializing the ultimate users of those vtables.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
condition|)
block|{
comment|/* We have to ensure that the second argment to 		     build_virtual_init is in binfo's hierarchy.  */
name|expand_expr_stmt
argument_list|(
name|build_virtual_init
argument_list|(
name|binfo
argument_list|,
name|get_binfo
argument_list|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
argument_list|,
name|binfo
argument_list|,
literal|0
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
operator|==
name|binfo
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
name|expand_expr_stmt
argument_list|(
name|build_vbase_vtables_init
argument_list|(
name|binfo
argument_list|,
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|49
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
name|tree
name|subexp
init|=
name|build_indirect_ref
argument_list|(
name|convert_pointer_to
argument_list|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|expand_aggr_init_1
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|subexp
argument_list|,
operator|*
name|init_ptr
argument_list|,
name|alias_this
operator|&&
name|BINFO_OFFSET_ZEROP
argument_list|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
argument_list|)
argument_list|,
name|LOOKUP_PROTECTED_OK
operator||
name|LOOKUP_COMPLAIN
argument_list|)
expr_stmt|;
comment|/* INIT_PTR is used up.  */
name|init_ptr
operator|=
operator|&
name|init_null
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|init_list
operator|=
name|TREE_CHAIN
argument_list|(
name|init_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize EXP with INIT.  Type EXP does not have a constructor,    but it has a baseclass with a constructor or a virtual function    table which needs initializing.     INIT_LIST is a cons-list describing what parts of EXP actually    need to be initialized.  INIT is given to the *unique*, first    constructor within INIT_LIST.  If there are multiple first    constructors, such as with multiple inheritance, INIT must    be zero or an ambiguity error is reported.     ALIAS_THIS is passed from `expand_aggr_init'.  See comments    there.  */
end_comment

begin_function
specifier|static
name|void
name|expand_recursive_init
parameter_list|(
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|exp
parameter_list|,
name|init
parameter_list|,
name|init_list
parameter_list|,
name|alias_this
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|true_exp
decl_stmt|,
name|exp
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|init_list
decl_stmt|;
name|int
name|alias_this
decl_stmt|;
block|{
name|tree
modifier|*
name|old_init_ptr
init|=
name|init_ptr
decl_stmt|;
name|tree
name|addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|init_ptr
operator|=
operator|&
name|init
expr_stmt|;
if|if
condition|(
name|true_exp
operator|==
name|exp
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|expand_aggr_vbase_init
argument_list|(
name|binfo
argument_list|,
name|exp
argument_list|,
name|addr
argument_list|,
name|init_list
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_vbase_vtables_init
argument_list|(
name|binfo
argument_list|,
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_recursive_init_1
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|addr
argument_list|,
name|init_list
argument_list|,
name|alias_this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|init_ptr
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|error_with_aggr_type
argument_list|(
name|type
argument_list|,
literal|"unexpected argument to constructor `%s'"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unexpected argument to constructor"
argument_list|)
expr_stmt|;
block|}
name|init_ptr
operator|=
name|old_init_ptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an error if NAME is not the name of a user-defined,    aggregate type.  If OR_ELSE is nonzero, give an error message.  */
end_comment

begin_function
name|int
name|is_aggr_typedef
parameter_list|(
name|name
parameter_list|,
name|or_else
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|or_else
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|or_else
condition|)
name|error
argument_list|(
literal|"`%s' fails to be an aggregate typedef"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|or_else
condition|)
name|error
argument_list|(
literal|"type `%s' is of non-aggregate type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This code could just as well go in `cp-class.c', but is placed here for    modularity.  */
end_comment

begin_comment
comment|/* For an expression of the form CNAME :: NAME (PARMLIST), build    the appropriate function call.  */
end_comment

begin_function
name|tree
name|build_member_call
parameter_list|(
name|cname
parameter_list|,
name|name
parameter_list|,
name|parmlist
parameter_list|)
name|tree
name|cname
decl_stmt|,
name|name
decl_stmt|,
name|parmlist
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|method_name
init|=
name|name
decl_stmt|;
name|int
name|dtor
init|=
literal|0
decl_stmt|;
name|int
name|dont_use_this
init|=
literal|0
decl_stmt|;
name|tree
name|basetype_path
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|method_name
operator|=
name|TREE_OPERAND
argument_list|(
name|method_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtor
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|cname
operator|=
name|resolve_scope_to_name
argument_list|(
name|NULL_TREE
argument_list|,
name|cname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cname
operator|==
name|NULL_TREE
operator|||
operator|!
name|is_aggr_typedef
argument_list|(
name|cname
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* An operator we did not like.  */
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|dtor
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"type `%s' does not have a destructor"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"destructor specification error"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
expr_stmt|;
comment|/* No object?  Then just fake one up, and let build_method_call      figure out what to do.  */
if|if
condition|(
name|current_class_type
operator|==
literal|0
operator|||
name|get_base_distance
argument_list|(
name|type
argument_list|,
name|current_class_type
argument_list|,
literal|0
argument_list|,
operator|&
name|basetype_path
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dont_use_this
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dont_use_this
condition|)
block|{
name|basetype_path
operator|=
name|NULL_TREE
expr_stmt|;
name|decl
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_class_decl
operator|==
literal|0
condition|)
block|{
name|dont_use_this
operator|=
literal|1
expr_stmt|;
name|decl
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|current_class_decl
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|type
condition|)
name|decl
operator|=
name|convert
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|method_name
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|method_name
argument_list|,
name|parmlist
argument_list|,
name|basetype_path
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
operator|(
name|t
operator|=
name|lookup_field
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|dont_use_this
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of non-static field `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|decl
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|decl
operator|=
name|t
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"invalid use of member `%s::%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cname
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|decl
argument_list|,
name|parmlist
argument_list|,
name|NULL_TREE
argument_list|)
return|;
return|return
name|build_function_call
argument_list|(
name|decl
argument_list|,
name|parmlist
argument_list|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|err_name
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|op_name
init|=
name|operator_name_string
argument_list|(
name|method_name
argument_list|)
decl_stmt|;
name|err_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|13
operator|+
name|strlen
argument_list|(
name|op_name
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|err_name
argument_list|,
literal|"operator %s"
argument_list|,
name|op_name
argument_list|)
expr_stmt|;
block|}
else|else
name|err_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|51
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"no method `%s::%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cname
argument_list|)
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* Build a reference to a member of an aggregate.  This is not a    C++ `&', but really something which can have its address taken,    and then act as a pointer to member, for example CNAME :: FIELD    can have its address taken by saying& CNAME :: FIELD.     @@ Prints out lousy diagnostics for operator<typename>    @@ fields.     @@ This function should be rewritten and placed in cp-search.c.  */
end_comment

begin_function
name|tree
name|build_offset_ref
parameter_list|(
name|cname
parameter_list|,
name|name
parameter_list|)
name|tree
name|cname
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|,
name|fnfields
decl_stmt|,
name|fields
decl_stmt|,
name|t
init|=
name|error_mark_node
decl_stmt|;
name|tree
name|basetypes
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|dtor
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|cname
operator|=
name|resolve_scope_to_name
argument_list|(
name|NULL_TREE
argument_list|,
name|cname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cname
operator|==
name|NULL_TREE
operator|||
operator|!
name|is_aggr_typedef
argument_list|(
name|cname
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|dtor
operator|=
literal|1
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|type
argument_list|,
literal|"incomplete type `%s' does not have member `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
name|t
argument_list|,
literal|"member `%s' is just a type declaration"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|sorry
argument_list|(
literal|"use of member in incomplete aggregate type"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|sorry
argument_list|(
literal|"use of member function in incomplete aggregate type"
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|52
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_EXPR
condition|)
comment|/* Pass a TYPE_DECL to build_component_type_expr.  */
return|return
name|build_component_type_expr
argument_list|(
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|cname
argument_list|)
argument_list|)
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
return|;
name|fnfields
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fields
operator|=
name|lookup_field
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|==
name|error_mark_node
operator|||
name|fnfields
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|current_class_type
operator|==
literal|0
operator|||
name|get_base_distance
argument_list|(
name|type
argument_list|,
name|current_class_type
argument_list|,
literal|0
argument_list|,
operator|&
name|basetypes
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|basetypes
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_class_decl
operator|==
literal|0
condition|)
name|decl
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|C_C_D
expr_stmt|;
comment|/* A lot of this logic is now handled in lookup_field and      lookup_fnfield. */
if|if
condition|(
name|fnfields
condition|)
block|{
name|basetypes
operator|=
name|TREE_PURPOSE
argument_list|(
name|fnfields
argument_list|)
expr_stmt|;
comment|/* Go from the TREE_BASELINK to the member function info.  */
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|fnfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
condition|)
block|{
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
argument_list|)
operator|==
name|DECL_FIELD_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"ambiguous member reference: member `%s' defined as both field and function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
argument_list|)
argument_list|,
name|DECL_FIELD_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|fields
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"ambiguous member reference: member `%s' derives from distinct classes in multiple inheritance lattice"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|t
operator|==
name|TREE_VALUE
argument_list|(
name|fnfields
argument_list|)
condition|)
block|{
specifier|extern
name|int
name|flag_save_memoized_contexts
decl_stmt|;
comment|/* This does not handle visibility checking yet.  */
if|if
condition|(
name|DECL_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|dtor
condition|)
block|{
name|enum
name|visibility_type
name|visibility
decl_stmt|;
comment|/* unique functions are handled easily.  */
name|unique
label|:
name|visibility
operator|=
name|compute_visibility
argument_list|(
name|basetypes
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|visibility
operator|==
name|visibility_protected
condition|)
block|{
name|error_with_decl
argument_list|(
name|t
argument_list|,
literal|"member function `%s' is protected"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"in this context"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
block|{
name|error_with_decl
argument_list|(
name|t
argument_list|,
literal|"member function `%s' is private"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"in this context"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|assemble_external
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
return|;
block|}
comment|/* overloaded functions may need more work.  */
if|if
condition|(
name|cname
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_CHAIN
argument_list|(
name|DECL_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|t
operator|=
name|DECL_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
goto|goto
name|unique
goto|;
block|}
block|}
comment|/* FNFIELDS is most likely allocated on the search_obstack, 	     which will go away after this class scope.  If we need 	     to save this value for later (either for memoization 	     or for use as an initializer for a static variable), then 	     do so here.  	     ??? The smart thing to do for the case of saving initializers 	     is to resolve them before we're done with this scope.  */
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|fnfields
argument_list|)
operator|&&
operator|(
operator|(
name|flag_save_memoized_contexts
operator|&&
name|global_bindings_p
argument_list|()
operator|)
operator|||
operator|!
name|allocation_temporary_p
argument_list|()
operator|)
condition|)
name|fnfields
operator|=
name|copy_list
argument_list|(
name|fnfields
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_tree_list
argument_list|(
name|error_mark_node
argument_list|,
name|fnfields
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|build_offset_type
argument_list|(
name|type
argument_list|,
name|unknown_type_node
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
comment|/* Now that we know we are looking for a field, see if we      have access to that field.  Lookup_field will give us the      error message.  */
name|t
operator|=
name|lookup_field
argument_list|(
name|basetypes
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
block|{
name|char
modifier|*
name|print_name
decl_stmt|,
modifier|*
name|non_operator
init|=
literal|"<"
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TYPE_EXPR
index|]
condition|)
block|{
name|error
argument_list|(
literal|"type conversion operator not a member of type `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cname
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
operator|)
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
name|print_name
operator|=
name|operator_name_string
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|print_name
operator|=
name|non_operator
expr_stmt|;
comment|/* First character of "<invalid operator>".  */
if|if
condition|(
name|print_name
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
name|error
argument_list|(
literal|"field `%s' is not a member of type `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"operator `%s' is not a member of type `%s'"
argument_list|,
name|print_name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cname
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
name|t
argument_list|,
literal|"member `%s' is just a type declaration"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* static class members and class-specific enum      values can be returned without further ado.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|assemble_external
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* static class functions too.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|my_friendly_abort
argument_list|(
literal|53
argument_list|)
expr_stmt|;
comment|/* In member functions, the form `cname::name' is no longer      equivalent to `this->cname::name'.  */
return|return
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|build_offset_type
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given an object EXP and a member function reference MEMBER,    return the address of the actual member function.  */
end_comment

begin_function
name|tree
name|get_member_function
parameter_list|(
name|exp_addr_ptr
parameter_list|,
name|exp
parameter_list|,
name|member
parameter_list|)
name|tree
modifier|*
name|exp_addr_ptr
decl_stmt|;
name|tree
name|exp
decl_stmt|,
name|member
decl_stmt|;
block|{
name|tree
name|ctype
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|function
init|=
name|save_expr
argument_list|(
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|member
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|ctype
argument_list|)
operator|||
operator|(
name|flag_all_virtual
operator|==
literal|1
operator|&&
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|ctype
argument_list|)
operator|)
condition|)
block|{
name|tree
name|e0
decl_stmt|,
name|e1
decl_stmt|,
name|e3
decl_stmt|;
name|tree
name|exp_addr
decl_stmt|;
comment|/* Save away the unadulterated `this' pointer.  */
name|exp_addr
operator|=
name|save_expr
argument_list|(
operator|*
name|exp_addr_ptr
argument_list|)
expr_stmt|;
comment|/* Cast function to signed integer.  */
name|e0
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|function
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VTABLE_USES_MASK
comment|/* If we are willing to limit the number of 	 virtual functions a class may have to some 	 *small* number, then if, for a function address, 	 we are passed some small number, we know that 	 it is a virtual function index, and work from there.  */
name|e1
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|e0
argument_list|,
name|vtbl_mask
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* There is a hack here that takes advantage of 	 twos complement arithmetic, and the fact that 	 there are more than one UNITS to the WORD. 	 If the high bit is set for the `function', 	 then we pretend it is a virtual function, 	 and the array indexing will knock this bit 	 out the top, leaving a valid index.  */
if|if
condition|(
name|UNITS_PER_WORD
operator|<=
literal|1
condition|)
name|my_friendly_abort
argument_list|(
literal|54
argument_list|)
expr_stmt|;
name|e1
operator|=
name|build
argument_list|(
name|GT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|e0
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|e1
operator|=
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|exp_addr
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|e1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|save_expr
argument_list|(
name|e1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
operator|*
name|exp_addr_ptr
argument_list|)
condition|)
block|{
name|exp
operator|=
name|build_indirect_ref
argument_list|(
name|exp_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|exp_addr_ptr
operator|=
name|exp_addr
expr_stmt|;
block|}
comment|/* This is really hairy: if the function pointer is a pointer 	 to a non-virtual member function, then we can't go mucking 	 with the `this' pointer (any more than we already have to 	 this point).  If it is a pointer to a virtual member function, 	 then we have to adjust the `this' pointer according to 	 what the virtual function table tells us.  */
name|e3
operator|=
name|build_vfn_ref
argument_list|(
name|exp_addr_ptr
argument_list|,
name|exp
argument_list|,
name|e0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|e3
operator|!=
name|error_mark_node
argument_list|,
literal|213
argument_list|)
expr_stmt|;
comment|/* Change this pointer type from `void *' to the 	 type it is really supposed to be.  */
name|TREE_TYPE
argument_list|(
name|e3
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* If non-virtual, use what we had originally.  Otherwise, 	 use the value we get from the virtual function table.  */
operator|*
name|exp_addr_ptr
operator|=
name|build_conditional_expr
argument_list|(
name|e1
argument_list|,
name|exp_addr
argument_list|,
operator|*
name|exp_addr_ptr
argument_list|)
expr_stmt|;
name|function
operator|=
name|build_conditional_expr
argument_list|(
name|e1
argument_list|,
name|function
argument_list|,
name|e3
argument_list|)
expr_stmt|;
block|}
return|return
name|build_indirect_ref
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If a OFFSET_REF made it through to here, then it did    not have its address taken.  */
end_comment

begin_function
name|tree
name|resolve_offset_ref
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|base
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|tree
name|basetype
decl_stmt|,
name|addr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_LIST
condition|)
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|OFFSET_REF
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
argument_list|,
literal|214
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|error
argument_list|(
literal|"object missing in use of pointer-to-member construct"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|member
operator|=
name|exp
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|base
operator|=
name|C_C_D
expr_stmt|;
block|}
else|else
block|{
name|member
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* These were static members.  */
if|if
condition|(
name|mark_addressable
argument_list|(
name|member
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
return|return
name|member
return|;
block|}
comment|/* Syntax error can cause a member which should      have been seen as static to be grok'd as non-static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|C_C_D
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|member
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|member
argument_list|,
literal|"member `%s' is non-static in static member function context"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|member
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
comment|/* The first case is really just a reference to a member of `this'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|(
name|base
operator|==
name|C_C_D
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
operator|)
operator|)
condition|)
block|{
name|tree
name|basetype_path
decl_stmt|;
name|enum
name|visibility_type
name|visibility
decl_stmt|;
name|basetype
operator|=
name|DECL_CONTEXT
argument_list|(
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_base_distance
argument_list|(
name|basetype
argument_list|,
name|current_class_type
argument_list|,
literal|0
argument_list|,
operator|&
name|basetype_path
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error_not_base_type
argument_list|(
name|basetype
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
name|visibility
operator|=
name|compute_visibility
argument_list|(
name|basetype_path
argument_list|,
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|visibility
operator|==
name|visibility_public
condition|)
return|return
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|,
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|member
argument_list|)
return|;
if|if
condition|(
name|visibility
operator|==
name|visibility_protected
condition|)
block|{
name|error_with_decl
argument_list|(
name|member
argument_list|,
literal|"member `%s' is protected"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"in this context"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
block|{
name|error_with_decl
argument_list|(
name|member
argument_list|,
literal|"member `%s' is private"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"in this context"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|my_friendly_abort
argument_list|(
literal|55
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a reference to a member function, then return      the address of the member function (which may involve going      through the object's vtable), otherwise, return an expression      for the dereferenced pointer-to-member construct.  */
name|addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|basetype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|get_member_function
argument_list|(
operator|&
name|addr
argument_list|,
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|member
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|basetype
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|member
operator|=
name|convert
argument_list|(
name|ptr_type_node
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|member
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|addr
argument_list|,
name|member
argument_list|)
argument_list|)
return|;
block|}
name|my_friendly_abort
argument_list|(
literal|56
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return either DECL or its known constant value (if it has one).  */
end_comment

begin_function
name|tree
name|decl_constant_value
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
if|#
directive|if
literal|0
comment|/* These may be necessary for C, but they break C++.  */
expr|! TREE_PUBLIC (decl)
comment|/* Don't change a variable array bound or initial value to a constant 	 in a place where a variable is invalid.  */
expr|&& ! pedantic
endif|#
directive|endif
comment|/* 0 */
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
comment|/* This is invalid if initial value is not constant. 	 If it has either a function call, a memory reference, 	 or a variable, then re-evaluating it could give different results.  */
operator|&&
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
comment|/* Check for cases where this is sub-optimal, even though valid.  */
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|CONSTRUCTOR
if|#
directive|if
literal|0
comment|/* We must allow this to work outside of functions so that 	 static constants can be used for array sizes.  */
condition|&& current_function_decl != 0&& DECL_MODE (decl) != BLKmode
endif|#
directive|endif
condition|)
return|return
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
return|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Friend handling routines.  */
end_comment

begin_comment
comment|/* Friend data structures:     Friend lists come from TYPE_DECL nodes.  Since all aggregate    types are automatically typedef'd, these node are guaranteed    to exist.     The TREE_PURPOSE of a friend list is the name of the friend,    and its TREE_VALUE is another list.     The TREE_PURPOSE of that list is a type, which allows    all functions of a given type to be friends.    The TREE_VALUE of that list is an individual function    which is a friend.     Non-member friends will match only by their DECL.  Their    member type is NULL_TREE, while the type of the inner    list will either be of aggregate type or error_mark_node.  */
end_comment

begin_comment
comment|/* Tell if this function specified by DECL    can be a friend of type TYPE.    Return nonzero if friend, zero otherwise.     DECL can be zero if we are calling a constructor or accessing a    member in global scope.  */
end_comment

begin_function
name|int
name|is_friend
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|typedecl
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|ctype
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|tree
name|name
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
name|ctype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
name|list
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
condition|)
return|return
literal|1
return|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
name|list
operator|=
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|tree
name|friends
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
while|while
condition|(
name|friends
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|TREE_PURPOSE
argument_list|(
name|friends
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|name
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a new friend to the friends of the aggregate type TYPE.    DECL is the FUNCTION_DECL of the friend being added.  */
end_comment

begin_function
specifier|static
name|void
name|add_friend
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|typedecl
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|list
init|=
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|ctype
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|?
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
else|:
name|error_mark_node
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|tree
name|friends
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
while|while
condition|(
name|friends
condition|)
block|{
if|if
condition|(
name|decl
operator|==
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' is already a friend of class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|typedecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
expr_stmt|;
block|}
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|error_mark_node
argument_list|,
name|decl
argument_list|)
argument_list|,
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
condition|)
block|{
name|tree
name|parmtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parmtypes
operator|&&
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
condition|)
block|{
name|tree
name|parmtype
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
condition|)
block|{
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_GETS_ASSIGN_REF
argument_list|(
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Declare that every member function NAME in FRIEND_TYPE    (which may be NULL_TREE) is a friend of type TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|add_friends
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|friend_type
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|,
name|friend_type
decl_stmt|;
block|{
name|tree
name|typedecl
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|list
init|=
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|tree
name|friends
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
while|while
condition|(
name|friends
operator|&&
name|TREE_PURPOSE
argument_list|(
name|friends
argument_list|)
operator|!=
name|friend_type
condition|)
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
expr_stmt|;
if|if
condition|(
name|friends
condition|)
if|if
condition|(
name|friend_type
condition|)
name|warning
argument_list|(
literal|"method `%s::%s' is already a friend of class"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|friend_type
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"function `%s' is already a friend of class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|typedecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|friend_type
argument_list|,
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|build_tree_list
argument_list|(
name|friend_type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|sorry
argument_list|(
literal|"declaring \"friend operator =\" will not find \"operator = (X&)\" if it exists"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set up a cross reference so that type TYPE will    make member function CTYPE::DECL a friend when CTYPE    is finally defined.  */
end_comment

begin_function
name|void
name|xref_friend
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|,
name|ctype
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|,
name|ctype
decl_stmt|;
block|{
name|tree
name|typedecl
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|friend_decl
init|=
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
name|tree
name|t
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ctype
argument_list|,
name|DECL_UNDEFINED_FRIENDS
argument_list|(
name|typedecl
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_UNDEFINED_FRIENDS
argument_list|(
name|typedecl
argument_list|)
operator|=
name|t
expr_stmt|;
name|SET_DECL_WAITING_FRIENDS
argument_list|(
name|friend_decl
argument_list|,
name|tree_cons
argument_list|(
name|type
argument_list|,
name|t
argument_list|,
name|DECL_WAITING_FRIENDS
argument_list|(
name|friend_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_WAITING_FRIENDS
argument_list|(
name|friend_decl
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up a cross reference so that functions with name NAME and    type CTYPE know that they are friends of TYPE.  */
end_comment

begin_function
name|void
name|xref_friends
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|ctype
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|,
name|ctype
decl_stmt|;
block|{
name|tree
name|typedecl
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|friend_decl
init|=
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
name|tree
name|t
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ctype
argument_list|,
name|DECL_UNDEFINED_FRIENDS
argument_list|(
name|typedecl
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_UNDEFINED_FRIENDS
argument_list|(
name|typedecl
argument_list|)
operator|=
name|t
expr_stmt|;
name|SET_DECL_WAITING_FRIENDS
argument_list|(
name|friend_decl
argument_list|,
name|tree_cons
argument_list|(
name|type
argument_list|,
name|t
argument_list|,
name|DECL_WAITING_FRIENDS
argument_list|(
name|friend_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_WAITING_FRIENDS
argument_list|(
name|friend_decl
argument_list|)
argument_list|)
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make FRIEND_TYPE a friend class to TYPE.  If FRIEND_TYPE has already    been defined, we make all of its member functions friends of    TYPE.  If not, we make it a pending friend, which can later be added    when its definition is seen.  If a type is defined, then its TYPE_DECL's    DECL_UNDEFINED_FRIENDS contains a (possibly empty) list of friend    classes that are not defined.  If a type has not yet been defined,    then the DECL_WAITING_FRIENDS contains a list of types    waiting to make it their friend.  Note that these two can both    be in use at the same time!  */
end_comment

begin_function
name|void
name|make_friend_class
parameter_list|(
name|type
parameter_list|,
name|friend_type
parameter_list|)
name|tree
name|type
decl_stmt|,
name|friend_type
decl_stmt|;
block|{
name|tree
name|classes
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|friend_type
condition|)
block|{
name|warning
argument_list|(
literal|"class `%s' is implicitly friends with itself"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|GNU_xref_hier
argument_list|(
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|friend_type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|classes
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|classes
operator|&&
name|TREE_VALUE
argument_list|(
name|classes
argument_list|)
operator|!=
name|friend_type
condition|)
name|classes
operator|=
name|TREE_CHAIN
argument_list|(
name|classes
argument_list|)
expr_stmt|;
if|if
condition|(
name|classes
condition|)
name|warning
argument_list|(
literal|"class `%s' is already friends with class `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|TREE_VALUE
argument_list|(
name|classes
argument_list|)
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|friend_type
argument_list|,
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Main friend processor.  This is large, and for modularity purposes,    has been removed from grokdeclarator.  It returns `void_type_node'    to indicate that something happened, though a FIELD_DECL is    not returned.     CTYPE is the class this friend belongs to.     DECLARATOR is the name of the friend.     DECL is the FUNCTION_DECL that the friend is.     In case we are parsing a friend which is part of an inline    definition, we will need to store PARM_DECL chain that comes    with it into the DECL_ARGUMENTS slot of the FUNCTION_DECL.     FLAGS is just used for `grokclassfn'.     QUALS say what special qualifies should apply to the object    pointed to by `this'.  */
end_comment

begin_function
name|tree
name|do_friend
parameter_list|(
name|ctype
parameter_list|,
name|declarator
parameter_list|,
name|decl
parameter_list|,
name|parmdecls
parameter_list|,
name|flags
parameter_list|,
name|quals
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|declarator
decl_stmt|,
name|decl
decl_stmt|,
name|parmdecls
decl_stmt|;
name|enum
name|overload_flags
name|flags
decl_stmt|;
name|tree
name|quals
decl_stmt|;
block|{
comment|/* first, lets find out if what we are making a friend needs overloading */
name|tree
name|previous_decl
decl_stmt|;
name|int
name|was_c_linkage
init|=
literal|0
decl_stmt|;
comment|/* if we find something in scope, let see if it has extern "C" linkage */
comment|/* This code is pretty general and should be ripped out and reused      as a separate function. */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|previous_decl
operator|=
name|lookup_name
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|previous_decl
operator|&&
name|TREE_CODE
argument_list|(
name|previous_decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
do|do
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|previous_decl
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|previous_decl
operator|=
name|TREE_VALUE
argument_list|(
name|previous_decl
argument_list|)
expr_stmt|;
break|break;
block|}
name|previous_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|previous_decl
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|previous_decl
condition|)
do|;
block|}
if|if
condition|(
name|previous_decl
operator|&&
name|TREE_CODE
argument_list|(
name|previous_decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|previous_decl
argument_list|)
condition|)
if|if
condition|(
name|DECL_LANGUAGE
argument_list|(
name|previous_decl
argument_list|)
operator|==
name|lang_c
condition|)
block|{
comment|/* it did, so lets not overload this */
name|was_c_linkage
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ctype
condition|)
block|{
name|tree
name|cname
init|=
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|cname
operator|=
name|DECL_NAME
argument_list|(
name|cname
argument_list|)
expr_stmt|;
comment|/* A method friend.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|NO_SPECIAL
operator|&&
name|ctype
operator|&&
name|declarator
operator|==
name|cname
condition|)
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* This will set up DECL_ARGUMENTS for us.  */
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|cname
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ctype
argument_list|)
operator|!=
literal|0
condition|)
name|check_classfn
argument_list|(
name|ctype
argument_list|,
name|cname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
comment|/* We don't call pushdecl here yet, or ever on this 		     actual FUNCTION_DECL.  We must preserve its TREE_CHAIN 		     until the end.  */
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|xref_friend
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Possibly a bunch of method friends.  */
comment|/* Get the class they belong to.  */
name|tree
name|ctype
init|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
decl_stmt|;
comment|/* This class is defined, use its methods now.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|tree
name|fields
init|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
condition|)
name|add_friends
argument_list|(
name|current_class_type
argument_list|,
name|declarator
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"method `%s' is not a member of class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cname
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|xref_friends
argument_list|(
name|current_class_type
argument_list|,
name|declarator
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|decl
operator|=
name|void_type_node
expr_stmt|;
block|}
block|}
comment|/* never overload C functions */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|declarator
argument_list|)
operator|==
literal|4
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'m'
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|)
operator|||
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|declarator
argument_list|)
operator|>
literal|10
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
operator|+
literal|2
argument_list|,
literal|"builtin_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|was_c_linkage
operator|)
condition|)
block|{
comment|/* raw "main", and builtin functions never gets overloaded, 	 but they can become friends.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
operator|+
literal|10
argument_list|,
literal|"new"
argument_list|)
condition|)
name|TREE_GETS_NEW
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
operator|+
literal|10
argument_list|,
literal|"delete"
argument_list|)
condition|)
name|TREE_GETS_DELETE
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|decl
operator|=
name|void_type_node
expr_stmt|;
block|}
comment|/* A global friend.      @@ or possibly a friend from a base class ?!?  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Friends must all go through the overload machinery, 	 even though they may not technically be overloaded.  	 Note that because classes all wind up being top-level 	 in their scope, their friend wind up in top-level scope as well.  */
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_decl_overload
argument_list|(
name|declarator
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
operator|=
name|parmdecls
expr_stmt|;
comment|/* We can call pushdecl here, because the TREE_CHAIN of this 	 FUNCTION_DECL is not needed for other purposes.  */
name|decl
operator|=
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_OVERLOADED
argument_list|(
name|declarator
argument_list|)
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|declarator
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|declarator
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|error
argument_list|(
literal|"friend `%s' implicitly overloaded"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|declarator
argument_list|)
argument_list|,
literal|"after declaration of non-overloaded `%s'"
argument_list|)
expr_stmt|;
block|}
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_OVERLOADED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_OVERLOADED
argument_list|(
name|declarator
argument_list|)
operator|=
literal|1
expr_stmt|;
name|decl
operator|=
name|push_overloaded_decl
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* @@ Should be able to ingest later definitions of this function 	 before use.  */
name|tree
name|decl
init|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|declarator
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
name|warning
argument_list|(
literal|"implicitly declaring `%s' as struct"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|xref_tag
argument_list|(
name|record_type_node
argument_list|,
name|declarator
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Allow abbreviated declarations of overloaded functions, 	 but not if those functions are really class names.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"`friend %s' archaic, use `friend class %s' instead"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|add_friends
argument_list|(
name|current_class_type
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|make_friend_class
argument_list|(
name|current_class_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|void_type_node
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* TYPE has now been defined.  It may, however, have a number of things    waiting make make it their friend.  We resolve these references    here.  */
end_comment

begin_function
name|void
name|embrace_waiting_friends
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|waiters
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
return|return;
for|for
control|(
name|waiters
operator|=
name|DECL_WAITING_FRIENDS
argument_list|(
name|decl
argument_list|)
init|;
name|waiters
condition|;
name|waiters
operator|=
name|TREE_CHAIN
argument_list|(
name|waiters
argument_list|)
control|)
block|{
name|tree
name|waiter
init|=
name|TREE_PURPOSE
argument_list|(
name|waiters
argument_list|)
decl_stmt|;
name|tree
name|waiter_prev
init|=
name|TREE_VALUE
argument_list|(
name|waiters
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|TREE_TYPE
argument_list|(
name|waiters
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|decl
condition|?
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|?
name|decl
else|:
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|)
else|:
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
comment|/* @@ There may be work to be done since we have not verified 	     @@ consistency between original and friend declarations 	     @@ of the functions waiting to become friends.  */
name|tree
name|field
init|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
condition|)
if|if
condition|(
name|decl
operator|==
name|name
condition|)
name|add_friends
argument_list|(
name|waiter
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|add_friend
argument_list|(
name|waiter
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error_with_file_and_line
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|TYPE_NAME
argument_list|(
name|waiter
argument_list|)
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|TYPE_NAME
argument_list|(
name|waiter
argument_list|)
argument_list|)
argument_list|,
literal|"no method `%s' defined in class `%s' to be friend"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|waiters
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|make_friend_class
argument_list|(
name|type
argument_list|,
name|waiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|waiter_prev
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|waiter_prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|waiter_prev
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|DECL_UNDEFINED_FRIENDS
argument_list|(
name|TYPE_NAME
argument_list|(
name|waiter
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Common subroutines of build_new and build_vec_delete.  */
end_comment

begin_comment
comment|/* Common interface for calling "builtin" functions that are not    really builtin.  */
end_comment

begin_function
name|tree
name|build_builtin_call
parameter_list|(
name|type
parameter_list|,
name|node
parameter_list|,
name|arglist
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|node
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
block|{
name|tree
name|rval
init|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|type
argument_list|,
name|node
argument_list|,
name|arglist
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|assemble_external
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a C++ "new" expression. DECL is either a TREE_LIST    (which needs to go through some sort of groktypename) or it    is the name of the class we are newing. INIT is an initialization value.    It is either an EXPRLIST, an EXPR_NO_COMMAS, or something in braces.    If INIT is void_type_node, it means do *not* call a constructor    for this instance.     For types with constructors, the data returned is initialized    by the appropriate constructor.     Whether the type has a constructor or not, if it has a pointer    to a virtual function table, then that pointer is set up    here.     Unless I am mistaken, a call to new () will return initialized    data regardless of whether the constructor itself is private or    not.     Note that build_new does nothing to assure that any special    alignment requirements of the type are met.  Rather, it leaves    it up to malloc to do the right thing.  Otherwise, folding to    the right alignment cal cause problems if the user tries to later    free the memory returned by `new'.     PLACEMENT is the `placement' list for user-defined operator new ().  */
end_comment

begin_function
name|tree
name|build_new
parameter_list|(
name|placement
parameter_list|,
name|decl
parameter_list|,
name|init
parameter_list|,
name|use_global_new
parameter_list|)
name|tree
name|placement
decl_stmt|;
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|int
name|use_global_new
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|,
name|true_type
decl_stmt|,
name|size
decl_stmt|,
name|rval
decl_stmt|;
name|tree
name|init1
init|=
name|NULL_TREE
decl_stmt|,
name|nelts
decl_stmt|;
name|int
name|has_call
init|=
literal|0
decl_stmt|,
name|has_array
init|=
literal|0
decl_stmt|;
name|tree
name|pending_sizes
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|absdcl
init|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|last_absdcl
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|old_immediate_size_expand
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|old_immediate_size_expand
operator|=
name|immediate_size_expand
expr_stmt|;
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
block|}
name|nelts
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
name|absdcl
operator|&&
name|TREE_CODE
argument_list|(
name|absdcl
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
comment|/* probably meant to be a call */
name|has_call
operator|=
literal|1
expr_stmt|;
name|init1
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|absdcl
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
operator|=
name|absdcl
expr_stmt|;
block|}
while|while
condition|(
name|absdcl
operator|&&
name|TREE_CODE
argument_list|(
name|absdcl
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|last_absdcl
operator|=
name|absdcl
expr_stmt|;
name|absdcl
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|absdcl
operator|&&
name|TREE_CODE
argument_list|(
name|absdcl
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
comment|/* probably meant to be a vec new */
name|tree
name|this_nelts
decl_stmt|;
name|has_array
operator|=
literal|1
expr_stmt|;
name|this_nelts
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_nelts
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|this_nelts
operator|==
name|NULL_TREE
condition|)
name|error
argument_list|(
literal|"new of array type fails to specify size"
argument_list|)
expr_stmt|;
else|else
block|{
name|this_nelts
operator|=
name|save_expr
argument_list|(
name|this_nelts
argument_list|)
expr_stmt|;
name|absdcl
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_nelts
operator|==
name|integer_zero_node
condition|)
block|{
name|warning
argument_list|(
literal|"zero size array reserves no space"
argument_list|)
expr_stmt|;
name|nelts
operator|=
name|integer_zero_node
expr_stmt|;
block|}
else|else
name|nelts
operator|=
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|nelts
argument_list|,
name|this_nelts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|nelts
operator|=
name|integer_zero_node
expr_stmt|;
block|}
if|if
condition|(
name|last_absdcl
condition|)
name|TREE_OPERAND
argument_list|(
name|last_absdcl
argument_list|,
literal|0
argument_list|)
operator|=
name|absdcl
expr_stmt|;
else|else
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
operator|=
name|absdcl
expr_stmt|;
name|type
operator|=
name|true_type
operator|=
name|groktypename
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
name|type
operator|==
name|error_mark_node
operator|||
name|true_type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* ``A reference cannot be created by the new operator.  A reference 	 is not an object (8.2.2, 8.4.3), so a pointer to it could not be 	 returned by new.'' ARM 5.3.3 */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|error
argument_list|(
literal|"new cannot be applied to a reference type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"invalid type: `void []'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|pending_sizes
operator|=
name|get_pending_sizes
argument_list|()
expr_stmt|;
name|immediate_size_expand
operator|=
name|old_immediate_size_expand
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* An aggregate type.  */
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A builtin type.  */
name|decl
operator|=
name|lookup_name
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|215
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|true_type
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|true_type
operator|=
name|type
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|decl
expr_stmt|;
name|true_type
operator|=
name|type
expr_stmt|;
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
name|error
argument_list|(
literal|"invalid type for new: `void'"
argument_list|)
expr_stmt|;
else|else
name|incomplete_type_error
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|abstract_virtuals_error
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If our base type is an array, then make sure we know how many elements      it has.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|this_nelts
init|=
name|array_type_nelts_top
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|nelts
operator|==
name|integer_one_node
condition|)
block|{
name|has_array
operator|=
literal|1
expr_stmt|;
name|nelts
operator|=
name|this_nelts
expr_stmt|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|has_array
operator|!=
literal|0
argument_list|,
literal|216
argument_list|)
expr_stmt|;
name|nelts
operator|=
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|nelts
argument_list|,
name|this_nelts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_array
condition|)
name|size
operator|=
name|fold
argument_list|(
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
name|nelts
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_call
condition|)
name|init
operator|=
name|init1
expr_stmt|;
comment|/* Get to the target type of TRUE_TYPE, so we can decide whether      any constructors need to be called or not.  */
name|type
operator|=
name|true_type
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Get a little extra space to store a couple of things before the new'ed      array. */
if|if
condition|(
name|has_array
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|true_type
argument_list|)
condition|)
block|{
name|tree
name|extra
init|=
name|BI_header_size
decl_stmt|;
name|size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate the object. */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|true_type
argument_list|)
operator|&&
operator|(
name|TREE_GETS_NEW
argument_list|(
name|true_type
argument_list|)
operator|&&
operator|!
name|use_global_new
operator|)
condition|)
name|rval
operator|=
name|build_opfncall
argument_list|(
name|NEW_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|size
argument_list|,
name|placement
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|placement
condition|)
block|{
name|rval
operator|=
name|build_opfncall
argument_list|(
name|NEW_EXPR
argument_list|,
name|LOOKUP_GLOBAL
operator||
name|LOOKUP_COMPLAIN
argument_list|,
name|ptr_type_node
argument_list|,
name|size
argument_list|,
name|placement
argument_list|)
expr_stmt|;
name|rval
operator|=
name|convert
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_this_is_variable
operator|>
literal|0
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|true_type
argument_list|)
operator|&&
name|init
operator|!=
name|void_type_node
condition|)
block|{
if|if
condition|(
name|init
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"constructors take parameter lists"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
block|{
name|rval
operator|=
name|build_builtin_call
argument_list|(
name|build_pointer_type
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|BIN
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* See comment above as to why this is disabled.  */
block|if (alignment) 	{ 	  rval = build (PLUS_EXPR, TYPE_POINTER_TO (true_type), rval, 			alignment); 	  rval = build (BIT_AND_EXPR, TYPE_POINTER_TO (true_type), 			rval, build1 (BIT_NOT_EXPR, integer_type_node, 				      alignment)); 	}
endif|#
directive|endif
name|TREE_CALLS_NEW
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* if rval is NULL_TREE I don't have to allocate it, but are we totally      sure we have some extra bytes in that case for the BI_header_size      cookies? And how does that interact with the code below? (mrs) */
comment|/* Finish up some magic for new'ed arrays */
if|if
condition|(
name|has_array
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|true_type
argument_list|)
operator|&&
name|rval
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|extra
init|=
name|BI_header_size
decl_stmt|;
name|tree
name|cookie
decl_stmt|,
name|exp1
decl_stmt|,
name|exp2
decl_stmt|;
name|rval
operator|=
name|convert
argument_list|(
name|ptr_type_node
argument_list|,
name|rval
argument_list|)
expr_stmt|;
comment|/* convert to void * first */
name|rval
operator|=
name|convert
argument_list|(
name|string_type_node
argument_list|,
name|rval
argument_list|)
expr_stmt|;
comment|/* lets not add void* and ints */
name|rval
operator|=
name|save_expr
argument_list|(
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rval
argument_list|,
name|extra
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store header info.  */
name|cookie
operator|=
name|build_indirect_ref
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|BI_header_type
argument_list|)
argument_list|,
name|rval
argument_list|,
name|extra
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exp1
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build_component_ref
argument_list|(
name|cookie
argument_list|,
name|get_identifier
argument_list|(
literal|"nelts"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nelts
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|exp2
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build_component_ref
argument_list|(
name|cookie
argument_list|,
name|get_identifier
argument_list|(
literal|"ptr_2comp"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|rval
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp2
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|TREE_CALLS_NEW
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|exp1
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|exp2
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We've figured out where the allocation is to go.      If we're not eliding constructors, then if a constructor      is defined, we must go through it.  */
if|if
condition|(
operator|!
name|has_array
operator|&&
operator|(
name|rval
operator|==
name|NULL_TREE
operator|||
operator|!
name|flag_elide_constructors
operator|)
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|true_type
argument_list|)
operator|&&
name|init
operator|!=
name|void_type_node
condition|)
block|{
name|tree
name|newrval
decl_stmt|;
comment|/* Constructors are never virtual.  */
name|int
name|flags
init|=
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
decl_stmt|;
comment|/* If a copy constructor might work, set things up so that we can 	 try that after this. */
if|if
condition|(
name|rval
operator|!=
name|NULL_TREE
condition|)
name|flags
operator|=
operator|~
name|LOOKUP_COMPLAIN
operator|&
operator|(
name|flags
operator||
name|LOOKUP_SPECULATIVELY
operator|)
expr_stmt|;
if|if
condition|(
name|rval
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|true_type
argument_list|)
condition|)
block|{
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LOOKUP_HAS_IN_CHARGE
expr_stmt|;
block|}
name|newrval
operator|=
name|build_method_call
argument_list|(
name|rval
argument_list|,
name|constructor_name
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrval
condition|)
block|{
name|rval
operator|=
name|newrval
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Didn't find the constructor, maybe it is a call to a copy constructor 	 that we should implement. */
block|}
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|rval
operator|=
name|save_expr
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't call any constructors or do any initialization.  */
if|if
condition|(
name|init
operator|==
name|void_type_node
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|has_call
operator|||
name|init
operator|)
condition|)
block|{
specifier|extern
name|tree
name|static_aggregates
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* In case of static initialization, SAVE_EXPR is good enough.  */
name|init
operator|=
name|copy_to_permanent
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|rval
operator|=
name|copy_to_permanent
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|static_aggregates
operator|=
name|perm_tree_cons
argument_list|(
name|init
argument_list|,
name|rval
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Have to wrap this in RTL_EXPR for two cases: 	     in base or member initialization and if we 	     are a branch of a ?: operator.  Since we 	     can't easily know the latter, just do it always.  */
name|tree
name|xval
init|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|xval
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* As a matter of principle, `start_sequence' should do this.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_array
condition|)
name|rval
operator|=
name|expand_vec_init
argument_list|(
name|decl
argument_list|,
name|rval
argument_list|,
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|nelts
argument_list|,
name|integer_one_node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expand_aggr_init
argument_list|(
name|build_indirect_ref
argument_list|(
name|rval
argument_list|,
literal|0
argument_list|)
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|xval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CALLS_NEW
argument_list|(
name|xval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|xval
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
block|{
comment|/* Errors may cause this to not get evaluated.  */
if|if
condition|(
name|SAVE_EXPR_RTL
argument_list|(
name|rval
argument_list|)
operator|==
literal|0
condition|)
name|SAVE_EXPR_RTL
argument_list|(
name|rval
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|xval
argument_list|)
operator|=
name|SAVE_EXPR_RTL
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|VAR_DECL
argument_list|,
literal|217
argument_list|)
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|xval
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
name|rval
operator|=
name|xval
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* It would seem that the above code handles this better than the code      below. (mrs) */
block|else if (has_call || init)     {       if (IS_AGGR_TYPE (type)) 	{
comment|/*  default copy constructor may be missing from the below. (mrs) */
block|error_with_aggr_type (type, "no constructor for type `%s'"); 	  rval = error_mark_node; 	}       else 	{
comment|/* New 2.0 interpretation: `new int (10)' means 	     allocate an int, and initialize it with 10.  */
block|init = build_c_cast (type, init); 	  rval = build (COMPOUND_EXPR, TREE_TYPE (rval), 			build_modify_expr (build_indirect_ref (rval, 0), 					   NOP_EXPR, init), 			rval); 	  TREE_SIDE_EFFECTS (rval) = 1; 	}     }
endif|#
directive|endif
name|done
label|:
if|if
condition|(
name|pending_sizes
condition|)
name|rval
operator|=
name|build_compound_expr
argument_list|(
name|chainon
argument_list|(
name|pending_sizes
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_gc
condition|)
block|{
specifier|extern
name|tree
name|gc_visible
decl_stmt|;
name|tree
name|objbits
decl_stmt|;
name|tree
name|update_expr
decl_stmt|;
name|rval
operator|=
name|save_expr
argument_list|(
name|rval
argument_list|)
expr_stmt|;
comment|/* We don't need a `headof' operation to do this because 	 we know where the object starts.  */
name|objbits
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|unsigned_type_node
argument_list|,
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|rval
argument_list|,
name|c_sizeof_nowarn
argument_list|(
name|unsigned_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|update_expr
operator|=
name|build_modify_expr
argument_list|(
name|objbits
argument_list|,
name|BIT_IOR_EXPR
argument_list|,
name|gc_visible
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|update_expr
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|save_expr
argument_list|(
name|rval
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* `expand_vec_init' performs initialization of a vector of aggregate    types.     DECL is passed only for error reporting, and provides line number    and source file name information.    BASE is the space where the vector will be.    MAXINDEX is the maximum index of the array (one less than the 	    number of elements).    INIT is the (possibly NULL) initializer.     FROM_ARRAY is 0 if we should init everything with INIT    (i.e., every element initialized from INIT).    FROM_ARRAY is 1 if we should index into INIT in parallel    with initialization of DECL.    FROM_ARRAY is 2 if we should index into INIT in parallel,    but use assignment instead of initialization.  */
end_comment

begin_function
name|tree
name|expand_vec_init
parameter_list|(
name|decl
parameter_list|,
name|base
parameter_list|,
name|maxindex
parameter_list|,
name|init
parameter_list|,
name|from_array
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|base
decl_stmt|,
name|maxindex
decl_stmt|,
name|init
decl_stmt|;
name|int
name|from_array
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
name|tree
name|iterator
decl_stmt|,
name|base2
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|size
decl_stmt|;
name|maxindex
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|maxindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxindex
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|rval
operator|=
name|make_tree_vec
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|rval
argument_list|,
literal|0
argument_list|)
operator|=
name|base
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|rval
argument_list|,
literal|1
argument_list|)
operator|=
name|maxindex
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|rval
argument_list|,
literal|2
argument_list|)
operator|=
name|init
expr_stmt|;
return|return
name|rval
return|;
block|}
name|size
operator|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Set to zero in case size is<= 0.  Optimizer will delete this if      it is not needed.  */
name|rval
operator|=
name|get_temp_regvar
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|convert
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|null_pointer_node
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|default_conversion
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|convert
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|rval
argument_list|,
name|base
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base
operator|=
name|get_temp_regvar
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Initialization of array from {...}.  */
name|tree
name|elts
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
decl_stmt|;
name|tree
name|baseref
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|tree
name|baseinc
init|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|int
name|host_i
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|maxindex
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
while|while
condition|(
name|elts
condition|)
block|{
name|host_i
operator|-=
literal|1
expr_stmt|;
name|expand_aggr_init
argument_list|(
name|baseref
argument_list|,
name|TREE_VALUE
argument_list|(
name|elts
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|base
argument_list|,
name|baseinc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elts
operator|=
name|TREE_CHAIN
argument_list|(
name|elts
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize any elements by default if possible.  */
if|if
condition|(
name|host_i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|obey_regdecls
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done_init
goto|;
block|}
name|iterator
operator|=
name|get_temp_regvar
argument_list|(
name|integer_type_node
argument_list|,
name|build_int_2
argument_list|(
name|host_i
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
goto|goto
name|init_by_default
goto|;
block|}
block|}
else|else
while|while
condition|(
name|elts
condition|)
block|{
name|expand_assignment
argument_list|(
name|baseref
argument_list|,
name|TREE_VALUE
argument_list|(
name|elts
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|base
argument_list|,
name|baseinc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elts
operator|=
name|TREE_CHAIN
argument_list|(
name|elts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|obey_regdecls
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iterator
operator|=
name|get_temp_regvar
argument_list|(
name|integer_type_node
argument_list|,
name|maxindex
argument_list|)
expr_stmt|;
name|init_by_default
label|:
comment|/* If initializing one array from another, 	 initialize element by element.  */
if|if
condition|(
name|from_array
condition|)
block|{
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
operator|||
operator|(
name|init
operator|&&
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|sorry
argument_list|(
literal|"initialization of array from dissimilar array type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|init
condition|)
block|{
name|base2
operator|=
name|default_conversion
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|base2
operator|=
name|get_temp_regvar
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|base2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"initializer ends prematurely"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|expand_start_cond
argument_list|(
name|build
argument_list|(
name|GE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|iterator
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_start_loop_continue_elsewhere
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_array
condition|)
block|{
name|tree
name|to
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|tree
name|from
decl_stmt|;
if|if
condition|(
name|base2
condition|)
name|from
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base2
argument_list|)
expr_stmt|;
else|else
name|from
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|from_array
operator|==
literal|2
condition|)
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|to
argument_list|,
name|NOP_EXPR
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|expand_aggr_init
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|from
condition|)
name|expand_assignment
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|57
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|init
operator|!=
literal|0
condition|)
name|sorry
argument_list|(
literal|"cannot initialize multi-dimensional array with initializer"
argument_list|)
expr_stmt|;
name|expand_vec_init
argument_list|(
name|decl
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|base
argument_list|)
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_aggr_init
argument_list|(
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|base
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|base2
condition|)
name|expand_assignment
argument_list|(
name|base2
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|base2
argument_list|,
name|size
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_loop_continue_here
argument_list|()
expr_stmt|;
name|expand_exit_loop_if_false
argument_list|(
literal|0
argument_list|,
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build
argument_list|(
name|PREDECREMENT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|iterator
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|minus_one
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obey_regdecls
condition|)
block|{
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base2
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|base2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_end_loop
argument_list|()
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
if|if
condition|(
name|obey_regdecls
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|iterator
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|done_init
label|:
if|if
condition|(
name|obey_regdecls
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|rval
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Free up storage of type TYPE, at address ADDR.     TYPE is a POINTER_TYPE and can be ptr_type_node for no special type    of pointer.     VIRTUAL_SIZE is the ammount of storage that was allocated, and is    used as the second argument to operator delete.  It can include    things like padding and magic size cookies.  It has virtual in it,    because if you have a base pointer and you delete through a virtual    destructor, it should be the size of the dynamic object, not the    static object, see Free Store 12.5 ANSI C++ WP.     This does not call any destructors.  */
end_comment

begin_function
name|tree
name|build_x_delete
parameter_list|(
name|type
parameter_list|,
name|addr
parameter_list|,
name|use_global_delete
parameter_list|,
name|virtual_size
parameter_list|)
name|tree
name|type
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|use_global_delete
decl_stmt|;
name|tree
name|virtual_size
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
if|if
condition|(
operator|!
name|use_global_delete
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TREE_GETS_DELETE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|rval
operator|=
name|build_opfncall
argument_list|(
name|DELETE_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|addr
argument_list|,
name|virtual_size
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
name|build_builtin_call
argument_list|(
name|void_type_node
argument_list|,
name|BID
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|virtual_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Objects returned by `build_new' may point to just what the user    requested (in the case of `new X'), or they may have a cookie    consisting of a special value (the two's complement of the pointer    address) and the number of elements allocated (in the case of    `new X[N]'.  In the latter case, we need to adjust the pointer    that's passed back to the storage allocator.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_adjust_addr_for_delete
parameter_list|(
name|addr
parameter_list|)
name|tree
name|addr
decl_stmt|;
block|{
name|tree
name|cookie_addr
decl_stmt|;
name|tree
name|cookie
decl_stmt|;
name|tree
name|adjusted_addr
decl_stmt|,
name|ptr_2comp
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|cookie_addr
operator|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|BI_header_type
argument_list|)
argument_list|,
name|addr
argument_list|,
name|BI_header_size
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|build_indirect_ref
argument_list|(
name|cookie_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr_2comp
operator|=
name|build_component_ref
argument_list|(
name|cookie
argument_list|,
name|get_identifier
argument_list|(
literal|"ptr_2comp"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adjusted_addr
operator|=
name|save_expr
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|,
name|addr
argument_list|,
name|BI_header_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We must zero out the storage here because if the memory is freed,      then later reallocated, we might get a false positive when the      address is reused.  */
name|adjusted_addr
operator|=
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_modify_expr
argument_list|(
name|ptr_2comp
argument_list|,
name|NOP_EXPR
argument_list|,
name|null_pointer_node
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|adjusted_addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|,
name|build
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|addr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|convert
argument_list|(
name|ptr_type_node
argument_list|,
name|addr
argument_list|)
argument_list|,
name|ptr_2comp
argument_list|)
argument_list|)
argument_list|,
name|addr
argument_list|,
name|adjusted_addr
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Generate a call to a destructor. TYPE is the type to cast ADDR to.    ADDR is an expression which yields the store to be destroyed.    AUTO_DELETE is nonzero if a call to DELETE should be made or not.    If in the program, (AUTO_DELETE& 2) is non-zero, we tear down the    virtual baseclasses.    If in the program, (AUTO_DELETE& 1) is non-zero, then we deallocate.     FLAGS is the logical disjunction of zero or more LOOKUP_    flags.  See cp-tree.h for more info.     MAYBE_ADJUST is nonzero iff we may need to adjust the address    of the object being deleted before calling `operator delete'.    This can happen when a user allocates an array with `operator new'    and simply calls delete.  Ideally this is unnecessary, but there    is much code that does `p = new char[n]; ... delete p;' and this code    would crash otherwise.     This function does not delete an object's virtual base classes.  */
end_comment

begin_function
name|tree
name|build_delete
parameter_list|(
name|type
parameter_list|,
name|addr
parameter_list|,
name|auto_delete
parameter_list|,
name|flags
parameter_list|,
name|use_global_delete
parameter_list|,
name|maybe_adjust
parameter_list|)
name|tree
name|type
decl_stmt|,
name|addr
decl_stmt|;
name|tree
name|auto_delete
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|use_global_delete
decl_stmt|;
name|int
name|maybe_adjust
decl_stmt|;
block|{
name|tree
name|function
decl_stmt|,
name|parms
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|ref
decl_stmt|;
name|int
name|ptr
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Can happen when CURRENT_EXCEPTION_OBJECT gets its type      set to `error_mark_node' before it gets properly cleaned up.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
goto|goto
name|handle_array
goto|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|virtual_size
decl_stmt|;
comment|/* This is probably wrong. It should be the size of the virtual 	     object being deleted.  */
name|virtual_size
operator|=
name|c_sizeof_nowarn
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|maybe_adjust
condition|)
name|addr
operator|=
name|maybe_adjust_addr_for_delete
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
name|build_builtin_call
argument_list|(
name|void_type_node
argument_list|,
name|BID
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|virtual_size
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|ref
operator|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|handle_array
label|:
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
name|build_vec_delete
argument_list|(
name|addr
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|c_sizeof_nowarn
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|auto_delete
argument_list|,
name|integer_two_node
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Don't check PROTECT here; leave that decision to the 	 destructor.  If the destructor is visible, call it, 	 else report error.  */
name|addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|type
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|current_class_decl
condition|)
name|ref
operator|=
name|C_C_D
expr_stmt|;
else|else
name|ref
operator|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|220
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|virtual_size
decl_stmt|;
comment|/* This is probably wrong. It should be the size of the virtual object 	 being deleted.  */
name|virtual_size
operator|=
name|c_sizeof_nowarn
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_delete
operator|==
name|integer_zero_node
condition|)
return|return
name|void_zero_node
return|;
if|if
condition|(
name|maybe_adjust
operator|&&
name|addr
operator|!=
name|current_class_decl
condition|)
name|addr
operator|=
name|maybe_adjust_addr_for_delete
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_GETS_DELETE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|use_global_delete
condition|)
return|return
name|build_opfncall
argument_list|(
name|DELETE_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|addr
argument_list|,
name|virtual_size
argument_list|,
name|NULL_TREE
argument_list|)
return|;
return|return
name|build_builtin_call
argument_list|(
name|void_type_node
argument_list|,
name|BID
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|virtual_size
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|parms
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Below, we will reverse the order in which these calls are made.      If we have a destructor, then that destructor will take care      of the base classes; otherwise, we must do that here.  */
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|dtor
init|=
name|DECL_MAIN_VARIANT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|basetypes
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_PROTECT
condition|)
block|{
name|enum
name|visibility_type
name|visibility
init|=
name|compute_visibility
argument_list|(
name|basetypes
argument_list|,
name|dtor
argument_list|)
decl_stmt|;
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|error_with_aggr_type
argument_list|(
name|type
argument_list|,
literal|"destructor for type `%s' is private in this scope"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|visibility
operator|==
name|visibility_protected
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_PROTECTED_OK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|error_with_aggr_type
argument_list|(
name|type
argument_list|,
literal|"destructor for type `%s' is protected in this scope"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Once we are in a destructor, try not going through 	 the virtual function table to find the next destructor.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|dtor
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|auto_delete
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
operator|(
name|ptr
operator|==
literal|1
operator|||
operator|!
name|resolves_to_fixed_type_p
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
comment|/* This destructor must be called via virtual function table.  */
name|dtor
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|dtor
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr
operator|=
name|convert_pointer_to
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|dtor
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|expr
operator|=
name|fold
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ref
operator|=
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|=
name|expr
expr_stmt|;
block|}
name|function
operator|=
name|build_vfn_ref
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|ref
argument_list|,
name|DECL_VINDEX
argument_list|(
name|dtor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|dtor
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|auto_delete
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_function_call
argument_list|(
name|function
argument_list|,
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_DESTRUCTOR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Handle the case where a virtual destructor is 		 being called on an item that is 0.  		 @@ Does this really need to be done?  */
name|tree
name|ifexp
init|=
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|addr
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|if (TREE_CODE (ref) == VAR_DECL 		  || TREE_CODE (ref) == COMPONENT_REF) 		warning ("losing in build_delete");
endif|#
directive|endif
name|expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ifexp
argument_list|,
name|expr
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|ifexp
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_DESTRUCTOR
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|ARRAY_REF
condition|)
comment|/* These can't be 0.  */
name|ifexp
operator|=
name|integer_one_node
expr_stmt|;
else|else
comment|/* Handle the case where a non-virtual destructor is 	       being called on an item that is 0.  */
name|ifexp
operator|=
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|addr
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Used to mean that this destructor was known to be empty, 	     but that's now obsolete.  */
name|my_friendly_assert
argument_list|(
name|DECL_INITIAL
argument_list|(
name|dtor
argument_list|)
operator|!=
name|void_type_node
argument_list|,
literal|221
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|auto_delete
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_function_call
argument_list|(
name|dtor
argument_list|,
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifexp
operator|!=
name|integer_one_node
condition|)
name|expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ifexp
argument_list|,
name|expr
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
else|else
block|{
comment|/* This can get visibilities wrong.  */
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|base_binfo
init|=
name|n_baseclasses
operator|>
literal|0
condition|?
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
literal|0
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
name|tree
name|exprstmt
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|parent_auto_delete
init|=
name|auto_delete
decl_stmt|;
name|tree
name|cond
decl_stmt|;
comment|/* If this type does not have a destructor, but does have 	 operator delete, call the parent parent destructor (if any), 	 but let this node do the deleting.  Otherwise, it is ok 	 to let the parent destructor do the deleting.  */
if|if
condition|(
name|TREE_GETS_DELETE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|use_global_delete
condition|)
block|{
name|parent_auto_delete
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|auto_delete
operator|==
name|integer_zero_node
condition|)
name|cond
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|tree
name|virtual_size
decl_stmt|;
comment|/* This is probably wrong. It should be the size of the 		   virtual object being deleted.  */
name|virtual_size
operator|=
name|c_sizeof_nowarn
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_opfncall
argument_list|(
name|DELETE_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|addr
argument_list|,
name|virtual_size
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|auto_delete
operator|!=
name|integer_one_node
condition|)
name|cond
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|auto_delete
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|expr
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
else|else
name|cond
operator|=
name|expr
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|base_binfo
operator|==
name|NULL_TREE
operator|||
operator|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|virtual_size
decl_stmt|;
comment|/* This is probably wrong. It should be the size of the virtual 	     object being deleted.  */
name|virtual_size
operator|=
name|c_sizeof_nowarn
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cond
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|auto_delete
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|build_builtin_call
argument_list|(
name|void_type_node
argument_list|,
name|BID
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|virtual_size
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
block|}
else|else
name|cond
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|cond
condition|)
name|exprstmt
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfo
operator|&&
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|this_auto_delete
decl_stmt|;
if|if
condition|(
name|BINFO_OFFSET_ZEROP
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|this_auto_delete
operator|=
name|parent_auto_delete
expr_stmt|;
else|else
name|this_auto_delete
operator|=
name|integer_zero_node
expr_stmt|;
name|expr
operator|=
name|build_delete
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
argument_list|,
name|addr
argument_list|,
name|this_auto_delete
argument_list|,
name|flags
operator||
name|LOOKUP_PROTECTED_OK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exprstmt
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|exprstmt
argument_list|)
expr_stmt|;
block|}
comment|/* Take care of the remaining baseclasses.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|base_binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
comment|/* May be zero offset if other baseclasses are virtual.  */
name|expr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
argument_list|,
name|addr
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_delete
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|,
name|flags
operator||
name|LOOKUP_PROTECTED_OK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exprstmt
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|exprstmt
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|this_member
init|=
name|build_component_ref
argument_list|(
name|ref
argument_list|,
name|DECL_NAME
argument_list|(
name|member
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|this_type
init|=
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
decl_stmt|;
name|expr
operator|=
name|build_delete
argument_list|(
name|this_type
argument_list|,
name|this_member
argument_list|,
name|integer_two_node
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exprstmt
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|exprstmt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exprstmt
condition|)
return|return
name|build_compound_expr
argument_list|(
name|exprstmt
argument_list|)
return|;
comment|/* Virtual base classes make this function do nothing.  */
return|return
name|void_zero_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* For type TYPE, delete the virtual baseclass objects of DECL.  */
end_comment

begin_function
name|tree
name|build_vbase_delete
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|vbases
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|addr
operator|!=
name|error_mark_node
argument_list|,
literal|222
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbases
condition|)
block|{
name|tree
name|this_addr
init|=
name|convert_force
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|this_addr
argument_list|)
argument_list|,
name|this_addr
argument_list|,
name|integer_zero_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
return|return
name|build_compound_expr
argument_list|(
name|nreverse
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a C++ vector delete expression.    MAXINDEX is the number of elements to be deleted.    ELT_SIZE is the nominal size of each element in the vector.    BASE is the expression that should yield the store to be deleted.    DTOR_DUMMY is a placeholder for a destructor.  The library function    __builtin_vec_delete has a pointer to function in this position.    This function expands (or synthesizes) these calls itself.    AUTO_DELETE_VEC says whether the container (vector) should be deallocated.    AUTO_DELETE say whether each item in the container should be deallocated.     This also calls delete for virtual baseclasses of elements of the vector.     Update: MAXINDEX is no longer needed.  The size can be extracted from the    start of the vector for pointers, and from the type for arrays.  We still    use MAXINDEX for arrays because it happens to already have one of the    values we'd have to extract.  (We could use MAXINDEX with pointers to    confirm the size, and trap if the numbers differ; not clear that it'd    be worth bothering.)  */
end_comment

begin_function
name|tree
name|build_vec_delete
parameter_list|(
name|base
parameter_list|,
name|maxindex
parameter_list|,
name|elt_size
parameter_list|,
name|dtor_dummy
parameter_list|,
name|auto_delete_vec
parameter_list|,
name|auto_delete
parameter_list|)
name|tree
name|base
decl_stmt|,
name|maxindex
decl_stmt|,
name|elt_size
decl_stmt|;
name|tree
name|dtor_dummy
decl_stmt|;
name|tree
name|auto_delete_vec
decl_stmt|,
name|auto_delete
decl_stmt|;
block|{
name|tree
name|ptype
init|=
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|virtual_size
decl_stmt|;
comment|/* Temporary variables used by the loop.  */
name|tree
name|tbase
decl_stmt|,
name|size_exp
decl_stmt|,
name|tbase_init
decl_stmt|;
comment|/* This is the body of the loop that implements the deletion of a      single element, and moves temp variables to next elements.  */
name|tree
name|body
decl_stmt|;
comment|/* This is the LOOP_EXPR that governs the deletion of the elements.  */
name|tree
name|loop
decl_stmt|;
comment|/* This is the thing that governs what to do after the loop has run.  */
name|tree
name|deallocate_expr
init|=
literal|0
decl_stmt|;
comment|/* This is the BIND_EXPR which holds the outermost iterator of the      loop.  It is convenient to set this variable up and test it before      executing any other code in the loop.      This is also the containing expression returned by this function.  */
name|tree
name|controller
init|=
name|NULL_TREE
decl_stmt|;
comment|/* This is the BLOCK to record the symbol binding for debugging.  */
name|tree
name|block
decl_stmt|;
name|base
operator|=
name|stabilize_reference
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Since we can use base many times, save_epr it. */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|base
argument_list|)
condition|)
name|base
operator|=
name|save_expr
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ptype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* Step back one from start of vector, and read dimension.  */
name|tree
name|cookie_addr
init|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|BI_header_type
argument_list|)
argument_list|,
name|base
argument_list|,
name|BI_header_size
argument_list|)
decl_stmt|;
name|tree
name|cookie
init|=
name|build_indirect_ref
argument_list|(
name|cookie_addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|build_component_ref
argument_list|(
name|cookie
argument_list|,
name|get_identifier
argument_list|(
literal|"nelts"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
name|ptype
operator|=
name|TREE_TYPE
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
do|while
condition|(
name|TREE_CODE
argument_list|(
name|ptype
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ptype
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* get the total number of things in the array, maxindex is a bad name */
name|maxindex
operator|=
name|array_type_nelts_total
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|ptype
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|ptype
operator|=
name|TREE_TYPE
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
name|base
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"type to vector delete is neither pointer or array type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|ptype
expr_stmt|;
name|ptype
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|loop
operator|=
name|integer_zero_node
expr_stmt|;
goto|goto
name|no_destructor
goto|;
block|}
comment|/* The below is short by BI_header_size */
name|virtual_size
operator|=
name|fold
argument_list|(
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_exp
argument_list|,
name|maxindex
argument_list|)
argument_list|)
expr_stmt|;
name|tbase
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|tbase_init
operator|=
name|build_modify_expr
argument_list|(
name|tbase
argument_list|,
name|NOP_EXPR
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptype
argument_list|,
name|base
argument_list|,
name|virtual_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|tbase
argument_list|)
operator|=
literal|1
expr_stmt|;
name|controller
operator|=
name|build
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tbase
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|controller
argument_list|)
operator|=
literal|1
expr_stmt|;
name|block
operator|=
name|build_block
argument_list|(
name|tbase
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_block_current_level
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_delete
operator|!=
name|integer_zero_node
operator|&&
name|auto_delete
operator|!=
name|integer_two_node
condition|)
block|{
name|tree
name|base_tbd
init|=
name|convert
argument_list|(
name|ptype
argument_list|,
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|ptr_type_node
argument_list|,
name|base
argument_list|)
argument_list|,
name|BI_header_size
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* This is the real size */
name|virtual_size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|virtual_size
argument_list|,
name|BI_header_size
argument_list|)
expr_stmt|;
name|body
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_x_delete
argument_list|(
name|ptr_type_node
argument_list|,
name|base_tbd
argument_list|,
literal|0
argument_list|,
name|virtual_size
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|auto_delete
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|body
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
else|else
name|body
operator|=
name|NULL_TREE
expr_stmt|;
name|body
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_delete
argument_list|(
name|ptype
argument_list|,
name|tbase
argument_list|,
name|auto_delete
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|body
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_modify_expr
argument_list|(
name|tbase
argument_list|,
name|NOP_EXPR
argument_list|,
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptype
argument_list|,
name|tbase
argument_list|,
name|size_exp
argument_list|)
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|body
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build
argument_list|(
name|EXIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|base
argument_list|,
name|tbase
argument_list|)
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|loop
operator|=
name|build
argument_list|(
name|LOOP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build_compound_expr
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tbase_init
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|loop
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|=
name|build_compound_expr
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|no_destructor
label|:
comment|/* If the delete flag is one, or anything else with the low bit set,      delete the storage.  */
if|if
condition|(
name|auto_delete_vec
operator|==
name|integer_zero_node
operator|||
name|auto_delete_vec
operator|==
name|integer_two_node
condition|)
name|deallocate_expr
operator|=
name|integer_zero_node
expr_stmt|;
else|else
block|{
name|tree
name|base_tbd
decl_stmt|;
comment|/* The below is short by BI_header_size */
name|virtual_size
operator|=
name|fold
argument_list|(
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_exp
argument_list|,
name|maxindex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|==
name|integer_zero_node
condition|)
comment|/* no header */
name|base_tbd
operator|=
name|base
expr_stmt|;
else|else
block|{
name|base_tbd
operator|=
name|convert
argument_list|(
name|ptype
argument_list|,
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|string_type_node
argument_list|,
name|base
argument_list|)
argument_list|,
name|BI_header_size
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* True size with header. */
name|virtual_size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|virtual_size
argument_list|,
name|BI_header_size
argument_list|)
expr_stmt|;
block|}
name|deallocate_expr
operator|=
name|build_x_delete
argument_list|(
name|ptr_type_node
argument_list|,
name|base_tbd
argument_list|,
literal|1
argument_list|,
name|virtual_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_delete_vec
operator|!=
name|integer_one_node
condition|)
name|deallocate_expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|auto_delete_vec
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|deallocate_expr
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loop
operator|&&
name|deallocate_expr
operator|!=
name|integer_zero_node
condition|)
block|{
name|body
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|loop
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|deallocate_expr
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|build_compound_expr
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
else|else
name|body
operator|=
name|loop
expr_stmt|;
comment|/* Outermost wrapper: If pointer is null, punt.  */
name|body
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|base
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|body
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|controller
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|controller
argument_list|,
literal|1
argument_list|)
operator|=
name|body
expr_stmt|;
return|return
name|controller
return|;
block|}
else|else
return|return
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|body
argument_list|)
return|;
block|}
end_function

end_unit

