begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Type Analyzer for GNU C++.    Copyright (C) 1987, 1989, 1992, 1993 Free Software Foundation, Inc.    Hacked... nay, bludgeoned... by Mark Eichin (eichin@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file is the type analyzer for GNU C++.  To debug it, define SPEW_DEBUG    when compiling cp-parse.c and cp-spew.c.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-lex.h"
end_include

begin_include
include|#
directive|include
file|"cp-parse.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* This takes a token stream that hasn't decided much about types and    tries to figure out as much as it can, with excessive lookahead and    backtracking. */
end_comment

begin_comment
comment|/* fifo of tokens recognized and available to parser. */
end_comment

begin_struct
struct|struct
name|token
block|{
comment|/* The values for YYCHAR will fit in a short.  */
name|short
name|yychar
decl_stmt|;
name|short
name|end_of_file
decl_stmt|;
name|YYSTYPE
name|yylval
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|do_aggr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|token
name|frob_identifier
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|token
name|hack_scope
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|hack_ptype
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|hack_more_ids
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* From cp-lex.c: */
end_comment

begin_comment
comment|/* the declaration found for the last IDENTIFIER token read in.    yylex must look this up to detect typedefs, which get token type TYPENAME,    so it is left around in case the identifier is not a typedef but is    used in a context which makes it a reference to a variable.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|lastiddecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* let our brains leak out here too */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the lookahead symbol		*/
end_comment

begin_decl_stmt
specifier|extern
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the semantic value of the		*/
end_comment

begin_comment
comment|/*  lookahead symbol			*/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|end_of_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
name|token_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|first_token
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SPEW_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|spew_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|yylex_ctr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|debug_yychar
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|follows_typename
index|[
name|END_OF_SAVED_INPUT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|follows_identifier
index|[
name|END_OF_SAVED_INPUT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a hack!!! TEMPLATE_TYPE_SEEN_BEFORE_SCOPE consists of the name  * of the last template_type parsed in cp-parse.y if it is followed by a  * scope operator.  It will be reset inside the next invocation of yylex().  * This is used for recognizing nested types inside templates.  * - niklas@appli.se */
end_comment

begin_decl_stmt
name|tree
name|template_type_seen_before_scope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize token_obstack. Called once, from init_lex.  */
end_comment

begin_function
name|void
name|init_spew
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|chars_following_identifier
init|=
literal|".+-|/%^!?:"
decl_stmt|;
name|short
modifier|*
name|ps
decl_stmt|;
specifier|static
name|short
name|toks_follow_ids
index|[]
init|=
block|{
name|POINTSAT_LEFT_RIGHT
block|,
name|ASSIGN
block|,
name|RANGE
block|,
name|OROR
block|,
name|ANDAND
block|,
name|MIN_MAX
block|,
name|EQCOMPARE
block|,
name|ARITHCOMPARE
block|,
name|LSHIFT
block|,
name|RSHIFT
block|,
name|UNARY
block|,
name|PLUSPLUS
block|,
name|MINUSMINUS
block|,
name|POINTSAT
block|,
name|POINTSAT_STAR
block|,
name|DOT_STAR
block|,
name|CONSTANT
block|,
name|STRING
block|,
name|SIZEOF
block|,
name|ENUM
block|,
name|IF
block|,
name|ELSE
block|,
name|WHILE
block|,
name|DO
block|,
name|FOR
block|,
name|SWITCH
block|,
name|CASE
block|,
name|DEFAULT
block|,
name|BREAK
block|,
name|CONTINUE
block|,
name|RETURN
block|,
name|GOTO
block|,
name|ASM_KEYWORD
block|,
name|GCC_ASM_KEYWORD
block|,
name|TYPEOF
block|,
name|ALIGNOF
block|,
name|HEADOF
block|,
name|CLASSOF
block|,
name|ATTRIBUTE
block|,
name|AGGR
block|,
name|VISSPEC
block|,
name|DELETE
block|,
name|RAISE
block|,
name|RERAISE
block|,
name|TRY
block|,
name|EXCEPT
block|,
name|CATCH
block|,
name|THROW
block|,
name|ANSI_TRY
block|,
name|ANSI_THROW
block|,
name|EXTERN_LANG_STRING
block|,
name|ALL
block|,
name|END_OF_SAVED_INPUT
block|,
operator|-
literal|1
block|}
decl_stmt|;
specifier|static
name|short
name|toks_follow_types
index|[]
init|=
block|{
name|IDENTIFIER
block|,
name|TYPENAME
block|,
name|SCOPED_TYPENAME
block|,
name|SCSPEC
block|,
name|TYPESPEC
block|,
name|TYPE_QUAL
block|,
name|ELLIPSIS
block|,
name|THIS
block|,
name|OPERATOR
block|,
name|DYNAMIC
block|,
name|TEMPLATE
block|,
name|SCOPE
block|,
name|START_DECLARATOR
block|,
name|TYPENAME_COLON
block|,
name|PAREN_STAR_PAREN
block|,
name|TYPENAME_ELLIPSIS
block|,
name|PTYPENAME
block|,
name|PRE_PARSED_FUNCTION_DECL
block|,
name|PRE_PARSED_CLASS_DECL
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|token_obstack
argument_list|)
expr_stmt|;
comment|/* Initialize the arrays saying what tokens are definitely      (or possibly) valid following typenames and identifiers.  */
while|while
condition|(
operator|*
name|chars_following_identifier
condition|)
name|follows_identifier
index|[
operator|*
name|chars_following_identifier
operator|++
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ps
operator|=
name|toks_follow_ids
init|;
operator|*
name|ps
operator|!=
operator|-
literal|1
condition|;
name|ps
operator|++
control|)
name|follows_identifier
index|[
operator|*
name|ps
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ps
operator|=
name|toks_follow_types
init|;
operator|*
name|ps
operator|!=
operator|-
literal|1
condition|;
name|ps
operator|++
control|)
name|follows_typename
index|[
operator|*
name|ps
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SPEW_DEBUG
end_ifdef

begin_comment
comment|/* Use functions for debugging...  */
end_comment

begin_comment
comment|/* Return the number of tokens available on the fifo. */
end_comment

begin_function
specifier|static
name|int
name|num_tokens
parameter_list|()
block|{
return|return
operator|(
name|obstack_object_size
argument_list|(
operator|&
name|token_obstack
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
operator|)
operator|-
name|first_token
return|;
block|}
end_function

begin_comment
comment|/* Fetch the token N down the line from the head of the fifo. */
end_comment

begin_function
specifier|static
name|struct
name|token
modifier|*
name|nth_token
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
comment|/* could just have this do slurp_ implicitly, but this way is easier    * to debug... */
name|my_friendly_assert
argument_list|(
name|n
operator|<
name|num_tokens
argument_list|()
argument_list|,
literal|298
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|token
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|token_obstack
argument_list|)
operator|)
operator|+
name|n
operator|+
name|first_token
return|;
block|}
end_function

begin_comment
comment|/* Add a token to the token fifo. */
end_comment

begin_function
specifier|static
name|void
name|add_token
parameter_list|(
name|t
parameter_list|)
name|struct
name|token
modifier|*
name|t
decl_stmt|;
block|{
name|obstack_grow
argument_list|(
operator|&
name|token_obstack
argument_list|,
name|t
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Consume the next token out of the fifo.  */
end_comment

begin_function
specifier|static
name|void
name|consume_token
parameter_list|()
block|{
if|if
condition|(
name|num_tokens
argument_list|()
operator|==
literal|1
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|token_obstack
argument_list|,
name|obstack_base
argument_list|(
operator|&
name|token_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|first_token
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|first_token
operator|++
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ...otherwise use macros.  */
end_comment

begin_define
define|#
directive|define
name|num_tokens
parameter_list|()
define|\
value|((obstack_object_size(&token_obstack)/sizeof(struct token)) - first_token)
end_define

begin_define
define|#
directive|define
name|nth_token
parameter_list|(
name|N
parameter_list|)
define|\
value|(((struct token*)obstack_base(&token_obstack))+(N)+first_token)
end_define

begin_define
define|#
directive|define
name|add_token
parameter_list|(
name|T
parameter_list|)
value|obstack_grow(&token_obstack, (T), sizeof (struct token))
end_define

begin_define
define|#
directive|define
name|consume_token
parameter_list|()
define|\
value|(num_tokens() == 1							\    ? (obstack_free (&token_obstack, obstack_base (&token_obstack)),	\       (first_token = 0))						\    : first_token++)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Pull in enough tokens from real_yylex that the queue is N long.  */
end_comment

begin_function
specifier|static
name|void
name|scan_tokens
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|token
modifier|*
name|tmp
decl_stmt|;
comment|/* We cannot read past certain tokens, so make sure we don't.  */
name|i
operator|=
name|num_tokens
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n
condition|)
return|return;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
name|nth_token
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Never read past these characters: they might separate 	 the current input stream from one we save away later.  */
if|if
condition|(
name|tmp
operator|->
name|yychar
operator|==
literal|'{'
operator|||
name|tmp
operator|->
name|yychar
operator|==
literal|':'
condition|)
goto|goto
name|pad_tokens
goto|;
block|}
while|while
condition|(
name|num_tokens
argument_list|()
operator|<=
name|n
condition|)
block|{
name|obstack_blank
argument_list|(
operator|&
name|token_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
operator|(
expr|struct
name|token
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|token_obstack
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
name|tmp
operator|->
name|yychar
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
name|tmp
operator|->
name|end_of_file
operator|=
name|end_of_file
expr_stmt|;
name|tmp
operator|->
name|yylval
operator|=
name|yylval
expr_stmt|;
name|end_of_file
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|yychar
operator|==
literal|'{'
operator|||
name|tmp
operator|->
name|yychar
operator|==
literal|':'
operator|||
name|tmp
operator|->
name|yychar
operator|==
literal|';'
condition|)
block|{
name|pad_tokens
label|:
while|while
condition|(
name|num_tokens
argument_list|()
operator|<=
name|n
condition|)
block|{
name|obstack_blank
argument_list|(
operator|&
name|token_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
operator|(
expr|struct
name|token
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|token_obstack
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
name|tmp
operator|->
name|yychar
operator|=
name|EMPTY
expr_stmt|;
name|tmp
operator|->
name|end_of_file
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create room for N tokens at the front of the fifo.  This is used    to insert new tokens into the stream ahead of the current token.  */
end_comment

begin_function
specifier|static
name|void
name|shift_tokens
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|first_token
operator|>=
name|n
condition|)
name|first_token
operator|-=
name|n
expr_stmt|;
else|else
block|{
name|int
name|old_token_count
init|=
name|num_tokens
argument_list|()
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|token_obstack
argument_list|,
operator|(
name|n
operator|-
name|first_token
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_token_count
condition|)
block|{
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|num_tokens
argument_list|()
operator|+
operator|(
name|n
operator|-
name|first_token
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This move does not rely on the system being able to handle 	     overlapping moves.  */
name|bcopy
argument_list|(
name|nth_token
argument_list|(
literal|0
argument_list|)
argument_list|,
name|tmp
argument_list|,
name|old_token_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tmp
argument_list|,
name|nth_token
argument_list|(
name|n
argument_list|)
argument_list|,
name|old_token_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|first_token
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|probe_obstack
parameter_list|(
name|h
parameter_list|,
name|obj
parameter_list|,
name|nlevels
parameter_list|)
name|struct
name|obstack
modifier|*
name|h
decl_stmt|;
name|tree
name|obj
decl_stmt|;
name|unsigned
name|int
name|nlevels
decl_stmt|;
block|{
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|lp
decl_stmt|;
comment|/* below addr of any objects in this chunk */
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|plp
decl_stmt|;
comment|/* point to previous chunk if any */
name|lp
operator|=
operator|(
name|h
operator|)
operator|->
name|chunk
expr_stmt|;
comment|/* We use>= rather than> since the object cannot be exactly at      the beginning of the chunk but might be an empty object exactly      at the end of an adjacent chunk. */
for|for
control|(
init|;
name|nlevels
operator|!=
literal|0
operator|&&
name|lp
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|tree
operator|)
name|lp
operator|>=
name|obj
operator|||
operator|(
name|tree
operator|)
name|lp
operator|->
name|limit
operator|<
name|obj
operator|)
condition|;
name|nlevels
operator|-=
literal|1
control|)
block|{
name|plp
operator|=
name|lp
operator|->
name|prev
expr_stmt|;
name|lp
operator|=
name|plp
expr_stmt|;
block|}
return|return
name|nlevels
operator|!=
literal|0
operator|&&
name|lp
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* from cp-lex.c: */
end_comment

begin_comment
comment|/* Value is 1 if we should try to make the next identifier look like a    typename (when it may be a local variable or a class variable).    Value is 0 if we treat this name in a default fashion.    Value is -1 if we must not see a type name.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|looking_for_typename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|,
modifier|*
name|saveable_obstack
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|yylex
parameter_list|()
block|{
name|struct
name|token
name|tmp_token
decl_stmt|;
name|tree
name|trrr
decl_stmt|;
name|retry
label|:
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
block|{
name|yylex_ctr
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t## %d ##"
argument_list|,
name|yylex_ctr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* This is a kludge for recognizing nested types in templates */
if|if
condition|(
name|template_type_seen_before_scope
condition|)
block|{
name|shift_tokens
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Sync in hack_more_ids (yes, it's ugly) */
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|=
name|SCOPE
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|hack_more_ids
argument_list|(
literal|0
argument_list|,
name|template_type_seen_before_scope
argument_list|)
expr_stmt|;
name|template_type_seen_before_scope
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|yylval
operator|.
name|ttype
condition|)
block|{
comment|/* Sync back again, leaving SCOPE on the token stream, because we 	   * failed to substitute the original SCOPE token with a 	   * SCOPED_TYPENAME.  See rule "template_type" in cp-parse.y */
name|consume_token
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|yychar
operator|=
name|SCOPED_TYPENAME
expr_stmt|;
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
name|debug_yychar
argument_list|(
name|yychar
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|yychar
return|;
block|}
block|}
comment|/* if we've got tokens, send them */
if|if
condition|(
name|num_tokens
argument_list|()
condition|)
block|{
name|tmp_token
operator|=
operator|*
name|nth_token
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* TMP_TOKEN.YYLVAL.TTYPE may have been allocated on the wrong obstack. 	 If we don't find it in CURRENT_OBSTACK's current or immediately 	 previous chunk, assume it was and copy it to the current obstack.  */
if|if
condition|(
operator|(
name|tmp_token
operator|.
name|yychar
operator|==
name|CONSTANT
operator|||
name|tmp_token
operator|.
name|yychar
operator|==
name|STRING
operator|)
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
argument_list|)
operator|&&
operator|!
name|probe_obstack
argument_list|(
name|current_obstack
argument_list|,
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
argument_list|,
literal|2
argument_list|)
operator|&&
operator|!
name|probe_obstack
argument_list|(
name|saveable_obstack
argument_list|,
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
argument_list|,
literal|2
argument_list|)
condition|)
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
operator|=
name|copy_node
argument_list|(
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if not, grab the next one and think about it */
name|tmp_token
operator|.
name|yychar
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
name|tmp_token
operator|.
name|yylval
operator|=
name|yylval
expr_stmt|;
name|tmp_token
operator|.
name|end_of_file
operator|=
name|end_of_file
expr_stmt|;
name|add_token
argument_list|(
operator|&
name|tmp_token
argument_list|)
expr_stmt|;
block|}
comment|/* many tokens just need to be returned. At first glance, all we    * have to do is send them back up, but some of them are needed to    * figure out local context. */
switch|switch
condition|(
name|tmp_token
operator|.
name|yychar
condition|)
block|{
case|case
name|EMPTY
case|:
comment|/* This is a lexical no-op.  */
name|consume_token
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
name|debug_yychar
argument_list|(
name|tmp_token
operator|.
name|yychar
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|retry
goto|;
case|case
name|IDENTIFIER
case|:
comment|/* Note: this calls arbitrate_lookup.  */
name|trrr
operator|=
name|lookup_name
argument_list|(
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|trrr
condition|)
block|{
name|tmp_token
operator|.
name|yychar
operator|=
name|identifier_type
argument_list|(
name|trrr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tmp_token
operator|.
name|yychar
condition|)
block|{
case|case
name|TYPENAME
case|:
name|lastiddecl
operator|=
name|identifier_typedecl_value
argument_list|(
name|tmp_token
operator|.
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastiddecl
operator|==
name|NULL_TREE
condition|)
name|lastiddecl
operator|=
name|trrr
expr_stmt|;
break|break;
case|case
name|IDENTIFIER
case|:
name|lastiddecl
operator|=
name|trrr
expr_stmt|;
break|break;
case|case
name|PTYPENAME
case|:
comment|/* This is for cases like 		    template<class A> X<A>::operator[] ... 		 since "X" is (presumably) a PTYPENAME; we might want to 		 avoid seeing the entire thing as a type name, but X<A> 		 must be one.  		 It might not work right if the thing after the :: 		 can be a typename nested in X<A>, but I don't think the 		 PT code would be up to dealing with that anyways.  --KR  */
if|if
condition|(
name|looking_for_typename
operator|==
operator|-
literal|1
condition|)
block|{
name|scan_tokens
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|==
literal|'<'
condition|)
name|looking_for_typename
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|101
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|lastiddecl
operator|=
name|trrr
expr_stmt|;
comment|/* and fall through to... */
case|case
name|TYPENAME
case|:
case|case
name|PTYPENAME
case|:
comment|/* if (new_token) add_token (&tmp_token); */
operator|*
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|=
name|tmp_token
expr_stmt|;
name|tmp_token
operator|=
name|frob_identifier
argument_list|()
expr_stmt|;
if|if
condition|(
name|looking_for_typename
operator|<
literal|0
condition|)
block|{
name|tmp_token
operator|.
name|yychar
operator|=
name|IDENTIFIER
expr_stmt|;
name|lastiddecl
operator|=
literal|0
expr_stmt|;
name|looking_for_typename
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastiddecl
operator|&&
name|TREE_CODE
argument_list|(
name|lastiddecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|scan_tokens
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|->
name|yychar
operator|==
name|IDENTIFIER
operator|&&
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|!=
name|SCOPE
condition|)
name|looking_for_typename
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|looking_for_typename
operator|=
literal|0
expr_stmt|;
goto|goto
name|finish_typename_processing
goto|;
block|}
else|else
name|looking_for_typename
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TYPESPEC
case|:
case|case
name|SCSPEC
case|:
name|consume_token
argument_list|()
expr_stmt|;
name|finish_typename_processing
label|:
comment|/* Now see if we should insert a START_DECLARATOR token.          Here are the cases caught:  	 typespec ( * ID ) (	// ptr to function 	 typespec (& ID ) (	// ref to function 	 typespec ( * ID ) [	// array of pointers 	 typespec (& ID ) [	// array of references  	 This is a terrible kludge.  */
name|scan_tokens
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|->
name|yychar
operator|==
literal|'('
operator|&&
operator|(
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|==
literal|'*'
operator|||
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|==
literal|'&'
operator|)
condition|)
block|{
name|scan_tokens
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|nth_token
argument_list|(
literal|3
argument_list|)
operator|->
name|yychar
operator|==
literal|')'
operator|&&
operator|(
name|nth_token
argument_list|(
literal|4
argument_list|)
operator|->
name|yychar
operator|==
literal|'('
operator|||
name|nth_token
argument_list|(
literal|4
argument_list|)
operator|->
name|yychar
operator|==
literal|'['
operator|||
name|nth_token
argument_list|(
literal|4
argument_list|)
operator|->
name|yychar
operator|==
name|LEFT_RIGHT
operator|)
operator|&&
operator|(
name|nth_token
argument_list|(
literal|2
argument_list|)
operator|->
name|yychar
operator|==
name|IDENTIFIER
operator|||
name|nth_token
argument_list|(
literal|2
argument_list|)
operator|->
name|yychar
operator|==
name|TYPENAME
operator|)
condition|)
block|{
name|shift_tokens
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|->
name|yychar
operator|=
name|START_DECLARATOR
expr_stmt|;
block|}
block|}
comment|/* Extend to handle:  	 typespec (ID::* qf)(   // ptr to member function 	 typespec (ID::* qf)[   // array of ptr to member functions  	 */
if|if
condition|(
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|->
name|yychar
operator|==
literal|'('
operator|&&
operator|(
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|==
name|IDENTIFIER
operator|||
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|==
name|TYPENAME
operator|)
condition|)
block|{
name|scan_tokens
argument_list|(
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|nth_token
argument_list|(
literal|2
argument_list|)
operator|->
name|yychar
operator|==
name|SCOPE
operator|&&
name|nth_token
argument_list|(
literal|3
argument_list|)
operator|->
name|yychar
operator|==
literal|'*'
operator|&&
operator|(
name|nth_token
argument_list|(
literal|4
argument_list|)
operator|->
name|yychar
operator|==
name|IDENTIFIER
operator|||
name|nth_token
argument_list|(
literal|4
argument_list|)
operator|->
name|yychar
operator|==
name|TYPENAME
operator|)
operator|&&
name|nth_token
argument_list|(
literal|5
argument_list|)
operator|->
name|yychar
operator|==
literal|')'
operator|&&
operator|(
name|nth_token
argument_list|(
literal|6
argument_list|)
operator|->
name|yychar
operator|==
literal|'('
operator|||
name|nth_token
argument_list|(
literal|6
argument_list|)
operator|->
name|yychar
operator|==
literal|'['
operator|||
name|nth_token
argument_list|(
literal|6
argument_list|)
operator|->
name|yychar
operator|==
name|LEFT_RIGHT
operator|)
condition|)
block|{
name|shift_tokens
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|->
name|yychar
operator|=
name|START_DECLARATOR
expr_stmt|;
block|}
block|}
break|break;
if|#
directive|if
literal|0
block|case '(':
comment|/* Handle casts.  We are looking for one of:          `( TYPENAME' followed by `)', or 	 `( TYPENAME *' followed by one of `[,*,&,)', or 	 `( TYPENAME&' followed by one of `[,*,&,)', or 	 `( TYPENAME [' followed by `]'.  We are punting 	 generality on scanning casts to array types.  */
block|scan_tokens (4);       if (nth_token (1)->yychar == IDENTIFIER) 	{ 	  tree type = identifier_typedecl_value (nth_token (1)->yylval.ttype); 	  if (type) 	    switch (nth_token (2)->yychar) 	      { 	      default: 		break; 	      } 	}       break;      case SCOPE:
comment|/* if (new_token) add_token (&tmp_token); */
block|*nth_token(0) = tmp_token;       tmp_token = hack_scope ();       break;
endif|#
directive|endif
case|case
name|AGGR
case|:
operator|*
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|=
name|tmp_token
expr_stmt|;
name|do_aggr
argument_list|()
expr_stmt|;
comment|/* fall through to output... */
case|case
name|ENUM
case|:
comment|/* Set this again, in case we are rescanning.  */
name|looking_for_typename
operator|=
literal|1
expr_stmt|;
comment|/* fall through... */
default|default:
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
name|debug_yychar
argument_list|(
name|tmp_token
operator|.
name|yychar
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|consume_token
argument_list|()
expr_stmt|;
name|yylval
operator|=
name|tmp_token
operator|.
name|yylval
expr_stmt|;
name|yychar
operator|=
name|tmp_token
operator|.
name|yychar
expr_stmt|;
name|end_of_file
operator|=
name|tmp_token
operator|.
name|end_of_file
expr_stmt|;
return|return
name|tmp_token
operator|.
name|yychar
return|;
block|}
if|if
condition|(
name|tmp_token
operator|.
name|yychar
operator|==
name|SCOPED_TYPENAME
condition|)
block|{
if|#
directive|if
literal|0
block|tree t2 = resolve_scope_to_name (NULL_TREE, tmp_token.yylval.ttype);       if (t2 != NULL_TREE) 	{ 	  tmp_token.yylval.ttype = t2; 	  tmp_token.yychar = TYPENAME; 	}       else 	{
comment|/* unwind? */
block|}     }   else     {
comment|/* couldn't get here, as is... */
endif|#
directive|endif
name|tmp_token
operator|.
name|yychar
operator|=
name|TYPENAME
expr_stmt|;
block|}
name|yylval
operator|=
name|tmp_token
operator|.
name|yylval
expr_stmt|;
name|yychar
operator|=
name|tmp_token
operator|.
name|yychar
expr_stmt|;
name|end_of_file
operator|=
name|tmp_token
operator|.
name|end_of_file
expr_stmt|;
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
name|debug_yychar
argument_list|(
name|yychar
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  consume_token(); */
comment|/* already eaten by frob_identifier?... */
return|return
name|yychar
return|;
block|}
end_function

begin_comment
comment|/* token[0] == AGGR (struct/union/enum)  * thus, token[1] is either a TYPENAME or a TYPENAME_DEFN  * if token[2] == '{' or ':' then it's TYPENAME_DEFN  */
end_comment

begin_function
specifier|static
name|int
name|do_aggr
parameter_list|()
block|{
name|int
name|yc1
decl_stmt|,
name|yc2
decl_stmt|;
name|scan_tokens
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|yc1
operator|=
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
expr_stmt|;
if|if
condition|(
name|yc1
operator|!=
name|TYPENAME
operator|&&
name|yc1
operator|!=
name|IDENTIFIER
operator|&&
name|yc1
operator|!=
name|PTYPENAME
condition|)
return|return
literal|0
return|;
name|yc2
operator|=
name|nth_token
argument_list|(
literal|2
argument_list|)
operator|->
name|yychar
expr_stmt|;
if|if
condition|(
name|yc2
operator|==
literal|'{'
operator|||
name|yc2
operator|==
literal|':'
condition|)
block|{
switch|switch
condition|(
name|yc1
condition|)
block|{
case|case
name|TYPENAME
case|:
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|=
name|TYPENAME_DEFN
expr_stmt|;
break|break;
case|case
name|PTYPENAME
case|:
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|=
name|PTYPENAME_DEFN
expr_stmt|;
break|break;
case|case
name|IDENTIFIER
case|:
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|=
name|IDENTIFIER_DEFN
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|102
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|token
name|frob_identifier
parameter_list|()
block|{
comment|/* we could have a type, if it is followed by :: (if so, suck it all up); */
comment|/* we could have a ptypename; */
comment|/* we could have a normal identifier. */
name|tree
name|t1
decl_stmt|;
name|struct
name|token
name|rt
decl_stmt|;
name|scan_tokens
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rt
operator|=
operator|*
name|nth_token
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (nth_token(1)->yychar == '<')     {       t1 = hack_ptype();
comment|/* suck up the whole thing */
block|if (t1) 	{ 	  rt.yylval.ttype = t1; 	  rt.yychar = TYPENAME; 	  *nth_token(0) = rt; 	}
comment|/* else fall out bottom */
block|}
endif|#
directive|endif
if|if
condition|(
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
operator|==
name|SCOPE
condition|)
block|{
if|#
directive|if
literal|0
block|t1 = hack_more_ids(0);       if (t1&& TREE_CODE(t1) == SCOPE_REF)
else|#
directive|else
name|t1
operator|=
name|hack_more_ids
argument_list|(
literal|0
argument_list|,
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|->
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
condition|)
endif|#
directive|endif
block|{
name|rt
operator|.
name|yylval
operator|.
name|ttype
operator|=
name|t1
expr_stmt|;
name|rt
operator|.
name|yychar
operator|=
name|SCOPED_TYPENAME
expr_stmt|;
return|return
name|rt
return|;
block|}
else|else
block|{
comment|/* deal with types (enums?) in classes... */
name|struct
name|token
modifier|*
name|tok
decl_stmt|;
name|tree
name|ta
decl_stmt|,
name|tb
decl_stmt|;
name|scan_tokens
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* Have to check for a type conversion operator 	     to a nested type.  */
if|if
condition|(
name|nth_token
argument_list|(
literal|2
argument_list|)
operator|->
name|yychar
operator|==
name|OPERATOR
condition|)
name|tok
operator|=
name|nth_token
argument_list|(
literal|3
argument_list|)
expr_stmt|;
else|else
name|tok
operator|=
name|nth_token
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|->
name|yychar
operator|==
name|IDENTIFIER
operator|||
name|tok
operator|->
name|yychar
operator|==
name|TYPENAME
condition|)
block|{
name|ta
operator|=
name|build_parse_node
argument_list|(
name|SCOPE_REF
argument_list|,
name|nth_token
argument_list|(
literal|0
argument_list|)
operator|->
name|yylval
operator|.
name|ttype
argument_list|,
name|tok
operator|->
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
name|tb
operator|=
name|resolve_scope_to_name
argument_list|(
name|NULL_TREE
argument_list|,
name|ta
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|nth_token
argument_list|(
literal|2
argument_list|)
operator|->
name|yychar
operator|==
name|OPERATOR
condition|)
block|{
comment|/* Have to keep these tokens around 			 so we can finish parsing the declaration. 			 What do we do for  			 int foo::operator bar::baz ();   			 where bar is a nested class in foo?  */
name|nth_token
argument_list|(
literal|3
argument_list|)
operator|->
name|yychar
operator|=
name|TYPENAME
expr_stmt|;
name|nth_token
argument_list|(
literal|3
argument_list|)
operator|->
name|yylval
operator|.
name|ttype
operator|=
name|tb
expr_stmt|;
block|}
else|else
block|{
name|consume_token
argument_list|()
expr_stmt|;
comment|/* base type */
name|consume_token
argument_list|()
expr_stmt|;
comment|/* SCOPE */
name|consume_token
argument_list|()
expr_stmt|;
comment|/* member type */
name|rt
operator|.
name|yychar
operator|=
name|TYPENAME
expr_stmt|;
name|rt
operator|.
name|yylval
operator|.
name|ttype
operator|=
name|tb
expr_stmt|;
name|rt
operator|.
name|end_of_file
operator|=
name|tok
operator|->
name|end_of_file
expr_stmt|;
return|return
name|rt
return|;
block|}
block|}
block|}
comment|/* else fall out bottom */
block|}
block|}
name|consume_token
argument_list|()
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_comment
comment|/* When this function is called, nth_token(0) is the current    token we are scanning.  This means that the next token we'll    scan is nth_token (1).  Usually the next token we'll scan    is nth_token (0) (and the current token is in [yylval,yychar]).  */
end_comment

begin_function
name|tree
name|arbitrate_lookup
parameter_list|(
name|name
parameter_list|,
name|exp_decl
parameter_list|,
name|type_decl
parameter_list|)
name|tree
name|name
decl_stmt|,
name|exp_decl
decl_stmt|,
name|type_decl
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|scan_tokens
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|ch
operator|=
name|nth_token
argument_list|(
literal|1
argument_list|)
operator|->
name|yychar
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'('
case|:
case|case
name|LEFT_RIGHT
case|:
comment|/* If we guessed wrong here, `build_functional_cast' can fix it.  */
return|return
name|type_decl
return|;
case|case
literal|'='
case|:
if|if
condition|(
name|global_bindings_p
argument_list|()
condition|)
comment|/* Probably a default parameter.  */
return|return
name|type_decl
return|;
comment|/* Probably not an initialization.  */
return|return
name|exp_decl
return|;
case|case
literal|'['
case|:
comment|/* This needs special help because an expression inside the 	 brackets means nothing.  */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|42
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ith_yychar
decl_stmt|;
name|scan_tokens
argument_list|(
literal|3
operator|+
name|i
argument_list|)
expr_stmt|;
name|ith_yychar
operator|=
name|nth_token
argument_list|(
literal|2
operator|+
name|i
argument_list|)
operator|->
name|yychar
expr_stmt|;
comment|/* If we hit an undefined identifier, assume 	       the decl in arbitration is its type specifier.  */
if|if
condition|(
name|ith_yychar
operator|==
name|IDENTIFIER
operator|&&
name|lookup_name
argument_list|(
name|nth_token
argument_list|(
literal|2
operator|+
name|i
argument_list|)
operator|->
name|yylval
operator|.
name|ttype
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
name|type_decl
return|;
elseif|else
if|if
condition|(
name|ith_yychar
operator|==
literal|']'
condition|)
block|{
comment|/* There are only a few things we expect after a ']' 		   in a declarator.  */
name|i
operator|+=
literal|1
expr_stmt|;
name|scan_tokens
argument_list|(
literal|4
operator|+
name|i
argument_list|)
expr_stmt|;
name|ith_yychar
operator|=
name|nth_token
argument_list|(
literal|2
operator|+
name|i
argument_list|)
operator|->
name|yychar
expr_stmt|;
comment|/* These are inconclusive.  */
if|if
condition|(
name|ith_yychar
operator|==
name|LEFT_RIGHT
operator|||
name|ith_yychar
operator|==
literal|'('
operator|||
name|ith_yychar
operator|==
literal|'['
operator|||
name|ith_yychar
operator|==
literal|','
condition|)
continue|continue;
comment|/* stmt or decl?  We'll probably never know.  */
elseif|else
if|if
condition|(
name|ith_yychar
operator|==
literal|';'
condition|)
goto|goto
name|warn_ambiguous
goto|;
if|if
condition|(
name|ith_yychar
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|nth_token
argument_list|(
literal|3
operator|+
name|i
argument_list|)
operator|->
name|yychar
operator|==
literal|'{'
condition|)
return|return
name|type_decl
return|;
continue|continue;
block|}
comment|/* Whatever it is, it looks like we're processing an expr.  */
return|return
name|exp_decl
return|;
block|}
block|}
goto|goto
name|warn_ambiguous
goto|;
block|}
case|case
literal|','
case|:
case|case
literal|';'
case|:
case|case
literal|'&'
case|:
case|case
literal|'<'
case|:
case|case
literal|'*'
case|:
case|case
literal|']'
case|:
case|case
literal|')'
case|:
case|case
literal|'>'
case|:
comment|/* see if the next token looks like it wants to be part 	 of a declaration list or an expression list.  */
block|{
name|int
name|i
decl_stmt|;
comment|/* Some heuristics: if we are inside a function definition, 	   prefer the local declaration.  */
if|if
condition|(
operator|!
name|global_bindings_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|exp_decl
condition|)
return|return
name|exp_decl
return|;
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|type_decl
operator|&&
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|exp_decl
condition|)
return|return
name|exp_decl
return|;
block|}
comment|/* If these symbols follow in a list, we know it's a list of 	   expressions.  */
if|if
condition|(
name|follows_identifier
index|[
name|nth_token
argument_list|(
literal|2
argument_list|)
operator|->
name|yychar
index|]
condition|)
return|return
name|exp_decl
return|;
comment|/* If we see a id&, or id&) the we are probably in an argument list. */
if|if
condition|(
name|ch
operator|==
literal|'&'
operator|&&
operator|(
name|nth_token
argument_list|(
literal|2
argument_list|)
operator|->
name|yychar
operator|==
literal|','
operator|||
name|nth_token
argument_list|(
literal|2
argument_list|)
operator|->
name|yychar
operator|==
literal|')'
operator|)
condition|)
return|return
name|type_decl
return|;
comment|/* Look for the first identifier or other distinguishing token 	   we find in the next several tokens.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|42
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ith_yychar
decl_stmt|;
name|scan_tokens
argument_list|(
literal|3
operator|+
name|i
argument_list|)
expr_stmt|;
name|ith_yychar
operator|=
name|nth_token
argument_list|(
literal|2
operator|+
name|i
argument_list|)
operator|->
name|yychar
expr_stmt|;
if|if
condition|(
name|ith_yychar
operator|==
name|IDENTIFIER
condition|)
block|{
name|tree
name|as_type
init|=
name|lookup_name
argument_list|(
name|nth_token
argument_list|(
literal|2
operator|+
name|i
argument_list|)
operator|->
name|yylval
operator|.
name|ttype
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|as_type
operator|&&
name|TREE_CODE
argument_list|(
name|as_type
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
return|return
name|exp_decl
return|;
comment|/* An undeclared identifier or a typename means we're 		   probably looking at a typename.  */
return|return
name|type_decl
return|;
block|}
elseif|else
if|if
condition|(
name|ith_yychar
operator|==
name|EMPTY
operator|||
name|follows_identifier
index|[
name|ith_yychar
index|]
condition|)
return|return
name|exp_decl
return|;
elseif|else
if|if
condition|(
name|follows_typename
index|[
name|ith_yychar
index|]
condition|)
return|return
name|type_decl
return|;
comment|/* stmt or decl?  We'll probably never know.  */
elseif|else
if|if
condition|(
name|ith_yychar
operator|==
literal|';'
condition|)
goto|goto
name|warn_ambiguous
goto|;
block|}
goto|goto
name|warn_ambiguous
goto|;
block|}
default|default:
if|if
condition|(
name|follows_identifier
index|[
name|ch
index|]
condition|)
return|return
name|exp_decl
return|;
if|if
condition|(
name|follows_typename
index|[
name|ch
index|]
condition|)
return|return
name|type_decl
return|;
comment|/* Fall through...  */
name|warn_ambiguous
label|:
name|warning
argument_list|(
literal|"name `%s' could be type or expression; compiler assuming type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|type_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|type_decl
return|;
block|}
block|}
end_function

begin_comment
comment|/* now returns decl_node */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static tree hack_ptype() {
comment|/* when we get here, we know that [0] is a ptype and [1] is '<'.    * now we loop over simple parameters. */
end_comment

begin_comment
unit|struct token this_param;   int n = 2;   tree tplist = 0;   tree tc;   scan_tokens(n+1);      while((this_param = *nth_token(n)).yychar != '>')     {
comment|/* if it is a type, add it to the list */
end_comment

begin_comment
unit|tree thistype;            switch(this_param.yychar) 	{ 	case IDENTIFIER: 	case TYPENAME: 	case TYPESPEC: 	  break; 	default: 	  return 0; 	}        thistype = this_param.yylval.ttype;       thistype = lookup_name(thistype, 1);       thistype = TREE_TYPE (thistype);                if (tplist) 	tplist = chainon (tplist, build_tree_list (NULL_TREE, thistype));       else 	tplist = build_tree_list(NULL_TREE, thistype);
comment|/* then suck up the comma */
end_comment

begin_comment
unit|n++;       scan_tokens(n+1);       this_param = *nth_token(n);       if (this_param.yychar == ',') 	{ 	  n++; 	  scan_tokens(n+1); 	  continue; 	}       if (this_param.yychar == '>') 	break;       return 0;     }
comment|/* once we're done, lookup_template_class -> identifier */
end_comment

begin_comment
unit|tc = lookup_template_class (nth_token(0)->yylval.ttype,tplist);
comment|/* then lookup_name on that to get a type, if there is one */
end_comment

begin_comment
unit|tc = lookup_name (tc, 1);   if (tc)     {       int i;
comment|/* don't actually eat the trailing '>'... we can replace it! */
end_comment

begin_comment
unit|for (i=0; i<n; i++) 	consume_token();
comment|/*    IDENTIFIER_TYPE_VALUE (DECL_NAME (tc)) = */
end_comment

begin_endif
unit|return DECL_NAME (tc);     }   return NULL_TREE; }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static tree hack_more_ids (n)      int n; {
comment|/*    * The recursion should probably do consume_tokens(), since once we've started    * down an IDENTIFIER SCOPE ... chain, we don't need to back-track - we just    * get as much as we can, make SCOPE_REF's out of it, and return it.    */
end_comment

begin_comment
unit|struct token this_iter, this2_iter;   int tmp_y;      scan_tokens(n+1);   this_iter = *nth_token(n);    tmp_y = nth_token(n)->yychar;   if (tmp_y == IDENTIFIER || tmp_y == TYPENAME)     {       scan_tokens(n+2+2);       if (nth_token(n+1)->yychar == SCOPE) 	{ 	  if (nth_token(n+1+2)->yychar == SCOPE) 	    { 	      tree hmi; 	 	      consume_token();
comment|/* last IDENTIFIER (this_iter) */
end_comment

begin_comment
unit|consume_token();
comment|/* last SCOPE */
end_comment

begin_comment
unit|this2_iter = *nth_token(n); 	 	      hmi = hack_more_ids (n); 	 	      if (hmi) 		return build_parse_node (SCOPE_REF, this_iter.yylval.ttype, hmi); 	      consume_token();
comment|/* last IDENTIFIER (this2_iter) */
end_comment

begin_comment
unit|return build_parse_node (SCOPE_REF, this_iter.yylval.ttype, 				       this2_iter.yylval.ttype); 	    } 	  else 	    {
comment|/* consume_token();	*/
end_comment

begin_comment
comment|/* last IDENTIFIER */
end_comment

begin_comment
comment|/* leave whatever else we got */
end_comment

begin_comment
comment|/* return this_iter.yylval.ttype; */
end_comment

begin_comment
unit|return NULL_TREE; 	    } 	}     }   return NULL_TREE;
comment|/* @@ may need to backtrack */
end_comment

begin_else
unit|}
else|#
directive|else
end_else

begin_comment
comment|/* niklas@appli.se says:  I didn't understand how the code above was intended  * to work, so I rewrote it (also changed the interface a bit).  This code  * dives down an IDENTIFIER/TYPENAME SCOPE ... chain as long as the parsed  * type prefix constitutes recognizable (by resolve_scope_to_name) types.  * Interface changed like this:  * 1. Takes an extra argument containing the name of the the type recognized  *    so far.  * 2. Now returns the name of the type instead of a SCOPE_REF. */
end_comment

begin_function
specifier|static
name|tree
name|hack_more_ids
parameter_list|(
name|n
parameter_list|,
name|outer
parameter_list|)
name|int
name|n
decl_stmt|;
name|tree
name|outer
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|val
decl_stmt|;
name|scan_tokens
argument_list|(
name|n
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nth_token
argument_list|(
name|n
operator|+
literal|1
argument_list|)
operator|->
name|yychar
operator|!=
name|SCOPE
operator|||
operator|(
operator|(
name|ch
operator|=
name|nth_token
argument_list|(
name|n
operator|+
literal|2
argument_list|)
operator|->
name|yychar
operator|)
operator|!=
name|IDENTIFIER
operator|&&
name|ch
operator|!=
name|TYPENAME
operator|)
condition|)
return|return
name|NULL_TREE
return|;
name|val
operator|=
name|build_parse_node
argument_list|(
name|SCOPE_REF
argument_list|,
name|outer
argument_list|,
name|nth_token
argument_list|(
name|n
operator|+
literal|2
argument_list|)
operator|->
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
name|type
operator|=
name|resolve_scope_to_name
argument_list|(
name|NULL_TREE
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
name|consume_token
argument_list|()
expr_stmt|;
name|consume_token
argument_list|()
expr_stmt|;
name|val
operator|=
name|hack_more_ids
argument_list|(
name|n
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
name|consume_token
argument_list|()
expr_stmt|;
return|return
name|val
condition|?
name|val
else|:
name|type
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static struct token hack_scope () {
comment|/* we've got a :: - what follows is either a global var or a type. */
end_comment

begin_comment
comment|/* hmm, template names can be in the global scope too... */
end_comment

begin_comment
unit|tree t1;   struct token rt;      scan_tokens(1);   if (nth_token(1)->yychar == IDENTIFIER)     {
comment|/* @@ this is probably not right, but doesn't get hit yet */
end_comment

begin_comment
unit|t1 = build_parse_node (SCOPE_REF, 			     NULL_TREE,
comment|/* to get "global" scope */
end_comment

begin_comment
unit|hack_more_ids(0));
comment|/* do some prefetching */
end_comment

begin_comment
unit|rt.yylval.ttype = t1;       rt.yychar =
comment|/*SCOPED_*/
end_comment

begin_endif
unit|TYPENAME;       return rt;     }   else     {       rt = *nth_token(0);       consume_token();       return rt;     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Generations:  * 	  * PINST: PTYPE { saved_arg_count = arg_count($1) }  *        '<' { arg_c = 0; } PARGS '>'  *        ;  * PARG: TYPE  *       | VALUE  *       ;  * (of course the arg counting doesn't work for recursion... Do it right.)  * PARGS: PARG { assert(arg_c == saved_arg_count); }  *        | PARG ',' PARGS	{ arg_c++; }  *        ;  * ATYPE: PINST  *        | TYPEID  *        ;  * TYPE: ATYPE  *       | ATYPE { basetype = $1; } '::' TYPEKIDS  *       ;  * TYPEKIDS: TYPE { assert ($1 is a member of basetype); }  * 	  | TYPEKIDS { basetype += $1} TYPE { assert( $3 is in basetype ); }  * 	  ;  *  *  * state0: ; ATYPE  * 	TYPE '<': ac = args($0), base = CALL state1, state3	  * 	TYPE '::': base=$0, state3  * 	else return TYPE  * state1: ; begin PARGS  * 	if(ac< list length) punt  * 	PARG ",": add to list, state1  * 	PARG ">": add to list, return  * 	else unravel  * state3: ; begin TYPEKIDS  * 	TYPE:   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SPEW_DEBUG
end_ifdef

begin_comment
comment|/* debug_yychar takes a yychar (token number) value and prints its name. */
end_comment

begin_function
specifier|static
name|int
name|debug_yychar
parameter_list|(
name|yy
parameter_list|)
name|int
name|yy
decl_stmt|;
block|{
comment|/* In cp-parse.y: */
specifier|extern
name|char
modifier|*
name|debug_yytranslate
parameter_list|()
function_decl|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|yy
operator|<
literal|256
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%d: %c>\n"
argument_list|,
name|yy
argument_list|,
name|yy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%d:%s>\n"
argument_list|,
name|yy
argument_list|,
name|debug_yytranslate
argument_list|(
name|yy
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

